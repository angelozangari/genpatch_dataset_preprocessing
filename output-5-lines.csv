code,vulnerable,vulnerability,vulnerable_line,patched_line,vulnerable_code,patched_code,file_name
"    yyinit ();				/* Set up for the parse */
    if (yyparse ())			/* Parse the language tables */
	exit (1);

    strcpy (Sfile, Dfile);
",1,unused,181,unused,"    yyinit ();				/* Set up for the parse */
    if (yyparse ())			/* Parse the language tables */
	exit (1);

    strcpy (Sfile, Dfile);
",unused,CS136-lab6-buildhash.c
"    strcpy (Sfile, Dfile);
    lastdot = rindex (Sfile, '.');
    if (lastdot != NULL)
	*lastdot = '\0';
    strcat (Sfile, STATSUFFIX);
",1,unused,185,unused,"    strcpy (Sfile, Dfile);
    lastdot = rindex (Sfile, '.');
    if (lastdot != NULL)
	*lastdot = '\0';
    strcat (Sfile, STATSUFFIX);
",unused,CS136-lab6-buildhash.c
"        exit(1);
    }
    /* FLAW: Do not lock the memory */
    /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
    strcpy(password, ""Password1234!"");
",1,unused,39,unused,"        exit(1);
    }
    /* FLAW: Do not lock the memory */
    /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
    strcpy(password, ""Password1234!"");
",unused,C_Prueba_04_CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory-CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_01.c
"        printLine(""Memory could not be locked"");
        exit(1);
    }
    /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
    strcpy(password, ""Password1234!"");
",1,unused,88,unused,"        printLine(""Memory could not be locked"");
        exit(1);
    }
    /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
    strcpy(password, ""Password1234!"");
",unused,C_Prueba_04_CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory-CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_01.c
"            exit(1);
        }
        /* FLAW: Do not lock the memory */
        /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
        strcpy(password, ""Password1234!"");
",1,unused,41,unused,"            exit(1);
        }
        /* FLAW: Do not lock the memory */
        /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
        strcpy(password, ""Password1234!"");
",unused,C_Prueba_04_CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory-CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_02.c
"            printLine(""Memory could not be locked"");
            exit(1);
        }
        /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
        strcpy(password, ""Password1234!"");
",1,unused,98,unused,"            printLine(""Memory could not be locked"");
            exit(1);
        }
        /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
        strcpy(password, ""Password1234!"");
",unused,C_Prueba_04_CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory-CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_02.c
"            printLine(""Memory could not be locked"");
            exit(1);
        }
        /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
        strcpy(password, ""Password1234!"");
",1,unused,146,unused,"            printLine(""Memory could not be locked"");
            exit(1);
        }
        /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
        strcpy(password, ""Password1234!"");
",unused,C_Prueba_04_CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory-CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_02.c
"            exit(1);
        }
        /* FLAW: Do not lock the memory */
        /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
        strcpy(password, ""Password1234!"");
",1,unused,41,unused,"            exit(1);
        }
        /* FLAW: Do not lock the memory */
        /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
        strcpy(password, ""Password1234!"");
",unused,C_Prueba_04_CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory-CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_03.c
"            printLine(""Memory could not be locked"");
            exit(1);
        }
        /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
        strcpy(password, ""Password1234!"");
",1,unused,98,unused,"            printLine(""Memory could not be locked"");
            exit(1);
        }
        /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
        strcpy(password, ""Password1234!"");
",unused,C_Prueba_04_CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory-CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_03.c
"            printLine(""Memory could not be locked"");
            exit(1);
        }
        /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
        strcpy(password, ""Password1234!"");
",1,unused,146,unused,"            printLine(""Memory could not be locked"");
            exit(1);
        }
        /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
        strcpy(password, ""Password1234!"");
",unused,C_Prueba_04_CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory-CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_03.c
"            exit(1);
        }
        /* FLAW: Do not lock the memory */
        /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
        strcpy(password, ""Password1234!"");
",1,unused,48,unused,"            exit(1);
        }
        /* FLAW: Do not lock the memory */
        /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
        strcpy(password, ""Password1234!"");
",unused,C_Prueba_04_CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory-CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_04.c
"            printLine(""Memory could not be locked"");
            exit(1);
        }
        /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
        strcpy(password, ""Password1234!"");
",1,unused,105,unused,"            printLine(""Memory could not be locked"");
            exit(1);
        }
        /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
        strcpy(password, ""Password1234!"");
",unused,C_Prueba_04_CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory-CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_04.c
"            printLine(""Memory could not be locked"");
            exit(1);
        }
        /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
        strcpy(password, ""Password1234!"");
",1,unused,153,unused,"            printLine(""Memory could not be locked"");
            exit(1);
        }
        /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
        strcpy(password, ""Password1234!"");
",unused,C_Prueba_04_CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory-CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_04.c
"            exit(1);
        }
        /* FLAW: Do not lock the memory */
        /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
        strcpy(password, ""Password1234!"");
",1,unused,48,unused,"            exit(1);
        }
        /* FLAW: Do not lock the memory */
        /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
        strcpy(password, ""Password1234!"");
",unused,C_Prueba_04_CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory-CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_05.c
"            printLine(""Memory could not be locked"");
            exit(1);
        }
        /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
        strcpy(password, ""Password1234!"");
",1,unused,105,unused,"            printLine(""Memory could not be locked"");
            exit(1);
        }
        /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
        strcpy(password, ""Password1234!"");
",unused,C_Prueba_04_CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory-CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_05.c
"            printLine(""Memory could not be locked"");
            exit(1);
        }
        /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
        strcpy(password, ""Password1234!"");
",1,unused,153,unused,"            printLine(""Memory could not be locked"");
            exit(1);
        }
        /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
        strcpy(password, ""Password1234!"");
",unused,C_Prueba_04_CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory-CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_05.c
"            exit(1);
        }
        /* FLAW: Do not lock the memory */
        /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
        strcpy(password, ""Password1234!"");
",1,unused,45,unused,"            exit(1);
        }
        /* FLAW: Do not lock the memory */
        /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
        strcpy(password, ""Password1234!"");
",unused,C_Prueba_04_CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory-CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_06.c
"            printLine(""Memory could not be locked"");
            exit(1);
        }
        /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
        strcpy(password, ""Password1234!"");
",1,unused,102,unused,"            printLine(""Memory could not be locked"");
            exit(1);
        }
        /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
        strcpy(password, ""Password1234!"");
",unused,C_Prueba_04_CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory-CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_06.c
"            printLine(""Memory could not be locked"");
            exit(1);
        }
        /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
        strcpy(password, ""Password1234!"");
",1,unused,150,unused,"            printLine(""Memory could not be locked"");
            exit(1);
        }
        /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
        strcpy(password, ""Password1234!"");
",unused,C_Prueba_04_CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory-CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_06.c
"            exit(1);
        }
        /* FLAW: Do not lock the memory */
        /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
        strcpy(password, ""Password1234!"");
",1,unused,47,unused,"            exit(1);
        }
        /* FLAW: Do not lock the memory */
        /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
        strcpy(password, ""Password1234!"");
",unused,C_Prueba_04_CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory-CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_07.c
"            printLine(""Memory could not be locked"");
            exit(1);
        }
        /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
        strcpy(password, ""Password1234!"");
",1,unused,104,unused,"            printLine(""Memory could not be locked"");
            exit(1);
        }
        /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
        strcpy(password, ""Password1234!"");
",unused,C_Prueba_04_CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory-CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_07.c
"            printLine(""Memory could not be locked"");
            exit(1);
        }
        /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
        strcpy(password, ""Password1234!"");
",1,unused,152,unused,"            printLine(""Memory could not be locked"");
            exit(1);
        }
        /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
        strcpy(password, ""Password1234!"");
",unused,C_Prueba_04_CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory-CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_07.c
"            exit(1);
        }
        /* FLAW: Do not lock the memory */
        /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
        strcpy(password, ""Password1234!"");
",1,unused,41,unused,"            exit(1);
        }
        /* FLAW: Do not lock the memory */
        /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
        strcpy(password, ""Password1234!"");
",unused,C_Prueba_04_CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory-CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_09.c
"            printLine(""Memory could not be locked"");
            exit(1);
        }
        /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
        strcpy(password, ""Password1234!"");
",1,unused,98,unused,"            printLine(""Memory could not be locked"");
            exit(1);
        }
        /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
        strcpy(password, ""Password1234!"");
",unused,C_Prueba_04_CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory-CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_09.c
"            printLine(""Memory could not be locked"");
            exit(1);
        }
        /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
        strcpy(password, ""Password1234!"");
",1,unused,146,unused,"            printLine(""Memory could not be locked"");
            exit(1);
        }
        /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
        strcpy(password, ""Password1234!"");
",unused,C_Prueba_04_CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory-CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_09.c
"            exit(1);
        }
        /* FLAW: Do not lock the memory */
        /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
        strcpy(password, ""Password1234!"");
",1,unused,41,unused,"            exit(1);
        }
        /* FLAW: Do not lock the memory */
        /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
        strcpy(password, ""Password1234!"");
",unused,C_Prueba_04_CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory-CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_10.c
"            printLine(""Memory could not be locked"");
            exit(1);
        }
        /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
        strcpy(password, ""Password1234!"");
",1,unused,98,unused,"            printLine(""Memory could not be locked"");
            exit(1);
        }
        /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
        strcpy(password, ""Password1234!"");
",unused,C_Prueba_04_CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory-CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_10.c
"            printLine(""Memory could not be locked"");
            exit(1);
        }
        /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
        strcpy(password, ""Password1234!"");
",1,unused,146,unused,"            printLine(""Memory could not be locked"");
            exit(1);
        }
        /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
        strcpy(password, ""Password1234!"");
",unused,C_Prueba_04_CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory-CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_10.c
"            exit(1);
        }
        /* FLAW: Do not lock the memory */
        /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
        strcpy(password, ""Password1234!"");
",1,unused,41,unused,"            exit(1);
        }
        /* FLAW: Do not lock the memory */
        /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
        strcpy(password, ""Password1234!"");
",unused,C_Prueba_04_CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory-CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_11.c
"            printLine(""Memory could not be locked"");
            exit(1);
        }
        /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
        strcpy(password, ""Password1234!"");
",1,unused,98,unused,"            printLine(""Memory could not be locked"");
            exit(1);
        }
        /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
        strcpy(password, ""Password1234!"");
",unused,C_Prueba_04_CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory-CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_11.c
"            printLine(""Memory could not be locked"");
            exit(1);
        }
        /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
        strcpy(password, ""Password1234!"");
",1,unused,146,unused,"            printLine(""Memory could not be locked"");
            exit(1);
        }
        /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
        strcpy(password, ""Password1234!"");
",unused,C_Prueba_04_CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory-CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_11.c
"            exit(1);
        }
        /* FLAW: Do not lock the memory */
        /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
        strcpy(password, ""Password1234!"");
",1,unused,41,unused,"            exit(1);
        }
        /* FLAW: Do not lock the memory */
        /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
        strcpy(password, ""Password1234!"");
",unused,C_Prueba_04_CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory-CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_12.c
"            printLine(""Memory could not be locked"");
            exit(1);
        }
        /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
        strcpy(password, ""Password1234!"");
",1,unused,58,unused,"            printLine(""Memory could not be locked"");
            exit(1);
        }
        /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
        strcpy(password, ""Password1234!"");
",unused,C_Prueba_04_CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory-CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_12.c
"            printLine(""Memory could not be locked"");
            exit(1);
        }
        /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
        strcpy(password, ""Password1234!"");
",1,unused,111,unused,"            printLine(""Memory could not be locked"");
            exit(1);
        }
        /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
        strcpy(password, ""Password1234!"");
",unused,C_Prueba_04_CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory-CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_12.c
"            printLine(""Memory could not be locked"");
            exit(1);
        }
        /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
        strcpy(password, ""Password1234!"");
",1,unused,128,unused,"            printLine(""Memory could not be locked"");
            exit(1);
        }
        /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
        strcpy(password, ""Password1234!"");
",unused,C_Prueba_04_CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory-CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_12.c
"            exit(1);
        }
        /* FLAW: Do not lock the memory */
        /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
        strcpy(password, ""Password1234!"");
",1,unused,41,unused,"            exit(1);
        }
        /* FLAW: Do not lock the memory */
        /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
        strcpy(password, ""Password1234!"");
",unused,C_Prueba_04_CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory-CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_13.c
"            printLine(""Memory could not be locked"");
            exit(1);
        }
        /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
        strcpy(password, ""Password1234!"");
",1,unused,98,unused,"            printLine(""Memory could not be locked"");
            exit(1);
        }
        /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
        strcpy(password, ""Password1234!"");
",unused,C_Prueba_04_CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory-CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_13.c
"            printLine(""Memory could not be locked"");
            exit(1);
        }
        /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
        strcpy(password, ""Password1234!"");
",1,unused,146,unused,"            printLine(""Memory could not be locked"");
            exit(1);
        }
        /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
        strcpy(password, ""Password1234!"");
",unused,C_Prueba_04_CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory-CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_13.c
"            exit(1);
        }
        /* FLAW: Do not lock the memory */
        /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
        strcpy(password, ""Password1234!"");
",1,unused,41,unused,"            exit(1);
        }
        /* FLAW: Do not lock the memory */
        /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
        strcpy(password, ""Password1234!"");
",unused,C_Prueba_04_CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory-CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_14.c
"            printLine(""Memory could not be locked"");
            exit(1);
        }
        /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
        strcpy(password, ""Password1234!"");
",1,unused,98,unused,"            printLine(""Memory could not be locked"");
            exit(1);
        }
        /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
        strcpy(password, ""Password1234!"");
",unused,C_Prueba_04_CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory-CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_14.c
"            printLine(""Memory could not be locked"");
            exit(1);
        }
        /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
        strcpy(password, ""Password1234!"");
",1,unused,146,unused,"            printLine(""Memory could not be locked"");
            exit(1);
        }
        /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
        strcpy(password, ""Password1234!"");
",unused,C_Prueba_04_CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory-CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_14.c
"            exit(1);
        }
        /* FLAW: Do not lock the memory */
        /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
        strcpy(password, ""Password1234!"");
",1,unused,42,unused,"            exit(1);
        }
        /* FLAW: Do not lock the memory */
        /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
        strcpy(password, ""Password1234!"");
",unused,C_Prueba_04_CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory-CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_15.c
"            printLine(""Memory could not be locked"");
            exit(1);
        }
        /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
        strcpy(password, ""Password1234!"");
",1,unused,104,unused,"            printLine(""Memory could not be locked"");
            exit(1);
        }
        /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
        strcpy(password, ""Password1234!"");
",unused,C_Prueba_04_CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory-CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_15.c
"            printLine(""Memory could not be locked"");
            exit(1);
        }
        /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
        strcpy(password, ""Password1234!"");
",1,unused,154,unused,"            printLine(""Memory could not be locked"");
            exit(1);
        }
        /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
        strcpy(password, ""Password1234!"");
",unused,C_Prueba_04_CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory-CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_15.c
"            exit(1);
        }
        /* FLAW: Do not lock the memory */
        /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
        strcpy(password, ""Password1234!"");
",1,unused,41,unused,"            exit(1);
        }
        /* FLAW: Do not lock the memory */
        /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
        strcpy(password, ""Password1234!"");
",unused,C_Prueba_04_CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory-CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_16.c
"            printLine(""Memory could not be locked"");
            exit(1);
        }
        /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
        strcpy(password, ""Password1234!"");
",1,unused,94,unused,"            printLine(""Memory could not be locked"");
            exit(1);
        }
        /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
        strcpy(password, ""Password1234!"");
",unused,C_Prueba_04_CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory-CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_16.c
"            exit(1);
        }
        /* FLAW: Do not lock the memory */
        /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
        strcpy(password, ""Password1234!"");
",1,unused,42,unused,"            exit(1);
        }
        /* FLAW: Do not lock the memory */
        /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
        strcpy(password, ""Password1234!"");
",unused,C_Prueba_04_CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory-CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_17.c
"            printLine(""Memory could not be locked"");
            exit(1);
        }
        /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
        strcpy(password, ""Password1234!"");
",1,unused,95,unused,"            printLine(""Memory could not be locked"");
            exit(1);
        }
        /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
        strcpy(password, ""Password1234!"");
",unused,C_Prueba_04_CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory-CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_17.c
"        exit(1);
    }
    /* FLAW: Do not lock the memory */
    /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
    strcpy(password, ""Password1234!"");
",1,unused,41,unused,"        exit(1);
    }
    /* FLAW: Do not lock the memory */
    /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
    strcpy(password, ""Password1234!"");
",unused,C_Prueba_04_CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory-CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_18.c
"        printLine(""Memory could not be locked"");
        exit(1);
    }
    /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
    strcpy(password, ""Password1234!"");
",1,unused,92,unused,"        printLine(""Memory could not be locked"");
        exit(1);
    }
    /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
    strcpy(password, ""Password1234!"");
",unused,C_Prueba_04_CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory-CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_18.c
"            exit(1);
        }
        /* FLAW: Do not lock the memory */
        /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
        strcpy(password, ""Password1234!"");
",1,unused,39,unused,"            exit(1);
        }
        /* FLAW: Do not lock the memory */
        /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
        strcpy(password, ""Password1234!"");
",unused,C_Prueba_04_CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory-CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_22b.c
"            printLine(""Memory could not be locked"");
            exit(1);
        }
        /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
        strcpy(password, ""Password1234!"");
",1,unused,75,unused,"            printLine(""Memory could not be locked"");
            exit(1);
        }
        /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
        strcpy(password, ""Password1234!"");
",unused,C_Prueba_04_CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory-CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_22b.c
"            printLine(""Memory could not be locked"");
            exit(1);
        }
        /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
        strcpy(password, ""Password1234!"");
",1,unused,98,unused,"            printLine(""Memory could not be locked"");
            exit(1);
        }
        /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
        strcpy(password, ""Password1234!"");
",unused,C_Prueba_04_CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory-CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_22b.c
"        exit(1);
    }
    /* FLAW: Do not lock the memory */
    /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
    strcpy(password, ""Password1234!"");
",1,unused,39,unused,"        exit(1);
    }
    /* FLAW: Do not lock the memory */
    /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
    strcpy(password, ""Password1234!"");
",unused,C_Prueba_04_CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory-CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_31.c
"        printLine(""Memory could not be locked"");
        exit(1);
    }
    /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
    strcpy(password, ""Password1234!"");
",1,unused,92,unused,"        printLine(""Memory could not be locked"");
        exit(1);
    }
    /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
    strcpy(password, ""Password1234!"");
",unused,C_Prueba_04_CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory-CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_31.c
"            exit(1);
        }
        /* FLAW: Do not lock the memory */
        /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
        strcpy(password, ""Password1234!"");
",1,unused,43,unused,"            exit(1);
        }
        /* FLAW: Do not lock the memory */
        /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
        strcpy(password, ""Password1234!"");
",unused,C_Prueba_04_CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory-CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_32.c
"            printLine(""Memory could not be locked"");
            exit(1);
        }
        /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
        strcpy(password, ""Password1234!"");
",1,unused,101,unused,"            printLine(""Memory could not be locked"");
            exit(1);
        }
        /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
        strcpy(password, ""Password1234!"");
",unused,C_Prueba_04_CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory-CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_32.c
"        exit(1);
    }
    /* FLAW: Do not lock the memory */
    /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
    strcpy(password, ""Password1234!"");
",1,unused,46,unused,"        exit(1);
    }
    /* FLAW: Do not lock the memory */
    /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
    strcpy(password, ""Password1234!"");
",unused,C_Prueba_04_CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory-CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_34.c
"        printLine(""Memory could not be locked"");
        exit(1);
    }
    /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
    strcpy(password, ""Password1234!"");
",1,unused,100,unused,"        printLine(""Memory could not be locked"");
        exit(1);
    }
    /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
    strcpy(password, ""Password1234!"");
",unused,C_Prueba_04_CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory-CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_34.c
"        exit(1);
    }
    /* FLAW: Do not lock the memory */
    /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
    strcpy(password, ""Password1234!"");
",1,unused,36,unused,"        exit(1);
    }
    /* FLAW: Do not lock the memory */
    /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
    strcpy(password, ""Password1234!"");
",unused,C_Prueba_04_CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory-CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_42.c
"        printLine(""Memory could not be locked"");
        exit(1);
    }
    /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
    strcpy(password, ""Password1234!"");
",1,unused,90,unused,"        printLine(""Memory could not be locked"");
        exit(1);
    }
    /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
    strcpy(password, ""Password1234!"");
",unused,C_Prueba_04_CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory-CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_42.c
"        exit(1);
    }
    /* FLAW: Do not lock the memory */
    /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
    strcpy(password, ""Password1234!"");
",1,unused,70,unused,"        exit(1);
    }
    /* FLAW: Do not lock the memory */
    /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
    strcpy(password, ""Password1234!"");
",unused,C_Prueba_04_CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory-CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_45.c
"        printLine(""Memory could not be locked"");
        exit(1);
    }
    /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
    strcpy(password, ""Password1234!"");
",1,unused,126,unused,"        printLine(""Memory could not be locked"");
        exit(1);
    }
    /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
    strcpy(password, ""Password1234!"");
",unused,C_Prueba_04_CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory-CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_45.c
"        exit(1);
    }
    /* FLAW: Do not lock the memory */
    /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
    strcpy(password, ""Password1234!"");
",1,unused,42,unused,"        exit(1);
    }
    /* FLAW: Do not lock the memory */
    /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
    strcpy(password, ""Password1234!"");
",unused,C_Prueba_04_CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory-CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_51a.c
"        printLine(""Memory could not be locked"");
        exit(1);
    }
    /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
    strcpy(password, ""Password1234!"");
",1,unused,72,unused,"        printLine(""Memory could not be locked"");
        exit(1);
    }
    /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
    strcpy(password, ""Password1234!"");
",unused,C_Prueba_04_CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory-CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_51a.c
"        exit(1);
    }
    /* FLAW: Do not lock the memory */
    /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
    strcpy(password, ""Password1234!"");
",1,unused,42,unused,"        exit(1);
    }
    /* FLAW: Do not lock the memory */
    /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
    strcpy(password, ""Password1234!"");
",unused,C_Prueba_04_CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory-CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_52a.c
"        printLine(""Memory could not be locked"");
        exit(1);
    }
    /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
    strcpy(password, ""Password1234!"");
",1,unused,72,unused,"        printLine(""Memory could not be locked"");
        exit(1);
    }
    /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
    strcpy(password, ""Password1234!"");
",unused,C_Prueba_04_CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory-CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_52a.c
"        exit(1);
    }
    /* FLAW: Do not lock the memory */
    /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
    strcpy(password, ""Password1234!"");
",1,unused,42,unused,"        exit(1);
    }
    /* FLAW: Do not lock the memory */
    /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
    strcpy(password, ""Password1234!"");
",unused,C_Prueba_04_CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory-CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_53a.c
"        printLine(""Memory could not be locked"");
        exit(1);
    }
    /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
    strcpy(password, ""Password1234!"");
",1,unused,72,unused,"        printLine(""Memory could not be locked"");
        exit(1);
    }
    /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
    strcpy(password, ""Password1234!"");
",unused,C_Prueba_04_CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory-CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_53a.c
"        exit(1);
    }
    /* FLAW: Do not lock the memory */
    /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
    strcpy(password, ""Password1234!"");
",1,unused,42,unused,"        exit(1);
    }
    /* FLAW: Do not lock the memory */
    /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
    strcpy(password, ""Password1234!"");
",unused,C_Prueba_04_CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory-CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_54a.c
"        printLine(""Memory could not be locked"");
        exit(1);
    }
    /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
    strcpy(password, ""Password1234!"");
",1,unused,72,unused,"        printLine(""Memory could not be locked"");
        exit(1);
    }
    /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
    strcpy(password, ""Password1234!"");
",unused,C_Prueba_04_CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory-CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_54a.c
"        exit(1);
    }
    /* FLAW: Do not lock the memory */
    /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
    strcpy(password, ""Password1234!"");
",1,unused,36,unused,"        exit(1);
    }
    /* FLAW: Do not lock the memory */
    /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
    strcpy(password, ""Password1234!"");
",unused,C_Prueba_04_CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory-CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_61b.c
"        printLine(""Memory could not be locked"");
        exit(1);
    }
    /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
    strcpy(password, ""Password1234!"");
",1,unused,60,unused,"        printLine(""Memory could not be locked"");
        exit(1);
    }
    /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
    strcpy(password, ""Password1234!"");
",unused,C_Prueba_04_CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory-CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_61b.c
"        exit(1);
    }
    /* FLAW: Do not lock the memory */
    /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
    strcpy(password, ""Password1234!"");
",1,unused,42,unused,"        exit(1);
    }
    /* FLAW: Do not lock the memory */
    /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
    strcpy(password, ""Password1234!"");
",unused,C_Prueba_04_CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory-CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_63a.c
"        printLine(""Memory could not be locked"");
        exit(1);
    }
    /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
    strcpy(password, ""Password1234!"");
",1,unused,71,unused,"        printLine(""Memory could not be locked"");
        exit(1);
    }
    /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
    strcpy(password, ""Password1234!"");
",unused,C_Prueba_04_CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory-CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_63a.c
"        exit(1);
    }
    /* FLAW: Do not lock the memory */
    /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
    strcpy(password, ""Password1234!"");
",1,unused,42,unused,"        exit(1);
    }
    /* FLAW: Do not lock the memory */
    /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
    strcpy(password, ""Password1234!"");
",unused,C_Prueba_04_CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory-CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_64a.c
"        printLine(""Memory could not be locked"");
        exit(1);
    }
    /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
    strcpy(password, ""Password1234!"");
",1,unused,71,unused,"        printLine(""Memory could not be locked"");
        exit(1);
    }
    /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
    strcpy(password, ""Password1234!"");
",unused,C_Prueba_04_CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory-CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_64a.c
"        exit(1);
    }
    /* FLAW: Do not lock the memory */
    /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
    strcpy(password, ""Password1234!"");
",1,unused,44,unused,"        exit(1);
    }
    /* FLAW: Do not lock the memory */
    /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
    strcpy(password, ""Password1234!"");
",unused,C_Prueba_04_CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory-CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_65a.c
"        printLine(""Memory could not be locked"");
        exit(1);
    }
    /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
    strcpy(password, ""Password1234!"");
",1,unused,75,unused,"        printLine(""Memory could not be locked"");
        exit(1);
    }
    /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
    strcpy(password, ""Password1234!"");
",unused,C_Prueba_04_CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory-CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_65a.c
"        exit(1);
    }
    /* FLAW: Do not lock the memory */
    /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
    strcpy(password, ""Password1234!"");
",1,unused,43,unused,"        exit(1);
    }
    /* FLAW: Do not lock the memory */
    /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
    strcpy(password, ""Password1234!"");
",unused,C_Prueba_04_CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory-CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_66a.c
"        printLine(""Memory could not be locked"");
        exit(1);
    }
    /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
    strcpy(password, ""Password1234!"");
",1,unused,75,unused,"        printLine(""Memory could not be locked"");
        exit(1);
    }
    /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
    strcpy(password, ""Password1234!"");
",unused,C_Prueba_04_CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory-CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_66a.c
"        exit(1);
    }
    /* FLAW: Do not lock the memory */
    /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
    strcpy(password, ""Password1234!"");
",1,unused,48,unused,"        exit(1);
    }
    /* FLAW: Do not lock the memory */
    /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
    strcpy(password, ""Password1234!"");
",unused,C_Prueba_04_CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory-CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_67a.c
"        printLine(""Memory could not be locked"");
        exit(1);
    }
    /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
    strcpy(password, ""Password1234!"");
",1,unused,79,unused,"        printLine(""Memory could not be locked"");
        exit(1);
    }
    /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
    strcpy(password, ""Password1234!"");
",unused,C_Prueba_04_CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory-CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_67a.c
"        exit(1);
    }
    /* FLAW: Do not lock the memory */
    /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
    strcpy(password, ""Password1234!"");
",1,unused,45,unused,"        exit(1);
    }
    /* FLAW: Do not lock the memory */
    /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
    strcpy(password, ""Password1234!"");
",unused,C_Prueba_04_CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory-CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_68a.c
"        printLine(""Memory could not be locked"");
        exit(1);
    }
    /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
    strcpy(password, ""Password1234!"");
",1,unused,76,unused,"        printLine(""Memory could not be locked"");
        exit(1);
    }
    /* INCIDENTAL FLAW: CWE-259 Hardcoded Password */
    strcpy(password, ""Password1234!"");
",unused,C_Prueba_04_CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory-CWE591_Sensitive_Data_Storage_in_Improperly_Locked_Memory__w32_char_68a.c
"	
	}
	if( params->logfile == NULL){
	        char *tmp_logfilename = (char *) malloc(sizeof(char *) * (strlen(VALOR_DEFAULT_LOG_FILE)+strlen(params->outprefix)+2));
		sprintf( tmp_logfilename, ""%s/%s"", params->outprefix, VALOR_DEFAULT_LOG_FILE);
",1,unused,122,unused,"	
	}
	if( params->logfile == NULL){
	        char *tmp_logfilename = (char *) malloc(sizeof(char *) * (strlen(VALOR_DEFAULT_LOG_FILE)+strlen(params->outprefix)+2));
		sprintf( tmp_logfilename, ""%s/%s"", params->outprefix, VALOR_DEFAULT_LOG_FILE);
",unused,CharlesTaylor_valor-cmdline.c
"
				alt_read *new_alt = malloc(sizeof(alt_read));
				char * read_name = bam_get_qname(bam_alignment);
				new_alt->read_name = malloc(sizeof(char) * (strlen(read_name) + 1));
				strcpy(new_alt->read_name,read_name);
",1,unused,336,unused,"
				alt_read *new_alt = malloc(sizeof(alt_read));
				char * read_name = bam_get_qname(bam_alignment);
				new_alt->read_name = malloc(sizeof(char) * (strlen(read_name) + 1));
				strcpy(new_alt->read_name,read_name);
",unused,CharlesTaylor_valor-readbam.c
"	return statistics;
}

void sstrcpy ( void *dest, const void *source, size_t dummy){
	strcpy(dest,source);
",1,unused,133,unused,"	return statistics;
}

void sstrcpy ( void *dest, const void *source, size_t dummy){
	strcpy(dest,source);
",unused,CharlesTaylor_valor-readbam.c
"
				alt_read *new_alt = malloc(sizeof(alt_read));
				char * read_name = bam_get_qname(bam_alignment);
				new_alt->read_name = malloc(sizeof(char) * (strlen(read_name) + 1));
				strcpy(new_alt->read_name,read_name);
",1,unused,560,unused,"
				alt_read *new_alt = malloc(sizeof(alt_read));
				char * read_name = bam_get_qname(bam_alignment);
				new_alt->read_name = malloc(sizeof(char) * (strlen(read_name) + 1));
				strcpy(new_alt->read_name,read_name);
",unused,CharlesTaylor_valor-readbam.c
"
    logFile = safe_fopen(params->logfile,""w+"");                                                                    

    char *molecule_bed_path = malloc((strlen(params->outprefix) + strlen(""/molecules.bed"") + 1) * sizeof(char));
    sprintf(molecule_bed_path,""%s/molecules.bed"",params->outprefix);                                            
",1,unused,78,unused,"
    logFile = safe_fopen(params->logfile,""w+"");                                                                    

    char *molecule_bed_path = malloc((strlen(params->outprefix) + strlen(""/molecules.bed"") + 1) * sizeof(char));
    sprintf(molecule_bed_path,""%s/molecules.bed"",params->outprefix);                                            
",unused,CharlesTaylor_valor-valor.c
"

    mkdir(params->outprefix, 0755 );
    char *out_file_path = malloc((strlen(""/predicted_svs.bedpe"")+strlen(params->outprefix)+1)*sizeof(char));
    sprintf(out_file_path,""%s/predicted_svs.bedpe"",params->outprefix);
",1,unused,57,unused,"

    mkdir(params->outprefix, 0755 );
    char *out_file_path = malloc((strlen(""/predicted_svs.bedpe"")+strlen(params->outprefix)+1)*sizeof(char));
    sprintf(out_file_path,""%s/predicted_svs.bedpe"",params->outprefix);
",unused,CharlesTaylor_valor-valor.c
"        if(str == NULL){ return tokens;}
        size_t str_size = strlen(str);
        if(delimiters == NULL || delimiters[0] == 0){
                char * dummy = malloc(str_size*sizeof(char)+1);
                strcpy(dummy,str);
",1,unused,290,unused,"        if(str == NULL){ return tokens;}
        size_t str_size = strlen(str);
        if(delimiters == NULL || delimiters[0] == 0){
                char * dummy = malloc(str_size*sizeof(char)+1);
                strcpy(dummy,str);
",unused,CharlesTaylor_valor-vector.c
"    seed = 123456789;
    n = 10000;
    if ( dim_num == 2 )
    {
      strcpy ( output_filename, ""bad_in_triangle.txt"" );
",1,unused,169,unused,"    seed = 123456789;
    n = 10000;
    if ( dim_num == 2 )
    {
      strcpy ( output_filename, ""bad_in_triangle.txt"" );
",unused,CodigoSuministrado-random_data_prb.c
"      strcpy ( output_filename, ""bad_in_triangle.txt"" );
    }
    else if ( dim_num == 3 )
    {
      strcpy ( output_filename, ""bad_in_tetrahedron.txt"" );
",1,unused,173,unused,"      strcpy ( output_filename, ""bad_in_triangle.txt"" );
    }
    else if ( dim_num == 3 )
    {
      strcpy ( output_filename, ""bad_in_tetrahedron.txt"" );
",unused,CodigoSuministrado-random_data_prb.c
"
void start_awk() {
    char* prefix = ""awk \'BEGIN{ FS=\""\\x1F\""; RS=\""\\x1E\"" } "";
    char* command = calloc(strlen(prefix) + strlen(config.script) + 2, sizeof(char));
    sprintf(command, ""%s %s\'"", prefix, config.script);
",1,unused,297,unused,"
void start_awk() {
    char* prefix = ""awk \'BEGIN{ FS=\""\\x1F\""; RS=\""\\x1E\"" } "";
    char* command = calloc(strlen(prefix) + strlen(config.script) + 2, sizeof(char));
    sprintf(command, ""%s %s\'"", prefix, config.script);
",unused,DavyLandman_csvtools-src2Fcsvawk.c
"    }
    else if (preconfig.kind == KEEP_INDEXES || preconfig.kind == DROP_INDEXES) {
        for (int c = 0; c < config.column_count; c++) {
            char str_index[15];
            int str_length = sprintf(str_index, ""%d"", c);
",1,unused,308,unused,"    }
    else if (preconfig.kind == KEEP_INDEXES || preconfig.kind == DROP_INDEXES) {
        for (int c = 0; c < config.column_count; c++) {
            char str_index[15];
            int str_length = sprintf(str_index, ""%d"", c);
",unused,DavyLandman_csvtools-src2Fcsvcut.c
"      dvr_config_t *cfg = dvr_config_find_by_list(perm->aa_dvrcfgs, config_uuid);
      if (cfg) {
        title = epg_broadcast_get_title(e, NULL);
        comment = alloca(strlen(title) + strlen(msg) + 1);
        sprintf(comment, ""%s%s"", title, msg);
",1,unused,491,unused,"      dvr_config_t *cfg = dvr_config_find_by_list(perm->aa_dvrcfgs, config_uuid);
      if (cfg) {
        title = epg_broadcast_get_title(e, NULL);
        comment = alloca(strlen(title) + strlen(msg) + 1);
        sprintf(comment, ""%s%s"", title, msg);
",unused,Flole998_tvheadend-src2Fapi2Fapi_dvr.c
"       *  matches titles containing ""self"".
       */
      title_esc = regexp_escape(title);
      title_anchor = alloca(strlen(title_esc) + 3);
      sprintf(title_anchor, ""^%s$"", title_esc);
",1,unused,658,unused,"       *  matches titles containing ""self"".
       */
      title_esc = regexp_escape(title);
      title_anchor = alloca(strlen(title_esc) + 3);
      sprintf(title_anchor, ""^%s$"", title_esc);
",unused,Flole998_tvheadend-src2Fapi2Fapi_epg.c
"
  /* Check each cutlist extension */
  for (i = 0; i < ARRAY_SIZE(dvr_cutpoint_parsers); i++) {

    strcpy(path, s);
",1,unused,292,unused,"
  /* Check each cutlist extension */
  for (i = 0; i < ARRAY_SIZE(dvr_cutpoint_parsers); i++) {

    strcpy(path, s);
",unused,Flole998_tvheadend-src2Fdvr2Fdvr_cutpoints.c
"    strcpy(path, s);
    if ((dot = (strrchr(path, '.') + 1)))
      *dot = 0;

    strcat(path, dvr_cutpoint_parsers[i].ext);
",1,unused,296,unused,"    strcpy(path, s);
    if ((dot = (strrchr(path, '.') + 1)))
      *dot = 0;

    strcat(path, dvr_cutpoint_parsers[i].ext);
",unused,Flole998_tvheadend-src2Fdvr2Fdvr_cutpoints.c
"      cookie_prev = 0;
    }
    // if unmatched ""from"", save in case matching ""to"" is coming in next read
    if (from) {
      strcpy(from_prev, from);
",1,unused,445,unused,"      cookie_prev = 0;
    }
    // if unmatched ""from"", save in case matching ""to"" is coming in next read
    if (from) {
      strcpy(from_prev, from);
",unused,Flole998_tvheadend-src2Fdvr2Fdvr_inotify.c
"    return NULL;
  TAILQ_INSERT_TAIL(&msg->hm_fields, f, hmf_link);

  if (name)
    strcpy((char *)f->_hmf_name, name);
",1,unused,141,unused,"    return NULL;
  TAILQ_INSERT_TAIL(&msg->hm_fields, f, hmf_link);

  if (name)
    strcpy((char *)f->_hmf_name, name);
",unused,Flole998_tvheadend-src2Fhtsmsg.c
"
static void
satip_rtsp_add_ival(const char *name, char *buf, uint32_t val)
{
  sprintf(buf + strlen(buf), ""&%s=%i"", name, val);
",1,unused,72,unused,"
static void
satip_rtsp_add_ival(const char *name, char *buf, uint32_t val)
{
  sprintf(buf + strlen(buf), ""&%s=%i"", name, val);
",unused,Flole998_tvheadend-src2Finput2Fmpegts2Fsatip2Fsatip_rtsp.c
"    // for sat>ip compliance
    if (flags & SATIP_SETUP_SPECINV0)
      strcat(buf, ""&specinv=0"");
    else if (flags & SATIP_SETUP_SPECINV1)
      strcat(buf, ""&specinv=1"");
",1,unused,225,unused,"    // for sat>ip compliance
    if (flags & SATIP_SETUP_SPECINV0)
      strcat(buf, ""&specinv=0"");
    else if (flags & SATIP_SETUP_SPECINV1)
      strcat(buf, ""&specinv=1"");
",unused,Flole998_tvheadend-src2Finput2Fmpegts2Fsatip2Fsatip_rtsp.c
"      ADD(u.dmc_fe_qam.fec_inner,   fec,   ""auto"");

    // for sat>ip compliance
    if (flags & SATIP_SETUP_SPECINV0)
      strcat(buf, ""&specinv=0"");
",1,unused,223,unused,"      ADD(u.dmc_fe_qam.fec_inner,   fec,   ""auto"");

    // for sat>ip compliance
    if (flags & SATIP_SETUP_SPECINV0)
      strcat(buf, ""&specinv=0"");
",unused,Flole998_tvheadend-src2Finput2Fmpegts2Fsatip2Fsatip_rtsp.c
"  if (strcmp((char *)ttm->ttm_last_sub_text, (char *)sub) == 0)
    return 0;

  ttm->ttm_last_sub_pts = pts;
  strcpy((char *)ttm->ttm_last_sub_text, (char *)sub);
",1,unused,793,unused,"  if (strcmp((char *)ttm->ttm_last_sub_text, (char *)sub) == 0)
    return 0;

  ttm->ttm_last_sub_pts = pts;
  strcpy((char *)ttm->ttm_last_sub_text, (char *)sub);
",unused,Flole998_tvheadend-src2Fparsers2Fparser_teletext.c
"                      (0x10000 <= l && l <= 0x10FFFF))
                    {
                      gchar buf[8];
                      char_str (l, buf);
                      strcpy (to, buf);
",1,unused,384,unused,"                      (0x10000 <= l && l <= 0x10FFFF))
                    {
                      gchar buf[8];
                      char_str (l, buf);
                      strcpy (to, buf);
",unused,GimpMaster-gimp2Fapp2Fcore2Fgimp-utils.c
"      g_snprintf (statusbar->cursor_format_str,
                  sizeof (statusbar->cursor_format_str),
                  ""%%s%%.%df%%s%%.%df%%s"",
                  w_digits, h_digits);
      strcpy (statusbar->cursor_format_str_f, statusbar->cursor_format_str);
",1,unused,1371,unused,"      g_snprintf (statusbar->cursor_format_str,
                  sizeof (statusbar->cursor_format_str),
                  ""%%s%%.%df%%s%%.%df%%s"",
                  w_digits, h_digits);
      strcpy (statusbar->cursor_format_str_f, statusbar->cursor_format_str);
",unused,GimpMaster-gimp2Fapp2Fdisplay2Fgimpstatusbar.c
"    {
      switch (*fields[i])
        {
        case 'i':
          strcpy (buffers[i], ""italic"");
",1,unused,101,unused,"    {
      switch (*fields[i])
        {
        case 'i':
          strcpy (buffers[i], ""italic"");
",unused,GimpMaster-gimp2Fapp2Ftext2Fgimptext-xlfd.c
"          strcpy (buffers[i], ""italic"");
          i++;
          break;
        case 'o':
          strcpy (buffers[i], ""oblique"");
",1,unused,105,unused,"          strcpy (buffers[i], ""italic"");
          i++;
          break;
        case 'o':
          strcpy (buffers[i], ""oblique"");
",unused,GimpMaster-gimp2Fapp2Ftext2Fgimptext-xlfd.c
"  len = strlen (extension);

  pattern = g_new (gchar, 4 + 4 * len);

  strcpy (pattern, ""*."");
",1,unused,451,unused,"  len = strlen (extension);

  pattern = g_new (gchar, 4 + 4 * len);

  strcpy (pattern, ""*."");
",unused,GimpMaster-gimp2Fapp2Fwidgets2Fgimpfileprocview.c
"
  /* write out the tag information for the image */
  if (info->file_version > 0)
    {
      sprintf (version_tag, ""gimp xcf v%03d"", info->file_version);
",1,unused,240,unused,"
  /* write out the tag information for the image */
  if (info->file_version > 0)
    {
      sprintf (version_tag, ""gimp xcf v%03d"", info->file_version);
",unused,GimpMaster-gimp2Fapp2Fxcf2Fxcf-save.c
"      sprintf (version_tag, ""gimp xcf v%03d"", info->file_version);
    }
  else
    {
      strcpy (version_tag, ""gimp xcf file"");
",1,unused,244,unused,"      sprintf (version_tag, ""gimp xcf v%03d"", info->file_version);
    }
  else
    {
      strcpy (version_tag, ""gimp xcf file"");
",unused,GimpMaster-gimp2Fapp2Fxcf2Fxcf-save.c
"
  /* Update new Instance ID */
  uuid = gimp_metadata_get_guid ();

  strcpy (iid_data, ""xmp.iid:"");
",1,unused,312,unused,"
  /* Update new Instance ID */
  uuid = gimp_metadata_get_guid ();

  strcpy (iid_data, ""xmp.iid:"");
",unused,GimpMaster-gimp2Flibgimpbase2Fgimpmetadata.c
"  /* Update new Instance ID */
  uuid = gimp_metadata_get_guid ();

  strcpy (iid_data, ""xmp.iid:"");
  strcat (iid_data, uuid);
",1,unused,313,unused,"  /* Update new Instance ID */
  uuid = gimp_metadata_get_guid ();

  strcpy (iid_data, ""xmp.iid:"");
  strcat (iid_data, uuid);
",unused,GimpMaster-gimp2Flibgimpbase2Fgimpmetadata.c
"      gchar did_data[256];

      uuid = gimp_metadata_get_guid ();

      strcpy (did_data, ""gimp:docid:gimp:"");
",1,unused,328,unused,"      gchar did_data[256];

      uuid = gimp_metadata_get_guid ();

      strcpy (did_data, ""gimp:docid:gimp:"");
",unused,GimpMaster-gimp2Flibgimpbase2Fgimpmetadata.c
"
      uuid = gimp_metadata_get_guid ();

      strcpy (did_data, ""gimp:docid:gimp:"");
      strcat (did_data, uuid);
",1,unused,329,unused,"
      uuid = gimp_metadata_get_guid ();

      strcpy (did_data, ""gimp:docid:gimp:"");
      strcat (did_data, uuid);
",unused,GimpMaster-gimp2Flibgimpbase2Fgimpmetadata.c
"    {
      gchar  did_data[256];
      gchar *uuid = gimp_metadata_get_guid ();

      strcpy (did_data, ""xmp.did:"");
",1,unused,344,unused,"    {
      gchar  did_data[256];
      gchar *uuid = gimp_metadata_get_guid ();

      strcpy (did_data, ""xmp.did:"");
",unused,GimpMaster-gimp2Flibgimpbase2Fgimpmetadata.c
"      gchar  did_data[256];
      gchar *uuid = gimp_metadata_get_guid ();

      strcpy (did_data, ""xmp.did:"");
      strcat (did_data, uuid);
",1,unused,345,unused,"      gchar  did_data[256];
      gchar *uuid = gimp_metadata_get_guid ();

      strcpy (did_data, ""xmp.did:"");
      strcat (did_data, uuid);
",unused,GimpMaster-gimp2Flibgimpbase2Fgimpmetadata.c
"
  g_snprintf (tagstr, sizeof (tagstr), ""%s[%d]%s"",
              tags[3], id_count, history_tags[4]);

  strcpy (strdata, ""/"");
",1,unused,457,unused,"
  g_snprintf (tagstr, sizeof (tagstr), ""%s[%d]%s"",
              tags[3], id_count, history_tags[4]);

  strcpy (strdata, ""/"");
",unused,GimpMaster-gimp2Flibgimpbase2Fgimpmetadata.c
"  g_snprintf (tagstr, sizeof (tagstr), ""%s[%d]%s"",
              tags[3], id_count, history_tags[4]);

  strcpy (strdata, ""/"");
  strcat (strdata, state_status);
",1,unused,458,unused,"  g_snprintf (tagstr, sizeof (tagstr), ""%s[%d]%s"",
              tags[3], id_count, history_tags[4]);

  strcpy (strdata, ""/"");
  strcat (strdata, state_status);
",unused,GimpMaster-gimp2Flibgimpbase2Fgimpmetadata.c
"
  if (isatty(0) && isatty(1))
    fgets (buf, 8, stdin);
  else
    strcpy (buf, ""E\n"");
",1,unused,1456,unused,"
  if (isatty(0) && isatty(1))
    fgets (buf, 8, stdin);
  else
    strcpy (buf, ""E\n"");
",unused,GimpMaster-gimp2Flibgimpbase2Fgimputils.c
"    {
      if (*p == '~' && home)
        {
          *n = '\0';
          strcat (n, home);
",1,unused,622,unused,"    {
      if (*p == '~' && home)
        {
          *n = '\0';
          strcat (n, home);
",unused,GimpMaster-gimp2Flibgimpconfig2Fgimpconfig-path.c
"                {
                  s = substs[2*i+1];

                  *n = '\0';
                  strcat (n, s);
",1,unused,635,unused,"                {
                  s = substs[2*i+1];

                  *n = '\0';
                  strcat (n, s);
",unused,GimpMaster-gimp2Flibgimpconfig2Fgimpconfig-path.c
"      gchar *p;

      p = strstr (short_format, ""%s"");
      if (p)
        strcpy (p, ""%a"");
",1,unused,418,unused,"      gchar *p;

      p = strstr (short_format, ""%s"");
      if (p)
        strcpy (p, ""%a"");
",unused,GimpMaster-gimp2Flibgimpwidgets2Fgimpsizeentry.c
"        strcpy (p, ""%a"");

      p = strstr (short_format, ""%p"");
      if (p)
        strcpy (p, ""%a"");
",1,unused,422,unused,"        strcpy (p, ""%a"");

      p = strstr (short_format, ""%p"");
      if (p)
        strcpy (p, ""%a"");
",unused,GimpMaster-gimp2Flibgimpwidgets2Fgimpsizeentry.c
"  }

  /* Format the message into the passed buffer */
  if (isstring)
    sprintf(buffer, msgtext, err->msg_parm.s);
",1,unused,169,unused,"  }

  /* Format the message into the passed buffer */
  if (isstring)
    sprintf(buffer, msgtext, err->msg_parm.s);
",unused,MiBench-consumer-jpeg-jerror.c
"  /* Format the message into the passed buffer */
  if (isstring)
    sprintf(buffer, msgtext, err->msg_parm.s);
  else
    sprintf(buffer, msgtext,
",1,unused,171,unused,"  /* Format the message into the passed buffer */
  if (isstring)
    sprintf(buffer, msgtext, err->msg_parm.s);
  else
    sprintf(buffer, msgtext,
",unused,MiBench-consumer-jpeg-jerror.c
"      if (comment_arg[0] == '""') {
	comment_arg = (char *) malloc((size_t) MAX_COM_LENGTH);
	if (comment_arg == NULL)
	  ERREXIT(""Insufficient memory"");
	strcpy(comment_arg, argv[argn]+1);
",1,unused,448,unused,"      if (comment_arg[0] == '""') {
	comment_arg = (char *) malloc((size_t) MAX_COM_LENGTH);
	if (comment_arg == NULL)
	  ERREXIT(""Insufficient memory"");
	strcpy(comment_arg, argv[argn]+1);
",unused,MiBench-consumer-jpeg-wrjpgcom.c
"	    break;
	  }
	  if (++argn >= argc)
	    ERREXIT(""Missing ending quote mark"");
	  strcat(comment_arg, "" "");
",1,unused,457,unused,"	    break;
	  }
	  if (++argn >= argc)
	    ERREXIT(""Missing ending quote mark"");
	  strcat(comment_arg, "" "");
",unused,MiBench-consumer-jpeg-wrjpgcom.c
"	  }
	  if (++argn >= argc)
	    ERREXIT(""Missing ending quote mark"");
	  strcat(comment_arg, "" "");
	  strcat(comment_arg, argv[argn]);
",1,unused,458,unused,"	  }
	  if (++argn >= argc)
	    ERREXIT(""Missing ending quote mark"");
	  strcat(comment_arg, "" "");
	  strcat(comment_arg, argv[argn]);
",unused,MiBench-consumer-jpeg-wrjpgcom.c
"  if( loc == (char *) NULL )
  { Error(1, 6, ""unable to initialize locale"", WARN, no_fpos);
    loc = ""C"";
  }
  sprintf(catname, ""%s/%s/%s/LC_MESSAGES/errors.%s"",
",1,unused,227,unused,"  if( loc == (char *) NULL )
  { Error(1, 6, ""unable to initialize locale"", WARN, no_fpos);
    loc = ""C"";
  }
  sprintf(catname, ""%s/%s/%s/LC_MESSAGES/errors.%s"",
",unused,MiBench-consumer-typeset-z01.c
"    }
    if( i < MAX_COMPRESSED )
    { char buff[MAX_BUFF];
      fclose(fp);
      sprintf(buff, UNCOMPRESS_COM, (char *) string(*full_name), LOUT_EPS);
",1,unused,838,unused,"    }
    if( i < MAX_COMPRESSED )
    { char buff[MAX_BUFF];
      fclose(fp);
      sprintf(buff, UNCOMPRESS_COM, (char *) string(*full_name), LOUT_EPS);
",unused,MiBench-consumer-typeset-z03.c
"    case CURR_ZUNIT:

      { FULL_CHAR buff[20];
        if( type(x) == CURR_YUNIT )
          sprintf( (char *) buff, ""%dp"", yunit(*style) / PT);
",1,unused,1637,unused,"    case CURR_ZUNIT:

      { FULL_CHAR buff[20];
        if( type(x) == CURR_YUNIT )
          sprintf( (char *) buff, ""%dp"", yunit(*style) / PT);
",unused,MiBench-consumer-typeset-z08.c
"      { FULL_CHAR buff[20];
        if( type(x) == CURR_YUNIT )
          sprintf( (char *) buff, ""%dp"", yunit(*style) / PT);
        else
	  sprintf( (char *) buff, ""%dp"", zunit(*style) / PT);
",1,unused,1639,unused,"      { FULL_CHAR buff[20];
        if( type(x) == CURR_YUNIT )
          sprintf( (char *) buff, ""%dp"", yunit(*style) / PT);
        else
	  sprintf( (char *) buff, ""%dp"", zunit(*style) / PT);
",unused,MiBench-consumer-typeset-z08.c
"      if( is_word(type(y)) && sscanf( (char *) string(y), ""%d"", &num1) == 1 &&
          is_word(type(z)) && sscanf( (char *) string(z), ""%d"", &num2) == 1 )
      {
	FULL_CHAR buff[MAX_BUFF];
	sprintf( (char *) buff, ""%d"", type(x) == PLUS ? num1+num2 : num1-num2);
",1,unused,1936,unused,"      if( is_word(type(y)) && sscanf( (char *) string(y), ""%d"", &num1) == 1 &&
          is_word(type(z)) && sscanf( (char *) string(z), ""%d"", &num2) == 1 )
      {
	FULL_CHAR buff[MAX_BUFF];
	sprintf( (char *) buff, ""%d"", type(x) == PLUS ? num1+num2 : num1-num2);
",unused,MiBench-consumer-typeset-z08.c
"  ifdebug(DCR, DDD, crtab_debug(crossref_tab, stderr));
  if( StringLength(file_name) + 20 >= MAX_BUFF )
    Error(10, 3, ""automatically generated tag is too long (contains %s)"",
      FATAL, &fpos(x), file_name);
  sprintf( (char *) buff, ""%d.%d.%s.%d"",
",1,unused,255,unused,"  ifdebug(DCR, DDD, crtab_debug(crossref_tab, stderr));
  if( StringLength(file_name) + 20 >= MAX_BUFF )
    Error(10, 3, ""automatically generated tag is too long (contains %s)"",
      FATAL, &fpos(x), file_name);
  sprintf( (char *) buff, ""%d.%d.%s.%d"",
",unused,MiBench-consumer-typeset-z10.c
"	    { int scale_factor;
	      scale_factor = ScaleToConstraint(back(y,dim), fwd(y,dim), &c);
	      if( scale_factor > 0.5 * SF )
	      {	char num1[20], num2[20];
		sprintf(num1, ""%.1fc"", (float) size(y, dim) / CM);
",1,unused,650,unused,"	    { int scale_factor;
	      scale_factor = ScaleToConstraint(back(y,dim), fwd(y,dim), &c);
	      if( scale_factor > 0.5 * SF )
	      {	char num1[20], num2[20];
		sprintf(num1, ""%.1fc"", (float) size(y, dim) / CM);
",unused,MiBench-consumer-typeset-z19.c
"	      scale_factor = ScaleToConstraint(back(y,dim), fwd(y,dim), &c);
	      if( scale_factor > 0.5 * SF )
	      {	char num1[20], num2[20];
		sprintf(num1, ""%.1fc"", (float) size(y, dim) / CM);
		sprintf(num2, ""%.1fc"", (float) bfc(c) / CM);
",1,unused,651,unused,"	      scale_factor = ScaleToConstraint(back(y,dim), fwd(y,dim), &c);
	      if( scale_factor > 0.5 * SF )
	      {	char num1[20], num2[20];
		sprintf(num1, ""%.1fc"", (float) size(y, dim) / CM);
		sprintf(num2, ""%.1fc"", (float) bfc(c) / CM);
",unused,MiBench-consumer-typeset-z19.c
"		EchoLength(back(y, dim)), EchoLength(fwd(y, dim)),
		EchoConstraint(&c));
	      ifdebug(DGA, D, DebugObject(y));
	      if( size(y, dim) > 0 )
	      { sprintf(num1, ""%.1fc"", (float) size(y, dim) / CM);
",1,unused,671,unused,"		EchoLength(back(y, dim)), EchoLength(fwd(y, dim)),
		EchoConstraint(&c));
	      ifdebug(DGA, D, DebugObject(y));
	      if( size(y, dim) > 0 )
	      { sprintf(num1, ""%.1fc"", (float) size(y, dim) / CM);
",unused,MiBench-consumer-typeset-z19.c
"		EchoConstraint(&c));
	      ifdebug(DGA, D, DebugObject(y));
	      if( size(y, dim) > 0 )
	      { sprintf(num1, ""%.1fc"", (float) size(y, dim) / CM);
	        sprintf(num2, ""%.1fc"", (float) bfc(c) / CM);
",1,unused,672,unused,"		EchoConstraint(&c));
	      ifdebug(DGA, D, DebugObject(y));
	      if( size(y, dim) > 0 )
	      { sprintf(num1, ""%.1fc"", (float) size(y, dim) / CM);
	        sprintf(num2, ""%.1fc"", (float) bfc(c) / CM);
",unused,MiBench-consumer-typeset-z19.c
"	    { int scale_factor;
	      scale_factor = ScaleToConstraint(perp_back, perp_fwd, &c);
	      if( scale_factor > 0.5 * SF )
	      {	char num1[20], num2[20];
		sprintf(num1, ""%.1fc"", (float) (perp_back + perp_fwd) / CM);
",1,unused,705,unused,"	    { int scale_factor;
	      scale_factor = ScaleToConstraint(perp_back, perp_fwd, &c);
	      if( scale_factor > 0.5 * SF )
	      {	char num1[20], num2[20];
		sprintf(num1, ""%.1fc"", (float) (perp_back + perp_fwd) / CM);
",unused,MiBench-consumer-typeset-z19.c
"	      scale_factor = ScaleToConstraint(perp_back, perp_fwd, &c);
	      if( scale_factor > 0.5 * SF )
	      {	char num1[20], num2[20];
		sprintf(num1, ""%.1fc"", (float) (perp_back + perp_fwd) / CM);
		sprintf(num2, ""%.1fc"", (float) bfc(c) / CM);
",1,unused,706,unused,"	      scale_factor = ScaleToConstraint(perp_back, perp_fwd, &c);
	      if( scale_factor > 0.5 * SF )
	      {	char num1[20], num2[20];
		sprintf(num1, ""%.1fc"", (float) (perp_back + perp_fwd) / CM);
		sprintf(num2, ""%.1fc"", (float) bfc(c) / CM);
",unused,MiBench-consumer-typeset-z19.c
"	    { int scale_factor;
	      scale_factor = ScaleToConstraint(back(z,dim), fwd(z,dim), &c);
	      if( scale_factor > 0.5 * SF )
	      {	char num1[20], num2[20];
		sprintf(num1, ""%.1fc"", (float) size(z, dim) / CM);
",1,unused,758,unused,"	    { int scale_factor;
	      scale_factor = ScaleToConstraint(back(z,dim), fwd(z,dim), &c);
	      if( scale_factor > 0.5 * SF )
	      {	char num1[20], num2[20];
		sprintf(num1, ""%.1fc"", (float) size(z, dim) / CM);
",unused,MiBench-consumer-typeset-z19.c
"	      scale_factor = ScaleToConstraint(back(z,dim), fwd(z,dim), &c);
	      if( scale_factor > 0.5 * SF )
	      {	char num1[20], num2[20];
		sprintf(num1, ""%.1fc"", (float) size(z, dim) / CM);
		sprintf(num2, ""%.1fc"", (float) bfc(c) / CM);
",1,unused,759,unused,"	      scale_factor = ScaleToConstraint(back(z,dim), fwd(z,dim), &c);
	      if( scale_factor > 0.5 * SF )
	      {	char num1[20], num2[20];
		sprintf(num1, ""%.1fc"", (float) size(z, dim) / CM);
		sprintf(num2, ""%.1fc"", (float) bfc(c) / CM);
",unused,MiBench-consumer-typeset-z19.c
"		EchoLength(back(z, dim)), EchoLength(fwd(z, dim)),
		EchoConstraint(&c));
	      ifdebug(DGA, D, DebugObject(y));
	      if( size(z, dim) > 0 )
	      { sprintf(num1, ""%.1fc"", (float) size(z, dim) / CM);
",1,unused,782,unused,"		EchoLength(back(z, dim)), EchoLength(fwd(z, dim)),
		EchoConstraint(&c));
	      ifdebug(DGA, D, DebugObject(y));
	      if( size(z, dim) > 0 )
	      { sprintf(num1, ""%.1fc"", (float) size(z, dim) / CM);
",unused,MiBench-consumer-typeset-z19.c
"		EchoConstraint(&c));
	      ifdebug(DGA, D, DebugObject(y));
	      if( size(z, dim) > 0 )
	      { sprintf(num1, ""%.1fc"", (float) size(z, dim) / CM);
	        sprintf(num2, ""%.1fc"", (float) bfc(c) / CM);
",1,unused,783,unused,"		EchoConstraint(&c));
	      ifdebug(DGA, D, DebugObject(y));
	      if( size(z, dim) > 0 )
	      { sprintf(num1, ""%.1fc"", (float) size(z, dim) / CM);
	        sprintf(num2, ""%.1fc"", (float) bfc(c) / CM);
",unused,MiBench-consumer-typeset-z19.c
"	    { int scale_factor;
	      scale_factor = ScaleToConstraint(back(z,1-dim), fwd(z,1-dim), &c);
	      if( scale_factor > 0.5 * SF )
	      {	char num1[20], num2[20];
		sprintf(num1, ""%.1fc"", (float) size(z, 1-dim) / CM);
",1,unused,816,unused,"	    { int scale_factor;
	      scale_factor = ScaleToConstraint(back(z,1-dim), fwd(z,1-dim), &c);
	      if( scale_factor > 0.5 * SF )
	      {	char num1[20], num2[20];
		sprintf(num1, ""%.1fc"", (float) size(z, 1-dim) / CM);
",unused,MiBench-consumer-typeset-z19.c
"	      scale_factor = ScaleToConstraint(back(z,1-dim), fwd(z,1-dim), &c);
	      if( scale_factor > 0.5 * SF )
	      {	char num1[20], num2[20];
		sprintf(num1, ""%.1fc"", (float) size(z, 1-dim) / CM);
		sprintf(num2, ""%.1fc"", (float) bfc(c) / CM);
",1,unused,817,unused,"	      scale_factor = ScaleToConstraint(back(z,1-dim), fwd(z,1-dim), &c);
	      if( scale_factor > 0.5 * SF )
	      {	char num1[20], num2[20];
		sprintf(num1, ""%.1fc"", (float) size(z, 1-dim) / CM);
		sprintf(num2, ""%.1fc"", (float) bfc(c) / CM);
",unused,MiBench-consumer-typeset-z19.c
"{ static FULL_CHAR buff[8][20];
  static int i = 0;
  i = (i + 1) % 8;
  if( len == MAX_FULL_LENGTH )
    sprintf( (char *) buff[i], ""%s"", ""INF"");
",1,unused,129,unused,"{ static FULL_CHAR buff[8][20];
  static int i = 0;
  i = (i + 1) % 8;
  if( len == MAX_FULL_LENGTH )
    sprintf( (char *) buff[i], ""%s"", ""INF"");
",unused,MiBench-consumer-typeset-z26.c
"    case GAP_ABS:		return  AsciiToFull(""abs"");
    case GAP_INC:		return  AsciiToFull(""inc"");
    case GAP_DEC:		return  AsciiToFull(""dec"");

    default:			sprintf( (char *) b, ""?? (%d)"", c);
",1,unused,315,unused,"    case GAP_ABS:		return  AsciiToFull(""abs"");
    case GAP_INC:		return  AsciiToFull(""inc"");
    case GAP_DEC:		return  AsciiToFull(""dec"");

    default:			sprintf( (char *) b, ""?? (%d)"", c);
",unused,MiBench-consumer-typeset-z26.c
"      else if( mess_top < MAX_ERRORS )
      {
	if( AltErrorFormat )
	{
	  sprintf(message[mess_top++], ""%s: %s\n"", EchoAltFilePos(pos), val);
",1,unused,238,unused,"      else if( mess_top < MAX_ERRORS )
      {
	if( AltErrorFormat )
	{
	  sprintf(message[mess_top++], ""%s: %s\n"", EchoAltFilePos(pos), val);
",unused,MiBench-consumer-typeset-z28.c
"	  sprintf(message[mess_top++], ""%s: %s\n"", EchoAltFilePos(pos), val);
	}
	else
	{ message_fnum[mess_top] = file_num(*pos);
	  sprintf(message[mess_top++], ""  %6s: %s\n"",
",1,unused,242,unused,"	  sprintf(message[mess_top++], ""%s: %s\n"", EchoAltFilePos(pos), val);
	}
	else
	{ message_fnum[mess_top] = file_num(*pos);
	  sprintf(message[mess_top++], ""  %6s: %s\n"",
",unused,MiBench-consumer-typeset-z28.c
"  }

  /* convert parameters into search key */
  SymToNum(db, sym, symnum, FALSE);
  sprintf( (char *) buff, ""%s%d&%s"", gall ? ""0"" : """", symnum, tag);
",1,unused,747,unused,"  }

  /* convert parameters into search key */
  SymToNum(db, sym, symnum, FALSE);
  sprintf( (char *) buff, ""%s%d&%s"", gall ? ""0"" : """", symnum, tag);
",unused,MiBench-consumer-typeset-z33.c
"      FATAL, no_fpos, family_name, face_name);
  }

  /* search the databases for @FontDef @Tag { family-face } */
  sprintf( (char *) tag, ""%s-%s"", family_name, face_name);
",1,unused,510,unused,"      FATAL, no_fpos, family_name, face_name);
  }

  /* search the databases for @FontDef @Tag { family-face } */
  sprintf( (char *) tag, ""%s-%s"", family_name, face_name);
",unused,MiBench-consumer-typeset-z37.c
"/*****************************************************************************/

FULL_CHAR *StringInt(int i)
{ static FULL_CHAR buff[20];
  sprintf( (char *) buff, ""%d"", i);
",1,unused,153,unused,"/*****************************************************************************/

FULL_CHAR *StringInt(int i)
{ static FULL_CHAR buff[20];
  sprintf( (char *) buff, ""%d"", i);
",unused,MiBench-consumer-typeset-z39.c
"} /* end StringInt */

FULL_CHAR *StringFiveInt(int i)
{ static FULL_CHAR buff[20];
  sprintf( (char *) buff, ""%.5d"", i);
",1,unused,159,unused,"} /* end StringInt */

FULL_CHAR *StringFiveInt(int i)
{ static FULL_CHAR buff[20];
  sprintf( (char *) buff, ""%.5d"", i);
",unused,MiBench-consumer-typeset-z39.c
"    Error(48, 3, ""PDFFile_BeginFontEncoding: out of memory"", FATAL, no_fpos);

  encoding_entry->m_next_entry = g_font_encoding_list;
  encoding_entry->m_object_num = encoding_num;
  strcpy((char*) encoding_entry->m_font_encoding, (char*) in_encoding_name);
",1,unused,707,unused,"    Error(48, 3, ""PDFFile_BeginFontEncoding: out of memory"", FATAL, no_fpos);

  encoding_entry->m_next_entry = g_font_encoding_list;
  encoding_entry->m_object_num = encoding_num;
  strcpy((char*) encoding_entry->m_font_encoding, (char*) in_encoding_name);
",unused,MiBench-consumer-typeset-z48.c
"    new_entry = (t_font_list_entry_ptr) malloc(sizeof(t_font_list_entry));
    if (new_entry == NULL)
      Error(48, 4, ""PDFFont_NewListEntry: run out of memory"", FATAL, no_fpos);

    sprintf(num, ""%u"", next_font_num);
",1,unused,808,unused,"    new_entry = (t_font_list_entry_ptr) malloc(sizeof(t_font_list_entry));
    if (new_entry == NULL)
      Error(48, 4, ""PDFFont_NewListEntry: run out of memory"", FATAL, no_fpos);

    sprintf(num, ""%u"", next_font_num);
",unused,MiBench-consumer-typeset-z48.c
"    if (new_entry == NULL)
      Error(48, 4, ""PDFFont_NewListEntry: run out of memory"", FATAL, no_fpos);

    sprintf(num, ""%u"", next_font_num);
    strcat(PDF_font_name, num);
",1,unused,809,unused,"    if (new_entry == NULL)
      Error(48, 4, ""PDFFont_NewListEntry: run out of memory"", FATAL, no_fpos);

    sprintf(num, ""%u"", next_font_num);
    strcat(PDF_font_name, num);
",unused,MiBench-consumer-typeset-z48.c
"    new_entry->m_PDF_font_name =
      (FULL_CHAR*) malloc(strlen((char*) PDF_font_name) + 1);
    if (new_entry->m_PDF_font_name == NULL)
      Error(48, 5, ""PDFFont_NewListEntry: run out of memory"", FATAL, no_fpos);
    strcpy((char*) new_entry->m_PDF_font_name, PDF_font_name);
",1,unused,815,unused,"    new_entry->m_PDF_font_name =
      (FULL_CHAR*) malloc(strlen((char*) PDF_font_name) + 1);
    if (new_entry->m_PDF_font_name == NULL)
      Error(48, 5, ""PDFFont_NewListEntry: run out of memory"", FATAL, no_fpos);
    strcpy((char*) new_entry->m_PDF_font_name, PDF_font_name);
",unused,MiBench-consumer-typeset-z48.c
"    new_entry->m_short_font_name =
      (FULL_CHAR*) malloc(strlen((char*) in_short_font_name) + 1);
    if (new_entry->m_short_font_name == NULL)
      Error(48, 6, ""PDFFont_NewListEntry: run out of memory"", FATAL, no_fpos);
    strcpy((char*) new_entry->m_short_font_name, (char*) in_short_font_name);
",1,unused,821,unused,"    new_entry->m_short_font_name =
      (FULL_CHAR*) malloc(strlen((char*) in_short_font_name) + 1);
    if (new_entry->m_short_font_name == NULL)
      Error(48, 6, ""PDFFont_NewListEntry: run out of memory"", FATAL, no_fpos);
    strcpy((char*) new_entry->m_short_font_name, (char*) in_short_font_name);
",unused,MiBench-consumer-typeset-z48.c
"    new_entry->m_actual_font_name =
      (FULL_CHAR*) malloc(strlen((char*) in_real_font_name) + 1);
    if (new_entry->m_actual_font_name == NULL)
      Error(48, 7, ""PDFFont_NewListEntry: run out of memory"", FATAL, no_fpos);
    strcpy((char*) new_entry->m_actual_font_name, (char*) in_real_font_name);
",1,unused,827,unused,"    new_entry->m_actual_font_name =
      (FULL_CHAR*) malloc(strlen((char*) in_real_font_name) + 1);
    if (new_entry->m_actual_font_name == NULL)
      Error(48, 7, ""PDFFont_NewListEntry: run out of memory"", FATAL, no_fpos);
    strcpy((char*) new_entry->m_actual_font_name, (char*) in_real_font_name);
",unused,MiBench-consumer-typeset-z48.c
"    }
#endif

#ifndef USE_MATRICES
    sprintf(str, ""%.2f 0 0 %.2f 0 0 cm\n"",
",1,unused,1253,unused,"    }
#endif

#ifndef USE_MATRICES
    sprintf(str, ""%.2f 0 0 %.2f 0 0 cm\n"",
",unused,MiBench-consumer-typeset-z48.c
"    sprintf(str, ""%.2f 0 0 %.2f 0 0 cm\n"",
      g_page_h_scale_factor, g_page_v_scale_factor);
    PDFPage_WriteStream(in_fp, str);
#endif
    sprintf(str, ""%u w\n"", g_page_line_width);
",1,unused,1257,unused,"    sprintf(str, ""%.2f 0 0 %.2f 0 0 cm\n"",
      g_page_h_scale_factor, g_page_v_scale_factor);
    PDFPage_WriteStream(in_fp, str);
#endif
    sprintf(str, ""%u w\n"", g_page_line_width);
",unused,MiBench-consumer-typeset-z48.c
"      PDFPage_WriteStream(in_fp, in_str);
    }
    else
    {
      strcpy(g_buffer + g_buffer_pos, in_str);		/* save into buffer */
",1,unused,1365,unused,"      PDFPage_WriteStream(in_fp, in_str);
    }
    else
    {
      strcpy(g_buffer + g_buffer_pos, in_str);		/* save into buffer */
",unused,MiBench-consumer-typeset-z48.c
"#ifdef USE_MATRICES
  sprintf(str, ""%s %u Tf\n"", entry->m_PDF_font_name,
    (int) (g_page_v_scale_factor * in_font_size));
#else
  sprintf(str, ""%s %u Tf\n"", entry->m_PDF_font_name, in_font_size);
",1,unused,1508,unused,"#ifdef USE_MATRICES
  sprintf(str, ""%s %u Tf\n"", entry->m_PDF_font_name,
    (int) (g_page_v_scale_factor * in_font_size));
#else
  sprintf(str, ""%s %u Tf\n"", entry->m_PDF_font_name, in_font_size);
",unused,MiBench-consumer-typeset-z48.c
"static void PDFText_MoveToXYAndOpen(FILE* in_fp, int hpos, int vpos)
{
#if 1
  t_tempbuf str;
  sprintf(str, ""1 0 0 1 %d %d Tm\n"", hpos, vpos);
",1,unused,1620,unused,"static void PDFText_MoveToXYAndOpen(FILE* in_fp, int hpos, int vpos)
{
#if 1
  t_tempbuf str;
  sprintf(str, ""1 0 0 1 %d %d Tm\n"", hpos, vpos);
",unused,MiBench-consumer-typeset-z48.c
"static void PDFText_MoveToXAndOpen(FILE* in_fp, int hpos)
{
#if 1
  t_tempbuf str;
  sprintf(str, ""%d 0 Td\n"", hpos);
",1,unused,1641,unused,"static void PDFText_MoveToXAndOpen(FILE* in_fp, int hpos)
{
#if 1
  t_tempbuf str;
  sprintf(str, ""%d 0 Td\n"", hpos);
",unused,MiBench-consumer-typeset-z48.c
"{
  t_tempbuf str;

  /* sprintf(str, "")%d("", -in_kern * 1000 / g_text_font_size_in_ems); */
  sprintf(str, "")%d("", -in_kern);
",1,unused,1749,unused,"{
  t_tempbuf str;

  /* sprintf(str, "")%d("", -in_kern * 1000 / g_text_font_size_in_ems); */
  sprintf(str, "")%d("", -in_kern);
",unused,MiBench-consumer-typeset-z48.c
"  PDF_Matrix_Mul(m, g_cur_matrix, g_cur_matrix);
#else
  t_tempbuf str;

  sprintf(str, ""%.2f 0 0 %.2f 0 0 cm\n"", in_h_scale_factor, in_v_scale_factor);
",1,unused,1854,unused,"  PDF_Matrix_Mul(m, g_cur_matrix, g_cur_matrix);
#else
  t_tempbuf str;

  sprintf(str, ""%.2f 0 0 %.2f 0 0 cm\n"", in_h_scale_factor, in_v_scale_factor);
",unused,MiBench-consumer-typeset-z48.c
"  PDF_Matrix_Mul(m, g_cur_matrix, g_cur_matrix);
#else
  t_tempbuf str;

  sprintf(str, ""%.2f %.2f %.2f %.2f 0 0 cm\n"", cos_radians, sin_radians,
",1,unused,1887,unused,"  PDF_Matrix_Mul(m, g_cur_matrix, g_cur_matrix);
#else
  t_tempbuf str;

  sprintf(str, ""%.2f %.2f %.2f %.2f 0 0 cm\n"", cos_radians, sin_radians,
",unused,MiBench-consumer-typeset-z48.c
"  PDF_Matrix_Mul(m, g_cur_matrix, g_cur_matrix);
#else
  t_tempbuf str;

  sprintf(str, ""1 0 0 1 %.2f %.2f cm\n"", in_delta_h, in_delta_v);
",1,unused,1916,unused,"  PDF_Matrix_Mul(m, g_cur_matrix, g_cur_matrix);
#else
  t_tempbuf str;

  sprintf(str, ""1 0 0 1 %.2f %.2f cm\n"", in_delta_h, in_delta_v);
",unused,MiBench-consumer-typeset-z48.c
"	      if (source->m_file_spec == NULL)
		Error(48, 25, ""PDFPage_ProcessLinkKeyword: out of memory"",
		  FATAL, no_fpos);
#if 1
	      strcpy((char*) source->m_file_spec, (char*) parm);
",1,unused,2519,unused,"	      if (source->m_file_spec == NULL)
		Error(48, 25, ""PDFPage_ProcessLinkKeyword: out of memory"",
		  FATAL, no_fpos);
#if 1
	      strcpy((char*) source->m_file_spec, (char*) parm);
",unused,MiBench-consumer-typeset-z48.c
"      if (g_doc_author == NULL)
	Error(48, 26, ""PDFPage_ProcessDocInfoKeyword: no memory for __author="",
	  WARN, no_fpos);
      else
	strcpy((char*) g_doc_author, (char*) charPtr);
",1,unused,2570,unused,"      if (g_doc_author == NULL)
	Error(48, 26, ""PDFPage_ProcessDocInfoKeyword: no memory for __author="",
	  WARN, no_fpos);
      else
	strcpy((char*) g_doc_author, (char*) charPtr);
",unused,MiBench-consumer-typeset-z48.c
"      if (g_doc_title == NULL)
	Error(48, 27, ""PDFPage_ProcessDocInfoKeyword: no memory for __title="",
	  WARN, no_fpos);
       else
	strcpy((char*) g_doc_title, (char*) charPtr);
",1,unused,2583,unused,"      if (g_doc_title == NULL)
	Error(48, 27, ""PDFPage_ProcessDocInfoKeyword: no memory for __title="",
	  WARN, no_fpos);
       else
	strcpy((char*) g_doc_title, (char*) charPtr);
",unused,MiBench-consumer-typeset-z48.c
"      if (g_doc_subject == NULL)
	Error(47, 28, ""PDFPage_ProcessDocInfoKeyword: no memory for __subject="",
	  WARN, no_fpos);
      else
	strcpy((char*) g_doc_subject, (char*) charPtr);
",1,unused,2596,unused,"      if (g_doc_subject == NULL)
	Error(47, 28, ""PDFPage_ProcessDocInfoKeyword: no memory for __subject="",
	  WARN, no_fpos);
      else
	strcpy((char*) g_doc_subject, (char*) charPtr);
",unused,MiBench-consumer-typeset-z48.c
"      if (g_doc_keywords == NULL)
	Error(48, 29, ""PDFPage_ProcessDocInfoKeyword: no memory for __keywords="",
	  WARN, no_fpos);
      else
	strcpy((char*) g_doc_keywords, (char*) charPtr);
",1,unused,2608,unused,"      if (g_doc_keywords == NULL)
	Error(48, 29, ""PDFPage_ProcessDocInfoKeyword: no memory for __keywords="",
	  WARN, no_fpos);
      else
	strcpy((char*) g_doc_keywords, (char*) charPtr);
",unused,MiBench-consumer-typeset-z48.c
"
    charPtr = PDFPage_CollectExpr(charPtr, &hasResult, &value);
    if (hasResult)
    {
      sprintf(strPtr, ""%.2f"", value);
",1,unused,2879,unused,"
    charPtr = PDFPage_CollectExpr(charPtr, &hasResult, &value);
    if (hasResult)
    {
      sprintf(strPtr, ""%.2f"", value);
",unused,MiBench-consumer-typeset-z48.c
"	if (i >= 0)
	{
	  charPtr += strlen(g_graphic_keywords[i]);
#if 1
	  sprintf(strPtr, ""%d"", g_graphics_vars[i]);
",1,unused,2922,unused,"	if (i >= 0)
	{
	  charPtr += strlen(g_graphic_keywords[i]);
#if 1
	  sprintf(strPtr, ""%d"", g_graphics_vars[i]);
",unused,MiBench-consumer-typeset-z48.c
"	      /* ""add"" ""sub"" ""mul"" ""div"", ""sin"", ""cos"" */
	      i = PDFKeyword_Find(kNumberOfArithmeticKeywords, g_arithmetic_keywords, charPtr);
	      if (i >= 0)
	      {
		strcpy(g_expr, g_arithmetic_keywords[i]);
",1,unused,2964,unused,"	      /* ""add"" ""sub"" ""mul"" ""div"", ""sin"", ""cos"" */
	      i = PDFKeyword_Find(kNumberOfArithmeticKeywords, g_arithmetic_keywords, charPtr);
	      if (i >= 0)
	      {
		strcpy(g_expr, g_arithmetic_keywords[i]);
",unused,MiBench-consumer-typeset-z48.c
"		  charPtr++;
		if (*charPtr != '(')
		  Error(48, 36, ""PDFPage_WriteGraphic: '(' expected"", FATAL, no_fpos);

		strcat(g_expr, ""("");
",1,unused,2971,unused,"		  charPtr++;
		if (*charPtr != '(')
		  Error(48, 36, ""PDFPage_WriteGraphic: '(' expected"", FATAL, no_fpos);

		strcat(g_expr, ""("");
",unused,MiBench-consumer-typeset-z48.c
"
		  charPtr = PDFPage_CollectExpr(++charPtr, &hasResult, &value);
		  if (hasResult)
		  {
		    sprintf(strPtr, ""%.2f"", value);
",1,unused,2980,unused,"
		  charPtr = PDFPage_CollectExpr(++charPtr, &hasResult, &value);
		  if (hasResult)
		  {
		    sprintf(strPtr, ""%.2f"", value);
",unused,MiBench-consumer-typeset-z48.c
"
  /* fprintf(out_fp, ""/ul { gsave setlinewidth dup 3 1 roll\n""); */
  /* fprintf(out_fp, ""      moveto lineto stroke grestore } bind def\n"");  */

  sprintf(str, ""q %d w %d %d m %d %d l s Q\n"",in_thickness,in_x1,in_y,in_x2,in_y);
",1,unused,3029,unused,"
  /* fprintf(out_fp, ""/ul { gsave setlinewidth dup 3 1 roll\n""); */
  /* fprintf(out_fp, ""      moveto lineto stroke grestore } bind def\n"");  */

  sprintf(str, ""q %d w %d %d m %d %d l s Q\n"",in_thickness,in_x1,in_y,in_x2,in_y);
",unused,MiBench-consumer-typeset-z48.c
"    if (the_block->m_block[block_pos] == 0)
    {
      t_tempbuf str;

      strcpy(str, ""PDFFile_WriteXREF: undefined object number: "");
",1,unused,3460,unused,"    if (the_block->m_block[block_pos] == 0)
    {
      t_tempbuf str;

      strcpy(str, ""PDFFile_WriteXREF: undefined object number: "");
",unused,MiBench-consumer-typeset-z48.c
"    {
      t_tempbuf str;

      strcpy(str, ""PDFFile_WriteXREF: undefined object number: "");
      sprintf(str + strlen(str), ""%u"", i);
",1,unused,3461,unused,"    {
      t_tempbuf str;

      strcpy(str, ""PDFFile_WriteXREF: undefined object number: "");
      sprintf(str + strlen(str), ""%u"", i);
",unused,MiBench-consumer-typeset-z48.c
"
    if (entry->m_target == NULL)
    {
      t_tempbuf str;
      strcpy(str, ""PDFFile_Cleanup: unresolved link annotation named "");
",1,unused,3688,unused,"
    if (entry->m_target == NULL)
    {
      t_tempbuf str;
      strcpy(str, ""PDFFile_Cleanup: unresolved link annotation named "");
",unused,MiBench-consumer-typeset-z48.c
"    if (entry->m_target == NULL)
    {
      t_tempbuf str;
      strcpy(str, ""PDFFile_Cleanup: unresolved link annotation named "");
      strcat(str, (char*) entry->m_name);
",1,unused,3689,unused,"    if (entry->m_target == NULL)
    {
      t_tempbuf str;
      strcpy(str, ""PDFFile_Cleanup: unresolved link annotation named "");
      strcat(str, (char*) entry->m_name);
",unused,MiBench-consumer-typeset-z48.c
"/*****************************************************************************/

static void PS_PrintLength(FULL_CHAR *buff, int length, int length_dim)
{
  sprintf( (char *) buff, ""%.3fc"", (float) length/CM);
",1,unused,249,unused,"/*****************************************************************************/

static void PS_PrintLength(FULL_CHAR *buff, int length, int length_dim)
{
  sprintf( (char *) buff, ""%.3fc"", (float) length/CM);
",unused,MiBench-consumer-typeset-z49.c
"char *ConvertToPDFName(OBJECT name)
{ static char buff[200];
  char *q;
  FULL_CHAR *p;
  strcpy(buff, ""LOUT"");
",1,unused,1272,unused,"char *ConvertToPDFName(OBJECT name)
{ static char buff[200];
  char *q;
  FULL_CHAR *p;
  strcpy(buff, ""LOUT"");
",unused,MiBench-consumer-typeset-z49.c
"/*****************************************************************************/

static void PDF_PrintLength(FULL_CHAR *buff, int length, int length_dim)
{
  sprintf( (char *) buff, ""%.3fc"", (float) length/CM);
",1,unused,122,unused,"/*****************************************************************************/

static void PDF_PrintLength(FULL_CHAR *buff, int length, int length_dim)
{
  sprintf( (char *) buff, ""%.3fc"", (float) length/CM);
",unused,MiBench-consumer-typeset-z50.c
"  {
    currentcolour = word_colour(x);
    if( currentcolour > 0 )
    { char str[256];
      sprintf(str, ""%s "", ColourCommand(currentcolour));
",1,unused,329,unused,"  {
    currentcolour = word_colour(x);
    if( currentcolour > 0 )
    { char str[256];
      sprintf(str, ""%s "", ColourCommand(currentcolour));
",unused,MiBench-consumer-typeset-z50.c
"  if( colour(save_style(x)) != currentcolour )
  { currentcolour = colour(save_style(x));
    if( currentcolour > 0 )
    { char str[256];
      sprintf(str, ""%s "", ColourCommand(currentcolour));
",1,unused,720,unused,"  if( colour(save_style(x)) != currentcolour )
  { currentcolour = colour(save_style(x));
    if( currentcolour > 0 )
    { char str[256];
      sprintf(str, ""%s "", ColourCommand(currentcolour));
",unused,MiBench-consumer-typeset-z50.c
"static void Plain_PrintLength(FULL_CHAR *buff, int length, int length_dim)
{
  if( length_dim == COLM )
  {
    sprintf( (char *) buff, ""%.2fs"", (float) length/PlainCharWidth);
",1,unused,86,unused,"static void Plain_PrintLength(FULL_CHAR *buff, int length, int length_dim)
{
  if( length_dim == COLM )
  {
    sprintf( (char *) buff, ""%.2fs"", (float) length/PlainCharWidth);
",unused,MiBench-consumer-typeset-z51.c
"    sprintf( (char *) buff, ""%.2fs"", (float) length/PlainCharWidth);
  }
  else
  {
    sprintf( (char *) buff, ""%.2ff"", (float) length/PlainCharHeight);
",1,unused,90,unused,"    sprintf( (char *) buff, ""%.2fs"", (float) length/PlainCharWidth);
  }
  else
  {
    sprintf( (char *) buff, ""%.2ff"", (float) length/PlainCharHeight);
",unused,MiBench-consumer-typeset-z51.c
"#ifdef WITH_TLS
		if(mosq->tls_cafile || mosq->tls_capath || mosq->tls_psk){
			h = _mosquitto_malloc(strlen(host) + strlen(""_secure-mqtt._tcp."") + 1);
			if(!h) return MOSQ_ERR_NOMEM;
			sprintf(h, ""_secure-mqtt._tcp.%s"", host);
",1,unused,74,unused,"#ifdef WITH_TLS
		if(mosq->tls_cafile || mosq->tls_capath || mosq->tls_psk){
			h = _mosquitto_malloc(strlen(host) + strlen(""_secure-mqtt._tcp."") + 1);
			if(!h) return MOSQ_ERR_NOMEM;
			sprintf(h, ""_secure-mqtt._tcp.%s"", host);
",unused,MosquittoTest-lib2Fsrv_mosq.c
"		}else{
#endif
			h = _mosquitto_malloc(strlen(host) + strlen(""_mqtt._tcp."") + 1);
			if(!h) return MOSQ_ERR_NOMEM;
			sprintf(h, ""_mqtt._tcp.%s"", host);
",1,unused,79,unused,"		}else{
#endif
			h = _mosquitto_malloc(strlen(host) + strlen(""_mqtt._tcp."") + 1);
			if(!h) return MOSQ_ERR_NOMEM;
			sprintf(h, ""_mqtt._tcp.%s"", host);
",unused,MosquittoTest-lib2Fsrv_mosq.c
"    this->state = S_IDLE;

    MailboxInit(this);

    int err = sprintf(this->nameTask, NAME_TASK, exampleCounter);
",1,unused,375,unused,"    this->state = S_IDLE;

    MailboxInit(this);

    int err = sprintf(this->nameTask, NAME_TASK, exampleCounter);
",unused,Nathan-LG_ProSE_C-src2Fexample2Fexample.c
"
WEAK
static void MailboxInit(Example * this)
{
    int err = sprintf(this->queueName, NAME_MQ_BOX, exampleCounter);
",1,unused,420,unused,"
WEAK
static void MailboxInit(Example * this)
{
    int err = sprintf(this->queueName, NAME_MQ_BOX, exampleCounter);
",unused,Nathan-LG_ProSE_C-src2Fexample2Fexample.c
"    this->state = S_IDLE;

    MailboxInit(this);

    int err = sprintf(this->nameTask, NAME_TASK, exampleCounter);
",1,unused,375,unused,"    this->state = S_IDLE;

    MailboxInit(this);

    int err = sprintf(this->nameTask, NAME_TASK, exampleCounter);
",unused,Nathan-LG_ProSE_C-src2Fexample2Fexample.c
"
WEAK
static void MailboxInit(Example * this)
{
    int err = sprintf(this->queueName, NAME_MQ_BOX, exampleCounter);
",1,unused,420,unused,"
WEAK
static void MailboxInit(Example * this)
{
    int err = sprintf(this->queueName, NAME_MQ_BOX, exampleCounter);
",unused,Nathan-LG_ProSE_C-src2Fexample2Fexample.c
"
  /*     */
  char line[MAXLINE];
  char output_line[MAXLINE];
  strcpy(line, contents);
",1,unused,35,unused,"
  /*     */
  char line[MAXLINE];
  char output_line[MAXLINE];
  strcpy(line, contents);
",unused,NekozillaXD_testing_lab2-app2Fshow.c
"
  if (cursor >= 0) {
    strncpy(output_line, line, cursor);
    output_line[cursor] = '|';
    strcpy(output_line + cursor + 1, line + cursor);
",1,unused,40,unused,"
  if (cursor >= 0) {
    strncpy(output_line, line, cursor);
    output_line[cursor] = '|';
    strcpy(output_line + cursor + 1, line + cursor);
",unused,NekozillaXD_testing_lab2-app2Fshow.c
"
  /*     */
  char line[MAXLINE];
  char output_line[MAXLINE];
  strcpy(line, contents);
",1,unused,35,unused,"
  /*     */
  char line[MAXLINE];
  char output_line[MAXLINE];
  strcpy(line, contents);
",unused,NekozillaXD_testing_lab2-app2Fshow.c
"
  if (cursor >= 0) {
    strncpy(output_line, line, cursor);
    output_line[cursor] = '|';
    strcpy(output_line + cursor + 1, line + cursor);
",1,unused,40,unused,"
  if (cursor >= 0) {
    strncpy(output_line, line, cursor);
    output_line[cursor] = '|';
    strcpy(output_line + cursor + 1, line + cursor);
",unused,NekozillaXD_testing_lab2-app2Fshow.c
"			ret = -ENOMEM;
			goto exit;
		}

		strcpy(entry, line);
",1,unused,901,unused,"			ret = -ENOMEM;
			goto exit;
		}

		strcpy(entry, line);
",unused,PavanNikhilesh_dpdk-app2Ftest-bbdev2Ftest_bbdev_vector.c
"				}

				entry = entry_extended;
				/* entry has been allocated accordingly */
				strcpy(&entry[strlen(entry)], line);
",1,unused,924,unused,"				}

				entry = entry_extended;
				/* entry has been allocated accordingly */
				strcpy(&entry[strlen(entry)], line);
",unused,PavanNikhilesh_dpdk-app2Ftest-bbdev2Ftest_bbdev_vector.c
"					sizeof(char) * strlen(line) + 1, 0);
		if (entry == NULL)
			return -1;

		strcpy(entry, line);
",1,unused,509,unused,"					sizeof(char) * strlen(line) + 1, 0);
		if (entry == NULL)
			return -1;

		strcpy(entry, line);
",unused,PavanNikhilesh_dpdk-app2Ftest-crypto-perf2Fcperf_test_vector_parsing.c
"				if (entry_extended == NULL)
					goto err;
				entry = entry_extended;
				/* entry has been allocated accordingly */
				strcpy(&entry[strlen(entry)], line);
",1,unused,527,unused,"				if (entry_extended == NULL)
					goto err;
				entry = entry_extended;
				/* entry has been allocated accordingly */
				strcpy(&entry[strlen(entry)], line);
",unused,PavanNikhilesh_dpdk-app2Ftest-crypto-perf2Fcperf_test_vector_parsing.c
"			if (slave_core_count > 1)
				break;
			snprintf(vdev_args, sizeof(vdev_args),
					""%s%d"", temp_str, i);
			strcpy(temp_str, vdev_args);
",1,unused,377,unused,"			if (slave_core_count > 1)
				break;
			snprintf(vdev_args, sizeof(vdev_args),
					""%s%d"", temp_str, i);
			strcpy(temp_str, vdev_args);
",unused,PavanNikhilesh_dpdk-app2Ftest2Ftest_cryptodev.c
"				break;
			snprintf(vdev_args, sizeof(vdev_args),
					""%s%d"", temp_str, i);
			strcpy(temp_str, vdev_args);
			strcat(temp_str, "";"");
",1,unused,378,unused,"				break;
			snprintf(vdev_args, sizeof(vdev_args),
					""%s%d"", temp_str, i);
			strcpy(temp_str, vdev_args);
			strcat(temp_str, "";"");
",unused,PavanNikhilesh_dpdk-app2Ftest2Ftest_cryptodev.c
"				""two slave cores to run. ""
				""Please use the correct coremask.\n"");
			return TEST_FAILED;
		}
		strcpy(temp_str, vdev_args);
",1,unused,389,unused,"				""two slave cores to run. ""
				""Please use the correct coremask.\n"");
			return TEST_FAILED;
		}
		strcpy(temp_str, vdev_args);
",unused,PavanNikhilesh_dpdk-app2Ftest2Ftest_cryptodev.c
"
	/* add the max port for rx_adapter */
	port_index = rte_eth_dev_count_total();
	for (; port_index < RTE_MAX_ETHPORTS; port_index += 1) {
		sprintf(driver_name, ""%s%u"", ""net_null"", drv_id);
",1,unused,482,unused,"
	/* add the max port for rx_adapter */
	port_index = rte_eth_dev_count_total();
	for (; port_index < RTE_MAX_ETHPORTS; port_index += 1) {
		sprintf(driver_name, ""%s%u"", ""net_null"", drv_id);
",unused,PavanNikhilesh_dpdk-app2Ftest2Ftest_event_eth_rx_adapter.c
"	memset(ts_params, 0, sizeof(*ts_params));

	uparams.auth = RTE_CRYPTO_SYM_XFORM_AUTH;
	uparams.cipher = RTE_CRYPTO_SYM_XFORM_CIPHER;
	strcpy(uparams.auth_algo, ""null"");
",1,unused,293,unused,"	memset(ts_params, 0, sizeof(*ts_params));

	uparams.auth = RTE_CRYPTO_SYM_XFORM_AUTH;
	uparams.cipher = RTE_CRYPTO_SYM_XFORM_CIPHER;
	strcpy(uparams.auth_algo, ""null"");
",unused,PavanNikhilesh_dpdk-app2Ftest2Ftest_ipsec.c
"
	uparams.auth = RTE_CRYPTO_SYM_XFORM_AUTH;
	uparams.cipher = RTE_CRYPTO_SYM_XFORM_CIPHER;
	strcpy(uparams.auth_algo, ""null"");
	strcpy(uparams.cipher_algo, ""null"");
",1,unused,294,unused,"
	uparams.auth = RTE_CRYPTO_SYM_XFORM_AUTH;
	uparams.cipher = RTE_CRYPTO_SYM_XFORM_CIPHER;
	strcpy(uparams.auth_algo, ""null"");
	strcpy(uparams.cipher_algo, ""null"");
",unused,PavanNikhilesh_dpdk-app2Ftest2Ftest_ipsec.c
"			char fm_name[16];
			snprintf(fm_name, 16, ""fm%d-mac%d"", i, j);
			if (strcmp(fm_name, sep) == 0) {
				if (out_name)
					strcpy(out_name, sep);
",1,unused,410,unused,"			char fm_name[16];
			snprintf(fm_name, 16, ""fm%d-mac%d"", i, j);
			if (strcmp(fm_name, sep) == 0) {
				if (out_name)
					strcpy(out_name, sep);
",unused,PavanNikhilesh_dpdk-drivers2Fbus2Fdpaa2Fdpaa_bus.c
"
		snprintf(sec_name, 16, ""dpaa-sec%d"", i);
		if (strcmp(sec_name, sep) == 0) {
			if (out_name)
				strcpy(out_name, sep);
",1,unused,422,unused,"
		snprintf(sec_name, 16, ""dpaa-sec%d"", i);
		if (strcmp(sec_name, sep) == 0) {
			if (out_name)
				strcpy(out_name, sep);
",unused,PavanNikhilesh_dpdk-drivers2Fbus2Fdpaa2Fdpaa_bus.c
"	}
	free(dname);

	if (addr)
		strcpy(addr, name);
",1,unused,270,unused,"	}
	free(dname);

	if (addr)
		strcpy(addr, name);
",unused,PavanNikhilesh_dpdk-drivers2Fbus2Ffslmc2Ffslmc_bus.c
"	EVENTDEV_INIT_FUNC_TRACE();

	RTE_SET_USED(port_conf);

	sprintf(event_port_name, ""event-port-%d"", port_id);
",1,unused,539,unused,"	EVENTDEV_INIT_FUNC_TRACE();

	RTE_SET_USED(port_conf);

	sprintf(event_port_name, ""event-port-%d"", port_id);
",unused,PavanNikhilesh_dpdk-drivers2Fevent2Fdpaa22Fdpaa2_eventdev.c
"	unsigned int i;

	for (i = 0; i < RTE_DIM(dsw_dev_xstats) && i < size; i++) {
		ids[i] = i;
		strcpy(xstats_names[i].name, dsw_dev_xstats[i].name);
",1,unused,161,unused,"	unsigned int i;

	for (i = 0; i < RTE_DIM(dsw_dev_xstats) && i < size; i++) {
		ids[i] = i;
		strcpy(xstats_names[i].name, dsw_dev_xstats[i].name);
",unused,PavanNikhilesh_dpdk-drivers2Fevent2Fdsw2Fdsw_xstats.c
"	if (n < xstats_count || !xstats_names)
		return xstats_count;

	for (stat = 0; stat < ENA_STATS_ARRAY_GLOBAL; stat++, count++)
		strcpy(xstats_names[count].name,
",1,unused,2472,unused,"	if (n < xstats_count || !xstats_names)
		return xstats_count;

	for (stat = 0; stat < ENA_STATS_ARRAY_GLOBAL; stat++, count++)
		strcpy(xstats_names[count].name,
",unused,PavanNikhilesh_dpdk-drivers2Fnet2Fena2Fena_ethdev.c
"
	memset(&address, 0, sizeof(struct sockaddr));

	address.sa_family = AF_UNIX;
	strcpy(address.sa_data, ""/tmp/nfp_cpp"");
",1,unused,3250,unused,"
	memset(&address, 0, sizeof(struct sockaddr));

	address.sa_family = AF_UNIX;
	strcpy(address.sa_data, ""/tmp/nfp_cpp"");
",unused,PavanNikhilesh_dpdk-drivers2Fnet2Fnfp2Fnfp_net.c
"
	/* Looking for firmware file in order of priority */

	/* First try to find a firmware image specific for this device */
	sprintf(serial, ""serial-%02x-%02x-%02x-%02x-%02x-%02x-%02x-%02x"",
",1,unused,3436,unused,"
	/* Looking for firmware file in order of priority */

	/* First try to find a firmware image specific for this device */
	sprintf(serial, ""serial-%02x-%02x-%02x-%02x-%02x-%02x-%02x-%02x"",
",unused,PavanNikhilesh_dpdk-drivers2Fnet2Fnfp2Fnfp_net.c
"		cpp->serial[0], cpp->serial[1], cpp->serial[2], cpp->serial[3],
		cpp->serial[4], cpp->serial[5], cpp->interface >> 8,
		cpp->interface & 0xff);

	sprintf(fw_name, ""%s/%s.nffw"", DEFAULT_FW_PATH, serial);
",1,unused,3441,unused,"		cpp->serial[0], cpp->serial[1], cpp->serial[2], cpp->serial[3],
		cpp->serial[4], cpp->serial[5], cpp->interface >> 8,
		cpp->interface & 0xff);

	sprintf(fw_name, ""%s/%s.nffw"", DEFAULT_FW_PATH, serial);
",unused,PavanNikhilesh_dpdk-drivers2Fnet2Fnfp2Fnfp_net.c
"	if (fw_f > 0)
		goto read_fw;

	/* Then try the PCI name */
	sprintf(fw_name, ""%s/pci-%s.nffw"", DEFAULT_FW_PATH, dev->device.name);
",1,unused,3449,unused,"	if (fw_f > 0)
		goto read_fw;

	/* Then try the PCI name */
	sprintf(fw_name, ""%s/pci-%s.nffw"", DEFAULT_FW_PATH, dev->device.name);
",unused,PavanNikhilesh_dpdk-drivers2Fnet2Fnfp2Fnfp_net.c
"	if (fw_f > 0)
		goto read_fw;

	/* Finally try the card type and media */
	sprintf(fw_name, ""%s/%s"", DEFAULT_FW_PATH, card);
",1,unused,3457,unused,"	if (fw_f > 0)
		goto read_fw;

	/* Finally try the card type and media */
	sprintf(fw_name, ""%s/%s"", DEFAULT_FW_PATH, card);
",unused,PavanNikhilesh_dpdk-drivers2Fnet2Fnfp2Fnfp_net.c
"			   nfp_eth_table->count);

	PMD_DRV_LOG(INFO, ""Port speed: %u"", nfp_eth_table->ports[0].speed);

	sprintf(card_desc, ""nic_%s_%dx%d.nffw"", nfp_fw_model,
",1,unused,3533,unused,"			   nfp_eth_table->count);

	PMD_DRV_LOG(INFO, ""Port speed: %u"", nfp_eth_table->ports[0].speed);

	sprintf(card_desc, ""nic_%s_%dx%d.nffw"", nfp_fw_model,
",unused,PavanNikhilesh_dpdk-drivers2Fnet2Fnfp2Fnfp_net.c
"	home_path = getenv(""HOME"");
	lockfile = calloc(strlen(home_path) + strlen(lockname) + 1,
			  sizeof(char));

	strcat(lockfile, home_path);
",1,unused,691,unused,"	home_path = getenv(""HOME"");
	lockfile = calloc(strlen(home_path) + strlen(lockname) + 1,
			  sizeof(char));

	strcat(lockfile, home_path);
",unused,PavanNikhilesh_dpdk-drivers2Fnet2Fnfp2Fnfpcore2Fnfp_cpp_pcie_ops.c
"	lockfile = calloc(strlen(home_path) + strlen(lockname) + 1,
			  sizeof(char));

	strcat(lockfile, home_path);
	strcat(lockfile, ""/.lock_nfp_secondary"");
",1,unused,692,unused,"	lockfile = calloc(strlen(home_path) + strlen(lockname) + 1,
			  sizeof(char));

	strcat(lockfile, home_path);
	strcat(lockfile, ""/.lock_nfp_secondary"");
",unused,PavanNikhilesh_dpdk-drivers2Fnet2Fnfp2Fnfpcore2Fnfp_cpp_pcie_ops.c
"	for (j = 0; j < RTE_DIM(qede_tunn_types); j++) {
		if (filter == qede_tunn_types[j].rte_filter_type) {
			*type = qede_tunn_types[j].qede_type;
			*clss = qede_tunn_types[j].qede_tunn_clss;
			strcpy(str, qede_tunn_types[j].string);
",1,unused,969,unused,"	for (j = 0; j < RTE_DIM(qede_tunn_types); j++) {
		if (filter == qede_tunn_types[j].rte_filter_type) {
			*type = qede_tunn_types[j].qede_type;
			*clss = qede_tunn_types[j].qede_tunn_clss;
			strcpy(str, qede_tunn_types[j].string);
",unused,PavanNikhilesh_dpdk-drivers2Fnet2Fqede2Fqede_filter.c
"	struct stat st;
	const char *fw = RTE_LIBRTE_QEDE_FW;

	if (strcmp(fw, """") == 0)
		strcpy(qede_fw_file, QEDE_DEFAULT_FIRMWARE);
",1,unused,129,unused,"	struct stat st;
	const char *fw = RTE_LIBRTE_QEDE_FW;

	if (strcmp(fw, """") == 0)
		strcpy(qede_fw_file, QEDE_DEFAULT_FIRMWARE);
",unused,PavanNikhilesh_dpdk-drivers2Fnet2Fqede2Fqede_main.c
"
	if (strcmp(fw, """") == 0)
		strcpy(qede_fw_file, QEDE_DEFAULT_FIRMWARE);
	else
		strcpy(qede_fw_file, fw);
",1,unused,131,unused,"
	if (strcmp(fw, """") == 0)
		strcpy(qede_fw_file, QEDE_DEFAULT_FIRMWARE);
	else
		strcpy(qede_fw_file, fw);
",unused,PavanNikhilesh_dpdk-drivers2Fnet2Fqede2Fqede_main.c
"	}

	/* find default container's IOMMU type */
	p->req = SOCKET_REQ_IOMMU_TYPE;
	strcpy(mp_req.name, EAL_VFIO_MP);
",1,unused,575,unused,"	}

	/* find default container's IOMMU type */
	p->req = SOCKET_REQ_IOMMU_TYPE;
	strcpy(mp_req.name, EAL_VFIO_MP);
",unused,PavanNikhilesh_dpdk-lib2Flibrte_eal2Flinuxapp2Feal2Feal_vfio.c
"		return -1;
	}

	p->req = SOCKET_REQ_DEFAULT_CONTAINER;
	strcpy(mp_req.name, EAL_VFIO_MP);
",1,unused,1041,unused,"		return -1;
	}

	p->req = SOCKET_REQ_DEFAULT_CONTAINER;
	strcpy(mp_req.name, EAL_VFIO_MP);
",unused,PavanNikhilesh_dpdk-lib2Flibrte_eal2Flinuxapp2Feal2Feal_vfio.c
"	 * process via mp channel.
	 */
	p->req = SOCKET_REQ_GROUP;
	p->group_num = iommu_group_num;
	strcpy(mp_req.name, EAL_VFIO_MP);
",1,unused,307,unused,"	 * process via mp channel.
	 */
	p->req = SOCKET_REQ_GROUP;
	p->group_num = iommu_group_num;
	strcpy(mp_req.name, EAL_VFIO_MP);
",unused,PavanNikhilesh_dpdk-lib2Flibrte_eal2Flinuxapp2Feal2Feal_vfio.c
"	 * if we're in a secondary process, request container fd from the
	 * primary process via mp channel
	 */
	p->req = SOCKET_REQ_CONTAINER;
	strcpy(mp_req.name, EAL_VFIO_MP);
",1,unused,1171,unused,"	 * if we're in a secondary process, request container fd from the
	 * primary process via mp channel
	 */
	p->req = SOCKET_REQ_CONTAINER;
	strcpy(mp_req.name, EAL_VFIO_MP);
",unused,PavanNikhilesh_dpdk-lib2Flibrte_eal2Flinuxapp2Feal2Feal_vfio.c
"		RTE_LOG(ERR, EAL, ""vfio received invalid message!\n"");
		return -1;
	}

	strcpy(reply.name, EAL_VFIO_MP);
",1,unused,101,unused,"		RTE_LOG(ERR, EAL, ""vfio received invalid message!\n"");
		return -1;
	}

	strcpy(reply.name, EAL_VFIO_MP);
",unused,PavanNikhilesh_dpdk-lib2Flibrte_eal2Flinuxapp2Feal2Feal_vfio_mp_sync.c
"	adapter->socket_id = socket_id;
	adapter->conf_cb = conf_cb;
	adapter->conf_arg = conf_arg;
	adapter->mode = mode;
	strcpy(adapter->mem_name, mem_name);
",1,unused,250,unused,"	adapter->socket_id = socket_id;
	adapter->conf_cb = conf_cb;
	adapter->conf_arg = conf_arg;
	adapter->mode = mode;
	strcpy(adapter->mem_name, mem_name);
",unused,PavanNikhilesh_dpdk-lib2Flibrte_eventdev2Frte_event_crypto_adapter.c
"
	char pfi_str[32];
	uint64_t p0_empty_deq;

	sprintf(pfi_str, ""%02d"", freq);
",1,unused,162,unused,"
	char pfi_str[32];
	uint64_t p0_empty_deq;

	sprintf(pfi_str, ""%02d"", freq);
",unused,PavanNikhilesh_dpdk-lib2Flibrte_power2Frte_power_empty_poll.c
"
  nsh_output(vtbl, ""%s:\n"", msg);
  for (i = 0; i < nbytes; i += 16)
    {
      sprintf(line, ""%04x: "", i);
",1,unused,311,unused,"
  nsh_output(vtbl, ""%s:\n"", msg);
  for (i = 0; i < nbytes; i += 16)
    {
      sprintf(line, ""%04x: "", i);
",unused,Pixhawk-build2Fnuttx_px4fmu-v5_default2FNuttX2Fapps2Fnshlib2Fnsh_dbgcmds.c
"      for ( j = 0; j < 16; j++)
        {
          if (i + j < nbytes)
            {
              sprintf(&line[strlen(line)], ""%02x "", buffer[i+j] );
",1,unused,317,unused,"      for ( j = 0; j < 16; j++)
        {
          if (i + j < nbytes)
            {
              sprintf(&line[strlen(line)], ""%02x "", buffer[i+j] );
",unused,Pixhawk-build2Fnuttx_px4fmu-v5_default2FNuttX2Fapps2Fnshlib2Fnsh_dbgcmds.c
"              sprintf(&line[strlen(line)], ""%02x "", buffer[i+j] );
            }
          else
            {
              strcpy(&line[strlen(line)], ""   "");
",1,unused,321,unused,"              sprintf(&line[strlen(line)], ""%02x "", buffer[i+j] );
            }
          else
            {
              strcpy(&line[strlen(line)], ""   "");
",unused,Pixhawk-build2Fnuttx_px4fmu-v5_default2FNuttX2Fapps2Fnshlib2Fnsh_dbgcmds.c
"        {
          if (i + j < nbytes)
            {
              ch = buffer[i+j];
              sprintf(&line[strlen(line)], ""%c"", ch >= 0x20 && ch <= 0x7e ? ch : '.');
",1,unused,330,unused,"        {
          if (i + j < nbytes)
            {
              ch = buffer[i+j];
              sprintf(&line[strlen(line)], ""%c"", ch >= 0x20 && ch <= 0x7e ? ch : '.');
",unused,Pixhawk-build2Fnuttx_px4fmu-v5_default2FNuttX2Fapps2Fnshlib2Fnsh_dbgcmds.c
"      len   = strlen(relpath) + 2;
      alloc = (char*)malloc(len);
      if (alloc)
        {
          sprintf(alloc, ""/%s"", relpath);
",1,unused,122,unused,"      len   = strlen(relpath) + 2;
      alloc = (char*)malloc(len);
      if (alloc)
        {
          sprintf(alloc, ""/%s"", relpath);
",unused,Pixhawk-build2Fnuttx_px4fmu-v5_default2FNuttX2Fapps2Fnshlib2Fnsh_envcmds.c
"      len = strlen(dirpath) + strlen(relpath) + 2;
      alloc = (char*)malloc(len);
      if (alloc)
        {
          sprintf(alloc, ""%s/%s"", dirpath, relpath);
",1,unused,131,unused,"      len = strlen(dirpath) + strlen(relpath) + 2;
      alloc = (char*)malloc(len);
      if (alloc)
        {
          sprintf(alloc, ""%s/%s"", dirpath, relpath);
",unused,Pixhawk-build2Fnuttx_px4fmu-v5_default2FNuttX2Fapps2Fnshlib2Fnsh_envcmds.c
"    }
  else
    {
      argument[s1size] = '\0';  /* (In case s1 was NULL) */
      strcat(argument, s2);
",1,unused,958,unused,"    }
  else
    {
      argument[s1size] = '\0';  /* (In case s1 was NULL) */
      strcat(argument, s2);
",unused,Pixhawk-build2Fnuttx_px4fmu-v5_default2FNuttX2Fapps2Fnshlib2Fnsh_parse.c
"
  fcnt = stm32_bbsram_probe(sizes, g_bbsram);

  strncpy(path, devpath, sizeof(path));
  strcat(path, ""%d"");
",1,unused,783,unused,"
  fcnt = stm32_bbsram_probe(sizes, g_bbsram);

  strncpy(path, devpath, sizeof(path));
  strcat(path, ""%d"");
",unused,Pixhawk-build2Fnuttx_px4fmu-v5_default2FNuttX2Fnuttx2Farch2Farm2Fsrc2Fchip2Fstm32_bbsram.c
"#endif /* CONSOLE_UART > 0 */

  /* Register all remaining USARTs */

  strcpy(devname, ""/dev/ttySx"");
",1,unused,2780,unused,"#endif /* CONSOLE_UART > 0 */

  /* Register all remaining USARTs */

  strcpy(devname, ""/dev/ttySx"");
",unused,Pixhawk-build2Fnuttx_px4fmu-v5_default2FNuttX2Fnuttx2Farch2Farm2Fsrc2Fchip2Fstm32_serial.c
"
  fcnt = stm32_bbsram_probe(sizes, g_bbsram);

  strncpy(path, devpath, sizeof(path));
  strcat(path, ""%d"");
",1,unused,783,unused,"
  fcnt = stm32_bbsram_probe(sizes, g_bbsram);

  strncpy(path, devpath, sizeof(path));
  strcat(path, ""%d"");
",unused,Pixhawk-build2Fnuttx_px4fmu-v5_default2FNuttX2Fnuttx2Farch2Farm2Fsrc2Fstm32f72Fstm32_bbsram.c
"#endif /* CONSOLE_UART > 0 */

  /* Register all remaining USARTs */

  strcpy(devname, ""/dev/ttySx"");
",1,unused,2780,unused,"#endif /* CONSOLE_UART > 0 */

  /* Register all remaining USARTs */

  strcpy(devname, ""/dev/ttySx"");
",unused,Pixhawk-build2Fnuttx_px4fmu-v5_default2FNuttX2Fnuttx2Farch2Farm2Fsrc2Fstm32f72Fstm32_serial.c
"#endif

  /* Register the CDC/ACM TTY device */

  sprintf(devname, CDCACM_DEVNAME_FORMAT, minor);
",1,unused,2982,unused,"#endif

  /* Register the CDC/ACM TTY device */

  sprintf(devname, CDCACM_DEVNAME_FORMAT, minor);
",unused,Pixhawk-build2Fnuttx_px4fmu-v5_default2FNuttX2Fnuttx2Fdrivers2Fusbdev2Fcdcacm.c
"#endif

  /* Un-register the CDC/ACM TTY device */

  sprintf(devname, CDCACM_DEVNAME_FORMAT, priv->minor);
",1,unused,3136,unused,"#endif

  /* Un-register the CDC/ACM TTY device */

  sprintf(devname, CDCACM_DEVNAME_FORMAT, priv->minor);
",unused,Pixhawk-build2Fnuttx_px4fmu-v5_default2FNuttX2Fnuttx2Fdrivers2Fusbdev2Fcdcacm.c
"  memcpy(&var->fv_sect[BS_JUMP], var->fv_jump, 3);

  /* 8@3: Usually ""MSWIN4.1"" */

  strcpy((FAR char *)&var->fv_sect[BS_OEMNAME], ""NUTTX   "");
",1,unused,84,unused,"  memcpy(&var->fv_sect[BS_JUMP], var->fv_jump, 3);

  /* 8@3: Usually ""MSWIN4.1"" */

  strcpy((FAR char *)&var->fv_sect[BS_OEMNAME], ""NUTTX   "");
",unused,Pixhawk-build2Fnuttx_px4fmu-v5_default2FNuttX2Fnuttx2Ffs2Ffat2Ffs_writefat.c
"        }

      /* Append the inode name to the directory path */

      sprintf(&dirpath[pathlen], ""/%s"", node->i_name);
",1,unused,113,unused,"        }

      /* Append the inode name to the directory path */

      sprintf(&dirpath[pathlen], ""/%s"", node->i_name);
",unused,Pixhawk-build2Fnuttx_px4fmu-v5_default2FNuttX2Fnuttx2Ffs2Fmount2Ffs_foreachmountpoint.c
"
FAR char *ether_ntoa(FAR const struct ether_addr *addr)
{
  static char buffer[20];
  sprintf(buffer, ""%02x:%02x:%02x:%02x:%02x:%02x"",
",1,unused,64,unused,"
FAR char *ether_ntoa(FAR const struct ether_addr *addr)
{
  static char buffer[20];
  sprintf(buffer, ""%02x:%02x:%02x:%02x:%02x:%02x"",
",unused,Pixhawk-build2Fnuttx_px4fmu-v5_default2FNuttX2Fnuttx2Flibc2Fnet2Flib_etherntoa.c
"    {
      news = (FAR char *)lib_malloc(strlen(s) + 1);
      if (news)
        {
          strcpy(news, s);
",1,unused,58,unused,"    {
      news = (FAR char *)lib_malloc(strlen(s) + 1);
      if (news)
        {
          strcpy(news, s);
",unused,Pixhawk-build2Fnuttx_px4fmu-v5_default2FNuttX2Fnuttx2Flibc2Fstring2Flib_strdup.c
"    }

  /* Copy the cwd to the user buffer */

  strcpy(buf, pwd);
",1,unused,128,unused,"    }

  /* Copy the cwd to the user buffer */

  strcpy(buf, pwd);
",unused,Pixhawk-build2Fnuttx_px4fmu-v5_default2FNuttX2Fnuttx2Flibc2Funistd2Flib_getcwd.c
"  group->tg_envsize = newsize;

  /* Now, put the new name=value string into the environment buffer */

  sprintf(pvar, ""%s=%s"", name, value);
",1,unused,189,unused,"  group->tg_envsize = newsize;

  /* Now, put the new name=value string into the environment buffer */

  sprintf(pvar, ""%s=%s"", name, value);
",unused,Pixhawk-build2Fnuttx_px4fmu-v5_default2FNuttX2Fnuttx2Fsched2Fenviron2Fenv_setenv.c
"   */

  stackargv[0] = str;
  nbytes       = strlen(name) + 1;
  strcpy(str, name);
",1,unused,583,unused,"   */

  stackargv[0] = str;
  nbytes       = strlen(name) + 1;
  strcpy(str, name);
",unused,Pixhawk-build2Fnuttx_px4fmu-v5_default2FNuttX2Fnuttx2Fsched2Ftask2Ftask_setup.c
"       */

      stackargv[i + 1] = str;
      nbytes           = strlen(argv[i]) + 1;
      strcpy(str, argv[i]);
",1,unused,597,unused,"       */

      stackargv[i + 1] = str;
      nbytes           = strlen(argv[i]) + 1;
      strcpy(str, argv[i]);
",unused,Pixhawk-build2Fnuttx_px4fmu-v5_default2FNuttX2Fnuttx2Fsched2Ftask2Ftask_setup.c
"#endif /* CONSOLE_UART > 0 */

  /* Register all remaining USARTs */

  strcpy(devname, ""/dev/ttySx"");
",1,unused,2855,unused,"#endif /* CONSOLE_UART > 0 */

  /* Register all remaining USARTs */

  strcpy(devname, ""/dev/ttySx"");
",unused,Pixhawk-build2Fnuttx_px4io-v2_default2FNuttX2Fnuttx2Farch2Farm2Fsrc2Fchip2Fstm32_serial.c
"#endif /* CONSOLE_UART > 0 */

  /* Register all remaining USARTs */

  strcpy(devname, ""/dev/ttySx"");
",1,unused,2855,unused,"#endif /* CONSOLE_UART > 0 */

  /* Register all remaining USARTs */

  strcpy(devname, ""/dev/ttySx"");
",unused,Pixhawk-build2Fnuttx_px4io-v2_default2FNuttX2Fnuttx2Farch2Farm2Fsrc2Fstm322Fstm32_serial.c
"            }

          /* Append the path segment to this inode and recurse */

          sprintf(&info->path[pathlen], ""/%s"", node->i_name);
",1,unused,135,unused,"            }

          /* Append the path segment to this inode and recurse */

          sprintf(&info->path[pathlen], ""/%s"", node->i_name);
",unused,Pixhawk-build2Fnuttx_px4io-v2_default2FNuttX2Fnuttx2Ffs2Finode2Ffs_foreachinode.c
"
FAR char *ether_ntoa(FAR const struct ether_addr *addr)
{
  static char buffer[20];
  sprintf(buffer, ""%02x:%02x:%02x:%02x:%02x:%02x"",
",1,unused,64,unused,"
FAR char *ether_ntoa(FAR const struct ether_addr *addr)
{
  static char buffer[20];
  sprintf(buffer, ""%02x:%02x:%02x:%02x:%02x:%02x"",
",unused,Pixhawk-build2Fnuttx_px4io-v2_default2FNuttX2Fnuttx2Flibc2Fnet2Flib_etherntoa.c
"    {
      news = (FAR char *)lib_malloc(strlen(s) + 1);
      if (news)
        {
          strcpy(news, s);
",1,unused,58,unused,"    {
      news = (FAR char *)lib_malloc(strlen(s) + 1);
      if (news)
        {
          strcpy(news, s);
",unused,Pixhawk-build2Fnuttx_px4io-v2_default2FNuttX2Fnuttx2Flibc2Fstring2Flib_strdup.c
"   */

  stackargv[0] = str;
  nbytes       = strlen(name) + 1;
  strcpy(str, name);
",1,unused,583,unused,"   */

  stackargv[0] = str;
  nbytes       = strlen(name) + 1;
  strcpy(str, name);
",unused,Pixhawk-build2Fnuttx_px4io-v2_default2FNuttX2Fnuttx2Fsched2Ftask2Ftask_setup.c
"       */

      stackargv[i + 1] = str;
      nbytes           = strlen(argv[i]) + 1;
      strcpy(str, argv[i]);
",1,unused,597,unused,"       */

      stackargv[i + 1] = str;
      nbytes           = strlen(argv[i]) + 1;
      strcpy(str, argv[i]);
",unused,Pixhawk-build2Fnuttx_px4io-v2_default2FNuttX2Fnuttx2Fsched2Ftask2Ftask_setup.c
"   
   //11/14/01 added id string 

   if(njunk > strlen(id_str)+8) {
     sprintf(id_str, ""%s-%s"", PACKAGE, VERSION);
",1,unused,547,unused,"   
   //11/14/01 added id string 

   if(njunk > strlen(id_str)+8) {
     sprintf(id_str, ""%s-%s"", PACKAGE, VERSION);
",unused,Rodinia-heartwall-AVI2Favilib.c
"
   OUT4CC (""ISFT"");
   OUTLONG(MAX_INFO_STRLEN);

   sprintf(id_str, ""%s-%s"", PACKAGE, VERSION);
",1,unused,821,unused,"
   OUT4CC (""ISFT"");
   OUTLONG(MAX_INFO_STRLEN);

   sprintf(id_str, ""%s-%s"", PACKAGE, VERSION);
",unused,Rodinia-heartwall-AVI2Favilib.c
"   
   /* Add index entry */

   //set tag for current audio track
   sprintf((char *)astr, ""0%1dwb"", AVI->aptr+1);
",1,unused,907,unused,"   
   /* Add index entry */

   //set tag for current audio track
   sprintf((char *)astr, ""0%1dwb"", AVI->aptr+1);
",unused,Rodinia-heartwall-AVI2Favilib.c
"      AVI_errno == AVI_ERR_WRITE ||
      AVI_errno == AVI_ERR_WRITE_INDEX ||
      AVI_errno == AVI_ERR_CLOSE )
   {
      sprintf(error_string,""%s - %s"",avi_errors[aerrno],strerror(errno));
",1,unused,1823,unused,"      AVI_errno == AVI_ERR_WRITE ||
      AVI_errno == AVI_ERR_WRITE_INDEX ||
      AVI_errno == AVI_ERR_CLOSE )
   {
      sprintf(error_string,""%s - %s"",avi_errors[aerrno],strerror(errno));
",unused,Rodinia-heartwall-AVI2Favilib.c
"    for (i=0; i < grid_rows; i++) 
      for (j=0; j < grid_cols; j++)
        for (k=0; k < layers; k++)
          {
            sprintf(str, ""%d\t%g\n"", index, vect[i*grid_cols+j+k*grid_rows*grid_cols]);
",1,unused,70,unused,"    for (i=0; i < grid_rows; i++) 
      for (j=0; j < grid_cols; j++)
        for (k=0; k < layers; k++)
          {
            sprintf(str, ""%d\t%g\n"", index, vect[i*grid_cols+j+k*grid_rows*grid_cols]);
",unused,Rodinia-hotspot3D-3D.c
"			}
			// compare each record with max value to find the nearest neighbor
			if( z[i] < neighbors[max_idx].dist ) {
				sandbox[(i+1)*REC_LENGTH-1] = '\0';
			  	strcpy(neighbors[max_idx].entry, sandbox +i*REC_LENGTH);
",1,unused,140,unused,"			}
			// compare each record with max value to find the nearest neighbor
			if( z[i] < neighbors[max_idx].dist ) {
				sandbox[(i+1)*REC_LENGTH-1] = '\0';
			  	strcpy(neighbors[max_idx].entry, sandbox +i*REC_LENGTH);
",unused,Rodinia-nn-nn_openmp.c
"        free(buf);
        return NULL;
    }

    sprintf(buf + 19, compact ? format_milliseconds_compact : format_milliseconds_terse, milliseconds);
",1,unused,77,unused,"        free(buf);
        return NULL;
    }

    sprintf(buf + 19, compact ? format_milliseconds_compact : format_milliseconds_terse, milliseconds);
",unused,S2OPC-csrc2Fhelpers_platform_dep2Fsopc_time.c
"
  result = (char*)malloc(strlen(s) + 1);
  if (result == (char*)0)
    return (char*)0;
  strcpy(result, s);
",1,unused,312,unused,"
  result = (char*)malloc(strlen(s) + 1);
  if (result == (char*)0)
    return (char*)0;
  strcpy(result, s);
",unused,Zialus_IIC-ACEBFA-src2FParser2Fcmdline.c
"
	for (i = 'p'; i <= 'z'; i++) {
		for (j = '0'; j <= 'f'; j++) {
			if (j == '9' + 1) j = 'a';
			sprintf(pty, ""/dev/pty%c%c"", i, j);
",1,unused,189,unused,"
	for (i = 'p'; i <= 'z'; i++) {
		for (j = '0'; j <= 'f'; j++) {
			if (j == '9' + 1) j = 'a';
			sprintf(pty, ""/dev/pty%c%c"", i, j);
",unused,aasysvinitxen-src2Fbootlogd.c
"	for (i = 'p'; i <= 'z'; i++) {
		for (j = '0'; j <= 'f'; j++) {
			if (j == '9' + 1) j = 'a';
			sprintf(pty, ""/dev/pty%c%c"", i, j);
			sprintf(tty, ""/dev/tty%c%c"", i, j);
",1,unused,190,unused,"	for (i = 'p'; i <= 'z'; i++) {
		for (j = '0'; j <= 'f'; j++) {
			if (j == '9' + 1) j = 'a';
			sprintf(pty, ""/dev/pty%c%c"", i, j);
			sprintf(tty, ""/dev/tty%c%c"", i, j);
",unused,aasysvinitxen-src2Fbootlogd.c
"		if (found) break;
	}
	if (!found) return -1;

	if (name) strcpy(name, tty);
",1,unused,203,unused,"		if (found) break;
	}
	if (!found) return -1;

	if (name) strcpy(name, tty);
",unused,aasysvinitxen-src2Fbootlogd.c
"			didnl = 0;
		}
		switch (*ptr) {
			case 27: /* ESC */
				strcpy(tmp, ""^["");
",1,unused,371,unused,"			didnl = 0;
		}
		switch (*ptr) {
			case 27: /* ESC */
				strcpy(tmp, ""^["");
",unused,aasysvinitxen-src2Fbootlogd.c
"				tmp[0] = *ptr;
				tmp[1] = 0;
				break;
			default:
				sprintf(tmp, ""\\%03o"", *ptr);
",1,unused,394,unused,"				tmp[0] = *ptr;
				tmp[1] = 0;
				break;
			default:
				sprintf(tmp, ""\\%03o"", *ptr);
",unused,aasysvinitxen-src2Fbootlogd.c
"	if (consolename(realcons, sizeof(realcons)) < 0)
		return 1;

	if (strcmp(realcons, ""/dev/tty0"") == 0)
		strcpy(realcons, ""/dev/tty1"");
",1,unused,535,unused,"	if (consolename(realcons, sizeof(realcons)) < 0)
		return 1;

	if (strcmp(realcons, ""/dev/tty0"") == 0)
		strcpy(realcons, ""/dev/tty1"");
",unused,aasysvinitxen-src2Fbootlogd.c
"
	if (strcmp(realcons, ""/dev/tty0"") == 0)
		strcpy(realcons, ""/dev/tty1"");
	if (strcmp(realcons, ""/dev/vc/0"") == 0)
		strcpy(realcons, ""/dev/vc/1"");
",1,unused,537,unused,"
	if (strcmp(realcons, ""/dev/tty0"") == 0)
		strcpy(realcons, ""/dev/tty1"");
	if (strcmp(realcons, ""/dev/vc/0"") == 0)
		strcpy(realcons, ""/dev/vc/1"");
",unused,aasysvinitxen-src2Fbootlogd.c
"		if ((pwd = getpwuid(uid)) != NULL) {
			uidbuf[0] = 0;
			strncat(uidbuf, pwd->pw_name, sizeof(uidbuf) - 1);
		} else {
			sprintf(uidbuf, uid ? ""uid %d"" : ""root"", (int)uid);
",1,unused,99,unused,"		if ((pwd = getpwuid(uid)) != NULL) {
			uidbuf[0] = 0;
			strncat(uidbuf, pwd->pw_name, sizeof(uidbuf) - 1);
		} else {
			sprintf(uidbuf, uid ? ""uid %d"" : ""root"", (int)uid);
",unused,aasysvinitxen-src2Fdowall.c
"  /* See if we need to fire off a shell for this command */
  	/* Give command line to shell */
  	args[1] = SHELL;
  	args[2] = ""-c"";
  	strcpy(buf, ""exec "");
",1,unused,999,unused,"  /* See if we need to fire off a shell for this command */
  	/* Give command line to shell */
  	args[1] = SHELL;
  	args[2] = ""-c"";
  	strcpy(buf, ""exec "");
",unused,aasysvinitxen-src2Finit.c
"  		execvp(args[1], args + 1);
		if (errno == ENOEXEC) {
  			args[1] = SHELL;
  			args[2] = ""-c"";
  			strcpy(buf, ""exec "");
",1,unused,1168,unused,"  		execvp(args[1], args + 1);
		if (errno == ENOEXEC) {
  			args[1] = SHELL;
  			args[2] = ""-c"";
  			strcpy(buf, ""exec "");
",unused,aasysvinitxen-src2Finit.c
"	 *	Check if syntax is OK. Be very verbose here, to
	 *	avoid newbie postings on comp.os.linux.setup :)
	 */
	err[0] = 0;
	if (!id || !*id) strcpy(err, ""missing id field"");
",1,unused,1306,unused,"	 *	Check if syntax is OK. Be very verbose here, to
	 *	avoid newbie postings on comp.os.linux.setup :)
	 */
	err[0] = 0;
	if (!id || !*id) strcpy(err, ""missing id field"");
",unused,aasysvinitxen-src2Finit.c
"	 *	avoid newbie postings on comp.os.linux.setup :)
	 */
	err[0] = 0;
	if (!id || !*id) strcpy(err, ""missing id field"");
	if (!rlevel)     strcpy(err, ""missing runlevel field"");
",1,unused,1307,unused,"	 *	avoid newbie postings on comp.os.linux.setup :)
	 */
	err[0] = 0;
	if (!id || !*id) strcpy(err, ""missing id field"");
	if (!rlevel)     strcpy(err, ""missing runlevel field"");
",unused,aasysvinitxen-src2Finit.c
"	 */
	err[0] = 0;
	if (!id || !*id) strcpy(err, ""missing id field"");
	if (!rlevel)     strcpy(err, ""missing runlevel field"");
	if (!process)    strcpy(err, ""missing process field"");
",1,unused,1308,unused,"	 */
	err[0] = 0;
	if (!id || !*id) strcpy(err, ""missing id field"");
	if (!rlevel)     strcpy(err, ""missing runlevel field"");
	if (!process)    strcpy(err, ""missing process field"");
",unused,aasysvinitxen-src2Finit.c
"	if (!id || !*id) strcpy(err, ""missing id field"");
	if (!rlevel)     strcpy(err, ""missing runlevel field"");
	if (!process)    strcpy(err, ""missing process field"");
	if (!action || !*action)
			strcpy(err, ""missing action field"");
",1,unused,1310,unused,"	if (!id || !*id) strcpy(err, ""missing id field"");
	if (!rlevel)     strcpy(err, ""missing runlevel field"");
	if (!process)    strcpy(err, ""missing process field"");
	if (!action || !*action)
			strcpy(err, ""missing action field"");
",unused,aasysvinitxen-src2Finit.c
"	if (!process)    strcpy(err, ""missing process field"");
	if (!action || !*action)
			strcpy(err, ""missing action field"");
	if (id && strlen(id) > sizeof(utproto.ut_id))
		sprintf(err, ""id field too long (max %d characters)"",
",1,unused,1312,unused,"	if (!process)    strcpy(err, ""missing process field"");
	if (!action || !*action)
			strcpy(err, ""missing action field"");
	if (id && strlen(id) > sizeof(utproto.ut_id))
		sprintf(err, ""id field too long (max %d characters)"",
",unused,aasysvinitxen-src2Finit.c
"	if (id && strlen(id) > sizeof(utproto.ut_id))
		sprintf(err, ""id field too long (max %d characters)"",
			(int)sizeof(utproto.ut_id));
	if (rlevel && strlen(rlevel) > 11)
		strcpy(err, ""rlevel field too long (max 11 characters)"");
",1,unused,1315,unused,"	if (id && strlen(id) > sizeof(utproto.ut_id))
		sprintf(err, ""id field too long (max %d characters)"",
			(int)sizeof(utproto.ut_id));
	if (rlevel && strlen(rlevel) > 11)
		strcpy(err, ""rlevel field too long (max 11 characters)"");
",unused,aasysvinitxen-src2Finit.c
"			(int)sizeof(utproto.ut_id));
	if (rlevel && strlen(rlevel) > 11)
		strcpy(err, ""rlevel field too long (max 11 characters)"");
	if (process && strlen(process) > 127)
		strcpy(err, ""process field too long"");
",1,unused,1317,unused,"			(int)sizeof(utproto.ut_id));
	if (rlevel && strlen(rlevel) > 11)
		strcpy(err, ""rlevel field too long (max 11 characters)"");
	if (process && strlen(process) > 127)
		strcpy(err, ""process field too long"");
",unused,aasysvinitxen-src2Finit.c
"		strcpy(err, ""rlevel field too long (max 11 characters)"");
	if (process && strlen(process) > 127)
		strcpy(err, ""process field too long"");
	if (action && strlen(action) > 32)
		strcpy(err, ""action field too long"");
",1,unused,1319,unused,"		strcpy(err, ""rlevel field too long (max 11 characters)"");
	if (process && strlen(process) > 127)
		strcpy(err, ""process field too long"");
	if (action && strlen(action) > 32)
		strcpy(err, ""action field too long"");
",unused,aasysvinitxen-src2Finit.c
"			if (ch->rlevel[f] == 's') ch->rlevel[f] = 'S';
		}
		strncpy(ch->rlevel, rlevel, sizeof(ch->rlevel) - 1);
	} else {
		strcpy(ch->rlevel, ""0123456789"");
",1,unused,1371,unused,"			if (ch->rlevel[f] == 's') ch->rlevel[f] = 'S';
		}
		strncpy(ch->rlevel, rlevel, sizeof(ch->rlevel) - 1);
	} else {
		strcpy(ch->rlevel, ""0123456789"");
",unused,aasysvinitxen-src2Finit.c
"		strncpy(ch->rlevel, rlevel, sizeof(ch->rlevel) - 1);
	} else {
		strcpy(ch->rlevel, ""0123456789"");
		if (ISPOWER(ch->action))
			strcpy(ch->rlevel, ""S0123456789"");
",1,unused,1373,unused,"		strncpy(ch->rlevel, rlevel, sizeof(ch->rlevel) - 1);
	} else {
		strcpy(ch->rlevel, ""0123456789"");
		if (ISPOWER(ch->action))
			strcpy(ch->rlevel, ""S0123456789"");
",unused,aasysvinitxen-src2Finit.c
"	/*
	 *	We have the fake runlevel '#' for SYSINIT  and
	 *	'*' for BOOT and BOOTWAIT.
	 */
	if (ch->action == SYSINIT) strcpy(ch->rlevel, ""#"");
",1,unused,1379,unused,"	/*
	 *	We have the fake runlevel '#' for SYSINIT  and
	 *	'*' for BOOT and BOOTWAIT.
	 */
	if (ch->action == SYSINIT) strcpy(ch->rlevel, ""#"");
",unused,aasysvinitxen-src2Finit.c
"	 *	'*' for BOOT and BOOTWAIT.
	 */
	if (ch->action == SYSINIT) strcpy(ch->rlevel, ""#"");
	if (ch->action == BOOT || ch->action == BOOTWAIT)
		strcpy(ch->rlevel, ""*"");
",1,unused,1381,unused,"	 *	'*' for BOOT and BOOTWAIT.
	 */
	if (ch->action == SYSINIT) strcpy(ch->rlevel, ""#"");
	if (ch->action == BOOT || ch->action == BOOTWAIT)
		strcpy(ch->rlevel, ""*"");
",unused,aasysvinitxen-src2Finit.c
"{
	static char btmp[128];
	char *p;

	strcpy(btmp, WTMP_FILE);
",1,unused,259,unused,"{
	static char btmp[128];
	char *p;

	strcpy(btmp, WTMP_FILE);
",unused,aasysvinitxen-src2Flast.c
"		p = btmp;
	else
		p++;
	*p = 0;
	strcat(btmp, ""btmp"");
",1,unused,265,unused,"		p = btmp;
	else
		p++;
	*p = 0;
	strcat(btmp, ""btmp"");
",unused,aasysvinitxen-src2Flast.c
"	/*
	 *	Calculate times
	 */
	tmp = (time_t)p->ut_time;
	strcpy(logintime, ctime(&tmp));
",1,unused,407,unused,"	/*
	 *	Calculate times
	 */
	tmp = (time_t)p->ut_time;
	strcpy(logintime, ctime(&tmp));
",unused,aasysvinitxen-src2Flast.c
"	 */
	tmp = (time_t)p->ut_time;
	strcpy(logintime, ctime(&tmp));
	if (fulltime)
		sprintf(logouttime, ""- %s"", ctime(&t));
",1,unused,409,unused,"	 */
	tmp = (time_t)p->ut_time;
	strcpy(logintime, ctime(&tmp));
	if (fulltime)
		sprintf(logouttime, ""- %s"", ctime(&t));
",unused,aasysvinitxen-src2Flast.c
"	if (fulltime)
		sprintf(logouttime, ""- %s"", ctime(&t));
	else {
		logintime[16] = 0;
		sprintf(logouttime, ""- %s"", ctime(&t) + 11);
",1,unused,412,unused,"	if (fulltime)
		sprintf(logouttime, ""- %s"", ctime(&t));
	else {
		logintime[16] = 0;
		sprintf(logouttime, ""- %s"", ctime(&t) + 11);
",unused,aasysvinitxen-src2Flast.c
"	mins  = (secs / 60) % 60;
	hours = (secs / 3600) % 24;
	days  = secs / 86400;
	if (days)
		sprintf(length, ""(%d+%02d:%02d)"", days, hours, mins);
",1,unused,420,unused,"	mins  = (secs / 60) % 60;
	hours = (secs / 3600) % 24;
	days  = secs / 86400;
	if (days)
		sprintf(length, ""(%d+%02d:%02d)"", days, hours, mins);
",unused,aasysvinitxen-src2Flast.c
"	days  = secs / 86400;
	if (days)
		sprintf(length, ""(%d+%02d:%02d)"", days, hours, mins);
	else
		sprintf(length, "" (%02d:%02d)"", hours, mins);
",1,unused,422,unused,"	days  = secs / 86400;
	if (days)
		sprintf(length, ""(%d+%02d:%02d)"", days, hours, mins);
	else
		sprintf(length, "" (%02d:%02d)"", hours, mins);
",unused,aasysvinitxen-src2Flast.c
"		sprintf(length, "" (%02d:%02d)"", hours, mins);

	switch(what) {
		case R_CRASH:
			sprintf(logouttime, ""- crash"");
",1,unused,426,unused,"		sprintf(length, "" (%02d:%02d)"", hours, mins);

	switch(what) {
		case R_CRASH:
			sprintf(logouttime, ""- crash"");
",unused,aasysvinitxen-src2Flast.c
"		case R_CRASH:
			sprintf(logouttime, ""- crash"");
			break;
		case R_DOWN:
			sprintf(logouttime, ""- down "");
",1,unused,429,unused,"		case R_CRASH:
			sprintf(logouttime, ""- crash"");
			break;
		case R_DOWN:
			sprintf(logouttime, ""- down "");
",unused,aasysvinitxen-src2Flast.c
"			break;
		case R_NOW:
			length[0] = 0;
			if (fulltime)
				sprintf(logouttime, ""  still logged in"");
",1,unused,434,unused,"			break;
		case R_NOW:
			length[0] = 0;
			if (fulltime)
				sprintf(logouttime, ""  still logged in"");
",unused,aasysvinitxen-src2Flast.c
"			length[0] = 0;
			if (fulltime)
				sprintf(logouttime, ""  still logged in"");
			else {
				sprintf(logouttime, ""  still"");
",1,unused,436,unused,"			length[0] = 0;
			if (fulltime)
				sprintf(logouttime, ""  still logged in"");
			else {
				sprintf(logouttime, ""  still"");
",unused,aasysvinitxen-src2Flast.c
"			if (fulltime)
				sprintf(logouttime, ""  still logged in"");
			else {
				sprintf(logouttime, ""  still"");
				sprintf(length, ""logged in"");
",1,unused,437,unused,"			if (fulltime)
				sprintf(logouttime, ""  still logged in"");
			else {
				sprintf(logouttime, ""  still"");
				sprintf(length, ""logged in"");
",unused,aasysvinitxen-src2Flast.c
"			break;
		case R_PHANTOM:
			length[0] = 0;
			if (fulltime)
				sprintf(logouttime, ""  gone - no logout"");
",1,unused,443,unused,"			break;
		case R_PHANTOM:
			length[0] = 0;
			if (fulltime)
				sprintf(logouttime, ""  gone - no logout"");
",unused,aasysvinitxen-src2Flast.c
"			length[0] = 0;
			if (fulltime)
				sprintf(logouttime, ""  gone - no logout"");
			else {
				sprintf(logouttime, ""   gone"");
",1,unused,445,unused,"			length[0] = 0;
			if (fulltime)
				sprintf(logouttime, ""  gone - no logout"");
			else {
				sprintf(logouttime, ""   gone"");
",unused,aasysvinitxen-src2Flast.c
"			if (fulltime)
				sprintf(logouttime, ""  gone - no logout"");
			else {
				sprintf(logouttime, ""   gone"");
				sprintf(length, ""- no logout"");
",1,unused,446,unused,"			if (fulltime)
				sprintf(logouttime, ""  gone - no logout"");
			else {
				sprintf(logouttime, ""   gone"");
				sprintf(length, ""- no logout"");
",unused,aasysvinitxen-src2Flast.c
"			fprintf(stderr, ""%s: out of memory\n"",
				progname);
			exit(1);
		}
		strcpy(altufile, optarg);
",1,unused,628,unused,"			fprintf(stderr, ""%s: out of memory\n"",
				progname);
			exit(1);
		}
		strcpy(altufile, optarg);
",unused,aasysvinitxen-src2Flast.c
"
	switch (ut.ut_type) {
		case SHUTDOWN_TIME:
			if (extended) {
				strcpy(ut.ut_line, ""system down"");
",1,unused,807,unused,"
	switch (ut.ut_type) {
		case SHUTDOWN_TIME:
			if (extended) {
				strcpy(ut.ut_line, ""system down"");
",unused,aasysvinitxen-src2Flast.c
"			break;
		case OLD_TIME:
		case NEW_TIME:
			if (extended) {
				strcpy(ut.ut_line,
",1,unused,816,unused,"			break;
		case OLD_TIME:
		case NEW_TIME:
			if (extended) {
				strcpy(ut.ut_line,
",unused,aasysvinitxen-src2Flast.c
"				quit = list(&ut, lastdown, R_TIMECHANGE);
			}
			break;
		case BOOT_TIME:
			strcpy(ut.ut_line, ""system boot"");
",1,unused,823,unused,"				quit = list(&ut, lastdown, R_TIMECHANGE);
			}
			break;
		case BOOT_TIME:
			strcpy(ut.ut_line, ""system boot"");
",unused,aasysvinitxen-src2Flast.c
"			break;
		case RUN_LVL:
			x = ut.ut_pid & 255;
			if (extended) {
				sprintf(ut.ut_line, ""(to lvl %c)"", x);
",1,unused,831,unused,"			break;
		case RUN_LVL:
			x = ut.ut_pid & 255;
			if (extended) {
				sprintf(ut.ut_line, ""(to lvl %c)"", x);
",unused,aasysvinitxen-src2Flast.c
"	}

	memset(buf, 0, sizeof(buf));
	strncpy(buf, path, sizeof(buf) - 4);
	strcat(buf, ""/.."");
",1,unused,115,unused,"	}

	memset(buf, 0, sizeof(buf));
	strncpy(buf, path, sizeof(buf) - 4);
	strcat(buf, ""/.."");
",unused,aasysvinitxen-src2Fmountpoint.c
"  		fprintf(stderr, ""shutdown: you must be root to do that!\n"");
		usage();
  		exit(1);
	}
	strcpy(down_level, ""1"");
",1,unused,509,unused,"  		fprintf(stderr, ""shutdown: you must be root to do that!\n"");
		usage();
  		exit(1);
	}
	strcpy(down_level, ""1"");
",unused,aasysvinitxen-src2Fshutdown.c
"		while(!user_ok && (ut = getutent()) != NULL) {

			/* See if this is a user process on a VC. */
			if (ut->ut_type != USER_PROCESS) continue;
			sprintf(term, ""/dev/%.*s"", UT_LINESIZE, ut->ut_line);
",1,unused,593,unused,"		while(!user_ok && (ut = getutent()) != NULL) {

			/* See if this is a user process on a VC. */
			if (ut->ut_type != USER_PROCESS) continue;
			sprintf(term, ""/dev/%.*s"", UT_LINESIZE, ut->ut_line);
",unused,aasysvinitxen-src2Fshutdown.c
"	message[0] = 0;
	for(c = optind + (!cancel && !when); c < argc; c++) {
		if (strlen(message) + strlen(argv[c]) + 4 > MESSAGELEN)
			break;
  		strcat(message, argv[c]);
",1,unused,639,unused,"	message[0] = 0;
	for(c = optind + (!cancel && !when); c < argc; c++) {
		if (strlen(message) + strlen(argv[c]) + 4 > MESSAGELEN)
			break;
  		strcat(message, argv[c]);
",unused,aasysvinitxen-src2Fshutdown.c
"	for(c = optind + (!cancel && !when); c < argc; c++) {
		if (strlen(message) + strlen(argv[c]) + 4 > MESSAGELEN)
			break;
  		strcat(message, argv[c]);
  		strcat(message, "" "");
",1,unused,640,unused,"	for(c = optind + (!cancel && !when); c < argc; c++) {
		if (strlen(message) + strlen(argv[c]) + 4 > MESSAGELEN)
			break;
  		strcat(message, argv[c]);
  		strcat(message, "" "");
",unused,aasysvinitxen-src2Fshutdown.c
"			break;
  		strcat(message, argv[c]);
  		strcat(message, "" "");
	}
	if (message[0]) strcat(message, ""\r\n"");
",1,unused,642,unused,"			break;
  		strcat(message, argv[c]);
  		strcat(message, "" "");
	}
	if (message[0]) strcat(message, ""\r\n"");
",unused,aasysvinitxen-src2Fshutdown.c
"
	/* Tell users what we're gonna do. */
	switch(down_level[0]) {
		case '0':
			strcpy(newstate, ""for system halt"");
",1,unused,682,unused,"
	/* Tell users what we're gonna do. */
	switch(down_level[0]) {
		case '0':
			strcpy(newstate, ""for system halt"");
",unused,aasysvinitxen-src2Fshutdown.c
"		case '0':
			strcpy(newstate, ""for system halt"");
			break;
		case '6':
			strcpy(newstate, ""for reboot"");
",1,unused,685,unused,"		case '0':
			strcpy(newstate, ""for system halt"");
			break;
		case '6':
			strcpy(newstate, ""for reboot"");
",unused,aasysvinitxen-src2Fshutdown.c
"		case '6':
			strcpy(newstate, ""for reboot"");
			break;
		case '1':
			strcpy(newstate, ""to maintenance mode"");
",1,unused,688,unused,"		case '6':
			strcpy(newstate, ""for reboot"");
			break;
		case '1':
			strcpy(newstate, ""to maintenance mode"");
",unused,aasysvinitxen-src2Fshutdown.c
"		case '1':
			strcpy(newstate, ""to maintenance mode"");
			break;
		default:
			sprintf(newstate, ""to runlevel %s"", down_level);
",1,unused,691,unused,"		case '1':
			strcpy(newstate, ""to maintenance mode"");
			break;
		default:
			sprintf(newstate, ""to runlevel %s"", down_level);
",unused,aasysvinitxen-src2Fshutdown.c
"	if (fastboot)  close(open(FASTBOOT,  O_CREAT | O_RDWR, 0644));
	if (forcefsck) close(open(FORCEFSCK, O_CREAT | O_RDWR, 0644));

	/* Alias now and take care of old '+mins' notation. */
	if (!strcmp(when, ""now"")) strcpy(when, ""0"");
",1,unused,724,unused,"	if (fastboot)  close(open(FASTBOOT,  O_CREAT | O_RDWR, 0644));
	if (forcefsck) close(open(FORCEFSCK, O_CREAT | O_RDWR, 0644));

	/* Alias now and take care of old '+mins' notation. */
	if (!strcmp(when, ""now"")) strcpy(when, ""0"");
",unused,aasysvinitxen-src2Fshutdown.c
"	/*
	 *	The password is invalid. If there is a
	 *	shadow password, try it.
	 */
	strcpy(pwd.pw_passwd, """");
",1,unused,310,unused,"	/*
	 *	The password is invalid. If there is a
	 *	shadow password, try it.
	 */
	strcpy(pwd.pw_passwd, """");
",unused,aasysvinitxen-src2Fsulogin.c
"	 *	NULL it, and return.
	 */
	if (p == NULL) {
		fprintf(stderr, ""%s: no entry for root\n"", F_SHADOW);
		strcpy(pwd.pw_passwd, """");
",1,unused,330,unused,"	 *	NULL it, and return.
	 */
	if (p == NULL) {
		fprintf(stderr, ""%s: no entry for root\n"", F_SHADOW);
		strcpy(pwd.pw_passwd, """");
",unused,aasysvinitxen-src2Fsulogin.c
"		strcpy(pwd.pw_passwd, """");
	}
	if (!valid(pwd.pw_passwd)) {
		fprintf(stderr, ""%s: root password garbled\n"", F_SHADOW);
		strcpy(pwd.pw_passwd, """"); }
",1,unused,334,unused,"		strcpy(pwd.pw_passwd, """");
	}
	if (!valid(pwd.pw_passwd)) {
		fprintf(stderr, ""%s: root password garbled\n"", F_SHADOW);
		strcpy(pwd.pw_passwd, """"); }
",unused,aasysvinitxen-src2Fsulogin.c
"  if ((argc - optind) > 0) {
	for(f = optind; f < argc; f++) {
		len += strlen(argv[f]) + 1;
		if (len >= MAXLEN-2) break;
		strcat(buf, argv[f]);
",1,unused,85,unused,"  if ((argc - optind) > 0) {
	for(f = optind; f < argc; f++) {
		len += strlen(argv[f]) + 1;
		if (len >= MAXLEN-2) break;
		strcat(buf, argv[f]);
",unused,aasysvinitxen-src2Fwall.c
"	for(f = optind; f < argc; f++) {
		len += strlen(argv[f]) + 1;
		if (len >= MAXLEN-2) break;
		strcat(buf, argv[f]);
		if (f < argc-1) strcat(buf, "" "");
",1,unused,86,unused,"	for(f = optind; f < argc; f++) {
		len += strlen(argv[f]) + 1;
		if (len >= MAXLEN-2) break;
		strcat(buf, argv[f]);
		if (f < argc-1) strcat(buf, "" "");
",unused,aasysvinitxen-src2Fwall.c
"		if (len >= MAXLEN-2) break;
		strcat(buf, argv[f]);
		if (f < argc-1) strcat(buf, "" "");
	}
	strcat(buf, ""\r\n"");
",1,unused,88,unused,"		if (len >= MAXLEN-2) break;
		strcat(buf, argv[f]);
		if (f < argc-1) strcat(buf, "" "");
	}
	strcat(buf, ""\r\n"");
",unused,aasysvinitxen-src2Fwall.c
"		 *	Make sure that line ends in \r\n
		 */
		for(p = line; *p && *p != '\r' && *p != '\n'; p++)
			;
		strcpy(p, ""\r\n"");
",1,unused,96,unused,"		 *	Make sure that line ends in \r\n
		 */
		for(p = line; *p && *p != '\r' && *p != '\n'; p++)
			;
		strcpy(p, ""\r\n"");
",unused,aasysvinitxen-src2Fwall.c
"			;
		strcpy(p, ""\r\n"");
		len += strlen(line);
		if (len >= MAXLEN) break;
		strcat(buf, line);
",1,unused,99,unused,"			;
		strcpy(p, ""\r\n"");
		len += strlen(line);
		if (len >= MAXLEN) break;
		strcat(buf, line);
",unused,aasysvinitxen-src2Fwall.c
"		ap_cur->target = 1;
		ap_cur->wpa.state = 7;
		ap_cur->wpa.keyver = (uint8_t)(opt.amode & 0xFF);
		strcpy(ap_cur->essid, ""sorbo"");
		strcpy((char *) ap_cur->bssid, ""deadb"");
",1,unused,6301,unused,"		ap_cur->target = 1;
		ap_cur->wpa.state = 7;
		ap_cur->wpa.keyver = (uint8_t)(opt.amode & 0xFF);
		strcpy(ap_cur->essid, ""sorbo"");
		strcpy((char *) ap_cur->bssid, ""deadb"");
",unused,aircrack-ng-jbenden-src2Faircrack-ng.c
"
		strbuf[0] = 0;
		strcat(strbuf, "" BSSID              PWR "");

		if (G.singlechan) strcat(strbuf, ""RXQ "");
",1,unused,3704,unused,"
		strbuf[0] = 0;
		strcat(strbuf, "" BSSID              PWR "");

		if (G.singlechan) strcat(strbuf, ""RXQ "");
",unused,aircrack-ng-jbenden-src2Fairodump-ng.c
"		if (G.singlechan) strcat(strbuf, ""RXQ "");

		strcat(strbuf, "" Beacons    #Data, #/s  CH  MB   ENC  CIPHER AUTH "");

		if (G.show_uptime) strcat(strbuf, ""       UPTIME  "");
",1,unused,3708,unused,"		if (G.singlechan) strcat(strbuf, ""RXQ "");

		strcat(strbuf, "" Beacons    #Data, #/s  CH  MB   ENC  CIPHER AUTH "");

		if (G.show_uptime) strcat(strbuf, ""       UPTIME  "");
",unused,aircrack-ng-jbenden-src2Fairodump-ng.c
"
		/*
		  Log driver register, MAINT driver ID is '0'
		*/
		len = sprintf(tmp, ""DIMAINT - drv # %d = '%s' registered"",
",1,unused,454,unused,"
		/*
		  Log driver register, MAINT driver ID is '0'
		*/
		len = sprintf(tmp, ""DIMAINT - drv # %d = '%s' registered"",
",unused,android-kernel-htc-msm8974-travis-drivers2Fisdn2Fhardware2Feicon2Fdebug.c
"
			/*
			  Log driver register, MAINT driver ID is '0'
			*/
			len = sprintf(tmp, ""DIMAINT - drv # %d = '%s' de-registered"",
",1,unused,526,unused,"
			/*
			  Log driver register, MAINT driver ID is '0'
			*/
			len = sprintf(tmp, ""DIMAINT - drv # %d = '%s' de-registered"",
",unused,android-kernel-htc-msm8974-travis-drivers2Fisdn2Fhardware2Feicon2Fdebug.c
"
	/*
	  Log driver register, MAINT driver ID is '0'
	*/
	len = sprintf(tmp, ""DIMAINT - drv # %d = '%s' registered"",
",1,unused,982,unused,"
	/*
	  Log driver register, MAINT driver ID is '0'
	*/
	len = sprintf(tmp, ""DIMAINT - drv # %d = '%s' registered"",
",unused,android-kernel-htc-msm8974-travis-drivers2Fisdn2Fhardware2Feicon2Fdebug.c
"
			/*
			  Log driver register, MAINT driver ID is '0'
			*/
			len = sprintf(tmp, ""DIMAINT - drv # %d = '%s' de-registered"",
",1,unused,1067,unused,"
			/*
			  Log driver register, MAINT driver ID is '0'
			*/
			len = sprintf(tmp, ""DIMAINT - drv # %d = '%s' de-registered"",
",unused,android-kernel-htc-msm8974-travis-drivers2Fisdn2Fhardware2Feicon2Fdebug.c
"	}

	if (pLib->ChannelsTraceActive < pLib->Channels) {
		pLib->ChannelsTraceActive++;
		sprintf(name, ""State\\B%d\\Line"", pLib->ChannelsTraceActive);
",1,unused,491,unused,"	}

	if (pLib->ChannelsTraceActive < pLib->Channels) {
		pLib->ChannelsTraceActive++;
		sprintf(name, ""State\\B%d\\Line"", pLib->ChannelsTraceActive);
",unused,android-kernel-htc-msm8974-travis-drivers2Fisdn2Fhardware2Feicon2Fmaintidi.c
"	}

	if (pLib->ModemTraceActive < pLib->Channels) {
		pLib->ModemTraceActive++;
		sprintf(name, ""State\\B%d\\Modem\\Event"", pLib->ModemTraceActive);
",1,unused,502,unused,"	}

	if (pLib->ModemTraceActive < pLib->Channels) {
		pLib->ModemTraceActive++;
		sprintf(name, ""State\\B%d\\Modem\\Event"", pLib->ModemTraceActive);
",unused,android-kernel-htc-msm8974-travis-drivers2Fisdn2Fhardware2Feicon2Fmaintidi.c
"	}

	if (pLib->FaxTraceActive < pLib->Channels) {
		pLib->FaxTraceActive++;
		sprintf(name, ""State\\B%d\\FAX\\Event"", pLib->FaxTraceActive);
",1,unused,513,unused,"	}

	if (pLib->FaxTraceActive < pLib->Channels) {
		pLib->FaxTraceActive++;
		sprintf(name, ""State\\B%d\\FAX\\Event"", pLib->FaxTraceActive);
",unused,android-kernel-htc-msm8974-travis-drivers2Fisdn2Fhardware2Feicon2Fmaintidi.c
"	}

	for (i = 0; i < 30; i++) {
		if (pLib->pending_line_status & (1L << i)) {
			sprintf(name, ""State\\B%d"", i + 1);
",1,unused,686,unused,"	}

	for (i = 0; i < 30; i++) {
		if (pLib->pending_line_status & (1L << i)) {
			sprintf(name, ""State\\B%d"", i + 1);
",unused,android-kernel-htc-msm8974-travis-drivers2Fisdn2Fhardware2Feicon2Fmaintidi.c
"			pLib->req_busy = 1;
			return (0);
		}
		if (pLib->pending_modem_status & (1L << i)) {
			sprintf(name, ""State\\B%d\\Modem"", i + 1);
",1,unused,695,unused,"			pLib->req_busy = 1;
			return (0);
		}
		if (pLib->pending_modem_status & (1L << i)) {
			sprintf(name, ""State\\B%d\\Modem"", i + 1);
",unused,android-kernel-htc-msm8974-travis-drivers2Fisdn2Fhardware2Feicon2Fmaintidi.c
"			pLib->req_busy = 1;
			return (0);
		}
		if (pLib->pending_fax_status & (1L << i)) {
			sprintf(name, ""State\\B%d\\FAX"", i + 1);
",1,unused,704,unused,"			pLib->req_busy = 1;
			return (0);
		}
		if (pLib->pending_fax_status & (1L << i)) {
			sprintf(name, ""State\\B%d\\FAX"", i + 1);
",unused,android-kernel-htc-msm8974-travis-drivers2Fisdn2Fhardware2Feicon2Fmaintidi.c
"			pLib->req_busy = 1;
			return (0);
		}
		if (pLib->clear_call_command & (1L << i)) {
			sprintf(name, ""State\\B%d\\Clear Call"", i + 1);
",1,unused,713,unused,"			pLib->req_busy = 1;
			return (0);
		}
		if (pLib->clear_call_command & (1L << i)) {
			sprintf(name, ""State\\B%d\\Clear Call"", i + 1);
",unused,android-kernel-htc-msm8974-travis-drivers2Fisdn2Fhardware2Feicon2Fmaintidi.c
"	}

	if (!pLib->IncomingCallsCallsActive) {
		pLib->IncomingCallsCallsActive = 1;
		sprintf(name, ""%s"", ""Statistics\\Incoming Calls\\Calls"");
",1,unused,813,unused,"	}

	if (!pLib->IncomingCallsCallsActive) {
		pLib->IncomingCallsCallsActive = 1;
		sprintf(name, ""%s"", ""Statistics\\Incoming Calls\\Calls"");
",unused,android-kernel-htc-msm8974-travis-drivers2Fisdn2Fhardware2Feicon2Fmaintidi.c
"		return (0);
	}
	if (!pLib->IncomingCallsConnectedActive) {
		pLib->IncomingCallsConnectedActive = 1;
		sprintf(name, ""%s"", ""Statistics\\Incoming Calls\\Connected"");
",1,unused,823,unused,"		return (0);
	}
	if (!pLib->IncomingCallsConnectedActive) {
		pLib->IncomingCallsConnectedActive = 1;
		sprintf(name, ""%s"", ""Statistics\\Incoming Calls\\Connected"");
",unused,android-kernel-htc-msm8974-travis-drivers2Fisdn2Fhardware2Feicon2Fmaintidi.c
"		return (0);
	}
	if (!pLib->OutgoingCallsCallsActive) {
		pLib->OutgoingCallsCallsActive = 1;
		sprintf(name, ""%s"", ""Statistics\\Outgoing Calls\\Calls"");
",1,unused,833,unused,"		return (0);
	}
	if (!pLib->OutgoingCallsCallsActive) {
		pLib->OutgoingCallsCallsActive = 1;
		sprintf(name, ""%s"", ""Statistics\\Outgoing Calls\\Calls"");
",unused,android-kernel-htc-msm8974-travis-drivers2Fisdn2Fhardware2Feicon2Fmaintidi.c
"		return (0);
	}
	if (!pLib->OutgoingCallsConnectedActive) {
		pLib->OutgoingCallsConnectedActive = 1;
		sprintf(name, ""%s"", ""Statistics\\Outgoing Calls\\Connected"");
",1,unused,843,unused,"		return (0);
	}
	if (!pLib->OutgoingCallsConnectedActive) {
		pLib->OutgoingCallsConnectedActive = 1;
		sprintf(name, ""%s"", ""Statistics\\Outgoing Calls\\Connected"");
",unused,android-kernel-htc-msm8974-travis-drivers2Fisdn2Fhardware2Feicon2Fmaintidi.c
"	/*
	  First look for Line Event
	*/
	for (i = 1; i <= pLib->Channels; i++) {
		sprintf(name, ""State\\B%d\\Line"", i);
",1,unused,913,unused,"	/*
	  First look for Line Event
	*/
	for (i = 1; i <= pLib->Channels; i++) {
		sprintf(name, ""State\\B%d\\Line"", i);
",unused,android-kernel-htc-msm8974-travis-drivers2Fisdn2Fhardware2Feicon2Fmaintidi.c
"	/*
	  Look for Moden Progress Event
	*/
	for (i = 1; i <= pLib->Channels; i++) {
		sprintf(name, ""State\\B%d\\Modem\\Event"", i);
",1,unused,923,unused,"	/*
	  Look for Moden Progress Event
	*/
	for (i = 1; i <= pLib->Channels; i++) {
		sprintf(name, ""State\\B%d\\Modem\\Event"", i);
",unused,android-kernel-htc-msm8974-travis-drivers2Fisdn2Fhardware2Feicon2Fmaintidi.c
"	/*
	  Look for Fax Event
	*/
	for (i = 1; i <= pLib->Channels; i++) {
		sprintf(name, ""State\\B%d\\FAX\\Event"", i);
",1,unused,933,unused,"	/*
	  Look for Fax Event
	*/
	for (i = 1; i <= pLib->Channels; i++) {
		sprintf(name, ""State\\B%d\\FAX\\Event"", i);
",unused,android-kernel-htc-msm8974-travis-drivers2Fisdn2Fhardware2Feicon2Fmaintidi.c
"	/*
	  First look for Modem Status Info
	*/
	for (i = pLib->Channels; i > 0; i--) {
		len = sprintf(name, ""State\\B%d\\Modem"", i);
",1,unused,1063,unused,"	/*
	  First look for Modem Status Info
	*/
	for (i = pLib->Channels; i > 0; i--) {
		len = sprintf(name, ""State\\B%d\\Modem"", i);
",unused,android-kernel-htc-msm8974-travis-drivers2Fisdn2Fhardware2Feicon2Fmaintidi.c
"	/*
	  Look for Fax Status Info
	*/
	for (i = pLib->Channels; i > 0; i--) {
		len = sprintf(name, ""State\\B%d\\FAX"", i);
",1,unused,1073,unused,"	/*
	  Look for Fax Status Info
	*/
	for (i = pLib->Channels; i > 0; i--) {
		len = sprintf(name, ""State\\B%d\\FAX"", i);
",unused,android-kernel-htc-msm8974-travis-drivers2Fisdn2Fhardware2Feicon2Fmaintidi.c
"	/*
	  Look for Line Status Info
	*/
	for (i = pLib->Channels; i > 0; i--) {
		len = sprintf(name, ""State\\B%d"", i);
",1,unused,1083,unused,"	/*
	  Look for Line Status Info
	*/
	for (i = pLib->Channels; i > 0; i--) {
		len = sprintf(name, ""State\\B%d"", i);
",unused,android-kernel-htc-msm8974-travis-drivers2Fisdn2Fhardware2Feicon2Fmaintidi.c
"	pLine->ChannelNumber = nr;

	pLib->line_parse_entry_first[Channel] = pLib->cur_parse_entry;

	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
",1,unused,1264,unused,"	pLine->ChannelNumber = nr;

	pLib->line_parse_entry_first[Channel] = pLib->cur_parse_entry;

	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
",unused,android-kernel-htc-msm8974-travis-drivers2Fisdn2Fhardware2Feicon2Fmaintidi.c
"	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
		""State\\B%d\\Framing"", nr);
	pLib->parse_table[pLib->cur_parse_entry++].variable = &pLine->Framing[0];

	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
",1,unused,1268,unused,"	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
		""State\\B%d\\Framing"", nr);
	pLib->parse_table[pLib->cur_parse_entry++].variable = &pLine->Framing[0];

	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
",unused,android-kernel-htc-msm8974-travis-drivers2Fisdn2Fhardware2Feicon2Fmaintidi.c
"	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
		""State\\B%d\\Line"", nr);
	pLib->parse_table[pLib->cur_parse_entry++].variable = &pLine->Line[0];

	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
",1,unused,1272,unused,"	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
		""State\\B%d\\Line"", nr);
	pLib->parse_table[pLib->cur_parse_entry++].variable = &pLine->Line[0];

	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
",unused,android-kernel-htc-msm8974-travis-drivers2Fisdn2Fhardware2Feicon2Fmaintidi.c
"	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
		""State\\B%d\\Layer2"", nr);
	pLib->parse_table[pLib->cur_parse_entry++].variable = &pLine->Layer2[0];

	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
",1,unused,1276,unused,"	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
		""State\\B%d\\Layer2"", nr);
	pLib->parse_table[pLib->cur_parse_entry++].variable = &pLine->Layer2[0];

	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
",unused,android-kernel-htc-msm8974-travis-drivers2Fisdn2Fhardware2Feicon2Fmaintidi.c
"	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
		""State\\B%d\\Layer3"", nr);
	pLib->parse_table[pLib->cur_parse_entry++].variable = &pLine->Layer3[0];

	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
",1,unused,1280,unused,"	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
		""State\\B%d\\Layer3"", nr);
	pLib->parse_table[pLib->cur_parse_entry++].variable = &pLine->Layer3[0];

	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
",unused,android-kernel-htc-msm8974-travis-drivers2Fisdn2Fhardware2Feicon2Fmaintidi.c
"		""State\\B%d\\Remote Address"", nr);
	pLib->parse_table[pLib->cur_parse_entry++].variable = \
		&pLine->RemoteAddress[0];

	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
",1,unused,1285,unused,"		""State\\B%d\\Remote Address"", nr);
	pLib->parse_table[pLib->cur_parse_entry++].variable = \
		&pLine->RemoteAddress[0];

	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
",unused,android-kernel-htc-msm8974-travis-drivers2Fisdn2Fhardware2Feicon2Fmaintidi.c
"		""State\\B%d\\Remote SubAddr"", nr);
	pLib->parse_table[pLib->cur_parse_entry++].variable = \
		&pLine->RemoteSubAddress[0];

	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
",1,unused,1290,unused,"		""State\\B%d\\Remote SubAddr"", nr);
	pLib->parse_table[pLib->cur_parse_entry++].variable = \
		&pLine->RemoteSubAddress[0];

	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
",unused,android-kernel-htc-msm8974-travis-drivers2Fisdn2Fhardware2Feicon2Fmaintidi.c
"		""State\\B%d\\Local Address"", nr);
	pLib->parse_table[pLib->cur_parse_entry++].variable = \
		&pLine->LocalAddress[0];

	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
",1,unused,1295,unused,"		""State\\B%d\\Local Address"", nr);
	pLib->parse_table[pLib->cur_parse_entry++].variable = \
		&pLine->LocalAddress[0];

	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
",unused,android-kernel-htc-msm8974-travis-drivers2Fisdn2Fhardware2Feicon2Fmaintidi.c
"		""State\\B%d\\Local SubAddr"", nr);
	pLib->parse_table[pLib->cur_parse_entry++].variable = \
		&pLine->LocalSubAddress[0];

	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
",1,unused,1300,unused,"		""State\\B%d\\Local SubAddr"", nr);
	pLib->parse_table[pLib->cur_parse_entry++].variable = \
		&pLine->LocalSubAddress[0];

	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
",unused,android-kernel-htc-msm8974-travis-drivers2Fisdn2Fhardware2Feicon2Fmaintidi.c
"	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
		""State\\B%d\\BC"", nr);
	pLib->parse_table[pLib->cur_parse_entry++].variable = &pLine->call_BC;

	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
",1,unused,1304,unused,"	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
		""State\\B%d\\BC"", nr);
	pLib->parse_table[pLib->cur_parse_entry++].variable = &pLine->call_BC;

	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
",unused,android-kernel-htc-msm8974-travis-drivers2Fisdn2Fhardware2Feicon2Fmaintidi.c
"	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
		""State\\B%d\\HLC"", nr);
	pLib->parse_table[pLib->cur_parse_entry++].variable = &pLine->call_HLC;

	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
",1,unused,1308,unused,"	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
		""State\\B%d\\HLC"", nr);
	pLib->parse_table[pLib->cur_parse_entry++].variable = &pLine->call_HLC;

	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
",unused,android-kernel-htc-msm8974-travis-drivers2Fisdn2Fhardware2Feicon2Fmaintidi.c
"	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
		""State\\B%d\\LLC"", nr);
	pLib->parse_table[pLib->cur_parse_entry++].variable = &pLine->call_LLC;

	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
",1,unused,1312,unused,"	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
		""State\\B%d\\LLC"", nr);
	pLib->parse_table[pLib->cur_parse_entry++].variable = &pLine->call_LLC;

	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
",unused,android-kernel-htc-msm8974-travis-drivers2Fisdn2Fhardware2Feicon2Fmaintidi.c
"	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
		""State\\B%d\\Charges"", nr);
	pLib->parse_table[pLib->cur_parse_entry++].variable = &pLine->Charges;

	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
",1,unused,1316,unused,"	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
		""State\\B%d\\Charges"", nr);
	pLib->parse_table[pLib->cur_parse_entry++].variable = &pLine->Charges;

	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
",unused,android-kernel-htc-msm8974-travis-drivers2Fisdn2Fhardware2Feicon2Fmaintidi.c
"	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
		""State\\B%d\\Call Reference"", nr);
	pLib->parse_table[pLib->cur_parse_entry++].variable = &pLine->CallReference;

	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
",1,unused,1320,unused,"	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
		""State\\B%d\\Call Reference"", nr);
	pLib->parse_table[pLib->cur_parse_entry++].variable = &pLine->CallReference;

	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
",unused,android-kernel-htc-msm8974-travis-drivers2Fisdn2Fhardware2Feicon2Fmaintidi.c
"		""State\\B%d\\Last Disc Cause"", nr);
	pLib->parse_table[pLib->cur_parse_entry++].variable = \
		&pLine->LastDisconnecCause;

	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
",1,unused,1325,unused,"		""State\\B%d\\Last Disc Cause"", nr);
	pLib->parse_table[pLib->cur_parse_entry++].variable = \
		&pLine->LastDisconnecCause;

	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
",unused,android-kernel-htc-msm8974-travis-drivers2Fisdn2Fhardware2Feicon2Fmaintidi.c
"	pFax->ChannelNumber = nr;

	pLib->fax_parse_entry_first[Channel] = pLib->cur_parse_entry;

	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
",1,unused,1345,unused,"	pFax->ChannelNumber = nr;

	pLib->fax_parse_entry_first[Channel] = pLib->cur_parse_entry;

	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
",unused,android-kernel-htc-msm8974-travis-drivers2Fisdn2Fhardware2Feicon2Fmaintidi.c
"	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
		""State\\B%d\\FAX\\Event"", nr);
	pLib->parse_table[pLib->cur_parse_entry++].variable = &pFax->Event;

	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
",1,unused,1349,unused,"	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
		""State\\B%d\\FAX\\Event"", nr);
	pLib->parse_table[pLib->cur_parse_entry++].variable = &pFax->Event;

	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
",unused,android-kernel-htc-msm8974-travis-drivers2Fisdn2Fhardware2Feicon2Fmaintidi.c
"	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
		""State\\B%d\\FAX\\Page Counter"", nr);
	pLib->parse_table[pLib->cur_parse_entry++].variable = &pFax->Page_Counter;

	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
",1,unused,1353,unused,"	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
		""State\\B%d\\FAX\\Page Counter"", nr);
	pLib->parse_table[pLib->cur_parse_entry++].variable = &pFax->Page_Counter;

	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
",unused,android-kernel-htc-msm8974-travis-drivers2Fisdn2Fhardware2Feicon2Fmaintidi.c
"	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
		""State\\B%d\\FAX\\Features"", nr);
	pLib->parse_table[pLib->cur_parse_entry++].variable = &pFax->Features;

	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
",1,unused,1357,unused,"	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
		""State\\B%d\\FAX\\Features"", nr);
	pLib->parse_table[pLib->cur_parse_entry++].variable = &pFax->Features;

	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
",unused,android-kernel-htc-msm8974-travis-drivers2Fisdn2Fhardware2Feicon2Fmaintidi.c
"	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
		""State\\B%d\\FAX\\Station ID"", nr);
	pLib->parse_table[pLib->cur_parse_entry++].variable = &pFax->Station_ID[0];

	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
",1,unused,1361,unused,"	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
		""State\\B%d\\FAX\\Station ID"", nr);
	pLib->parse_table[pLib->cur_parse_entry++].variable = &pFax->Station_ID[0];

	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
",unused,android-kernel-htc-msm8974-travis-drivers2Fisdn2Fhardware2Feicon2Fmaintidi.c
"	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
		""State\\B%d\\FAX\\Subaddress"", nr);
	pLib->parse_table[pLib->cur_parse_entry++].variable = &pFax->Subaddress[0];

	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
",1,unused,1365,unused,"	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
		""State\\B%d\\FAX\\Subaddress"", nr);
	pLib->parse_table[pLib->cur_parse_entry++].variable = &pFax->Subaddress[0];

	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
",unused,android-kernel-htc-msm8974-travis-drivers2Fisdn2Fhardware2Feicon2Fmaintidi.c
"	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
		""State\\B%d\\FAX\\Password"", nr);
	pLib->parse_table[pLib->cur_parse_entry++].variable = &pFax->Password[0];

	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
",1,unused,1369,unused,"	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
		""State\\B%d\\FAX\\Password"", nr);
	pLib->parse_table[pLib->cur_parse_entry++].variable = &pFax->Password[0];

	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
",unused,android-kernel-htc-msm8974-travis-drivers2Fisdn2Fhardware2Feicon2Fmaintidi.c
"	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
		""State\\B%d\\FAX\\Speed"", nr);
	pLib->parse_table[pLib->cur_parse_entry++].variable = &pFax->Speed;

	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
",1,unused,1373,unused,"	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
		""State\\B%d\\FAX\\Speed"", nr);
	pLib->parse_table[pLib->cur_parse_entry++].variable = &pFax->Speed;

	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
",unused,android-kernel-htc-msm8974-travis-drivers2Fisdn2Fhardware2Feicon2Fmaintidi.c
"	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
		""State\\B%d\\FAX\\Resolution"", nr);
	pLib->parse_table[pLib->cur_parse_entry++].variable = &pFax->Resolution;

	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
",1,unused,1377,unused,"	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
		""State\\B%d\\FAX\\Resolution"", nr);
	pLib->parse_table[pLib->cur_parse_entry++].variable = &pFax->Resolution;

	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
",unused,android-kernel-htc-msm8974-travis-drivers2Fisdn2Fhardware2Feicon2Fmaintidi.c
"	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
		""State\\B%d\\FAX\\Paper Width"", nr);
	pLib->parse_table[pLib->cur_parse_entry++].variable = &pFax->Paper_Width;

	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
",1,unused,1381,unused,"	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
		""State\\B%d\\FAX\\Paper Width"", nr);
	pLib->parse_table[pLib->cur_parse_entry++].variable = &pFax->Paper_Width;

	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
",unused,android-kernel-htc-msm8974-travis-drivers2Fisdn2Fhardware2Feicon2Fmaintidi.c
"	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
		""State\\B%d\\FAX\\Paper Length"", nr);
	pLib->parse_table[pLib->cur_parse_entry++].variable = &pFax->Paper_Length;

	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
",1,unused,1385,unused,"	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
		""State\\B%d\\FAX\\Paper Length"", nr);
	pLib->parse_table[pLib->cur_parse_entry++].variable = &pFax->Paper_Length;

	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
",unused,android-kernel-htc-msm8974-travis-drivers2Fisdn2Fhardware2Feicon2Fmaintidi.c
"	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
		""State\\B%d\\FAX\\Scanline Time"", nr);
	pLib->parse_table[pLib->cur_parse_entry++].variable = &pFax->Scanline_Time;

	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
",1,unused,1389,unused,"	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
		""State\\B%d\\FAX\\Scanline Time"", nr);
	pLib->parse_table[pLib->cur_parse_entry++].variable = &pFax->Scanline_Time;

	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
",unused,android-kernel-htc-msm8974-travis-drivers2Fisdn2Fhardware2Feicon2Fmaintidi.c
"	pModem->ChannelNumber = nr;

	pLib->modem_parse_entry_first[Channel] = pLib->cur_parse_entry;

	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
",1,unused,1409,unused,"	pModem->ChannelNumber = nr;

	pLib->modem_parse_entry_first[Channel] = pLib->cur_parse_entry;

	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
",unused,android-kernel-htc-msm8974-travis-drivers2Fisdn2Fhardware2Feicon2Fmaintidi.c
"	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
		""State\\B%d\\Modem\\Event"", nr);
	pLib->parse_table[pLib->cur_parse_entry++].variable = &pModem->Event;

	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
",1,unused,1413,unused,"	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
		""State\\B%d\\Modem\\Event"", nr);
	pLib->parse_table[pLib->cur_parse_entry++].variable = &pModem->Event;

	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
",unused,android-kernel-htc-msm8974-travis-drivers2Fisdn2Fhardware2Feicon2Fmaintidi.c
"	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
		""State\\B%d\\Modem\\Norm"", nr);
	pLib->parse_table[pLib->cur_parse_entry++].variable = &pModem->Norm;

	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
",1,unused,1417,unused,"	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
		""State\\B%d\\Modem\\Norm"", nr);
	pLib->parse_table[pLib->cur_parse_entry++].variable = &pModem->Norm;

	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
",unused,android-kernel-htc-msm8974-travis-drivers2Fisdn2Fhardware2Feicon2Fmaintidi.c
"	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
		""State\\B%d\\Modem\\Options"", nr);
	pLib->parse_table[pLib->cur_parse_entry++].variable = &pModem->Options;

	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
",1,unused,1421,unused,"	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
		""State\\B%d\\Modem\\Options"", nr);
	pLib->parse_table[pLib->cur_parse_entry++].variable = &pModem->Options;

	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
",unused,android-kernel-htc-msm8974-travis-drivers2Fisdn2Fhardware2Feicon2Fmaintidi.c
"	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
		""State\\B%d\\Modem\\TX Speed"", nr);
	pLib->parse_table[pLib->cur_parse_entry++].variable = &pModem->TxSpeed;

	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
",1,unused,1425,unused,"	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
		""State\\B%d\\Modem\\TX Speed"", nr);
	pLib->parse_table[pLib->cur_parse_entry++].variable = &pModem->TxSpeed;

	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
",unused,android-kernel-htc-msm8974-travis-drivers2Fisdn2Fhardware2Feicon2Fmaintidi.c
"	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
		""State\\B%d\\Modem\\RX Speed"", nr);
	pLib->parse_table[pLib->cur_parse_entry++].variable = &pModem->RxSpeed;

	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
",1,unused,1429,unused,"	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
		""State\\B%d\\Modem\\RX Speed"", nr);
	pLib->parse_table[pLib->cur_parse_entry++].variable = &pModem->RxSpeed;

	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
",unused,android-kernel-htc-msm8974-travis-drivers2Fisdn2Fhardware2Feicon2Fmaintidi.c
"	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
		""State\\B%d\\Modem\\Roundtrip ms"", nr);
	pLib->parse_table[pLib->cur_parse_entry++].variable = &pModem->RoundtripMsec;

	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
",1,unused,1433,unused,"	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
		""State\\B%d\\Modem\\Roundtrip ms"", nr);
	pLib->parse_table[pLib->cur_parse_entry++].variable = &pModem->RoundtripMsec;

	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
",unused,android-kernel-htc-msm8974-travis-drivers2Fisdn2Fhardware2Feicon2Fmaintidi.c
"	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
		""State\\B%d\\Modem\\Symbol Rate"", nr);
	pLib->parse_table[pLib->cur_parse_entry++].variable = &pModem->SymbolRate;

	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
",1,unused,1437,unused,"	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
		""State\\B%d\\Modem\\Symbol Rate"", nr);
	pLib->parse_table[pLib->cur_parse_entry++].variable = &pModem->SymbolRate;

	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
",unused,android-kernel-htc-msm8974-travis-drivers2Fisdn2Fhardware2Feicon2Fmaintidi.c
"	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
		""State\\B%d\\Modem\\RX Level dBm"", nr);
	pLib->parse_table[pLib->cur_parse_entry++].variable = &pModem->RxLeveldBm;

	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
",1,unused,1441,unused,"	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
		""State\\B%d\\Modem\\RX Level dBm"", nr);
	pLib->parse_table[pLib->cur_parse_entry++].variable = &pModem->RxLeveldBm;

	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
",unused,android-kernel-htc-msm8974-travis-drivers2Fisdn2Fhardware2Feicon2Fmaintidi.c
"	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
		""State\\B%d\\Modem\\Echo Level dBm"", nr);
	pLib->parse_table[pLib->cur_parse_entry++].variable = &pModem->EchoLeveldBm;

	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
",1,unused,1445,unused,"	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
		""State\\B%d\\Modem\\Echo Level dBm"", nr);
	pLib->parse_table[pLib->cur_parse_entry++].variable = &pModem->EchoLeveldBm;

	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
",unused,android-kernel-htc-msm8974-travis-drivers2Fisdn2Fhardware2Feicon2Fmaintidi.c
"	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
		""State\\B%d\\Modem\\SNR dB"", nr);
	pLib->parse_table[pLib->cur_parse_entry++].variable = &pModem->SNRdb;

	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
",1,unused,1449,unused,"	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
		""State\\B%d\\Modem\\SNR dB"", nr);
	pLib->parse_table[pLib->cur_parse_entry++].variable = &pModem->SNRdb;

	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
",unused,android-kernel-htc-msm8974-travis-drivers2Fisdn2Fhardware2Feicon2Fmaintidi.c
"	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
		""State\\B%d\\Modem\\MAE"", nr);
	pLib->parse_table[pLib->cur_parse_entry++].variable = &pModem->MAE;

	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
",1,unused,1453,unused,"	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
		""State\\B%d\\Modem\\MAE"", nr);
	pLib->parse_table[pLib->cur_parse_entry++].variable = &pModem->MAE;

	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
",unused,android-kernel-htc-msm8974-travis-drivers2Fisdn2Fhardware2Feicon2Fmaintidi.c
"	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
		""State\\B%d\\Modem\\Local Retrains"", nr);
	pLib->parse_table[pLib->cur_parse_entry++].variable = &pModem->LocalRetrains;

	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
",1,unused,1457,unused,"	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
		""State\\B%d\\Modem\\Local Retrains"", nr);
	pLib->parse_table[pLib->cur_parse_entry++].variable = &pModem->LocalRetrains;

	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
",unused,android-kernel-htc-msm8974-travis-drivers2Fisdn2Fhardware2Feicon2Fmaintidi.c
"	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
		""State\\B%d\\Modem\\Remote Retrains"", nr);
	pLib->parse_table[pLib->cur_parse_entry++].variable = &pModem->RemoteRetrains;

	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
",1,unused,1461,unused,"	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
		""State\\B%d\\Modem\\Remote Retrains"", nr);
	pLib->parse_table[pLib->cur_parse_entry++].variable = &pModem->RemoteRetrains;

	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
",unused,android-kernel-htc-msm8974-travis-drivers2Fisdn2Fhardware2Feicon2Fmaintidi.c
"	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
		""State\\B%d\\Modem\\Local Resyncs"", nr);
	pLib->parse_table[pLib->cur_parse_entry++].variable = &pModem->LocalResyncs;

	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
",1,unused,1465,unused,"	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
		""State\\B%d\\Modem\\Local Resyncs"", nr);
	pLib->parse_table[pLib->cur_parse_entry++].variable = &pModem->LocalResyncs;

	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
",unused,android-kernel-htc-msm8974-travis-drivers2Fisdn2Fhardware2Feicon2Fmaintidi.c
"	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
		""State\\B%d\\Modem\\Remote Resyncs"", nr);
	pLib->parse_table[pLib->cur_parse_entry++].variable = &pModem->RemoteResyncs;

	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
",1,unused,1469,unused,"	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
		""State\\B%d\\Modem\\Remote Resyncs"", nr);
	pLib->parse_table[pLib->cur_parse_entry++].variable = &pModem->RemoteResyncs;

	sprintf(pLib->parse_table[pLib->cur_parse_entry].path,
",unused,android-kernel-htc-msm8974-travis-drivers2Fisdn2Fhardware2Feicon2Fmaintidi.c
"	if (!ret)
		goto out;

	for (i = 0; i < len; i++) {
		sprintf(buf, ""%.2s"", hexstring);
",1,unused,145,unused,"	if (!ret)
		goto out;

	for (i = 0; i < len; i++) {
		sprintf(buf, ""%.2s"", hexstring);
",unused,apparmor-src2Flibaalogparse.c
"  if ((2*sizeof(void *) + 2) > bsz) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,&ptr,sizeof(void *));
  if (strlen(name) + 1 > (bsz - (r - buff))) return 0;
  strcpy(r,name);
",1,unused,664,unused,"  if ((2*sizeof(void *) + 2) > bsz) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,&ptr,sizeof(void *));
  if (strlen(name) + 1 > (bsz - (r - buff))) return 0;
  strcpy(r,name);
",unused,apparmor-swig2Fperl2Flibapparmor_wrap.c
"  char *r = result;
  if ((2*sz + 1 + strlen(SWIG_Perl_TypeProxyName(type))) > 1000) return;
  *(r++) = '_';
  r = SWIG_PackData(r,ptr,sz);
  strcpy(r,SWIG_Perl_TypeProxyName(type));
",1,unused,1251,unused,"  char *r = result;
  if ((2*sz + 1 + strlen(SWIG_Perl_TypeProxyName(type))) > 1000) return;
  *(r++) = '_';
  r = SWIG_PackData(r,ptr,sz);
  strcpy(r,SWIG_Perl_TypeProxyName(type));
",unused,apparmor-swig2Fperl2Flibapparmor_wrap.c
"  if ((2*sizeof(void *) + 2) > bsz) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,&ptr,sizeof(void *));
  if (strlen(name) + 1 > (bsz - (r - buff))) return 0;
  strcpy(r,name);
",1,unused,674,unused,"  if ((2*sizeof(void *) + 2) > bsz) return 0;
  *(r++) = '_';
  r = SWIG_PackData(r,&ptr,sizeof(void *));
  if (strlen(name) + 1 > (bsz - (r - buff))) return 0;
  strcpy(r,name);
",unused,apparmor-swig2Fpython2Flibapparmor_wrap.c
"
	  /* +3 because we possibly add one more character below. */
	  RESIZE_MALLOCED_BUFFER (line, llen, (vlen + 3), line_len, (vlen + 50));

	  strcpy (line + llen, v);
",1,unused,562,unused,"
	  /* +3 because we possibly add one more character below. */
	  RESIZE_MALLOCED_BUFFER (line, llen, (vlen + 3), line_len, (vlen + 50));

	  strcpy (line + llen, v);
",unused,bashdebstretche-alias.c
"			t = quoted ? quote_string(element_value(ae)) : element_value(ae);
			reg = strlen(t);
			RESIZE_MALLOCED_BUFFER (result, rlen, (reg + slen + 2),
						rsize, rsize);
			strcpy(result + rlen, t);
",1,unused,838,unused,"			t = quoted ? quote_string(element_value(ae)) : element_value(ae);
			reg = strlen(t);
			RESIZE_MALLOCED_BUFFER (result, rlen, (reg + slen + 2),
						rsize, rsize);
			strcpy(result + rlen, t);
",unused,bashdebstretche-array.c
"			/*
			 * Add a separator only after non-null elements.
			 */
			if (element_forw(ae) != end) {
				strcpy(result + rlen, sep);
",1,unused,846,unused,"			/*
			 * Add a separator only after non-null elements.
			 */
			if (element_forw(ae) != end) {
				strcpy(result + rlen, sep);
",unused,bashdebstretche-array.c
"		elen = STRLEN (is) + 8 + STRLEN (valstr);
		RESIZE_MALLOCED_BUFFER (result, rlen, (elen + 1), rsize, rsize);

		result[rlen++] = '[';
		strcpy (result + rlen, is);
",1,unused,884,unused,"		elen = STRLEN (is) + 8 + STRLEN (valstr);
		RESIZE_MALLOCED_BUFFER (result, rlen, (elen + 1), rsize, rsize);

		result[rlen++] = '[';
		strcpy (result + rlen, is);
",unused,bashdebstretche-array.c
"		rlen += STRLEN (is);
		result[rlen++] = ']';
		result[rlen++] = '=';
		if (valstr) {
			strcpy (result + rlen, valstr);
",1,unused,889,unused,"		rlen += STRLEN (is);
		result[rlen++] = ']';
		result[rlen++] = '=';
		if (valstr) {
			strcpy (result + rlen, valstr);
",unused,bashdebstretche-array.c
"	elen = STRLEN (istr) + 8 + STRLEN (vstr);
	RESIZE_MALLOCED_BUFFER (ret, rlen, (elen+1), rsize, rsize);

	ret[rlen++] = '[';
	strcpy (ret+rlen, istr);
",1,unused,457,unused,"	elen = STRLEN (istr) + 8 + STRLEN (vstr);
	RESIZE_MALLOCED_BUFFER (ret, rlen, (elen+1), rsize, rsize);

	ret[rlen++] = '[';
	strcpy (ret+rlen, istr);
",unused,bashdebstretche-assoc.c
"	ret[rlen++] = ']';
	ret[rlen++] = '=';
	if (vstr)
	  {
	    strcpy (ret + rlen, vstr);
",1,unused,463,unused,"	ret[rlen++] = ']';
	ret[rlen++] = '=';
	if (vstr)
	  {
	    strcpy (ret + rlen, vstr);
",unused,bashdebstretche-assoc.c
"	  new_line = (char *)xmalloc (1
				      + curlen
				      + strlen (line)
				      + strlen (chars_to_add));
	  sprintf (new_line, ""%s%s%s"", current->line, chars_to_add, line);
",1,unused,838,unused,"	  new_line = (char *)xmalloc (1
				      + curlen
				      + strlen (line)
				      + strlen (chars_to_add));
	  sprintf (new_line, ""%s%s%s"", current->line, chars_to_add, line);
",unused,bashdebstretche-bashhist.c
"	}
      else
	{
	  nval[0] = '@';
	  strcpy (nval + 1, rl_completer_word_break_characters);
",1,unused,404,unused,"	}
      else
	{
	  nval[0] = '@';
	  strcpy (nval + 1, rl_completer_word_break_characters);
",unused,bashdebstretche-bashline.c
"
  if (rl_explicit_arg)
    {
      command = (char *)xmalloc (strlen (edit_command) + 8);
      sprintf (command, ""%s %d"", edit_command, count);
",1,unused,961,unused,"
  if (rl_explicit_arg)
    {
      command = (char *)xmalloc (strlen (edit_command) + 8);
      sprintf (command, ""%s %d"", edit_command, count);
",unused,bashdebstretche-bashline.c
"	value[0] = *orig_start;
      else
	strncpy (value, orig_start, start_len);

      strcpy (value + start_len, matches[cmd_index]);
",1,unused,2291,unused,"	value[0] = *orig_start;
      else
	strncpy (value, orig_start, start_len);

      strcpy (value + start_len, matches[cmd_index]);
",unused,bashdebstretche-bashline.c
"	  if (first_char_loc == 2)
	    value[1] = '{';
	}

      strcpy (value + first_char_loc, varlist[varlist_index]);
",1,unused,2351,unused,"	  if (first_char_loc == 2)
	    value[1] = '{';
	}

      strcpy (value + first_char_loc, varlist[varlist_index]);
",unused,bashdebstretche-bashline.c
"	}

      strcpy (value + first_char_loc, varlist[varlist_index]);
      if (first_char_loc == 2)
	strcat (value, ""}"");
",1,unused,2353,unused,"	}

      strcpy (value + first_char_loc, varlist[varlist_index]);
      if (first_char_loc == 2)
	strcat (value, ""}"");
",unused,bashdebstretche-bashline.c
"      char *t;

      t = (char *)xmalloc (2 + strlen (list[list_index]));
      *t = first_char;
      strcpy (t + first_char_loc, list[list_index]);
",1,unused,2393,unused,"      char *t;

      t = (char *)xmalloc (2 + strlen (list[list_index]));
      *t = first_char;
      strcpy (t + first_char_loc, list[list_index]);
",unused,bashdebstretche-bashline.c
"  */
  l = (vl - xl) + 1;

  ret = (char *)xmalloc (dl2 + 2 + l);
  strcpy (ret, dh2);
",1,unused,2994,unused,"  */
  l = (vl - xl) + 1;

  ret = (char *)xmalloc (dl2 + 2 + l);
  strcpy (ret, dh2);
",unused,bashdebstretche-bashline.c
"  l = (vl - xl) + 1;

  ret = (char *)xmalloc (dl2 + 2 + l);
  strcpy (ret, dh2);
  strcpy (ret + dl2, val + xl);
",1,unused,2995,unused,"  l = (vl - xl) + 1;

  ret = (char *)xmalloc (dl2 + 2 + l);
  strcpy (ret, dh2);
  strcpy (ret + dl2, val + xl);
",unused,bashdebstretche-bashline.c
"	{
	  globorig = savestring (ttext);
	  glen = strlen (ttext);
	  globtext = (char *)xmalloc (glen + 2);
	  strcpy (globtext, ttext);
",1,unused,3688,unused,"	{
	  globorig = savestring (ttext);
	  glen = strlen (ttext);
	  globtext = (char *)xmalloc (glen + 2);
	  strcpy (globtext, ttext);
",unused,bashdebstretche-bashline.c
"  if (rtext)
    {
      rlen = strlen (rtext);
      ret = (char *)xmalloc (rlen + 1);
      strcpy (ret, rtext);
",1,unused,4034,unused,"  if (rtext)
    {
      rlen = strlen (rtext);
      ret = (char *)xmalloc (rlen + 1);
      strcpy (ret, rtext);
",unused,bashdebstretche-bashline.c
"	  subterm = sh_backslash_quote (x, 0, 0);
	  free (x);
	  result_size += strlen (subterm) + 1;
	  result = (char *)xrealloc (result, result_size);
	  strcat (result, subterm);
",1,unused,133,unused,"	  subterm = sh_backslash_quote (x, 0, 0);
	  free (x);
	  result_size += strlen (subterm) + 1;
	  result = (char *)xrealloc (result, result_size);
	  strcat (result, subterm);
",unused,bashdebstretche-bracecomp.c
"	  result_size += strlen (subterm) + 1;
	  result = (char *)xrealloc (result, result_size);
	  strcat (result, subterm);
	  free (subterm);
	  strcat (result, ""{"");
",1,unused,135,unused,"	  result_size += strlen (subterm) + 1;
	  result = (char *)xrealloc (result, result_size);
	  strcat (result, subterm);
	  free (subterm);
	  strcat (result, ""{"");
",unused,bashdebstretche-bracecomp.c
"	}

      result_size += strlen (subterm) + 1;
      result = (char *)xrealloc (result, result_size);
      strcat (result, subterm);
",1,unused,142,unused,"	}

      result_size += strlen (subterm) + 1;
      result = (char *)xrealloc (result, result_size);
      strcat (result, subterm);
",unused,bashdebstretche-bracecomp.c
"
      result_size += strlen (subterm) + 1;
      result = (char *)xrealloc (result, result_size);
      strcat (result, subterm);
      strcat (result, "","");
",1,unused,143,unused,"
      result_size += strlen (subterm) + 1;
      result = (char *)xrealloc (result, result_size);
      strcat (result, subterm);
      strcat (result, "","");
",unused,bashdebstretche-bracecomp.c
"
      for (j = 0; j < len2; j++)
	{
	  result[len] = (char *)xmalloc (1 + strlen_1 + strlen (arr2[j]));
	  strcpy (result[len], arr1[i]);
",1,unused,803,unused,"
      for (j = 0; j < len2; j++)
	{
	  result[len] = (char *)xmalloc (1 + strlen_1 + strlen (arr2[j]));
	  strcpy (result[len], arr1[i]);
",unused,bashdebstretche-braces.c
"      for (j = 0; j < len2; j++)
	{
	  result[len] = (char *)xmalloc (1 + strlen_1 + strlen (arr2[j]));
	  strcpy (result[len], arr1[i]);
	  strcpy (result[len] + strlen_1, arr2[j]);
",1,unused,804,unused,"      for (j = 0; j < len2; j++)
	{
	  result[len] = (char *)xmalloc (1 + strlen_1 + strlen (arr2[j]));
	  strcpy (result[len], arr1[i]);
	  strcpy (result[len] + strlen_1, arr2[j]);
",unused,bashdebstretche-braces.c
"	  sum = cpu / 100;
	  sum_frac = (cpu % 100) * 10;
	  len = mkfmt (ts, 2, 0, sum, sum_frac);
	  RESIZE_MALLOCED_BUFFER (str, sindex, len, ssize, 64);
	  strcpy (str + sindex, ts);
",1,unused,1249,unused,"	  sum = cpu / 100;
	  sum_frac = (cpu % 100) * 10;
	  len = mkfmt (ts, 2, 0, sum, sum_frac);
	  RESIZE_MALLOCED_BUFFER (str, sindex, len, ssize, 64);
	  strcpy (str + sindex, ts);
",unused,bashdebstretche-execute_cmd.c
"	      free (str);
	      return;
	    }
	  RESIZE_MALLOCED_BUFFER (str, sindex, len, ssize, 64);
	  strcpy (str + sindex, ts);
",1,unused,1280,unused,"	      free (str);
	      return;
	    }
	  RESIZE_MALLOCED_BUFFER (str, sindex, len, ssize, 64);
	  strcpy (str + sindex, ts);
",unused,bashdebstretche-execute_cmd.c
"  bind_variable (namevar, t, 0);
  free (t);
#endif

  sprintf (namevar, ""%s_PID"", cp->c_name);
",1,unused,2222,unused,"  bind_variable (namevar, t, 0);
  free (t);
#endif

  sprintf (namevar, ""%s_PID"", cp->c_name);
",unused,bashdebstretche-execute_cmd.c
"
  l = strlen (cp->c_name);
  namevar = xmalloc (l + 16);

  sprintf (namevar, ""%s_PID"", cp->c_name);
",1,unused,2243,unused,"
  l = strlen (cp->c_name);
  namevar = xmalloc (l + 16);

  sprintf (namevar, ""%s_PID"", cp->c_name);
",unused,bashdebstretche-execute_cmd.c
"
  llen = strlen (vname) + sizeof (ibuf) + 3;
  lhs = xmalloc (llen);

  sprintf (lhs, ""%s[%s]"", vname, istr);		/* XXX */
",1,unused,342,unused,"
  llen = strlen (vname) + sizeof (ibuf) + 3;
  lhs = xmalloc (llen);

  sprintf (lhs, ""%s[%s]"", vname, istr);		/* XXX */
",unused,bashdebstretche-expr.c
"      if (tail[0] != '.' || tail[1] != '/')
	{
	  dotted_filename = (char *)xmalloc (3 + strlen (tail));
	  dotted_filename[0] = '.'; dotted_filename[1] = '/';
	  strcpy (dotted_filename + 2, tail);
",1,unused,155,unused,"      if (tail[0] != '.' || tail[1] != '/')
	{
	  dotted_filename = (char *)xmalloc (3 + strlen (tail));
	  dotted_filename[0] = '.'; dotted_filename[1] = '/';
	  strcpy (dotted_filename + 2, tail);
",unused,bashdebstretche-hashcmd.c
"	  lose = 1;
	}
      else
	{
	  strcpy (npat, pat);
",1,unused,644,unused,"	  lose = 1;
	}
      else
	{
	  strcpy (npat, pat);
",unused,bashdebstretche-lib2Fglob2Fglob.c
"	{
	  strcpy (npat, pat);
	  dequote_pathname (npat);

	  strcpy (nextname, dir);
",1,unused,647,unused,"	{
	  strcpy (npat, pat);
	  dequote_pathname (npat);

	  strcpy (nextname, dir);
",unused,bashdebstretche-lib2Fglob2Fglob.c
"	  dequote_pathname (npat);

	  strcpy (nextname, dir);
	  nextname[dirlen++] = '/';
	  strcpy (nextname + dirlen, npat);
",1,unused,649,unused,"	  dequote_pathname (npat);

	  strcpy (nextname, dir);
	  nextname[dirlen++] = '/';
	  strcpy (nextname + dirlen, npat);
",unused,bashdebstretche-lib2Fglob2Fglob.c
"	  free (result);
	  return (NULL);
	}

      strcpy (result[i], dir);
",1,unused,986,unused,"	  free (result);
	  return (NULL);
	}

      strcpy (result[i], dir);
",unused,bashdebstretche-lib2Fglob2Fglob.c
"
      strcpy (result[i], dir);
      if (add_slash)
	result[i][l] = '/';
      strcpy (result[i] + l + add_slash, array[i]);
",1,unused,989,unused,"
      strcpy (result[i], dir);
      if (add_slash)
	result[i][l] = '/';
      strcpy (result[i] + l + add_slash, array[i]);
",unused,bashdebstretche-lib2Fglob2Fglob.c
"		       with the eighth bit set to ESC-prefixed sequences, then
		       we can use \M-.  Otherwise we need to use the sequence
		       for ESC. */
		    if (_rl_convert_meta_chars_to_ascii && map[ESC].type == ISKMAP)
		      sprintf (keyname, ""\\M-"");
",1,unused,2304,unused,"		       with the eighth bit set to ESC-prefixed sequences, then
		       we can use \M-.  Otherwise we need to use the sequence
		       for ESC. */
		    if (_rl_convert_meta_chars_to_ascii && map[ESC].type == ISKMAP)
		      sprintf (keyname, ""\\M-"");
",unused,bashdebstretche-lib2Freadline2Fbind.c
"		       for ESC. */
		    if (_rl_convert_meta_chars_to_ascii && map[ESC].type == ISKMAP)
		      sprintf (keyname, ""\\M-"");
		    else
		      sprintf (keyname, ""\\e"");
",1,unused,2306,unused,"		       for ESC. */
		    if (_rl_convert_meta_chars_to_ascii && map[ESC].type == ISKMAP)
		      sprintf (keyname, ""\\M-"");
		    else
		      sprintf (keyname, ""\\e"");
",unused,bashdebstretche-lib2Freadline2Fbind.c
"		    else
		      sprintf (keyname, ""\\e"");
		  }
		else if (CTRL_CHAR (key))
		  sprintf (keyname, ""\\C-%c"", _rl_to_lower (UNCTRL (key)));
",1,unused,2309,unused,"		    else
		      sprintf (keyname, ""\\e"");
		  }
		else if (CTRL_CHAR (key))
		  sprintf (keyname, ""\\C-%c"", _rl_to_lower (UNCTRL (key)));
",unused,bashdebstretche-lib2Freadline2Fbind.c
"		  }
		else if (CTRL_CHAR (key))
		  sprintf (keyname, ""\\C-%c"", _rl_to_lower (UNCTRL (key)));
		else if (key == RUBOUT)
		  sprintf (keyname, ""\\C-?"");
",1,unused,2311,unused,"		  }
		else if (CTRL_CHAR (key))
		  sprintf (keyname, ""\\C-%c"", _rl_to_lower (UNCTRL (key)));
		else if (key == RUBOUT)
		  sprintf (keyname, ""\\C-?"");
",unused,bashdebstretche-lib2Freadline2Fbind.c
"		    keyname[0] = (char) key;
		    keyname[1] = '\0';
		  }
		
		strcat (keyname, seqs[i]);
",1,unused,2324,unused,"		    keyname[0] = (char) key;
		    keyname[1] = '\0';
		  }
		
		strcat (keyname, seqs[i]);
",unused,bashdebstretche-lib2Freadline2Fbind.c
"	  if (key == ESC)
	    {
	      keyname = (char *)xmalloc (3 + prefix_len);
	      if (prefix)
		strcpy (keyname, prefix);
",1,unused,2477,unused,"	  if (key == ESC)
	    {
	      keyname = (char *)xmalloc (3 + prefix_len);
	      if (prefix)
		strcpy (keyname, prefix);
",unused,bashdebstretche-lib2Freadline2Fbind.c
"	      keyname = _rl_get_keyname (key);
	      if (prefix)
		{
		  out = (char *)xmalloc (strlen (keyname) + prefix_len + 1);
		  strcpy (out, prefix);
",1,unused,2488,unused,"	      keyname = _rl_get_keyname (key);
	      if (prefix)
		{
		  out = (char *)xmalloc (strlen (keyname) + prefix_len + 1);
		  strcpy (out, prefix);
",unused,bashdebstretche-lib2Freadline2Fbind.c
"	      if (prefix)
		{
		  out = (char *)xmalloc (strlen (keyname) + prefix_len + 1);
		  strcpy (out, prefix);
		  strcpy (out + prefix_len, keyname);
",1,unused,2489,unused,"	      if (prefix)
		{
		  out = (char *)xmalloc (strlen (keyname) + prefix_len + 1);
		  strcpy (out, prefix);
		  strcpy (out + prefix_len, keyname);
",unused,bashdebstretche-lib2Freadline2Fbind.c
"  else if (_rl_stricmp (name, ""comment-begin"") == 0)
    return (_rl_comment_begin ? _rl_comment_begin : RL_COMMENT_BEGIN_DEFAULT);
  else if (_rl_stricmp (name, ""completion-display-width"") == 0)
    {
      sprintf (numbuf, ""%d"", _rl_completion_columns);
",1,unused,2544,unused,"  else if (_rl_stricmp (name, ""comment-begin"") == 0)
    return (_rl_comment_begin ? _rl_comment_begin : RL_COMMENT_BEGIN_DEFAULT);
  else if (_rl_stricmp (name, ""completion-display-width"") == 0)
    {
      sprintf (numbuf, ""%d"", _rl_completion_columns);
",unused,bashdebstretche-lib2Freadline2Fbind.c
"      return (numbuf);
    }
  else if (_rl_stricmp (name, ""completion-prefix-display-length"") == 0)
    {
      sprintf (numbuf, ""%d"", _rl_completion_prefix_display_length);
",1,unused,2549,unused,"      return (numbuf);
    }
  else if (_rl_stricmp (name, ""completion-prefix-display-length"") == 0)
    {
      sprintf (numbuf, ""%d"", _rl_completion_prefix_display_length);
",unused,bashdebstretche-lib2Freadline2Fbind.c
"      return (numbuf);
    }
  else if (_rl_stricmp (name, ""completion-query-items"") == 0)
    {
      sprintf (numbuf, ""%d"", rl_completion_query_items);
",1,unused,2554,unused,"      return (numbuf);
    }
  else if (_rl_stricmp (name, ""completion-query-items"") == 0)
    {
      sprintf (numbuf, ""%d"", rl_completion_query_items);
",unused,bashdebstretche-lib2Freadline2Fbind.c
"  else if (_rl_stricmp (name, ""editing-mode"") == 0)
    return (rl_get_keymap_name_from_edit_mode ());
  else if (_rl_stricmp (name, ""history-size"") == 0)
    {
      sprintf (numbuf, ""%d"", history_is_stifled() ? history_max_entries : 0);
",1,unused,2561,unused,"  else if (_rl_stricmp (name, ""editing-mode"") == 0)
    return (rl_get_keymap_name_from_edit_mode ());
  else if (_rl_stricmp (name, ""history-size"") == 0)
    {
      sprintf (numbuf, ""%d"", history_is_stifled() ? history_max_entries : 0);
",unused,bashdebstretche-lib2Freadline2Fbind.c
"      return (ret ? ret : ""none"");
    }
  else if (_rl_stricmp (name, ""keyseq-timeout"") == 0)
    {
      sprintf (numbuf, ""%d"", _rl_keyseq_timeout);    
",1,unused,2588,unused,"      return (ret ? ret : ""none"");
    }
  else if (_rl_stricmp (name, ""keyseq-timeout"") == 0)
    {
      sprintf (numbuf, ""%d"", _rl_keyseq_timeout);    
",unused,bashdebstretche-lib2Freadline2Fbind.c
"
	  slen = strlen (s);
	  tlen = strlen (to_print);
	  new_full_pathname = (char *)xmalloc (slen + tlen + 2);
	  strcpy (new_full_pathname, s);
",1,unused,986,unused,"
	  slen = strlen (s);
	  tlen = strlen (to_print);
	  new_full_pathname = (char *)xmalloc (slen + tlen + 2);
	  strcpy (new_full_pathname, s);
",unused,bashdebstretche-lib2Freadline2Fcomplete.c
"	    slen--;
	  else
	    new_full_pathname[slen] = '/';
	  new_full_pathname[slen] = '/';
	  strcpy (new_full_pathname + slen + 1, to_print);
",1,unused,992,unused,"	    slen--;
	  else
	    new_full_pathname[slen] = '/';
	  new_full_pathname[slen] = '/';
	  strcpy (new_full_pathname + slen + 1, to_print);
",unused,bashdebstretche-lib2Freadline2Fcomplete.c
"  char *r;

  r = (char *)xmalloc (strlen (s) + 2);
  *r = *rl_completer_quote_characters;
  strcpy (r + 1, s);
",1,unused,1061,unused,"  char *r;

  r = (char *)xmalloc (strlen (s) + 2);
  *r = *rl_completer_quote_characters;
  strcpy (r + 1, s);
",unused,bashdebstretche-lib2Freadline2Fcomplete.c
"     value of matches[0]. */
  if (low == 0 && text && *text)
    {
      match_list[0] = (char *)xmalloc (strlen (text) + 1);
      strcpy (match_list[0], text);
",1,unused,1421,unused,"     value of matches[0]. */
  if (low == 0 && text && *text)
    {
      match_list[0] = (char *)xmalloc (strlen (text) + 1);
      strcpy (match_list[0], text);
",unused,bashdebstretche-lib2Freadline2Fcomplete.c
"      value = (char *)xmalloc (2 + strlen (entry->pw_name));

      *value = *text;

      strcpy (value + first_char_loc, entry->pw_name);
",1,unused,2327,unused,"      value = (char *)xmalloc (2 + strlen (entry->pw_name));

      *value = *text;

      strcpy (value + first_char_loc, entry->pw_name);
",unused,bashdebstretche-lib2Freadline2Fcomplete.c
"#endif

      if (temp)
	{
	  strcpy (filename, ++temp);
",1,unused,2518,unused,"#endif

      if (temp)
	{
	  strcpy (filename, ++temp);
",unused,bashdebstretche-lib2Freadline2Fcomplete.c
"	  if (rl_complete_with_tilde_expansion && *users_dirname == '~')
	    {
	      dirlen = strlen (dirname);
	      temp = (char *)xmalloc (2 + dirlen + D_NAMLEN (entry));
	      strcpy (temp, dirname);
",1,unused,2664,unused,"	  if (rl_complete_with_tilde_expansion && *users_dirname == '~')
	    {
	      dirlen = strlen (dirname);
	      temp = (char *)xmalloc (2 + dirlen + D_NAMLEN (entry));
	      strcpy (temp, dirname);
",unused,bashdebstretche-lib2Freadline2Fcomplete.c
"	  else
	    {
	      dirlen = strlen (users_dirname);
	      temp = (char *)xmalloc (2 + dirlen + D_NAMLEN (entry));
	      strcpy (temp, users_dirname);
",1,unused,2677,unused,"	  else
	    {
	      dirlen = strlen (users_dirname);
	      temp = (char *)xmalloc (2 + dirlen + D_NAMLEN (entry));
	      strcpy (temp, users_dirname);
",unused,bashdebstretche-lib2Freadline2Fcomplete.c
"	      if (users_dirname[dirlen - 1] != '/')
		temp[dirlen++] = '/';
	    }

	  strcpy (temp + dirlen, convfn);
",1,unused,2683,unused,"	      if (users_dirname[dirlen - 1] != '/')
		temp[dirlen++] = '/';
	    }

	  strcpy (temp + dirlen, convfn);
",unused,bashdebstretche-lib2Freadline2Fcomplete.c
"    {
      l = strlen (pmt);
      nprompt = (char *)xmalloc (l + mlen + 1);
      memcpy (nprompt, ms, mlen);
      strcpy (nprompt + mlen, pmt);
",1,unused,325,unused,"    {
      l = strlen (pmt);
      nprompt = (char *)xmalloc (l + mlen + 1);
      memcpy (nprompt, ms, mlen);
      strcpy (nprompt + mlen, pmt);
",unused,bashdebstretche-lib2Freadline2Fdisplay.c
"#endif
	{
	  if (_rl_output_meta_chars == 0)
	    {
	      sprintf (line + out, ""\\%o"", c);
",1,unused,903,unused,"#endif
	{
	  if (_rl_output_meta_chars == 0)
	    {
	      sprintf (line + out, ""\\%o"", c);
",unused,bashdebstretche-lib2Freadline2Fdisplay.c
"
  /* Make sure the line structures hold the already-displayed prompt for
     redisplay. */
  lprompt = local_prompt ? local_prompt : rl_prompt;
  strcpy (visible_line, lprompt);
",1,unused,2079,unused,"
  /* Make sure the line structures hold the already-displayed prompt for
     redisplay. */
  lprompt = local_prompt ? local_prompt : rl_prompt;
  strcpy (visible_line, lprompt);
",unused,bashdebstretche-lib2Freadline2Fdisplay.c
"  /* Make sure the line structures hold the already-displayed prompt for
     redisplay. */
  lprompt = local_prompt ? local_prompt : rl_prompt;
  strcpy (visible_line, lprompt);
  strcpy (invisible_line, lprompt);
",1,unused,2080,unused,"  /* Make sure the line structures hold the already-displayed prompt for
     redisplay. */
  lprompt = local_prompt ? local_prompt : rl_prompt;
  strcpy (visible_line, lprompt);
  strcpy (invisible_line, lprompt);
",unused,bashdebstretche-lib2Freadline2Fdisplay.c
"    {
      len = (rl_prompt && *rl_prompt) ? strlen (rl_prompt) : 0;
      pmt = (char *)xmalloc (len + 2);
      if (len)
	strcpy (pmt, rl_prompt);
",1,unused,2602,unused,"    {
      len = (rl_prompt && *rl_prompt) ? strlen (rl_prompt) : 0;
      pmt = (char *)xmalloc (len + 2);
      if (len)
	strcpy (pmt, rl_prompt);
",unused,bashdebstretche-lib2Freadline2Fdisplay.c
"      p++;
      len = strlen (p);
      pmt = (char *)xmalloc (len + 2);
      if (len)
	strcpy (pmt, p);
",1,unused,2612,unused,"      p++;
      len = strlen (p);
      pmt = (char *)xmalloc (len + 2);
      if (len)
	strcpy (pmt, p);
",unused,bashdebstretche-lib2Freadline2Fdisplay.c
"  temp = (char *)xmalloc (ll + elen + 3);
  strncpy (temp, s + start, ll);
  temp[ll] = ':';
  temp[ll + 1] = ' ';
  strcpy (temp + ll + 2, emsg);
",1,unused,419,unused,"  temp = (char *)xmalloc (ll + elen + 3);
  strncpy (temp, s + start, ll);
  temp[ll] = ':';
  temp[ll + 1] = ' ';
  strcpy (temp + ll + 2, emsg);
",unused,bashdebstretche-lib2Freadline2Fhistexpand.c
"      if (subst_rhs[i] == '&')
	{
	  if (j + subst_lhs_len >= new_size)
	    new = (char *)xrealloc (new, (new_size = new_size * 2 + subst_lhs_len));
	  strcpy (new + j, subst_lhs);
",1,unused,505,unused,"      if (subst_rhs[i] == '&')
	{
	  if (j + subst_lhs_len >= new_size)
	    new = (char *)xrealloc (new, (new_size = new_size * 2 + subst_lhs_len));
	  strcpy (new + j, subst_lhs);
",unused,bashdebstretche-lib2Freadline2Fhistexpand.c
"
  n = strlen (temp);
  if (n >= result_len)
    result = (char *)xrealloc (result, n + 2);
  strcpy (result, temp);
",1,unused,864,unused,"
  n = strlen (temp);
  if (n >= result_len)
    result = (char *)xrealloc (result, n + 2);
  strcpy (result, temp);
",unused,bashdebstretche-lib2Freadline2Fhistexpand.c
"
      string[0] = string[1] = history_expansion_char;
      string[2] = ':';
      string[3] = 's';
      strcpy (string + 4, hstring);
",1,unused,965,unused,"
      string[0] = string[1] = history_expansion_char;
      string[2] = ':';
      string[3] = 's';
      strcpy (string + 4, hstring);
",unused,bashdebstretche-lib2Freadline2Fhistexpand.c
"	  if ((dquote == 0 || history_quotes_inhibit_expansion == 0) &&
	      (i == 0 || member (string[i - 1], history_word_delimiters)))
	    {
	      temp = (char *)xmalloc (l - i + 1);
	      strcpy (temp, string + i);
",1,unused,1163,unused,"	  if ((dquote == 0 || history_quotes_inhibit_expansion == 0) &&
	      (i == 0 || member (string[i - 1], history_word_delimiters)))
	    {
	      temp = (char *)xmalloc (l - i + 1);
	      strcpy (temp, string + i);
",unused,bashdebstretche-lib2Freadline2Fhistexpand.c
"      result[0] = '\0';

      for (i = first, offset = 0; i < last; i++)
	{
	  strcpy (result + offset, list[i]);
",1,unused,1403,unused,"      result[0] = '\0';

      for (i = first, offset = 0; i < last; i++)
	{
	  strcpy (result + offset, list[i]);
",unused,bashdebstretche-lib2Freadline2Fhistexpand.c
"  else
    home_len = strlen (home);

  return_val = (char *)xmalloc (2 + home_len + 8); /* strlen("".history"") == 8 */
  strcpy (return_val, home);
",1,unused,170,unused,"  else
    home_len = strlen (home);

  return_val = (char *)xmalloc (2 + home_len + 8); /* strlen("".history"") == 8 */
  strcpy (return_val, home);
",unused,bashdebstretche-lib2Freadline2Fhistfile.c
"  return_val[home_len] = '/';
#if defined (__MSDOS__)
  strcpy (return_val + home_len + 1, ""_history"");
#else
  strcpy (return_val + home_len + 1, "".history"");
",1,unused,175,unused,"  return_val[home_len] = '/';
#if defined (__MSDOS__)
  strcpy (return_val + home_len + 1, ""_history"");
#else
  strcpy (return_val + home_len + 1, "".history"");
",unused,bashdebstretche-lib2Freadline2Fhistfile.c
"#endif
      
  len = strlen (fn);
  ret = xmalloc (len + 2);
  strcpy (ret, fn);
",1,unused,204,unused,"#endif
      
  len = strlen (fn);
  ret = xmalloc (len + 2);
  strcpy (ret, fn);
",unused,bashdebstretche-lib2Freadline2Fhistfile.c
"#endif
      
  len = strlen (fn);
  ret = xmalloc (len + 11);
  strcpy (ret, fn);
",1,unused,234,unused,"#endif
      
  len = strlen (fn);
  ret = xmalloc (len + 11);
  strcpy (ret, fn);
",unused,bashdebstretche-lib2Freadline2Fhistfile.c
"  ret[len+2] = (pid / 1000 % 10) + '0';
  ret[len+3] = (pid / 100 % 10) + '0';
  ret[len+4] = (pid / 10 % 10) + '0';
  ret[len+5] = (pid % 10) + '0';
  strcpy (ret + len + 6, "".tmp"");
",1,unused,245,unused,"  ret[len+2] = (pid / 1000 % 10) + '0';
  ret[len+3] = (pid / 100 % 10) + '0';
  ret[len+4] = (pid / 10 % 10) + '0';
  ret[len+5] = (pid % 10) + '0';
  strcpy (ret + len + 6, "".tmp"");
",unused,bashdebstretche-lib2Freadline2Fhistfile.c
"    for (j = 0, i = history_length - nelements; i < history_length; i++)
      {
	if (history_write_timestamps && the_history[i]->timestamp && the_history[i]->timestamp[0])
	  {
	    strcpy (buffer + j, the_history[i]->timestamp);
",1,unused,722,unused,"    for (j = 0, i = history_length - nelements; i < history_length; i++)
      {
	if (history_write_timestamps && the_history[i]->timestamp && the_history[i]->timestamp[0])
	  {
	    strcpy (buffer + j, the_history[i]->timestamp);
",unused,bashdebstretche-lib2Freadline2Fhistfile.c
"	    strcpy (buffer + j, the_history[i]->timestamp);
	    j += strlen (the_history[i]->timestamp);
	    buffer[j++] = '\n';
	  }
	strcpy (buffer + j, the_history[i]->line);
",1,unused,726,unused,"	    strcpy (buffer + j, the_history[i]->timestamp);
	    j += strlen (the_history[i]->timestamp);
	    buffer[j++] = '\n';
	  }
	strcpy (buffer + j, the_history[i]->line);
",unused,bashdebstretche-lib2Freadline2Fhistfile.c
"  if (newline)
    {
      hent->line = newline;
      hent->line[curlen++] = '\n';
      strcpy (hent->line + curlen, line);
",1,unused,430,unused,"  if (newline)
    {
      hent->line = newline;
      hent->line[curlen++] = '\n';
      strcpy (hent->line + curlen, line);
",unused,bashdebstretche-lib2Freadline2Fhistory.c
"  message[msglen++] = '(';

  if (flags & SF_FAILED)
    {
      strcpy (message + msglen, ""failed "");
",1,unused,182,unused,"  message[msglen++] = '(';

  if (flags & SF_FAILED)
    {
      strcpy (message + msglen, ""failed "");
",unused,bashdebstretche-lib2Freadline2Fisearch.c
"    }

  if (flags & SF_REVERSE)
    {
      strcpy (message + msglen, ""reverse-"");
",1,unused,188,unused,"    }

  if (flags & SF_REVERSE)
    {
      strcpy (message + msglen, ""reverse-"");
",unused,bashdebstretche-lib2Freadline2Fisearch.c
"      strcpy (message + msglen, ""reverse-"");
      msglen += 8;
    }

  strcpy (message + msglen, ""i-search)`"");
",1,unused,192,unused,"      strcpy (message + msglen, ""reverse-"");
      msglen += 8;
    }

  strcpy (message + msglen, ""i-search)`"");
",unused,bashdebstretche-lib2Freadline2Fisearch.c
"  msglen += 10;

  if (search_string)
    {
      strcpy (message + msglen, search_string);
",1,unused,197,unused,"  msglen += 10;

  if (search_string)
    {
      strcpy (message + msglen, search_string);
",unused,bashdebstretche-lib2Freadline2Fisearch.c
"      strcpy (message + msglen, search_string);
      msglen += searchlen;
    }

  strcpy (message + msglen, ""': "");
",1,unused,201,unused,"      strcpy (message + msglen, search_string);
      msglen += searchlen;
    }

  strcpy (message + msglen, ""': "");
",unused,bashdebstretche-lib2Freadline2Fisearch.c
"  else
    {
      /* Keep track of this so we can free it. */
      cxt->allocated_line = (char *)xmalloc (1 + strlen (rl_line_buffer));
      strcpy (cxt->allocated_line, &rl_line_buffer[0]);
",1,unused,242,unused,"  else
    {
      /* Keep track of this so we can free it. */
      cxt->allocated_line = (char *)xmalloc (1 + strlen (rl_line_buffer));
      strcpy (cxt->allocated_line, &rl_line_buffer[0]);
",unused,bashdebstretche-lib2Freadline2Fisearch.c
"_rl_isearch_fini (cxt)
     _rl_search_cxt *cxt;
{
  /* First put back the original state. */
  strcpy (rl_line_buffer, cxt->lines[cxt->save_line]);
",1,unused,274,unused,"_rl_isearch_fini (cxt)
     _rl_search_cxt *cxt;
{
  /* First put back the original state. */
  strcpy (rl_line_buffer, cxt->lines[cxt->save_line]);
",unused,bashdebstretche-lib2Freadline2Fisearch.c
"	  if (last_isearch_string)
	    {
	      cxt->search_string_size = 64 + last_isearch_string_len;
	      cxt->search_string = (char *)xrealloc (cxt->search_string, cxt->search_string_size);
	      strcpy (cxt->search_string, last_isearch_string);
",1,unused,523,unused,"	  if (last_isearch_string)
	    {
	      cxt->search_string_size = 64 + last_isearch_string_len;
	      cxt->search_string = (char *)xrealloc (cxt->search_string, cxt->search_string_size);
	      strcpy (cxt->search_string, last_isearch_string);
",unused,bashdebstretche-lib2Freadline2Fisearch.c
"      new = (char *)xmalloc (1 + strlen (old) + strlen (text));

      if (append)
	{
	  strcpy (new, old);
",1,unused,141,unused,"      new = (char *)xmalloc (1 + strlen (old) + strlen (text));

      if (append)
	{
	  strcpy (new, old);
",unused,bashdebstretche-lib2Freadline2Fkill.c
"
      if (append)
	{
	  strcpy (new, old);
	  strcat (new, text);
",1,unused,142,unused,"
      if (append)
	{
	  strcpy (new, old);
	  strcat (new, text);
",unused,bashdebstretche-lib2Freadline2Fkill.c
"	  strcat (new, text);
	}
      else
	{
	  strcpy (new, text);
",1,unused,146,unused,"	  strcat (new, text);
	}
      else
	{
	  strcpy (new, text);
",unused,bashdebstretche-lib2Freadline2Fkill.c
"	}
      else
	{
	  strcpy (new, text);
	  strcat (new, old);
",1,unused,147,unused,"	}
      else
	{
	  strcpy (new, text);
	  strcat (new, old);
",unused,bashdebstretche-lib2Freadline2Fkill.c
"      return;
    }

  ext = NULL;
  strcpy (label, ""??"");
",1,unused,318,unused,"      return;
    }

  ext = NULL;
  strcpy (label, ""??"");
",unused,bashdebstretche-lib2Freadline2Fparse-colors.c
"{
  char *ret;

  ret = (char *)xmalloc (strlen (s) + 1);
  strcpy (ret, s);
",1,unused,39,unused,"{
  char *ret;

  ret = (char *)xmalloc (strlen (s) + 1);
  strcpy (ret, s);
",unused,bashdebstretche-lib2Freadline2Fsavestring.c
"sh_set_lines_and_columns (lines, cols)
     int lines, cols;
{
#if defined (HAVE_SETENV)
  sprintf (setenv_buf, ""%d"", lines);
",1,unused,134,unused,"sh_set_lines_and_columns (lines, cols)
     int lines, cols;
{
#if defined (HAVE_SETENV)
  sprintf (setenv_buf, ""%d"", lines);
",unused,bashdebstretche-lib2Freadline2Fshell.c
"#if defined (HAVE_SETENV)
  sprintf (setenv_buf, ""%d"", lines);
  setenv (""LINES"", setenv_buf, 1);

  sprintf (setenv_buf, ""%d"", cols);
",1,unused,137,unused,"#if defined (HAVE_SETENV)
  sprintf (setenv_buf, ""%d"", lines);
  setenv (""LINES"", setenv_buf, 1);

  sprintf (setenv_buf, ""%d"", cols);
",unused,bashdebstretche-lib2Freadline2Fshell.c
"
  len = strlen (text);
  if (len >= rl_line_buffer_len)
    rl_extend_line_buffer (len);
  strcpy (rl_line_buffer, text);
",1,unused,218,unused,"
  len = strlen (text);
  if (len >= rl_line_buffer_len)
    rl_extend_line_buffer (len);
  strcpy (rl_line_buffer, text);
",unused,bashdebstretche-lib2Freadline2Ftext.c
"	{
	  if ((result_index + len + 1) > result_size)
	    result = (char *)xrealloc (result, 1 + (result_size += (len + 20)));

	  strcpy (result + result_index, expansion);
",1,unused,255,unused,"	{
	  if ((result_index + len + 1) > result_size)
	    result = (char *)xrealloc (result, 1 + (result_size += (len + 20)));

	  strcpy (result + result_index, expansion);
",unused,bashdebstretche-lib2Freadline2Ftilde.c
"  plen = (prefix && *prefix) ? strlen (prefix) : 0;
  slen = strlen (suffix + suffind);
  ret = (char *)xmalloc (plen + slen + 1);
  if (plen)
    strcpy (ret, prefix);
",1,unused,338,unused,"  plen = (prefix && *prefix) ? strlen (prefix) : 0;
  slen = strlen (suffix + suffind);
  ret = (char *)xmalloc (plen + slen + 1);
  if (plen)
    strcpy (ret, prefix);
",unused,bashdebstretche-lib2Freadline2Ftilde.c
"  slen = strlen (suffix + suffind);
  ret = (char *)xmalloc (plen + slen + 1);
  if (plen)
    strcpy (ret, prefix);
  strcpy (ret + plen, suffix + suffind);
",1,unused,339,unused,"  slen = strlen (suffix + suffind);
  ret = (char *)xmalloc (plen + slen + 1);
  if (plen)
    strcpy (ret, prefix);
  strcpy (ret + plen, suffix + suffind);
",unused,bashdebstretche-lib2Freadline2Ftilde.c
"char *
_rl_savestring (s)
     const char *s;
{
  return (strcpy ((char *)xmalloc (1 + (int)strlen (s)), (s)));
",1,unused,478,unused,"char *
_rl_savestring (s)
     const char *s;
{
  return (strcpy ((char *)xmalloc (1 + (int)strlen (s)), (s)));
",unused,bashdebstretche-lib2Freadline2Futil.c
"     trailing slash.  Make sure /dev/fd/xx really uses DEV_FD_PREFIX/xx.
     On most systems, with the notable exception of linux, this is
     effectively a no-op. */
      pbuf = xrealloc (pbuf, sizeof (DEV_FD_PREFIX) + strlen (path + 8));
      strcpy (pbuf, DEV_FD_PREFIX);
",1,unused,112,unused,"     trailing slash.  Make sure /dev/fd/xx really uses DEV_FD_PREFIX/xx.
     On most systems, with the notable exception of linux, this is
     effectively a no-op. */
      pbuf = xrealloc (pbuf, sizeof (DEV_FD_PREFIX) + strlen (path + 8));
      strcpy (pbuf, DEV_FD_PREFIX);
",unused,bashdebstretche-lib2Fsh2Feaccess.c
"     On most systems, with the notable exception of linux, this is
     effectively a no-op. */
      pbuf = xrealloc (pbuf, sizeof (DEV_FD_PREFIX) + strlen (path + 8));
      strcpy (pbuf, DEV_FD_PREFIX);
      strcat (pbuf, path + 8);
",1,unused,113,unused,"     On most systems, with the notable exception of linux, this is
     effectively a no-op. */
      pbuf = xrealloc (pbuf, sizeof (DEV_FD_PREFIX) + strlen (path + 8));
      strcpy (pbuf, DEV_FD_PREFIX);
      strcat (pbuf, path + 8);
",unused,bashdebstretche-lib2Fsh2Feaccess.c
"  st_ret.st_mode  &= ~S_IFDIR;
  st_ret.st_mode  |= S_IFREG;

  /* See if cur/ is present */
  sprintf(dir, ""%s/cur"", path);
",1,unused,95,unused,"  st_ret.st_mode  &= ~S_IFDIR;
  st_ret.st_mode  |= S_IFREG;

  /* See if cur/ is present */
  sprintf(dir, ""%s/cur"", path);
",unused,bashdebstretche-lib2Fsh2Fmailstat.c
"    return 0;
  st_ret.st_atime = st_tmp.st_atime;

  /* See if tmp/ is present */
  sprintf(dir, ""%s/tmp"", path);
",1,unused,101,unused,"    return 0;
  st_ret.st_atime = st_tmp.st_atime;

  /* See if tmp/ is present */
  sprintf(dir, ""%s/tmp"", path);
",unused,bashdebstretche-lib2Fsh2Fmailstat.c
"    return 0;
  st_ret.st_mtime = st_tmp.st_mtime;

  /* And new/ */
  sprintf(dir, ""%s/new"", path);
",1,unused,107,unused,"    return 0;
  st_ret.st_mtime = st_tmp.st_mtime;

  /* And new/ */
  sprintf(dir, ""%s/new"", path);
",unused,bashdebstretche-lib2Fsh2Fmailstat.c
"
  /* Loop over new/ and cur/ */
  for (i = 0; i < 2; i++)
    {
      sprintf(dir, ""%s/%s"", path, i ? ""cur"" : ""new"");
",1,unused,126,unused,"
  /* Loop over new/ and cur/ */
  for (i = 0; i < 2; i++)
    {
      sprintf(dir, ""%s/%s"", path, i ? ""cur"" : ""new"");
",unused,bashdebstretche-lib2Fsh2Fmailstat.c
"  /* Loop over new/ and cur/ */
  for (i = 0; i < 2; i++)
    {
      sprintf(dir, ""%s/%s"", path, i ? ""cur"" : ""new"");
      sprintf(file, ""%s/"", dir);
",1,unused,127,unused,"  /* Loop over new/ and cur/ */
  for (i = 0; i < 2; i++)
    {
      sprintf(dir, ""%s/%s"", path, i ? ""cur"" : ""new"");
      sprintf(file, ""%s/"", dir);
",unused,bashdebstretche-lib2Fsh2Fmailstat.c
"      while ((fn = readdir(dd)) != NULL)
	{
	  if (fn->d_name[0] == '.' || strlen(fn->d_name) + l >= sizeof(file))
	    continue;
	  strcpy(file + l, fn->d_name);
",1,unused,135,unused,"      while ((fn = readdir(dd)) != NULL)
	{
	  if (fn->d_name[0] == '.' || strlen(fn->d_name) + l >= sizeof(file))
	    continue;
	  strcpy(file + l, fn->d_name);
",unused,bashdebstretche-lib2Fsh2Fmailstat.c
"  char *np, *s, *t;
  int fd;

  np = (char *)xmalloc (strlen (path) + 1);
  strcpy (np, path);
",1,unused,300,unused,"  char *np, *s, *t;
  int fd;

  np = (char *)xmalloc (strlen (path) + 1);
  strcpy (np, path);
",unused,bashdebstretche-lib2Fsh2Fnetopen.c
"    {
      if (result[2] == '\0')	/* short-circuit for bare `//' */
	result[1] = '\0';
      else
	strcpy (result, result + 1);
",1,unused,230,unused,"    {
      if (result[2] == '\0')	/* short-circuit for bare `//' */
	result[1] = '\0';
      else
	strcpy (result, result + 1);
",unused,bashdebstretche-lib2Fsh2Fpathcanon.c
"    workpath = savestring (path);
  else
    {
      workpath = (char *)xmalloc (PATH_MAX + 1);
      strcpy (workpath, path);
",1,unused,101,unused,"    workpath = savestring (path);
  else
    {
      workpath = (char *)xmalloc (PATH_MAX + 1);
      strcpy (workpath, path);
",unused,bashdebstretche-lib2Fsh2Fpathphys.c
"	     buffer and appending the rest of `workpath'.  Reset p to point
	     to the start of the rest of the path.  If the link value is an
	     absolute pathname, reset p, q, and qbase.  If not, reset p
	     and q. */
	  strcpy (tbuf, linkbuf);
",1,unused,208,unused,"	     buffer and appending the rest of `workpath'.  Reset p to point
	     to the start of the rest of the path.  If the link value is an
	     absolute pathname, reset p, q, and qbase.  If not, reset p
	     and q. */
	  strcpy (tbuf, linkbuf);
",unused,bashdebstretche-lib2Fsh2Fpathphys.c
"	     absolute pathname, reset p, q, and qbase.  If not, reset p
	     and q. */
	  strcpy (tbuf, linkbuf);
	  tbuf[linklen] = '/';
	  strcpy (tbuf + linklen, p);
",1,unused,210,unused,"	     absolute pathname, reset p, q, and qbase.  If not, reset p
	     and q. */
	  strcpy (tbuf, linkbuf);
	  tbuf[linklen] = '/';
	  strcpy (tbuf + linklen, p);
",unused,bashdebstretche-lib2Fsh2Fpathphys.c
"	     and q. */
	  strcpy (tbuf, linkbuf);
	  tbuf[linklen] = '/';
	  strcpy (tbuf + linklen, p);
	  strcpy (workpath, tbuf);
",1,unused,211,unused,"	     and q. */
	  strcpy (tbuf, linkbuf);
	  tbuf[linklen] = '/';
	  strcpy (tbuf + linklen, p);
	  strcpy (workpath, tbuf);
",unused,bashdebstretche-lib2Fsh2Fpathphys.c
"    {
      if (result[2] == '\0')	/* short-circuit for bare `//' */
	result[1] = '\0';
      else
	strcpy (result, result + 1);
",1,unused,248,unused,"    {
      if (result[2] == '\0')	/* short-circuit for bare `//' */
	result[1] = '\0';
      else
	strcpy (result, result + 1);
",unused,bashdebstretche-lib2Fsh2Fpathphys.c
"       */
      x = spdist(dp->d_name, guess);
      if (x <= dist && x != 3)
	{
	  strcpy(best, dp->d_name);
",1,unused,134,unused,"       */
      x = spdist(dp->d_name, guess);
      if (x <= dist && x != 3)
	{
	  strcpy(best, dp->d_name);
",unused,bashdebstretche-lib2Fsh2Fspell.c
"      llen = STRLEN (sl->list[i]);
      tlen = plen + llen + slen + 1;
      t = (char *)xmalloc (tlen + 1);
      if (plen)
	strcpy (t, prefix);
",1,unused,214,unused,"      llen = STRLEN (sl->list[i]);
      tlen = plen + llen + slen + 1;
      t = (char *)xmalloc (tlen + 1);
      if (plen)
	strcpy (t, prefix);
",unused,bashdebstretche-lib2Fsh2Fstringlist.c
"      tlen = plen + llen + slen + 1;
      t = (char *)xmalloc (tlen + 1);
      if (plen)
	strcpy (t, prefix);
      strcpy (t + plen, sl->list[i]);
",1,unused,215,unused,"      tlen = plen + llen + slen + 1;
      t = (char *)xmalloc (tlen + 1);
      if (plen)
	strcpy (t, prefix);
      strcpy (t + plen, sl->list[i]);
",unused,bashdebstretche-lib2Fsh2Fstringlist.c
"      if (plen)
	strcpy (t, prefix);
      strcpy (t + plen, sl->list[i]);
      if (slen)
	strcpy (t + plen + llen, suffix);
",1,unused,217,unused,"      if (plen)
	strcpy (t, prefix);
      strcpy (t + plen, sl->list[i]);
      if (slen)
	strcpy (t + plen + llen, suffix);
",unused,bashdebstretche-lib2Fsh2Fstringlist.c
"
  lroot = nameroot ? nameroot : DEFAULT_NAMEROOT;

#ifdef USE_MKTEMP
  sprintf (filename, ""%s/%s.XXXXXX"", tdir, lroot);
",1,unused,151,unused,"
  lroot = nameroot ? nameroot : DEFAULT_NAMEROOT;

#ifdef USE_MKTEMP
  sprintf (filename, ""%s/%s.XXXXXX"", tdir, lroot);
",unused,bashdebstretche-lib2Fsh2Ftmpfile.c
"
  lroot = nameroot ? nameroot : DEFAULT_NAMEROOT;

#ifdef USE_MKSTEMP
  sprintf (filename, ""%s/%s.XXXXXX"", tdir, lroot);
",1,unused,197,unused,"
  lroot = nameroot ? nameroot : DEFAULT_NAMEROOT;

#ifdef USE_MKSTEMP
  sprintf (filename, ""%s/%s.XXXXXX"", tdir, lroot);
",unused,bashdebstretche-lib2Fsh2Ftmpfile.c
"
  locale = get_locale_var (""LC_CTYPE"");
  if (locale == 0 || *locale == 0)
    {
      strcpy (charsetbuf, ""ASCII"");
",1,unused,75,unused,"
  locale = get_locale_var (""LC_CTYPE"");
  if (locale == 0 || *locale == 0)
    {
      strcpy (charsetbuf, ""ASCII"");
",unused,bashdebstretche-lib2Fsh2Funicode.c
"{
  int l;

  if (wc < 0x10000)
    l = sprintf (s, ""\\u%04X"", wc);
",1,unused,144,unused,"{
  int l;

  if (wc < 0x10000)
    l = sprintf (s, ""\\u%04X"", wc);
",unused,bashdebstretche-lib2Fsh2Funicode.c
"
  if (wc < 0x10000)
    l = sprintf (s, ""\\u%04X"", wc);
  else
    l = sprintf (s, ""\\u%08X"", wc);
",1,unused,146,unused,"
  if (wc < 0x10000)
    l = sprintf (s, ""\\u%04X"", wc);
  else
    l = sprintf (s, ""\\u%08X"", wc);
",unused,bashdebstretche-lib2Fsh2Funicode.c
"  *optr = '\0';

  /* number of chars to be copied is optr - obuf if we want to do bounds
     checking */
  strcpy (s, obuf);
",1,unused,331,unused,"  *optr = '\0';

  /* number of chars to be copied is optr - obuf if we want to do bounds
     checking */
  strcpy (s, obuf);
",unused,bashdebstretche-lib2Fsh2Funicode.c
"	{
	  if ((result_index + len + 1) > result_size)
	    result = (char *)xrealloc (result, 1 + (result_size += (len + 20)));

	  strcpy (result + result_index, expansion);
",1,unused,255,unused,"	{
	  if ((result_index + len + 1) > result_size)
	    result = (char *)xrealloc (result, 1 + (result_size += (len + 20)));

	  strcpy (result + result_index, expansion);
",unused,bashdebstretche-lib2Ftilde2Ftilde.c
"  plen = (prefix && *prefix) ? strlen (prefix) : 0;
  slen = strlen (suffix + suffind);
  ret = (char *)xmalloc (plen + slen + 1);
  if (plen)
    strcpy (ret, prefix);
",1,unused,338,unused,"  plen = (prefix && *prefix) ? strlen (prefix) : 0;
  slen = strlen (suffix + suffind);
  ret = (char *)xmalloc (plen + slen + 1);
  if (plen)
    strcpy (ret, prefix);
",unused,bashdebstretche-lib2Ftilde2Ftilde.c
"  slen = strlen (suffix + suffind);
  ret = (char *)xmalloc (plen + slen + 1);
  if (plen)
    strcpy (ret, prefix);
  strcpy (ret + plen, suffix + suffind);
",1,unused,339,unused,"  slen = strlen (suffix + suffind);
  ret = (char *)xmalloc (plen + slen + 1);
  if (plen)
    strcpy (ret, prefix);
  strcpy (ret + plen, suffix + suffind);
",unused,bashdebstretche-lib2Ftilde2Ftilde.c
"  if (locale == 0 || locale[0] == '\0' ||
      (locale[0] == 'C' && locale[1] == '\0') || STREQ (locale, ""POSIX""))
    {
      t = (char *)xmalloc (len + 1);
      strcpy (t, string);
",1,unused,391,unused,"  if (locale == 0 || locale[0] == '\0' ||
      (locale[0] == 'C' && locale[1] == '\0') || STREQ (locale, ""POSIX""))
    {
      t = (char *)xmalloc (len + 1);
      strcpy (t, string);
",unused,bashdebstretche-locale.c
"
  if (translated == string)	/* gettext returns its argument if untranslatable */
    {
      t = (char *)xmalloc (len + 1);
      strcpy (t, string);
",1,unused,406,unused,"
  if (translated == string)	/* gettext returns its argument if untranslatable */
    {
      t = (char *)xmalloc (len + 1);
      strcpy (t, string);
",unused,bashdebstretche-locale.c
"  else
    {
      tlen = strlen (translated);
      t = (char *)xmalloc (tlen + 1);
      strcpy (t, translated);
",1,unused,414,unused,"  else
    {
      tlen = strlen (translated);
      t = (char *)xmalloc (tlen + 1);
      strcpy (t, translated);
",unused,bashdebstretche-locale.c
"  char *mp;

  get_current_user_info ();
  mp = (char *)xmalloc (2 + sizeof (DEFAULT_MAIL_DIRECTORY) + strlen (current_user.user_name));
  strcpy (mp, DEFAULT_MAIL_DIRECTORY);
",1,unused,354,unused,"  char *mp;

  get_current_user_info ();
  mp = (char *)xmalloc (2 + sizeof (DEFAULT_MAIL_DIRECTORY) + strlen (current_user.user_name));
  strcpy (mp, DEFAULT_MAIL_DIRECTORY);
",unused,bashdebstretche-mailcheck.c
"  get_current_user_info ();
  mp = (char *)xmalloc (2 + sizeof (DEFAULT_MAIL_DIRECTORY) + strlen (current_user.user_name));
  strcpy (mp, DEFAULT_MAIL_DIRECTORY);
  mp[sizeof(DEFAULT_MAIL_DIRECTORY) - 1] = '/';
  strcpy (mp + sizeof (DEFAULT_MAIL_DIRECTORY), current_user.user_name);
",1,unused,356,unused,"  get_current_user_info ();
  mp = (char *)xmalloc (2 + sizeof (DEFAULT_MAIL_DIRECTORY) + strlen (current_user.user_name));
  strcpy (mp, DEFAULT_MAIL_DIRECTORY);
  mp[sizeof(DEFAULT_MAIL_DIRECTORY) - 1] = '/';
  strcpy (mp + sizeof (DEFAULT_MAIL_DIRECTORY), current_user.user_name);
",unused,bashdebstretche-mailcheck.c
"    case '\f': xbuf[1] = 'f'; break;
    case '\n': xbuf[1] = 'n'; break;
    case '\r': xbuf[1] = 'r'; break;
    case '\t': xbuf[1] = 't'; break;
    default: sprintf (xbuf, ""%d"", i); break;
",1,unused,145,unused,"    case '\f': xbuf[1] = 'f'; break;
    case '\n': xbuf[1] = 'n'; break;
    case '\r': xbuf[1] = 'r'; break;
    case '\t': xbuf[1] = 't'; break;
    default: sprintf (xbuf, ""%d"", i); break;
",unused,bashdebstretche-mksyntax.c
"
  /* allocate the string for the command and fill it in. */
  cscmd = (char *)xmalloc (cmdsize + 1);

  strcpy (cscmd, cs->command);			/* $0 */
",1,unused,1230,unused,"
  /* allocate the string for the command and fill it in. */
  cscmd = (char *)xmalloc (cmdsize + 1);

  strcpy (cscmd, cs->command);			/* $0 */
",unused,bashdebstretche-pcomplete.c
"    {
      t = sh_single_quote (cl->word->word ? cl->word->word : """");
      n = strlen (t);
      RESIZE_MALLOCED_BUFFER (cscmd, cmdlen, n + 2, cmdsize, 64);
      strcpy (cscmd + cmdlen, t);
",1,unused,1238,unused,"    {
      t = sh_single_quote (cl->word->word ? cl->word->word : """");
      n = strlen (t);
      RESIZE_MALLOCED_BUFFER (cscmd, cmdlen, n + 2, cmdsize, 64);
      strcpy (cscmd + cmdlen, t);
",unused,bashdebstretche-pcomplete.c
"		 a redirection. */
	      digit_arg = va_arg (args, int);
	      if (digit_arg < 0)
		{
		  sprintf (intbuf, ""%u"", (unsigned)-1);
",1,unused,1519,unused,"		 a redirection. */
	      digit_arg = va_arg (args, int);
	      if (digit_arg < 0)
		{
		  sprintf (intbuf, ""%u"", (unsigned)-1);
",unused,bashdebstretche-print_cmd.c
"
	  alloca_hack = (char *)
	    alloca (1 + strlen (new_redirect->redirectee.filename->word));
	  redirectee->word = alloca_hack;
	  strcpy (redirectee->word, new_redirect->redirectee.filename->word);
",1,unused,807,unused,"
	  alloca_hack = (char *)
	    alloca (1 + strlen (new_redirect->redirectee.filename->word));
	  redirectee->word = alloca_hack;
	  strcpy (redirectee->word, new_redirect->redirectee.filename->word);
",unused,bashdebstretche-redir.c
"		  t = quote_globbing_chars (text);
		  tlen = strlen (t);
		  RESIZE_MALLOCED_BUFFER (ret, ind, tlen, rlen, rlen);
		  r = ret + ind;	/* in case reallocated */
		  strcpy (r, t);
",1,unused,210,unused,"		  t = quote_globbing_chars (text);
		  tlen = strlen (t);
		  RESIZE_MALLOCED_BUFFER (ret, ind, tlen, rlen, rlen);
		  r = ret + ind;	/* in case reallocated */
		  strcpy (r, t);
",unused,bashdebstretche-stringlib.c
"	      else
		{
		  RESIZE_MALLOCED_BUFFER (ret, ind, len, rlen, rlen);
		  r = ret + ind;	/* in case reallocated */
		  strcpy (r, text);
",1,unused,218,unused,"	      else
		{
		  RESIZE_MALLOCED_BUFFER (ret, ind, len, rlen, rlen);
		  r = ret + ind;	/* in case reallocated */
		  strcpy (r, text);
",unused,bashdebstretche-stringlib.c
"
  t = result = (char *)xmalloc (slen + 1);

  if (strchr (string, CTLESC) == 0)
    return (strcpy (result, string));
",1,unused,3920,unused,"
  t = result = (char *)xmalloc (slen + 1);

  if (strchr (string, CTLESC) == 0)
    return (strcpy (result, string));
",unused,bashdebstretche-subst.c
"
  /* If no character in the string can be quoted, don't bother examining
     each character.  Just return a copy of the string passed to us. */
  if (strchr (string, CTLESC) == NULL)
    return (strcpy (result, string));
",1,unused,4052,unused,"
  /* If no character in the string can be quoted, don't bother examining
     each character.  Just return a copy of the string passed to us. */
  if (strchr (string, CTLESC) == NULL)
    return (strcpy (result, string));
",unused,bashdebstretche-subst.c
"
  if (string)
    {
      t = dequote_escapes (string);
      strcpy (string, t);
",1,unused,4121,unused,"
  if (string)
    {
      t = dequote_escapes (string);
      strcpy (string, t);
",unused,bashdebstretche-subst.c
"  val = sh_quote_reusable (s, 0);
  i = var_attribute_string (v, 0, flags);
  ret = (char *)xmalloc (i + strlen (val) + strlen (v->name) + 16 + MAX_ATTRIBUTES);
  if (i > 0)
    sprintf (ret, ""declare -%s %s=%s"", flags, v->name, val);
",1,unused,5042,unused,"  val = sh_quote_reusable (s, 0);
  i = var_attribute_string (v, 0, flags);
  ret = (char *)xmalloc (i + strlen (val) + strlen (v->name) + 16 + MAX_ATTRIBUTES);
  if (i > 0)
    sprintf (ret, ""declare -%s %s=%s"", flags, v->name, val);
",unused,bashdebstretche-subst.c
"  ret = (char *)xmalloc (i + strlen (val) + strlen (v->name) + 16 + MAX_ATTRIBUTES);
  if (i > 0)
    sprintf (ret, ""declare -%s %s=%s"", flags, v->name, val);
  else
    sprintf (ret, ""%s=%s"", v->name, val);
",1,unused,5044,unused,"  ret = (char *)xmalloc (i + strlen (val) + strlen (v->name) + 16 + MAX_ATTRIBUTES);
  if (i > 0)
    sprintf (ret, ""declare -%s %s=%s"", flags, v->name, val);
  else
    sprintf (ret, ""%s=%s"", v->name, val);
",unused,bashdebstretche-subst.c
"      val = ret;
    }
  i = var_attribute_string (v, 0, flags);
  ret = (char *)xmalloc (i + strlen (val) + strlen (v->name) + 16);
  sprintf (ret, ""declare -%s %s=%s"", flags, v->name, val);
",1,unused,5077,unused,"      val = ret;
    }
  i = var_attribute_string (v, 0, flags);
  ret = (char *)xmalloc (i + strlen (val) + strlen (v->name) + 16);
  sprintf (ret, ""declare -%s %s=%s"", flags, v->name, val);
",unused,bashdebstretche-subst.c
"
  /* first, we transform the list to quote each word. */
  temp = list_transform ('Q', (SHELL_VAR *)0, list, itype, quoted);
  ret = (char *)xmalloc (strlen (temp) + 8);
  strcpy (ret, ""set -- "");
",1,unused,5094,unused,"
  /* first, we transform the list to quote each word. */
  temp = list_transform ('Q', (SHELL_VAR *)0, list, itype, quoted);
  ret = (char *)xmalloc (strlen (temp) + 8);
  strcpy (ret, ""set -- "");
",unused,bashdebstretche-subst.c
"  /* first, we transform the list to quote each word. */
  temp = list_transform ('Q', (SHELL_VAR *)0, list, itype, quoted);
  ret = (char *)xmalloc (strlen (temp) + 8);
  strcpy (ret, ""set -- "");
  strcpy (ret + 7, temp);
",1,unused,5095,unused,"  /* first, we transform the list to quote each word. */
  temp = list_transform ('Q', (SHELL_VAR *)0, list, itype, quoted);
  ret = (char *)xmalloc (strlen (temp) + 8);
  strcpy (ret, ""set -- "");
  strcpy (ret + 7, temp);
",unused,bashdebstretche-subst.c
"  char *ret, intbuf[INT_STRLEN_BOUND (int) + 1], *p;

  ret = (char *)xmalloc (sizeof (DEV_FD_PREFIX) + 8);

  strcpy (ret, DEV_FD_PREFIX);
",1,unused,5694,unused,"  char *ret, intbuf[INT_STRLEN_BOUND (int) + 1], *p;

  ret = (char *)xmalloc (sizeof (DEV_FD_PREFIX) + 8);

  strcpy (ret, DEV_FD_PREFIX);
",unused,bashdebstretche-subst.c
"  ret = (char *)xmalloc (sizeof (DEV_FD_PREFIX) + 8);

  strcpy (ret, DEV_FD_PREFIX);
  p = inttostr (fd, intbuf, sizeof (intbuf));
  strcpy (ret + sizeof (DEV_FD_PREFIX) - 1, p);
",1,unused,5696,unused,"  ret = (char *)xmalloc (sizeof (DEV_FD_PREFIX) + 8);

  strcpy (ret, DEV_FD_PREFIX);
  p = inttostr (fd, intbuf, sizeof (intbuf));
  strcpy (ret + sizeof (DEV_FD_PREFIX) - 1, p);
",unused,bashdebstretche-subst.c
"    {
      int sindex;
      tt = (char *)xmalloc (2 + strlen (name));
      tt[sindex = 0] = '$';
      strcpy (tt + 1, name);
",1,unused,6501,unused,"    {
      int sindex;
      tt = (char *)xmalloc (2 + strlen (name));
      tt[sindex = 0] = '$';
      strcpy (tt + 1, name);
",unused,bashdebstretche-subst.c
"      replen = STRLEN (rep);
      l = STRLEN (string);
      ret = (char *)xmalloc (replen + l + 2);
      if (replen == 0)
	strcpy (ret, string);
",1,unused,7428,unused,"      replen = STRLEN (rep);
      l = STRLEN (string);
      ret = (char *)xmalloc (replen + l + 2);
      if (replen == 0)
	strcpy (ret, string);
",unused,bashdebstretche-subst.c
"      if (replen == 0)
	strcpy (ret, string);
      else if (mtype == MATCH_BEG)
	{
	  strcpy (ret, rep);
",1,unused,7431,unused,"      if (replen == 0)
	strcpy (ret, string);
      else if (mtype == MATCH_BEG)
	{
	  strcpy (ret, rep);
",unused,bashdebstretche-subst.c
"	strcpy (ret, string);
      else if (mtype == MATCH_BEG)
	{
	  strcpy (ret, rep);
	  strcpy (ret + replen, string);
",1,unused,7432,unused,"	strcpy (ret, string);
      else if (mtype == MATCH_BEG)
	{
	  strcpy (ret, rep);
	  strcpy (ret + replen, string);
",unused,bashdebstretche-subst.c
"	  strcpy (ret + replen, string);
	}
      else
	{
	  strcpy (ret, string);
",1,unused,7436,unused,"	  strcpy (ret + replen, string);
	}
      else
	{
	  strcpy (ret, string);
",unused,bashdebstretche-subst.c
"	}
      else
	{
	  strcpy (ret, string);
	  strcpy (ret + l, rep);
",1,unused,7437,unused,"	}
      else
	{
	  strcpy (ret, string);
	  strcpy (ret + l, rep);
",unused,bashdebstretche-subst.c
"      ret = (char *)xmalloc (replen + 1);
      if (replen == 0)
	ret[0] = '\0';
      else
	strcpy (ret, rep);
",1,unused,7448,unused,"      ret = (char *)xmalloc (replen + 1);
      if (replen == 0)
	ret[0] = '\0';
      else
	strcpy (ret, rep);
",unused,bashdebstretche-subst.c
"  /* Now copy the unmatched portion of the input string */
  if (str && *str)
    {
      RESIZE_MALLOCED_BUFFER (ret, rptr, STRLEN(str) + 1, rsize, 64);
      strcpy (ret + rptr, str);
",1,unused,7517,unused,"  /* Now copy the unmatched portion of the input string */
  if (str && *str)
    {
      RESIZE_MALLOCED_BUFFER (ret, rptr, STRLEN(str) + 1, rsize, 64);
      strcpy (ret + rptr, str);
",unused,bashdebstretche-subst.c
"      if (string[sindex] == '!')
	{
	  /* indirect reference of $#, $?, $@, or $* */
	  name[1] = string[sindex + 1];
	  strcpy (name + 2, temp1);
",1,unused,7989,unused,"      if (string[sindex] == '!')
	{
	  /* indirect reference of $#, $?, $@, or $* */
	  name[1] = string[sindex + 1];
	  strcpy (name + 2, temp1);
",unused,bashdebstretche-subst.c
"	  name[1] = string[sindex + 1];
	  strcpy (name + 2, temp1);
	}
      else	
	strcpy (name + 1, temp1);
",1,unused,7992,unused,"	  name[1] = string[sindex + 1];
	  strcpy (name + 2, temp1);
	}
      else	
	strcpy (name + 1, temp1);
",unused,bashdebstretche-subst.c
"	  tindex = sindex + 1;
	  temp = string_extract_single_quoted (string, &tindex);
	  if (temp)
	    {
	      strcpy (r, temp);
",1,unused,9891,unused,"	  tindex = sindex + 1;
	  temp = string_extract_single_quoted (string, &tindex);
	  if (temp)
	    {
	      strcpy (r, temp);
",unused,bashdebstretche-subst.c
"strduplicate(char *from)
{
	char   *new = stralloc(strlen(from));

	strcpy(new, from);
",1,unused,194,unused,"strduplicate(char *from)
{
	char   *new = stralloc(strlen(from));

	strcpy(new, from);
",unused,bashdebstretche-support2Fman2html.c
"	if (nr == current_size)
		return """";
	i = current_font;
	sizebuf[0] = '\0';
	strcat(sizebuf, change_to_font(0));
",1,unused,915,unused,"	if (nr == current_size)
		return """";
	i = current_font;
	sizebuf[0] = '\0';
	strcat(sizebuf, change_to_font(0));
",unused,bashdebstretche-support2Fman2html.c
"	i = current_font;
	sizebuf[0] = '\0';
	strcat(sizebuf, change_to_font(0));
	if (current_size)
		strcat(sizebuf, ""</FONT>"");
",1,unused,917,unused,"	i = current_font;
	sizebuf[0] = '\0';
	strcat(sizebuf, change_to_font(0));
	if (current_size)
		strcat(sizebuf, ""</FONT>"");
",unused,bashdebstretche-support2Fman2html.c
"	current_size = nr;
	if (nr) {
		int     l;

		strcat(sizebuf, ""<FONT SIZE="");
",1,unused,922,unused,"	current_size = nr;
	if (nr) {
		int     l;

		strcat(sizebuf, ""<FONT SIZE="");
",unused,bashdebstretche-support2Fman2html.c
"		sizebuf[l++] = nr + '0';
		sizebuf[l++] = '>';
		sizebuf[l] = '\0';
	}
	strcat(sizebuf, change_to_font(i));
",1,unused,932,unused,"		sizebuf[l++] = nr + '0';
		sizebuf[l++] = '>';
		sizebuf[l] = '\0';
	}
	strcat(sizebuf, change_to_font(i));
",unused,bashdebstretche-support2Fman2html.c
"				if (curfield->colspan > 1) {
					char    buf[5];

					out_html("" COLSPAN="");
					sprintf(buf, ""%i"", curfield->colspan);
",1,unused,1709,unused,"				if (curfield->colspan > 1) {
					char    buf[5];

					out_html("" COLSPAN="");
					sprintf(buf, ""%i"", curfield->colspan);
",unused,bashdebstretche-support2Fman2html.c
"				if (curfield->rowspan > 1) {
					char    buf[5];

					out_html("" ROWSPAN="");
					sprintf(buf, ""%i"", curfield->rowspan);
",1,unused,1716,unused,"				if (curfield->rowspan > 1) {
					char    buf[5];

					out_html("" ROWSPAN="");
					sprintf(buf, ""%i"", curfield->rowspan);
",unused,bashdebstretche-support2Fman2html.c
"	i = 0;
	while (i < l && c[i]) {
		if (c[i] == '\a') {
			if (c[i+1])
				strcpy(c + i, c + i + 1);	/* should be memmove */
",1,unused,1995,unused,"	i = 0;
	while (i < l && c[i]) {
		if (c[i] == '\a') {
			if (c[i+1])
				strcpy(c + i, c + i + 1);	/* should be memmove */
",unused,bashdebstretche-support2Fman2html.c
"		}
	}
	subs = level;
	scan_troff(item, 1, &c);
	sprintf(manidx + mip, ""<DT><A HREF=\""#%s\"">%s</A><DD>\n"", label, c);
",1,unused,2138,unused,"		}
	}
	subs = level;
	scan_troff(item, 1, &c);
	sprintf(manidx + mip, ""<DT><A HREF=\""#%s\"">%s</A><DD>\n"", label, c);
",unused,bashdebstretche-support2Fman2html.c
"					for (i = 1; i < words; i++)
						wordlist[i][-1] = '\0';
					*sl = '\0';
					output_possible = 1;
					sprintf(th_page_and_sec, ""%s(%s)"", wordlist[0], wordlist[1]);
",1,unused,2902,unused,"					for (i = 1; i < words; i++)
						wordlist[i][-1] = '\0';
					*sl = '\0';
					output_possible = 1;
					sprintf(th_page_and_sec, ""%s(%s)"", wordlist[0], wordlist[1]);
",unused,bashdebstretche-support2Fman2html.c
"      for (i = 1; i <= rtcnt; i++)
	{
	  signal_names[rtmin+i] = (char *)malloc(RTLEN);
	  if (signal_names[rtmin+i])
	    sprintf (signal_names[rtmin+i], ""SIGRTMIN+%d"", i);
",1,unused,125,unused,"      for (i = 1; i <= rtcnt; i++)
	{
	  signal_names[rtmin+i] = (char *)malloc(RTLEN);
	  if (signal_names[rtmin+i])
	    sprintf (signal_names[rtmin+i], ""SIGRTMIN+%d"", i);
",unused,bashdebstretche-support2Fsignames.c
"	  if (signal_names[rtmin+i])
	    sprintf (signal_names[rtmin+i], ""SIGRTMIN+%d"", i);
	  signal_names[rtmax-i] = (char *)malloc(RTLEN);
	  if (signal_names[rtmax-i])
	    sprintf (signal_names[rtmax-i], ""SIGRTMAX-%d"", i);
",1,unused,128,unused,"	  if (signal_names[rtmin+i])
	    sprintf (signal_names[rtmin+i], ""SIGRTMIN+%d"", i);
	  signal_names[rtmax-i] = (char *)malloc(RTLEN);
	  if (signal_names[rtmax-i])
	    sprintf (signal_names[rtmax-i], ""SIGRTMAX-%d"", i);
",unused,bashdebstretche-support2Fsignames.c
"	{
	  /* Need an extra RTMIN signal */
	  signal_names[rtmin+rtcnt+1] = (char *)malloc(RTLEN);
	  if (signal_names[rtmin+rtcnt+1])
	    sprintf (signal_names[rtmin+rtcnt+1], ""SIGRTMIN+%d"", rtcnt+1);
",1,unused,136,unused,"	{
	  /* Need an extra RTMIN signal */
	  signal_names[rtmin+rtcnt+1] = (char *)malloc(RTLEN);
	  if (signal_names[rtmin+rtcnt+1])
	    sprintf (signal_names[rtmin+rtcnt+1], ""SIGRTMIN+%d"", rtcnt+1);
",unused,bashdebstretche-support2Fsignames.c
"    if (signal_names[i] == (char *)NULL)
      {
	signal_names[i] = (char *)malloc (18);
	if (signal_names[i])
	  sprintf (signal_names[i], ""SIGJUNK(%d)"", i);
",1,unused,395,unused,"    if (signal_names[i] == (char *)NULL)
      {
	signal_names[i] = (char *)malloc (18);
	if (signal_names[i])
	  sprintf (signal_names[i], ""SIGJUNK(%d)"", i);
",unused,bashdebstretche-support2Fsignames.c
"      if (cdir)
	{
	  len = strlen (cdir);
	  name = (char *)xmalloc (len + strlen (shell_name) + 1);
	  strcpy (name, cdir);
",1,unused,748,unused,"      if (cdir)
	{
	  len = strlen (cdir);
	  name = (char *)xmalloc (len + strlen (shell_name) + 1);
	  strcpy (name, cdir);
",unused,bashdebstretche-variables.c
"	{
	  len = strlen (cdir);
	  name = (char *)xmalloc (len + strlen (shell_name) + 1);
	  strcpy (name, cdir);
	  strcpy (name + len, shell_name + 1);
",1,unused,749,unused,"	{
	  len = strlen (cdir);
	  name = (char *)xmalloc (len + strlen (shell_name) + 1);
	  strcpy (name, cdir);
	  strcpy (name + len, shell_name + 1);
",unused,bashdebstretche-variables.c
"  unbind_variable_noref (""BASH_VERSINFO"");

  vv = make_new_array_variable (""BASH_VERSINFO"");
  av = array_cell (vv);
  strcpy (d, dist_version);
",1,unused,961,unused,"  unbind_variable_noref (""BASH_VERSINFO"");

  vv = make_new_array_variable (""BASH_VERSINFO"");
  av = array_cell (vv);
  strcpy (d, dist_version);
",unused,bashdebstretche-variables.c
"	  if (oval == 0)	/* paranoia */
	    oval = """";
	  olen = STRLEN (oval);
	  retval = (char *)xmalloc (olen + (value ? STRLEN (value) : 0) + 1);
	  strcpy (retval, oval);
",1,unused,2638,unused,"	  if (oval == 0)	/* paranoia */
	    oval = """";
	  olen = STRLEN (oval);
	  retval = (char *)xmalloc (olen + (value ? STRLEN (value) : 0) + 1);
	  strcpy (retval, oval);
",unused,bashdebstretche-variables.c
"	  olen = STRLEN (oval);
	  retval = (char *)xmalloc (olen + (value ? STRLEN (value) : 0) + 1);
	  strcpy (retval, oval);
	  if (value)
	    strcpy (retval+olen, value);
",1,unused,2640,unused,"	  olen = STRLEN (oval);
	  retval = (char *)xmalloc (olen + (value ? STRLEN (value) : 0) + 1);
	  strcpy (retval, oval);
	  if (value)
	    strcpy (retval+olen, value);
",unused,bashdebstretche-variables.c
"	  if (oval == 0)	/* paranoia */
	    oval = """";
	  olen = STRLEN (oval);
	  retval = (char *)xmalloc (olen + (value ? STRLEN (value) : 0) + 1);
	  strcpy (retval, oval);
",1,unused,2665,unused,"	  if (oval == 0)	/* paranoia */
	    oval = """";
	  olen = STRLEN (oval);
	  retval = (char *)xmalloc (olen + (value ? STRLEN (value) : 0) + 1);
	  strcpy (retval, oval);
",unused,bashdebstretche-variables.c
"	  olen = STRLEN (oval);
	  retval = (char *)xmalloc (olen + (value ? STRLEN (value) : 0) + 1);
	  strcpy (retval, oval);
	  if (value)
	    strcpy (retval+olen, value);
",1,unused,2667,unused,"	  olen = STRLEN (oval);
	  retval = (char *)xmalloc (olen + (value ? STRLEN (value) : 0) + 1);
	  strcpy (retval, oval);
	  if (value)
	    strcpy (retval+olen, value);
",unused,bashdebstretche-variables.c
"{
  char *evar;

  evar = (char *)xmalloc (STRLEN (value) + preflen + 1);
  strcpy (evar, env_prefix);
",1,unused,4540,unused,"{
  char *evar;

  evar = (char *)xmalloc (STRLEN (value) + preflen + 1);
  strcpy (evar, env_prefix);
",unused,bashdebstretche-variables.c
"
  evar = (char *)xmalloc (STRLEN (value) + preflen + 1);
  strcpy (evar, env_prefix);
  if (value)
    strcpy (evar + preflen, value);
",1,unused,4542,unused,"
  evar = (char *)xmalloc (STRLEN (value) + preflen + 1);
  strcpy (evar, env_prefix);
  if (value)
    strcpy (evar + preflen, value);
",unused,bashdebstretche-variables.c
"  char *r;

  l = strlen (s);
  r = xmalloc (l + 2);
  strcpy (r, s);
",1,unused,5102,unused,"  char *r;

  l = strlen (s);
  r = xmalloc (l + 2);
  strcpy (r, s);
",unused,bashdebstretche-y.tab.c
"	    return -1;		/* Bail immediately. */
	  RESIZE_MALLOCED_BUFFER (token, token_index, ttoklen + 2,
				  token_buffer_size, TOKEN_DEFAULT_GROW_SIZE);
	  token[token_index++] = character;
	  strcpy (token + token_index, ttok);
",1,unused,7064,unused,"	    return -1;		/* Bail immediately. */
	  RESIZE_MALLOCED_BUFFER (token, token_index, ttoklen + 2,
				  token_buffer_size, TOKEN_DEFAULT_GROW_SIZE);
	  token[token_index++] = character;
	  strcpy (token + token_index, ttok);
",unused,bashdebstretche-y.tab.c
"	    return -1;		/* Bail immediately. */
	  RESIZE_MALLOCED_BUFFER (token, token_index, ttoklen + 2,
				  token_buffer_size, TOKEN_DEFAULT_GROW_SIZE);
	  token[token_index++] = character;
	  strcpy (token + token_index, ttok);
",1,unused,7090,unused,"	    return -1;		/* Bail immediately. */
	  RESIZE_MALLOCED_BUFFER (token, token_index, ttoklen + 2,
				  token_buffer_size, TOKEN_DEFAULT_GROW_SIZE);
	  token[token_index++] = character;
	  strcpy (token + token_index, ttok);
",unused,bashdebstretche-y.tab.c
"				      token_buffer_size,
				      TOKEN_DEFAULT_GROW_SIZE);
	      token[token_index++] = character;
	      token[token_index++] = peek_char;
	      strcpy (token + token_index, ttok);
",1,unused,7115,unused,"				      token_buffer_size,
				      TOKEN_DEFAULT_GROW_SIZE);
	      token[token_index++] = character;
	      token[token_index++] = peek_char;
	      strcpy (token + token_index, ttok);
",unused,bashdebstretche-y.tab.c
"				      token_buffer_size,
				      TOKEN_DEFAULT_GROW_SIZE);
	      token[token_index++] = character;
	      token[token_index++] = peek_char;
	      strcpy (token + token_index, ttok);
",1,unused,7157,unused,"				      token_buffer_size,
				      TOKEN_DEFAULT_GROW_SIZE);
	      token[token_index++] = character;
	      token[token_index++] = peek_char;
	      strcpy (token + token_index, ttok);
",unused,bashdebstretche-y.tab.c
"
	      RESIZE_MALLOCED_BUFFER (token, token_index, ttranslen + 1,
				      token_buffer_size,
				      TOKEN_DEFAULT_GROW_SIZE);
	      strcpy (token + token_index, ttrans);
",1,unused,7206,unused,"
	      RESIZE_MALLOCED_BUFFER (token, token_index, ttranslen + 1,
				      token_buffer_size,
				      TOKEN_DEFAULT_GROW_SIZE);
	      strcpy (token + token_index, ttrans);
",unused,bashdebstretche-y.tab.c
"	  RESIZE_MALLOCED_BUFFER (token, token_index, ttoklen + 2,
				  token_buffer_size,
				  TOKEN_DEFAULT_GROW_SIZE);
	  token[token_index++] = character;
	  strcpy (token + token_index, ttok);
",1,unused,7245,unused,"	  RESIZE_MALLOCED_BUFFER (token, token_index, ttoklen + 2,
				  token_buffer_size,
				  TOKEN_DEFAULT_GROW_SIZE);
	  token[token_index++] = character;
	  strcpy (token + token_index, ttok);
",unused,bashdebstretche-y.tab.c
"	      token[token_index++] = '=';
	      token[token_index++] = '(';
	      if (ttok)
		{
		  strcpy (token + token_index, ttok);
",1,unused,7267,unused,"	      token[token_index++] = '=';
	      token[token_index++] = '(';
	      if (ttok)
		{
		  strcpy (token + token_index, ttok);
",unused,bashdebstretche-y.tab.c
"
  the_word = alloc_word_desc ();
  the_word->word = (char *)xmalloc (1 + token_index);
  the_word->flags = 0;
  strcpy (the_word->word, token);
",1,unused,7373,unused,"
  the_word = alloc_word_desc ();
  the_word->word = (char *)xmalloc (1 + token_index);
  the_word->flags = 0;
  strcpy (the_word->word, token);
",unused,bashdebstretche-y.tab.c
"#else
      if (legal_identifier (token+1))
#endif
	{
	  strcpy (the_word->word, token+1);
",1,unused,7418,unused,"#else
      if (legal_identifier (token+1))
#endif
	{
	  strcpy (the_word->word, token+1);
",unused,bashdebstretche-y.tab.c
"	    case 'v':
	    case 'V':
	      temp = (char *)xmalloc (16);
	      if (c == 'v')
		strcpy (temp, dist_version);
",1,unused,7915,unused,"	    case 'v':
	    case 'V':
	      temp = (char *)xmalloc (16);
	      if (c == 'v')
		strcpy (temp, dist_version);
",unused,bashdebstretche-y.tab.c
"	      temp = (char *)xmalloc (16);
	      if (c == 'v')
		strcpy (temp, dist_version);
	      else
		sprintf (temp, ""%s.%d"", dist_version, patch_level);
",1,unused,7917,unused,"	      temp = (char *)xmalloc (16);
	      if (c == 'v')
		strcpy (temp, dist_version);
	      else
		sprintf (temp, ""%s.%d"", dist_version, patch_level);
",unused,bashdebstretche-y.tab.c
"		    /* polite_directory_format is guaranteed to return a string
		       no longer than PATH_MAX - 1 characters. */
		    temp = polite_directory_format (t_string);
		    if (temp != t_string)
		      strcpy (t_string, temp);
",1,unused,7973,unused,"		    /* polite_directory_format is guaranteed to return a string
		       no longer than PATH_MAX - 1 characters. */
		    temp = polite_directory_format (t_string);
		    if (temp != t_string)
		      strcpy (t_string, temp);
",unused,bashdebstretche-y.tab.c
"
	  /* +3 because we possibly add one more character below. */
	  RESIZE_MALLOCED_BUFFER (line, llen, (vlen + 3), line_len, (vlen + 50));

	  strcpy (line + llen, v);
",1,unused,562,unused,"
	  /* +3 because we possibly add one more character below. */
	  RESIZE_MALLOCED_BUFFER (line, llen, (vlen + 3), line_len, (vlen + 50));

	  strcpy (line + llen, v);
",unused,bashsources-alias.c
"			t = quoted ? quote_string(element_value(ae)) : element_value(ae);
			reg = strlen(t);
			RESIZE_MALLOCED_BUFFER (result, rlen, (reg + slen + 2),
						rsize, rsize);
			strcpy(result + rlen, t);
",1,unused,838,unused,"			t = quoted ? quote_string(element_value(ae)) : element_value(ae);
			reg = strlen(t);
			RESIZE_MALLOCED_BUFFER (result, rlen, (reg + slen + 2),
						rsize, rsize);
			strcpy(result + rlen, t);
",unused,bashsources-array.c
"			/*
			 * Add a separator only after non-null elements.
			 */
			if (element_forw(ae) != end) {
				strcpy(result + rlen, sep);
",1,unused,846,unused,"			/*
			 * Add a separator only after non-null elements.
			 */
			if (element_forw(ae) != end) {
				strcpy(result + rlen, sep);
",unused,bashsources-array.c
"		elen = STRLEN (is) + 8 + STRLEN (valstr);
		RESIZE_MALLOCED_BUFFER (result, rlen, (elen + 1), rsize, rsize);

		result[rlen++] = '[';
		strcpy (result + rlen, is);
",1,unused,884,unused,"		elen = STRLEN (is) + 8 + STRLEN (valstr);
		RESIZE_MALLOCED_BUFFER (result, rlen, (elen + 1), rsize, rsize);

		result[rlen++] = '[';
		strcpy (result + rlen, is);
",unused,bashsources-array.c
"		rlen += STRLEN (is);
		result[rlen++] = ']';
		result[rlen++] = '=';
		if (valstr) {
			strcpy (result + rlen, valstr);
",1,unused,889,unused,"		rlen += STRLEN (is);
		result[rlen++] = ']';
		result[rlen++] = '=';
		if (valstr) {
			strcpy (result + rlen, valstr);
",unused,bashsources-array.c
"	  new_line = (char *)xmalloc (1
				      + curlen
				      + strlen (line)
				      + strlen (chars_to_add));
	  sprintf (new_line, ""%s%s%s"", current->line, chars_to_add, line);
",1,unused,838,unused,"	  new_line = (char *)xmalloc (1
				      + curlen
				      + strlen (line)
				      + strlen (chars_to_add));
	  sprintf (new_line, ""%s%s%s"", current->line, chars_to_add, line);
",unused,bashsources-bashhist.c
"	}
      else
	{
	  nval[0] = '@';
	  strcpy (nval + 1, rl_completer_word_break_characters);
",1,unused,404,unused,"	}
      else
	{
	  nval[0] = '@';
	  strcpy (nval + 1, rl_completer_word_break_characters);
",unused,bashsources-bashline.c
"
  if (rl_explicit_arg)
    {
      command = (char *)xmalloc (strlen (edit_command) + 8);
      sprintf (command, ""%s %d"", edit_command, count);
",1,unused,961,unused,"
  if (rl_explicit_arg)
    {
      command = (char *)xmalloc (strlen (edit_command) + 8);
      sprintf (command, ""%s %d"", edit_command, count);
",unused,bashsources-bashline.c
"	value[0] = *orig_start;
      else
	strncpy (value, orig_start, start_len);

      strcpy (value + start_len, matches[cmd_index]);
",1,unused,2291,unused,"	value[0] = *orig_start;
      else
	strncpy (value, orig_start, start_len);

      strcpy (value + start_len, matches[cmd_index]);
",unused,bashsources-bashline.c
"	  if (first_char_loc == 2)
	    value[1] = '{';
	}

      strcpy (value + first_char_loc, varlist[varlist_index]);
",1,unused,2351,unused,"	  if (first_char_loc == 2)
	    value[1] = '{';
	}

      strcpy (value + first_char_loc, varlist[varlist_index]);
",unused,bashsources-bashline.c
"	}

      strcpy (value + first_char_loc, varlist[varlist_index]);
      if (first_char_loc == 2)
	strcat (value, ""}"");
",1,unused,2353,unused,"	}

      strcpy (value + first_char_loc, varlist[varlist_index]);
      if (first_char_loc == 2)
	strcat (value, ""}"");
",unused,bashsources-bashline.c
"      char *t;

      t = (char *)xmalloc (2 + strlen (list[list_index]));
      *t = first_char;
      strcpy (t + first_char_loc, list[list_index]);
",1,unused,2393,unused,"      char *t;

      t = (char *)xmalloc (2 + strlen (list[list_index]));
      *t = first_char;
      strcpy (t + first_char_loc, list[list_index]);
",unused,bashsources-bashline.c
"  */
  l = (vl - xl) + 1;

  ret = (char *)xmalloc (dl2 + 2 + l);
  strcpy (ret, dh2);
",1,unused,2994,unused,"  */
  l = (vl - xl) + 1;

  ret = (char *)xmalloc (dl2 + 2 + l);
  strcpy (ret, dh2);
",unused,bashsources-bashline.c
"  l = (vl - xl) + 1;

  ret = (char *)xmalloc (dl2 + 2 + l);
  strcpy (ret, dh2);
  strcpy (ret + dl2, val + xl);
",1,unused,2995,unused,"  l = (vl - xl) + 1;

  ret = (char *)xmalloc (dl2 + 2 + l);
  strcpy (ret, dh2);
  strcpy (ret + dl2, val + xl);
",unused,bashsources-bashline.c
"	{
	  globorig = savestring (ttext);
	  glen = strlen (ttext);
	  globtext = (char *)xmalloc (glen + 2);
	  strcpy (globtext, ttext);
",1,unused,3688,unused,"	{
	  globorig = savestring (ttext);
	  glen = strlen (ttext);
	  globtext = (char *)xmalloc (glen + 2);
	  strcpy (globtext, ttext);
",unused,bashsources-bashline.c
"  if (rtext)
    {
      rlen = strlen (rtext);
      ret = (char *)xmalloc (rlen + 1);
      strcpy (ret, rtext);
",1,unused,4034,unused,"  if (rtext)
    {
      rlen = strlen (rtext);
      ret = (char *)xmalloc (rlen + 1);
      strcpy (ret, rtext);
",unused,bashsources-bashline.c
"	  subterm = sh_backslash_quote (x, 0, 0);
	  free (x);
	  result_size += strlen (subterm) + 1;
	  result = (char *)xrealloc (result, result_size);
	  strcat (result, subterm);
",1,unused,133,unused,"	  subterm = sh_backslash_quote (x, 0, 0);
	  free (x);
	  result_size += strlen (subterm) + 1;
	  result = (char *)xrealloc (result, result_size);
	  strcat (result, subterm);
",unused,bashsources-bracecomp.c
"	  result_size += strlen (subterm) + 1;
	  result = (char *)xrealloc (result, result_size);
	  strcat (result, subterm);
	  free (subterm);
	  strcat (result, ""{"");
",1,unused,135,unused,"	  result_size += strlen (subterm) + 1;
	  result = (char *)xrealloc (result, result_size);
	  strcat (result, subterm);
	  free (subterm);
	  strcat (result, ""{"");
",unused,bashsources-bracecomp.c
"	}

      result_size += strlen (subterm) + 1;
      result = (char *)xrealloc (result, result_size);
      strcat (result, subterm);
",1,unused,142,unused,"	}

      result_size += strlen (subterm) + 1;
      result = (char *)xrealloc (result, result_size);
      strcat (result, subterm);
",unused,bashsources-bracecomp.c
"
      result_size += strlen (subterm) + 1;
      result = (char *)xrealloc (result, result_size);
      strcat (result, subterm);
      strcat (result, "","");
",1,unused,143,unused,"
      result_size += strlen (subterm) + 1;
      result = (char *)xrealloc (result, result_size);
      strcat (result, subterm);
      strcat (result, "","");
",unused,bashsources-bracecomp.c
"
      for (j = 0; j < len2; j++)
	{
	  result[len] = (char *)xmalloc (1 + strlen_1 + strlen (arr2[j]));
	  strcpy (result[len], arr1[i]);
",1,unused,803,unused,"
      for (j = 0; j < len2; j++)
	{
	  result[len] = (char *)xmalloc (1 + strlen_1 + strlen (arr2[j]));
	  strcpy (result[len], arr1[i]);
",unused,bashsources-braces.c
"      for (j = 0; j < len2; j++)
	{
	  result[len] = (char *)xmalloc (1 + strlen_1 + strlen (arr2[j]));
	  strcpy (result[len], arr1[i]);
	  strcpy (result[len] + strlen_1, arr2[j]);
",1,unused,804,unused,"      for (j = 0; j < len2; j++)
	{
	  result[len] = (char *)xmalloc (1 + strlen_1 + strlen (arr2[j]));
	  strcpy (result[len], arr1[i]);
	  strcpy (result[len] + strlen_1, arr2[j]);
",unused,bashsources-braces.c
"	  if (error_directory)
	    free (error_directory);

	  error_directory = xmalloc (2 + strlen (argv[arg_index]));
	  strcpy (error_directory, argv[arg_index]);
",1,unused,248,unused,"	  if (error_directory)
	    free (error_directory);

	  error_directory = xmalloc (2 + strlen (argv[arg_index]));
	  strcpy (error_directory, argv[arg_index]);
",unused,bashsources-builtins2Fmkbuiltins.c
"	  strcpy (error_directory, argv[arg_index]);
	  len = strlen (error_directory);

	  if (len && error_directory[len - 1] != '/')
	    strcat (error_directory, ""/"");
",1,unused,252,unused,"	  strcpy (error_directory, argv[arg_index]);
	  len = strlen (error_directory);

	  if (len && error_directory[len - 1] != '/')
	    strcat (error_directory, ""/"");
",unused,bashsources-builtins2Fmkbuiltins.c
"      /* Open the files. */
      if (struct_filename)
	{
	  temp_struct_filename = xmalloc (15);
	  sprintf (temp_struct_filename, ""mk-%ld"", (long) getpid ());
",1,unused,285,unused,"      /* Open the files. */
      if (struct_filename)
	{
	  temp_struct_filename = xmalloc (15);
	  sprintf (temp_struct_filename, ""mk-%ld"", (long) getpid ());
",unused,bashsources-builtins2Fmkbuiltins.c
"      if (separate_helpfiles)
	{
	  int l = strlen (helpfile_directory) + strlen (dname) + 1;
	  sarray[0] = (char *)xmalloc (l + 1);
	  sprintf (sarray[0], ""%s/%s"", helpfile_directory, dname);
",1,unused,1337,unused,"      if (separate_helpfiles)
	{
	  int l = strlen (helpfile_directory) + strlen (dname) + 1;
	  sarray[0] = (char *)xmalloc (l + 1);
	  sprintf (sarray[0], ""%s/%s"", helpfile_directory, dname);
",unused,bashsources-builtins2Fmkbuiltins.c
"      builtin = (BUILTIN_DESC *)builtins->array[i];

      bname = document_name (builtin);
      helpfile = (char *)xmalloc (hdlen + strlen (bname) + 1);
      sprintf (helpfile, ""helpfiles/%s"", bname);
",1,unused,1589,unused,"      builtin = (BUILTIN_DESC *)builtins->array[i];

      bname = document_name (builtin);
      helpfile = (char *)xmalloc (hdlen + strlen (bname) + 1);
      sprintf (helpfile, ""helpfiles/%s"", bname);
",unused,bashsources-builtins2Fmkbuiltins.c
"	  sum = cpu / 100;
	  sum_frac = (cpu % 100) * 10;
	  len = mkfmt (ts, 2, 0, sum, sum_frac);
	  RESIZE_MALLOCED_BUFFER (str, sindex, len, ssize, 64);
	  strcpy (str + sindex, ts);
",1,unused,1249,unused,"	  sum = cpu / 100;
	  sum_frac = (cpu % 100) * 10;
	  len = mkfmt (ts, 2, 0, sum, sum_frac);
	  RESIZE_MALLOCED_BUFFER (str, sindex, len, ssize, 64);
	  strcpy (str + sindex, ts);
",unused,bashsources-execute_cmd.c
"	      free (str);
	      return;
	    }
	  RESIZE_MALLOCED_BUFFER (str, sindex, len, ssize, 64);
	  strcpy (str + sindex, ts);
",1,unused,1280,unused,"	      free (str);
	      return;
	    }
	  RESIZE_MALLOCED_BUFFER (str, sindex, len, ssize, 64);
	  strcpy (str + sindex, ts);
",unused,bashsources-execute_cmd.c
"  bind_variable (namevar, t, 0);
  free (t);
#endif

  sprintf (namevar, ""%s_PID"", cp->c_name);
",1,unused,2222,unused,"  bind_variable (namevar, t, 0);
  free (t);
#endif

  sprintf (namevar, ""%s_PID"", cp->c_name);
",unused,bashsources-execute_cmd.c
"
  l = strlen (cp->c_name);
  namevar = xmalloc (l + 16);

  sprintf (namevar, ""%s_PID"", cp->c_name);
",1,unused,2243,unused,"
  l = strlen (cp->c_name);
  namevar = xmalloc (l + 16);

  sprintf (namevar, ""%s_PID"", cp->c_name);
",unused,bashsources-execute_cmd.c
"
  llen = strlen (vname) + sizeof (ibuf) + 3;
  lhs = xmalloc (llen);

  sprintf (lhs, ""%s[%s]"", vname, istr);		/* XXX */
",1,unused,342,unused,"
  llen = strlen (vname) + sizeof (ibuf) + 3;
  lhs = xmalloc (llen);

  sprintf (lhs, ""%s[%s]"", vname, istr);		/* XXX */
",unused,bashsources-expr.c
"      if (tail[0] != '.' || tail[1] != '/')
	{
	  dotted_filename = (char *)xmalloc (3 + strlen (tail));
	  dotted_filename[0] = '.'; dotted_filename[1] = '/';
	  strcpy (dotted_filename + 2, tail);
",1,unused,155,unused,"      if (tail[0] != '.' || tail[1] != '/')
	{
	  dotted_filename = (char *)xmalloc (3 + strlen (tail));
	  dotted_filename[0] = '.'; dotted_filename[1] = '/';
	  strcpy (dotted_filename + 2, tail);
",unused,bashsources-hashcmd.c
"	  lose = 1;
	}
      else
	{
	  strcpy (npat, pat);
",1,unused,644,unused,"	  lose = 1;
	}
      else
	{
	  strcpy (npat, pat);
",unused,bashsources-lib2Fglob2Fglob.c
"	{
	  strcpy (npat, pat);
	  dequote_pathname (npat);

	  strcpy (nextname, dir);
",1,unused,647,unused,"	{
	  strcpy (npat, pat);
	  dequote_pathname (npat);

	  strcpy (nextname, dir);
",unused,bashsources-lib2Fglob2Fglob.c
"	  dequote_pathname (npat);

	  strcpy (nextname, dir);
	  nextname[dirlen++] = '/';
	  strcpy (nextname + dirlen, npat);
",1,unused,649,unused,"	  dequote_pathname (npat);

	  strcpy (nextname, dir);
	  nextname[dirlen++] = '/';
	  strcpy (nextname + dirlen, npat);
",unused,bashsources-lib2Fglob2Fglob.c
"	  free (result);
	  return (NULL);
	}

      strcpy (result[i], dir);
",1,unused,986,unused,"	  free (result);
	  return (NULL);
	}

      strcpy (result[i], dir);
",unused,bashsources-lib2Fglob2Fglob.c
"
      strcpy (result[i], dir);
      if (add_slash)
	result[i][l] = '/';
      strcpy (result[i] + l + add_slash, array[i]);
",1,unused,989,unused,"
      strcpy (result[i], dir);
      if (add_slash)
	result[i][l] = '/';
      strcpy (result[i] + l + add_slash, array[i]);
",unused,bashsources-lib2Fglob2Fglob.c
"		       with the eighth bit set to ESC-prefixed sequences, then
		       we can use \M-.  Otherwise we need to use the sequence
		       for ESC. */
		    if (_rl_convert_meta_chars_to_ascii && map[ESC].type == ISKMAP)
		      sprintf (keyname, ""\\M-"");
",1,unused,2304,unused,"		       with the eighth bit set to ESC-prefixed sequences, then
		       we can use \M-.  Otherwise we need to use the sequence
		       for ESC. */
		    if (_rl_convert_meta_chars_to_ascii && map[ESC].type == ISKMAP)
		      sprintf (keyname, ""\\M-"");
",unused,bashsources-lib2Freadline2Fbind.c
"		       for ESC. */
		    if (_rl_convert_meta_chars_to_ascii && map[ESC].type == ISKMAP)
		      sprintf (keyname, ""\\M-"");
		    else
		      sprintf (keyname, ""\\e"");
",1,unused,2306,unused,"		       for ESC. */
		    if (_rl_convert_meta_chars_to_ascii && map[ESC].type == ISKMAP)
		      sprintf (keyname, ""\\M-"");
		    else
		      sprintf (keyname, ""\\e"");
",unused,bashsources-lib2Freadline2Fbind.c
"		    else
		      sprintf (keyname, ""\\e"");
		  }
		else if (CTRL_CHAR (key))
		  sprintf (keyname, ""\\C-%c"", _rl_to_lower (UNCTRL (key)));
",1,unused,2309,unused,"		    else
		      sprintf (keyname, ""\\e"");
		  }
		else if (CTRL_CHAR (key))
		  sprintf (keyname, ""\\C-%c"", _rl_to_lower (UNCTRL (key)));
",unused,bashsources-lib2Freadline2Fbind.c
"		  }
		else if (CTRL_CHAR (key))
		  sprintf (keyname, ""\\C-%c"", _rl_to_lower (UNCTRL (key)));
		else if (key == RUBOUT)
		  sprintf (keyname, ""\\C-?"");
",1,unused,2311,unused,"		  }
		else if (CTRL_CHAR (key))
		  sprintf (keyname, ""\\C-%c"", _rl_to_lower (UNCTRL (key)));
		else if (key == RUBOUT)
		  sprintf (keyname, ""\\C-?"");
",unused,bashsources-lib2Freadline2Fbind.c
"		    keyname[0] = (char) key;
		    keyname[1] = '\0';
		  }
		
		strcat (keyname, seqs[i]);
",1,unused,2324,unused,"		    keyname[0] = (char) key;
		    keyname[1] = '\0';
		  }
		
		strcat (keyname, seqs[i]);
",unused,bashsources-lib2Freadline2Fbind.c
"	  if (key == ESC)
	    {
	      keyname = (char *)xmalloc (3 + prefix_len);
	      if (prefix)
		strcpy (keyname, prefix);
",1,unused,2477,unused,"	  if (key == ESC)
	    {
	      keyname = (char *)xmalloc (3 + prefix_len);
	      if (prefix)
		strcpy (keyname, prefix);
",unused,bashsources-lib2Freadline2Fbind.c
"	      keyname = _rl_get_keyname (key);
	      if (prefix)
		{
		  out = (char *)xmalloc (strlen (keyname) + prefix_len + 1);
		  strcpy (out, prefix);
",1,unused,2488,unused,"	      keyname = _rl_get_keyname (key);
	      if (prefix)
		{
		  out = (char *)xmalloc (strlen (keyname) + prefix_len + 1);
		  strcpy (out, prefix);
",unused,bashsources-lib2Freadline2Fbind.c
"	      if (prefix)
		{
		  out = (char *)xmalloc (strlen (keyname) + prefix_len + 1);
		  strcpy (out, prefix);
		  strcpy (out + prefix_len, keyname);
",1,unused,2489,unused,"	      if (prefix)
		{
		  out = (char *)xmalloc (strlen (keyname) + prefix_len + 1);
		  strcpy (out, prefix);
		  strcpy (out + prefix_len, keyname);
",unused,bashsources-lib2Freadline2Fbind.c
"  else if (_rl_stricmp (name, ""comment-begin"") == 0)
    return (_rl_comment_begin ? _rl_comment_begin : RL_COMMENT_BEGIN_DEFAULT);
  else if (_rl_stricmp (name, ""completion-display-width"") == 0)
    {
      sprintf (numbuf, ""%d"", _rl_completion_columns);
",1,unused,2544,unused,"  else if (_rl_stricmp (name, ""comment-begin"") == 0)
    return (_rl_comment_begin ? _rl_comment_begin : RL_COMMENT_BEGIN_DEFAULT);
  else if (_rl_stricmp (name, ""completion-display-width"") == 0)
    {
      sprintf (numbuf, ""%d"", _rl_completion_columns);
",unused,bashsources-lib2Freadline2Fbind.c
"      return (numbuf);
    }
  else if (_rl_stricmp (name, ""completion-prefix-display-length"") == 0)
    {
      sprintf (numbuf, ""%d"", _rl_completion_prefix_display_length);
",1,unused,2549,unused,"      return (numbuf);
    }
  else if (_rl_stricmp (name, ""completion-prefix-display-length"") == 0)
    {
      sprintf (numbuf, ""%d"", _rl_completion_prefix_display_length);
",unused,bashsources-lib2Freadline2Fbind.c
"      return (numbuf);
    }
  else if (_rl_stricmp (name, ""completion-query-items"") == 0)
    {
      sprintf (numbuf, ""%d"", rl_completion_query_items);
",1,unused,2554,unused,"      return (numbuf);
    }
  else if (_rl_stricmp (name, ""completion-query-items"") == 0)
    {
      sprintf (numbuf, ""%d"", rl_completion_query_items);
",unused,bashsources-lib2Freadline2Fbind.c
"  else if (_rl_stricmp (name, ""editing-mode"") == 0)
    return (rl_get_keymap_name_from_edit_mode ());
  else if (_rl_stricmp (name, ""history-size"") == 0)
    {
      sprintf (numbuf, ""%d"", history_is_stifled() ? history_max_entries : 0);
",1,unused,2561,unused,"  else if (_rl_stricmp (name, ""editing-mode"") == 0)
    return (rl_get_keymap_name_from_edit_mode ());
  else if (_rl_stricmp (name, ""history-size"") == 0)
    {
      sprintf (numbuf, ""%d"", history_is_stifled() ? history_max_entries : 0);
",unused,bashsources-lib2Freadline2Fbind.c
"      return (ret ? ret : ""none"");
    }
  else if (_rl_stricmp (name, ""keyseq-timeout"") == 0)
    {
      sprintf (numbuf, ""%d"", _rl_keyseq_timeout);    
",1,unused,2588,unused,"      return (ret ? ret : ""none"");
    }
  else if (_rl_stricmp (name, ""keyseq-timeout"") == 0)
    {
      sprintf (numbuf, ""%d"", _rl_keyseq_timeout);    
",unused,bashsources-lib2Freadline2Fbind.c
"
	  slen = strlen (s);
	  tlen = strlen (to_print);
	  new_full_pathname = (char *)xmalloc (slen + tlen + 2);
	  strcpy (new_full_pathname, s);
",1,unused,986,unused,"
	  slen = strlen (s);
	  tlen = strlen (to_print);
	  new_full_pathname = (char *)xmalloc (slen + tlen + 2);
	  strcpy (new_full_pathname, s);
",unused,bashsources-lib2Freadline2Fcomplete.c
"	    slen--;
	  else
	    new_full_pathname[slen] = '/';
	  new_full_pathname[slen] = '/';
	  strcpy (new_full_pathname + slen + 1, to_print);
",1,unused,992,unused,"	    slen--;
	  else
	    new_full_pathname[slen] = '/';
	  new_full_pathname[slen] = '/';
	  strcpy (new_full_pathname + slen + 1, to_print);
",unused,bashsources-lib2Freadline2Fcomplete.c
"  char *r;

  r = (char *)xmalloc (strlen (s) + 2);
  *r = *rl_completer_quote_characters;
  strcpy (r + 1, s);
",1,unused,1061,unused,"  char *r;

  r = (char *)xmalloc (strlen (s) + 2);
  *r = *rl_completer_quote_characters;
  strcpy (r + 1, s);
",unused,bashsources-lib2Freadline2Fcomplete.c
"     value of matches[0]. */
  if (low == 0 && text && *text)
    {
      match_list[0] = (char *)xmalloc (strlen (text) + 1);
      strcpy (match_list[0], text);
",1,unused,1421,unused,"     value of matches[0]. */
  if (low == 0 && text && *text)
    {
      match_list[0] = (char *)xmalloc (strlen (text) + 1);
      strcpy (match_list[0], text);
",unused,bashsources-lib2Freadline2Fcomplete.c
"      value = (char *)xmalloc (2 + strlen (entry->pw_name));

      *value = *text;

      strcpy (value + first_char_loc, entry->pw_name);
",1,unused,2327,unused,"      value = (char *)xmalloc (2 + strlen (entry->pw_name));

      *value = *text;

      strcpy (value + first_char_loc, entry->pw_name);
",unused,bashsources-lib2Freadline2Fcomplete.c
"#endif

      if (temp)
	{
	  strcpy (filename, ++temp);
",1,unused,2518,unused,"#endif

      if (temp)
	{
	  strcpy (filename, ++temp);
",unused,bashsources-lib2Freadline2Fcomplete.c
"	  if (rl_complete_with_tilde_expansion && *users_dirname == '~')
	    {
	      dirlen = strlen (dirname);
	      temp = (char *)xmalloc (2 + dirlen + D_NAMLEN (entry));
	      strcpy (temp, dirname);
",1,unused,2664,unused,"	  if (rl_complete_with_tilde_expansion && *users_dirname == '~')
	    {
	      dirlen = strlen (dirname);
	      temp = (char *)xmalloc (2 + dirlen + D_NAMLEN (entry));
	      strcpy (temp, dirname);
",unused,bashsources-lib2Freadline2Fcomplete.c
"	  else
	    {
	      dirlen = strlen (users_dirname);
	      temp = (char *)xmalloc (2 + dirlen + D_NAMLEN (entry));
	      strcpy (temp, users_dirname);
",1,unused,2677,unused,"	  else
	    {
	      dirlen = strlen (users_dirname);
	      temp = (char *)xmalloc (2 + dirlen + D_NAMLEN (entry));
	      strcpy (temp, users_dirname);
",unused,bashsources-lib2Freadline2Fcomplete.c
"	      if (users_dirname[dirlen - 1] != '/')
		temp[dirlen++] = '/';
	    }

	  strcpy (temp + dirlen, convfn);
",1,unused,2683,unused,"	      if (users_dirname[dirlen - 1] != '/')
		temp[dirlen++] = '/';
	    }

	  strcpy (temp + dirlen, convfn);
",unused,bashsources-lib2Freadline2Fcomplete.c
"    {
      l = strlen (pmt);
      nprompt = (char *)xmalloc (l + mlen + 1);
      memcpy (nprompt, ms, mlen);
      strcpy (nprompt + mlen, pmt);
",1,unused,325,unused,"    {
      l = strlen (pmt);
      nprompt = (char *)xmalloc (l + mlen + 1);
      memcpy (nprompt, ms, mlen);
      strcpy (nprompt + mlen, pmt);
",unused,bashsources-lib2Freadline2Fdisplay.c
"#endif
	{
	  if (_rl_output_meta_chars == 0)
	    {
	      sprintf (line + out, ""\\%o"", c);
",1,unused,903,unused,"#endif
	{
	  if (_rl_output_meta_chars == 0)
	    {
	      sprintf (line + out, ""\\%o"", c);
",unused,bashsources-lib2Freadline2Fdisplay.c
"
  /* Make sure the line structures hold the already-displayed prompt for
     redisplay. */
  lprompt = local_prompt ? local_prompt : rl_prompt;
  strcpy (visible_line, lprompt);
",1,unused,2079,unused,"
  /* Make sure the line structures hold the already-displayed prompt for
     redisplay. */
  lprompt = local_prompt ? local_prompt : rl_prompt;
  strcpy (visible_line, lprompt);
",unused,bashsources-lib2Freadline2Fdisplay.c
"  /* Make sure the line structures hold the already-displayed prompt for
     redisplay. */
  lprompt = local_prompt ? local_prompt : rl_prompt;
  strcpy (visible_line, lprompt);
  strcpy (invisible_line, lprompt);
",1,unused,2080,unused,"  /* Make sure the line structures hold the already-displayed prompt for
     redisplay. */
  lprompt = local_prompt ? local_prompt : rl_prompt;
  strcpy (visible_line, lprompt);
  strcpy (invisible_line, lprompt);
",unused,bashsources-lib2Freadline2Fdisplay.c
"    {
      len = (rl_prompt && *rl_prompt) ? strlen (rl_prompt) : 0;
      pmt = (char *)xmalloc (len + 2);
      if (len)
	strcpy (pmt, rl_prompt);
",1,unused,2602,unused,"    {
      len = (rl_prompt && *rl_prompt) ? strlen (rl_prompt) : 0;
      pmt = (char *)xmalloc (len + 2);
      if (len)
	strcpy (pmt, rl_prompt);
",unused,bashsources-lib2Freadline2Fdisplay.c
"      p++;
      len = strlen (p);
      pmt = (char *)xmalloc (len + 2);
      if (len)
	strcpy (pmt, p);
",1,unused,2612,unused,"      p++;
      len = strlen (p);
      pmt = (char *)xmalloc (len + 2);
      if (len)
	strcpy (pmt, p);
",unused,bashsources-lib2Freadline2Fdisplay.c
"  temp = (char *)xmalloc (ll + elen + 3);
  strncpy (temp, s + start, ll);
  temp[ll] = ':';
  temp[ll + 1] = ' ';
  strcpy (temp + ll + 2, emsg);
",1,unused,419,unused,"  temp = (char *)xmalloc (ll + elen + 3);
  strncpy (temp, s + start, ll);
  temp[ll] = ':';
  temp[ll + 1] = ' ';
  strcpy (temp + ll + 2, emsg);
",unused,bashsources-lib2Freadline2Fhistexpand.c
"      if (subst_rhs[i] == '&')
	{
	  if (j + subst_lhs_len >= new_size)
	    new = (char *)xrealloc (new, (new_size = new_size * 2 + subst_lhs_len));
	  strcpy (new + j, subst_lhs);
",1,unused,505,unused,"      if (subst_rhs[i] == '&')
	{
	  if (j + subst_lhs_len >= new_size)
	    new = (char *)xrealloc (new, (new_size = new_size * 2 + subst_lhs_len));
	  strcpy (new + j, subst_lhs);
",unused,bashsources-lib2Freadline2Fhistexpand.c
"
  n = strlen (temp);
  if (n >= result_len)
    result = (char *)xrealloc (result, n + 2);
  strcpy (result, temp);
",1,unused,864,unused,"
  n = strlen (temp);
  if (n >= result_len)
    result = (char *)xrealloc (result, n + 2);
  strcpy (result, temp);
",unused,bashsources-lib2Freadline2Fhistexpand.c
"
      string[0] = string[1] = history_expansion_char;
      string[2] = ':';
      string[3] = 's';
      strcpy (string + 4, hstring);
",1,unused,965,unused,"
      string[0] = string[1] = history_expansion_char;
      string[2] = ':';
      string[3] = 's';
      strcpy (string + 4, hstring);
",unused,bashsources-lib2Freadline2Fhistexpand.c
"	  if ((dquote == 0 || history_quotes_inhibit_expansion == 0) &&
	      (i == 0 || member (string[i - 1], history_word_delimiters)))
	    {
	      temp = (char *)xmalloc (l - i + 1);
	      strcpy (temp, string + i);
",1,unused,1163,unused,"	  if ((dquote == 0 || history_quotes_inhibit_expansion == 0) &&
	      (i == 0 || member (string[i - 1], history_word_delimiters)))
	    {
	      temp = (char *)xmalloc (l - i + 1);
	      strcpy (temp, string + i);
",unused,bashsources-lib2Freadline2Fhistexpand.c
"      result[0] = '\0';

      for (i = first, offset = 0; i < last; i++)
	{
	  strcpy (result + offset, list[i]);
",1,unused,1403,unused,"      result[0] = '\0';

      for (i = first, offset = 0; i < last; i++)
	{
	  strcpy (result + offset, list[i]);
",unused,bashsources-lib2Freadline2Fhistexpand.c
"  else
    home_len = strlen (home);

  return_val = (char *)xmalloc (2 + home_len + 8); /* strlen("".history"") == 8 */
  strcpy (return_val, home);
",1,unused,170,unused,"  else
    home_len = strlen (home);

  return_val = (char *)xmalloc (2 + home_len + 8); /* strlen("".history"") == 8 */
  strcpy (return_val, home);
",unused,bashsources-lib2Freadline2Fhistfile.c
"  return_val[home_len] = '/';
#if defined (__MSDOS__)
  strcpy (return_val + home_len + 1, ""_history"");
#else
  strcpy (return_val + home_len + 1, "".history"");
",1,unused,175,unused,"  return_val[home_len] = '/';
#if defined (__MSDOS__)
  strcpy (return_val + home_len + 1, ""_history"");
#else
  strcpy (return_val + home_len + 1, "".history"");
",unused,bashsources-lib2Freadline2Fhistfile.c
"#endif
      
  len = strlen (fn);
  ret = xmalloc (len + 2);
  strcpy (ret, fn);
",1,unused,204,unused,"#endif
      
  len = strlen (fn);
  ret = xmalloc (len + 2);
  strcpy (ret, fn);
",unused,bashsources-lib2Freadline2Fhistfile.c
"#endif
      
  len = strlen (fn);
  ret = xmalloc (len + 11);
  strcpy (ret, fn);
",1,unused,234,unused,"#endif
      
  len = strlen (fn);
  ret = xmalloc (len + 11);
  strcpy (ret, fn);
",unused,bashsources-lib2Freadline2Fhistfile.c
"  ret[len+2] = (pid / 1000 % 10) + '0';
  ret[len+3] = (pid / 100 % 10) + '0';
  ret[len+4] = (pid / 10 % 10) + '0';
  ret[len+5] = (pid % 10) + '0';
  strcpy (ret + len + 6, "".tmp"");
",1,unused,245,unused,"  ret[len+2] = (pid / 1000 % 10) + '0';
  ret[len+3] = (pid / 100 % 10) + '0';
  ret[len+4] = (pid / 10 % 10) + '0';
  ret[len+5] = (pid % 10) + '0';
  strcpy (ret + len + 6, "".tmp"");
",unused,bashsources-lib2Freadline2Fhistfile.c
"    for (j = 0, i = history_length - nelements; i < history_length; i++)
      {
	if (history_write_timestamps && the_history[i]->timestamp && the_history[i]->timestamp[0])
	  {
	    strcpy (buffer + j, the_history[i]->timestamp);
",1,unused,722,unused,"    for (j = 0, i = history_length - nelements; i < history_length; i++)
      {
	if (history_write_timestamps && the_history[i]->timestamp && the_history[i]->timestamp[0])
	  {
	    strcpy (buffer + j, the_history[i]->timestamp);
",unused,bashsources-lib2Freadline2Fhistfile.c
"	    strcpy (buffer + j, the_history[i]->timestamp);
	    j += strlen (the_history[i]->timestamp);
	    buffer[j++] = '\n';
	  }
	strcpy (buffer + j, the_history[i]->line);
",1,unused,726,unused,"	    strcpy (buffer + j, the_history[i]->timestamp);
	    j += strlen (the_history[i]->timestamp);
	    buffer[j++] = '\n';
	  }
	strcpy (buffer + j, the_history[i]->line);
",unused,bashsources-lib2Freadline2Fhistfile.c
"  if (newline)
    {
      hent->line = newline;
      hent->line[curlen++] = '\n';
      strcpy (hent->line + curlen, line);
",1,unused,430,unused,"  if (newline)
    {
      hent->line = newline;
      hent->line[curlen++] = '\n';
      strcpy (hent->line + curlen, line);
",unused,bashsources-lib2Freadline2Fhistory.c
"  message[msglen++] = '(';

  if (flags & SF_FAILED)
    {
      strcpy (message + msglen, ""failed "");
",1,unused,182,unused,"  message[msglen++] = '(';

  if (flags & SF_FAILED)
    {
      strcpy (message + msglen, ""failed "");
",unused,bashsources-lib2Freadline2Fisearch.c
"    }

  if (flags & SF_REVERSE)
    {
      strcpy (message + msglen, ""reverse-"");
",1,unused,188,unused,"    }

  if (flags & SF_REVERSE)
    {
      strcpy (message + msglen, ""reverse-"");
",unused,bashsources-lib2Freadline2Fisearch.c
"      strcpy (message + msglen, ""reverse-"");
      msglen += 8;
    }

  strcpy (message + msglen, ""i-search)`"");
",1,unused,192,unused,"      strcpy (message + msglen, ""reverse-"");
      msglen += 8;
    }

  strcpy (message + msglen, ""i-search)`"");
",unused,bashsources-lib2Freadline2Fisearch.c
"  msglen += 10;

  if (search_string)
    {
      strcpy (message + msglen, search_string);
",1,unused,197,unused,"  msglen += 10;

  if (search_string)
    {
      strcpy (message + msglen, search_string);
",unused,bashsources-lib2Freadline2Fisearch.c
"      strcpy (message + msglen, search_string);
      msglen += searchlen;
    }

  strcpy (message + msglen, ""': "");
",1,unused,201,unused,"      strcpy (message + msglen, search_string);
      msglen += searchlen;
    }

  strcpy (message + msglen, ""': "");
",unused,bashsources-lib2Freadline2Fisearch.c
"  else
    {
      /* Keep track of this so we can free it. */
      cxt->allocated_line = (char *)xmalloc (1 + strlen (rl_line_buffer));
      strcpy (cxt->allocated_line, &rl_line_buffer[0]);
",1,unused,242,unused,"  else
    {
      /* Keep track of this so we can free it. */
      cxt->allocated_line = (char *)xmalloc (1 + strlen (rl_line_buffer));
      strcpy (cxt->allocated_line, &rl_line_buffer[0]);
",unused,bashsources-lib2Freadline2Fisearch.c
"_rl_isearch_fini (cxt)
     _rl_search_cxt *cxt;
{
  /* First put back the original state. */
  strcpy (rl_line_buffer, cxt->lines[cxt->save_line]);
",1,unused,274,unused,"_rl_isearch_fini (cxt)
     _rl_search_cxt *cxt;
{
  /* First put back the original state. */
  strcpy (rl_line_buffer, cxt->lines[cxt->save_line]);
",unused,bashsources-lib2Freadline2Fisearch.c
"	  if (last_isearch_string)
	    {
	      cxt->search_string_size = 64 + last_isearch_string_len;
	      cxt->search_string = (char *)xrealloc (cxt->search_string, cxt->search_string_size);
	      strcpy (cxt->search_string, last_isearch_string);
",1,unused,523,unused,"	  if (last_isearch_string)
	    {
	      cxt->search_string_size = 64 + last_isearch_string_len;
	      cxt->search_string = (char *)xrealloc (cxt->search_string, cxt->search_string_size);
	      strcpy (cxt->search_string, last_isearch_string);
",unused,bashsources-lib2Freadline2Fisearch.c
"      new = (char *)xmalloc (1 + strlen (old) + strlen (text));

      if (append)
	{
	  strcpy (new, old);
",1,unused,141,unused,"      new = (char *)xmalloc (1 + strlen (old) + strlen (text));

      if (append)
	{
	  strcpy (new, old);
",unused,bashsources-lib2Freadline2Fkill.c
"
      if (append)
	{
	  strcpy (new, old);
	  strcat (new, text);
",1,unused,142,unused,"
      if (append)
	{
	  strcpy (new, old);
	  strcat (new, text);
",unused,bashsources-lib2Freadline2Fkill.c
"	  strcat (new, text);
	}
      else
	{
	  strcpy (new, text);
",1,unused,146,unused,"	  strcat (new, text);
	}
      else
	{
	  strcpy (new, text);
",unused,bashsources-lib2Freadline2Fkill.c
"	}
      else
	{
	  strcpy (new, text);
	  strcat (new, old);
",1,unused,147,unused,"	}
      else
	{
	  strcpy (new, text);
	  strcat (new, old);
",unused,bashsources-lib2Freadline2Fkill.c
"      return;
    }

  ext = NULL;
  strcpy (label, ""??"");
",1,unused,318,unused,"      return;
    }

  ext = NULL;
  strcpy (label, ""??"");
",unused,bashsources-lib2Freadline2Fparse-colors.c
"      rl_revert_line (1, 0);
      entry = replace_history_entry (where_history (), the_line, (histdata_t)NULL);
      _rl_free_history_entry (entry);

      strcpy (the_line, temp);
",1,unused,472,unused,"      rl_revert_line (1, 0);
      entry = replace_history_entry (where_history (), the_line, (histdata_t)NULL);
      _rl_free_history_entry (entry);

      strcpy (the_line, temp);
",unused,bashsources-lib2Freadline2Freadline.c
"sh_set_lines_and_columns (lines, cols)
     int lines, cols;
{
#if defined (HAVE_SETENV)
  sprintf (setenv_buf, ""%d"", lines);
",1,unused,134,unused,"sh_set_lines_and_columns (lines, cols)
     int lines, cols;
{
#if defined (HAVE_SETENV)
  sprintf (setenv_buf, ""%d"", lines);
",unused,bashsources-lib2Freadline2Fshell.c
"#if defined (HAVE_SETENV)
  sprintf (setenv_buf, ""%d"", lines);
  setenv (""LINES"", setenv_buf, 1);

  sprintf (setenv_buf, ""%d"", cols);
",1,unused,137,unused,"#if defined (HAVE_SETENV)
  sprintf (setenv_buf, ""%d"", lines);
  setenv (""LINES"", setenv_buf, 1);

  sprintf (setenv_buf, ""%d"", cols);
",unused,bashsources-lib2Freadline2Fshell.c
"
  len = strlen (text);
  if (len >= rl_line_buffer_len)
    rl_extend_line_buffer (len);
  strcpy (rl_line_buffer, text);
",1,unused,218,unused,"
  len = strlen (text);
  if (len >= rl_line_buffer_len)
    rl_extend_line_buffer (len);
  strcpy (rl_line_buffer, text);
",unused,bashsources-lib2Freadline2Ftext.c
"	{
	  if ((result_index + len + 1) > result_size)
	    result = (char *)xrealloc (result, 1 + (result_size += (len + 20)));

	  strcpy (result + result_index, expansion);
",1,unused,255,unused,"	{
	  if ((result_index + len + 1) > result_size)
	    result = (char *)xrealloc (result, 1 + (result_size += (len + 20)));

	  strcpy (result + result_index, expansion);
",unused,bashsources-lib2Freadline2Ftilde.c
"  plen = (prefix && *prefix) ? strlen (prefix) : 0;
  slen = strlen (suffix + suffind);
  ret = (char *)xmalloc (plen + slen + 1);
  if (plen)
    strcpy (ret, prefix);
",1,unused,338,unused,"  plen = (prefix && *prefix) ? strlen (prefix) : 0;
  slen = strlen (suffix + suffind);
  ret = (char *)xmalloc (plen + slen + 1);
  if (plen)
    strcpy (ret, prefix);
",unused,bashsources-lib2Freadline2Ftilde.c
"  slen = strlen (suffix + suffind);
  ret = (char *)xmalloc (plen + slen + 1);
  if (plen)
    strcpy (ret, prefix);
  strcpy (ret + plen, suffix + suffind);
",1,unused,339,unused,"  slen = strlen (suffix + suffind);
  ret = (char *)xmalloc (plen + slen + 1);
  if (plen)
    strcpy (ret, prefix);
  strcpy (ret + plen, suffix + suffind);
",unused,bashsources-lib2Freadline2Ftilde.c
"char *
_rl_savestring (s)
     const char *s;
{
  return (strcpy ((char *)xmalloc (1 + (int)strlen (s)), (s)));
",1,unused,478,unused,"char *
_rl_savestring (s)
     const char *s;
{
  return (strcpy ((char *)xmalloc (1 + (int)strlen (s)), (s)));
",unused,bashsources-lib2Freadline2Futil.c
"     trailing slash.  Make sure /dev/fd/xx really uses DEV_FD_PREFIX/xx.
     On most systems, with the notable exception of linux, this is
     effectively a no-op. */
      pbuf = xrealloc (pbuf, sizeof (DEV_FD_PREFIX) + strlen (path + 8));
      strcpy (pbuf, DEV_FD_PREFIX);
",1,unused,112,unused,"     trailing slash.  Make sure /dev/fd/xx really uses DEV_FD_PREFIX/xx.
     On most systems, with the notable exception of linux, this is
     effectively a no-op. */
      pbuf = xrealloc (pbuf, sizeof (DEV_FD_PREFIX) + strlen (path + 8));
      strcpy (pbuf, DEV_FD_PREFIX);
",unused,bashsources-lib2Fsh2Feaccess.c
"     On most systems, with the notable exception of linux, this is
     effectively a no-op. */
      pbuf = xrealloc (pbuf, sizeof (DEV_FD_PREFIX) + strlen (path + 8));
      strcpy (pbuf, DEV_FD_PREFIX);
      strcat (pbuf, path + 8);
",1,unused,113,unused,"     On most systems, with the notable exception of linux, this is
     effectively a no-op. */
      pbuf = xrealloc (pbuf, sizeof (DEV_FD_PREFIX) + strlen (path + 8));
      strcpy (pbuf, DEV_FD_PREFIX);
      strcat (pbuf, path + 8);
",unused,bashsources-lib2Fsh2Feaccess.c
"  st_ret.st_mode  &= ~S_IFDIR;
  st_ret.st_mode  |= S_IFREG;

  /* See if cur/ is present */
  sprintf(dir, ""%s/cur"", path);
",1,unused,95,unused,"  st_ret.st_mode  &= ~S_IFDIR;
  st_ret.st_mode  |= S_IFREG;

  /* See if cur/ is present */
  sprintf(dir, ""%s/cur"", path);
",unused,bashsources-lib2Fsh2Fmailstat.c
"    return 0;
  st_ret.st_atime = st_tmp.st_atime;

  /* See if tmp/ is present */
  sprintf(dir, ""%s/tmp"", path);
",1,unused,101,unused,"    return 0;
  st_ret.st_atime = st_tmp.st_atime;

  /* See if tmp/ is present */
  sprintf(dir, ""%s/tmp"", path);
",unused,bashsources-lib2Fsh2Fmailstat.c
"    return 0;
  st_ret.st_mtime = st_tmp.st_mtime;

  /* And new/ */
  sprintf(dir, ""%s/new"", path);
",1,unused,107,unused,"    return 0;
  st_ret.st_mtime = st_tmp.st_mtime;

  /* And new/ */
  sprintf(dir, ""%s/new"", path);
",unused,bashsources-lib2Fsh2Fmailstat.c
"
  /* Loop over new/ and cur/ */
  for (i = 0; i < 2; i++)
    {
      sprintf(dir, ""%s/%s"", path, i ? ""cur"" : ""new"");
",1,unused,126,unused,"
  /* Loop over new/ and cur/ */
  for (i = 0; i < 2; i++)
    {
      sprintf(dir, ""%s/%s"", path, i ? ""cur"" : ""new"");
",unused,bashsources-lib2Fsh2Fmailstat.c
"  /* Loop over new/ and cur/ */
  for (i = 0; i < 2; i++)
    {
      sprintf(dir, ""%s/%s"", path, i ? ""cur"" : ""new"");
      sprintf(file, ""%s/"", dir);
",1,unused,127,unused,"  /* Loop over new/ and cur/ */
  for (i = 0; i < 2; i++)
    {
      sprintf(dir, ""%s/%s"", path, i ? ""cur"" : ""new"");
      sprintf(file, ""%s/"", dir);
",unused,bashsources-lib2Fsh2Fmailstat.c
"      while ((fn = readdir(dd)) != NULL)
	{
	  if (fn->d_name[0] == '.' || strlen(fn->d_name) + l >= sizeof(file))
	    continue;
	  strcpy(file + l, fn->d_name);
",1,unused,135,unused,"      while ((fn = readdir(dd)) != NULL)
	{
	  if (fn->d_name[0] == '.' || strlen(fn->d_name) + l >= sizeof(file))
	    continue;
	  strcpy(file + l, fn->d_name);
",unused,bashsources-lib2Fsh2Fmailstat.c
"  char *np, *s, *t;
  int fd;

  np = (char *)xmalloc (strlen (path) + 1);
  strcpy (np, path);
",1,unused,300,unused,"  char *np, *s, *t;
  int fd;

  np = (char *)xmalloc (strlen (path) + 1);
  strcpy (np, path);
",unused,bashsources-lib2Fsh2Fnetopen.c
"    {
      if (result[2] == '\0')	/* short-circuit for bare `//' */
	result[1] = '\0';
      else
	strcpy (result, result + 1);
",1,unused,230,unused,"    {
      if (result[2] == '\0')	/* short-circuit for bare `//' */
	result[1] = '\0';
      else
	strcpy (result, result + 1);
",unused,bashsources-lib2Fsh2Fpathcanon.c
"    workpath = savestring (path);
  else
    {
      workpath = (char *)xmalloc (PATH_MAX + 1);
      strcpy (workpath, path);
",1,unused,101,unused,"    workpath = savestring (path);
  else
    {
      workpath = (char *)xmalloc (PATH_MAX + 1);
      strcpy (workpath, path);
",unused,bashsources-lib2Fsh2Fpathphys.c
"	     buffer and appending the rest of `workpath'.  Reset p to point
	     to the start of the rest of the path.  If the link value is an
	     absolute pathname, reset p, q, and qbase.  If not, reset p
	     and q. */
	  strcpy (tbuf, linkbuf);
",1,unused,208,unused,"	     buffer and appending the rest of `workpath'.  Reset p to point
	     to the start of the rest of the path.  If the link value is an
	     absolute pathname, reset p, q, and qbase.  If not, reset p
	     and q. */
	  strcpy (tbuf, linkbuf);
",unused,bashsources-lib2Fsh2Fpathphys.c
"	     absolute pathname, reset p, q, and qbase.  If not, reset p
	     and q. */
	  strcpy (tbuf, linkbuf);
	  tbuf[linklen] = '/';
	  strcpy (tbuf + linklen, p);
",1,unused,210,unused,"	     absolute pathname, reset p, q, and qbase.  If not, reset p
	     and q. */
	  strcpy (tbuf, linkbuf);
	  tbuf[linklen] = '/';
	  strcpy (tbuf + linklen, p);
",unused,bashsources-lib2Fsh2Fpathphys.c
"	     and q. */
	  strcpy (tbuf, linkbuf);
	  tbuf[linklen] = '/';
	  strcpy (tbuf + linklen, p);
	  strcpy (workpath, tbuf);
",1,unused,211,unused,"	     and q. */
	  strcpy (tbuf, linkbuf);
	  tbuf[linklen] = '/';
	  strcpy (tbuf + linklen, p);
	  strcpy (workpath, tbuf);
",unused,bashsources-lib2Fsh2Fpathphys.c
"    {
      if (result[2] == '\0')	/* short-circuit for bare `//' */
	result[1] = '\0';
      else
	strcpy (result, result + 1);
",1,unused,248,unused,"    {
      if (result[2] == '\0')	/* short-circuit for bare `//' */
	result[1] = '\0';
      else
	strcpy (result, result + 1);
",unused,bashsources-lib2Fsh2Fpathphys.c
"       */
      x = spdist(dp->d_name, guess);
      if (x <= dist && x != 3)
	{
	  strcpy(best, dp->d_name);
",1,unused,134,unused,"       */
      x = spdist(dp->d_name, guess);
      if (x <= dist && x != 3)
	{
	  strcpy(best, dp->d_name);
",unused,bashsources-lib2Fsh2Fspell.c
"      llen = STRLEN (sl->list[i]);
      tlen = plen + llen + slen + 1;
      t = (char *)xmalloc (tlen + 1);
      if (plen)
	strcpy (t, prefix);
",1,unused,214,unused,"      llen = STRLEN (sl->list[i]);
      tlen = plen + llen + slen + 1;
      t = (char *)xmalloc (tlen + 1);
      if (plen)
	strcpy (t, prefix);
",unused,bashsources-lib2Fsh2Fstringlist.c
"      tlen = plen + llen + slen + 1;
      t = (char *)xmalloc (tlen + 1);
      if (plen)
	strcpy (t, prefix);
      strcpy (t + plen, sl->list[i]);
",1,unused,215,unused,"      tlen = plen + llen + slen + 1;
      t = (char *)xmalloc (tlen + 1);
      if (plen)
	strcpy (t, prefix);
      strcpy (t + plen, sl->list[i]);
",unused,bashsources-lib2Fsh2Fstringlist.c
"      if (plen)
	strcpy (t, prefix);
      strcpy (t + plen, sl->list[i]);
      if (slen)
	strcpy (t + plen + llen, suffix);
",1,unused,217,unused,"      if (plen)
	strcpy (t, prefix);
      strcpy (t + plen, sl->list[i]);
      if (slen)
	strcpy (t + plen + llen, suffix);
",unused,bashsources-lib2Fsh2Fstringlist.c
"
  lroot = nameroot ? nameroot : DEFAULT_NAMEROOT;

#ifdef USE_MKTEMP
  sprintf (filename, ""%s/%s.XXXXXX"", tdir, lroot);
",1,unused,151,unused,"
  lroot = nameroot ? nameroot : DEFAULT_NAMEROOT;

#ifdef USE_MKTEMP
  sprintf (filename, ""%s/%s.XXXXXX"", tdir, lroot);
",unused,bashsources-lib2Fsh2Ftmpfile.c
"
  lroot = nameroot ? nameroot : DEFAULT_NAMEROOT;

#ifdef USE_MKSTEMP
  sprintf (filename, ""%s/%s.XXXXXX"", tdir, lroot);
",1,unused,197,unused,"
  lroot = nameroot ? nameroot : DEFAULT_NAMEROOT;

#ifdef USE_MKSTEMP
  sprintf (filename, ""%s/%s.XXXXXX"", tdir, lroot);
",unused,bashsources-lib2Fsh2Ftmpfile.c
"
  locale = get_locale_var (""LC_CTYPE"");
  if (locale == 0 || *locale == 0)
    {
      strcpy (charsetbuf, ""ASCII"");
",1,unused,75,unused,"
  locale = get_locale_var (""LC_CTYPE"");
  if (locale == 0 || *locale == 0)
    {
      strcpy (charsetbuf, ""ASCII"");
",unused,bashsources-lib2Fsh2Funicode.c
"{
  int l;

  if (wc < 0x10000)
    l = sprintf (s, ""\\u%04X"", wc);
",1,unused,144,unused,"{
  int l;

  if (wc < 0x10000)
    l = sprintf (s, ""\\u%04X"", wc);
",unused,bashsources-lib2Fsh2Funicode.c
"
  if (wc < 0x10000)
    l = sprintf (s, ""\\u%04X"", wc);
  else
    l = sprintf (s, ""\\u%08X"", wc);
",1,unused,146,unused,"
  if (wc < 0x10000)
    l = sprintf (s, ""\\u%04X"", wc);
  else
    l = sprintf (s, ""\\u%08X"", wc);
",unused,bashsources-lib2Fsh2Funicode.c
"  *optr = '\0';

  /* number of chars to be copied is optr - obuf if we want to do bounds
     checking */
  strcpy (s, obuf);
",1,unused,331,unused,"  *optr = '\0';

  /* number of chars to be copied is optr - obuf if we want to do bounds
     checking */
  strcpy (s, obuf);
",unused,bashsources-lib2Fsh2Funicode.c
"	{
	  if ((result_index + len + 1) > result_size)
	    result = (char *)xrealloc (result, 1 + (result_size += (len + 20)));

	  strcpy (result + result_index, expansion);
",1,unused,255,unused,"	{
	  if ((result_index + len + 1) > result_size)
	    result = (char *)xrealloc (result, 1 + (result_size += (len + 20)));

	  strcpy (result + result_index, expansion);
",unused,bashsources-lib2Ftilde2Ftilde.c
"  plen = (prefix && *prefix) ? strlen (prefix) : 0;
  slen = strlen (suffix + suffind);
  ret = (char *)xmalloc (plen + slen + 1);
  if (plen)
    strcpy (ret, prefix);
",1,unused,338,unused,"  plen = (prefix && *prefix) ? strlen (prefix) : 0;
  slen = strlen (suffix + suffind);
  ret = (char *)xmalloc (plen + slen + 1);
  if (plen)
    strcpy (ret, prefix);
",unused,bashsources-lib2Ftilde2Ftilde.c
"  slen = strlen (suffix + suffind);
  ret = (char *)xmalloc (plen + slen + 1);
  if (plen)
    strcpy (ret, prefix);
  strcpy (ret + plen, suffix + suffind);
",1,unused,339,unused,"  slen = strlen (suffix + suffind);
  ret = (char *)xmalloc (plen + slen + 1);
  if (plen)
    strcpy (ret, prefix);
  strcpy (ret + plen, suffix + suffind);
",unused,bashsources-lib2Ftilde2Ftilde.c
"  if (locale == 0 || locale[0] == '\0' ||
      (locale[0] == 'C' && locale[1] == '\0') || STREQ (locale, ""POSIX""))
    {
      t = (char *)xmalloc (len + 1);
      strcpy (t, string);
",1,unused,391,unused,"  if (locale == 0 || locale[0] == '\0' ||
      (locale[0] == 'C' && locale[1] == '\0') || STREQ (locale, ""POSIX""))
    {
      t = (char *)xmalloc (len + 1);
      strcpy (t, string);
",unused,bashsources-locale.c
"
  if (translated == string)	/* gettext returns its argument if untranslatable */
    {
      t = (char *)xmalloc (len + 1);
      strcpy (t, string);
",1,unused,406,unused,"
  if (translated == string)	/* gettext returns its argument if untranslatable */
    {
      t = (char *)xmalloc (len + 1);
      strcpy (t, string);
",unused,bashsources-locale.c
"  else
    {
      tlen = strlen (translated);
      t = (char *)xmalloc (tlen + 1);
      strcpy (t, translated);
",1,unused,414,unused,"  else
    {
      tlen = strlen (translated);
      t = (char *)xmalloc (tlen + 1);
      strcpy (t, translated);
",unused,bashsources-locale.c
"  char *mp;

  get_current_user_info ();
  mp = (char *)xmalloc (2 + sizeof (DEFAULT_MAIL_DIRECTORY) + strlen (current_user.user_name));
  strcpy (mp, DEFAULT_MAIL_DIRECTORY);
",1,unused,354,unused,"  char *mp;

  get_current_user_info ();
  mp = (char *)xmalloc (2 + sizeof (DEFAULT_MAIL_DIRECTORY) + strlen (current_user.user_name));
  strcpy (mp, DEFAULT_MAIL_DIRECTORY);
",unused,bashsources-mailcheck.c
"  get_current_user_info ();
  mp = (char *)xmalloc (2 + sizeof (DEFAULT_MAIL_DIRECTORY) + strlen (current_user.user_name));
  strcpy (mp, DEFAULT_MAIL_DIRECTORY);
  mp[sizeof(DEFAULT_MAIL_DIRECTORY) - 1] = '/';
  strcpy (mp + sizeof (DEFAULT_MAIL_DIRECTORY), current_user.user_name);
",1,unused,356,unused,"  get_current_user_info ();
  mp = (char *)xmalloc (2 + sizeof (DEFAULT_MAIL_DIRECTORY) + strlen (current_user.user_name));
  strcpy (mp, DEFAULT_MAIL_DIRECTORY);
  mp[sizeof(DEFAULT_MAIL_DIRECTORY) - 1] = '/';
  strcpy (mp + sizeof (DEFAULT_MAIL_DIRECTORY), current_user.user_name);
",unused,bashsources-mailcheck.c
"    case '\f': xbuf[1] = 'f'; break;
    case '\n': xbuf[1] = 'n'; break;
    case '\r': xbuf[1] = 'r'; break;
    case '\t': xbuf[1] = 't'; break;
    default: sprintf (xbuf, ""%d"", i); break;
",1,unused,145,unused,"    case '\f': xbuf[1] = 'f'; break;
    case '\n': xbuf[1] = 'n'; break;
    case '\r': xbuf[1] = 'r'; break;
    case '\t': xbuf[1] = 't'; break;
    default: sprintf (xbuf, ""%d"", i); break;
",unused,bashsources-mksyntax.c
"
  /* allocate the string for the command and fill it in. */
  cscmd = (char *)xmalloc (cmdsize + 1);

  strcpy (cscmd, cs->command);			/* $0 */
",1,unused,1230,unused,"
  /* allocate the string for the command and fill it in. */
  cscmd = (char *)xmalloc (cmdsize + 1);

  strcpy (cscmd, cs->command);			/* $0 */
",unused,bashsources-pcomplete.c
"    {
      t = sh_single_quote (cl->word->word ? cl->word->word : """");
      n = strlen (t);
      RESIZE_MALLOCED_BUFFER (cscmd, cmdlen, n + 2, cmdsize, 64);
      strcpy (cscmd + cmdlen, t);
",1,unused,1238,unused,"    {
      t = sh_single_quote (cl->word->word ? cl->word->word : """");
      n = strlen (t);
      RESIZE_MALLOCED_BUFFER (cscmd, cmdlen, n + 2, cmdsize, 64);
      strcpy (cscmd + cmdlen, t);
",unused,bashsources-pcomplete.c
"		 a redirection. */
	      digit_arg = va_arg (args, int);
	      if (digit_arg < 0)
		{
		  sprintf (intbuf, ""%u"", (unsigned)-1);
",1,unused,1519,unused,"		 a redirection. */
	      digit_arg = va_arg (args, int);
	      if (digit_arg < 0)
		{
		  sprintf (intbuf, ""%u"", (unsigned)-1);
",unused,bashsources-print_cmd.c
"		  t = quote_globbing_chars (text);
		  tlen = strlen (t);
		  RESIZE_MALLOCED_BUFFER (ret, ind, tlen, rlen, rlen);
		  r = ret + ind;	/* in case reallocated */
		  strcpy (r, t);
",1,unused,210,unused,"		  t = quote_globbing_chars (text);
		  tlen = strlen (t);
		  RESIZE_MALLOCED_BUFFER (ret, ind, tlen, rlen, rlen);
		  r = ret + ind;	/* in case reallocated */
		  strcpy (r, t);
",unused,bashsources-stringlib.c
"	      else
		{
		  RESIZE_MALLOCED_BUFFER (ret, ind, len, rlen, rlen);
		  r = ret + ind;	/* in case reallocated */
		  strcpy (r, text);
",1,unused,218,unused,"	      else
		{
		  RESIZE_MALLOCED_BUFFER (ret, ind, len, rlen, rlen);
		  r = ret + ind;	/* in case reallocated */
		  strcpy (r, text);
",unused,bashsources-stringlib.c
"
  t = result = (char *)xmalloc (slen + 1);

  if (strchr (string, CTLESC) == 0)
    return (strcpy (result, string));
",1,unused,3920,unused,"
  t = result = (char *)xmalloc (slen + 1);

  if (strchr (string, CTLESC) == 0)
    return (strcpy (result, string));
",unused,bashsources-subst.c
"
  /* If no character in the string can be quoted, don't bother examining
     each character.  Just return a copy of the string passed to us. */
  if (strchr (string, CTLESC) == NULL)
    return (strcpy (result, string));
",1,unused,4052,unused,"
  /* If no character in the string can be quoted, don't bother examining
     each character.  Just return a copy of the string passed to us. */
  if (strchr (string, CTLESC) == NULL)
    return (strcpy (result, string));
",unused,bashsources-subst.c
"
  if (string)
    {
      t = dequote_escapes (string);
      strcpy (string, t);
",1,unused,4121,unused,"
  if (string)
    {
      t = dequote_escapes (string);
      strcpy (string, t);
",unused,bashsources-subst.c
"  val = sh_quote_reusable (s, 0);
  i = var_attribute_string (v, 0, flags);
  ret = (char *)xmalloc (i + strlen (val) + strlen (v->name) + 16 + MAX_ATTRIBUTES);
  if (i > 0)
    sprintf (ret, ""declare -%s %s=%s"", flags, v->name, val);
",1,unused,5042,unused,"  val = sh_quote_reusable (s, 0);
  i = var_attribute_string (v, 0, flags);
  ret = (char *)xmalloc (i + strlen (val) + strlen (v->name) + 16 + MAX_ATTRIBUTES);
  if (i > 0)
    sprintf (ret, ""declare -%s %s=%s"", flags, v->name, val);
",unused,bashsources-subst.c
"  ret = (char *)xmalloc (i + strlen (val) + strlen (v->name) + 16 + MAX_ATTRIBUTES);
  if (i > 0)
    sprintf (ret, ""declare -%s %s=%s"", flags, v->name, val);
  else
    sprintf (ret, ""%s=%s"", v->name, val);
",1,unused,5044,unused,"  ret = (char *)xmalloc (i + strlen (val) + strlen (v->name) + 16 + MAX_ATTRIBUTES);
  if (i > 0)
    sprintf (ret, ""declare -%s %s=%s"", flags, v->name, val);
  else
    sprintf (ret, ""%s=%s"", v->name, val);
",unused,bashsources-subst.c
"      val = ret;
    }
  i = var_attribute_string (v, 0, flags);
  ret = (char *)xmalloc (i + strlen (val) + strlen (v->name) + 16);
  sprintf (ret, ""declare -%s %s=%s"", flags, v->name, val);
",1,unused,5077,unused,"      val = ret;
    }
  i = var_attribute_string (v, 0, flags);
  ret = (char *)xmalloc (i + strlen (val) + strlen (v->name) + 16);
  sprintf (ret, ""declare -%s %s=%s"", flags, v->name, val);
",unused,bashsources-subst.c
"
  /* first, we transform the list to quote each word. */
  temp = list_transform ('Q', (SHELL_VAR *)0, list, itype, quoted);
  ret = (char *)xmalloc (strlen (temp) + 8);
  strcpy (ret, ""set -- "");
",1,unused,5094,unused,"
  /* first, we transform the list to quote each word. */
  temp = list_transform ('Q', (SHELL_VAR *)0, list, itype, quoted);
  ret = (char *)xmalloc (strlen (temp) + 8);
  strcpy (ret, ""set -- "");
",unused,bashsources-subst.c
"  /* first, we transform the list to quote each word. */
  temp = list_transform ('Q', (SHELL_VAR *)0, list, itype, quoted);
  ret = (char *)xmalloc (strlen (temp) + 8);
  strcpy (ret, ""set -- "");
  strcpy (ret + 7, temp);
",1,unused,5095,unused,"  /* first, we transform the list to quote each word. */
  temp = list_transform ('Q', (SHELL_VAR *)0, list, itype, quoted);
  ret = (char *)xmalloc (strlen (temp) + 8);
  strcpy (ret, ""set -- "");
  strcpy (ret + 7, temp);
",unused,bashsources-subst.c
"  char *ret, intbuf[INT_STRLEN_BOUND (int) + 1], *p;

  ret = (char *)xmalloc (sizeof (DEV_FD_PREFIX) + 8);

  strcpy (ret, DEV_FD_PREFIX);
",1,unused,5694,unused,"  char *ret, intbuf[INT_STRLEN_BOUND (int) + 1], *p;

  ret = (char *)xmalloc (sizeof (DEV_FD_PREFIX) + 8);

  strcpy (ret, DEV_FD_PREFIX);
",unused,bashsources-subst.c
"  ret = (char *)xmalloc (sizeof (DEV_FD_PREFIX) + 8);

  strcpy (ret, DEV_FD_PREFIX);
  p = inttostr (fd, intbuf, sizeof (intbuf));
  strcpy (ret + sizeof (DEV_FD_PREFIX) - 1, p);
",1,unused,5696,unused,"  ret = (char *)xmalloc (sizeof (DEV_FD_PREFIX) + 8);

  strcpy (ret, DEV_FD_PREFIX);
  p = inttostr (fd, intbuf, sizeof (intbuf));
  strcpy (ret + sizeof (DEV_FD_PREFIX) - 1, p);
",unused,bashsources-subst.c
"    {
      int sindex;
      tt = (char *)xmalloc (2 + strlen (name));
      tt[sindex = 0] = '$';
      strcpy (tt + 1, name);
",1,unused,6501,unused,"    {
      int sindex;
      tt = (char *)xmalloc (2 + strlen (name));
      tt[sindex = 0] = '$';
      strcpy (tt + 1, name);
",unused,bashsources-subst.c
"      replen = STRLEN (rep);
      l = STRLEN (string);
      ret = (char *)xmalloc (replen + l + 2);
      if (replen == 0)
	strcpy (ret, string);
",1,unused,7428,unused,"      replen = STRLEN (rep);
      l = STRLEN (string);
      ret = (char *)xmalloc (replen + l + 2);
      if (replen == 0)
	strcpy (ret, string);
",unused,bashsources-subst.c
"      if (replen == 0)
	strcpy (ret, string);
      else if (mtype == MATCH_BEG)
	{
	  strcpy (ret, rep);
",1,unused,7431,unused,"      if (replen == 0)
	strcpy (ret, string);
      else if (mtype == MATCH_BEG)
	{
	  strcpy (ret, rep);
",unused,bashsources-subst.c
"	strcpy (ret, string);
      else if (mtype == MATCH_BEG)
	{
	  strcpy (ret, rep);
	  strcpy (ret + replen, string);
",1,unused,7432,unused,"	strcpy (ret, string);
      else if (mtype == MATCH_BEG)
	{
	  strcpy (ret, rep);
	  strcpy (ret + replen, string);
",unused,bashsources-subst.c
"	  strcpy (ret + replen, string);
	}
      else
	{
	  strcpy (ret, string);
",1,unused,7436,unused,"	  strcpy (ret + replen, string);
	}
      else
	{
	  strcpy (ret, string);
",unused,bashsources-subst.c
"	}
      else
	{
	  strcpy (ret, string);
	  strcpy (ret + l, rep);
",1,unused,7437,unused,"	}
      else
	{
	  strcpy (ret, string);
	  strcpy (ret + l, rep);
",unused,bashsources-subst.c
"      ret = (char *)xmalloc (replen + 1);
      if (replen == 0)
	ret[0] = '\0';
      else
	strcpy (ret, rep);
",1,unused,7448,unused,"      ret = (char *)xmalloc (replen + 1);
      if (replen == 0)
	ret[0] = '\0';
      else
	strcpy (ret, rep);
",unused,bashsources-subst.c
"  /* Now copy the unmatched portion of the input string */
  if (str && *str)
    {
      RESIZE_MALLOCED_BUFFER (ret, rptr, STRLEN(str) + 1, rsize, 64);
      strcpy (ret + rptr, str);
",1,unused,7517,unused,"  /* Now copy the unmatched portion of the input string */
  if (str && *str)
    {
      RESIZE_MALLOCED_BUFFER (ret, rptr, STRLEN(str) + 1, rsize, 64);
      strcpy (ret + rptr, str);
",unused,bashsources-subst.c
"      if (string[sindex] == '!')
	{
	  /* indirect reference of $#, $?, $@, or $* */
	  name[1] = string[sindex + 1];
	  strcpy (name + 2, temp1);
",1,unused,7989,unused,"      if (string[sindex] == '!')
	{
	  /* indirect reference of $#, $?, $@, or $* */
	  name[1] = string[sindex + 1];
	  strcpy (name + 2, temp1);
",unused,bashsources-subst.c
"	  name[1] = string[sindex + 1];
	  strcpy (name + 2, temp1);
	}
      else	
	strcpy (name + 1, temp1);
",1,unused,7992,unused,"	  name[1] = string[sindex + 1];
	  strcpy (name + 2, temp1);
	}
      else	
	strcpy (name + 1, temp1);
",unused,bashsources-subst.c
"	  tindex = sindex + 1;
	  temp = string_extract_single_quoted (string, &tindex);
	  if (temp)
	    {
	      strcpy (r, temp);
",1,unused,9891,unused,"	  tindex = sindex + 1;
	  temp = string_extract_single_quoted (string, &tindex);
	  if (temp)
	    {
	      strcpy (r, temp);
",unused,bashsources-subst.c
"strduplicate(char *from)
{
	char   *new = stralloc(strlen(from));

	strcpy(new, from);
",1,unused,194,unused,"strduplicate(char *from)
{
	char   *new = stralloc(strlen(from));

	strcpy(new, from);
",unused,bashsources-support2Fman2html.c
"	if (nr == current_size)
		return """";
	i = current_font;
	sizebuf[0] = '\0';
	strcat(sizebuf, change_to_font(0));
",1,unused,915,unused,"	if (nr == current_size)
		return """";
	i = current_font;
	sizebuf[0] = '\0';
	strcat(sizebuf, change_to_font(0));
",unused,bashsources-support2Fman2html.c
"	i = current_font;
	sizebuf[0] = '\0';
	strcat(sizebuf, change_to_font(0));
	if (current_size)
		strcat(sizebuf, ""</FONT>"");
",1,unused,917,unused,"	i = current_font;
	sizebuf[0] = '\0';
	strcat(sizebuf, change_to_font(0));
	if (current_size)
		strcat(sizebuf, ""</FONT>"");
",unused,bashsources-support2Fman2html.c
"	current_size = nr;
	if (nr) {
		int     l;

		strcat(sizebuf, ""<FONT SIZE="");
",1,unused,922,unused,"	current_size = nr;
	if (nr) {
		int     l;

		strcat(sizebuf, ""<FONT SIZE="");
",unused,bashsources-support2Fman2html.c
"		sizebuf[l++] = nr + '0';
		sizebuf[l++] = '>';
		sizebuf[l] = '\0';
	}
	strcat(sizebuf, change_to_font(i));
",1,unused,932,unused,"		sizebuf[l++] = nr + '0';
		sizebuf[l++] = '>';
		sizebuf[l] = '\0';
	}
	strcat(sizebuf, change_to_font(i));
",unused,bashsources-support2Fman2html.c
"				if (curfield->colspan > 1) {
					char    buf[5];

					out_html("" COLSPAN="");
					sprintf(buf, ""%i"", curfield->colspan);
",1,unused,1709,unused,"				if (curfield->colspan > 1) {
					char    buf[5];

					out_html("" COLSPAN="");
					sprintf(buf, ""%i"", curfield->colspan);
",unused,bashsources-support2Fman2html.c
"				if (curfield->rowspan > 1) {
					char    buf[5];

					out_html("" ROWSPAN="");
					sprintf(buf, ""%i"", curfield->rowspan);
",1,unused,1716,unused,"				if (curfield->rowspan > 1) {
					char    buf[5];

					out_html("" ROWSPAN="");
					sprintf(buf, ""%i"", curfield->rowspan);
",unused,bashsources-support2Fman2html.c
"	i = 0;
	while (i < l && c[i]) {
		if (c[i] == '\a') {
			if (c[i+1])
				strcpy(c + i, c + i + 1);	/* should be memmove */
",1,unused,1995,unused,"	i = 0;
	while (i < l && c[i]) {
		if (c[i] == '\a') {
			if (c[i+1])
				strcpy(c + i, c + i + 1);	/* should be memmove */
",unused,bashsources-support2Fman2html.c
"		}
	}
	subs = level;
	scan_troff(item, 1, &c);
	sprintf(manidx + mip, ""<DT><A HREF=\""#%s\"">%s</A><DD>\n"", label, c);
",1,unused,2138,unused,"		}
	}
	subs = level;
	scan_troff(item, 1, &c);
	sprintf(manidx + mip, ""<DT><A HREF=\""#%s\"">%s</A><DD>\n"", label, c);
",unused,bashsources-support2Fman2html.c
"					for (i = 1; i < words; i++)
						wordlist[i][-1] = '\0';
					*sl = '\0';
					output_possible = 1;
					sprintf(th_page_and_sec, ""%s(%s)"", wordlist[0], wordlist[1]);
",1,unused,2902,unused,"					for (i = 1; i < words; i++)
						wordlist[i][-1] = '\0';
					*sl = '\0';
					output_possible = 1;
					sprintf(th_page_and_sec, ""%s(%s)"", wordlist[0], wordlist[1]);
",unused,bashsources-support2Fman2html.c
"      for (i = 1; i <= rtcnt; i++)
	{
	  signal_names[rtmin+i] = (char *)malloc(RTLEN);
	  if (signal_names[rtmin+i])
	    sprintf (signal_names[rtmin+i], ""SIGRTMIN+%d"", i);
",1,unused,125,unused,"      for (i = 1; i <= rtcnt; i++)
	{
	  signal_names[rtmin+i] = (char *)malloc(RTLEN);
	  if (signal_names[rtmin+i])
	    sprintf (signal_names[rtmin+i], ""SIGRTMIN+%d"", i);
",unused,bashsources-support2Fsignames.c
"	  if (signal_names[rtmin+i])
	    sprintf (signal_names[rtmin+i], ""SIGRTMIN+%d"", i);
	  signal_names[rtmax-i] = (char *)malloc(RTLEN);
	  if (signal_names[rtmax-i])
	    sprintf (signal_names[rtmax-i], ""SIGRTMAX-%d"", i);
",1,unused,128,unused,"	  if (signal_names[rtmin+i])
	    sprintf (signal_names[rtmin+i], ""SIGRTMIN+%d"", i);
	  signal_names[rtmax-i] = (char *)malloc(RTLEN);
	  if (signal_names[rtmax-i])
	    sprintf (signal_names[rtmax-i], ""SIGRTMAX-%d"", i);
",unused,bashsources-support2Fsignames.c
"	{
	  /* Need an extra RTMIN signal */
	  signal_names[rtmin+rtcnt+1] = (char *)malloc(RTLEN);
	  if (signal_names[rtmin+rtcnt+1])
	    sprintf (signal_names[rtmin+rtcnt+1], ""SIGRTMIN+%d"", rtcnt+1);
",1,unused,136,unused,"	{
	  /* Need an extra RTMIN signal */
	  signal_names[rtmin+rtcnt+1] = (char *)malloc(RTLEN);
	  if (signal_names[rtmin+rtcnt+1])
	    sprintf (signal_names[rtmin+rtcnt+1], ""SIGRTMIN+%d"", rtcnt+1);
",unused,bashsources-support2Fsignames.c
"    if (signal_names[i] == (char *)NULL)
      {
	signal_names[i] = (char *)malloc (18);
	if (signal_names[i])
	  sprintf (signal_names[i], ""SIGJUNK(%d)"", i);
",1,unused,395,unused,"    if (signal_names[i] == (char *)NULL)
      {
	signal_names[i] = (char *)malloc (18);
	if (signal_names[i])
	  sprintf (signal_names[i], ""SIGJUNK(%d)"", i);
",unused,bashsources-support2Fsignames.c
"      if (cdir)
	{
	  len = strlen (cdir);
	  name = (char *)xmalloc (len + strlen (shell_name) + 1);
	  strcpy (name, cdir);
",1,unused,748,unused,"      if (cdir)
	{
	  len = strlen (cdir);
	  name = (char *)xmalloc (len + strlen (shell_name) + 1);
	  strcpy (name, cdir);
",unused,bashsources-variables.c
"	{
	  len = strlen (cdir);
	  name = (char *)xmalloc (len + strlen (shell_name) + 1);
	  strcpy (name, cdir);
	  strcpy (name + len, shell_name + 1);
",1,unused,749,unused,"	{
	  len = strlen (cdir);
	  name = (char *)xmalloc (len + strlen (shell_name) + 1);
	  strcpy (name, cdir);
	  strcpy (name + len, shell_name + 1);
",unused,bashsources-variables.c
"  unbind_variable_noref (""BASH_VERSINFO"");

  vv = make_new_array_variable (""BASH_VERSINFO"");
  av = array_cell (vv);
  strcpy (d, dist_version);
",1,unused,961,unused,"  unbind_variable_noref (""BASH_VERSINFO"");

  vv = make_new_array_variable (""BASH_VERSINFO"");
  av = array_cell (vv);
  strcpy (d, dist_version);
",unused,bashsources-variables.c
"	  if (oval == 0)	/* paranoia */
	    oval = """";
	  olen = STRLEN (oval);
	  retval = (char *)xmalloc (olen + (value ? STRLEN (value) : 0) + 1);
	  strcpy (retval, oval);
",1,unused,2638,unused,"	  if (oval == 0)	/* paranoia */
	    oval = """";
	  olen = STRLEN (oval);
	  retval = (char *)xmalloc (olen + (value ? STRLEN (value) : 0) + 1);
	  strcpy (retval, oval);
",unused,bashsources-variables.c
"	  olen = STRLEN (oval);
	  retval = (char *)xmalloc (olen + (value ? STRLEN (value) : 0) + 1);
	  strcpy (retval, oval);
	  if (value)
	    strcpy (retval+olen, value);
",1,unused,2640,unused,"	  olen = STRLEN (oval);
	  retval = (char *)xmalloc (olen + (value ? STRLEN (value) : 0) + 1);
	  strcpy (retval, oval);
	  if (value)
	    strcpy (retval+olen, value);
",unused,bashsources-variables.c
"	  if (oval == 0)	/* paranoia */
	    oval = """";
	  olen = STRLEN (oval);
	  retval = (char *)xmalloc (olen + (value ? STRLEN (value) : 0) + 1);
	  strcpy (retval, oval);
",1,unused,2665,unused,"	  if (oval == 0)	/* paranoia */
	    oval = """";
	  olen = STRLEN (oval);
	  retval = (char *)xmalloc (olen + (value ? STRLEN (value) : 0) + 1);
	  strcpy (retval, oval);
",unused,bashsources-variables.c
"	  olen = STRLEN (oval);
	  retval = (char *)xmalloc (olen + (value ? STRLEN (value) : 0) + 1);
	  strcpy (retval, oval);
	  if (value)
	    strcpy (retval+olen, value);
",1,unused,2667,unused,"	  olen = STRLEN (oval);
	  retval = (char *)xmalloc (olen + (value ? STRLEN (value) : 0) + 1);
	  strcpy (retval, oval);
	  if (value)
	    strcpy (retval+olen, value);
",unused,bashsources-variables.c
"{
  char *evar;

  evar = (char *)xmalloc (STRLEN (value) + preflen + 1);
  strcpy (evar, env_prefix);
",1,unused,4540,unused,"{
  char *evar;

  evar = (char *)xmalloc (STRLEN (value) + preflen + 1);
  strcpy (evar, env_prefix);
",unused,bashsources-variables.c
"
  evar = (char *)xmalloc (STRLEN (value) + preflen + 1);
  strcpy (evar, env_prefix);
  if (value)
    strcpy (evar + preflen, value);
",1,unused,4542,unused,"
  evar = (char *)xmalloc (STRLEN (value) + preflen + 1);
  strcpy (evar, env_prefix);
  if (value)
    strcpy (evar + preflen, value);
",unused,bashsources-variables.c
"  char *r;

  l = strlen (s);
  r = xmalloc (l + 2);
  strcpy (r, s);
",1,unused,5102,unused,"  char *r;

  l = strlen (s);
  r = xmalloc (l + 2);
  strcpy (r, s);
",unused,bashsources-y.tab.c
"	    return -1;		/* Bail immediately. */
	  RESIZE_MALLOCED_BUFFER (token, token_index, ttoklen + 2,
				  token_buffer_size, TOKEN_DEFAULT_GROW_SIZE);
	  token[token_index++] = character;
	  strcpy (token + token_index, ttok);
",1,unused,7064,unused,"	    return -1;		/* Bail immediately. */
	  RESIZE_MALLOCED_BUFFER (token, token_index, ttoklen + 2,
				  token_buffer_size, TOKEN_DEFAULT_GROW_SIZE);
	  token[token_index++] = character;
	  strcpy (token + token_index, ttok);
",unused,bashsources-y.tab.c
"	    return -1;		/* Bail immediately. */
	  RESIZE_MALLOCED_BUFFER (token, token_index, ttoklen + 2,
				  token_buffer_size, TOKEN_DEFAULT_GROW_SIZE);
	  token[token_index++] = character;
	  strcpy (token + token_index, ttok);
",1,unused,7090,unused,"	    return -1;		/* Bail immediately. */
	  RESIZE_MALLOCED_BUFFER (token, token_index, ttoklen + 2,
				  token_buffer_size, TOKEN_DEFAULT_GROW_SIZE);
	  token[token_index++] = character;
	  strcpy (token + token_index, ttok);
",unused,bashsources-y.tab.c
"				      token_buffer_size,
				      TOKEN_DEFAULT_GROW_SIZE);
	      token[token_index++] = character;
	      token[token_index++] = peek_char;
	      strcpy (token + token_index, ttok);
",1,unused,7115,unused,"				      token_buffer_size,
				      TOKEN_DEFAULT_GROW_SIZE);
	      token[token_index++] = character;
	      token[token_index++] = peek_char;
	      strcpy (token + token_index, ttok);
",unused,bashsources-y.tab.c
"				      token_buffer_size,
				      TOKEN_DEFAULT_GROW_SIZE);
	      token[token_index++] = character;
	      token[token_index++] = peek_char;
	      strcpy (token + token_index, ttok);
",1,unused,7157,unused,"				      token_buffer_size,
				      TOKEN_DEFAULT_GROW_SIZE);
	      token[token_index++] = character;
	      token[token_index++] = peek_char;
	      strcpy (token + token_index, ttok);
",unused,bashsources-y.tab.c
"
	      RESIZE_MALLOCED_BUFFER (token, token_index, ttranslen + 1,
				      token_buffer_size,
				      TOKEN_DEFAULT_GROW_SIZE);
	      strcpy (token + token_index, ttrans);
",1,unused,7206,unused,"
	      RESIZE_MALLOCED_BUFFER (token, token_index, ttranslen + 1,
				      token_buffer_size,
				      TOKEN_DEFAULT_GROW_SIZE);
	      strcpy (token + token_index, ttrans);
",unused,bashsources-y.tab.c
"	  RESIZE_MALLOCED_BUFFER (token, token_index, ttoklen + 2,
				  token_buffer_size,
				  TOKEN_DEFAULT_GROW_SIZE);
	  token[token_index++] = character;
	  strcpy (token + token_index, ttok);
",1,unused,7245,unused,"	  RESIZE_MALLOCED_BUFFER (token, token_index, ttoklen + 2,
				  token_buffer_size,
				  TOKEN_DEFAULT_GROW_SIZE);
	  token[token_index++] = character;
	  strcpy (token + token_index, ttok);
",unused,bashsources-y.tab.c
"	      token[token_index++] = '=';
	      token[token_index++] = '(';
	      if (ttok)
		{
		  strcpy (token + token_index, ttok);
",1,unused,7267,unused,"	      token[token_index++] = '=';
	      token[token_index++] = '(';
	      if (ttok)
		{
		  strcpy (token + token_index, ttok);
",unused,bashsources-y.tab.c
"
  the_word = alloc_word_desc ();
  the_word->word = (char *)xmalloc (1 + token_index);
  the_word->flags = 0;
  strcpy (the_word->word, token);
",1,unused,7373,unused,"
  the_word = alloc_word_desc ();
  the_word->word = (char *)xmalloc (1 + token_index);
  the_word->flags = 0;
  strcpy (the_word->word, token);
",unused,bashsources-y.tab.c
"#else
      if (legal_identifier (token+1))
#endif
	{
	  strcpy (the_word->word, token+1);
",1,unused,7418,unused,"#else
      if (legal_identifier (token+1))
#endif
	{
	  strcpy (the_word->word, token+1);
",unused,bashsources-y.tab.c
"	    case 'v':
	    case 'V':
	      temp = (char *)xmalloc (16);
	      if (c == 'v')
		strcpy (temp, dist_version);
",1,unused,7915,unused,"	    case 'v':
	    case 'V':
	      temp = (char *)xmalloc (16);
	      if (c == 'v')
		strcpy (temp, dist_version);
",unused,bashsources-y.tab.c
"	      temp = (char *)xmalloc (16);
	      if (c == 'v')
		strcpy (temp, dist_version);
	      else
		sprintf (temp, ""%s.%d"", dist_version, patch_level);
",1,unused,7917,unused,"	      temp = (char *)xmalloc (16);
	      if (c == 'v')
		strcpy (temp, dist_version);
	      else
		sprintf (temp, ""%s.%d"", dist_version, patch_level);
",unused,bashsources-y.tab.c
"		    /* polite_directory_format is guaranteed to return a string
		       no longer than PATH_MAX - 1 characters. */
		    temp = polite_directory_format (t_string);
		    if (temp != t_string)
		      strcpy (t_string, temp);
",1,unused,7973,unused,"		    /* polite_directory_format is guaranteed to return a string
		       no longer than PATH_MAX - 1 characters. */
		    temp = polite_directory_format (t_string);
		    if (temp != t_string)
		      strcpy (t_string, temp);
",unused,bashsources-y.tab.c
"
	  /* +3 because we possibly add one more character below. */
	  RESIZE_MALLOCED_BUFFER (line, llen, (vlen + 3), line_len, (vlen + 50));

	  strcpy (line + llen, v);
",1,unused,558,unused,"
	  /* +3 because we possibly add one more character below. */
	  RESIZE_MALLOCED_BUFFER (line, llen, (vlen + 3), line_len, (vlen + 50));

	  strcpy (line + llen, v);
",unused,bashxenial-alias.c
"			t = quoted ? quote_string(element_value(ae)) : element_value(ae);
			reg = strlen(t);
			RESIZE_MALLOCED_BUFFER (result, rlen, (reg + slen + 2),
						rsize, rsize);
			strcpy(result + rlen, t);
",1,unused,835,unused,"			t = quoted ? quote_string(element_value(ae)) : element_value(ae);
			reg = strlen(t);
			RESIZE_MALLOCED_BUFFER (result, rlen, (reg + slen + 2),
						rsize, rsize);
			strcpy(result + rlen, t);
",unused,bashxenial-array.c
"			/*
			 * Add a separator only after non-null elements.
			 */
			if (element_forw(ae) != end) {
				strcpy(result + rlen, sep);
",1,unused,843,unused,"			/*
			 * Add a separator only after non-null elements.
			 */
			if (element_forw(ae) != end) {
				strcpy(result + rlen, sep);
",unused,bashxenial-array.c
"		elen = STRLEN (is) + 8 + STRLEN (valstr);
		RESIZE_MALLOCED_BUFFER (result, rlen, (elen + 1), rsize, rsize);

		result[rlen++] = '[';
		strcpy (result + rlen, is);
",1,unused,878,unused,"		elen = STRLEN (is) + 8 + STRLEN (valstr);
		RESIZE_MALLOCED_BUFFER (result, rlen, (elen + 1), rsize, rsize);

		result[rlen++] = '[';
		strcpy (result + rlen, is);
",unused,bashxenial-array.c
"		rlen += STRLEN (is);
		result[rlen++] = ']';
		result[rlen++] = '=';
		if (valstr) {
			strcpy (result + rlen, valstr);
",1,unused,883,unused,"		rlen += STRLEN (is);
		result[rlen++] = ']';
		result[rlen++] = '=';
		if (valstr) {
			strcpy (result + rlen, valstr);
",unused,bashxenial-array.c
"	  ss = s - string;
	  se = skipsubscript (string, ss, 0);
	  subs = substring (s, ss, se);
	  *t++ = '\\';
	  strcpy (t, subs);
",1,unused,663,unused,"	  ss = s - string;
	  se = skipsubscript (string, ss, 0);
	  subs = substring (s, ss, se);
	  *t++ = '\\';
	  strcpy (t, subs);
",unused,bashxenial-arrayfunc.c
"	elen = STRLEN (istr) + 8 + STRLEN (vstr);
	RESIZE_MALLOCED_BUFFER (ret, rlen, (elen+1), rsize, rsize);

	ret[rlen++] = '[';
	strcpy (ret+rlen, istr);
",1,unused,450,unused,"	elen = STRLEN (istr) + 8 + STRLEN (vstr);
	RESIZE_MALLOCED_BUFFER (ret, rlen, (elen+1), rsize, rsize);

	ret[rlen++] = '[';
	strcpy (ret+rlen, istr);
",unused,bashxenial-assoc.c
"	ret[rlen++] = ']';
	ret[rlen++] = '=';
	if (vstr)
	  {
	    strcpy (ret + rlen, vstr);
",1,unused,456,unused,"	ret[rlen++] = ']';
	ret[rlen++] = '=';
	if (vstr)
	  {
	    strcpy (ret + rlen, vstr);
",unused,bashxenial-assoc.c
"	  new_line = (char *)xmalloc (1
				      + curlen
				      + strlen (line)
				      + strlen (chars_to_add));
	  sprintf (new_line, ""%s%s%s"", current->line, chars_to_add, line);
",1,unused,783,unused,"	  new_line = (char *)xmalloc (1
				      + curlen
				      + strlen (line)
				      + strlen (chars_to_add));
	  sprintf (new_line, ""%s%s%s"", current->line, chars_to_add, line);
",unused,bashxenial-bashhist.c
"	}
      else
	{
	  nval[0] = '@';
	  strcpy (nval + 1, rl_completer_word_break_characters);
",1,unused,396,unused,"	}
      else
	{
	  nval[0] = '@';
	  strcpy (nval + 1, rl_completer_word_break_characters);
",unused,bashxenial-bashline.c
"
  if (rl_explicit_arg)
    {
      command = (char *)xmalloc (strlen (edit_command) + 8);
      sprintf (command, ""%s %d"", edit_command, count);
",1,unused,951,unused,"
  if (rl_explicit_arg)
    {
      command = (char *)xmalloc (strlen (edit_command) + 8);
      sprintf (command, ""%s %d"", edit_command, count);
",unused,bashxenial-bashline.c
"	value[0] = *orig_start;
      else
	strncpy (value, orig_start, start_len);

      strcpy (value + start_len, matches[cmd_index]);
",1,unused,2205,unused,"	value[0] = *orig_start;
      else
	strncpy (value, orig_start, start_len);

      strcpy (value + start_len, matches[cmd_index]);
",unused,bashxenial-bashline.c
"	  if (first_char_loc == 2)
	    value[1] = '{';
	}

      strcpy (value + first_char_loc, varlist[varlist_index]);
",1,unused,2265,unused,"	  if (first_char_loc == 2)
	    value[1] = '{';
	}

      strcpy (value + first_char_loc, varlist[varlist_index]);
",unused,bashxenial-bashline.c
"	}

      strcpy (value + first_char_loc, varlist[varlist_index]);
      if (first_char_loc == 2)
	strcat (value, ""}"");
",1,unused,2267,unused,"	}

      strcpy (value + first_char_loc, varlist[varlist_index]);
      if (first_char_loc == 2)
	strcat (value, ""}"");
",unused,bashxenial-bashline.c
"      char *t;

      t = (char *)xmalloc (2 + strlen (list[list_index]));
      *t = first_char;
      strcpy (t + first_char_loc, list[list_index]);
",1,unused,2307,unused,"      char *t;

      t = (char *)xmalloc (2 + strlen (list[list_index]));
      *t = first_char;
      strcpy (t + first_char_loc, list[list_index]);
",unused,bashxenial-bashline.c
"  */
  l = (vl - xl) + 1;

  ret = (char *)xmalloc (dl2 + 2 + l);
  strcpy (ret, dh2);
",1,unused,2908,unused,"  */
  l = (vl - xl) + 1;

  ret = (char *)xmalloc (dl2 + 2 + l);
  strcpy (ret, dh2);
",unused,bashxenial-bashline.c
"  l = (vl - xl) + 1;

  ret = (char *)xmalloc (dl2 + 2 + l);
  strcpy (ret, dh2);
  strcpy (ret + dl2, val + xl);
",1,unused,2909,unused,"  l = (vl - xl) + 1;

  ret = (char *)xmalloc (dl2 + 2 + l);
  strcpy (ret, dh2);
  strcpy (ret + dl2, val + xl);
",unused,bashxenial-bashline.c
"	{
	  globorig = savestring (ttext);
	  glen = strlen (ttext);
	  globtext = (char *)xmalloc (glen + 2);
	  strcpy (globtext, ttext);
",1,unused,3579,unused,"	{
	  globorig = savestring (ttext);
	  glen = strlen (ttext);
	  globtext = (char *)xmalloc (glen + 2);
	  strcpy (globtext, ttext);
",unused,bashxenial-bashline.c
"  if (rtext)
    {
      rlen = strlen (rtext);
      ret = (char *)xmalloc (rlen + 1);
      strcpy (ret, rtext);
",1,unused,3925,unused,"  if (rtext)
    {
      rlen = strlen (rtext);
      ret = (char *)xmalloc (rlen + 1);
      strcpy (ret, rtext);
",unused,bashxenial-bashline.c
"	  subterm = sh_backslash_quote (x, 0, 0);
	  free (x);
	  result_size += strlen (subterm) + 1;
	  result = (char *)xrealloc (result, result_size);
	  strcat (result, subterm);
",1,unused,133,unused,"	  subterm = sh_backslash_quote (x, 0, 0);
	  free (x);
	  result_size += strlen (subterm) + 1;
	  result = (char *)xrealloc (result, result_size);
	  strcat (result, subterm);
",unused,bashxenial-bracecomp.c
"	  result_size += strlen (subterm) + 1;
	  result = (char *)xrealloc (result, result_size);
	  strcat (result, subterm);
	  free (subterm);
	  strcat (result, ""{"");
",1,unused,135,unused,"	  result_size += strlen (subterm) + 1;
	  result = (char *)xrealloc (result, result_size);
	  strcat (result, subterm);
	  free (subterm);
	  strcat (result, ""{"");
",unused,bashxenial-bracecomp.c
"	}

      result_size += strlen (subterm) + 1;
      result = (char *)xrealloc (result, result_size);
      strcat (result, subterm);
",1,unused,142,unused,"	}

      result_size += strlen (subterm) + 1;
      result = (char *)xrealloc (result, result_size);
      strcat (result, subterm);
",unused,bashxenial-bracecomp.c
"
      result_size += strlen (subterm) + 1;
      result = (char *)xrealloc (result, result_size);
      strcat (result, subterm);
      strcat (result, "","");
",1,unused,143,unused,"
      result_size += strlen (subterm) + 1;
      result = (char *)xrealloc (result, result_size);
      strcat (result, subterm);
      strcat (result, "","");
",unused,bashxenial-bracecomp.c
"
      for (j = 0; j < len2; j++)
	{
	  result[len] = (char *)xmalloc (1 + strlen_1 + strlen (arr2[j]));
	  strcpy (result[len], arr1[i]);
",1,unused,772,unused,"
      for (j = 0; j < len2; j++)
	{
	  result[len] = (char *)xmalloc (1 + strlen_1 + strlen (arr2[j]));
	  strcpy (result[len], arr1[i]);
",unused,bashxenial-braces.c
"      for (j = 0; j < len2; j++)
	{
	  result[len] = (char *)xmalloc (1 + strlen_1 + strlen (arr2[j]));
	  strcpy (result[len], arr1[i]);
	  strcpy (result[len] + strlen_1, arr2[j]);
",1,unused,773,unused,"      for (j = 0; j < len2; j++)
	{
	  result[len] = (char *)xmalloc (1 + strlen_1 + strlen (arr2[j]));
	  strcpy (result[len], arr1[i]);
	  strcpy (result[len] + strlen_1, arr2[j]);
",unused,bashxenial-braces.c
"	  if (error_directory)
	    free (error_directory);

	  error_directory = xmalloc (2 + strlen (argv[arg_index]));
	  strcpy (error_directory, argv[arg_index]);
",1,unused,241,unused,"	  if (error_directory)
	    free (error_directory);

	  error_directory = xmalloc (2 + strlen (argv[arg_index]));
	  strcpy (error_directory, argv[arg_index]);
",unused,bashxenial-builtins2Fmkbuiltins.c
"	  strcpy (error_directory, argv[arg_index]);
	  len = strlen (error_directory);

	  if (len && error_directory[len - 1] != '/')
	    strcat (error_directory, ""/"");
",1,unused,245,unused,"	  strcpy (error_directory, argv[arg_index]);
	  len = strlen (error_directory);

	  if (len && error_directory[len - 1] != '/')
	    strcat (error_directory, ""/"");
",unused,bashxenial-builtins2Fmkbuiltins.c
"      /* Open the files. */
      if (struct_filename)
	{
	  temp_struct_filename = xmalloc (15);
	  sprintf (temp_struct_filename, ""mk-%ld"", (long) getpid ());
",1,unused,278,unused,"      /* Open the files. */
      if (struct_filename)
	{
	  temp_struct_filename = xmalloc (15);
	  sprintf (temp_struct_filename, ""mk-%ld"", (long) getpid ());
",unused,bashxenial-builtins2Fmkbuiltins.c
"      if (separate_helpfiles)
	{
	  int l = strlen (helpfile_directory) + strlen (dname) + 1;
	  sarray[0] = (char *)xmalloc (l + 1);
	  sprintf (sarray[0], ""%s/%s"", helpfile_directory, dname);
",1,unused,1313,unused,"      if (separate_helpfiles)
	{
	  int l = strlen (helpfile_directory) + strlen (dname) + 1;
	  sarray[0] = (char *)xmalloc (l + 1);
	  sprintf (sarray[0], ""%s/%s"", helpfile_directory, dname);
",unused,bashxenial-builtins2Fmkbuiltins.c
"      builtin = (BUILTIN_DESC *)builtins->array[i];

      bname = document_name (builtin);
      helpfile = (char *)xmalloc (hdlen + strlen (bname) + 1);
      sprintf (helpfile, ""helpfiles/%s"", bname);
",1,unused,1565,unused,"      builtin = (BUILTIN_DESC *)builtins->array[i];

      bname = document_name (builtin);
      helpfile = (char *)xmalloc (hdlen + strlen (bname) + 1);
      sprintf (helpfile, ""helpfiles/%s"", bname);
",unused,bashxenial-builtins2Fmkbuiltins.c
"	  sum = cpu / 100;
	  sum_frac = (cpu % 100) * 10;
	  len = mkfmt (ts, 2, 0, sum, sum_frac);
	  RESIZE_MALLOCED_BUFFER (str, sindex, len, ssize, 64);
	  strcpy (str + sindex, ts);
",1,unused,1207,unused,"	  sum = cpu / 100;
	  sum_frac = (cpu % 100) * 10;
	  len = mkfmt (ts, 2, 0, sum, sum_frac);
	  RESIZE_MALLOCED_BUFFER (str, sindex, len, ssize, 64);
	  strcpy (str + sindex, ts);
",unused,bashxenial-execute_cmd.c
"	      free (str);
	      return;
	    }
	  RESIZE_MALLOCED_BUFFER (str, sindex, len, ssize, 64);
	  strcpy (str + sindex, ts);
",1,unused,1238,unused,"	      free (str);
	      return;
	    }
	  RESIZE_MALLOCED_BUFFER (str, sindex, len, ssize, 64);
	  strcpy (str + sindex, ts);
",unused,bashxenial-execute_cmd.c
"  bind_variable (namevar, t, 0);
  free (t);
#endif

  sprintf (namevar, ""%s_PID"", cp->c_name);
",1,unused,2132,unused,"  bind_variable (namevar, t, 0);
  free (t);
#endif

  sprintf (namevar, ""%s_PID"", cp->c_name);
",unused,bashxenial-execute_cmd.c
"
  l = strlen (cp->c_name);
  namevar = xmalloc (l + 16);

  sprintf (namevar, ""%s_PID"", cp->c_name);
",1,unused,2153,unused,"
  l = strlen (cp->c_name);
  namevar = xmalloc (l + 16);

  sprintf (namevar, ""%s_PID"", cp->c_name);
",unused,bashxenial-execute_cmd.c
"
  llen = strlen (vname) + sizeof (ibuf) + 3;
  lhs = xmalloc (llen);

  sprintf (lhs, ""%s[%s]"", vname, istr);		/* XXX */
",1,unused,342,unused,"
  llen = strlen (vname) + sizeof (ibuf) + 3;
  lhs = xmalloc (llen);

  sprintf (lhs, ""%s[%s]"", vname, istr);		/* XXX */
",unused,bashxenial-expr.c
"      if (tail[0] != '.' || tail[1] != '/')
	{
	  dotted_filename = (char *)xmalloc (3 + strlen (tail));
	  dotted_filename[0] = '.'; dotted_filename[1] = '/';
	  strcpy (dotted_filename + 2, tail);
",1,unused,155,unused,"      if (tail[0] != '.' || tail[1] != '/')
	{
	  dotted_filename = (char *)xmalloc (3 + strlen (tail));
	  dotted_filename[0] = '.'; dotted_filename[1] = '/';
	  strcpy (dotted_filename + 2, tail);
",unused,bashxenial-hashcmd.c
"  x = strsignal (s);
  if (x == 0)
    {
      x = retcode_name_buffer;
      sprintf (x, _(""Signal %d""), s);
",1,unused,1450,unused,"  x = strsignal (s);
  if (x == 0)
    {
      x = retcode_name_buffer;
      sprintf (x, _(""Signal %d""), s);
",unused,bashxenial-jobs.c
"	temp = _(""Stopped"");
      else
	{
	  temp = retcode_name_buffer;
	  sprintf (temp, _(""Stopped(%s)""), signal_name (WSTOPSIG (p->status)));
",1,unused,1473,unused,"	temp = _(""Stopped"");
      else
	{
	  temp = retcode_name_buffer;
	  sprintf (temp, _(""Stopped(%s)""), signal_name (WSTOPSIG (p->status)));
",unused,bashxenial-jobs.c
"	{
	  temp = retcode_name_buffer;
	  es = WEXITSTATUS (p->status);
	  if (es == 0)
	    strcpy (temp, _(""Done""));
",1,unused,1489,unused,"	{
	  temp = retcode_name_buffer;
	  es = WEXITSTATUS (p->status);
	  if (es == 0)
	    strcpy (temp, _(""Done""));
",unused,bashxenial-jobs.c
"	  es = WEXITSTATUS (p->status);
	  if (es == 0)
	    strcpy (temp, _(""Done""));
	  else if (posixly_correct)
	    sprintf (temp, _(""Done(%d)""), es);
",1,unused,1491,unused,"	  es = WEXITSTATUS (p->status);
	  if (es == 0)
	    strcpy (temp, _(""Done""));
	  else if (posixly_correct)
	    sprintf (temp, _(""Done(%d)""), es);
",unused,bashxenial-jobs.c
"	    strcpy (temp, _(""Done""));
	  else if (posixly_correct)
	    sprintf (temp, _(""Done(%d)""), es);
	  else
	    sprintf (temp, _(""Exit %d""), es);
",1,unused,1493,unused,"	    strcpy (temp, _(""Done""));
	  else if (posixly_correct)
	    sprintf (temp, _(""Done(%d)""), es);
	  else
	    sprintf (temp, _(""Exit %d""), es);
",unused,bashxenial-jobs.c
"	  lose = 1;
	}
      else
	{
	  strcpy (npat, pat);
",1,unused,630,unused,"	  lose = 1;
	}
      else
	{
	  strcpy (npat, pat);
",unused,bashxenial-lib2Fglob2Fglob.c
"	{
	  strcpy (npat, pat);
	  dequote_pathname (npat);

	  strcpy (nextname, dir);
",1,unused,633,unused,"	{
	  strcpy (npat, pat);
	  dequote_pathname (npat);

	  strcpy (nextname, dir);
",unused,bashxenial-lib2Fglob2Fglob.c
"	  dequote_pathname (npat);

	  strcpy (nextname, dir);
	  nextname[dirlen++] = '/';
	  strcpy (nextname + dirlen, npat);
",1,unused,635,unused,"	  dequote_pathname (npat);

	  strcpy (nextname, dir);
	  nextname[dirlen++] = '/';
	  strcpy (nextname + dirlen, npat);
",unused,bashxenial-lib2Fglob2Fglob.c
"	  free (result);
	  return (NULL);
	}

      strcpy (result[i], dir);
",1,unused,972,unused,"	  free (result);
	  return (NULL);
	}

      strcpy (result[i], dir);
",unused,bashxenial-lib2Fglob2Fglob.c
"
      strcpy (result[i], dir);
      if (add_slash)
	result[i][l] = '/';
      strcpy (result[i] + l + add_slash, array[i]);
",1,unused,975,unused,"
      strcpy (result[i], dir);
      if (add_slash)
	result[i][l] = '/';
      strcpy (result[i] + l + add_slash, array[i]);
",unused,bashxenial-lib2Fglob2Fglob.c
"		       with the eighth bit set to ESC-prefixed sequences, then
		       we can use \M-.  Otherwise we need to use the sequence
		       for ESC. */
		    if (_rl_convert_meta_chars_to_ascii && map[ESC].type == ISKMAP)
		      sprintf (keyname, ""\\M-"");
",1,unused,2136,unused,"		       with the eighth bit set to ESC-prefixed sequences, then
		       we can use \M-.  Otherwise we need to use the sequence
		       for ESC. */
		    if (_rl_convert_meta_chars_to_ascii && map[ESC].type == ISKMAP)
		      sprintf (keyname, ""\\M-"");
",unused,bashxenial-lib2Freadline2Fbind.c
"		       for ESC. */
		    if (_rl_convert_meta_chars_to_ascii && map[ESC].type == ISKMAP)
		      sprintf (keyname, ""\\M-"");
		    else
		      sprintf (keyname, ""\\e"");
",1,unused,2138,unused,"		       for ESC. */
		    if (_rl_convert_meta_chars_to_ascii && map[ESC].type == ISKMAP)
		      sprintf (keyname, ""\\M-"");
		    else
		      sprintf (keyname, ""\\e"");
",unused,bashxenial-lib2Freadline2Fbind.c
"		    else
		      sprintf (keyname, ""\\e"");
		  }
		else if (CTRL_CHAR (key))
		  sprintf (keyname, ""\\C-%c"", _rl_to_lower (UNCTRL (key)));
",1,unused,2141,unused,"		    else
		      sprintf (keyname, ""\\e"");
		  }
		else if (CTRL_CHAR (key))
		  sprintf (keyname, ""\\C-%c"", _rl_to_lower (UNCTRL (key)));
",unused,bashxenial-lib2Freadline2Fbind.c
"		  }
		else if (CTRL_CHAR (key))
		  sprintf (keyname, ""\\C-%c"", _rl_to_lower (UNCTRL (key)));
		else if (key == RUBOUT)
		  sprintf (keyname, ""\\C-?"");
",1,unused,2143,unused,"		  }
		else if (CTRL_CHAR (key))
		  sprintf (keyname, ""\\C-%c"", _rl_to_lower (UNCTRL (key)));
		else if (key == RUBOUT)
		  sprintf (keyname, ""\\C-?"");
",unused,bashxenial-lib2Freadline2Fbind.c
"		    keyname[0] = (char) key;
		    keyname[1] = '\0';
		  }
		
		strcat (keyname, seqs[i]);
",1,unused,2156,unused,"		    keyname[0] = (char) key;
		    keyname[1] = '\0';
		  }
		
		strcat (keyname, seqs[i]);
",unused,bashxenial-lib2Freadline2Fbind.c
"	  if (key == ESC)
	    {
	      keyname = (char *)xmalloc (3 + prefix_len);
	      if (prefix)
		strcpy (keyname, prefix);
",1,unused,2309,unused,"	  if (key == ESC)
	    {
	      keyname = (char *)xmalloc (3 + prefix_len);
	      if (prefix)
		strcpy (keyname, prefix);
",unused,bashxenial-lib2Freadline2Fbind.c
"	      keyname = _rl_get_keyname (key);
	      if (prefix)
		{
		  out = (char *)xmalloc (strlen (keyname) + prefix_len + 1);
		  strcpy (out, prefix);
",1,unused,2320,unused,"	      keyname = _rl_get_keyname (key);
	      if (prefix)
		{
		  out = (char *)xmalloc (strlen (keyname) + prefix_len + 1);
		  strcpy (out, prefix);
",unused,bashxenial-lib2Freadline2Fbind.c
"	      if (prefix)
		{
		  out = (char *)xmalloc (strlen (keyname) + prefix_len + 1);
		  strcpy (out, prefix);
		  strcpy (out + prefix_len, keyname);
",1,unused,2321,unused,"	      if (prefix)
		{
		  out = (char *)xmalloc (strlen (keyname) + prefix_len + 1);
		  strcpy (out, prefix);
		  strcpy (out + prefix_len, keyname);
",unused,bashxenial-lib2Freadline2Fbind.c
"  else if (_rl_stricmp (name, ""comment-begin"") == 0)
    return (_rl_comment_begin ? _rl_comment_begin : RL_COMMENT_BEGIN_DEFAULT);
  else if (_rl_stricmp (name, ""completion-display-width"") == 0)
    {
      sprintf (numbuf, ""%d"", _rl_completion_columns);
",1,unused,2376,unused,"  else if (_rl_stricmp (name, ""comment-begin"") == 0)
    return (_rl_comment_begin ? _rl_comment_begin : RL_COMMENT_BEGIN_DEFAULT);
  else if (_rl_stricmp (name, ""completion-display-width"") == 0)
    {
      sprintf (numbuf, ""%d"", _rl_completion_columns);
",unused,bashxenial-lib2Freadline2Fbind.c
"      return (numbuf);
    }
  else if (_rl_stricmp (name, ""completion-prefix-display-length"") == 0)
    {
      sprintf (numbuf, ""%d"", _rl_completion_prefix_display_length);
",1,unused,2381,unused,"      return (numbuf);
    }
  else if (_rl_stricmp (name, ""completion-prefix-display-length"") == 0)
    {
      sprintf (numbuf, ""%d"", _rl_completion_prefix_display_length);
",unused,bashxenial-lib2Freadline2Fbind.c
"      return (numbuf);
    }
  else if (_rl_stricmp (name, ""completion-query-items"") == 0)
    {
      sprintf (numbuf, ""%d"", rl_completion_query_items);
",1,unused,2386,unused,"      return (numbuf);
    }
  else if (_rl_stricmp (name, ""completion-query-items"") == 0)
    {
      sprintf (numbuf, ""%d"", rl_completion_query_items);
",unused,bashxenial-lib2Freadline2Fbind.c
"  else if (_rl_stricmp (name, ""editing-mode"") == 0)
    return (rl_get_keymap_name_from_edit_mode ());
  else if (_rl_stricmp (name, ""history-size"") == 0)
    {
      sprintf (numbuf, ""%d"", history_is_stifled() ? history_max_entries : 0);
",1,unused,2393,unused,"  else if (_rl_stricmp (name, ""editing-mode"") == 0)
    return (rl_get_keymap_name_from_edit_mode ());
  else if (_rl_stricmp (name, ""history-size"") == 0)
    {
      sprintf (numbuf, ""%d"", history_is_stifled() ? history_max_entries : 0);
",unused,bashxenial-lib2Freadline2Fbind.c
"      return (ret ? ret : ""none"");
    }
  else if (_rl_stricmp (name, ""keyseq-timeout"") == 0)
    {
      sprintf (numbuf, ""%d"", _rl_keyseq_timeout);    
",1,unused,2420,unused,"      return (ret ? ret : ""none"");
    }
  else if (_rl_stricmp (name, ""keyseq-timeout"") == 0)
    {
      sprintf (numbuf, ""%d"", _rl_keyseq_timeout);    
",unused,bashxenial-lib2Freadline2Fbind.c
"
	  slen = strlen (s);
	  tlen = strlen (to_print);
	  new_full_pathname = (char *)xmalloc (slen + tlen + 2);
	  strcpy (new_full_pathname, s);
",1,unused,909,unused,"
	  slen = strlen (s);
	  tlen = strlen (to_print);
	  new_full_pathname = (char *)xmalloc (slen + tlen + 2);
	  strcpy (new_full_pathname, s);
",unused,bashxenial-lib2Freadline2Fcomplete.c
"	    slen--;
	  else
	    new_full_pathname[slen] = '/';
	  new_full_pathname[slen] = '/';
	  strcpy (new_full_pathname + slen + 1, to_print);
",1,unused,915,unused,"	    slen--;
	  else
	    new_full_pathname[slen] = '/';
	  new_full_pathname[slen] = '/';
	  strcpy (new_full_pathname + slen + 1, to_print);
",unused,bashxenial-lib2Freadline2Fcomplete.c
"  char *r;

  r = (char *)xmalloc (strlen (s) + 2);
  *r = *rl_completer_quote_characters;
  strcpy (r + 1, s);
",1,unused,991,unused,"  char *r;

  r = (char *)xmalloc (strlen (s) + 2);
  *r = *rl_completer_quote_characters;
  strcpy (r + 1, s);
",unused,bashxenial-lib2Freadline2Fcomplete.c
"     value of matches[0]. */
  if (low == 0 && text && *text)
    {
      match_list[0] = (char *)xmalloc (strlen (text) + 1);
      strcpy (match_list[0], text);
",1,unused,1351,unused,"     value of matches[0]. */
  if (low == 0 && text && *text)
    {
      match_list[0] = (char *)xmalloc (strlen (text) + 1);
      strcpy (match_list[0], text);
",unused,bashxenial-lib2Freadline2Fcomplete.c
"      value = (char *)xmalloc (2 + strlen (entry->pw_name));

      *value = *text;

      strcpy (value + first_char_loc, entry->pw_name);
",1,unused,2214,unused,"      value = (char *)xmalloc (2 + strlen (entry->pw_name));

      *value = *text;

      strcpy (value + first_char_loc, entry->pw_name);
",unused,bashxenial-lib2Freadline2Fcomplete.c
"#endif

      if (temp)
	{
	  strcpy (filename, ++temp);
",1,unused,2404,unused,"#endif

      if (temp)
	{
	  strcpy (filename, ++temp);
",unused,bashxenial-lib2Freadline2Fcomplete.c
"	  if (rl_complete_with_tilde_expansion && *users_dirname == '~')
	    {
	      dirlen = strlen (dirname);
	      temp = (char *)xmalloc (2 + dirlen + D_NAMLEN (entry));
	      strcpy (temp, dirname);
",1,unused,2548,unused,"	  if (rl_complete_with_tilde_expansion && *users_dirname == '~')
	    {
	      dirlen = strlen (dirname);
	      temp = (char *)xmalloc (2 + dirlen + D_NAMLEN (entry));
	      strcpy (temp, dirname);
",unused,bashxenial-lib2Freadline2Fcomplete.c
"	  else
	    {
	      dirlen = strlen (users_dirname);
	      temp = (char *)xmalloc (2 + dirlen + D_NAMLEN (entry));
	      strcpy (temp, users_dirname);
",1,unused,2561,unused,"	  else
	    {
	      dirlen = strlen (users_dirname);
	      temp = (char *)xmalloc (2 + dirlen + D_NAMLEN (entry));
	      strcpy (temp, users_dirname);
",unused,bashxenial-lib2Freadline2Fcomplete.c
"	      if (users_dirname[dirlen - 1] != '/')
		temp[dirlen++] = '/';
	    }

	  strcpy (temp + dirlen, convfn);
",1,unused,2567,unused,"	      if (users_dirname[dirlen - 1] != '/')
		temp[dirlen++] = '/';
	    }

	  strcpy (temp + dirlen, convfn);
",unused,bashxenial-lib2Freadline2Fcomplete.c
"        {
          l = strlen (pmt);
          r = (char *)xmalloc (l + 2);
          r[0] = prompt_modechar ();
          strcpy (r + 1, pmt);
",1,unused,285,unused,"        {
          l = strlen (pmt);
          r = (char *)xmalloc (l + 2);
          r[0] = prompt_modechar ();
          strcpy (r + 1, pmt);
",unused,bashxenial-lib2Freadline2Fdisplay.c
"#endif
	{
	  if (_rl_output_meta_chars == 0)
	    {
	      sprintf (line + out, ""\\%o"", c);
",1,unused,832,unused,"#endif
	{
	  if (_rl_output_meta_chars == 0)
	    {
	      sprintf (line + out, ""\\%o"", c);
",unused,bashxenial-lib2Freadline2Fdisplay.c
"
  /* Make sure the line structures hold the already-displayed prompt for
     redisplay. */
  lprompt = local_prompt ? local_prompt : rl_prompt;
  strcpy (visible_line, lprompt);
",1,unused,1911,unused,"
  /* Make sure the line structures hold the already-displayed prompt for
     redisplay. */
  lprompt = local_prompt ? local_prompt : rl_prompt;
  strcpy (visible_line, lprompt);
",unused,bashxenial-lib2Freadline2Fdisplay.c
"  /* Make sure the line structures hold the already-displayed prompt for
     redisplay. */
  lprompt = local_prompt ? local_prompt : rl_prompt;
  strcpy (visible_line, lprompt);
  strcpy (invisible_line, lprompt);
",1,unused,1912,unused,"  /* Make sure the line structures hold the already-displayed prompt for
     redisplay. */
  lprompt = local_prompt ? local_prompt : rl_prompt;
  strcpy (visible_line, lprompt);
  strcpy (invisible_line, lprompt);
",unused,bashxenial-lib2Freadline2Fdisplay.c
"    {
      len = (rl_prompt && *rl_prompt) ? strlen (rl_prompt) : 0;
      pmt = (char *)xmalloc (len + 2);
      if (len)
	strcpy (pmt, rl_prompt);
",1,unused,2404,unused,"    {
      len = (rl_prompt && *rl_prompt) ? strlen (rl_prompt) : 0;
      pmt = (char *)xmalloc (len + 2);
      if (len)
	strcpy (pmt, rl_prompt);
",unused,bashxenial-lib2Freadline2Fdisplay.c
"      p++;
      len = strlen (p);
      pmt = (char *)xmalloc (len + 2);
      if (len)
	strcpy (pmt, p);
",1,unused,2414,unused,"      p++;
      len = strlen (p);
      pmt = (char *)xmalloc (len + 2);
      if (len)
	strcpy (pmt, p);
",unused,bashxenial-lib2Freadline2Fdisplay.c
"  temp = (char *)xmalloc (ll + elen + 3);
  strncpy (temp, s + start, ll);
  temp[ll] = ':';
  temp[ll + 1] = ' ';
  strcpy (temp + ll + 2, emsg);
",1,unused,413,unused,"  temp = (char *)xmalloc (ll + elen + 3);
  strncpy (temp, s + start, ll);
  temp[ll] = ':';
  temp[ll + 1] = ' ';
  strcpy (temp + ll + 2, emsg);
",unused,bashxenial-lib2Freadline2Fhistexpand.c
"      if (subst_rhs[i] == '&')
	{
	  if (j + subst_lhs_len >= new_size)
	    new = (char *)xrealloc (new, (new_size = new_size * 2 + subst_lhs_len));
	  strcpy (new + j, subst_lhs);
",1,unused,499,unused,"      if (subst_rhs[i] == '&')
	{
	  if (j + subst_lhs_len >= new_size)
	    new = (char *)xrealloc (new, (new_size = new_size * 2 + subst_lhs_len));
	  strcpy (new + j, subst_lhs);
",unused,bashxenial-lib2Freadline2Fhistexpand.c
"
  n = strlen (temp);
  if (n >= result_len)
    result = (char *)xrealloc (result, n + 2);
  strcpy (result, temp);
",1,unused,858,unused,"
  n = strlen (temp);
  if (n >= result_len)
    result = (char *)xrealloc (result, n + 2);
  strcpy (result, temp);
",unused,bashxenial-lib2Freadline2Fhistexpand.c
"
      string[0] = string[1] = history_expansion_char;
      string[2] = ':';
      string[3] = 's';
      strcpy (string + 4, hstring);
",1,unused,959,unused,"
      string[0] = string[1] = history_expansion_char;
      string[2] = ':';
      string[3] = 's';
      strcpy (string + 4, hstring);
",unused,bashxenial-lib2Freadline2Fhistexpand.c
"	case -2:		/* history_comment_char */
	  if (i == 0 || member (string[i - 1], history_word_delimiters))
	    {
	      temp = (char *)xmalloc (l - i + 1);
	      strcpy (temp, string + i);
",1,unused,1155,unused,"	case -2:		/* history_comment_char */
	  if (i == 0 || member (string[i - 1], history_word_delimiters))
	    {
	      temp = (char *)xmalloc (l - i + 1);
	      strcpy (temp, string + i);
",unused,bashxenial-lib2Freadline2Fhistexpand.c
"      result[0] = '\0';

      for (i = first, offset = 0; i < last; i++)
	{
	  strcpy (result + offset, list[i]);
",1,unused,1395,unused,"      result[0] = '\0';

      for (i = first, offset = 0; i < last; i++)
	{
	  strcpy (result + offset, list[i]);
",unused,bashxenial-lib2Freadline2Fhistexpand.c
"  else
    home_len = strlen (home);

  return_val = (char *)xmalloc (2 + home_len + 8); /* strlen("".history"") == 8 */
  strcpy (return_val, home);
",1,unused,133,unused,"  else
    home_len = strlen (home);

  return_val = (char *)xmalloc (2 + home_len + 8); /* strlen("".history"") == 8 */
  strcpy (return_val, home);
",unused,bashxenial-lib2Freadline2Fhistfile.c
"  return_val[home_len] = '/';
#if defined (__MSDOS__)
  strcpy (return_val + home_len + 1, ""_history"");
#else
  strcpy (return_val + home_len + 1, "".history"");
",1,unused,138,unused,"  return_val[home_len] = '/';
#if defined (__MSDOS__)
  strcpy (return_val + home_len + 1, ""_history"");
#else
  strcpy (return_val + home_len + 1, "".history"");
",unused,bashxenial-lib2Freadline2Fhistfile.c
"  size_t len;

  len = strlen (filename);
  ret = xmalloc (len + 2);
  strcpy (ret, filename);
",1,unused,153,unused,"  size_t len;

  len = strlen (filename);
  ret = xmalloc (len + 2);
  strcpy (ret, filename);
",unused,bashxenial-lib2Freadline2Fhistfile.c
"    for (j = 0, i = history_length - nelements; i < history_length; i++)
      {
	if (history_write_timestamps && the_history[i]->timestamp && the_history[i]->timestamp[0])
	  {
	    strcpy (buffer + j, the_history[i]->timestamp);
",1,unused,533,unused,"    for (j = 0, i = history_length - nelements; i < history_length; i++)
      {
	if (history_write_timestamps && the_history[i]->timestamp && the_history[i]->timestamp[0])
	  {
	    strcpy (buffer + j, the_history[i]->timestamp);
",unused,bashxenial-lib2Freadline2Fhistfile.c
"	    strcpy (buffer + j, the_history[i]->timestamp);
	    j += strlen (the_history[i]->timestamp);
	    buffer[j++] = '\n';
	  }
	strcpy (buffer + j, the_history[i]->line);
",1,unused,537,unused,"	    strcpy (buffer + j, the_history[i]->timestamp);
	    j += strlen (the_history[i]->timestamp);
	    buffer[j++] = '\n';
	  }
	strcpy (buffer + j, the_history[i]->line);
",unused,bashxenial-lib2Freadline2Fhistfile.c
"  message[msglen++] = '(';

  if (flags & SF_FAILED)
    {
      strcpy (message + msglen, ""failed "");
",1,unused,183,unused,"  message[msglen++] = '(';

  if (flags & SF_FAILED)
    {
      strcpy (message + msglen, ""failed "");
",unused,bashxenial-lib2Freadline2Fisearch.c
"    }

  if (flags & SF_REVERSE)
    {
      strcpy (message + msglen, ""reverse-"");
",1,unused,189,unused,"    }

  if (flags & SF_REVERSE)
    {
      strcpy (message + msglen, ""reverse-"");
",unused,bashxenial-lib2Freadline2Fisearch.c
"      strcpy (message + msglen, ""reverse-"");
      msglen += 8;
    }

  strcpy (message + msglen, ""i-search)`"");
",1,unused,193,unused,"      strcpy (message + msglen, ""reverse-"");
      msglen += 8;
    }

  strcpy (message + msglen, ""i-search)`"");
",unused,bashxenial-lib2Freadline2Fisearch.c
"  msglen += 10;

  if (search_string)
    {
      strcpy (message + msglen, search_string);
",1,unused,198,unused,"  msglen += 10;

  if (search_string)
    {
      strcpy (message + msglen, search_string);
",unused,bashxenial-lib2Freadline2Fisearch.c
"      strcpy (message + msglen, search_string);
      msglen += searchlen;
    }

  strcpy (message + msglen, ""': "");
",1,unused,202,unused,"      strcpy (message + msglen, search_string);
      msglen += searchlen;
    }

  strcpy (message + msglen, ""': "");
",unused,bashxenial-lib2Freadline2Fisearch.c
"  else
    {
      /* Keep track of this so we can free it. */
      cxt->allocated_line = (char *)xmalloc (1 + strlen (rl_line_buffer));
      strcpy (cxt->allocated_line, &rl_line_buffer[0]);
",1,unused,243,unused,"  else
    {
      /* Keep track of this so we can free it. */
      cxt->allocated_line = (char *)xmalloc (1 + strlen (rl_line_buffer));
      strcpy (cxt->allocated_line, &rl_line_buffer[0]);
",unused,bashxenial-lib2Freadline2Fisearch.c
"_rl_isearch_fini (cxt)
     _rl_search_cxt *cxt;
{
  /* First put back the original state. */
  strcpy (rl_line_buffer, cxt->lines[cxt->save_line]);
",1,unused,275,unused,"_rl_isearch_fini (cxt)
     _rl_search_cxt *cxt;
{
  /* First put back the original state. */
  strcpy (rl_line_buffer, cxt->lines[cxt->save_line]);
",unused,bashxenial-lib2Freadline2Fisearch.c
"	  if (last_isearch_string)
	    {
	      cxt->search_string_size = 64 + last_isearch_string_len;
	      cxt->search_string = (char *)xrealloc (cxt->search_string, cxt->search_string_size);
	      strcpy (cxt->search_string, last_isearch_string);
",1,unused,524,unused,"	  if (last_isearch_string)
	    {
	      cxt->search_string_size = 64 + last_isearch_string_len;
	      cxt->search_string = (char *)xrealloc (cxt->search_string, cxt->search_string_size);
	      strcpy (cxt->search_string, last_isearch_string);
",unused,bashxenial-lib2Freadline2Fisearch.c
"      new = (char *)xmalloc (1 + strlen (old) + strlen (text));

      if (append)
	{
	  strcpy (new, old);
",1,unused,141,unused,"      new = (char *)xmalloc (1 + strlen (old) + strlen (text));

      if (append)
	{
	  strcpy (new, old);
",unused,bashxenial-lib2Freadline2Fkill.c
"
      if (append)
	{
	  strcpy (new, old);
	  strcat (new, text);
",1,unused,142,unused,"
      if (append)
	{
	  strcpy (new, old);
	  strcat (new, text);
",unused,bashxenial-lib2Freadline2Fkill.c
"	  strcat (new, text);
	}
      else
	{
	  strcpy (new, text);
",1,unused,146,unused,"	  strcat (new, text);
	}
      else
	{
	  strcpy (new, text);
",unused,bashxenial-lib2Freadline2Fkill.c
"	}
      else
	{
	  strcpy (new, text);
	  strcat (new, old);
",1,unused,147,unused,"	}
      else
	{
	  strcpy (new, text);
	  strcat (new, old);
",unused,bashxenial-lib2Freadline2Fkill.c
"      return;
    }

  ext = NULL;
  strcpy (label, ""??"");
",1,unused,318,unused,"      return;
    }

  ext = NULL;
  strcpy (label, ""??"");
",unused,bashxenial-lib2Freadline2Fparse-colors.c
"      rl_revert_line (1, 0);
      entry = replace_history_entry (where_history (), the_line, (histdata_t)NULL);
      _rl_free_history_entry (entry);

      strcpy (the_line, temp);
",1,unused,465,unused,"      rl_revert_line (1, 0);
      entry = replace_history_entry (where_history (), the_line, (histdata_t)NULL);
      _rl_free_history_entry (entry);

      strcpy (the_line, temp);
",unused,bashxenial-lib2Freadline2Freadline.c
"{
  char *ret;

  ret = (char *)xmalloc (strlen (s) + 1);
  strcpy (ret, s);
",1,unused,39,unused,"{
  char *ret;

  ret = (char *)xmalloc (strlen (s) + 1);
  strcpy (ret, s);
",unused,bashxenial-lib2Freadline2Fsavestring.c
"sh_set_lines_and_columns (lines, cols)
     int lines, cols;
{
#if defined (HAVE_SETENV)
  sprintf (setenv_buf, ""%d"", lines);
",1,unused,134,unused,"sh_set_lines_and_columns (lines, cols)
     int lines, cols;
{
#if defined (HAVE_SETENV)
  sprintf (setenv_buf, ""%d"", lines);
",unused,bashxenial-lib2Freadline2Fshell.c
"#if defined (HAVE_SETENV)
  sprintf (setenv_buf, ""%d"", lines);
  setenv (""LINES"", setenv_buf, 1);

  sprintf (setenv_buf, ""%d"", cols);
",1,unused,137,unused,"#if defined (HAVE_SETENV)
  sprintf (setenv_buf, ""%d"", lines);
  setenv (""LINES"", setenv_buf, 1);

  sprintf (setenv_buf, ""%d"", cols);
",unused,bashxenial-lib2Freadline2Fshell.c
"
  len = strlen (text);
  if (len >= rl_line_buffer_len)
    rl_extend_line_buffer (len);
  strcpy (rl_line_buffer, text);
",1,unused,216,unused,"
  len = strlen (text);
  if (len >= rl_line_buffer_len)
    rl_extend_line_buffer (len);
  strcpy (rl_line_buffer, text);
",unused,bashxenial-lib2Freadline2Ftext.c
"	{
	  if ((result_index + len + 1) > result_size)
	    result = (char *)xrealloc (result, 1 + (result_size += (len + 20)));

	  strcpy (result + result_index, expansion);
",1,unused,251,unused,"	{
	  if ((result_index + len + 1) > result_size)
	    result = (char *)xrealloc (result, 1 + (result_size += (len + 20)));

	  strcpy (result + result_index, expansion);
",unused,bashxenial-lib2Freadline2Ftilde.c
"  plen = (prefix && *prefix) ? strlen (prefix) : 0;
  slen = strlen (suffix + suffind);
  ret = (char *)xmalloc (plen + slen + 1);
  if (plen)
    strcpy (ret, prefix);
",1,unused,334,unused,"  plen = (prefix && *prefix) ? strlen (prefix) : 0;
  slen = strlen (suffix + suffind);
  ret = (char *)xmalloc (plen + slen + 1);
  if (plen)
    strcpy (ret, prefix);
",unused,bashxenial-lib2Freadline2Ftilde.c
"  slen = strlen (suffix + suffind);
  ret = (char *)xmalloc (plen + slen + 1);
  if (plen)
    strcpy (ret, prefix);
  strcpy (ret + plen, suffix + suffind);
",1,unused,335,unused,"  slen = strlen (suffix + suffind);
  ret = (char *)xmalloc (plen + slen + 1);
  if (plen)
    strcpy (ret, prefix);
  strcpy (ret + plen, suffix + suffind);
",unused,bashxenial-lib2Freadline2Ftilde.c
"  start = 0;
  end = strlen (string);

  ret = (char *)xmalloc (end + 1);
  strcpy (ret, string);
",1,unused,135,unused,"  start = 0;
  end = strlen (string);

  ret = (char *)xmalloc (end + 1);
  strcpy (ret, string);
",unused,bashxenial-lib2Fsh2Fcasemod.c
"     trailing slash.  Make sure /dev/fd/xx really uses DEV_FD_PREFIX/xx.
     On most systems, with the notable exception of linux, this is
     effectively a no-op. */
      pbuf = xrealloc (pbuf, sizeof (DEV_FD_PREFIX) + strlen (path + 8));
      strcpy (pbuf, DEV_FD_PREFIX);
",1,unused,112,unused,"     trailing slash.  Make sure /dev/fd/xx really uses DEV_FD_PREFIX/xx.
     On most systems, with the notable exception of linux, this is
     effectively a no-op. */
      pbuf = xrealloc (pbuf, sizeof (DEV_FD_PREFIX) + strlen (path + 8));
      strcpy (pbuf, DEV_FD_PREFIX);
",unused,bashxenial-lib2Fsh2Feaccess.c
"     On most systems, with the notable exception of linux, this is
     effectively a no-op. */
      pbuf = xrealloc (pbuf, sizeof (DEV_FD_PREFIX) + strlen (path + 8));
      strcpy (pbuf, DEV_FD_PREFIX);
      strcat (pbuf, path + 8);
",1,unused,113,unused,"     On most systems, with the notable exception of linux, this is
     effectively a no-op. */
      pbuf = xrealloc (pbuf, sizeof (DEV_FD_PREFIX) + strlen (path + 8));
      strcpy (pbuf, DEV_FD_PREFIX);
      strcat (pbuf, path + 8);
",unused,bashxenial-lib2Fsh2Feaccess.c
"  st_ret.st_mode  &= ~S_IFDIR;
  st_ret.st_mode  |= S_IFREG;

  /* See if cur/ is present */
  sprintf(dir, ""%s/cur"", path);
",1,unused,95,unused,"  st_ret.st_mode  &= ~S_IFDIR;
  st_ret.st_mode  |= S_IFREG;

  /* See if cur/ is present */
  sprintf(dir, ""%s/cur"", path);
",unused,bashxenial-lib2Fsh2Fmailstat.c
"    return 0;
  st_ret.st_atime = st_tmp.st_atime;

  /* See if tmp/ is present */
  sprintf(dir, ""%s/tmp"", path);
",1,unused,101,unused,"    return 0;
  st_ret.st_atime = st_tmp.st_atime;

  /* See if tmp/ is present */
  sprintf(dir, ""%s/tmp"", path);
",unused,bashxenial-lib2Fsh2Fmailstat.c
"    return 0;
  st_ret.st_mtime = st_tmp.st_mtime;

  /* And new/ */
  sprintf(dir, ""%s/new"", path);
",1,unused,107,unused,"    return 0;
  st_ret.st_mtime = st_tmp.st_mtime;

  /* And new/ */
  sprintf(dir, ""%s/new"", path);
",unused,bashxenial-lib2Fsh2Fmailstat.c
"
  /* Loop over new/ and cur/ */
  for (i = 0; i < 2; i++)
    {
      sprintf(dir, ""%s/%s"", path, i ? ""cur"" : ""new"");
",1,unused,126,unused,"
  /* Loop over new/ and cur/ */
  for (i = 0; i < 2; i++)
    {
      sprintf(dir, ""%s/%s"", path, i ? ""cur"" : ""new"");
",unused,bashxenial-lib2Fsh2Fmailstat.c
"  /* Loop over new/ and cur/ */
  for (i = 0; i < 2; i++)
    {
      sprintf(dir, ""%s/%s"", path, i ? ""cur"" : ""new"");
      sprintf(file, ""%s/"", dir);
",1,unused,127,unused,"  /* Loop over new/ and cur/ */
  for (i = 0; i < 2; i++)
    {
      sprintf(dir, ""%s/%s"", path, i ? ""cur"" : ""new"");
      sprintf(file, ""%s/"", dir);
",unused,bashxenial-lib2Fsh2Fmailstat.c
"      while ((fn = readdir(dd)) != NULL)
	{
	  if (fn->d_name[0] == '.' || strlen(fn->d_name) + l >= sizeof(file))
	    continue;
	  strcpy(file + l, fn->d_name);
",1,unused,135,unused,"      while ((fn = readdir(dd)) != NULL)
	{
	  if (fn->d_name[0] == '.' || strlen(fn->d_name) + l >= sizeof(file))
	    continue;
	  strcpy(file + l, fn->d_name);
",unused,bashxenial-lib2Fsh2Fmailstat.c
"  char *np, *s, *t;
  int fd;

  np = (char *)xmalloc (strlen (path) + 1);
  strcpy (np, path);
",1,unused,300,unused,"  char *np, *s, *t;
  int fd;

  np = (char *)xmalloc (strlen (path) + 1);
  strcpy (np, path);
",unused,bashxenial-lib2Fsh2Fnetopen.c
"    workpath = savestring (path);
  else
    {
      workpath = (char *)xmalloc (PATH_MAX + 1);
      strcpy (workpath, path);
",1,unused,101,unused,"    workpath = savestring (path);
  else
    {
      workpath = (char *)xmalloc (PATH_MAX + 1);
      strcpy (workpath, path);
",unused,bashxenial-lib2Fsh2Fpathphys.c
"	     buffer and appending the rest of `workpath'.  Reset p to point
	     to the start of the rest of the path.  If the link value is an
	     absolute pathname, reset p, q, and qbase.  If not, reset p
	     and q. */
	  strcpy (tbuf, linkbuf);
",1,unused,208,unused,"	     buffer and appending the rest of `workpath'.  Reset p to point
	     to the start of the rest of the path.  If the link value is an
	     absolute pathname, reset p, q, and qbase.  If not, reset p
	     and q. */
	  strcpy (tbuf, linkbuf);
",unused,bashxenial-lib2Fsh2Fpathphys.c
"	     absolute pathname, reset p, q, and qbase.  If not, reset p
	     and q. */
	  strcpy (tbuf, linkbuf);
	  tbuf[linklen] = '/';
	  strcpy (tbuf + linklen, p);
",1,unused,210,unused,"	     absolute pathname, reset p, q, and qbase.  If not, reset p
	     and q. */
	  strcpy (tbuf, linkbuf);
	  tbuf[linklen] = '/';
	  strcpy (tbuf + linklen, p);
",unused,bashxenial-lib2Fsh2Fpathphys.c
"	     and q. */
	  strcpy (tbuf, linkbuf);
	  tbuf[linklen] = '/';
	  strcpy (tbuf + linklen, p);
	  strcpy (workpath, tbuf);
",1,unused,211,unused,"	     and q. */
	  strcpy (tbuf, linkbuf);
	  tbuf[linklen] = '/';
	  strcpy (tbuf + linklen, p);
	  strcpy (workpath, tbuf);
",unused,bashxenial-lib2Fsh2Fpathphys.c
"    {
      if (result[2] == '\0')	/* short-circuit for bare `//' */
	result[1] = '\0';
      else
	strcpy (result, result + 1);
",1,unused,248,unused,"    {
      if (result[2] == '\0')	/* short-circuit for bare `//' */
	result[1] = '\0';
      else
	strcpy (result, result + 1);
",unused,bashxenial-lib2Fsh2Fpathphys.c
"      llen = STRLEN (sl->list[i]);
      tlen = plen + llen + slen + 1;
      t = (char *)xmalloc (tlen + 1);
      if (plen)
	strcpy (t, prefix);
",1,unused,214,unused,"      llen = STRLEN (sl->list[i]);
      tlen = plen + llen + slen + 1;
      t = (char *)xmalloc (tlen + 1);
      if (plen)
	strcpy (t, prefix);
",unused,bashxenial-lib2Fsh2Fstringlist.c
"      tlen = plen + llen + slen + 1;
      t = (char *)xmalloc (tlen + 1);
      if (plen)
	strcpy (t, prefix);
      strcpy (t + plen, sl->list[i]);
",1,unused,215,unused,"      tlen = plen + llen + slen + 1;
      t = (char *)xmalloc (tlen + 1);
      if (plen)
	strcpy (t, prefix);
      strcpy (t + plen, sl->list[i]);
",unused,bashxenial-lib2Fsh2Fstringlist.c
"      if (plen)
	strcpy (t, prefix);
      strcpy (t + plen, sl->list[i]);
      if (slen)
	strcpy (t + plen + llen, suffix);
",1,unused,217,unused,"      if (plen)
	strcpy (t, prefix);
      strcpy (t + plen, sl->list[i]);
      if (slen)
	strcpy (t + plen + llen, suffix);
",unused,bashxenial-lib2Fsh2Fstringlist.c
"      filenum = (filenum << 1) ^
		(unsigned long) time ((time_t *)0) ^
		(unsigned long) dollar_dollar_pid ^
		(unsigned long) ((flags & MT_USERANDOM) ? random () : ntmpfiles++);
      sprintf (filename, ""%s/%s-%lu"", tdir, lroot, filenum);
",1,unused,141,unused,"      filenum = (filenum << 1) ^
		(unsigned long) time ((time_t *)0) ^
		(unsigned long) dollar_dollar_pid ^
		(unsigned long) ((flags & MT_USERANDOM) ? random () : ntmpfiles++);
      sprintf (filename, ""%s/%s-%lu"", tdir, lroot, filenum);
",unused,bashxenial-lib2Fsh2Ftmpfile.c
"      filenum = (filenum << 1) ^
		(unsigned long) time ((time_t *)0) ^
		(unsigned long) dollar_dollar_pid ^
		(unsigned long) ((flags & MT_USERANDOM) ? random () : ntmpfiles++);
      sprintf (filename, ""%s/%s-%lu"", tdir, lroot, filenum);
",1,unused,190,unused,"      filenum = (filenum << 1) ^
		(unsigned long) time ((time_t *)0) ^
		(unsigned long) dollar_dollar_pid ^
		(unsigned long) ((flags & MT_USERANDOM) ? random () : ntmpfiles++);
      sprintf (filename, ""%s/%s-%lu"", tdir, lroot, filenum);
",unused,bashxenial-lib2Fsh2Ftmpfile.c
"	{
	  if ((result_index + len + 1) > result_size)
	    result = (char *)xrealloc (result, 1 + (result_size += (len + 20)));

	  strcpy (result + result_index, expansion);
",1,unused,251,unused,"	{
	  if ((result_index + len + 1) > result_size)
	    result = (char *)xrealloc (result, 1 + (result_size += (len + 20)));

	  strcpy (result + result_index, expansion);
",unused,bashxenial-lib2Ftilde2Ftilde.c
"  plen = (prefix && *prefix) ? strlen (prefix) : 0;
  slen = strlen (suffix + suffind);
  ret = (char *)xmalloc (plen + slen + 1);
  if (plen)
    strcpy (ret, prefix);
",1,unused,334,unused,"  plen = (prefix && *prefix) ? strlen (prefix) : 0;
  slen = strlen (suffix + suffind);
  ret = (char *)xmalloc (plen + slen + 1);
  if (plen)
    strcpy (ret, prefix);
",unused,bashxenial-lib2Ftilde2Ftilde.c
"  slen = strlen (suffix + suffind);
  ret = (char *)xmalloc (plen + slen + 1);
  if (plen)
    strcpy (ret, prefix);
  strcpy (ret + plen, suffix + suffind);
",1,unused,335,unused,"  slen = strlen (suffix + suffind);
  ret = (char *)xmalloc (plen + slen + 1);
  if (plen)
    strcpy (ret, prefix);
  strcpy (ret + plen, suffix + suffind);
",unused,bashxenial-lib2Ftilde2Ftilde.c
"  if (locale == 0 || locale[0] == '\0' ||
      (locale[0] == 'C' && locale[1] == '\0') || STREQ (locale, ""POSIX""))
    {
      t = (char *)xmalloc (len + 1);
      strcpy (t, string);
",1,unused,391,unused,"  if (locale == 0 || locale[0] == '\0' ||
      (locale[0] == 'C' && locale[1] == '\0') || STREQ (locale, ""POSIX""))
    {
      t = (char *)xmalloc (len + 1);
      strcpy (t, string);
",unused,bashxenial-locale.c
"
  if (translated == string)	/* gettext returns its argument if untranslatable */
    {
      t = (char *)xmalloc (len + 1);
      strcpy (t, string);
",1,unused,406,unused,"
  if (translated == string)	/* gettext returns its argument if untranslatable */
    {
      t = (char *)xmalloc (len + 1);
      strcpy (t, string);
",unused,bashxenial-locale.c
"  else
    {
      tlen = strlen (translated);
      t = (char *)xmalloc (tlen + 1);
      strcpy (t, translated);
",1,unused,414,unused,"  else
    {
      tlen = strlen (translated);
      t = (char *)xmalloc (tlen + 1);
      strcpy (t, translated);
",unused,bashxenial-locale.c
"    case '\f': xbuf[1] = 'f'; break;
    case '\n': xbuf[1] = 'n'; break;
    case '\r': xbuf[1] = 'r'; break;
    case '\t': xbuf[1] = 't'; break;
    default: sprintf (xbuf, ""%d"", i); break;
",1,unused,145,unused,"    case '\f': xbuf[1] = 'f'; break;
    case '\n': xbuf[1] = 'n'; break;
    case '\r': xbuf[1] = 'r'; break;
    case '\t': xbuf[1] = 't'; break;
    default: sprintf (xbuf, ""%d"", i); break;
",unused,bashxenial-mksyntax.c
"
  /* allocate the string for the command and fill it in. */
  cscmd = (char *)xmalloc (cmdsize + 1);

  strcpy (cscmd, cs->command);			/* $0 */
",1,unused,1198,unused,"
  /* allocate the string for the command and fill it in. */
  cscmd = (char *)xmalloc (cmdsize + 1);

  strcpy (cscmd, cs->command);			/* $0 */
",unused,bashxenial-pcomplete.c
"    {
      t = sh_single_quote (cl->word->word ? cl->word->word : """");
      n = strlen (t);
      RESIZE_MALLOCED_BUFFER (cscmd, cmdlen, n + 2, cmdsize, 64);
      strcpy (cscmd + cmdlen, t);
",1,unused,1206,unused,"    {
      t = sh_single_quote (cl->word->word ? cl->word->word : """");
      n = strlen (t);
      RESIZE_MALLOCED_BUFFER (cscmd, cmdlen, n + 2, cmdsize, 64);
      strcpy (cscmd + cmdlen, t);
",unused,bashxenial-pcomplete.c
"		 a redirection. */
	      digit_arg = va_arg (args, int);
	      if (digit_arg < 0)
		{
		  sprintf (intbuf, ""%u"", (unsigned)-1);
",1,unused,1503,unused,"		 a redirection. */
	      digit_arg = va_arg (args, int);
	      if (digit_arg < 0)
		{
		  sprintf (intbuf, ""%u"", (unsigned)-1);
",unused,bashxenial-print_cmd.c
"
	  alloca_hack = (char *)
	    alloca (1 + strlen (new_redirect->redirectee.filename->word));
	  redirectee->word = alloca_hack;
	  strcpy (redirectee->word, new_redirect->redirectee.filename->word);
",1,unused,800,unused,"
	  alloca_hack = (char *)
	    alloca (1 + strlen (new_redirect->redirectee.filename->word));
	  redirectee->word = alloca_hack;
	  strcpy (redirectee->word, new_redirect->redirectee.filename->word);
",unused,bashxenial-redir.c
"		  t = quote_globbing_chars (text);
		  tlen = strlen (t);
		  RESIZE_MALLOCED_BUFFER (ret, ind, tlen, rlen, rlen);
		  r = ret + ind;	/* in case reallocated */
		  strcpy (r, t);
",1,unused,210,unused,"		  t = quote_globbing_chars (text);
		  tlen = strlen (t);
		  RESIZE_MALLOCED_BUFFER (ret, ind, tlen, rlen, rlen);
		  r = ret + ind;	/* in case reallocated */
		  strcpy (r, t);
",unused,bashxenial-stringlib.c
"	      else
		{
		  RESIZE_MALLOCED_BUFFER (ret, ind, len, rlen, rlen);
		  r = ret + ind;	/* in case reallocated */
		  strcpy (r, text);
",1,unused,218,unused,"	      else
		{
		  RESIZE_MALLOCED_BUFFER (ret, ind, len, rlen, rlen);
		  r = ret + ind;	/* in case reallocated */
		  strcpy (r, text);
",unused,bashxenial-stringlib.c
"
  t = result = (char *)xmalloc (slen + 1);

  if (strchr (string, CTLESC) == 0)
    return (strcpy (result, string));
",1,unused,3602,unused,"
  t = result = (char *)xmalloc (slen + 1);

  if (strchr (string, CTLESC) == 0)
    return (strcpy (result, string));
",unused,bashxenial-subst.c
"
  /* If no character in the string can be quoted, don't bother examining
     each character.  Just return a copy of the string passed to us. */
  if (strchr (string, CTLESC) == NULL)
    return (strcpy (result, string));
",1,unused,3721,unused,"
  /* If no character in the string can be quoted, don't bother examining
     each character.  Just return a copy of the string passed to us. */
  if (strchr (string, CTLESC) == NULL)
    return (strcpy (result, string));
",unused,bashxenial-subst.c
"
  if (string)
    {
      t = dequote_escapes (string);
      strcpy (string, t);
",1,unused,3790,unused,"
  if (string)
    {
      t = dequote_escapes (string);
      strcpy (string, t);
",unused,bashxenial-subst.c
"  char *ret, intbuf[INT_STRLEN_BOUND (int) + 1], *p;

  ret = (char *)xmalloc (sizeof (DEV_FD_PREFIX) + 8);

  strcpy (ret, DEV_FD_PREFIX);
",1,unused,5019,unused,"  char *ret, intbuf[INT_STRLEN_BOUND (int) + 1], *p;

  ret = (char *)xmalloc (sizeof (DEV_FD_PREFIX) + 8);

  strcpy (ret, DEV_FD_PREFIX);
",unused,bashxenial-subst.c
"  ret = (char *)xmalloc (sizeof (DEV_FD_PREFIX) + 8);

  strcpy (ret, DEV_FD_PREFIX);
  p = inttostr (fd, intbuf, sizeof (intbuf));
  strcpy (ret + sizeof (DEV_FD_PREFIX) - 1, p);
",1,unused,5021,unused,"  ret = (char *)xmalloc (sizeof (DEV_FD_PREFIX) + 8);

  strcpy (ret, DEV_FD_PREFIX);
  p = inttostr (fd, intbuf, sizeof (intbuf));
  strcpy (ret + sizeof (DEV_FD_PREFIX) - 1, p);
",unused,bashxenial-subst.c
"    {
      int sindex;
      tt = (char *)xmalloc (2 + strlen (name));
      tt[sindex = 0] = '$';
      strcpy (tt + 1, name);
",1,unused,5764,unused,"    {
      int sindex;
      tt = (char *)xmalloc (2 + strlen (name));
      tt[sindex = 0] = '$';
      strcpy (tt + 1, name);
",unused,bashxenial-subst.c
"      replen = STRLEN (rep);
      l = STRLEN (string);
      ret = (char *)xmalloc (replen + l + 2);
      if (replen == 0)
	strcpy (ret, string);
",1,unused,6645,unused,"      replen = STRLEN (rep);
      l = STRLEN (string);
      ret = (char *)xmalloc (replen + l + 2);
      if (replen == 0)
	strcpy (ret, string);
",unused,bashxenial-subst.c
"      if (replen == 0)
	strcpy (ret, string);
      else if (mtype == MATCH_BEG)
	{
	  strcpy (ret, rep);
",1,unused,6648,unused,"      if (replen == 0)
	strcpy (ret, string);
      else if (mtype == MATCH_BEG)
	{
	  strcpy (ret, rep);
",unused,bashxenial-subst.c
"	strcpy (ret, string);
      else if (mtype == MATCH_BEG)
	{
	  strcpy (ret, rep);
	  strcpy (ret + replen, string);
",1,unused,6649,unused,"	strcpy (ret, string);
      else if (mtype == MATCH_BEG)
	{
	  strcpy (ret, rep);
	  strcpy (ret + replen, string);
",unused,bashxenial-subst.c
"	  strcpy (ret + replen, string);
	}
      else
	{
	  strcpy (ret, string);
",1,unused,6653,unused,"	  strcpy (ret + replen, string);
	}
      else
	{
	  strcpy (ret, string);
",unused,bashxenial-subst.c
"	}
      else
	{
	  strcpy (ret, string);
	  strcpy (ret + l, rep);
",1,unused,6654,unused,"	}
      else
	{
	  strcpy (ret, string);
	  strcpy (ret + l, rep);
",unused,bashxenial-subst.c
"  /* Now copy the unmatched portion of the input string */
  if (str && *str)
    {
      RESIZE_MALLOCED_BUFFER (ret, rptr, STRLEN(str) + 1, rsize, 64);
      strcpy (ret + rptr, str);
",1,unused,6723,unused,"  /* Now copy the unmatched portion of the input string */
  if (str && *str)
    {
      RESIZE_MALLOCED_BUFFER (ret, rptr, STRLEN(str) + 1, rsize, 64);
      strcpy (ret + rptr, str);
",unused,bashxenial-subst.c
"      if (string[sindex] == '!')
	{
	  /* indirect reference of $#, $?, $@, or $* */
	  name[1] = string[sindex + 1];
	  strcpy (name + 2, temp1);
",1,unused,7170,unused,"      if (string[sindex] == '!')
	{
	  /* indirect reference of $#, $?, $@, or $* */
	  name[1] = string[sindex + 1];
	  strcpy (name + 2, temp1);
",unused,bashxenial-subst.c
"	  name[1] = string[sindex + 1];
	  strcpy (name + 2, temp1);
	}
      else	
	strcpy (name + 1, temp1);
",1,unused,7173,unused,"	  name[1] = string[sindex + 1];
	  strcpy (name + 2, temp1);
	}
      else	
	strcpy (name + 1, temp1);
",unused,bashxenial-subst.c
"	  tindex = sindex + 1;
	  temp = string_extract_single_quoted (string, &tindex);
	  if (temp)
	    {
	      strcpy (r, temp);
",1,unused,8915,unused,"	  tindex = sindex + 1;
	  temp = string_extract_single_quoted (string, &tindex);
	  if (temp)
	    {
	      strcpy (r, temp);
",unused,bashxenial-subst.c
"    oflags = SFLAG;

  if (oflags & (RFLAG|VFLAG))
    {
      strcpy (dv, dist_version);
",1,unused,125,unused,"    oflags = SFLAG;

  if (oflags & (RFLAG|VFLAG))
    {
      strcpy (dv, dist_version);
",unused,bashxenial-support2Fbashversion.c
"      for (i = 1; i <= rtcnt; i++)
	{
	  signal_names[rtmin+i] = (char *)malloc(RTLEN);
	  if (signal_names[rtmin+i])
	    sprintf (signal_names[rtmin+i], ""SIGRTMIN+%d"", i);
",1,unused,125,unused,"      for (i = 1; i <= rtcnt; i++)
	{
	  signal_names[rtmin+i] = (char *)malloc(RTLEN);
	  if (signal_names[rtmin+i])
	    sprintf (signal_names[rtmin+i], ""SIGRTMIN+%d"", i);
",unused,bashxenial-support2Fsignames.c
"	  if (signal_names[rtmin+i])
	    sprintf (signal_names[rtmin+i], ""SIGRTMIN+%d"", i);
	  signal_names[rtmax-i] = (char *)malloc(RTLEN);
	  if (signal_names[rtmax-i])
	    sprintf (signal_names[rtmax-i], ""SIGRTMAX-%d"", i);
",1,unused,128,unused,"	  if (signal_names[rtmin+i])
	    sprintf (signal_names[rtmin+i], ""SIGRTMIN+%d"", i);
	  signal_names[rtmax-i] = (char *)malloc(RTLEN);
	  if (signal_names[rtmax-i])
	    sprintf (signal_names[rtmax-i], ""SIGRTMAX-%d"", i);
",unused,bashxenial-support2Fsignames.c
"	{
	  /* Need an extra RTMIN signal */
	  signal_names[rtmin+rtcnt+1] = (char *)malloc(RTLEN);
	  if (signal_names[rtmin+rtcnt+1])
	    sprintf (signal_names[rtmin+rtcnt+1], ""SIGRTMIN+%d"", rtcnt+1);
",1,unused,136,unused,"	{
	  /* Need an extra RTMIN signal */
	  signal_names[rtmin+rtcnt+1] = (char *)malloc(RTLEN);
	  if (signal_names[rtmin+rtcnt+1])
	    sprintf (signal_names[rtmin+rtcnt+1], ""SIGRTMIN+%d"", rtcnt+1);
",unused,bashxenial-support2Fsignames.c
"    if (signal_names[i] == (char *)NULL)
      {
	signal_names[i] = (char *)malloc (18);
	if (signal_names[i])
	  sprintf (signal_names[i], ""SIGJUNK(%d)"", i);
",1,unused,395,unused,"    if (signal_names[i] == (char *)NULL)
      {
	signal_names[i] = (char *)malloc (18);
	if (signal_names[i])
	  sprintf (signal_names[i], ""SIGJUNK(%d)"", i);
",unused,bashxenial-support2Fsignames.c
"	{
	  string_length = strlen (string);
	  temp_string = (char *)xmalloc (3 + string_length + char_index);

	  strcpy (temp_string, name);
",1,unused,357,unused,"	{
	  string_length = strlen (string);
	  temp_string = (char *)xmalloc (3 + string_length + char_index);

	  strcpy (temp_string, name);
",unused,bashxenial-variables.c
"	  temp_string = (char *)xmalloc (3 + string_length + char_index);

	  strcpy (temp_string, name);
	  temp_string[char_index] = ' ';
	  strcpy (temp_string + char_index + 1, string);
",1,unused,359,unused,"	  temp_string = (char *)xmalloc (3 + string_length + char_index);

	  strcpy (temp_string, name);
	  temp_string[char_index] = ' ';
	  strcpy (temp_string + char_index + 1, string);
",unused,bashxenial-variables.c
"      if (cdir)
	{
	  len = strlen (cdir);
	  name = (char *)xmalloc (len + strlen (shell_name) + 1);
	  strcpy (name, cdir);
",1,unused,714,unused,"      if (cdir)
	{
	  len = strlen (cdir);
	  name = (char *)xmalloc (len + strlen (shell_name) + 1);
	  strcpy (name, cdir);
",unused,bashxenial-variables.c
"	{
	  len = strlen (cdir);
	  name = (char *)xmalloc (len + strlen (shell_name) + 1);
	  strcpy (name, cdir);
	  strcpy (name + len, shell_name + 1);
",1,unused,715,unused,"	{
	  len = strlen (cdir);
	  name = (char *)xmalloc (len + strlen (shell_name) + 1);
	  strcpy (name, cdir);
	  strcpy (name + len, shell_name + 1);
",unused,bashxenial-variables.c
"  unbind_variable (""BASH_VERSINFO"");

  vv = make_new_array_variable (""BASH_VERSINFO"");
  av = array_cell (vv);
  strcpy (d, dist_version);
",1,unused,913,unused,"  unbind_variable (""BASH_VERSINFO"");

  vv = make_new_array_variable (""BASH_VERSINFO"");
  av = array_cell (vv);
  strcpy (d, dist_version);
",unused,bashxenial-variables.c
"	  if (oval == 0)	/* paranoia */
	    oval = """";
	  olen = STRLEN (oval);
	  retval = (char *)xmalloc (olen + (value ? STRLEN (value) : 0) + 1);
	  strcpy (retval, oval);
",1,unused,2455,unused,"	  if (oval == 0)	/* paranoia */
	    oval = """";
	  olen = STRLEN (oval);
	  retval = (char *)xmalloc (olen + (value ? STRLEN (value) : 0) + 1);
	  strcpy (retval, oval);
",unused,bashxenial-variables.c
"	  olen = STRLEN (oval);
	  retval = (char *)xmalloc (olen + (value ? STRLEN (value) : 0) + 1);
	  strcpy (retval, oval);
	  if (value)
	    strcpy (retval+olen, value);
",1,unused,2457,unused,"	  olen = STRLEN (oval);
	  retval = (char *)xmalloc (olen + (value ? STRLEN (value) : 0) + 1);
	  strcpy (retval, oval);
	  if (value)
	    strcpy (retval+olen, value);
",unused,bashxenial-variables.c
"	  if (oval == 0)	/* paranoia */
	    oval = """";
	  olen = STRLEN (oval);
	  retval = (char *)xmalloc (olen + (value ? STRLEN (value) : 0) + 1);
	  strcpy (retval, oval);
",1,unused,2482,unused,"	  if (oval == 0)	/* paranoia */
	    oval = """";
	  olen = STRLEN (oval);
	  retval = (char *)xmalloc (olen + (value ? STRLEN (value) : 0) + 1);
	  strcpy (retval, oval);
",unused,bashxenial-variables.c
"	  olen = STRLEN (oval);
	  retval = (char *)xmalloc (olen + (value ? STRLEN (value) : 0) + 1);
	  strcpy (retval, oval);
	  if (value)
	    strcpy (retval+olen, value);
",1,unused,2484,unused,"	  olen = STRLEN (oval);
	  retval = (char *)xmalloc (olen + (value ? STRLEN (value) : 0) + 1);
	  strcpy (retval, oval);
	  if (value)
	    strcpy (retval+olen, value);
",unused,bashxenial-variables.c
"
  name_len = strlen (name);
  value_len = STRLEN (value);
  p = (char *)xmalloc (2 + name_len + value_len);
  strcpy (p, name);
",1,unused,3873,unused,"
  name_len = strlen (name);
  value_len = STRLEN (value);
  p = (char *)xmalloc (2 + name_len + value_len);
  strcpy (p, name);
",unused,bashxenial-variables.c
"  p = (char *)xmalloc (2 + name_len + value_len);
  strcpy (p, name);
  p[name_len] = '=';
  if (value && *value)
    strcpy (p + name_len + 1, value);
",1,unused,3876,unused,"  p = (char *)xmalloc (2 + name_len + value_len);
  strcpy (p, name);
  p[name_len] = '=';
  if (value && *value)
    strcpy (p + name_len + 1, value);
",unused,bashxenial-variables.c
"{
  char *evar;

  evar = (char *)xmalloc (STRLEN (value) + preflen + 1);
  strcpy (evar, env_prefix);
",1,unused,4215,unused,"{
  char *evar;

  evar = (char *)xmalloc (STRLEN (value) + preflen + 1);
  strcpy (evar, env_prefix);
",unused,bashxenial-variables.c
"
  evar = (char *)xmalloc (STRLEN (value) + preflen + 1);
  strcpy (evar, env_prefix);
  if (value)
    strcpy (evar + preflen, value);
",1,unused,4217,unused,"
  evar = (char *)xmalloc (STRLEN (value) + preflen + 1);
  strcpy (evar, env_prefix);
  if (value)
    strcpy (evar + preflen, value);
",unused,bashxenial-variables.c
"
	  /* +3 because we possibly add one more character below. */
	  RESIZE_MALLOCED_BUFFER (line, llen, (vlen + 3), line_len, (vlen + 50));

	  strcpy (line + llen, v);
",1,unused,558,unused,"
	  /* +3 because we possibly add one more character below. */
	  RESIZE_MALLOCED_BUFFER (line, llen, (vlen + 3), line_len, (vlen + 50));

	  strcpy (line + llen, v);
",unused,bashxenpatch-alias.c
"			t = quoted ? quote_string(element_value(ae)) : element_value(ae);
			reg = strlen(t);
			RESIZE_MALLOCED_BUFFER (result, rlen, (reg + slen + 2),
						rsize, rsize);
			strcpy(result + rlen, t);
",1,unused,835,unused,"			t = quoted ? quote_string(element_value(ae)) : element_value(ae);
			reg = strlen(t);
			RESIZE_MALLOCED_BUFFER (result, rlen, (reg + slen + 2),
						rsize, rsize);
			strcpy(result + rlen, t);
",unused,bashxenpatch-array.c
"			/*
			 * Add a separator only after non-null elements.
			 */
			if (element_forw(ae) != end) {
				strcpy(result + rlen, sep);
",1,unused,843,unused,"			/*
			 * Add a separator only after non-null elements.
			 */
			if (element_forw(ae) != end) {
				strcpy(result + rlen, sep);
",unused,bashxenpatch-array.c
"		elen = STRLEN (is) + 8 + STRLEN (valstr);
		RESIZE_MALLOCED_BUFFER (result, rlen, (elen + 1), rsize, rsize);

		result[rlen++] = '[';
		strcpy (result + rlen, is);
",1,unused,878,unused,"		elen = STRLEN (is) + 8 + STRLEN (valstr);
		RESIZE_MALLOCED_BUFFER (result, rlen, (elen + 1), rsize, rsize);

		result[rlen++] = '[';
		strcpy (result + rlen, is);
",unused,bashxenpatch-array.c
"		rlen += STRLEN (is);
		result[rlen++] = ']';
		result[rlen++] = '=';
		if (valstr) {
			strcpy (result + rlen, valstr);
",1,unused,883,unused,"		rlen += STRLEN (is);
		result[rlen++] = ']';
		result[rlen++] = '=';
		if (valstr) {
			strcpy (result + rlen, valstr);
",unused,bashxenpatch-array.c
"	  ss = s - string;
	  se = skipsubscript (string, ss, 0);
	  subs = substring (s, ss, se);
	  *t++ = '\\';
	  strcpy (t, subs);
",1,unused,676,unused,"	  ss = s - string;
	  se = skipsubscript (string, ss, 0);
	  subs = substring (s, ss, se);
	  *t++ = '\\';
	  strcpy (t, subs);
",unused,bashxenpatch-arrayfunc.c
"	elen = STRLEN (istr) + 8 + STRLEN (vstr);
	RESIZE_MALLOCED_BUFFER (ret, rlen, (elen+1), rsize, rsize);

	ret[rlen++] = '[';
	strcpy (ret+rlen, istr);
",1,unused,452,unused,"	elen = STRLEN (istr) + 8 + STRLEN (vstr);
	RESIZE_MALLOCED_BUFFER (ret, rlen, (elen+1), rsize, rsize);

	ret[rlen++] = '[';
	strcpy (ret+rlen, istr);
",unused,bashxenpatch-assoc.c
"	ret[rlen++] = ']';
	ret[rlen++] = '=';
	if (vstr)
	  {
	    strcpy (ret + rlen, vstr);
",1,unused,458,unused,"	ret[rlen++] = ']';
	ret[rlen++] = '=';
	if (vstr)
	  {
	    strcpy (ret + rlen, vstr);
",unused,bashxenpatch-assoc.c
"	  new_line = (char *)xmalloc (1
				      + curlen
				      + strlen (line)
				      + strlen (chars_to_add));
	  sprintf (new_line, ""%s%s%s"", current->line, chars_to_add, line);
",1,unused,783,unused,"	  new_line = (char *)xmalloc (1
				      + curlen
				      + strlen (line)
				      + strlen (chars_to_add));
	  sprintf (new_line, ""%s%s%s"", current->line, chars_to_add, line);
",unused,bashxenpatch-bashhist.c
"	}
      else
	{
	  nval[0] = '@';
	  strcpy (nval + 1, rl_completer_word_break_characters);
",1,unused,397,unused,"	}
      else
	{
	  nval[0] = '@';
	  strcpy (nval + 1, rl_completer_word_break_characters);
",unused,bashxenpatch-bashline.c
"
  if (rl_explicit_arg)
    {
      command = (char *)xmalloc (strlen (edit_command) + 8);
      sprintf (command, ""%s %d"", edit_command, count);
",1,unused,952,unused,"
  if (rl_explicit_arg)
    {
      command = (char *)xmalloc (strlen (edit_command) + 8);
      sprintf (command, ""%s %d"", edit_command, count);
",unused,bashxenpatch-bashline.c
"	value[0] = *orig_start;
      else
	strncpy (value, orig_start, start_len);

      strcpy (value + start_len, matches[cmd_index]);
",1,unused,2219,unused,"	value[0] = *orig_start;
      else
	strncpy (value, orig_start, start_len);

      strcpy (value + start_len, matches[cmd_index]);
",unused,bashxenpatch-bashline.c
"	  if (first_char_loc == 2)
	    value[1] = '{';
	}

      strcpy (value + first_char_loc, varlist[varlist_index]);
",1,unused,2279,unused,"	  if (first_char_loc == 2)
	    value[1] = '{';
	}

      strcpy (value + first_char_loc, varlist[varlist_index]);
",unused,bashxenpatch-bashline.c
"	}

      strcpy (value + first_char_loc, varlist[varlist_index]);
      if (first_char_loc == 2)
	strcat (value, ""}"");
",1,unused,2281,unused,"	}

      strcpy (value + first_char_loc, varlist[varlist_index]);
      if (first_char_loc == 2)
	strcat (value, ""}"");
",unused,bashxenpatch-bashline.c
"      char *t;

      t = (char *)xmalloc (2 + strlen (list[list_index]));
      *t = first_char;
      strcpy (t + first_char_loc, list[list_index]);
",1,unused,2321,unused,"      char *t;

      t = (char *)xmalloc (2 + strlen (list[list_index]));
      *t = first_char;
      strcpy (t + first_char_loc, list[list_index]);
",unused,bashxenpatch-bashline.c
"  */
  l = (vl - xl) + 1;

  ret = (char *)xmalloc (dl2 + 2 + l);
  strcpy (ret, dh2);
",1,unused,2922,unused,"  */
  l = (vl - xl) + 1;

  ret = (char *)xmalloc (dl2 + 2 + l);
  strcpy (ret, dh2);
",unused,bashxenpatch-bashline.c
"  l = (vl - xl) + 1;

  ret = (char *)xmalloc (dl2 + 2 + l);
  strcpy (ret, dh2);
  strcpy (ret + dl2, val + xl);
",1,unused,2923,unused,"  l = (vl - xl) + 1;

  ret = (char *)xmalloc (dl2 + 2 + l);
  strcpy (ret, dh2);
  strcpy (ret + dl2, val + xl);
",unused,bashxenpatch-bashline.c
"	{
	  globorig = savestring (ttext);
	  glen = strlen (ttext);
	  globtext = (char *)xmalloc (glen + 2);
	  strcpy (globtext, ttext);
",1,unused,3593,unused,"	{
	  globorig = savestring (ttext);
	  glen = strlen (ttext);
	  globtext = (char *)xmalloc (glen + 2);
	  strcpy (globtext, ttext);
",unused,bashxenpatch-bashline.c
"  if (rtext)
    {
      rlen = strlen (rtext);
      ret = (char *)xmalloc (rlen + 1);
      strcpy (ret, rtext);
",1,unused,3939,unused,"  if (rtext)
    {
      rlen = strlen (rtext);
      ret = (char *)xmalloc (rlen + 1);
      strcpy (ret, rtext);
",unused,bashxenpatch-bashline.c
"	  subterm = sh_backslash_quote (x, 0, 0);
	  free (x);
	  result_size += strlen (subterm) + 1;
	  result = (char *)xrealloc (result, result_size);
	  strcat (result, subterm);
",1,unused,133,unused,"	  subterm = sh_backslash_quote (x, 0, 0);
	  free (x);
	  result_size += strlen (subterm) + 1;
	  result = (char *)xrealloc (result, result_size);
	  strcat (result, subterm);
",unused,bashxenpatch-bracecomp.c
"	  result_size += strlen (subterm) + 1;
	  result = (char *)xrealloc (result, result_size);
	  strcat (result, subterm);
	  free (subterm);
	  strcat (result, ""{"");
",1,unused,135,unused,"	  result_size += strlen (subterm) + 1;
	  result = (char *)xrealloc (result, result_size);
	  strcat (result, subterm);
	  free (subterm);
	  strcat (result, ""{"");
",unused,bashxenpatch-bracecomp.c
"	}

      result_size += strlen (subterm) + 1;
      result = (char *)xrealloc (result, result_size);
      strcat (result, subterm);
",1,unused,142,unused,"	}

      result_size += strlen (subterm) + 1;
      result = (char *)xrealloc (result, result_size);
      strcat (result, subterm);
",unused,bashxenpatch-bracecomp.c
"
      result_size += strlen (subterm) + 1;
      result = (char *)xrealloc (result, result_size);
      strcat (result, subterm);
      strcat (result, "","");
",1,unused,143,unused,"
      result_size += strlen (subterm) + 1;
      result = (char *)xrealloc (result, result_size);
      strcat (result, subterm);
      strcat (result, "","");
",unused,bashxenpatch-bracecomp.c
"
      for (j = 0; j < len2; j++)
	{
	  result[len] = (char *)xmalloc (1 + strlen_1 + strlen (arr2[j]));
	  strcpy (result[len], arr1[i]);
",1,unused,772,unused,"
      for (j = 0; j < len2; j++)
	{
	  result[len] = (char *)xmalloc (1 + strlen_1 + strlen (arr2[j]));
	  strcpy (result[len], arr1[i]);
",unused,bashxenpatch-braces.c
"      for (j = 0; j < len2; j++)
	{
	  result[len] = (char *)xmalloc (1 + strlen_1 + strlen (arr2[j]));
	  strcpy (result[len], arr1[i]);
	  strcpy (result[len] + strlen_1, arr2[j]);
",1,unused,773,unused,"      for (j = 0; j < len2; j++)
	{
	  result[len] = (char *)xmalloc (1 + strlen_1 + strlen (arr2[j]));
	  strcpy (result[len], arr1[i]);
	  strcpy (result[len] + strlen_1, arr2[j]);
",unused,bashxenpatch-braces.c
"	  if (error_directory)
	    free (error_directory);

	  error_directory = xmalloc (2 + strlen (argv[arg_index]));
	  strcpy (error_directory, argv[arg_index]);
",1,unused,241,unused,"	  if (error_directory)
	    free (error_directory);

	  error_directory = xmalloc (2 + strlen (argv[arg_index]));
	  strcpy (error_directory, argv[arg_index]);
",unused,bashxenpatch-builtins2Fmkbuiltins.c
"	  strcpy (error_directory, argv[arg_index]);
	  len = strlen (error_directory);

	  if (len && error_directory[len - 1] != '/')
	    strcat (error_directory, ""/"");
",1,unused,245,unused,"	  strcpy (error_directory, argv[arg_index]);
	  len = strlen (error_directory);

	  if (len && error_directory[len - 1] != '/')
	    strcat (error_directory, ""/"");
",unused,bashxenpatch-builtins2Fmkbuiltins.c
"      /* Open the files. */
      if (struct_filename)
	{
	  temp_struct_filename = xmalloc (15);
	  sprintf (temp_struct_filename, ""mk-%ld"", (long) getpid ());
",1,unused,278,unused,"      /* Open the files. */
      if (struct_filename)
	{
	  temp_struct_filename = xmalloc (15);
	  sprintf (temp_struct_filename, ""mk-%ld"", (long) getpid ());
",unused,bashxenpatch-builtins2Fmkbuiltins.c
"      if (separate_helpfiles)
	{
	  int l = strlen (helpfile_directory) + strlen (dname) + 1;
	  sarray[0] = (char *)xmalloc (l + 1);
	  sprintf (sarray[0], ""%s/%s"", helpfile_directory, dname);
",1,unused,1313,unused,"      if (separate_helpfiles)
	{
	  int l = strlen (helpfile_directory) + strlen (dname) + 1;
	  sarray[0] = (char *)xmalloc (l + 1);
	  sprintf (sarray[0], ""%s/%s"", helpfile_directory, dname);
",unused,bashxenpatch-builtins2Fmkbuiltins.c
"      builtin = (BUILTIN_DESC *)builtins->array[i];

      bname = document_name (builtin);
      helpfile = (char *)xmalloc (hdlen + strlen (bname) + 1);
      sprintf (helpfile, ""helpfiles/%s"", bname);
",1,unused,1565,unused,"      builtin = (BUILTIN_DESC *)builtins->array[i];

      bname = document_name (builtin);
      helpfile = (char *)xmalloc (hdlen + strlen (bname) + 1);
      sprintf (helpfile, ""helpfiles/%s"", bname);
",unused,bashxenpatch-builtins2Fmkbuiltins.c
"	  sum = cpu / 100;
	  sum_frac = (cpu % 100) * 10;
	  len = mkfmt (ts, 2, 0, sum, sum_frac);
	  RESIZE_MALLOCED_BUFFER (str, sindex, len, ssize, 64);
	  strcpy (str + sindex, ts);
",1,unused,1207,unused,"	  sum = cpu / 100;
	  sum_frac = (cpu % 100) * 10;
	  len = mkfmt (ts, 2, 0, sum, sum_frac);
	  RESIZE_MALLOCED_BUFFER (str, sindex, len, ssize, 64);
	  strcpy (str + sindex, ts);
",unused,bashxenpatch-execute_cmd.c
"	      free (str);
	      return;
	    }
	  RESIZE_MALLOCED_BUFFER (str, sindex, len, ssize, 64);
	  strcpy (str + sindex, ts);
",1,unused,1238,unused,"	      free (str);
	      return;
	    }
	  RESIZE_MALLOCED_BUFFER (str, sindex, len, ssize, 64);
	  strcpy (str + sindex, ts);
",unused,bashxenpatch-execute_cmd.c
"  bind_variable (namevar, t, 0);
  free (t);
#endif

  sprintf (namevar, ""%s_PID"", cp->c_name);
",1,unused,2132,unused,"  bind_variable (namevar, t, 0);
  free (t);
#endif

  sprintf (namevar, ""%s_PID"", cp->c_name);
",unused,bashxenpatch-execute_cmd.c
"
  l = strlen (cp->c_name);
  namevar = xmalloc (l + 16);

  sprintf (namevar, ""%s_PID"", cp->c_name);
",1,unused,2153,unused,"
  l = strlen (cp->c_name);
  namevar = xmalloc (l + 16);

  sprintf (namevar, ""%s_PID"", cp->c_name);
",unused,bashxenpatch-execute_cmd.c
"      if (tail[0] != '.' || tail[1] != '/')
	{
	  dotted_filename = (char *)xmalloc (3 + strlen (tail));
	  dotted_filename[0] = '.'; dotted_filename[1] = '/';
	  strcpy (dotted_filename + 2, tail);
",1,unused,155,unused,"      if (tail[0] != '.' || tail[1] != '/')
	{
	  dotted_filename = (char *)xmalloc (3 + strlen (tail));
	  dotted_filename[0] = '.'; dotted_filename[1] = '/';
	  strcpy (dotted_filename + 2, tail);
",unused,bashxenpatch-hashcmd.c
"  x = strsignal (s);
  if (x == 0)
    {
      x = retcode_name_buffer;
      sprintf (x, _(""Signal %d""), s);
",1,unused,1450,unused,"  x = strsignal (s);
  if (x == 0)
    {
      x = retcode_name_buffer;
      sprintf (x, _(""Signal %d""), s);
",unused,bashxenpatch-jobs.c
"	temp = _(""Stopped"");
      else
	{
	  temp = retcode_name_buffer;
	  sprintf (temp, _(""Stopped(%s)""), signal_name (WSTOPSIG (p->status)));
",1,unused,1473,unused,"	temp = _(""Stopped"");
      else
	{
	  temp = retcode_name_buffer;
	  sprintf (temp, _(""Stopped(%s)""), signal_name (WSTOPSIG (p->status)));
",unused,bashxenpatch-jobs.c
"	{
	  temp = retcode_name_buffer;
	  es = WEXITSTATUS (p->status);
	  if (es == 0)
	    strcpy (temp, _(""Done""));
",1,unused,1489,unused,"	{
	  temp = retcode_name_buffer;
	  es = WEXITSTATUS (p->status);
	  if (es == 0)
	    strcpy (temp, _(""Done""));
",unused,bashxenpatch-jobs.c
"	  es = WEXITSTATUS (p->status);
	  if (es == 0)
	    strcpy (temp, _(""Done""));
	  else if (posixly_correct)
	    sprintf (temp, _(""Done(%d)""), es);
",1,unused,1491,unused,"	  es = WEXITSTATUS (p->status);
	  if (es == 0)
	    strcpy (temp, _(""Done""));
	  else if (posixly_correct)
	    sprintf (temp, _(""Done(%d)""), es);
",unused,bashxenpatch-jobs.c
"	    strcpy (temp, _(""Done""));
	  else if (posixly_correct)
	    sprintf (temp, _(""Done(%d)""), es);
	  else
	    sprintf (temp, _(""Exit %d""), es);
",1,unused,1493,unused,"	    strcpy (temp, _(""Done""));
	  else if (posixly_correct)
	    sprintf (temp, _(""Done(%d)""), es);
	  else
	    sprintf (temp, _(""Exit %d""), es);
",unused,bashxenpatch-jobs.c
"	  lose = 1;
	}
      else
	{
	  strcpy (npat, pat);
",1,unused,644,unused,"	  lose = 1;
	}
      else
	{
	  strcpy (npat, pat);
",unused,bashxenpatch-lib2Fglob2Fglob.c
"	{
	  strcpy (npat, pat);
	  dequote_pathname (npat);

	  strcpy (nextname, dir);
",1,unused,647,unused,"	{
	  strcpy (npat, pat);
	  dequote_pathname (npat);

	  strcpy (nextname, dir);
",unused,bashxenpatch-lib2Fglob2Fglob.c
"	  dequote_pathname (npat);

	  strcpy (nextname, dir);
	  nextname[dirlen++] = '/';
	  strcpy (nextname + dirlen, npat);
",1,unused,649,unused,"	  dequote_pathname (npat);

	  strcpy (nextname, dir);
	  nextname[dirlen++] = '/';
	  strcpy (nextname + dirlen, npat);
",unused,bashxenpatch-lib2Fglob2Fglob.c
"	  free (result);
	  return (NULL);
	}

      strcpy (result[i], dir);
",1,unused,986,unused,"	  free (result);
	  return (NULL);
	}

      strcpy (result[i], dir);
",unused,bashxenpatch-lib2Fglob2Fglob.c
"
      strcpy (result[i], dir);
      if (add_slash)
	result[i][l] = '/';
      strcpy (result[i] + l + add_slash, array[i]);
",1,unused,989,unused,"
      strcpy (result[i], dir);
      if (add_slash)
	result[i][l] = '/';
      strcpy (result[i] + l + add_slash, array[i]);
",unused,bashxenpatch-lib2Fglob2Fglob.c
"		       with the eighth bit set to ESC-prefixed sequences, then
		       we can use \M-.  Otherwise we need to use the sequence
		       for ESC. */
		    if (_rl_convert_meta_chars_to_ascii && map[ESC].type == ISKMAP)
		      sprintf (keyname, ""\\M-"");
",1,unused,2136,unused,"		       with the eighth bit set to ESC-prefixed sequences, then
		       we can use \M-.  Otherwise we need to use the sequence
		       for ESC. */
		    if (_rl_convert_meta_chars_to_ascii && map[ESC].type == ISKMAP)
		      sprintf (keyname, ""\\M-"");
",unused,bashxenpatch-lib2Freadline2Fbind.c
"		       for ESC. */
		    if (_rl_convert_meta_chars_to_ascii && map[ESC].type == ISKMAP)
		      sprintf (keyname, ""\\M-"");
		    else
		      sprintf (keyname, ""\\e"");
",1,unused,2138,unused,"		       for ESC. */
		    if (_rl_convert_meta_chars_to_ascii && map[ESC].type == ISKMAP)
		      sprintf (keyname, ""\\M-"");
		    else
		      sprintf (keyname, ""\\e"");
",unused,bashxenpatch-lib2Freadline2Fbind.c
"		    else
		      sprintf (keyname, ""\\e"");
		  }
		else if (CTRL_CHAR (key))
		  sprintf (keyname, ""\\C-%c"", _rl_to_lower (UNCTRL (key)));
",1,unused,2141,unused,"		    else
		      sprintf (keyname, ""\\e"");
		  }
		else if (CTRL_CHAR (key))
		  sprintf (keyname, ""\\C-%c"", _rl_to_lower (UNCTRL (key)));
",unused,bashxenpatch-lib2Freadline2Fbind.c
"		  }
		else if (CTRL_CHAR (key))
		  sprintf (keyname, ""\\C-%c"", _rl_to_lower (UNCTRL (key)));
		else if (key == RUBOUT)
		  sprintf (keyname, ""\\C-?"");
",1,unused,2143,unused,"		  }
		else if (CTRL_CHAR (key))
		  sprintf (keyname, ""\\C-%c"", _rl_to_lower (UNCTRL (key)));
		else if (key == RUBOUT)
		  sprintf (keyname, ""\\C-?"");
",unused,bashxenpatch-lib2Freadline2Fbind.c
"		    keyname[0] = (char) key;
		    keyname[1] = '\0';
		  }
		
		strcat (keyname, seqs[i]);
",1,unused,2156,unused,"		    keyname[0] = (char) key;
		    keyname[1] = '\0';
		  }
		
		strcat (keyname, seqs[i]);
",unused,bashxenpatch-lib2Freadline2Fbind.c
"	  if (key == ESC)
	    {
	      keyname = (char *)xmalloc (3 + prefix_len);
	      if (prefix)
		strcpy (keyname, prefix);
",1,unused,2309,unused,"	  if (key == ESC)
	    {
	      keyname = (char *)xmalloc (3 + prefix_len);
	      if (prefix)
		strcpy (keyname, prefix);
",unused,bashxenpatch-lib2Freadline2Fbind.c
"	      keyname = _rl_get_keyname (key);
	      if (prefix)
		{
		  out = (char *)xmalloc (strlen (keyname) + prefix_len + 1);
		  strcpy (out, prefix);
",1,unused,2320,unused,"	      keyname = _rl_get_keyname (key);
	      if (prefix)
		{
		  out = (char *)xmalloc (strlen (keyname) + prefix_len + 1);
		  strcpy (out, prefix);
",unused,bashxenpatch-lib2Freadline2Fbind.c
"	      if (prefix)
		{
		  out = (char *)xmalloc (strlen (keyname) + prefix_len + 1);
		  strcpy (out, prefix);
		  strcpy (out + prefix_len, keyname);
",1,unused,2321,unused,"	      if (prefix)
		{
		  out = (char *)xmalloc (strlen (keyname) + prefix_len + 1);
		  strcpy (out, prefix);
		  strcpy (out + prefix_len, keyname);
",unused,bashxenpatch-lib2Freadline2Fbind.c
"  else if (_rl_stricmp (name, ""comment-begin"") == 0)
    return (_rl_comment_begin ? _rl_comment_begin : RL_COMMENT_BEGIN_DEFAULT);
  else if (_rl_stricmp (name, ""completion-display-width"") == 0)
    {
      sprintf (numbuf, ""%d"", _rl_completion_columns);
",1,unused,2376,unused,"  else if (_rl_stricmp (name, ""comment-begin"") == 0)
    return (_rl_comment_begin ? _rl_comment_begin : RL_COMMENT_BEGIN_DEFAULT);
  else if (_rl_stricmp (name, ""completion-display-width"") == 0)
    {
      sprintf (numbuf, ""%d"", _rl_completion_columns);
",unused,bashxenpatch-lib2Freadline2Fbind.c
"      return (numbuf);
    }
  else if (_rl_stricmp (name, ""completion-prefix-display-length"") == 0)
    {
      sprintf (numbuf, ""%d"", _rl_completion_prefix_display_length);
",1,unused,2381,unused,"      return (numbuf);
    }
  else if (_rl_stricmp (name, ""completion-prefix-display-length"") == 0)
    {
      sprintf (numbuf, ""%d"", _rl_completion_prefix_display_length);
",unused,bashxenpatch-lib2Freadline2Fbind.c
"      return (numbuf);
    }
  else if (_rl_stricmp (name, ""completion-query-items"") == 0)
    {
      sprintf (numbuf, ""%d"", rl_completion_query_items);
",1,unused,2386,unused,"      return (numbuf);
    }
  else if (_rl_stricmp (name, ""completion-query-items"") == 0)
    {
      sprintf (numbuf, ""%d"", rl_completion_query_items);
",unused,bashxenpatch-lib2Freadline2Fbind.c
"  else if (_rl_stricmp (name, ""editing-mode"") == 0)
    return (rl_get_keymap_name_from_edit_mode ());
  else if (_rl_stricmp (name, ""history-size"") == 0)
    {
      sprintf (numbuf, ""%d"", history_is_stifled() ? history_max_entries : 0);
",1,unused,2393,unused,"  else if (_rl_stricmp (name, ""editing-mode"") == 0)
    return (rl_get_keymap_name_from_edit_mode ());
  else if (_rl_stricmp (name, ""history-size"") == 0)
    {
      sprintf (numbuf, ""%d"", history_is_stifled() ? history_max_entries : 0);
",unused,bashxenpatch-lib2Freadline2Fbind.c
"      return (ret ? ret : ""none"");
    }
  else if (_rl_stricmp (name, ""keyseq-timeout"") == 0)
    {
      sprintf (numbuf, ""%d"", _rl_keyseq_timeout);    
",1,unused,2420,unused,"      return (ret ? ret : ""none"");
    }
  else if (_rl_stricmp (name, ""keyseq-timeout"") == 0)
    {
      sprintf (numbuf, ""%d"", _rl_keyseq_timeout);    
",unused,bashxenpatch-lib2Freadline2Fbind.c
"
	  slen = strlen (s);
	  tlen = strlen (to_print);
	  new_full_pathname = (char *)xmalloc (slen + tlen + 2);
	  strcpy (new_full_pathname, s);
",1,unused,911,unused,"
	  slen = strlen (s);
	  tlen = strlen (to_print);
	  new_full_pathname = (char *)xmalloc (slen + tlen + 2);
	  strcpy (new_full_pathname, s);
",unused,bashxenpatch-lib2Freadline2Fcomplete.c
"	    slen--;
	  else
	    new_full_pathname[slen] = '/';
	  new_full_pathname[slen] = '/';
	  strcpy (new_full_pathname + slen + 1, to_print);
",1,unused,917,unused,"	    slen--;
	  else
	    new_full_pathname[slen] = '/';
	  new_full_pathname[slen] = '/';
	  strcpy (new_full_pathname + slen + 1, to_print);
",unused,bashxenpatch-lib2Freadline2Fcomplete.c
"  char *r;

  r = (char *)xmalloc (strlen (s) + 2);
  *r = *rl_completer_quote_characters;
  strcpy (r + 1, s);
",1,unused,993,unused,"  char *r;

  r = (char *)xmalloc (strlen (s) + 2);
  *r = *rl_completer_quote_characters;
  strcpy (r + 1, s);
",unused,bashxenpatch-lib2Freadline2Fcomplete.c
"     value of matches[0]. */
  if (low == 0 && text && *text)
    {
      match_list[0] = (char *)xmalloc (strlen (text) + 1);
      strcpy (match_list[0], text);
",1,unused,1353,unused,"     value of matches[0]. */
  if (low == 0 && text && *text)
    {
      match_list[0] = (char *)xmalloc (strlen (text) + 1);
      strcpy (match_list[0], text);
",unused,bashxenpatch-lib2Freadline2Fcomplete.c
"      value = (char *)xmalloc (2 + strlen (entry->pw_name));

      *value = *text;

      strcpy (value + first_char_loc, entry->pw_name);
",1,unused,2216,unused,"      value = (char *)xmalloc (2 + strlen (entry->pw_name));

      *value = *text;

      strcpy (value + first_char_loc, entry->pw_name);
",unused,bashxenpatch-lib2Freadline2Fcomplete.c
"#endif

      if (temp)
	{
	  strcpy (filename, ++temp);
",1,unused,2406,unused,"#endif

      if (temp)
	{
	  strcpy (filename, ++temp);
",unused,bashxenpatch-lib2Freadline2Fcomplete.c
"	  if (rl_complete_with_tilde_expansion && *users_dirname == '~')
	    {
	      dirlen = strlen (dirname);
	      temp = (char *)xmalloc (2 + dirlen + D_NAMLEN (entry));
	      strcpy (temp, dirname);
",1,unused,2550,unused,"	  if (rl_complete_with_tilde_expansion && *users_dirname == '~')
	    {
	      dirlen = strlen (dirname);
	      temp = (char *)xmalloc (2 + dirlen + D_NAMLEN (entry));
	      strcpy (temp, dirname);
",unused,bashxenpatch-lib2Freadline2Fcomplete.c
"	  else
	    {
	      dirlen = strlen (users_dirname);
	      temp = (char *)xmalloc (2 + dirlen + D_NAMLEN (entry));
	      strcpy (temp, users_dirname);
",1,unused,2563,unused,"	  else
	    {
	      dirlen = strlen (users_dirname);
	      temp = (char *)xmalloc (2 + dirlen + D_NAMLEN (entry));
	      strcpy (temp, users_dirname);
",unused,bashxenpatch-lib2Freadline2Fcomplete.c
"	      if (users_dirname[dirlen - 1] != '/')
		temp[dirlen++] = '/';
	    }

	  strcpy (temp + dirlen, convfn);
",1,unused,2569,unused,"	      if (users_dirname[dirlen - 1] != '/')
		temp[dirlen++] = '/';
	    }

	  strcpy (temp + dirlen, convfn);
",unused,bashxenpatch-lib2Freadline2Fcomplete.c
"        {
          l = strlen (pmt);
          r = (char *)xmalloc (l + 2);
          r[0] = prompt_modechar ();
          strcpy (r + 1, pmt);
",1,unused,285,unused,"        {
          l = strlen (pmt);
          r = (char *)xmalloc (l + 2);
          r[0] = prompt_modechar ();
          strcpy (r + 1, pmt);
",unused,bashxenpatch-lib2Freadline2Fdisplay.c
"#endif
	{
	  if (_rl_output_meta_chars == 0)
	    {
	      sprintf (line + out, ""\\%o"", c);
",1,unused,832,unused,"#endif
	{
	  if (_rl_output_meta_chars == 0)
	    {
	      sprintf (line + out, ""\\%o"", c);
",unused,bashxenpatch-lib2Freadline2Fdisplay.c
"
  /* Make sure the line structures hold the already-displayed prompt for
     redisplay. */
  lprompt = local_prompt ? local_prompt : rl_prompt;
  strcpy (visible_line, lprompt);
",1,unused,1916,unused,"
  /* Make sure the line structures hold the already-displayed prompt for
     redisplay. */
  lprompt = local_prompt ? local_prompt : rl_prompt;
  strcpy (visible_line, lprompt);
",unused,bashxenpatch-lib2Freadline2Fdisplay.c
"  /* Make sure the line structures hold the already-displayed prompt for
     redisplay. */
  lprompt = local_prompt ? local_prompt : rl_prompt;
  strcpy (visible_line, lprompt);
  strcpy (invisible_line, lprompt);
",1,unused,1917,unused,"  /* Make sure the line structures hold the already-displayed prompt for
     redisplay. */
  lprompt = local_prompt ? local_prompt : rl_prompt;
  strcpy (visible_line, lprompt);
  strcpy (invisible_line, lprompt);
",unused,bashxenpatch-lib2Freadline2Fdisplay.c
"    {
      len = (rl_prompt && *rl_prompt) ? strlen (rl_prompt) : 0;
      pmt = (char *)xmalloc (len + 2);
      if (len)
	strcpy (pmt, rl_prompt);
",1,unused,2409,unused,"    {
      len = (rl_prompt && *rl_prompt) ? strlen (rl_prompt) : 0;
      pmt = (char *)xmalloc (len + 2);
      if (len)
	strcpy (pmt, rl_prompt);
",unused,bashxenpatch-lib2Freadline2Fdisplay.c
"      p++;
      len = strlen (p);
      pmt = (char *)xmalloc (len + 2);
      if (len)
	strcpy (pmt, p);
",1,unused,2419,unused,"      p++;
      len = strlen (p);
      pmt = (char *)xmalloc (len + 2);
      if (len)
	strcpy (pmt, p);
",unused,bashxenpatch-lib2Freadline2Fdisplay.c
"  temp = (char *)xmalloc (ll + elen + 3);
  strncpy (temp, s + start, ll);
  temp[ll] = ':';
  temp[ll + 1] = ' ';
  strcpy (temp + ll + 2, emsg);
",1,unused,413,unused,"  temp = (char *)xmalloc (ll + elen + 3);
  strncpy (temp, s + start, ll);
  temp[ll] = ':';
  temp[ll + 1] = ' ';
  strcpy (temp + ll + 2, emsg);
",unused,bashxenpatch-lib2Freadline2Fhistexpand.c
"      if (subst_rhs[i] == '&')
	{
	  if (j + subst_lhs_len >= new_size)
	    new = (char *)xrealloc (new, (new_size = new_size * 2 + subst_lhs_len));
	  strcpy (new + j, subst_lhs);
",1,unused,499,unused,"      if (subst_rhs[i] == '&')
	{
	  if (j + subst_lhs_len >= new_size)
	    new = (char *)xrealloc (new, (new_size = new_size * 2 + subst_lhs_len));
	  strcpy (new + j, subst_lhs);
",unused,bashxenpatch-lib2Freadline2Fhistexpand.c
"
  n = strlen (temp);
  if (n >= result_len)
    result = (char *)xrealloc (result, n + 2);
  strcpy (result, temp);
",1,unused,858,unused,"
  n = strlen (temp);
  if (n >= result_len)
    result = (char *)xrealloc (result, n + 2);
  strcpy (result, temp);
",unused,bashxenpatch-lib2Freadline2Fhistexpand.c
"
      string[0] = string[1] = history_expansion_char;
      string[2] = ':';
      string[3] = 's';
      strcpy (string + 4, hstring);
",1,unused,959,unused,"
      string[0] = string[1] = history_expansion_char;
      string[2] = ':';
      string[3] = 's';
      strcpy (string + 4, hstring);
",unused,bashxenpatch-lib2Freadline2Fhistexpand.c
"	case -2:		/* history_comment_char */
	  if (i == 0 || member (string[i - 1], history_word_delimiters))
	    {
	      temp = (char *)xmalloc (l - i + 1);
	      strcpy (temp, string + i);
",1,unused,1155,unused,"	case -2:		/* history_comment_char */
	  if (i == 0 || member (string[i - 1], history_word_delimiters))
	    {
	      temp = (char *)xmalloc (l - i + 1);
	      strcpy (temp, string + i);
",unused,bashxenpatch-lib2Freadline2Fhistexpand.c
"      result[0] = '\0';

      for (i = first, offset = 0; i < last; i++)
	{
	  strcpy (result + offset, list[i]);
",1,unused,1395,unused,"      result[0] = '\0';

      for (i = first, offset = 0; i < last; i++)
	{
	  strcpy (result + offset, list[i]);
",unused,bashxenpatch-lib2Freadline2Fhistexpand.c
"  else
    home_len = strlen (home);

  return_val = (char *)xmalloc (2 + home_len + 8); /* strlen("".history"") == 8 */
  strcpy (return_val, home);
",1,unused,133,unused,"  else
    home_len = strlen (home);

  return_val = (char *)xmalloc (2 + home_len + 8); /* strlen("".history"") == 8 */
  strcpy (return_val, home);
",unused,bashxenpatch-lib2Freadline2Fhistfile.c
"  return_val[home_len] = '/';
#if defined (__MSDOS__)
  strcpy (return_val + home_len + 1, ""_history"");
#else
  strcpy (return_val + home_len + 1, "".history"");
",1,unused,138,unused,"  return_val[home_len] = '/';
#if defined (__MSDOS__)
  strcpy (return_val + home_len + 1, ""_history"");
#else
  strcpy (return_val + home_len + 1, "".history"");
",unused,bashxenpatch-lib2Freadline2Fhistfile.c
"  size_t len;

  len = strlen (filename);
  ret = xmalloc (len + 2);
  strcpy (ret, filename);
",1,unused,153,unused,"  size_t len;

  len = strlen (filename);
  ret = xmalloc (len + 2);
  strcpy (ret, filename);
",unused,bashxenpatch-lib2Freadline2Fhistfile.c
"    for (j = 0, i = history_length - nelements; i < history_length; i++)
      {
	if (history_write_timestamps && the_history[i]->timestamp && the_history[i]->timestamp[0])
	  {
	    strcpy (buffer + j, the_history[i]->timestamp);
",1,unused,533,unused,"    for (j = 0, i = history_length - nelements; i < history_length; i++)
      {
	if (history_write_timestamps && the_history[i]->timestamp && the_history[i]->timestamp[0])
	  {
	    strcpy (buffer + j, the_history[i]->timestamp);
",unused,bashxenpatch-lib2Freadline2Fhistfile.c
"	    strcpy (buffer + j, the_history[i]->timestamp);
	    j += strlen (the_history[i]->timestamp);
	    buffer[j++] = '\n';
	  }
	strcpy (buffer + j, the_history[i]->line);
",1,unused,537,unused,"	    strcpy (buffer + j, the_history[i]->timestamp);
	    j += strlen (the_history[i]->timestamp);
	    buffer[j++] = '\n';
	  }
	strcpy (buffer + j, the_history[i]->line);
",unused,bashxenpatch-lib2Freadline2Fhistfile.c
"  message[msglen++] = '(';

  if (flags & SF_FAILED)
    {
      strcpy (message + msglen, ""failed "");
",1,unused,183,unused,"  message[msglen++] = '(';

  if (flags & SF_FAILED)
    {
      strcpy (message + msglen, ""failed "");
",unused,bashxenpatch-lib2Freadline2Fisearch.c
"    }

  if (flags & SF_REVERSE)
    {
      strcpy (message + msglen, ""reverse-"");
",1,unused,189,unused,"    }

  if (flags & SF_REVERSE)
    {
      strcpy (message + msglen, ""reverse-"");
",unused,bashxenpatch-lib2Freadline2Fisearch.c
"      strcpy (message + msglen, ""reverse-"");
      msglen += 8;
    }

  strcpy (message + msglen, ""i-search)`"");
",1,unused,193,unused,"      strcpy (message + msglen, ""reverse-"");
      msglen += 8;
    }

  strcpy (message + msglen, ""i-search)`"");
",unused,bashxenpatch-lib2Freadline2Fisearch.c
"  msglen += 10;

  if (search_string)
    {
      strcpy (message + msglen, search_string);
",1,unused,198,unused,"  msglen += 10;

  if (search_string)
    {
      strcpy (message + msglen, search_string);
",unused,bashxenpatch-lib2Freadline2Fisearch.c
"      strcpy (message + msglen, search_string);
      msglen += searchlen;
    }

  strcpy (message + msglen, ""': "");
",1,unused,202,unused,"      strcpy (message + msglen, search_string);
      msglen += searchlen;
    }

  strcpy (message + msglen, ""': "");
",unused,bashxenpatch-lib2Freadline2Fisearch.c
"  else
    {
      /* Keep track of this so we can free it. */
      cxt->allocated_line = (char *)xmalloc (1 + strlen (rl_line_buffer));
      strcpy (cxt->allocated_line, &rl_line_buffer[0]);
",1,unused,243,unused,"  else
    {
      /* Keep track of this so we can free it. */
      cxt->allocated_line = (char *)xmalloc (1 + strlen (rl_line_buffer));
      strcpy (cxt->allocated_line, &rl_line_buffer[0]);
",unused,bashxenpatch-lib2Freadline2Fisearch.c
"_rl_isearch_fini (cxt)
     _rl_search_cxt *cxt;
{
  /* First put back the original state. */
  strcpy (rl_line_buffer, cxt->lines[cxt->save_line]);
",1,unused,275,unused,"_rl_isearch_fini (cxt)
     _rl_search_cxt *cxt;
{
  /* First put back the original state. */
  strcpy (rl_line_buffer, cxt->lines[cxt->save_line]);
",unused,bashxenpatch-lib2Freadline2Fisearch.c
"	  if (last_isearch_string)
	    {
	      cxt->search_string_size = 64 + last_isearch_string_len;
	      cxt->search_string = (char *)xrealloc (cxt->search_string, cxt->search_string_size);
	      strcpy (cxt->search_string, last_isearch_string);
",1,unused,524,unused,"	  if (last_isearch_string)
	    {
	      cxt->search_string_size = 64 + last_isearch_string_len;
	      cxt->search_string = (char *)xrealloc (cxt->search_string, cxt->search_string_size);
	      strcpy (cxt->search_string, last_isearch_string);
",unused,bashxenpatch-lib2Freadline2Fisearch.c
"      new = (char *)xmalloc (1 + strlen (old) + strlen (text));

      if (append)
	{
	  strcpy (new, old);
",1,unused,141,unused,"      new = (char *)xmalloc (1 + strlen (old) + strlen (text));

      if (append)
	{
	  strcpy (new, old);
",unused,bashxenpatch-lib2Freadline2Fkill.c
"
      if (append)
	{
	  strcpy (new, old);
	  strcat (new, text);
",1,unused,142,unused,"
      if (append)
	{
	  strcpy (new, old);
	  strcat (new, text);
",unused,bashxenpatch-lib2Freadline2Fkill.c
"	  strcat (new, text);
	}
      else
	{
	  strcpy (new, text);
",1,unused,146,unused,"	  strcat (new, text);
	}
      else
	{
	  strcpy (new, text);
",unused,bashxenpatch-lib2Freadline2Fkill.c
"	}
      else
	{
	  strcpy (new, text);
	  strcat (new, old);
",1,unused,147,unused,"	}
      else
	{
	  strcpy (new, text);
	  strcat (new, old);
",unused,bashxenpatch-lib2Freadline2Fkill.c
"      return;
    }

  ext = NULL;
  strcpy (label, ""??"");
",1,unused,318,unused,"      return;
    }

  ext = NULL;
  strcpy (label, ""??"");
",unused,bashxenpatch-lib2Freadline2Fparse-colors.c
"      rl_revert_line (1, 0);
      entry = replace_history_entry (where_history (), the_line, (histdata_t)NULL);
      _rl_free_history_entry (entry);

      strcpy (the_line, temp);
",1,unused,465,unused,"      rl_revert_line (1, 0);
      entry = replace_history_entry (where_history (), the_line, (histdata_t)NULL);
      _rl_free_history_entry (entry);

      strcpy (the_line, temp);
",unused,bashxenpatch-lib2Freadline2Freadline.c
"{
  char *ret;

  ret = (char *)xmalloc (strlen (s) + 1);
  strcpy (ret, s);
",1,unused,39,unused,"{
  char *ret;

  ret = (char *)xmalloc (strlen (s) + 1);
  strcpy (ret, s);
",unused,bashxenpatch-lib2Freadline2Fsavestring.c
"sh_set_lines_and_columns (lines, cols)
     int lines, cols;
{
#if defined (HAVE_SETENV)
  sprintf (setenv_buf, ""%d"", lines);
",1,unused,134,unused,"sh_set_lines_and_columns (lines, cols)
     int lines, cols;
{
#if defined (HAVE_SETENV)
  sprintf (setenv_buf, ""%d"", lines);
",unused,bashxenpatch-lib2Freadline2Fshell.c
"#if defined (HAVE_SETENV)
  sprintf (setenv_buf, ""%d"", lines);
  setenv (""LINES"", setenv_buf, 1);

  sprintf (setenv_buf, ""%d"", cols);
",1,unused,137,unused,"#if defined (HAVE_SETENV)
  sprintf (setenv_buf, ""%d"", lines);
  setenv (""LINES"", setenv_buf, 1);

  sprintf (setenv_buf, ""%d"", cols);
",unused,bashxenpatch-lib2Freadline2Fshell.c
"
  len = strlen (text);
  if (len >= rl_line_buffer_len)
    rl_extend_line_buffer (len);
  strcpy (rl_line_buffer, text);
",1,unused,216,unused,"
  len = strlen (text);
  if (len >= rl_line_buffer_len)
    rl_extend_line_buffer (len);
  strcpy (rl_line_buffer, text);
",unused,bashxenpatch-lib2Freadline2Ftext.c
"	{
	  if ((result_index + len + 1) > result_size)
	    result = (char *)xrealloc (result, 1 + (result_size += (len + 20)));

	  strcpy (result + result_index, expansion);
",1,unused,251,unused,"	{
	  if ((result_index + len + 1) > result_size)
	    result = (char *)xrealloc (result, 1 + (result_size += (len + 20)));

	  strcpy (result + result_index, expansion);
",unused,bashxenpatch-lib2Freadline2Ftilde.c
"  plen = (prefix && *prefix) ? strlen (prefix) : 0;
  slen = strlen (suffix + suffind);
  ret = (char *)xmalloc (plen + slen + 1);
  if (plen)
    strcpy (ret, prefix);
",1,unused,334,unused,"  plen = (prefix && *prefix) ? strlen (prefix) : 0;
  slen = strlen (suffix + suffind);
  ret = (char *)xmalloc (plen + slen + 1);
  if (plen)
    strcpy (ret, prefix);
",unused,bashxenpatch-lib2Freadline2Ftilde.c
"  slen = strlen (suffix + suffind);
  ret = (char *)xmalloc (plen + slen + 1);
  if (plen)
    strcpy (ret, prefix);
  strcpy (ret + plen, suffix + suffind);
",1,unused,335,unused,"  slen = strlen (suffix + suffind);
  ret = (char *)xmalloc (plen + slen + 1);
  if (plen)
    strcpy (ret, prefix);
  strcpy (ret + plen, suffix + suffind);
",unused,bashxenpatch-lib2Freadline2Ftilde.c
"char *
_rl_savestring (s)
     const char *s;
{
  return (strcpy ((char *)xmalloc (1 + (int)strlen (s)), (s)));
",1,unused,476,unused,"char *
_rl_savestring (s)
     const char *s;
{
  return (strcpy ((char *)xmalloc (1 + (int)strlen (s)), (s)));
",unused,bashxenpatch-lib2Freadline2Futil.c
"  char fnbuf[128];

  if (_rl_tracefp)
    fclose (_rl_tracefp);
  sprintf (fnbuf, ""/var/tmp/rltrace.%ld"", (long)getpid());
",1,unused,518,unused,"  char fnbuf[128];

  if (_rl_tracefp)
    fclose (_rl_tracefp);
  sprintf (fnbuf, ""/var/tmp/rltrace.%ld"", (long)getpid());
",unused,bashxenpatch-lib2Freadline2Futil.c
"  start = 0;
  end = strlen (string);

  ret = (char *)xmalloc (end + 1);
  strcpy (ret, string);
",1,unused,135,unused,"  start = 0;
  end = strlen (string);

  ret = (char *)xmalloc (end + 1);
  strcpy (ret, string);
",unused,bashxenpatch-lib2Fsh2Fcasemod.c
"     trailing slash.  Make sure /dev/fd/xx really uses DEV_FD_PREFIX/xx.
     On most systems, with the notable exception of linux, this is
     effectively a no-op. */
      pbuf = xrealloc (pbuf, sizeof (DEV_FD_PREFIX) + strlen (path + 8));
      strcpy (pbuf, DEV_FD_PREFIX);
",1,unused,112,unused,"     trailing slash.  Make sure /dev/fd/xx really uses DEV_FD_PREFIX/xx.
     On most systems, with the notable exception of linux, this is
     effectively a no-op. */
      pbuf = xrealloc (pbuf, sizeof (DEV_FD_PREFIX) + strlen (path + 8));
      strcpy (pbuf, DEV_FD_PREFIX);
",unused,bashxenpatch-lib2Fsh2Feaccess.c
"     On most systems, with the notable exception of linux, this is
     effectively a no-op. */
      pbuf = xrealloc (pbuf, sizeof (DEV_FD_PREFIX) + strlen (path + 8));
      strcpy (pbuf, DEV_FD_PREFIX);
      strcat (pbuf, path + 8);
",1,unused,113,unused,"     On most systems, with the notable exception of linux, this is
     effectively a no-op. */
      pbuf = xrealloc (pbuf, sizeof (DEV_FD_PREFIX) + strlen (path + 8));
      strcpy (pbuf, DEV_FD_PREFIX);
      strcat (pbuf, path + 8);
",unused,bashxenpatch-lib2Fsh2Feaccess.c
"  st_ret.st_mode  &= ~S_IFDIR;
  st_ret.st_mode  |= S_IFREG;

  /* See if cur/ is present */
  sprintf(dir, ""%s/cur"", path);
",1,unused,95,unused,"  st_ret.st_mode  &= ~S_IFDIR;
  st_ret.st_mode  |= S_IFREG;

  /* See if cur/ is present */
  sprintf(dir, ""%s/cur"", path);
",unused,bashxenpatch-lib2Fsh2Fmailstat.c
"    return 0;
  st_ret.st_atime = st_tmp.st_atime;

  /* See if tmp/ is present */
  sprintf(dir, ""%s/tmp"", path);
",1,unused,101,unused,"    return 0;
  st_ret.st_atime = st_tmp.st_atime;

  /* See if tmp/ is present */
  sprintf(dir, ""%s/tmp"", path);
",unused,bashxenpatch-lib2Fsh2Fmailstat.c
"    return 0;
  st_ret.st_mtime = st_tmp.st_mtime;

  /* And new/ */
  sprintf(dir, ""%s/new"", path);
",1,unused,107,unused,"    return 0;
  st_ret.st_mtime = st_tmp.st_mtime;

  /* And new/ */
  sprintf(dir, ""%s/new"", path);
",unused,bashxenpatch-lib2Fsh2Fmailstat.c
"
  /* Loop over new/ and cur/ */
  for (i = 0; i < 2; i++)
    {
      sprintf(dir, ""%s/%s"", path, i ? ""cur"" : ""new"");
",1,unused,126,unused,"
  /* Loop over new/ and cur/ */
  for (i = 0; i < 2; i++)
    {
      sprintf(dir, ""%s/%s"", path, i ? ""cur"" : ""new"");
",unused,bashxenpatch-lib2Fsh2Fmailstat.c
"  /* Loop over new/ and cur/ */
  for (i = 0; i < 2; i++)
    {
      sprintf(dir, ""%s/%s"", path, i ? ""cur"" : ""new"");
      sprintf(file, ""%s/"", dir);
",1,unused,127,unused,"  /* Loop over new/ and cur/ */
  for (i = 0; i < 2; i++)
    {
      sprintf(dir, ""%s/%s"", path, i ? ""cur"" : ""new"");
      sprintf(file, ""%s/"", dir);
",unused,bashxenpatch-lib2Fsh2Fmailstat.c
"      while ((fn = readdir(dd)) != NULL)
	{
	  if (fn->d_name[0] == '.' || strlen(fn->d_name) + l >= sizeof(file))
	    continue;
	  strcpy(file + l, fn->d_name);
",1,unused,135,unused,"      while ((fn = readdir(dd)) != NULL)
	{
	  if (fn->d_name[0] == '.' || strlen(fn->d_name) + l >= sizeof(file))
	    continue;
	  strcpy(file + l, fn->d_name);
",unused,bashxenpatch-lib2Fsh2Fmailstat.c
"  char *np, *s, *t;
  int fd;

  np = (char *)xmalloc (strlen (path) + 1);
  strcpy (np, path);
",1,unused,300,unused,"  char *np, *s, *t;
  int fd;

  np = (char *)xmalloc (strlen (path) + 1);
  strcpy (np, path);
",unused,bashxenpatch-lib2Fsh2Fnetopen.c
"    {
      if (result[2] == '\0')	/* short-circuit for bare `//' */
	result[1] = '\0';
      else
	strcpy (result, result + 1);
",1,unused,230,unused,"    {
      if (result[2] == '\0')	/* short-circuit for bare `//' */
	result[1] = '\0';
      else
	strcpy (result, result + 1);
",unused,bashxenpatch-lib2Fsh2Fpathcanon.c
"    workpath = savestring (path);
  else
    {
      workpath = (char *)xmalloc (PATH_MAX + 1);
      strcpy (workpath, path);
",1,unused,101,unused,"    workpath = savestring (path);
  else
    {
      workpath = (char *)xmalloc (PATH_MAX + 1);
      strcpy (workpath, path);
",unused,bashxenpatch-lib2Fsh2Fpathphys.c
"	     buffer and appending the rest of `workpath'.  Reset p to point
	     to the start of the rest of the path.  If the link value is an
	     absolute pathname, reset p, q, and qbase.  If not, reset p
	     and q. */
	  strcpy (tbuf, linkbuf);
",1,unused,208,unused,"	     buffer and appending the rest of `workpath'.  Reset p to point
	     to the start of the rest of the path.  If the link value is an
	     absolute pathname, reset p, q, and qbase.  If not, reset p
	     and q. */
	  strcpy (tbuf, linkbuf);
",unused,bashxenpatch-lib2Fsh2Fpathphys.c
"	     absolute pathname, reset p, q, and qbase.  If not, reset p
	     and q. */
	  strcpy (tbuf, linkbuf);
	  tbuf[linklen] = '/';
	  strcpy (tbuf + linklen, p);
",1,unused,210,unused,"	     absolute pathname, reset p, q, and qbase.  If not, reset p
	     and q. */
	  strcpy (tbuf, linkbuf);
	  tbuf[linklen] = '/';
	  strcpy (tbuf + linklen, p);
",unused,bashxenpatch-lib2Fsh2Fpathphys.c
"	     and q. */
	  strcpy (tbuf, linkbuf);
	  tbuf[linklen] = '/';
	  strcpy (tbuf + linklen, p);
	  strcpy (workpath, tbuf);
",1,unused,211,unused,"	     and q. */
	  strcpy (tbuf, linkbuf);
	  tbuf[linklen] = '/';
	  strcpy (tbuf + linklen, p);
	  strcpy (workpath, tbuf);
",unused,bashxenpatch-lib2Fsh2Fpathphys.c
"    {
      if (result[2] == '\0')	/* short-circuit for bare `//' */
	result[1] = '\0';
      else
	strcpy (result, result + 1);
",1,unused,248,unused,"    {
      if (result[2] == '\0')	/* short-circuit for bare `//' */
	result[1] = '\0';
      else
	strcpy (result, result + 1);
",unused,bashxenpatch-lib2Fsh2Fpathphys.c
"       */
      x = spdist(dp->d_name, guess);
      if (x <= dist && x != 3)
	{
	  strcpy(best, dp->d_name);
",1,unused,134,unused,"       */
      x = spdist(dp->d_name, guess);
      if (x <= dist && x != 3)
	{
	  strcpy(best, dp->d_name);
",unused,bashxenpatch-lib2Fsh2Fspell.c
"      llen = STRLEN (sl->list[i]);
      tlen = plen + llen + slen + 1;
      t = (char *)xmalloc (tlen + 1);
      if (plen)
	strcpy (t, prefix);
",1,unused,214,unused,"      llen = STRLEN (sl->list[i]);
      tlen = plen + llen + slen + 1;
      t = (char *)xmalloc (tlen + 1);
      if (plen)
	strcpy (t, prefix);
",unused,bashxenpatch-lib2Fsh2Fstringlist.c
"      tlen = plen + llen + slen + 1;
      t = (char *)xmalloc (tlen + 1);
      if (plen)
	strcpy (t, prefix);
      strcpy (t + plen, sl->list[i]);
",1,unused,215,unused,"      tlen = plen + llen + slen + 1;
      t = (char *)xmalloc (tlen + 1);
      if (plen)
	strcpy (t, prefix);
      strcpy (t + plen, sl->list[i]);
",unused,bashxenpatch-lib2Fsh2Fstringlist.c
"      if (plen)
	strcpy (t, prefix);
      strcpy (t + plen, sl->list[i]);
      if (slen)
	strcpy (t + plen + llen, suffix);
",1,unused,217,unused,"      if (plen)
	strcpy (t, prefix);
      strcpy (t + plen, sl->list[i]);
      if (slen)
	strcpy (t + plen + llen, suffix);
",unused,bashxenpatch-lib2Fsh2Fstringlist.c
"      filenum = (filenum << 1) ^
		(unsigned long) time ((time_t *)0) ^
		(unsigned long) dollar_dollar_pid ^
		(unsigned long) ((flags & MT_USERANDOM) ? random () : ntmpfiles++);
      sprintf (filename, ""%s/%s-%lu"", tdir, lroot, filenum);
",1,unused,141,unused,"      filenum = (filenum << 1) ^
		(unsigned long) time ((time_t *)0) ^
		(unsigned long) dollar_dollar_pid ^
		(unsigned long) ((flags & MT_USERANDOM) ? random () : ntmpfiles++);
      sprintf (filename, ""%s/%s-%lu"", tdir, lroot, filenum);
",unused,bashxenpatch-lib2Fsh2Ftmpfile.c
"      filenum = (filenum << 1) ^
		(unsigned long) time ((time_t *)0) ^
		(unsigned long) dollar_dollar_pid ^
		(unsigned long) ((flags & MT_USERANDOM) ? random () : ntmpfiles++);
      sprintf (filename, ""%s/%s-%lu"", tdir, lroot, filenum);
",1,unused,190,unused,"      filenum = (filenum << 1) ^
		(unsigned long) time ((time_t *)0) ^
		(unsigned long) dollar_dollar_pid ^
		(unsigned long) ((flags & MT_USERANDOM) ? random () : ntmpfiles++);
      sprintf (filename, ""%s/%s-%lu"", tdir, lroot, filenum);
",unused,bashxenpatch-lib2Fsh2Ftmpfile.c
"
  locale = get_locale_var (""LC_CTYPE"");
  if (locale == 0 || *locale == 0)
    {
      strcpy (charsetbuf, ""ASCII"");
",1,unused,75,unused,"
  locale = get_locale_var (""LC_CTYPE"");
  if (locale == 0 || *locale == 0)
    {
      strcpy (charsetbuf, ""ASCII"");
",unused,bashxenpatch-lib2Fsh2Funicode.c
"{
  int l;

  if (wc < 0x10000)
    l = sprintf (s, ""\\u%04X"", wc);
",1,unused,144,unused,"{
  int l;

  if (wc < 0x10000)
    l = sprintf (s, ""\\u%04X"", wc);
",unused,bashxenpatch-lib2Fsh2Funicode.c
"
  if (wc < 0x10000)
    l = sprintf (s, ""\\u%04X"", wc);
  else
    l = sprintf (s, ""\\u%08X"", wc);
",1,unused,146,unused,"
  if (wc < 0x10000)
    l = sprintf (s, ""\\u%04X"", wc);
  else
    l = sprintf (s, ""\\u%08X"", wc);
",unused,bashxenpatch-lib2Fsh2Funicode.c
"  *optr = '\0';

  /* number of chars to be copied is optr - obuf if we want to do bounds
     checking */
  strcpy (s, obuf);
",1,unused,331,unused,"  *optr = '\0';

  /* number of chars to be copied is optr - obuf if we want to do bounds
     checking */
  strcpy (s, obuf);
",unused,bashxenpatch-lib2Fsh2Funicode.c
"	{
	  if ((result_index + len + 1) > result_size)
	    result = (char *)xrealloc (result, 1 + (result_size += (len + 20)));

	  strcpy (result + result_index, expansion);
",1,unused,251,unused,"	{
	  if ((result_index + len + 1) > result_size)
	    result = (char *)xrealloc (result, 1 + (result_size += (len + 20)));

	  strcpy (result + result_index, expansion);
",unused,bashxenpatch-lib2Ftilde2Ftilde.c
"  plen = (prefix && *prefix) ? strlen (prefix) : 0;
  slen = strlen (suffix + suffind);
  ret = (char *)xmalloc (plen + slen + 1);
  if (plen)
    strcpy (ret, prefix);
",1,unused,334,unused,"  plen = (prefix && *prefix) ? strlen (prefix) : 0;
  slen = strlen (suffix + suffind);
  ret = (char *)xmalloc (plen + slen + 1);
  if (plen)
    strcpy (ret, prefix);
",unused,bashxenpatch-lib2Ftilde2Ftilde.c
"  slen = strlen (suffix + suffind);
  ret = (char *)xmalloc (plen + slen + 1);
  if (plen)
    strcpy (ret, prefix);
  strcpy (ret + plen, suffix + suffind);
",1,unused,335,unused,"  slen = strlen (suffix + suffind);
  ret = (char *)xmalloc (plen + slen + 1);
  if (plen)
    strcpy (ret, prefix);
  strcpy (ret + plen, suffix + suffind);
",unused,bashxenpatch-lib2Ftilde2Ftilde.c
"  if (locale == 0 || locale[0] == '\0' ||
      (locale[0] == 'C' && locale[1] == '\0') || STREQ (locale, ""POSIX""))
    {
      t = (char *)xmalloc (len + 1);
      strcpy (t, string);
",1,unused,391,unused,"  if (locale == 0 || locale[0] == '\0' ||
      (locale[0] == 'C' && locale[1] == '\0') || STREQ (locale, ""POSIX""))
    {
      t = (char *)xmalloc (len + 1);
      strcpy (t, string);
",unused,bashxenpatch-locale.c
"
  if (translated == string)	/* gettext returns its argument if untranslatable */
    {
      t = (char *)xmalloc (len + 1);
      strcpy (t, string);
",1,unused,406,unused,"
  if (translated == string)	/* gettext returns its argument if untranslatable */
    {
      t = (char *)xmalloc (len + 1);
      strcpy (t, string);
",unused,bashxenpatch-locale.c
"  else
    {
      tlen = strlen (translated);
      t = (char *)xmalloc (tlen + 1);
      strcpy (t, translated);
",1,unused,414,unused,"  else
    {
      tlen = strlen (translated);
      t = (char *)xmalloc (tlen + 1);
      strcpy (t, translated);
",unused,bashxenpatch-locale.c
"		 a redirection. */
	      digit_arg = va_arg (args, int);
	      if (digit_arg < 0)
		{
		  sprintf (intbuf, ""%u"", (unsigned)-1);
",1,unused,1503,unused,"		 a redirection. */
	      digit_arg = va_arg (args, int);
	      if (digit_arg < 0)
		{
		  sprintf (intbuf, ""%u"", (unsigned)-1);
",unused,bashxenpatch-print_cmd.c
"
	  alloca_hack = (char *)
	    alloca (1 + strlen (new_redirect->redirectee.filename->word));
	  redirectee->word = alloca_hack;
	  strcpy (redirectee->word, new_redirect->redirectee.filename->word);
",1,unused,803,unused,"
	  alloca_hack = (char *)
	    alloca (1 + strlen (new_redirect->redirectee.filename->word));
	  redirectee->word = alloca_hack;
	  strcpy (redirectee->word, new_redirect->redirectee.filename->word);
",unused,bashxenpatch-redir.c
"
  t = result = (char *)xmalloc (slen + 1);

  if (strchr (string, CTLESC) == 0)
    return (strcpy (result, string));
",1,unused,3610,unused,"
  t = result = (char *)xmalloc (slen + 1);

  if (strchr (string, CTLESC) == 0)
    return (strcpy (result, string));
",unused,bashxenpatch-subst.c
"
  /* If no character in the string can be quoted, don't bother examining
     each character.  Just return a copy of the string passed to us. */
  if (strchr (string, CTLESC) == NULL)
    return (strcpy (result, string));
",1,unused,3729,unused,"
  /* If no character in the string can be quoted, don't bother examining
     each character.  Just return a copy of the string passed to us. */
  if (strchr (string, CTLESC) == NULL)
    return (strcpy (result, string));
",unused,bashxenpatch-subst.c
"
  if (string)
    {
      t = dequote_escapes (string);
      strcpy (string, t);
",1,unused,3798,unused,"
  if (string)
    {
      t = dequote_escapes (string);
      strcpy (string, t);
",unused,bashxenpatch-subst.c
"  char *ret, intbuf[INT_STRLEN_BOUND (int) + 1], *p;

  ret = (char *)xmalloc (sizeof (DEV_FD_PREFIX) + 8);

  strcpy (ret, DEV_FD_PREFIX);
",1,unused,5027,unused,"  char *ret, intbuf[INT_STRLEN_BOUND (int) + 1], *p;

  ret = (char *)xmalloc (sizeof (DEV_FD_PREFIX) + 8);

  strcpy (ret, DEV_FD_PREFIX);
",unused,bashxenpatch-subst.c
"  ret = (char *)xmalloc (sizeof (DEV_FD_PREFIX) + 8);

  strcpy (ret, DEV_FD_PREFIX);
  p = inttostr (fd, intbuf, sizeof (intbuf));
  strcpy (ret + sizeof (DEV_FD_PREFIX) - 1, p);
",1,unused,5029,unused,"  ret = (char *)xmalloc (sizeof (DEV_FD_PREFIX) + 8);

  strcpy (ret, DEV_FD_PREFIX);
  p = inttostr (fd, intbuf, sizeof (intbuf));
  strcpy (ret + sizeof (DEV_FD_PREFIX) - 1, p);
",unused,bashxenpatch-subst.c
"    {
      int sindex;
      tt = (char *)xmalloc (2 + strlen (name));
      tt[sindex = 0] = '$';
      strcpy (tt + 1, name);
",1,unused,5772,unused,"    {
      int sindex;
      tt = (char *)xmalloc (2 + strlen (name));
      tt[sindex = 0] = '$';
      strcpy (tt + 1, name);
",unused,bashxenpatch-subst.c
"      replen = STRLEN (rep);
      l = STRLEN (string);
      ret = (char *)xmalloc (replen + l + 2);
      if (replen == 0)
	strcpy (ret, string);
",1,unused,6653,unused,"      replen = STRLEN (rep);
      l = STRLEN (string);
      ret = (char *)xmalloc (replen + l + 2);
      if (replen == 0)
	strcpy (ret, string);
",unused,bashxenpatch-subst.c
"      if (replen == 0)
	strcpy (ret, string);
      else if (mtype == MATCH_BEG)
	{
	  strcpy (ret, rep);
",1,unused,6656,unused,"      if (replen == 0)
	strcpy (ret, string);
      else if (mtype == MATCH_BEG)
	{
	  strcpy (ret, rep);
",unused,bashxenpatch-subst.c
"	strcpy (ret, string);
      else if (mtype == MATCH_BEG)
	{
	  strcpy (ret, rep);
	  strcpy (ret + replen, string);
",1,unused,6657,unused,"	strcpy (ret, string);
      else if (mtype == MATCH_BEG)
	{
	  strcpy (ret, rep);
	  strcpy (ret + replen, string);
",unused,bashxenpatch-subst.c
"	  strcpy (ret + replen, string);
	}
      else
	{
	  strcpy (ret, string);
",1,unused,6661,unused,"	  strcpy (ret + replen, string);
	}
      else
	{
	  strcpy (ret, string);
",unused,bashxenpatch-subst.c
"	}
      else
	{
	  strcpy (ret, string);
	  strcpy (ret + l, rep);
",1,unused,6662,unused,"	}
      else
	{
	  strcpy (ret, string);
	  strcpy (ret + l, rep);
",unused,bashxenpatch-subst.c
"  /* Now copy the unmatched portion of the input string */
  if (str && *str)
    {
      RESIZE_MALLOCED_BUFFER (ret, rptr, STRLEN(str) + 1, rsize, 64);
      strcpy (ret + rptr, str);
",1,unused,6731,unused,"  /* Now copy the unmatched portion of the input string */
  if (str && *str)
    {
      RESIZE_MALLOCED_BUFFER (ret, rptr, STRLEN(str) + 1, rsize, 64);
      strcpy (ret + rptr, str);
",unused,bashxenpatch-subst.c
"      if (string[sindex] == '!')
	{
	  /* indirect reference of $#, $?, $@, or $* */
	  name[1] = string[sindex + 1];
	  strcpy (name + 2, temp1);
",1,unused,7178,unused,"      if (string[sindex] == '!')
	{
	  /* indirect reference of $#, $?, $@, or $* */
	  name[1] = string[sindex + 1];
	  strcpy (name + 2, temp1);
",unused,bashxenpatch-subst.c
"	  name[1] = string[sindex + 1];
	  strcpy (name + 2, temp1);
	}
      else	
	strcpy (name + 1, temp1);
",1,unused,7181,unused,"	  name[1] = string[sindex + 1];
	  strcpy (name + 2, temp1);
	}
      else	
	strcpy (name + 1, temp1);
",unused,bashxenpatch-subst.c
"	  tindex = sindex + 1;
	  temp = string_extract_single_quoted (string, &tindex);
	  if (temp)
	    {
	      strcpy (r, temp);
",1,unused,8961,unused,"	  tindex = sindex + 1;
	  temp = string_extract_single_quoted (string, &tindex);
	  if (temp)
	    {
	      strcpy (r, temp);
",unused,bashxenpatch-subst.c
"      if (cdir)
	{
	  len = strlen (cdir);
	  name = (char *)xmalloc (len + strlen (shell_name) + 1);
	  strcpy (name, cdir);
",1,unused,731,unused,"      if (cdir)
	{
	  len = strlen (cdir);
	  name = (char *)xmalloc (len + strlen (shell_name) + 1);
	  strcpy (name, cdir);
",unused,bashxenpatch-variables.c
"	{
	  len = strlen (cdir);
	  name = (char *)xmalloc (len + strlen (shell_name) + 1);
	  strcpy (name, cdir);
	  strcpy (name + len, shell_name + 1);
",1,unused,732,unused,"	{
	  len = strlen (cdir);
	  name = (char *)xmalloc (len + strlen (shell_name) + 1);
	  strcpy (name, cdir);
	  strcpy (name + len, shell_name + 1);
",unused,bashxenpatch-variables.c
"  unbind_variable (""BASH_VERSINFO"");

  vv = make_new_array_variable (""BASH_VERSINFO"");
  av = array_cell (vv);
  strcpy (d, dist_version);
",1,unused,930,unused,"  unbind_variable (""BASH_VERSINFO"");

  vv = make_new_array_variable (""BASH_VERSINFO"");
  av = array_cell (vv);
  strcpy (d, dist_version);
",unused,bashxenpatch-variables.c
"	  if (oval == 0)	/* paranoia */
	    oval = """";
	  olen = STRLEN (oval);
	  retval = (char *)xmalloc (olen + (value ? STRLEN (value) : 0) + 1);
	  strcpy (retval, oval);
",1,unused,2469,unused,"	  if (oval == 0)	/* paranoia */
	    oval = """";
	  olen = STRLEN (oval);
	  retval = (char *)xmalloc (olen + (value ? STRLEN (value) : 0) + 1);
	  strcpy (retval, oval);
",unused,bashxenpatch-variables.c
"	  olen = STRLEN (oval);
	  retval = (char *)xmalloc (olen + (value ? STRLEN (value) : 0) + 1);
	  strcpy (retval, oval);
	  if (value)
	    strcpy (retval+olen, value);
",1,unused,2471,unused,"	  olen = STRLEN (oval);
	  retval = (char *)xmalloc (olen + (value ? STRLEN (value) : 0) + 1);
	  strcpy (retval, oval);
	  if (value)
	    strcpy (retval+olen, value);
",unused,bashxenpatch-variables.c
"	  if (oval == 0)	/* paranoia */
	    oval = """";
	  olen = STRLEN (oval);
	  retval = (char *)xmalloc (olen + (value ? STRLEN (value) : 0) + 1);
	  strcpy (retval, oval);
",1,unused,2496,unused,"	  if (oval == 0)	/* paranoia */
	    oval = """";
	  olen = STRLEN (oval);
	  retval = (char *)xmalloc (olen + (value ? STRLEN (value) : 0) + 1);
	  strcpy (retval, oval);
",unused,bashxenpatch-variables.c
"	  olen = STRLEN (oval);
	  retval = (char *)xmalloc (olen + (value ? STRLEN (value) : 0) + 1);
	  strcpy (retval, oval);
	  if (value)
	    strcpy (retval+olen, value);
",1,unused,2498,unused,"	  olen = STRLEN (oval);
	  retval = (char *)xmalloc (olen + (value ? STRLEN (value) : 0) + 1);
	  strcpy (retval, oval);
	  if (value)
	    strcpy (retval+olen, value);
",unused,bashxenpatch-variables.c
"{
  char *evar;

  evar = (char *)xmalloc (STRLEN (value) + preflen + 1);
  strcpy (evar, env_prefix);
",1,unused,4280,unused,"{
  char *evar;

  evar = (char *)xmalloc (STRLEN (value) + preflen + 1);
  strcpy (evar, env_prefix);
",unused,bashxenpatch-variables.c
"
  evar = (char *)xmalloc (STRLEN (value) + preflen + 1);
  strcpy (evar, env_prefix);
  if (value)
    strcpy (evar + preflen, value);
",1,unused,4282,unused,"
  evar = (char *)xmalloc (STRLEN (value) + preflen + 1);
  strcpy (evar, env_prefix);
  if (value)
    strcpy (evar + preflen, value);
",unused,bashxenpatch-variables.c
"  char *r;

  l = strlen (s);
  r = xmalloc (l + 2);
  strcpy (r, s);
",1,unused,5063,unused,"  char *r;

  l = strlen (s);
  r = xmalloc (l + 2);
  strcpy (r, s);
",unused,bashxenpatch-y.tab.c
"	    return -1;		/* Bail immediately. */
	  RESIZE_MALLOCED_BUFFER (token, token_index, ttoklen + 2,
				  token_buffer_size, TOKEN_DEFAULT_GROW_SIZE);
	  token[token_index++] = character;
	  strcpy (token + token_index, ttok);
",1,unused,6884,unused,"	    return -1;		/* Bail immediately. */
	  RESIZE_MALLOCED_BUFFER (token, token_index, ttoklen + 2,
				  token_buffer_size, TOKEN_DEFAULT_GROW_SIZE);
	  token[token_index++] = character;
	  strcpy (token + token_index, ttok);
",unused,bashxenpatch-y.tab.c
"	    return -1;		/* Bail immediately. */
	  RESIZE_MALLOCED_BUFFER (token, token_index, ttoklen + 2,
				  token_buffer_size, TOKEN_DEFAULT_GROW_SIZE);
	  token[token_index++] = character;
	  strcpy (token + token_index, ttok);
",1,unused,6910,unused,"	    return -1;		/* Bail immediately. */
	  RESIZE_MALLOCED_BUFFER (token, token_index, ttoklen + 2,
				  token_buffer_size, TOKEN_DEFAULT_GROW_SIZE);
	  token[token_index++] = character;
	  strcpy (token + token_index, ttok);
",unused,bashxenpatch-y.tab.c
"				      token_buffer_size,
				      TOKEN_DEFAULT_GROW_SIZE);
	      token[token_index++] = character;
	      token[token_index++] = peek_char;
	      strcpy (token + token_index, ttok);
",1,unused,6935,unused,"				      token_buffer_size,
				      TOKEN_DEFAULT_GROW_SIZE);
	      token[token_index++] = character;
	      token[token_index++] = peek_char;
	      strcpy (token + token_index, ttok);
",unused,bashxenpatch-y.tab.c
"				      token_buffer_size,
				      TOKEN_DEFAULT_GROW_SIZE);
	      token[token_index++] = character;
	      token[token_index++] = peek_char;
	      strcpy (token + token_index, ttok);
",1,unused,6977,unused,"				      token_buffer_size,
				      TOKEN_DEFAULT_GROW_SIZE);
	      token[token_index++] = character;
	      token[token_index++] = peek_char;
	      strcpy (token + token_index, ttok);
",unused,bashxenpatch-y.tab.c
"
	      RESIZE_MALLOCED_BUFFER (token, token_index, ttranslen + 1,
				      token_buffer_size,
				      TOKEN_DEFAULT_GROW_SIZE);
	      strcpy (token + token_index, ttrans);
",1,unused,7026,unused,"
	      RESIZE_MALLOCED_BUFFER (token, token_index, ttranslen + 1,
				      token_buffer_size,
				      TOKEN_DEFAULT_GROW_SIZE);
	      strcpy (token + token_index, ttrans);
",unused,bashxenpatch-y.tab.c
"	  RESIZE_MALLOCED_BUFFER (token, token_index, ttoklen + 2,
				  token_buffer_size,
				  TOKEN_DEFAULT_GROW_SIZE);
	  token[token_index++] = character;
	  strcpy (token + token_index, ttok);
",1,unused,7065,unused,"	  RESIZE_MALLOCED_BUFFER (token, token_index, ttoklen + 2,
				  token_buffer_size,
				  TOKEN_DEFAULT_GROW_SIZE);
	  token[token_index++] = character;
	  strcpy (token + token_index, ttok);
",unused,bashxenpatch-y.tab.c
"	      token[token_index++] = '=';
	      token[token_index++] = '(';
	      if (ttok)
		{
		  strcpy (token + token_index, ttok);
",1,unused,7087,unused,"	      token[token_index++] = '=';
	      token[token_index++] = '(';
	      if (ttok)
		{
		  strcpy (token + token_index, ttok);
",unused,bashxenpatch-y.tab.c
"
  the_word = (WORD_DESC *)xmalloc (sizeof (WORD_DESC));
  the_word->word = (char *)xmalloc (1 + token_index);
  the_word->flags = 0;
  strcpy (the_word->word, token);
",1,unused,7194,unused,"
  the_word = (WORD_DESC *)xmalloc (sizeof (WORD_DESC));
  the_word->word = (char *)xmalloc (1 + token_index);
  the_word->flags = 0;
  strcpy (the_word->word, token);
",unused,bashxenpatch-y.tab.c
"#else
      if (legal_identifier (token+1))
#endif
	{
	  strcpy (the_word->word, token+1);
",1,unused,7239,unused,"#else
      if (legal_identifier (token+1))
#endif
	{
	  strcpy (the_word->word, token+1);
",unused,bashxenpatch-y.tab.c
"	    case 'v':
	    case 'V':
	      temp = (char *)xmalloc (16);
	      if (c == 'v')
		strcpy (temp, dist_version);
",1,unused,7732,unused,"	    case 'v':
	    case 'V':
	      temp = (char *)xmalloc (16);
	      if (c == 'v')
		strcpy (temp, dist_version);
",unused,bashxenpatch-y.tab.c
"	      temp = (char *)xmalloc (16);
	      if (c == 'v')
		strcpy (temp, dist_version);
	      else
		sprintf (temp, ""%s.%d"", dist_version, patch_level);
",1,unused,7734,unused,"	      temp = (char *)xmalloc (16);
	      if (c == 'v')
		strcpy (temp, dist_version);
	      else
		sprintf (temp, ""%s.%d"", dist_version, patch_level);
",unused,bashxenpatch-y.tab.c
"		    /* polite_directory_format is guaranteed to return a string
		       no longer than PATH_MAX - 1 characters. */
		    temp = polite_directory_format (t_string);
		    if (temp != t_string)
		      strcpy (t_string, temp);
",1,unused,7790,unused,"		    /* polite_directory_format is guaranteed to return a string
		       no longer than PATH_MAX - 1 characters. */
		    temp = polite_directory_format (t_string);
		    if (temp != t_string)
		      strcpy (t_string, temp);
",unused,bashxenpatch-y.tab.c
"			      if (break_label == 0)
				yyerror (""Break outside a for/while"");
			      else
				{
				  sprintf (genstr, ""J%1d:"", break_label);
",1,unused,1557,unused,"			      if (break_label == 0)
				yyerror (""Break outside a for/while"");
			      else
				{
				  sprintf (genstr, ""J%1d:"", break_label);
",unused,bcdebstretche-bc2Fbc.c
"			      if (continue_label == 0)
				yyerror (""Continue outside a for"");
			      else
				{
				  sprintf (genstr, ""J%1d:"", continue_label);
",1,unused,1571,unused,"			      if (continue_label == 0)
				yyerror (""Continue outside a for"");
			      else
				{
				  sprintf (genstr, ""J%1d:"", continue_label);
",unused,bcdebstretche-bc2Fbc.c
"				yyerror (""first expression is void"");
			      if (!((yyvsp[-1].i_value) & EX_EMPTY))
				generate (""p"");
			      (yyvsp[-1].i_value) = next_label++;
			      sprintf (genstr, ""N%1d:"", (yyvsp[-1].i_value));
",1,unused,1610,unused,"				yyerror (""first expression is void"");
			      if (!((yyvsp[-1].i_value) & EX_EMPTY))
				generate (""p"");
			      (yyvsp[-1].i_value) = next_label++;
			      sprintf (genstr, ""N%1d:"", (yyvsp[-1].i_value));
",unused,bcdebstretche-bc2Fbc.c
"			      if ((yyvsp[-1].i_value) & EX_VOID)
				yyerror (""second expression is void"");
			      if ((yyvsp[-1].i_value) & EX_EMPTY ) generate (""1"");
			      (yyvsp[-1].i_value) = next_label++;
			      sprintf (genstr, ""B%1d:J%1d:"", (yyvsp[-1].i_value), break_label);
",1,unused,1622,unused,"			      if ((yyvsp[-1].i_value) & EX_VOID)
				yyerror (""second expression is void"");
			      if ((yyvsp[-1].i_value) & EX_EMPTY ) generate (""1"");
			      (yyvsp[-1].i_value) = next_label++;
			      sprintf (genstr, ""B%1d:J%1d:"", (yyvsp[-1].i_value), break_label);
",unused,bcdebstretche-bc2Fbc.c
"			      sprintf (genstr, ""B%1d:J%1d:"", (yyvsp[-1].i_value), break_label);
			      generate (genstr);
			      (yyval.i_value) = continue_label;
			      continue_label = next_label++;
			      sprintf (genstr, ""N%1d:"", continue_label);
",1,unused,1626,unused,"			      sprintf (genstr, ""B%1d:J%1d:"", (yyvsp[-1].i_value), break_label);
			      generate (genstr);
			      (yyval.i_value) = continue_label;
			      continue_label = next_label++;
			      sprintf (genstr, ""N%1d:"", continue_label);
",unused,bcdebstretche-bc2Fbc.c
"				warn (""Comparison in third for expression"");
			      if ((yyvsp[-1].i_value) & EX_VOID)
				yyerror (""third expression is void"");
			      if ((yyvsp[-1].i_value) & EX_EMPTY)
				sprintf (genstr, ""J%1d:N%1d:"", (yyvsp[-7].i_value), (yyvsp[-4].i_value));
",1,unused,1639,unused,"				warn (""Comparison in third for expression"");
			      if ((yyvsp[-1].i_value) & EX_VOID)
				yyerror (""third expression is void"");
			      if ((yyvsp[-1].i_value) & EX_EMPTY)
				sprintf (genstr, ""J%1d:N%1d:"", (yyvsp[-7].i_value), (yyvsp[-4].i_value));
",unused,bcdebstretche-bc2Fbc.c
"				yyerror (""third expression is void"");
			      if ((yyvsp[-1].i_value) & EX_EMPTY)
				sprintf (genstr, ""J%1d:N%1d:"", (yyvsp[-7].i_value), (yyvsp[-4].i_value));
			      else
				sprintf (genstr, ""pJ%1d:N%1d:"", (yyvsp[-7].i_value), (yyvsp[-4].i_value));
",1,unused,1641,unused,"				yyerror (""third expression is void"");
			      if ((yyvsp[-1].i_value) & EX_EMPTY)
				sprintf (genstr, ""J%1d:N%1d:"", (yyvsp[-7].i_value), (yyvsp[-4].i_value));
			      else
				sprintf (genstr, ""pJ%1d:N%1d:"", (yyvsp[-7].i_value), (yyvsp[-4].i_value));
",unused,bcdebstretche-bc2Fbc.c
"
  case 34:
#line 256 ""bc.y""
    {
			      sprintf (genstr, ""J%1d:N%1d:"",
",1,unused,1649,unused,"
  case 34:
#line 256 ""bc.y""
    {
			      sprintf (genstr, ""J%1d:N%1d:"",
",unused,bcdebstretche-bc2Fbc.c
"			      if ((yyvsp[-1].i_value) & EX_VOID)
				yyerror (""void expression"");
			      (yyvsp[-1].i_value) = if_label;
			      if_label = next_label++;
			      sprintf (genstr, ""Z%1d:"", if_label);
",1,unused,1664,unused,"			      if ((yyvsp[-1].i_value) & EX_VOID)
				yyerror (""void expression"");
			      (yyvsp[-1].i_value) = if_label;
			      if_label = next_label++;
			      sprintf (genstr, ""Z%1d:"", if_label);
",unused,bcdebstretche-bc2Fbc.c
"
  case 36:
#line 273 ""bc.y""
    {
			      sprintf (genstr, ""N%1d:"", if_label); 
",1,unused,1672,unused,"
  case 36:
#line 273 ""bc.y""
    {
			      sprintf (genstr, ""N%1d:"", if_label); 
",unused,bcdebstretche-bc2Fbc.c
"  case 37:
#line 279 ""bc.y""
    {
			      (yyvsp[0].i_value) = next_label++;
			      sprintf (genstr, ""N%1d:"", (yyvsp[0].i_value));
",1,unused,1682,unused,"  case 37:
#line 279 ""bc.y""
    {
			      (yyvsp[0].i_value) = next_label++;
			      sprintf (genstr, ""N%1d:"", (yyvsp[0].i_value));
",unused,bcdebstretche-bc2Fbc.c
"			      if ((yyvsp[0].i_value) & EX_VOID)
				yyerror (""void expression"");
			      (yyvsp[0].i_value) = break_label; 
			      break_label = next_label++;
			      sprintf (genstr, ""Z%1d:"", break_label);
",1,unused,1694,unused,"			      if ((yyvsp[0].i_value) & EX_VOID)
				yyerror (""void expression"");
			      (yyvsp[0].i_value) = break_label; 
			      break_label = next_label++;
			      sprintf (genstr, ""Z%1d:"", break_label);
",unused,bcdebstretche-bc2Fbc.c
"
  case 39:
#line 294 ""bc.y""
    {
			      sprintf (genstr, ""J%1d:N%1d:"", (yyvsp[-7].i_value), break_label);
",1,unused,1702,unused,"
  case 39:
#line 294 ""bc.y""
    {
			      sprintf (genstr, ""J%1d:N%1d:"", (yyvsp[-7].i_value), break_label);
",unused,bcdebstretche-bc2Fbc.c
"#line 323 ""bc.y""
    {
			      warn (""else clause in if statement"");
			      (yyvsp[0].i_value) = next_label++;
			      sprintf (genstr, ""J%d:N%1d:"", (yyvsp[0].i_value), if_label); 
",1,unused,1741,unused,"#line 323 ""bc.y""
    {
			      warn (""else clause in if statement"");
			      (yyvsp[0].i_value) = next_label++;
			      sprintf (genstr, ""J%d:N%1d:"", (yyvsp[0].i_value), if_label); 
",unused,bcdebstretche-bc2Fbc.c
"			      autos  = arg_str ((yyvsp[0].a_value));
			      set_genstr_size (30 + strlen (params)
					       + strlen (autos));
			      cur_func = lookup((yyvsp[-7].s_value),FUNCTDEF);
			      sprintf (genstr, ""F%d,%s.%s["", cur_func, params,
",1,unused,1757,unused,"			      autos  = arg_str ((yyvsp[0].a_value));
			      set_genstr_size (30 + strlen (params)
					       + strlen (autos));
			      cur_func = lookup((yyvsp[-7].s_value),FUNCTDEF);
			      sprintf (genstr, ""F%d,%s.%s["", cur_func, params,
",unused,bcdebstretche-bc2Fbc.c
"
  case 70:
#line 415 ""bc.y""
    {
			      sprintf (genstr, ""K%d:"", -lookup ((yyvsp[-2].s_value),ARRAY));
",1,unused,1877,unused,"
  case 70:
#line 415 ""bc.y""
    {
			      sprintf (genstr, ""K%d:"", -lookup ((yyvsp[-2].s_value),ARRAY));
",unused,bcdebstretche-bc2Fbc.c
"
  case 72:
#line 429 ""bc.y""
    {
			      sprintf (genstr, ""K%d:"", -lookup ((yyvsp[-2].s_value),ARRAY));
",1,unused,1897,unused,"
  case 72:
#line 429 ""bc.y""
    {
			      sprintf (genstr, ""K%d:"", -lookup ((yyvsp[-2].s_value),ARRAY));
",unused,bcdebstretche-bc2Fbc.c
"    {
			      if ((yyvsp[0].c_value) != '=')
				{
				  if ((yyvsp[-1].i_value) < 0)
				    sprintf (genstr, ""DL%d:"", -(yyvsp[-1].i_value));
",1,unused,1943,unused,"    {
			      if ((yyvsp[0].c_value) != '=')
				{
				  if ((yyvsp[-1].i_value) < 0)
				    sprintf (genstr, ""DL%d:"", -(yyvsp[-1].i_value));
",unused,bcdebstretche-bc2Fbc.c
"				{
				  if ((yyvsp[-1].i_value) < 0)
				    sprintf (genstr, ""DL%d:"", -(yyvsp[-1].i_value));
				  else
				    sprintf (genstr, ""l%d:"", (yyvsp[-1].i_value));
",1,unused,1945,unused,"				{
				  if ((yyvsp[-1].i_value) < 0)
				    sprintf (genstr, ""DL%d:"", -(yyvsp[-1].i_value));
				  else
				    sprintf (genstr, ""l%d:"", (yyvsp[-1].i_value));
",unused,bcdebstretche-bc2Fbc.c
"			      if ((yyvsp[0].i_value) & EX_VOID)
				yyerror(""Assignment of a void expression"");
			      if ((yyvsp[-2].c_value) != '=')
				{
				  sprintf (genstr, ""%c"", (yyvsp[-2].c_value));
",1,unused,1960,unused,"			      if ((yyvsp[0].i_value) & EX_VOID)
				yyerror(""Assignment of a void expression"");
			      if ((yyvsp[-2].c_value) != '=')
				{
				  sprintf (genstr, ""%c"", (yyvsp[-2].c_value));
",unused,bcdebstretche-bc2Fbc.c
"				  sprintf (genstr, ""%c"", (yyvsp[-2].c_value));
				  generate (genstr);
				}
			      if ((yyvsp[-3].i_value) < 0)
				sprintf (genstr, ""S%d:"", -(yyvsp[-3].i_value));
",1,unused,1964,unused,"				  sprintf (genstr, ""%c"", (yyvsp[-2].c_value));
				  generate (genstr);
				}
			      if ((yyvsp[-3].i_value) < 0)
				sprintf (genstr, ""S%d:"", -(yyvsp[-3].i_value));
",unused,bcdebstretche-bc2Fbc.c
"				}
			      if ((yyvsp[-3].i_value) < 0)
				sprintf (genstr, ""S%d:"", -(yyvsp[-3].i_value));
			      else
				sprintf (genstr, ""s%d:"", (yyvsp[-3].i_value));
",1,unused,1966,unused,"				}
			      if ((yyvsp[-3].i_value) < 0)
				sprintf (genstr, ""S%d:"", -(yyvsp[-3].i_value));
			      else
				sprintf (genstr, ""s%d:"", (yyvsp[-3].i_value));
",unused,bcdebstretche-bc2Fbc.c
"#line 503 ""bc.y""
    {
			      warn(""&& operator"");
			      (yyvsp[0].i_value) = next_label++;
			      sprintf (genstr, ""DZ%d:p"", (yyvsp[0].i_value));
",1,unused,1977,unused,"#line 503 ""bc.y""
    {
			      warn(""&& operator"");
			      (yyvsp[0].i_value) = next_label++;
			      sprintf (genstr, ""DZ%d:p"", (yyvsp[0].i_value));
",unused,bcdebstretche-bc2Fbc.c
"#line 510 ""bc.y""
    {
			      if (((yyvsp[-3].i_value) & EX_VOID) || ((yyvsp[0].i_value) & EX_VOID))
				yyerror (""void expression with &&"");
			      sprintf (genstr, ""DZ%d:p1N%d:"", (yyvsp[-2].i_value), (yyvsp[-2].i_value));
",1,unused,1987,unused,"#line 510 ""bc.y""
    {
			      if (((yyvsp[-3].i_value) & EX_VOID) || ((yyvsp[0].i_value) & EX_VOID))
				yyerror (""void expression with &&"");
			      sprintf (genstr, ""DZ%d:p1N%d:"", (yyvsp[-2].i_value), (yyvsp[-2].i_value));
",unused,bcdebstretche-bc2Fbc.c
"#line 518 ""bc.y""
    {
			      warn(""|| operator"");
			      (yyvsp[0].i_value) = next_label++;
			      sprintf (genstr, ""B%d:"", (yyvsp[0].i_value));
",1,unused,1998,unused,"#line 518 ""bc.y""
    {
			      warn(""|| operator"");
			      (yyvsp[0].i_value) = next_label++;
			      sprintf (genstr, ""B%d:"", (yyvsp[0].i_value));
",unused,bcdebstretche-bc2Fbc.c
"			      int tmplab;
			      if (((yyvsp[-3].i_value) & EX_VOID) || ((yyvsp[0].i_value) & EX_VOID))
				yyerror (""void expression with ||"");
			      tmplab = next_label++;
			      sprintf (genstr, ""B%d:0J%d:N%d:1N%d:"",
",1,unused,2010,unused,"			      int tmplab;
			      if (((yyvsp[-3].i_value) & EX_VOID) || ((yyvsp[0].i_value) & EX_VOID))
				yyerror (""void expression with ||"");
			      tmplab = next_label++;
			      sprintf (genstr, ""B%d:0J%d:N%d:1N%d:"",
",unused,bcdebstretche-bc2Fbc.c
"#line 623 ""bc.y""
    {
			      (yyval.i_value) = EX_REG;
			      if ((yyvsp[0].i_value) < 0)
				sprintf (genstr, ""L%d:"", -(yyvsp[0].i_value));
",1,unused,2136,unused,"#line 623 ""bc.y""
    {
			      (yyval.i_value) = EX_REG;
			      if ((yyvsp[0].i_value) < 0)
				sprintf (genstr, ""L%d:"", -(yyvsp[0].i_value));
",unused,bcdebstretche-bc2Fbc.c
"			      (yyval.i_value) = EX_REG;
			      if ((yyvsp[0].i_value) < 0)
				sprintf (genstr, ""L%d:"", -(yyvsp[0].i_value));
			      else
				sprintf (genstr, ""l%d:"", (yyvsp[0].i_value));
",1,unused,2138,unused,"			      (yyval.i_value) = EX_REG;
			      if ((yyvsp[0].i_value) < 0)
				sprintf (genstr, ""L%d:"", -(yyvsp[0].i_value));
			      else
				sprintf (genstr, ""l%d:"", (yyvsp[0].i_value));
",unused,bcdebstretche-bc2Fbc.c
"				(yyval.i_value) = EX_REG;
			      if ((yyvsp[-1].a_value) != NULL)
				{ char *params = call_str ((yyvsp[-1].a_value));
				  set_genstr_size (20 + strlen (params));
				  sprintf (genstr, ""C%d,%s:"", fn, params);
",1,unused,2182,unused,"				(yyval.i_value) = EX_REG;
			      if ((yyvsp[-1].a_value) != NULL)
				{ char *params = call_str ((yyvsp[-1].a_value));
				  set_genstr_size (20 + strlen (params));
				  sprintf (genstr, ""C%d,%s:"", fn, params);
",unused,bcdebstretche-bc2Fbc.c
"				  free_args ((yyvsp[-1].a_value));
				}
			      else
				{
				  sprintf (genstr, ""C%d:"", fn);
",1,unused,2187,unused,"				  free_args ((yyvsp[-1].a_value));
				}
			      else
				{
				  sprintf (genstr, ""C%d:"", fn);
",unused,bcdebstretche-bc2Fbc.c
"			      (yyval.i_value) = EX_REG;
			      if ((yyvsp[0].i_value) < 0)
				{
				  if ((yyvsp[-1].c_value) == '+')
				    sprintf (genstr, ""DA%d:L%d:"", -(yyvsp[0].i_value), -(yyvsp[0].i_value));
",1,unused,2200,unused,"			      (yyval.i_value) = EX_REG;
			      if ((yyvsp[0].i_value) < 0)
				{
				  if ((yyvsp[-1].c_value) == '+')
				    sprintf (genstr, ""DA%d:L%d:"", -(yyvsp[0].i_value), -(yyvsp[0].i_value));
",unused,bcdebstretche-bc2Fbc.c
"				{
				  if ((yyvsp[-1].c_value) == '+')
				    sprintf (genstr, ""DA%d:L%d:"", -(yyvsp[0].i_value), -(yyvsp[0].i_value));
				  else
				    sprintf (genstr, ""DM%d:L%d:"", -(yyvsp[0].i_value), -(yyvsp[0].i_value));
",1,unused,2202,unused,"				{
				  if ((yyvsp[-1].c_value) == '+')
				    sprintf (genstr, ""DA%d:L%d:"", -(yyvsp[0].i_value), -(yyvsp[0].i_value));
				  else
				    sprintf (genstr, ""DM%d:L%d:"", -(yyvsp[0].i_value), -(yyvsp[0].i_value));
",unused,bcdebstretche-bc2Fbc.c
"				}
			      else
				{
				  if ((yyvsp[-1].c_value) == '+')
				    sprintf (genstr, ""i%d:l%d:"", (yyvsp[0].i_value), (yyvsp[0].i_value));
",1,unused,2207,unused,"				}
			      else
				{
				  if ((yyvsp[-1].c_value) == '+')
				    sprintf (genstr, ""i%d:l%d:"", (yyvsp[0].i_value), (yyvsp[0].i_value));
",unused,bcdebstretche-bc2Fbc.c
"				{
				  if ((yyvsp[-1].c_value) == '+')
				    sprintf (genstr, ""i%d:l%d:"", (yyvsp[0].i_value), (yyvsp[0].i_value));
				  else
				    sprintf (genstr, ""d%d:l%d:"", (yyvsp[0].i_value), (yyvsp[0].i_value));
",1,unused,2209,unused,"				{
				  if ((yyvsp[-1].c_value) == '+')
				    sprintf (genstr, ""i%d:l%d:"", (yyvsp[0].i_value), (yyvsp[0].i_value));
				  else
				    sprintf (genstr, ""d%d:l%d:"", (yyvsp[0].i_value), (yyvsp[0].i_value));
",unused,bcdebstretche-bc2Fbc.c
"    {
			      (yyval.i_value) = EX_REG;
			      if ((yyvsp[-1].i_value) < 0)
				{
				  sprintf (genstr, ""DL%d:x"", -(yyvsp[-1].i_value));
",1,unused,2221,unused,"    {
			      (yyval.i_value) = EX_REG;
			      if ((yyvsp[-1].i_value) < 0)
				{
				  sprintf (genstr, ""DL%d:x"", -(yyvsp[-1].i_value));
",unused,bcdebstretche-bc2Fbc.c
"				{
				  sprintf (genstr, ""DL%d:x"", -(yyvsp[-1].i_value));
				  generate (genstr); 
				  if ((yyvsp[0].c_value) == '+')
				    sprintf (genstr, ""A%d:"", -(yyvsp[-1].i_value));
",1,unused,2224,unused,"				{
				  sprintf (genstr, ""DL%d:x"", -(yyvsp[-1].i_value));
				  generate (genstr); 
				  if ((yyvsp[0].c_value) == '+')
				    sprintf (genstr, ""A%d:"", -(yyvsp[-1].i_value));
",unused,bcdebstretche-bc2Fbc.c
"				  generate (genstr); 
				  if ((yyvsp[0].c_value) == '+')
				    sprintf (genstr, ""A%d:"", -(yyvsp[-1].i_value));
				  else
				      sprintf (genstr, ""M%d:"", -(yyvsp[-1].i_value));
",1,unused,2226,unused,"				  generate (genstr); 
				  if ((yyvsp[0].c_value) == '+')
				    sprintf (genstr, ""A%d:"", -(yyvsp[-1].i_value));
				  else
				      sprintf (genstr, ""M%d:"", -(yyvsp[-1].i_value));
",unused,bcdebstretche-bc2Fbc.c
"				      sprintf (genstr, ""M%d:"", -(yyvsp[-1].i_value));
				}
			      else
				{
				  sprintf (genstr, ""l%d:"", (yyvsp[-1].i_value));
",1,unused,2230,unused,"				      sprintf (genstr, ""M%d:"", -(yyvsp[-1].i_value));
				}
			      else
				{
				  sprintf (genstr, ""l%d:"", (yyvsp[-1].i_value));
",unused,bcdebstretche-bc2Fbc.c
"				{
				  sprintf (genstr, ""l%d:"", (yyvsp[-1].i_value));
				  generate (genstr);
				  if ((yyvsp[0].c_value) == '+')
				    sprintf (genstr, ""i%d:"", (yyvsp[-1].i_value));
",1,unused,2233,unused,"				{
				  sprintf (genstr, ""l%d:"", (yyvsp[-1].i_value));
				  generate (genstr);
				  if ((yyvsp[0].c_value) == '+')
				    sprintf (genstr, ""i%d:"", (yyvsp[-1].i_value));
",unused,bcdebstretche-bc2Fbc.c
"				  generate (genstr);
				  if ((yyvsp[0].c_value) == '+')
				    sprintf (genstr, ""i%d:"", (yyvsp[-1].i_value));
				  else
				    sprintf (genstr, ""d%d:"", (yyvsp[-1].i_value));
",1,unused,2235,unused,"				  generate (genstr);
				  if ((yyvsp[0].c_value) == '+')
				    sprintf (genstr, ""i%d:"", (yyvsp[-1].i_value));
				  else
				    sprintf (genstr, ""d%d:"", (yyvsp[-1].i_value));
",unused,bcdebstretche-bc2Fbc.c
"{
  char *temp;

  temp = (char *) bc_malloc (strlen (str)+1);
  return (strcpy (temp,str));
",1,unused,51,unused,"{
  char *temp;

  temp = (char *) bc_malloc (strlen (str)+1);
  return (strcpy (temp,str));
",unused,bcdebstretche-bc2Futil.c
"
  /* Add the current number to the end of the string. */
  if (args->arg_is_var)
    if (len != 1) 
      sprintf (sval, ""*%d,"", args->av_name);
",1,unused,109,unused,"
  /* Add the current number to the end of the string. */
  if (args->arg_is_var)
    if (len != 1) 
      sprintf (sval, ""*%d,"", args->av_name);
",unused,bcdebstretche-bc2Futil.c
"  if (args->arg_is_var)
    if (len != 1) 
      sprintf (sval, ""*%d,"", args->av_name);
    else
      sprintf (sval, ""*%d"", args->av_name);
",1,unused,111,unused,"  if (args->arg_is_var)
    if (len != 1) 
      sprintf (sval, ""*%d,"", args->av_name);
    else
      sprintf (sval, ""*%d"", args->av_name);
",unused,bcdebstretche-bc2Futil.c
"    else
      sprintf (sval, ""*%d"", args->av_name);
  else
    if (len != 1) 
      sprintf (sval, ""%d,"", args->av_name);
",1,unused,114,unused,"    else
      sprintf (sval, ""*%d"", args->av_name);
  else
    if (len != 1) 
      sprintf (sval, ""%d,"", args->av_name);
",unused,bcdebstretche-bc2Futil.c
"  else
    if (len != 1) 
      sprintf (sval, ""%d,"", args->av_name);
    else
      sprintf (sval, ""%d"", args->av_name);
",1,unused,116,unused,"  else
    if (len != 1) 
      sprintf (sval, ""%d,"", args->av_name);
    else
      sprintf (sval, ""%d"", args->av_name);
",unused,bcdebstretche-bc2Futil.c
"    if (len != 1) 
      sprintf (sval, ""%d,"", args->av_name);
    else
      sprintf (sval, ""%d"", args->av_name);
  temp = strcat (temp, sval);
",1,unused,117,unused,"    if (len != 1) 
      sprintf (sval, ""%d,"", args->av_name);
    else
      sprintf (sval, ""%d"", args->av_name);
  temp = strcat (temp, sval);
",unused,bcdebstretche-bc2Futil.c
"  char digits[40];
  int len, ix;

  if (space) (*out_char) (' ');
  sprintf (digits, ""%ld"", val);
",1,unused,1446,unused,"  char digits[40];
  int len, ix;

  if (space) (*out_char) (' ');
  sprintf (digits, ""%ld"", val);
",unused,bcdebstretche-lib2Fnumber.c
"{
  char *temp;

  temp = (char *) bc_malloc (strlen (str)+1);
  return (strcpy (temp,str));
",1,unused,51,unused,"{
  char *temp;

  temp = (char *) bc_malloc (strlen (str)+1);
  return (strcpy (temp,str));
",unused,bcpatchxen-bc2Futil.c
"
  /* Add the current number to the end of the string. */
  if (args->arg_is_var)
    if (len != 1) 
      sprintf (sval, ""*%d,"", args->av_name);
",1,unused,109,unused,"
  /* Add the current number to the end of the string. */
  if (args->arg_is_var)
    if (len != 1) 
      sprintf (sval, ""*%d,"", args->av_name);
",unused,bcpatchxen-bc2Futil.c
"  if (args->arg_is_var)
    if (len != 1) 
      sprintf (sval, ""*%d,"", args->av_name);
    else
      sprintf (sval, ""*%d"", args->av_name);
",1,unused,111,unused,"  if (args->arg_is_var)
    if (len != 1) 
      sprintf (sval, ""*%d,"", args->av_name);
    else
      sprintf (sval, ""*%d"", args->av_name);
",unused,bcpatchxen-bc2Futil.c
"    else
      sprintf (sval, ""*%d"", args->av_name);
  else
    if (len != 1) 
      sprintf (sval, ""%d,"", args->av_name);
",1,unused,114,unused,"    else
      sprintf (sval, ""*%d"", args->av_name);
  else
    if (len != 1) 
      sprintf (sval, ""%d,"", args->av_name);
",unused,bcpatchxen-bc2Futil.c
"  else
    if (len != 1) 
      sprintf (sval, ""%d,"", args->av_name);
    else
      sprintf (sval, ""%d"", args->av_name);
",1,unused,116,unused,"  else
    if (len != 1) 
      sprintf (sval, ""%d,"", args->av_name);
    else
      sprintf (sval, ""%d"", args->av_name);
",unused,bcpatchxen-bc2Futil.c
"    if (len != 1) 
      sprintf (sval, ""%d,"", args->av_name);
    else
      sprintf (sval, ""%d"", args->av_name);
  temp = strcat (temp, sval);
",1,unused,117,unused,"    if (len != 1) 
      sprintf (sval, ""%d,"", args->av_name);
    else
      sprintf (sval, ""%d"", args->av_name);
  temp = strcat (temp, sval);
",unused,bcpatchxen-bc2Futil.c
"	pw=getpwuid(getuid());
	homedir=pw->pw_dir;
    }
    rcfile=malloc(strlen(homedir)+8);
    sprintf(rcfile, ""%s/.dcrc"", homedir);
",1,unused,268,unused,"	pw=getpwuid(getuid());
	homedir=pw->pw_dir;
    }
    rcfile=malloc(strlen(homedir)+8);
    sprintf(rcfile, ""%s/.dcrc"", homedir);
",unused,bcpatchxen-dc2Fdc.c
"	pw=getpwuid(getuid());
	homedir=pw->pw_dir;
    }
    rcfile=malloc(strlen(homedir)+8);
    sprintf(rcfile, ""%s/.dcrc"", homedir);
",1,unused,268,unused,"	pw=getpwuid(getuid());
	homedir=pw->pw_dir;
    }
    rcfile=malloc(strlen(homedir)+8);
    sprintf(rcfile, ""%s/.dcrc"", homedir);
",unused,bcpatchxen-dc2Fdc.c
"  char digits[40];
  int len, ix;

  if (space) (*out_char) (' ');
  sprintf (digits, ""%ld"", val);
",1,unused,1446,unused,"  char digits[40];
  int len, ix;

  if (space) (*out_char) (' ');
  sprintf (digits, ""%ld"", val);
",unused,bcpatchxen-lib2Fnumber.c
"			      if (break_label == 0)
				yyerror (""Break outside a for/while"");
			      else
				{
				  sprintf (genstr, ""J%1d:"", break_label);
",1,unused,1074,unused,"			      if (break_label == 0)
				yyerror (""Break outside a for/while"");
			      else
				{
				  sprintf (genstr, ""J%1d:"", break_label);
",unused,bcsources-bc2Fbc.c
"			      if (continue_label == 0)
				yyerror (""Continue outside a for"");
			      else
				{
				  sprintf (genstr, ""J%1d:"", continue_label);
",1,unused,1087,unused,"			      if (continue_label == 0)
				yyerror (""Continue outside a for"");
			      else
				{
				  sprintf (genstr, ""J%1d:"", continue_label);
",unused,bcsources-bc2Fbc.c
"				warn (""Comparison in first for expression"");
			      if (yyvsp[-1].i_value >= 0)
				generate (""p"");
			      yyvsp[-1].i_value = next_label++;
			      sprintf (genstr, ""N%1d:"", yyvsp[-1].i_value);
",1,unused,1119,unused,"				warn (""Comparison in first for expression"");
			      if (yyvsp[-1].i_value >= 0)
				generate (""p"");
			      yyvsp[-1].i_value = next_label++;
			      sprintf (genstr, ""N%1d:"", yyvsp[-1].i_value);
",unused,bcsources-bc2Fbc.c
"#line 213 ""bc.y""
{
			      if (yyvsp[-1].i_value < 0) generate (""1"");
			      yyvsp[-1].i_value = next_label++;
			      sprintf (genstr, ""B%1d:J%1d:"", yyvsp[-1].i_value, break_label);
",1,unused,1128,unused,"#line 213 ""bc.y""
{
			      if (yyvsp[-1].i_value < 0) generate (""1"");
			      yyvsp[-1].i_value = next_label++;
			      sprintf (genstr, ""B%1d:J%1d:"", yyvsp[-1].i_value, break_label);
",unused,bcsources-bc2Fbc.c
"			      sprintf (genstr, ""B%1d:J%1d:"", yyvsp[-1].i_value, break_label);
			      generate (genstr);
			      yyval.i_value = continue_label;
			      continue_label = next_label++;
			      sprintf (genstr, ""N%1d:"", continue_label);
",1,unused,1132,unused,"			      sprintf (genstr, ""B%1d:J%1d:"", yyvsp[-1].i_value, break_label);
			      generate (genstr);
			      yyval.i_value = continue_label;
			      continue_label = next_label++;
			      sprintf (genstr, ""N%1d:"", continue_label);
",unused,bcsources-bc2Fbc.c
"{
			      if (yyvsp[-1].i_value & 2 )
				warn (""Comparison in third for expression"");
			      if (yyvsp[-1].i_value & 16)
				sprintf (genstr, ""J%1d:N%1d:"", yyvsp[-7].i_value, yyvsp[-4].i_value);
",1,unused,1142,unused,"{
			      if (yyvsp[-1].i_value & 2 )
				warn (""Comparison in third for expression"");
			      if (yyvsp[-1].i_value & 16)
				sprintf (genstr, ""J%1d:N%1d:"", yyvsp[-7].i_value, yyvsp[-4].i_value);
",unused,bcsources-bc2Fbc.c
"				warn (""Comparison in third for expression"");
			      if (yyvsp[-1].i_value & 16)
				sprintf (genstr, ""J%1d:N%1d:"", yyvsp[-7].i_value, yyvsp[-4].i_value);
			      else
				sprintf (genstr, ""pJ%1d:N%1d:"", yyvsp[-7].i_value, yyvsp[-4].i_value);
",1,unused,1144,unused,"				warn (""Comparison in third for expression"");
			      if (yyvsp[-1].i_value & 16)
				sprintf (genstr, ""J%1d:N%1d:"", yyvsp[-7].i_value, yyvsp[-4].i_value);
			      else
				sprintf (genstr, ""pJ%1d:N%1d:"", yyvsp[-7].i_value, yyvsp[-4].i_value);
",unused,bcsources-bc2Fbc.c
"    break;}
case 33:
#line 234 ""bc.y""
{
			      sprintf (genstr, ""J%1d:N%1d:"",
",1,unused,1151,unused,"    break;}
case 33:
#line 234 ""bc.y""
{
			      sprintf (genstr, ""J%1d:N%1d:"",
",unused,bcsources-bc2Fbc.c
"#line 242 ""bc.y""
{
			      yyvsp[-1].i_value = if_label;
			      if_label = next_label++;
			      sprintf (genstr, ""Z%1d:"", if_label);
",1,unused,1163,unused,"#line 242 ""bc.y""
{
			      yyvsp[-1].i_value = if_label;
			      if_label = next_label++;
			      sprintf (genstr, ""Z%1d:"", if_label);
",unused,bcsources-bc2Fbc.c
"    break;}
case 35:
#line 249 ""bc.y""
{
			      sprintf (genstr, ""N%1d:"", if_label); 
",1,unused,1170,unused,"    break;}
case 35:
#line 249 ""bc.y""
{
			      sprintf (genstr, ""N%1d:"", if_label); 
",unused,bcsources-bc2Fbc.c
"case 36:
#line 255 ""bc.y""
{
			      yyvsp[0].i_value = next_label++;
			      sprintf (genstr, ""N%1d:"", yyvsp[0].i_value);
",1,unused,1179,unused,"case 36:
#line 255 ""bc.y""
{
			      yyvsp[0].i_value = next_label++;
			      sprintf (genstr, ""N%1d:"", yyvsp[0].i_value);
",unused,bcsources-bc2Fbc.c
"#line 261 ""bc.y""
{
			      yyvsp[0].i_value = break_label; 
			      break_label = next_label++;
			      sprintf (genstr, ""Z%1d:"", break_label);
",1,unused,1188,unused,"#line 261 ""bc.y""
{
			      yyvsp[0].i_value = break_label; 
			      break_label = next_label++;
			      sprintf (genstr, ""Z%1d:"", break_label);
",unused,bcsources-bc2Fbc.c
"    break;}
case 38:
#line 268 ""bc.y""
{
			      sprintf (genstr, ""J%1d:N%1d:"", yyvsp[-7].i_value, break_label);
",1,unused,1195,unused,"    break;}
case 38:
#line 268 ""bc.y""
{
			      sprintf (genstr, ""J%1d:N%1d:"", yyvsp[-7].i_value, break_label);
",unused,bcsources-bc2Fbc.c
"#line 293 ""bc.y""
{
			      warn (""else clause in if statement"");
			      yyvsp[0].i_value = next_label++;
			      sprintf (genstr, ""J%d:N%1d:"", yyvsp[0].i_value, if_label); 
",1,unused,1225,unused,"#line 293 ""bc.y""
{
			      warn (""else clause in if statement"");
			      yyvsp[0].i_value = next_label++;
			      sprintf (genstr, ""J%d:N%1d:"", yyvsp[0].i_value, if_label); 
",unused,bcsources-bc2Fbc.c
"#line 303 ""bc.y""
{
			      /* Check auto list against parameter list? */
			      check_params (yyvsp[-5].a_value,yyvsp[0].a_value);
			      sprintf (genstr, ""F%d,%s.%s["",
",1,unused,1235,unused,"#line 303 ""bc.y""
{
			      /* Check auto list against parameter list? */
			      check_params (yyvsp[-5].a_value,yyvsp[0].a_value);
			      sprintf (genstr, ""F%d,%s.%s["",
",unused,bcsources-bc2Fbc.c
"    break;}
case 65:
#line 355 ""bc.y""
{
			      sprintf (genstr, ""K%d:"", -lookup (yyvsp[-2].s_value,ARRAY));
",1,unused,1306,unused,"    break;}
case 65:
#line 355 ""bc.y""
{
			      sprintf (genstr, ""K%d:"", -lookup (yyvsp[-2].s_value,ARRAY));
",unused,bcsources-bc2Fbc.c
"    break;}
case 67:
#line 366 ""bc.y""
{
			      sprintf (genstr, ""K%d:"", -lookup (yyvsp[-2].s_value,ARRAY));
",1,unused,1321,unused,"    break;}
case 67:
#line 366 ""bc.y""
{
			      sprintf (genstr, ""K%d:"", -lookup (yyvsp[-2].s_value,ARRAY));
",unused,bcsources-bc2Fbc.c
"{
			      if (yyvsp[0].c_value != '=')
				{
				  if (yyvsp[-1].i_value < 0)
				    sprintf (genstr, ""DL%d:"", -yyvsp[-1].i_value);
",1,unused,1355,unused,"{
			      if (yyvsp[0].c_value != '=')
				{
				  if (yyvsp[-1].i_value < 0)
				    sprintf (genstr, ""DL%d:"", -yyvsp[-1].i_value);
",unused,bcsources-bc2Fbc.c
"				{
				  if (yyvsp[-1].i_value < 0)
				    sprintf (genstr, ""DL%d:"", -yyvsp[-1].i_value);
				  else
				    sprintf (genstr, ""l%d:"", yyvsp[-1].i_value);
",1,unused,1357,unused,"				{
				  if (yyvsp[-1].i_value < 0)
				    sprintf (genstr, ""DL%d:"", -yyvsp[-1].i_value);
				  else
				    sprintf (genstr, ""l%d:"", yyvsp[-1].i_value);
",unused,bcsources-bc2Fbc.c
"{
			      if (yyvsp[0].i_value & 2) warn(""comparison in assignment"");
			      if (yyvsp[-2].c_value != '=')
				{
				  sprintf (genstr, ""%c"", yyvsp[-2].c_value);
",1,unused,1368,unused,"{
			      if (yyvsp[0].i_value & 2) warn(""comparison in assignment"");
			      if (yyvsp[-2].c_value != '=')
				{
				  sprintf (genstr, ""%c"", yyvsp[-2].c_value);
",unused,bcsources-bc2Fbc.c
"				  sprintf (genstr, ""%c"", yyvsp[-2].c_value);
				  generate (genstr);
				}
			      if (yyvsp[-3].i_value < 0)
				sprintf (genstr, ""S%d:"", -yyvsp[-3].i_value);
",1,unused,1372,unused,"				  sprintf (genstr, ""%c"", yyvsp[-2].c_value);
				  generate (genstr);
				}
			      if (yyvsp[-3].i_value < 0)
				sprintf (genstr, ""S%d:"", -yyvsp[-3].i_value);
",unused,bcsources-bc2Fbc.c
"				}
			      if (yyvsp[-3].i_value < 0)
				sprintf (genstr, ""S%d:"", -yyvsp[-3].i_value);
			      else
				sprintf (genstr, ""s%d:"", yyvsp[-3].i_value);
",1,unused,1374,unused,"				}
			      if (yyvsp[-3].i_value < 0)
				sprintf (genstr, ""S%d:"", -yyvsp[-3].i_value);
			      else
				sprintf (genstr, ""s%d:"", yyvsp[-3].i_value);
",unused,bcsources-bc2Fbc.c
"#line 429 ""bc.y""
{
			      warn(""&& operator"");
			      yyvsp[0].i_value = next_label++;
			      sprintf (genstr, ""DZ%d:p"", yyvsp[0].i_value);
",1,unused,1384,unused,"#line 429 ""bc.y""
{
			      warn(""&& operator"");
			      yyvsp[0].i_value = next_label++;
			      sprintf (genstr, ""DZ%d:p"", yyvsp[0].i_value);
",unused,bcsources-bc2Fbc.c
"    break;}
case 75:
#line 436 ""bc.y""
{
			      sprintf (genstr, ""DZ%d:p1N%d:"", yyvsp[-2].i_value, yyvsp[-2].i_value);
",1,unused,1391,unused,"    break;}
case 75:
#line 436 ""bc.y""
{
			      sprintf (genstr, ""DZ%d:p1N%d:"", yyvsp[-2].i_value, yyvsp[-2].i_value);
",unused,bcsources-bc2Fbc.c
"#line 442 ""bc.y""
{
			      warn(""|| operator"");
			      yyvsp[0].i_value = next_label++;
			      sprintf (genstr, ""B%d:"", yyvsp[0].i_value);
",1,unused,1401,unused,"#line 442 ""bc.y""
{
			      warn(""|| operator"");
			      yyvsp[0].i_value = next_label++;
			      sprintf (genstr, ""B%d:"", yyvsp[0].i_value);
",unused,bcsources-bc2Fbc.c
"#line 449 ""bc.y""
{
			      int tmplab;
			      tmplab = next_label++;
			      sprintf (genstr, ""B%d:0J%d:N%d:1N%d:"",
",1,unused,1410,unused,"#line 449 ""bc.y""
{
			      int tmplab;
			      tmplab = next_label++;
			      sprintf (genstr, ""B%d:0J%d:N%d:1N%d:"",
",unused,bcsources-bc2Fbc.c
"#line 527 ""bc.y""
{
			      yyval.i_value = 1;
			      if (yyvsp[0].i_value < 0)
				sprintf (genstr, ""L%d:"", -yyvsp[0].i_value);
",1,unused,1508,unused,"#line 527 ""bc.y""
{
			      yyval.i_value = 1;
			      if (yyvsp[0].i_value < 0)
				sprintf (genstr, ""L%d:"", -yyvsp[0].i_value);
",unused,bcsources-bc2Fbc.c
"			      yyval.i_value = 1;
			      if (yyvsp[0].i_value < 0)
				sprintf (genstr, ""L%d:"", -yyvsp[0].i_value);
			      else
				sprintf (genstr, ""l%d:"", yyvsp[0].i_value);
",1,unused,1510,unused,"			      yyval.i_value = 1;
			      if (yyvsp[0].i_value < 0)
				sprintf (genstr, ""L%d:"", -yyvsp[0].i_value);
			      else
				sprintf (genstr, ""l%d:"", yyvsp[0].i_value);
",unused,bcsources-bc2Fbc.c
"{
			      yyval.i_value = 1;
			      if (yyvsp[-1].a_value != NULL)
				{ 
				  sprintf (genstr, ""C%d,%s:"",
",1,unused,1542,unused,"{
			      yyval.i_value = 1;
			      if (yyvsp[-1].a_value != NULL)
				{ 
				  sprintf (genstr, ""C%d,%s:"",
",unused,bcsources-bc2Fbc.c
"				  free_args (yyvsp[-1].a_value);
				}
			      else
				{
				  sprintf (genstr, ""C%d:"", lookup (yyvsp[-3].s_value,FUNCT));
",1,unused,1549,unused,"				  free_args (yyvsp[-1].a_value);
				}
			      else
				{
				  sprintf (genstr, ""C%d:"", lookup (yyvsp[-3].s_value,FUNCT));
",unused,bcsources-bc2Fbc.c
"			      yyval.i_value = 1;
			      if (yyvsp[0].i_value < 0)
				{
				  if (yyvsp[-1].c_value == '+')
				    sprintf (genstr, ""DA%d:L%d:"", -yyvsp[0].i_value, -yyvsp[0].i_value);
",1,unused,1561,unused,"			      yyval.i_value = 1;
			      if (yyvsp[0].i_value < 0)
				{
				  if (yyvsp[-1].c_value == '+')
				    sprintf (genstr, ""DA%d:L%d:"", -yyvsp[0].i_value, -yyvsp[0].i_value);
",unused,bcsources-bc2Fbc.c
"				{
				  if (yyvsp[-1].c_value == '+')
				    sprintf (genstr, ""DA%d:L%d:"", -yyvsp[0].i_value, -yyvsp[0].i_value);
				  else
				    sprintf (genstr, ""DM%d:L%d:"", -yyvsp[0].i_value, -yyvsp[0].i_value);
",1,unused,1563,unused,"				{
				  if (yyvsp[-1].c_value == '+')
				    sprintf (genstr, ""DA%d:L%d:"", -yyvsp[0].i_value, -yyvsp[0].i_value);
				  else
				    sprintf (genstr, ""DM%d:L%d:"", -yyvsp[0].i_value, -yyvsp[0].i_value);
",unused,bcsources-bc2Fbc.c
"				}
			      else
				{
				  if (yyvsp[-1].c_value == '+')
				    sprintf (genstr, ""i%d:l%d:"", yyvsp[0].i_value, yyvsp[0].i_value);
",1,unused,1568,unused,"				}
			      else
				{
				  if (yyvsp[-1].c_value == '+')
				    sprintf (genstr, ""i%d:l%d:"", yyvsp[0].i_value, yyvsp[0].i_value);
",unused,bcsources-bc2Fbc.c
"				{
				  if (yyvsp[-1].c_value == '+')
				    sprintf (genstr, ""i%d:l%d:"", yyvsp[0].i_value, yyvsp[0].i_value);
				  else
				    sprintf (genstr, ""d%d:l%d:"", yyvsp[0].i_value, yyvsp[0].i_value);
",1,unused,1570,unused,"				{
				  if (yyvsp[-1].c_value == '+')
				    sprintf (genstr, ""i%d:l%d:"", yyvsp[0].i_value, yyvsp[0].i_value);
				  else
				    sprintf (genstr, ""d%d:l%d:"", yyvsp[0].i_value, yyvsp[0].i_value);
",unused,bcsources-bc2Fbc.c
"{
			      yyval.i_value = 1;
			      if (yyvsp[-1].i_value < 0)
				{
				  sprintf (genstr, ""DL%d:x"", -yyvsp[-1].i_value);
",1,unused,1581,unused,"{
			      yyval.i_value = 1;
			      if (yyvsp[-1].i_value < 0)
				{
				  sprintf (genstr, ""DL%d:x"", -yyvsp[-1].i_value);
",unused,bcsources-bc2Fbc.c
"				{
				  sprintf (genstr, ""DL%d:x"", -yyvsp[-1].i_value);
				  generate (genstr); 
				  if (yyvsp[0].c_value == '+')
				    sprintf (genstr, ""A%d:"", -yyvsp[-1].i_value);
",1,unused,1584,unused,"				{
				  sprintf (genstr, ""DL%d:x"", -yyvsp[-1].i_value);
				  generate (genstr); 
				  if (yyvsp[0].c_value == '+')
				    sprintf (genstr, ""A%d:"", -yyvsp[-1].i_value);
",unused,bcsources-bc2Fbc.c
"				  generate (genstr); 
				  if (yyvsp[0].c_value == '+')
				    sprintf (genstr, ""A%d:"", -yyvsp[-1].i_value);
				  else
				      sprintf (genstr, ""M%d:"", -yyvsp[-1].i_value);
",1,unused,1586,unused,"				  generate (genstr); 
				  if (yyvsp[0].c_value == '+')
				    sprintf (genstr, ""A%d:"", -yyvsp[-1].i_value);
				  else
				      sprintf (genstr, ""M%d:"", -yyvsp[-1].i_value);
",unused,bcsources-bc2Fbc.c
"				      sprintf (genstr, ""M%d:"", -yyvsp[-1].i_value);
				}
			      else
				{
				  sprintf (genstr, ""l%d:"", yyvsp[-1].i_value);
",1,unused,1590,unused,"				      sprintf (genstr, ""M%d:"", -yyvsp[-1].i_value);
				}
			      else
				{
				  sprintf (genstr, ""l%d:"", yyvsp[-1].i_value);
",unused,bcsources-bc2Fbc.c
"				{
				  sprintf (genstr, ""l%d:"", yyvsp[-1].i_value);
				  generate (genstr);
				  if (yyvsp[0].c_value == '+')
				    sprintf (genstr, ""i%d:"", yyvsp[-1].i_value);
",1,unused,1593,unused,"				{
				  sprintf (genstr, ""l%d:"", yyvsp[-1].i_value);
				  generate (genstr);
				  if (yyvsp[0].c_value == '+')
				    sprintf (genstr, ""i%d:"", yyvsp[-1].i_value);
",unused,bcsources-bc2Fbc.c
"				  generate (genstr);
				  if (yyvsp[0].c_value == '+')
				    sprintf (genstr, ""i%d:"", yyvsp[-1].i_value);
				  else
				    sprintf (genstr, ""d%d:"", yyvsp[-1].i_value);
",1,unused,1595,unused,"				  generate (genstr);
				  if (yyvsp[0].c_value == '+')
				    sprintf (genstr, ""i%d:"", yyvsp[-1].i_value);
				  else
				    sprintf (genstr, ""d%d:"", yyvsp[-1].i_value);
",unused,bcsources-bc2Fbc.c
"{
  char *temp;

  temp = (char *) bc_malloc (strlen (str)+1);
  return (strcpy (temp,str));
",1,unused,52,unused,"{
  char *temp;

  temp = (char *) bc_malloc (strlen (str)+1);
  return (strcpy (temp,str));
",unused,bcsources-bc2Futil.c
"
  /* Add the current number to the end of the string. */
  if (args->arg_is_var)
    if (len != 1) 
      sprintf (sval, ""*%d,"", args->av_name);
",1,unused,110,unused,"
  /* Add the current number to the end of the string. */
  if (args->arg_is_var)
    if (len != 1) 
      sprintf (sval, ""*%d,"", args->av_name);
",unused,bcsources-bc2Futil.c
"  if (args->arg_is_var)
    if (len != 1) 
      sprintf (sval, ""*%d,"", args->av_name);
    else
      sprintf (sval, ""*%d"", args->av_name);
",1,unused,112,unused,"  if (args->arg_is_var)
    if (len != 1) 
      sprintf (sval, ""*%d,"", args->av_name);
    else
      sprintf (sval, ""*%d"", args->av_name);
",unused,bcsources-bc2Futil.c
"    else
      sprintf (sval, ""*%d"", args->av_name);
  else
    if (len != 1) 
      sprintf (sval, ""%d,"", args->av_name);
",1,unused,115,unused,"    else
      sprintf (sval, ""*%d"", args->av_name);
  else
    if (len != 1) 
      sprintf (sval, ""%d,"", args->av_name);
",unused,bcsources-bc2Futil.c
"  else
    if (len != 1) 
      sprintf (sval, ""%d,"", args->av_name);
    else
      sprintf (sval, ""%d"", args->av_name);
",1,unused,117,unused,"  else
    if (len != 1) 
      sprintf (sval, ""%d,"", args->av_name);
    else
      sprintf (sval, ""%d"", args->av_name);
",unused,bcsources-bc2Futil.c
"    if (len != 1) 
      sprintf (sval, ""%d,"", args->av_name);
    else
      sprintf (sval, ""%d"", args->av_name);
  temp = strcat (temp, sval);
",1,unused,118,unused,"    if (len != 1) 
      sprintf (sval, ""%d,"", args->av_name);
    else
      sprintf (sval, ""%d"", args->av_name);
  temp = strcat (temp, sval);
",unused,bcsources-bc2Futil.c
"  char digits[40];
  int len, ix;

  if (space) (*out_char) (' ');
  sprintf (digits, ""%ld"", val);
",1,unused,1441,unused,"  char digits[40];
  int len, ix;

  if (space) (*out_char) (' ');
  sprintf (digits, ""%ld"", val);
",unused,bcsources-lib2Fnumber.c
"			      if (break_label == 0)
				yyerror (""Break outside a for/while"");
			      else
				{
				  sprintf (genstr, ""J%1d:"", break_label);
",1,unused,1557,unused,"			      if (break_label == 0)
				yyerror (""Break outside a for/while"");
			      else
				{
				  sprintf (genstr, ""J%1d:"", break_label);
",unused,bcxenial-bc2Fbc.c
"			      if (continue_label == 0)
				yyerror (""Continue outside a for"");
			      else
				{
				  sprintf (genstr, ""J%1d:"", continue_label);
",1,unused,1571,unused,"			      if (continue_label == 0)
				yyerror (""Continue outside a for"");
			      else
				{
				  sprintf (genstr, ""J%1d:"", continue_label);
",unused,bcxenial-bc2Fbc.c
"				yyerror (""first expression is void"");
			      if (!((yyvsp[-1].i_value) & EX_EMPTY))
				generate (""p"");
			      (yyvsp[-1].i_value) = next_label++;
			      sprintf (genstr, ""N%1d:"", (yyvsp[-1].i_value));
",1,unused,1610,unused,"				yyerror (""first expression is void"");
			      if (!((yyvsp[-1].i_value) & EX_EMPTY))
				generate (""p"");
			      (yyvsp[-1].i_value) = next_label++;
			      sprintf (genstr, ""N%1d:"", (yyvsp[-1].i_value));
",unused,bcxenial-bc2Fbc.c
"			      if ((yyvsp[-1].i_value) & EX_VOID)
				yyerror (""second expression is void"");
			      if ((yyvsp[-1].i_value) & EX_EMPTY ) generate (""1"");
			      (yyvsp[-1].i_value) = next_label++;
			      sprintf (genstr, ""B%1d:J%1d:"", (yyvsp[-1].i_value), break_label);
",1,unused,1622,unused,"			      if ((yyvsp[-1].i_value) & EX_VOID)
				yyerror (""second expression is void"");
			      if ((yyvsp[-1].i_value) & EX_EMPTY ) generate (""1"");
			      (yyvsp[-1].i_value) = next_label++;
			      sprintf (genstr, ""B%1d:J%1d:"", (yyvsp[-1].i_value), break_label);
",unused,bcxenial-bc2Fbc.c
"			      sprintf (genstr, ""B%1d:J%1d:"", (yyvsp[-1].i_value), break_label);
			      generate (genstr);
			      (yyval.i_value) = continue_label;
			      continue_label = next_label++;
			      sprintf (genstr, ""N%1d:"", continue_label);
",1,unused,1626,unused,"			      sprintf (genstr, ""B%1d:J%1d:"", (yyvsp[-1].i_value), break_label);
			      generate (genstr);
			      (yyval.i_value) = continue_label;
			      continue_label = next_label++;
			      sprintf (genstr, ""N%1d:"", continue_label);
",unused,bcxenial-bc2Fbc.c
"				warn (""Comparison in third for expression"");
			      if ((yyvsp[-1].i_value) & EX_VOID)
				yyerror (""third expression is void"");
			      if ((yyvsp[-1].i_value) & EX_EMPTY)
				sprintf (genstr, ""J%1d:N%1d:"", (yyvsp[-7].i_value), (yyvsp[-4].i_value));
",1,unused,1639,unused,"				warn (""Comparison in third for expression"");
			      if ((yyvsp[-1].i_value) & EX_VOID)
				yyerror (""third expression is void"");
			      if ((yyvsp[-1].i_value) & EX_EMPTY)
				sprintf (genstr, ""J%1d:N%1d:"", (yyvsp[-7].i_value), (yyvsp[-4].i_value));
",unused,bcxenial-bc2Fbc.c
"				yyerror (""third expression is void"");
			      if ((yyvsp[-1].i_value) & EX_EMPTY)
				sprintf (genstr, ""J%1d:N%1d:"", (yyvsp[-7].i_value), (yyvsp[-4].i_value));
			      else
				sprintf (genstr, ""pJ%1d:N%1d:"", (yyvsp[-7].i_value), (yyvsp[-4].i_value));
",1,unused,1641,unused,"				yyerror (""third expression is void"");
			      if ((yyvsp[-1].i_value) & EX_EMPTY)
				sprintf (genstr, ""J%1d:N%1d:"", (yyvsp[-7].i_value), (yyvsp[-4].i_value));
			      else
				sprintf (genstr, ""pJ%1d:N%1d:"", (yyvsp[-7].i_value), (yyvsp[-4].i_value));
",unused,bcxenial-bc2Fbc.c
"
  case 34:
#line 256 ""bc.y""
    {
			      sprintf (genstr, ""J%1d:N%1d:"",
",1,unused,1649,unused,"
  case 34:
#line 256 ""bc.y""
    {
			      sprintf (genstr, ""J%1d:N%1d:"",
",unused,bcxenial-bc2Fbc.c
"			      if ((yyvsp[-1].i_value) & EX_VOID)
				yyerror (""void expression"");
			      (yyvsp[-1].i_value) = if_label;
			      if_label = next_label++;
			      sprintf (genstr, ""Z%1d:"", if_label);
",1,unused,1664,unused,"			      if ((yyvsp[-1].i_value) & EX_VOID)
				yyerror (""void expression"");
			      (yyvsp[-1].i_value) = if_label;
			      if_label = next_label++;
			      sprintf (genstr, ""Z%1d:"", if_label);
",unused,bcxenial-bc2Fbc.c
"
  case 36:
#line 273 ""bc.y""
    {
			      sprintf (genstr, ""N%1d:"", if_label); 
",1,unused,1672,unused,"
  case 36:
#line 273 ""bc.y""
    {
			      sprintf (genstr, ""N%1d:"", if_label); 
",unused,bcxenial-bc2Fbc.c
"  case 37:
#line 279 ""bc.y""
    {
			      (yyvsp[0].i_value) = next_label++;
			      sprintf (genstr, ""N%1d:"", (yyvsp[0].i_value));
",1,unused,1682,unused,"  case 37:
#line 279 ""bc.y""
    {
			      (yyvsp[0].i_value) = next_label++;
			      sprintf (genstr, ""N%1d:"", (yyvsp[0].i_value));
",unused,bcxenial-bc2Fbc.c
"			      if ((yyvsp[0].i_value) & EX_VOID)
				yyerror (""void expression"");
			      (yyvsp[0].i_value) = break_label; 
			      break_label = next_label++;
			      sprintf (genstr, ""Z%1d:"", break_label);
",1,unused,1694,unused,"			      if ((yyvsp[0].i_value) & EX_VOID)
				yyerror (""void expression"");
			      (yyvsp[0].i_value) = break_label; 
			      break_label = next_label++;
			      sprintf (genstr, ""Z%1d:"", break_label);
",unused,bcxenial-bc2Fbc.c
"
  case 39:
#line 294 ""bc.y""
    {
			      sprintf (genstr, ""J%1d:N%1d:"", (yyvsp[-7].i_value), break_label);
",1,unused,1702,unused,"
  case 39:
#line 294 ""bc.y""
    {
			      sprintf (genstr, ""J%1d:N%1d:"", (yyvsp[-7].i_value), break_label);
",unused,bcxenial-bc2Fbc.c
"#line 323 ""bc.y""
    {
			      warn (""else clause in if statement"");
			      (yyvsp[0].i_value) = next_label++;
			      sprintf (genstr, ""J%d:N%1d:"", (yyvsp[0].i_value), if_label); 
",1,unused,1741,unused,"#line 323 ""bc.y""
    {
			      warn (""else clause in if statement"");
			      (yyvsp[0].i_value) = next_label++;
			      sprintf (genstr, ""J%d:N%1d:"", (yyvsp[0].i_value), if_label); 
",unused,bcxenial-bc2Fbc.c
"			      autos  = arg_str ((yyvsp[0].a_value));
			      set_genstr_size (30 + strlen (params)
					       + strlen (autos));
			      cur_func = lookup((yyvsp[-7].s_value),FUNCTDEF);
			      sprintf (genstr, ""F%d,%s.%s["", cur_func, params,
",1,unused,1757,unused,"			      autos  = arg_str ((yyvsp[0].a_value));
			      set_genstr_size (30 + strlen (params)
					       + strlen (autos));
			      cur_func = lookup((yyvsp[-7].s_value),FUNCTDEF);
			      sprintf (genstr, ""F%d,%s.%s["", cur_func, params,
",unused,bcxenial-bc2Fbc.c
"
  case 70:
#line 415 ""bc.y""
    {
			      sprintf (genstr, ""K%d:"", -lookup ((yyvsp[-2].s_value),ARRAY));
",1,unused,1877,unused,"
  case 70:
#line 415 ""bc.y""
    {
			      sprintf (genstr, ""K%d:"", -lookup ((yyvsp[-2].s_value),ARRAY));
",unused,bcxenial-bc2Fbc.c
"
  case 72:
#line 429 ""bc.y""
    {
			      sprintf (genstr, ""K%d:"", -lookup ((yyvsp[-2].s_value),ARRAY));
",1,unused,1897,unused,"
  case 72:
#line 429 ""bc.y""
    {
			      sprintf (genstr, ""K%d:"", -lookup ((yyvsp[-2].s_value),ARRAY));
",unused,bcxenial-bc2Fbc.c
"    {
			      if ((yyvsp[0].c_value) != '=')
				{
				  if ((yyvsp[-1].i_value) < 0)
				    sprintf (genstr, ""DL%d:"", -(yyvsp[-1].i_value));
",1,unused,1943,unused,"    {
			      if ((yyvsp[0].c_value) != '=')
				{
				  if ((yyvsp[-1].i_value) < 0)
				    sprintf (genstr, ""DL%d:"", -(yyvsp[-1].i_value));
",unused,bcxenial-bc2Fbc.c
"				{
				  if ((yyvsp[-1].i_value) < 0)
				    sprintf (genstr, ""DL%d:"", -(yyvsp[-1].i_value));
				  else
				    sprintf (genstr, ""l%d:"", (yyvsp[-1].i_value));
",1,unused,1945,unused,"				{
				  if ((yyvsp[-1].i_value) < 0)
				    sprintf (genstr, ""DL%d:"", -(yyvsp[-1].i_value));
				  else
				    sprintf (genstr, ""l%d:"", (yyvsp[-1].i_value));
",unused,bcxenial-bc2Fbc.c
"			      if ((yyvsp[0].i_value) & EX_VOID)
				yyerror(""Assignment of a void expression"");
			      if ((yyvsp[-2].c_value) != '=')
				{
				  sprintf (genstr, ""%c"", (yyvsp[-2].c_value));
",1,unused,1960,unused,"			      if ((yyvsp[0].i_value) & EX_VOID)
				yyerror(""Assignment of a void expression"");
			      if ((yyvsp[-2].c_value) != '=')
				{
				  sprintf (genstr, ""%c"", (yyvsp[-2].c_value));
",unused,bcxenial-bc2Fbc.c
"				  sprintf (genstr, ""%c"", (yyvsp[-2].c_value));
				  generate (genstr);
				}
			      if ((yyvsp[-3].i_value) < 0)
				sprintf (genstr, ""S%d:"", -(yyvsp[-3].i_value));
",1,unused,1964,unused,"				  sprintf (genstr, ""%c"", (yyvsp[-2].c_value));
				  generate (genstr);
				}
			      if ((yyvsp[-3].i_value) < 0)
				sprintf (genstr, ""S%d:"", -(yyvsp[-3].i_value));
",unused,bcxenial-bc2Fbc.c
"				}
			      if ((yyvsp[-3].i_value) < 0)
				sprintf (genstr, ""S%d:"", -(yyvsp[-3].i_value));
			      else
				sprintf (genstr, ""s%d:"", (yyvsp[-3].i_value));
",1,unused,1966,unused,"				}
			      if ((yyvsp[-3].i_value) < 0)
				sprintf (genstr, ""S%d:"", -(yyvsp[-3].i_value));
			      else
				sprintf (genstr, ""s%d:"", (yyvsp[-3].i_value));
",unused,bcxenial-bc2Fbc.c
"#line 503 ""bc.y""
    {
			      warn(""&& operator"");
			      (yyvsp[0].i_value) = next_label++;
			      sprintf (genstr, ""DZ%d:p"", (yyvsp[0].i_value));
",1,unused,1977,unused,"#line 503 ""bc.y""
    {
			      warn(""&& operator"");
			      (yyvsp[0].i_value) = next_label++;
			      sprintf (genstr, ""DZ%d:p"", (yyvsp[0].i_value));
",unused,bcxenial-bc2Fbc.c
"#line 510 ""bc.y""
    {
			      if (((yyvsp[-3].i_value) & EX_VOID) || ((yyvsp[0].i_value) & EX_VOID))
				yyerror (""void expression with &&"");
			      sprintf (genstr, ""DZ%d:p1N%d:"", (yyvsp[-2].i_value), (yyvsp[-2].i_value));
",1,unused,1987,unused,"#line 510 ""bc.y""
    {
			      if (((yyvsp[-3].i_value) & EX_VOID) || ((yyvsp[0].i_value) & EX_VOID))
				yyerror (""void expression with &&"");
			      sprintf (genstr, ""DZ%d:p1N%d:"", (yyvsp[-2].i_value), (yyvsp[-2].i_value));
",unused,bcxenial-bc2Fbc.c
"#line 518 ""bc.y""
    {
			      warn(""|| operator"");
			      (yyvsp[0].i_value) = next_label++;
			      sprintf (genstr, ""B%d:"", (yyvsp[0].i_value));
",1,unused,1998,unused,"#line 518 ""bc.y""
    {
			      warn(""|| operator"");
			      (yyvsp[0].i_value) = next_label++;
			      sprintf (genstr, ""B%d:"", (yyvsp[0].i_value));
",unused,bcxenial-bc2Fbc.c
"			      int tmplab;
			      if (((yyvsp[-3].i_value) & EX_VOID) || ((yyvsp[0].i_value) & EX_VOID))
				yyerror (""void expression with ||"");
			      tmplab = next_label++;
			      sprintf (genstr, ""B%d:0J%d:N%d:1N%d:"",
",1,unused,2010,unused,"			      int tmplab;
			      if (((yyvsp[-3].i_value) & EX_VOID) || ((yyvsp[0].i_value) & EX_VOID))
				yyerror (""void expression with ||"");
			      tmplab = next_label++;
			      sprintf (genstr, ""B%d:0J%d:N%d:1N%d:"",
",unused,bcxenial-bc2Fbc.c
"#line 623 ""bc.y""
    {
			      (yyval.i_value) = EX_REG;
			      if ((yyvsp[0].i_value) < 0)
				sprintf (genstr, ""L%d:"", -(yyvsp[0].i_value));
",1,unused,2136,unused,"#line 623 ""bc.y""
    {
			      (yyval.i_value) = EX_REG;
			      if ((yyvsp[0].i_value) < 0)
				sprintf (genstr, ""L%d:"", -(yyvsp[0].i_value));
",unused,bcxenial-bc2Fbc.c
"			      (yyval.i_value) = EX_REG;
			      if ((yyvsp[0].i_value) < 0)
				sprintf (genstr, ""L%d:"", -(yyvsp[0].i_value));
			      else
				sprintf (genstr, ""l%d:"", (yyvsp[0].i_value));
",1,unused,2138,unused,"			      (yyval.i_value) = EX_REG;
			      if ((yyvsp[0].i_value) < 0)
				sprintf (genstr, ""L%d:"", -(yyvsp[0].i_value));
			      else
				sprintf (genstr, ""l%d:"", (yyvsp[0].i_value));
",unused,bcxenial-bc2Fbc.c
"				(yyval.i_value) = EX_REG;
			      if ((yyvsp[-1].a_value) != NULL)
				{ char *params = call_str ((yyvsp[-1].a_value));
				  set_genstr_size (20 + strlen (params));
				  sprintf (genstr, ""C%d,%s:"", fn, params);
",1,unused,2182,unused,"				(yyval.i_value) = EX_REG;
			      if ((yyvsp[-1].a_value) != NULL)
				{ char *params = call_str ((yyvsp[-1].a_value));
				  set_genstr_size (20 + strlen (params));
				  sprintf (genstr, ""C%d,%s:"", fn, params);
",unused,bcxenial-bc2Fbc.c
"				  free_args ((yyvsp[-1].a_value));
				}
			      else
				{
				  sprintf (genstr, ""C%d:"", fn);
",1,unused,2187,unused,"				  free_args ((yyvsp[-1].a_value));
				}
			      else
				{
				  sprintf (genstr, ""C%d:"", fn);
",unused,bcxenial-bc2Fbc.c
"			      (yyval.i_value) = EX_REG;
			      if ((yyvsp[0].i_value) < 0)
				{
				  if ((yyvsp[-1].c_value) == '+')
				    sprintf (genstr, ""DA%d:L%d:"", -(yyvsp[0].i_value), -(yyvsp[0].i_value));
",1,unused,2200,unused,"			      (yyval.i_value) = EX_REG;
			      if ((yyvsp[0].i_value) < 0)
				{
				  if ((yyvsp[-1].c_value) == '+')
				    sprintf (genstr, ""DA%d:L%d:"", -(yyvsp[0].i_value), -(yyvsp[0].i_value));
",unused,bcxenial-bc2Fbc.c
"				{
				  if ((yyvsp[-1].c_value) == '+')
				    sprintf (genstr, ""DA%d:L%d:"", -(yyvsp[0].i_value), -(yyvsp[0].i_value));
				  else
				    sprintf (genstr, ""DM%d:L%d:"", -(yyvsp[0].i_value), -(yyvsp[0].i_value));
",1,unused,2202,unused,"				{
				  if ((yyvsp[-1].c_value) == '+')
				    sprintf (genstr, ""DA%d:L%d:"", -(yyvsp[0].i_value), -(yyvsp[0].i_value));
				  else
				    sprintf (genstr, ""DM%d:L%d:"", -(yyvsp[0].i_value), -(yyvsp[0].i_value));
",unused,bcxenial-bc2Fbc.c
"				}
			      else
				{
				  if ((yyvsp[-1].c_value) == '+')
				    sprintf (genstr, ""i%d:l%d:"", (yyvsp[0].i_value), (yyvsp[0].i_value));
",1,unused,2207,unused,"				}
			      else
				{
				  if ((yyvsp[-1].c_value) == '+')
				    sprintf (genstr, ""i%d:l%d:"", (yyvsp[0].i_value), (yyvsp[0].i_value));
",unused,bcxenial-bc2Fbc.c
"				{
				  if ((yyvsp[-1].c_value) == '+')
				    sprintf (genstr, ""i%d:l%d:"", (yyvsp[0].i_value), (yyvsp[0].i_value));
				  else
				    sprintf (genstr, ""d%d:l%d:"", (yyvsp[0].i_value), (yyvsp[0].i_value));
",1,unused,2209,unused,"				{
				  if ((yyvsp[-1].c_value) == '+')
				    sprintf (genstr, ""i%d:l%d:"", (yyvsp[0].i_value), (yyvsp[0].i_value));
				  else
				    sprintf (genstr, ""d%d:l%d:"", (yyvsp[0].i_value), (yyvsp[0].i_value));
",unused,bcxenial-bc2Fbc.c
"    {
			      (yyval.i_value) = EX_REG;
			      if ((yyvsp[-1].i_value) < 0)
				{
				  sprintf (genstr, ""DL%d:x"", -(yyvsp[-1].i_value));
",1,unused,2221,unused,"    {
			      (yyval.i_value) = EX_REG;
			      if ((yyvsp[-1].i_value) < 0)
				{
				  sprintf (genstr, ""DL%d:x"", -(yyvsp[-1].i_value));
",unused,bcxenial-bc2Fbc.c
"				{
				  sprintf (genstr, ""DL%d:x"", -(yyvsp[-1].i_value));
				  generate (genstr); 
				  if ((yyvsp[0].c_value) == '+')
				    sprintf (genstr, ""A%d:"", -(yyvsp[-1].i_value));
",1,unused,2224,unused,"				{
				  sprintf (genstr, ""DL%d:x"", -(yyvsp[-1].i_value));
				  generate (genstr); 
				  if ((yyvsp[0].c_value) == '+')
				    sprintf (genstr, ""A%d:"", -(yyvsp[-1].i_value));
",unused,bcxenial-bc2Fbc.c
"				  generate (genstr); 
				  if ((yyvsp[0].c_value) == '+')
				    sprintf (genstr, ""A%d:"", -(yyvsp[-1].i_value));
				  else
				      sprintf (genstr, ""M%d:"", -(yyvsp[-1].i_value));
",1,unused,2226,unused,"				  generate (genstr); 
				  if ((yyvsp[0].c_value) == '+')
				    sprintf (genstr, ""A%d:"", -(yyvsp[-1].i_value));
				  else
				      sprintf (genstr, ""M%d:"", -(yyvsp[-1].i_value));
",unused,bcxenial-bc2Fbc.c
"				      sprintf (genstr, ""M%d:"", -(yyvsp[-1].i_value));
				}
			      else
				{
				  sprintf (genstr, ""l%d:"", (yyvsp[-1].i_value));
",1,unused,2230,unused,"				      sprintf (genstr, ""M%d:"", -(yyvsp[-1].i_value));
				}
			      else
				{
				  sprintf (genstr, ""l%d:"", (yyvsp[-1].i_value));
",unused,bcxenial-bc2Fbc.c
"				{
				  sprintf (genstr, ""l%d:"", (yyvsp[-1].i_value));
				  generate (genstr);
				  if ((yyvsp[0].c_value) == '+')
				    sprintf (genstr, ""i%d:"", (yyvsp[-1].i_value));
",1,unused,2233,unused,"				{
				  sprintf (genstr, ""l%d:"", (yyvsp[-1].i_value));
				  generate (genstr);
				  if ((yyvsp[0].c_value) == '+')
				    sprintf (genstr, ""i%d:"", (yyvsp[-1].i_value));
",unused,bcxenial-bc2Fbc.c
"				  generate (genstr);
				  if ((yyvsp[0].c_value) == '+')
				    sprintf (genstr, ""i%d:"", (yyvsp[-1].i_value));
				  else
				    sprintf (genstr, ""d%d:"", (yyvsp[-1].i_value));
",1,unused,2235,unused,"				  generate (genstr);
				  if ((yyvsp[0].c_value) == '+')
				    sprintf (genstr, ""i%d:"", (yyvsp[-1].i_value));
				  else
				    sprintf (genstr, ""d%d:"", (yyvsp[-1].i_value));
",unused,bcxenial-bc2Fbc.c
"{
  char *temp;

  temp = (char *) bc_malloc (strlen (str)+1);
  return (strcpy (temp,str));
",1,unused,51,unused,"{
  char *temp;

  temp = (char *) bc_malloc (strlen (str)+1);
  return (strcpy (temp,str));
",unused,bcxenial-bc2Futil.c
"
  /* Add the current number to the end of the string. */
  if (args->arg_is_var)
    if (len != 1) 
      sprintf (sval, ""*%d,"", args->av_name);
",1,unused,109,unused,"
  /* Add the current number to the end of the string. */
  if (args->arg_is_var)
    if (len != 1) 
      sprintf (sval, ""*%d,"", args->av_name);
",unused,bcxenial-bc2Futil.c
"  if (args->arg_is_var)
    if (len != 1) 
      sprintf (sval, ""*%d,"", args->av_name);
    else
      sprintf (sval, ""*%d"", args->av_name);
",1,unused,111,unused,"  if (args->arg_is_var)
    if (len != 1) 
      sprintf (sval, ""*%d,"", args->av_name);
    else
      sprintf (sval, ""*%d"", args->av_name);
",unused,bcxenial-bc2Futil.c
"    else
      sprintf (sval, ""*%d"", args->av_name);
  else
    if (len != 1) 
      sprintf (sval, ""%d,"", args->av_name);
",1,unused,114,unused,"    else
      sprintf (sval, ""*%d"", args->av_name);
  else
    if (len != 1) 
      sprintf (sval, ""%d,"", args->av_name);
",unused,bcxenial-bc2Futil.c
"  else
    if (len != 1) 
      sprintf (sval, ""%d,"", args->av_name);
    else
      sprintf (sval, ""%d"", args->av_name);
",1,unused,116,unused,"  else
    if (len != 1) 
      sprintf (sval, ""%d,"", args->av_name);
    else
      sprintf (sval, ""%d"", args->av_name);
",unused,bcxenial-bc2Futil.c
"    if (len != 1) 
      sprintf (sval, ""%d,"", args->av_name);
    else
      sprintf (sval, ""%d"", args->av_name);
  temp = strcat (temp, sval);
",1,unused,117,unused,"    if (len != 1) 
      sprintf (sval, ""%d,"", args->av_name);
    else
      sprintf (sval, ""%d"", args->av_name);
  temp = strcat (temp, sval);
",unused,bcxenial-bc2Futil.c
"	/*
	 * Turn off search.
	 */
	if (dns_name_countlabels(name) > 1U)
		strcat(namebuf, ""."");
",1,unused,213,unused,"	/*
	 * Turn off search.
	 */
	if (dns_name_countlabels(name) > 1U)
		strcat(namebuf, ""."");
",unused,bind-9.11.0-bin2Fcheck2Fcheck-tool.c
"	/*
	 * Turn off search.
	 */
	if (dns_name_countlabels(name) > 1U)
		strcat(namebuf, ""."");
",1,unused,402,unused,"	/*
	 * Turn off search.
	 */
	if (dns_name_countlabels(name) > 1U)
		strcat(namebuf, ""."");
",unused,bind-9.11.0-bin2Fcheck2Fcheck-tool.c
"	/*
	 * Turn off search.
	 */
	if (dns_name_countlabels(name) > 1U)
		strcat(namebuf, ""."");
",1,unused,487,unused,"	/*
	 * Turn off search.
	 */
	if (dns_name_countlabels(name) > 1U)
		strcat(namebuf, ""."");
",unused,bind-9.11.0-bin2Fcheck2Fcheck-tool.c
"		need_clone = ISC_TRUE;
		lookup->trace_root = ISC_TF(lookup->trace ||
					    lookup->ns_search_only);
		lookup->new_search = ISC_TRUE;
		strcpy(lookup->textname, ""."");
",1,unused,2055,unused,"		need_clone = ISC_TRUE;
		lookup->trace_root = ISC_TF(lookup->trace ||
					    lookup->ns_search_only);
		lookup->new_search = ISC_TRUE;
		strcpy(lookup->textname, ""."");
",unused,bind-9.11.0-bin2Fdig2Fdig.c
"	filename = isc_mem_get(mctx, filenamelen + 1);
	if (filename == NULL)
		fatal(""out of memory"");
	if (dsdir != NULL)
		sprintf(filename, ""%s/"", dsdir);
",1,unused,2816,unused,"	filename = isc_mem_get(mctx, filenamelen + 1);
	if (filename == NULL)
		fatal(""out of memory"");
	if (dsdir != NULL)
		sprintf(filename, ""%s/"", dsdir);
",unused,bind-9.11.0-bin2Fdnssec2Fdnssec-signzone.c
"	if (dsdir != NULL)
		sprintf(filename, ""%s/"", dsdir);
	else
		filename[0] = 0;
	strcat(filename, prefix);
",1,unused,2819,unused,"	if (dsdir != NULL)
		sprintf(filename, ""%s/"", dsdir);
	else
		filename[0] = 0;
	strcat(filename, prefix);
",unused,bind-9.11.0-bin2Fdnssec2Fdnssec-signzone.c
"		sprintf(filename, ""%s/"", dsdir);
	else
		filename[0] = 0;
	strcat(filename, prefix);
	strcat(filename, namestr);
",1,unused,2820,unused,"		sprintf(filename, ""%s/"", dsdir);
	else
		filename[0] = 0;
	strcat(filename, prefix);
	strcat(filename, namestr);
",unused,bind-9.11.0-bin2Fdnssec2Fdnssec-signzone.c
"		output = isc_mem_allocate(mctx,
					  strlen(file) + strlen("".signed"") + 1);
		if (output == NULL)
			fatal(""out of memory"");
		sprintf(output, ""%s.signed"", file);
",1,unused,3493,unused,"		output = isc_mem_allocate(mctx,
					  strlen(file) + strlen("".signed"") + 1);
		if (output == NULL)
			fatal(""out of memory"");
		sprintf(output, ""%s.signed"", file);
",unused,bind-9.11.0-bin2Fdnssec2Fdnssec-signzone.c
"					     sizeof(typebuf));
			dns_rdataclass_format(rdataset->rdclass, classbuf,
					      sizeof(classbuf));
		} else {
			strcpy(typebuf, ""-"");
",1,unused,3852,unused,"					     sizeof(typebuf));
			dns_rdataclass_format(rdataset->rdclass, classbuf,
					      sizeof(classbuf));
		} else {
			strcpy(typebuf, ""-"");
",unused,bind-9.11.0-bin2Fnamed2Fclient.c
"			dns_rdataclass_format(rdataset->rdclass, classbuf,
					      sizeof(classbuf));
		} else {
			strcpy(typebuf, ""-"");
			strcpy(classbuf, ""-"");
",1,unused,3853,unused,"			dns_rdataclass_format(rdataset->rdclass, classbuf,
					      sizeof(classbuf));
		} else {
			strcpy(typebuf, ""-"");
			strcpy(classbuf, ""-"");
",unused,bind-9.11.0-bin2Fnamed2Fclient.c
"	cp = reverse;
	s6 = na->type.in6.s6_addr;
	while (prefixlen > 0) {
		prefixlen -= 8;
		sprintf(cp, ""%x.%x."", s6[prefixlen/8] & 0xf,
",1,unused,1704,unused,"	cp = reverse;
	s6 = na->type.in6.s6_addr;
	while (prefixlen > 0) {
		prefixlen -= 8;
		sprintf(cp, ""%x.%x."", s6[prefixlen/8] & 0xf,
",unused,bind-9.11.0-bin2Fnamed2Fserver.c
"		sprintf(cp, ""%x.%x."", s6[prefixlen/8] & 0xf,
			(s6[prefixlen/8] >> 4) & 0xf);
		cp += 4;
	}
	strcat(cp, ""ip6.arpa."");
",1,unused,1708,unused,"		sprintf(cp, ""%x.%x."", s6[prefixlen/8] & 0xf,
			(s6[prefixlen/8] >> 4) & 0xf);
		cp += 4;
	}
	strcat(cp, ""ip6.arpa."");
",unused,bind-9.11.0-bin2Fnamed2Fserver.c
"		l += snprintf(&buf[l], buf_len-l, ""%02x"", d[i]);
	}
	if (l >= buf_len-3) {
		REQUIRE(buf_len > sizeof(""...""));
		strcpy(&buf[l-sizeof("" ..."")], "" ..."");
",1,unused,266,unused,"		l += snprintf(&buf[l], buf_len-l, ""%02x"", d[i]);
	}
	if (l >= buf_len-3) {
		REQUIRE(buf_len > sizeof(""...""));
		strcpy(&buf[l-sizeof("" ..."")], "" ..."");
",unused,bind-9.11.0-bin2Ftests2Fhashes2Ft_hashes.c
"		free(state);
		return (ISC_R_NOMEMORY);
	}
	if (argv[1][strlen(argv[1]) - 1] == '.')
		strcpy(state->zone_name, argv[1]);
",1,unused,264,unused,"		free(state);
		return (ISC_R_NOMEMORY);
	}
	if (argv[1][strlen(argv[1]) - 1] == '.')
		strcpy(state->zone_name, argv[1]);
",unused,bind-9.11.0-bin2Ftests2Fsystem2Fdlzexternal2Fdriver.c
"	}
	if (argv[1][strlen(argv[1]) - 1] == '.')
		strcpy(state->zone_name, argv[1]);
	else
		sprintf(state->zone_name, ""%s."", argv[1]);
",1,unused,266,unused,"	}
	if (argv[1][strlen(argv[1]) - 1] == '.')
		strcpy(state->zone_name, argv[1]);
	else
		sprintf(state->zone_name, ""%s."", argv[1]);
",unused,bind-9.11.0-bin2Ftests2Fsystem2Fdlzexternal2Fdriver.c
"		extra = "".root"";
	else
		extra = ""."";

	n = sprintf(soa_data, ""%s hostmaster%s%s 123 900 600 86400 3600"",
",1,unused,273,unused,"		extra = "".root"";
	else
		extra = ""."";

	n = sprintf(soa_data, ""%s hostmaster%s%s 123 900 600 86400 3600"",
",unused,bind-9.11.0-bin2Ftests2Fsystem2Fdlzexternal2Fdriver.c
"	isc_sockaddr_t *src;
	char addrbuf[100];
	char absolute[1024];

	strcpy(addrbuf, ""unknown"");
",1,unused,329,unused,"	isc_sockaddr_t *src;
	char addrbuf[100];
	char absolute[1024];

	strcpy(addrbuf, ""unknown"");
",unused,bind-9.11.0-bin2Ftests2Fsystem2Fdlzexternal2Fdriver.c
"				   ""transaction"");
	}

	if (strcmp(name, ""source-addr"") == 0) {
		strcpy(buf, ""unknown"");
",1,unused,458,unused,"				   ""transaction"");
	}

	if (strcmp(name, ""source-addr"") == 0) {
		strcpy(buf, ""unknown"");
",unused,bind-9.11.0-bin2Ftests2Fsystem2Fdlzexternal2Fdriver.c
"	} else if (strlen(hostname) <= 127U) {
		char tmpbuf[128], *d;
		isc_uint32_t zone = 0;

		strcpy(tmpbuf, hostname);
",1,unused,84,unused,"	} else if (strlen(hostname) <= 127U) {
		char tmpbuf[128], *d;
		isc_uint32_t zone = 0;

		strcpy(tmpbuf, hostname);
",unused,bind-9.11.0-lib2Fbind92Fgetaddresses.c
"			*cp++ = hex_digits[(bytes[i] >> 4) & 0x0f];
			*cp++ = '.';
		}
		if ((options & DNS_BYADDROPT_IPV6INT) != 0)
			strcpy(cp, ""ip6.int."");
",1,unused,91,unused,"			*cp++ = hex_digits[(bytes[i] >> 4) & 0x0f];
			*cp++ = '.';
		}
		if ((options & DNS_BYADDROPT_IPV6INT) != 0)
			strcpy(cp, ""ip6.int."");
",unused,bind-9.11.0-lib2Fdns2Fbyaddr.c
"		}
		if ((options & DNS_BYADDROPT_IPV6INT) != 0)
			strcpy(cp, ""ip6.int."");
		else
			strcpy(cp, ""ip6.arpa."");
",1,unused,93,unused,"		}
		if ((options & DNS_BYADDROPT_IPV6INT) != 0)
			strcpy(cp, ""ip6.int."");
		else
			strcpy(cp, ""ip6.arpa."");
",unused,bind-9.11.0-lib2Fdns2Fbyaddr.c
"		return (result);
	len = 1 + 3 + 1 + 5 + strlen(suffix) + 1;
	if (isc_buffer_availablelength(out) < len)
		return (ISC_R_NOSPACE);
	sprintf((char *) isc_buffer_used(out), ""+%03d+%05d%s"", alg, id,
",1,unused,1845,unused,"		return (result);
	len = 1 + 3 + 1 + 5 + strlen(suffix) + 1;
	if (isc_buffer_availablelength(out) < len)
		return (ISC_R_NOSPACE);
	sprintf((char *) isc_buffer_used(out), ""+%03d+%05d%s"", alg, id,
",unused,bind-9.11.0-lib2Fdns2Fdst_api.c
"
	for (i = 0; i < TYPENAMES; i++)
		memset(&typenames[i], 0, sizeof(typenames[i]));

	strcpy(srcdir, """");
",1,unused,533,unused,"
	for (i = 0; i < TYPENAMES; i++)
		memset(&typenames[i], 0, sizeof(typenames[i]));

	strcpy(srcdir, """");
",unused,bind-9.11.0-lib2Fdns2Fgen.c
"			n = snprintf(year, sizeof(year), ""-%d"",
				     tm->tm_year + 1900);
			INSIST(n > 0 && (unsigned)n < sizeof(year));
		} else
			strcpy(year, ""-2016"");
",1,unused,624,unused,"			n = snprintf(year, sizeof(year), ""-%d"",
				     tm->tm_year + 1900);
			INSIST(n > 0 && (unsigned)n < sizeof(year));
		} else
			strcpy(year, ""-2016"");
",unused,bind-9.11.0-lib2Fdns2Fgen.c
"			INSIST(n > 0 && (unsigned)n < sizeof(year));
		} else
			strcpy(year, ""-2016"");
	} else
		strcpy(year, ""-2016"");
",1,unused,626,unused,"			INSIST(n > 0 && (unsigned)n < sizeof(year));
		} else
			strcpy(year, ""-2016"");
	} else
		strcpy(year, ""-2016"");
",unused,bind-9.11.0-lib2Fdns2Fgen.c
"				isc_textregion_consume(&r, 1);
				continue;
			}
			nibblemode = ISC_FALSE;
			strcpy(fmt, ""%d"");
",1,unused,727,unused,"				isc_textregion_consume(&r, 1);
				continue;
			}
			nibblemode = ISC_FALSE;
			strcpy(fmt, ""%d"");
",unused,bind-9.11.0-lib2Fdns2Fmaster.c
"					nlen--;
				} else {
					if (trem < 3)
						return (ISC_R_NOSPACE);
					sprintf(tdata, ""%%%02X"", c);
",1,unused,1653,unused,"					nlen--;
				} else {
					if (trem < 3)
						return (ISC_R_NOSPACE);
					sprintf(tdata, ""%%%02X"", c);
",unused,bind-9.11.0-lib2Fdns2Fname.c
"		else
			isc_buffer_putstr(buf, ""Signing with "");

		dns_secalg_format(alg, algbuf, sizeof(algbuf));
		sprintf(keybuf, ""key %d/%s"", keyid, algbuf);
",1,unused,354,unused,"		else
			isc_buffer_putstr(buf, ""Signing with "");

		dns_secalg_format(alg, algbuf, sizeof(algbuf));
		sprintf(keybuf, ""key %d/%s"", keyid, algbuf);
",unused,bind-9.11.0-lib2Fdns2Fprivate.c
"		if (dns_name_dynamic(&rbtdb->common.origin))
			dns_name_format(&rbtdb->common.origin, buf,
					sizeof(buf));
		else
			strcpy(buf, ""<UNKNOWN>"");
",1,unused,1244,unused,"		if (dns_name_dynamic(&rbtdb->common.origin))
			dns_name_format(&rbtdb->common.origin, buf,
					sizeof(buf));
		else
			strcpy(buf, ""<UNKNOWN>"");
",unused,bind-9.11.0-lib2Fdns2Frbtdb.c
"			if (dns_name_dynamic(&rbtdb->common.origin))
				dns_name_format(&rbtdb->common.origin, buf,
						sizeof(buf));
			else
				strcpy(buf, ""<UNKNOWN>"");
",1,unused,1373,unused,"			if (dns_name_dynamic(&rbtdb->common.origin))
				dns_name_format(&rbtdb->common.origin, buf,
						sizeof(buf));
			else
				strcpy(buf, ""<UNKNOWN>"");
",unused,bind-9.11.0-lib2Fdns2Frbtdb.c
"			if (dns_name_dynamic(&rbtdb->common.origin))
				dns_name_format(&rbtdb->common.origin, buf,
						sizeof(buf));
			else
				strcpy(buf, ""<UNKNOWN>"");
",1,unused,5473,unused,"			if (dns_name_dynamic(&rbtdb->common.origin))
				dns_name_format(&rbtdb->common.origin, buf,
						sizeof(buf));
			else
				strcpy(buf, ""<UNKNOWN>"");
",unused,bind-9.11.0-lib2Fdns2Frbtdb.c
"				if (dns_rdatatype_isknown(t)) {
					RETERR(dns_rdatatype_totext(t, target));
				} else {
					char buf[sizeof(""TYPE65535"")];
					sprintf(buf, ""TYPE%u"", t);
",1,unused,511,unused,"				if (dns_rdatatype_isknown(t)) {
					RETERR(dns_rdatatype_totext(t, target));
				} else {
					char buf[sizeof(""TYPE65535"")];
					sprintf(buf, ""TYPE%u"", t);
",unused,bind-9.11.0-lib2Fdns2Frdata.c
"	 * Fudge.
	 */
	n = uint16_fromregion(&sr);
	isc_region_consume(&sr, 2);
	sprintf(buf, ""%u "", n);
",1,unused,177,unused,"	 * Fudge.
	 */
	n = uint16_fromregion(&sr);
	isc_region_consume(&sr, 2);
	sprintf(buf, ""%u "", n);
",unused,bind-9.11.0-lib2Fdns2Frdata2Fany_2552Ftsig_250.c
"	 * Signature Size.
	 */
	n = uint16_fromregion(&sr);
	isc_region_consume(&sr, 2);
	sprintf(buf, ""%u"", n);
",1,unused,185,unused,"	 * Signature Size.
	 */
	n = uint16_fromregion(&sr);
	isc_region_consume(&sr, 2);
	sprintf(buf, ""%u"", n);
",unused,bind-9.11.0-lib2Fdns2Frdata2Fany_2552Ftsig_250.c
"	 * Original ID.
	 */
	n = uint16_fromregion(&sr);
	isc_region_consume(&sr, 2);
	sprintf(buf, ""%u "", n);
",1,unused,213,unused,"	 * Original ID.
	 */
	n = uint16_fromregion(&sr);
	isc_region_consume(&sr, 2);
	sprintf(buf, ""%u "", n);
",unused,bind-9.11.0-lib2Fdns2Frdata2Fany_2552Ftsig_250.c
"	 * Other Size.
	 */
	n = uint16_fromregion(&sr);
	isc_region_consume(&sr, 2);
	sprintf(buf, "" %u "", n);
",1,unused,228,unused,"	 * Other Size.
	 */
	n = uint16_fromregion(&sr);
	isc_region_consume(&sr, 2);
	sprintf(buf, "" %u "", n);
",unused,bind-9.11.0-lib2Fdns2Frdata2Fany_2552Ftsig_250.c
"
	sub = name_prefix(&name, tctx->origin, &prefix);
	RETERR(dns_name_totext(&prefix, sub, target));

	sprintf(buf, ""%o"", addr); /* note octal */
",1,unused,83,unused,"
	sub = name_prefix(&name, tctx->origin, &prefix);
	RETERR(dns_name_totext(&prefix, sub, target));

	sprintf(buf, ""%o"", addr); /* note octal */
",unused,bind-9.11.0-lib2Fdns2Frdata2Fch_32Fa_1.c
"
	dns_rdata_toregion(rdata, &region);
	num = uint16_fromregion(&region);
	isc_region_consume(&region, 2);
	sprintf(buf, ""%u "", num);
",1,unused,80,unused,"
	dns_rdata_toregion(rdata, &region);
	num = uint16_fromregion(&region);
	isc_region_consume(&region, 2);
	sprintf(buf, ""%u "", num);
",unused,bind-9.11.0-lib2Fdns2Frdata2Fgeneric2Fafsdb_18.c
"	/*
	 * Flags
	 */
	flags = uint8_consume_fromregion(&region);
	sprintf(buf, ""%u "", flags);
",1,unused,98,unused,"	/*
	 * Flags
	 */
	flags = uint8_consume_fromregion(&region);
	sprintf(buf, ""%u "", flags);
",unused,bind-9.11.0-lib2Fdns2Frdata2Fgeneric2Fcaa_257.c
"	 * Key tag.
	 */
	n = uint16_fromregion(&sr);
	isc_region_consume(&sr, 2);
	sprintf(buf, ""%u "", n);
",1,unused,88,unused,"	 * Key tag.
	 */
	n = uint16_fromregion(&sr);
	isc_region_consume(&sr, 2);
	sprintf(buf, ""%u "", n);
",unused,bind-9.11.0-lib2Fdns2Frdata2Fgeneric2Fcert_37.c
"	dns_rdata_toregion(rdata, &sr);

	num = uint32_fromregion(&sr);
	isc_region_consume(&sr, 4);
	sprintf(buf, ""%lu"", num);
",1,unused,59,unused,"	dns_rdata_toregion(rdata, &sr);

	num = uint32_fromregion(&sr);
	isc_region_consume(&sr, 4);
	sprintf(buf, ""%lu"", num);
",unused,bind-9.11.0-lib2Fdns2Frdata2Fgeneric2Fcsync_62.c
"	RETERR(str_totext("" "", target));

	num = uint16_fromregion(&sr);
	isc_region_consume(&sr, 2);
	sprintf(buf, ""%lu"", num);
",1,unused,66,unused,"	RETERR(str_totext("" "", target));

	num = uint16_fromregion(&sr);
	isc_region_consume(&sr, 2);
	sprintf(buf, ""%lu"", num);
",unused,bind-9.11.0-lib2Fdns2Frdata2Fgeneric2Fcsync_62.c
"	 * Key tag.
	 */
	n = uint16_fromregion(&sr);
	isc_region_consume(&sr, 2);
	sprintf(buf, ""%u "", n);
",1,unused,114,unused,"	 * Key tag.
	 */
	n = uint16_fromregion(&sr);
	isc_region_consume(&sr, 2);
	sprintf(buf, ""%u "", n);
",unused,bind-9.11.0-lib2Fdns2Frdata2Fgeneric2Fds_43.c
"	 * Algorithm.
	 */
	n = uint8_fromregion(&sr);
	isc_region_consume(&sr, 1);
	sprintf(buf, ""%u "", n);
",1,unused,122,unused,"	 * Algorithm.
	 */
	n = uint8_fromregion(&sr);
	isc_region_consume(&sr, 1);
	sprintf(buf, ""%u "", n);
",unused,bind-9.11.0-lib2Fdns2Frdata2Fgeneric2Fds_43.c
"	 * Digest type.
	 */
	n = uint8_fromregion(&sr);
	isc_region_consume(&sr, 1);
	sprintf(buf, ""%u"", n);
",1,unused,130,unused,"	 * Digest type.
	 */
	n = uint8_fromregion(&sr);
	isc_region_consume(&sr, 1);
	sprintf(buf, ""%u"", n);
",unused,bind-9.11.0-lib2Fdns2Frdata2Fgeneric2Fds_43.c
"
	/*
	 * Algorithm
	 */
	sprintf(buf, ""%u "", algorithm);
",1,unused,143,unused,"
	/*
	 * Algorithm
	 */
	sprintf(buf, ""%u "", algorithm);
",unused,bind-9.11.0-lib2Fdns2Frdata2Fgeneric2Fhip_55.c
"	 */
	dns_rdata_toregion(rdata, &region);
	num = uint8_fromregion(&region);
	isc_region_consume(&region, 1);
	sprintf(buf, ""%u "", num);
",1,unused,137,unused,"	 */
	dns_rdata_toregion(rdata, &region);
	num = uint8_fromregion(&region);
	isc_region_consume(&region, 1);
	sprintf(buf, ""%u "", num);
",unused,bind-9.11.0-lib2Fdns2Frdata2Fgeneric2Fipseckey_45.c
"	 * Gateway type.
	 */
	gateway = uint8_fromregion(&region);
	isc_region_consume(&region, 1);
	sprintf(buf, ""%u "", gateway);
",1,unused,145,unused,"	 * Gateway type.
	 */
	gateway = uint8_fromregion(&region);
	isc_region_consume(&region, 1);
	sprintf(buf, ""%u "", gateway);
",unused,bind-9.11.0-lib2Fdns2Frdata2Fgeneric2Fipseckey_45.c
"	 * Algorithm.
	 */
	num = uint8_fromregion(&region);
	isc_region_consume(&region, 1);
	sprintf(buf, ""%u "", num);
",1,unused,153,unused,"	 * Algorithm.
	 */
	num = uint8_fromregion(&region);
	isc_region_consume(&region, 1);
	sprintf(buf, ""%u "", num);
",unused,bind-9.11.0-lib2Fdns2Frdata2Fgeneric2Fipseckey_45.c
"
	/* flags */
	flags = uint16_fromregion(&sr);
	isc_region_consume(&sr, 2);
	sprintf(buf, ""%u"", flags);
",1,unused,88,unused,"
	/* flags */
	flags = uint16_fromregion(&sr);
	isc_region_consume(&sr, 2);
	sprintf(buf, ""%u"", flags);
",unused,bind-9.11.0-lib2Fdns2Frdata2Fgeneric2Fkey_25.c
"		keyinfo = ""ZSK"";


	/* protocol */
	sprintf(buf, ""%u"", sr.base[0]);
",1,unused,101,unused,"		keyinfo = ""ZSK"";


	/* protocol */
	sprintf(buf, ""%u"", sr.base[0]);
",unused,bind-9.11.0-lib2Fdns2Frdata2Fgeneric2Fkey_25.c
"	RETERR(str_totext("" "", target));

	/* algorithm */
	algorithm = sr.base[0];
	sprintf(buf, ""%u"", algorithm);
",1,unused,108,unused,"	RETERR(str_totext("" "", target));

	/* algorithm */
	algorithm = sr.base[0];
	sprintf(buf, ""%u"", algorithm);
",unused,bind-9.11.0-lib2Fdns2Frdata2Fgeneric2Fkey_25.c
"		RETERR(str_totext(""; alg = "", target));
		RETERR(str_totext(algbuf, target));
		RETERR(str_totext("" ; key id = "", target));
		dns_rdata_toregion(rdata, &tmpr);
		sprintf(buf, ""%u"", dst_region_computeid(&tmpr, algorithm));
",1,unused,164,unused,"		RETERR(str_totext(""; alg = "", target));
		RETERR(str_totext(algbuf, target));
		RETERR(str_totext("" ; key id = "", target));
		dns_rdata_toregion(rdata, &tmpr);
		sprintf(buf, ""%u"", dst_region_computeid(&tmpr, algorithm));
",unused,bind-9.11.0-lib2Fdns2Frdata2Fgeneric2Fkey_25.c
"
	/* flags */
	flags = uint16_fromregion(&sr);
	isc_region_consume(&sr, 2);
	sprintf(buf, ""%u"", flags);
",1,unused,125,unused,"
	/* flags */
	flags = uint16_fromregion(&sr);
	isc_region_consume(&sr, 2);
	sprintf(buf, ""%u"", flags);
",unused,bind-9.11.0-lib2Fdns2Frdata2Fgeneric2Fkeydata_65533.c
"	} else
		keyinfo = ""ZSK"";

	/* protocol */
	sprintf(buf, ""%u"", sr.base[0]);
",1,unused,137,unused,"	} else
		keyinfo = ""ZSK"";

	/* protocol */
	sprintf(buf, ""%u"", sr.base[0]);
",unused,bind-9.11.0-lib2Fdns2Frdata2Fgeneric2Fkeydata_65533.c
"	RETERR(str_totext("" "", target));

	/* algorithm */
	algorithm = sr.base[0];
	sprintf(buf, ""%u"", algorithm);
",1,unused,144,unused,"	RETERR(str_totext("" "", target));

	/* algorithm */
	algorithm = sr.base[0];
	sprintf(buf, ""%u"", algorithm);
",unused,bind-9.11.0-lib2Fdns2Frdata2Fgeneric2Fkeydata_65533.c
"		RETERR(str_totext(""; key id = "", target));
		dns_rdata_toregion(rdata, &tmpr);
		/* Skip over refresh, addhd, and removehd */
		isc_region_consume(&tmpr, 12);
		sprintf(buf, ""%u"", dst_region_computeid(&tmpr, algorithm));
",1,unused,187,unused,"		RETERR(str_totext(""; key id = "", target));
		dns_rdata_toregion(rdata, &tmpr);
		/* Skip over refresh, addhd, and removehd */
		isc_region_consume(&tmpr, 12);
		sprintf(buf, ""%u"", dst_region_computeid(&tmpr, algorithm));
",unused,bind-9.11.0-lib2Fdns2Frdata2Fgeneric2Fkeydata_65533.c
"
	dns_rdata_toregion(rdata, &region);
	num = uint16_fromregion(&region);
	isc_region_consume(&region, 2);
	sprintf(buf, ""%u"", num);
",1,unused,65,unused,"
	dns_rdata_toregion(rdata, &region);
	num = uint16_fromregion(&region);
	isc_region_consume(&region, 2);
	sprintf(buf, ""%u"", num);
",unused,bind-9.11.0-lib2Fdns2Frdata2Fgeneric2Fl32_105.c
"
	dns_rdata_toregion(rdata, &region);
	num = uint16_fromregion(&region);
	isc_region_consume(&region, 2);
	sprintf(buf, ""%u"", num);
",1,unused,59,unused,"
	dns_rdata_toregion(rdata, &region);
	num = uint16_fromregion(&region);
	isc_region_consume(&region, 2);
	sprintf(buf, ""%u"", num);
",unused,bind-9.11.0-lib2Fdns2Frdata2Fgeneric2Fl64_106.c
"	RETERR(str_totext(buf, target));

	RETERR(str_totext("" "", target));

	sprintf(buf, ""%x:%x:%x:%x"",
",1,unused,64,unused,"	RETERR(str_totext(buf, target));

	RETERR(str_totext("" "", target));

	sprintf(buf, ""%x:%x:%x:%x"",
",unused,bind-9.11.0-lib2Fdns2Frdata2Fgeneric2Fl64_106.c
"
	size = sr.base[1];
	INSIST((size&0x0f) < 10 && (size>>4) < 10);
	if ((size&0x0f)> 1)
		sprintf(sbuf, ""%lum"", (size>>4) * poweroften[(size&0x0f)-2]);
",1,unused,482,unused,"
	size = sr.base[1];
	INSIST((size&0x0f) < 10 && (size>>4) < 10);
	if ((size&0x0f)> 1)
		sprintf(sbuf, ""%lum"", (size>>4) * poweroften[(size&0x0f)-2]);
",unused,bind-9.11.0-lib2Fdns2Frdata2Fgeneric2Floc_29.c
"	INSIST((size&0x0f) < 10 && (size>>4) < 10);
	if ((size&0x0f)> 1)
		sprintf(sbuf, ""%lum"", (size>>4) * poweroften[(size&0x0f)-2]);
	else
		sprintf(sbuf, ""0.%02lum"", (size>>4) * poweroften[(size&0x0f)]);
",1,unused,484,unused,"	INSIST((size&0x0f) < 10 && (size>>4) < 10);
	if ((size&0x0f)> 1)
		sprintf(sbuf, ""%lum"", (size>>4) * poweroften[(size&0x0f)-2]);
	else
		sprintf(sbuf, ""0.%02lum"", (size>>4) * poweroften[(size&0x0f)]);
",unused,bind-9.11.0-lib2Fdns2Frdata2Fgeneric2Floc_29.c
"		sprintf(sbuf, ""0.%02lum"", (size>>4) * poweroften[(size&0x0f)]);
	hp = sr.base[2];
	INSIST((hp&0x0f) < 10 && (hp>>4) < 10);
	if ((hp&0x0f)> 1)
		sprintf(hbuf, ""%lum"", (hp>>4) * poweroften[(hp&0x0f)-2]);
",1,unused,488,unused,"		sprintf(sbuf, ""0.%02lum"", (size>>4) * poweroften[(size&0x0f)]);
	hp = sr.base[2];
	INSIST((hp&0x0f) < 10 && (hp>>4) < 10);
	if ((hp&0x0f)> 1)
		sprintf(hbuf, ""%lum"", (hp>>4) * poweroften[(hp&0x0f)-2]);
",unused,bind-9.11.0-lib2Fdns2Frdata2Fgeneric2Floc_29.c
"	INSIST((hp&0x0f) < 10 && (hp>>4) < 10);
	if ((hp&0x0f)> 1)
		sprintf(hbuf, ""%lum"", (hp>>4) * poweroften[(hp&0x0f)-2]);
	else
		sprintf(hbuf, ""0.%02lum"", (hp>>4) * poweroften[(hp&0x0f)]);
",1,unused,490,unused,"	INSIST((hp&0x0f) < 10 && (hp>>4) < 10);
	if ((hp&0x0f)> 1)
		sprintf(hbuf, ""%lum"", (hp>>4) * poweroften[(hp&0x0f)-2]);
	else
		sprintf(hbuf, ""0.%02lum"", (hp>>4) * poweroften[(hp&0x0f)]);
",unused,bind-9.11.0-lib2Fdns2Frdata2Fgeneric2Floc_29.c
"		sprintf(hbuf, ""0.%02lum"", (hp>>4) * poweroften[(hp&0x0f)]);
	vp = sr.base[3];
	INSIST((vp&0x0f) < 10 && (vp>>4) < 10);
	if ((vp&0x0f)> 1)
		sprintf(vbuf, ""%lum"", (vp>>4) * poweroften[(vp&0x0f)-2]);
",1,unused,494,unused,"		sprintf(hbuf, ""0.%02lum"", (hp>>4) * poweroften[(hp&0x0f)]);
	vp = sr.base[3];
	INSIST((vp&0x0f) < 10 && (vp>>4) < 10);
	if ((vp&0x0f)> 1)
		sprintf(vbuf, ""%lum"", (vp>>4) * poweroften[(vp&0x0f)-2]);
",unused,bind-9.11.0-lib2Fdns2Frdata2Fgeneric2Floc_29.c
"	INSIST((vp&0x0f) < 10 && (vp>>4) < 10);
	if ((vp&0x0f)> 1)
		sprintf(vbuf, ""%lum"", (vp>>4) * poweroften[(vp&0x0f)-2]);
	else
		sprintf(vbuf, ""0.%02lum"", (vp>>4) * poweroften[(vp&0x0f)]);
",1,unused,496,unused,"	INSIST((vp&0x0f) < 10 && (vp>>4) < 10);
	if ((vp&0x0f)> 1)
		sprintf(vbuf, ""%lum"", (vp>>4) * poweroften[(vp&0x0f)-2]);
	else
		sprintf(vbuf, ""0.%02lum"", (vp>>4) * poweroften[(vp&0x0f)]);
",unused,bind-9.11.0-lib2Fdns2Frdata2Fgeneric2Floc_29.c
"		below =ISC_FALSE;
		altitude -= 10000000;
	}

	sprintf(buf, ""%d %d %d.%03d %s %d %d %d.%03d %s %s%ld.%02ldm %s %s %s"",
",1,unused,545,unused,"		below =ISC_FALSE;
		altitude -= 10000000;
	}

	sprintf(buf, ""%d %d %d.%03d %s %d %d %d.%03d %s %s%ld.%02ldm %s %s %s"",
",unused,bind-9.11.0-lib2Fdns2Frdata2Fgeneric2Floc_29.c
"
	dns_rdata_toregion(rdata, &region);
	num = uint16_fromregion(&region);
	isc_region_consume(&region, 2);
	sprintf(buf, ""%u"", num);
",1,unused,64,unused,"
	dns_rdata_toregion(rdata, &region);
	num = uint16_fromregion(&region);
	isc_region_consume(&region, 2);
	sprintf(buf, ""%u"", num);
",unused,bind-9.11.0-lib2Fdns2Frdata2Fgeneric2Flp_107.c
"
	dns_rdata_toregion(rdata, &region);
	num = uint16_fromregion(&region);
	isc_region_consume(&region, 2);
	sprintf(buf, ""%u"", num);
",1,unused,104,unused,"
	dns_rdata_toregion(rdata, &region);
	num = uint16_fromregion(&region);
	isc_region_consume(&region, 2);
	sprintf(buf, ""%u"", num);
",unused,bind-9.11.0-lib2Fdns2Frdata2Fgeneric2Fmx_15.c
"	 * Order.
	 */
	num = uint16_fromregion(&region);
	isc_region_consume(&region, 2);
	sprintf(buf, ""%u"", num);
",1,unused,203,unused,"	 * Order.
	 */
	num = uint16_fromregion(&region);
	isc_region_consume(&region, 2);
	sprintf(buf, ""%u"", num);
",unused,bind-9.11.0-lib2Fdns2Frdata2Fgeneric2Fnaptr_35.c
"	 * Preference.
	 */
	num = uint16_fromregion(&region);
	isc_region_consume(&region, 2);
	sprintf(buf, ""%u"", num);
",1,unused,212,unused,"	 * Preference.
	 */
	num = uint16_fromregion(&region);
	isc_region_consume(&region, 2);
	sprintf(buf, ""%u"", num);
",unused,bind-9.11.0-lib2Fdns2Frdata2Fgeneric2Fnaptr_35.c
"
	dns_rdata_toregion(rdata, &region);
	num = uint16_fromregion(&region);
	isc_region_consume(&region, 2);
	sprintf(buf, ""%u"", num);
",1,unused,59,unused,"
	dns_rdata_toregion(rdata, &region);
	num = uint16_fromregion(&region);
	isc_region_consume(&region, 2);
	sprintf(buf, ""%u"", num);
",unused,bind-9.11.0-lib2Fdns2Frdata2Fgeneric2Fnid_104.c
"	RETERR(str_totext(buf, target));

	RETERR(str_totext("" "", target));

	sprintf(buf, ""%x:%x:%x:%x"",
",1,unused,64,unused,"	RETERR(str_totext(buf, target));

	RETERR(str_totext("" "", target));

	sprintf(buf, ""%x:%x:%x:%x"",
",unused,bind-9.11.0-lib2Fdns2Frdata2Fgeneric2Fnid_104.c
"
	/* Hash */
	hash = uint8_fromregion(&sr);
	isc_region_consume(&sr, 1);
	sprintf(buf, ""%u "", hash);
",1,unused,118,unused,"
	/* Hash */
	hash = uint8_fromregion(&sr);
	isc_region_consume(&sr, 1);
	sprintf(buf, ""%u "", hash);
",unused,bind-9.11.0-lib2Fdns2Frdata2Fgeneric2Fnsec3_50.c
"
	/* Flags */
	flags = uint8_fromregion(&sr);
	isc_region_consume(&sr, 1);
	sprintf(buf, ""%u "", flags);
",1,unused,124,unused,"
	/* Flags */
	flags = uint8_fromregion(&sr);
	isc_region_consume(&sr, 1);
	sprintf(buf, ""%u "", flags);
",unused,bind-9.11.0-lib2Fdns2Frdata2Fgeneric2Fnsec3_50.c
"
	/* Iterations */
	iterations = uint16_fromregion(&sr);
	isc_region_consume(&sr, 2);
	sprintf(buf, ""%u "", iterations);
",1,unused,130,unused,"
	/* Iterations */
	iterations = uint16_fromregion(&sr);
	isc_region_consume(&sr, 2);
	sprintf(buf, ""%u "", iterations);
",unused,bind-9.11.0-lib2Fdns2Frdata2Fgeneric2Fnsec3_50.c
"
	iterations = uint16_fromregion(&sr);
	isc_region_consume(&sr, 2);

	sprintf(buf, ""%u "", hash);
",1,unused,112,unused,"
	iterations = uint16_fromregion(&sr);
	isc_region_consume(&sr, 2);

	sprintf(buf, ""%u "", hash);
",unused,bind-9.11.0-lib2Fdns2Frdata2Fgeneric2Fnsec3param_51.c
"
	sprintf(buf, ""%u "", hash);
	RETERR(str_totext(buf, target));

	sprintf(buf, ""%u "", flags);
",1,unused,115,unused,"
	sprintf(buf, ""%u "", hash);
	RETERR(str_totext(buf, target));

	sprintf(buf, ""%u "", flags);
",unused,bind-9.11.0-lib2Fdns2Frdata2Fgeneric2Fnsec3param_51.c
"
	sprintf(buf, ""%u "", flags);
	RETERR(str_totext(buf, target));

	sprintf(buf, ""%u "", iterations);
",1,unused,118,unused,"
	sprintf(buf, ""%u "", flags);
	RETERR(str_totext(buf, target));

	sprintf(buf, ""%u "", iterations);
",unused,bind-9.11.0-lib2Fdns2Frdata2Fgeneric2Fnsec3param_51.c
"						RETERR(dns_rdatatype_totext(t,
								      target));
					} else {
						char buf[sizeof(""65535"")];
						sprintf(buf, ""%u"", t);
",1,unused,112,unused,"						RETERR(dns_rdatatype_totext(t,
								      target));
					} else {
						char buf[sizeof(""65535"")];
						sprintf(buf, ""%u"", t);
",unused,bind-9.11.0-lib2Fdns2Frdata2Fgeneric2Fnxt_30.c
"		option = uint16_fromregion(&r);
		isc_region_consume(&r, 2);
		length = uint16_fromregion(&r);
		isc_region_consume(&r, 2);
		sprintf(buf, ""%u %u"", option, length);
",1,unused,59,unused,"		option = uint16_fromregion(&r);
		isc_region_consume(&r, 2);
		length = uint16_fromregion(&r);
		isc_region_consume(&r, 2);
		sprintf(buf, ""%u %u"", option, length);
",unused,bind-9.11.0-lib2Fdns2Frdata2Fgeneric2Fopt_41.c
"	 */
	if (dns_rdatatype_isknown(covered) && covered != 0) {
		RETERR(dns_rdatatype_totext(covered, target));
	} else {
		sprintf(buf, ""TYPE%u"", covered);
",1,unused,173,unused,"	 */
	if (dns_rdatatype_isknown(covered) && covered != 0) {
		RETERR(dns_rdatatype_totext(covered, target));
	} else {
		sprintf(buf, ""TYPE%u"", covered);
",unused,bind-9.11.0-lib2Fdns2Frdata2Fgeneric2Frrsig_46.c
"
	/*
	 * Algorithm.
	 */
	sprintf(buf, ""%u"", sr.base[0]);
",1,unused,181,unused,"
	/*
	 * Algorithm.
	 */
	sprintf(buf, ""%u"", sr.base[0]);
",unused,bind-9.11.0-lib2Fdns2Frdata2Fgeneric2Frrsig_46.c
"
	/*
	 * Labels.
	 */
	sprintf(buf, ""%u"", sr.base[0]);
",1,unused,189,unused,"
	/*
	 * Labels.
	 */
	sprintf(buf, ""%u"", sr.base[0]);
",unused,bind-9.11.0-lib2Fdns2Frdata2Fgeneric2Frrsig_46.c
"	 * Ttl.
	 */
	ttl = uint32_fromregion(&sr);
	isc_region_consume(&sr, 4);
	sprintf(buf, ""%lu"", ttl);
",1,unused,199,unused,"	 * Ttl.
	 */
	ttl = uint32_fromregion(&sr);
	isc_region_consume(&sr, 4);
	sprintf(buf, ""%lu"", ttl);
",unused,bind-9.11.0-lib2Fdns2Frdata2Fgeneric2Frrsig_46.c
"	 * Footprint.
	 */
	foot = uint16_fromregion(&sr);
	isc_region_consume(&sr, 2);
	sprintf(buf, ""%lu"", foot);
",1,unused,227,unused,"	 * Footprint.
	 */
	foot = uint16_fromregion(&sr);
	isc_region_consume(&sr, 2);
	sprintf(buf, ""%lu"", foot);
",unused,bind-9.11.0-lib2Fdns2Frdata2Fgeneric2Frrsig_46.c
"	 */
	if (dns_rdatatype_isknown(covered) && covered != 0) {
		RETERR(dns_rdatatype_totext(covered, target));
	} else {
		sprintf(buf, ""%u"", covered);
",1,unused,149,unused,"	 */
	if (dns_rdatatype_isknown(covered) && covered != 0) {
		RETERR(dns_rdatatype_totext(covered, target));
	} else {
		sprintf(buf, ""%u"", covered);
",unused,bind-9.11.0-lib2Fdns2Frdata2Fgeneric2Fsig_24.c
"
	/*
	 * Algorithm.
	 */
	sprintf(buf, ""%u"", sr.base[0]);
",1,unused,157,unused,"
	/*
	 * Algorithm.
	 */
	sprintf(buf, ""%u"", sr.base[0]);
",unused,bind-9.11.0-lib2Fdns2Frdata2Fgeneric2Fsig_24.c
"
	/*
	 * Labels.
	 */
	sprintf(buf, ""%u"", sr.base[0]);
",1,unused,165,unused,"
	/*
	 * Labels.
	 */
	sprintf(buf, ""%u"", sr.base[0]);
",unused,bind-9.11.0-lib2Fdns2Frdata2Fgeneric2Fsig_24.c
"	 * Ttl.
	 */
	ttl = uint32_fromregion(&sr);
	isc_region_consume(&sr, 4);
	sprintf(buf, ""%lu"", ttl);
",1,unused,175,unused,"	 * Ttl.
	 */
	ttl = uint32_fromregion(&sr);
	isc_region_consume(&sr, 4);
	sprintf(buf, ""%lu"", ttl);
",unused,bind-9.11.0-lib2Fdns2Frdata2Fgeneric2Fsig_24.c
"	 * Footprint.
	 */
	foot = uint16_fromregion(&sr);
	isc_region_consume(&sr, 2);
	sprintf(buf, ""%lu"", foot);
",1,unused,203,unused,"	 * Footprint.
	 */
	foot = uint16_fromregion(&sr);
	isc_region_consume(&sr, 2);
	sprintf(buf, ""%lu"", foot);
",unused,bind-9.11.0-lib2Fdns2Frdata2Fgeneric2Fsig_24.c
"	coding = uint8_fromregion(&sr);
	isc_region_consume(&sr, 1);
	subcoding = uint8_fromregion(&sr);
	isc_region_consume(&sr, 1);
	sprintf(buf, ""%u %u %u"", meaning, coding, subcoding);
",1,unused,70,unused,"	coding = uint8_fromregion(&sr);
	isc_region_consume(&sr, 1);
	subcoding = uint8_fromregion(&sr);
	isc_region_consume(&sr, 1);
	sprintf(buf, ""%u %u %u"", meaning, coding, subcoding);
",unused,bind-9.11.0-lib2Fdns2Frdata2Fgeneric2Fsink_40.c
"		char buf[sizeof(""0123456789 ; "")];
		unsigned long num;
		num = uint32_fromregion(&dregion);
		isc_region_consume(&dregion, 4);
		sprintf(buf, comm ? ""%-10lu ; "" : ""%lu"", num);
",1,unused,131,unused,"		char buf[sizeof(""0123456789 ; "")];
		unsigned long num;
		num = uint32_fromregion(&dregion);
		isc_region_consume(&dregion, 4);
		sprintf(buf, comm ? ""%-10lu ; "" : ""%lu"", num);
",unused,bind-9.11.0-lib2Fdns2Frdata2Fgeneric2Fsoa_6.c
"	 * Algorithm.
	 */
	n = uint8_fromregion(&sr);
	isc_region_consume(&sr, 1);
	sprintf(buf, ""%u "", n);
",1,unused,72,unused,"	 * Algorithm.
	 */
	n = uint8_fromregion(&sr);
	isc_region_consume(&sr, 1);
	sprintf(buf, ""%u "", n);
",unused,bind-9.11.0-lib2Fdns2Frdata2Fgeneric2Fsshfp_44.c
"	 * Digest type.
	 */
	n = uint8_fromregion(&sr);
	isc_region_consume(&sr, 1);
	sprintf(buf, ""%u"", n);
",1,unused,80,unused,"	 * Digest type.
	 */
	n = uint8_fromregion(&sr);
	isc_region_consume(&sr, 1);
	sprintf(buf, ""%u"", n);
",unused,bind-9.11.0-lib2Fdns2Frdata2Fgeneric2Fsshfp_44.c
"	 * Inception.
	 */
	n = uint32_fromregion(&sr);
	isc_region_consume(&sr, 4);
	sprintf(buf, ""%lu "", n);
",1,unused,148,unused,"	 * Inception.
	 */
	n = uint32_fromregion(&sr);
	isc_region_consume(&sr, 4);
	sprintf(buf, ""%lu "", n);
",unused,bind-9.11.0-lib2Fdns2Frdata2Fgeneric2Ftkey_249.c
"	 * Expiration.
	 */
	n = uint32_fromregion(&sr);
	isc_region_consume(&sr, 4);
	sprintf(buf, ""%lu "", n);
",1,unused,156,unused,"	 * Expiration.
	 */
	n = uint32_fromregion(&sr);
	isc_region_consume(&sr, 4);
	sprintf(buf, ""%lu "", n);
",unused,bind-9.11.0-lib2Fdns2Frdata2Fgeneric2Ftkey_249.c
"	 * Mode.
	 */
	n = uint16_fromregion(&sr);
	isc_region_consume(&sr, 2);
	sprintf(buf, ""%lu "", n);
",1,unused,164,unused,"	 * Mode.
	 */
	n = uint16_fromregion(&sr);
	isc_region_consume(&sr, 2);
	sprintf(buf, ""%lu "", n);
",unused,bind-9.11.0-lib2Fdns2Frdata2Fgeneric2Ftkey_249.c
"	isc_region_consume(&sr, 2);
	if (dns_tsigrcode_totext((dns_rcode_t)n, target) == ISC_R_SUCCESS)
		RETERR(str_totext("" "", target));
	else {
		sprintf(buf, ""%lu "", n);
",1,unused,175,unused,"	isc_region_consume(&sr, 2);
	if (dns_tsigrcode_totext((dns_rcode_t)n, target) == ISC_R_SUCCESS)
		RETERR(str_totext("" "", target));
	else {
		sprintf(buf, ""%lu "", n);
",unused,bind-9.11.0-lib2Fdns2Frdata2Fgeneric2Ftkey_249.c
"	 * Key Size.
	 */
	n = uint16_fromregion(&sr);
	isc_region_consume(&sr, 2);
	sprintf(buf, ""%lu"", n);
",1,unused,184,unused,"	 * Key Size.
	 */
	n = uint16_fromregion(&sr);
	isc_region_consume(&sr, 2);
	sprintf(buf, ""%lu"", n);
",unused,bind-9.11.0-lib2Fdns2Frdata2Fgeneric2Ftkey_249.c
"	 * Other Size.
	 */
	n = uint16_fromregion(&sr);
	isc_region_consume(&sr, 2);
	sprintf(buf, ""%lu"", n);
",1,unused,212,unused,"	 * Other Size.
	 */
	n = uint16_fromregion(&sr);
	isc_region_consume(&sr, 2);
	sprintf(buf, ""%lu"", n);
",unused,bind-9.11.0-lib2Fdns2Frdata2Fgeneric2Ftkey_249.c
"	 * Certificate Usage.
	 */
	n = uint8_fromregion(&sr);
	isc_region_consume(&sr, 1);
	sprintf(buf, ""%u "", n);
",1,unused,76,unused,"	 * Certificate Usage.
	 */
	n = uint8_fromregion(&sr);
	isc_region_consume(&sr, 1);
	sprintf(buf, ""%u "", n);
",unused,bind-9.11.0-lib2Fdns2Frdata2Fgeneric2Ftlsa_52.c
"	 * Selector.
	 */
	n = uint8_fromregion(&sr);
	isc_region_consume(&sr, 1);
	sprintf(buf, ""%u "", n);
",1,unused,84,unused,"	 * Selector.
	 */
	n = uint8_fromregion(&sr);
	isc_region_consume(&sr, 1);
	sprintf(buf, ""%u "", n);
",unused,bind-9.11.0-lib2Fdns2Frdata2Fgeneric2Ftlsa_52.c
"	 * Matching type.
	 */
	n = uint8_fromregion(&sr);
	isc_region_consume(&sr, 1);
	sprintf(buf, ""%u"", n);
",1,unused,92,unused,"	 * Matching type.
	 */
	n = uint8_fromregion(&sr);
	isc_region_consume(&sr, 1);
	sprintf(buf, ""%u"", n);
",unused,bind-9.11.0-lib2Fdns2Frdata2Fgeneric2Ftlsa_52.c
"	 * Priority
	 */
	priority = uint16_fromregion(&region);
	isc_region_consume(&region, 2);
	sprintf(buf, ""%u "", priority);
",1,unused,75,unused,"	 * Priority
	 */
	priority = uint16_fromregion(&region);
	isc_region_consume(&region, 2);
	sprintf(buf, ""%u "", priority);
",unused,bind-9.11.0-lib2Fdns2Frdata2Fgeneric2Furi_256.c
"	 * Weight
	 */
	weight = uint16_fromregion(&region);
	isc_region_consume(&region, 2);
	sprintf(buf, ""%u "", weight);
",1,unused,83,unused,"	 * Weight
	 */
	weight = uint16_fromregion(&region);
	isc_region_consume(&region, 2);
	sprintf(buf, ""%u "", weight);
",unused,bind-9.11.0-lib2Fdns2Frdata2Fgeneric2Furi_256.c
"	dns_rdata_toregion(rdata, &sr);
	prefixlen = sr.base[0];
	INSIST(prefixlen <= 128);
	isc_region_consume(&sr, 1);
	sprintf(buf, ""%u"", prefixlen);
",1,unused,110,unused,"	dns_rdata_toregion(rdata, &sr);
	prefixlen = sr.base[0];
	INSIST(prefixlen <= 128);
	isc_region_consume(&sr, 1);
	sprintf(buf, ""%u"", prefixlen);
",unused,bind-9.11.0-lib2Fdns2Frdata2Fin_12Fa6_38.c
"
	dns_rdata_toregion(rdata, &region);
	num = uint16_fromregion(&region);
	isc_region_consume(&region, 2);
	sprintf(buf, ""%u"", num);
",1,unused,68,unused,"
	dns_rdata_toregion(rdata, &region);
	num = uint16_fromregion(&region);
	isc_region_consume(&region, 2);
	sprintf(buf, ""%u"", num);
",unused,bind-9.11.0-lib2Fdns2Frdata2Fin_12Fkx_36.c
"
	dns_rdata_toregion(rdata, &region);
	RETERR(str_totext(""0x"", target));
	while (region.length != 0) {
		sprintf(buf, ""%02x"", region.base[0]);
",1,unused,83,unused,"
	dns_rdata_toregion(rdata, &region);
	RETERR(str_totext(""0x"", target));
	while (region.length != 0) {
		sprintf(buf, ""%02x"", region.base[0]);
",unused,bind-9.11.0-lib2Fdns2Frdata2Fin_12Fnsap_22.c
"	 */
	dns_rdata_toregion(rdata, &region);
	num = uint16_fromregion(&region);
	isc_region_consume(&region, 2);
	sprintf(buf, ""%u"", num);
",1,unused,87,unused,"	 */
	dns_rdata_toregion(rdata, &region);
	num = uint16_fromregion(&region);
	isc_region_consume(&region, 2);
	sprintf(buf, ""%u"", num);
",unused,bind-9.11.0-lib2Fdns2Frdata2Fin_12Fpx_26.c
"	RETERR(inet_totext(AF_INET, &sr, target));
	isc_region_consume(&sr, 4);

	proto = uint8_fromregion(&sr);
	sprintf(buf, ""%u"", proto);
",1,unused,174,unused,"	RETERR(inet_totext(AF_INET, &sr, target));
	isc_region_consume(&sr, 4);

	proto = uint8_fromregion(&sr);
	sprintf(buf, ""%u"", proto);
",unused,bind-9.11.0-lib2Fdns2Frdata2Fin_12Fwks_11.c
"	for (i = 0; i < sr.length; i++) {
		if (sr.base[i] != 0)
			for (j = 0; j < 8; j++)
				if ((sr.base[i] & (0x80 >> j)) != 0) {
					sprintf(buf, ""%u"", i * 8 + j);
",1,unused,184,unused,"	for (i = 0; i < sr.length; i++) {
		if (sr.base[i] != 0)
			for (j = 0; j < 8; j++)
				if ((sr.base[i] & (0x80 >> j)) != 0) {
					sprintf(buf, ""%u"", i * 8 + j);
",unused,bind-9.11.0-lib2Fdns2Frdata2Fin_12Fwks_11.c
"		return;
	if (key != NULL)
		dns_name_format(&key->name, namestr, sizeof(namestr));
	else
		strcpy(namestr, ""<null>"");
",1,unused,210,unused,"		return;
	if (key != NULL)
		dns_name_format(&key->name, namestr, sizeof(namestr));
	else
		strcpy(namestr, ""<null>"");
",unused,bind-9.11.0-lib2Fdns2Ftsig.c
"
	if (key != NULL && key->generated && key->creator)
		dns_name_format(key->creator, creatorstr, sizeof(creatorstr));
	else
		strcpy(creatorstr, ""<null>"");
",1,unused,215,unused,"
	if (key != NULL && key->generated && key->creator)
		dns_name_format(key->creator, creatorstr, sizeof(creatorstr));
	else
		strcpy(creatorstr, ""<null>"");
",unused,bind-9.11.0-lib2Fdns2Ftsig.c
"		   (sp = getservbyport(port, proto)) == NULL) {
		snprintf(numserv, sizeof(numserv), ""%d"", ntohs(port));
		if ((strlen(numserv) + 1) > servlen)
			ERR(EAI_OVERFLOW);
		strcpy(serv, numserv);
",1,unused,208,unused,"		   (sp = getservbyport(port, proto)) == NULL) {
		snprintf(numserv, sizeof(numserv), ""%d"", ntohs(port));
		if ((strlen(numserv) + 1) > servlen)
			ERR(EAI_OVERFLOW);
		strcpy(serv, numserv);
",unused,bind-9.11.0-lib2Firs2Fgetnameinfo.c
"		strcpy(serv, numserv);
	} else {
		if ((strlen(sp->s_name) + 1) > servlen)
			ERR(EAI_OVERFLOW);
		strcpy(serv, sp->s_name);
",1,unused,212,unused,"		strcpy(serv, numserv);
	} else {
		if ((strlen(sp->s_name) + 1) > servlen)
			ERR(EAI_OVERFLOW);
		strcpy(serv, sp->s_name);
",unused,bind-9.11.0-lib2Firs2Fgetnameinfo.c
"		}
#endif
		if (strlen(numaddr) + 1 > hostlen)
			ERR(EAI_OVERFLOW);
		strcpy(host, numaddr);
",1,unused,269,unused,"		}
#endif
		if (strlen(numaddr) + 1 > hostlen)
			ERR(EAI_OVERFLOW);
		strcpy(host, numaddr);
",unused,bind-9.11.0-lib2Firs2Fgetnameinfo.c
"				      sizeof(numaddr)) == NULL)
				ERR(EAI_SYSTEM);
			if ((strlen(numaddr) + 1) > hostlen)
				ERR(EAI_OVERFLOW);
			strcpy(host, numaddr);
",1,unused,395,unused,"				      sizeof(numaddr)) == NULL)
				ERR(EAI_SYSTEM);
			if ((strlen(numaddr) + 1) > hostlen)
				ERR(EAI_OVERFLOW);
			strcpy(host, numaddr);
",unused,bind-9.11.0-lib2Firs2Fgetnameinfo.c
"		if (result != ISC_R_SUCCESS)
			return (result);
	}

	sprintf(isc_buffer_used(&httpd->headerbuffer), ""%s %03u %s\r\n"",
",1,unused,1049,unused,"		if (result != ISC_R_SUCCESS)
			return (result);
	}

	sprintf(isc_buffer_used(&httpd->headerbuffer), ""%s %03u %s\r\n"",
",unused,bind-9.11.0-lib2Fisc2Fhttpd.c
"			return (result);
	}

	if (val != NULL)
		sprintf(isc_buffer_used(&httpd->headerbuffer),
",1,unused,1075,unused,"			return (result);
	}

	if (val != NULL)
		sprintf(isc_buffer_used(&httpd->headerbuffer),
",unused,bind-9.11.0-lib2Fisc2Fhttpd.c
"	if (val != NULL)
		sprintf(isc_buffer_used(&httpd->headerbuffer),
			""%s: %s\r\n"", name, val);
	else
		sprintf(isc_buffer_used(&httpd->headerbuffer),
",1,unused,1078,unused,"	if (val != NULL)
		sprintf(isc_buffer_used(&httpd->headerbuffer),
			""%s: %s\r\n"", name, val);
	else
		sprintf(isc_buffer_used(&httpd->headerbuffer),
",unused,bind-9.11.0-lib2Fisc2Fhttpd.c
"		if (result != ISC_R_SUCCESS)
			return (result);
	}

	sprintf(isc_buffer_used(&httpd->headerbuffer), ""\r\n"");
",1,unused,1096,unused,"		if (result != ISC_R_SUCCESS)
			return (result);
	}

	sprintf(isc_buffer_used(&httpd->headerbuffer), ""\r\n"");
",unused,bind-9.11.0-lib2Fisc2Fhttpd.c
"	isc_result_t result;
	unsigned int needlen;
	char buf[sizeof ""18446744073709551616""];

	sprintf(buf, ""%d"", val);
",1,unused,1108,unused,"	isc_result_t result;
	unsigned int needlen;
	char buf[sizeof ""18446744073709551616""];

	sprintf(buf, ""%d"", val);
",unused,bind-9.11.0-lib2Fisc2Fhttpd.c
"		if (result != ISC_R_SUCCESS)
			return (result);
	}

	sprintf(isc_buffer_used(&httpd->headerbuffer),
",1,unused,1120,unused,"		if (result != ISC_R_SUCCESS)
			return (result);
	}

	sprintf(isc_buffer_used(&httpd->headerbuffer),
",unused,bind-9.11.0-lib2Fisc2Fhttpd.c
"		return (ISC_R_NOSPACE);

	memset(netaddr, 0, sizeof(*netaddr));
	netaddr->family = AF_UNIX;
	strcpy(netaddr->type.un, path);
",1,unused,301,unused,"		return (ISC_R_NOSPACE);

	memset(netaddr, 0, sizeof(*netaddr));
	netaddr->family = AF_UNIX;
	strcpy(netaddr->type.un, path);
",unused,bind-9.11.0-lib2Fisc2Fnetaddr.c
"#ifdef ISC_PLATFORM_HAVESALEN
	sockaddr->type.sunix.sun_len =
			(unsigned char)sizeof(sockaddr->type.sunix);
#endif
	strcpy(sockaddr->type.sunix.sun_path, path);
",1,unused,496,unused,"#ifdef ISC_PLATFORM_HAVESALEN
	sockaddr->type.sunix.sun_len =
			(unsigned char)sizeof(sockaddr->type.sunix);
#endif
	strcpy(sockaddr->type.sunix.sun_path, path);
",unused,bind-9.11.0-lib2Fisc2Fsockaddr.c
"	 */
	if (strlen(dirname) + 3 > sizeof(dir->dirname))
		/* XXXDCL ? */
		return (ISC_R_NOSPACE);
	strcpy(dir->dirname, dirname);
",1,unused,64,unused,"	 */
	if (strlen(dirname) + 3 > sizeof(dir->dirname))
		/* XXXDCL ? */
		return (ISC_R_NOSPACE);
	strcpy(dir->dirname, dirname);
",unused,bind-9.11.0-lib2Fisc2Funix2Fdir.c
"	 */
	if (sizeof(dir->entry.name) <= strlen(entry->d_name))
	    return (ISC_R_UNEXPECTED);

	strcpy(dir->entry.name, entry->d_name);
",1,unused,113,unused,"	 */
	if (sizeof(dir->entry.name) <= strlen(entry->d_name))
	    return (ISC_R_UNEXPECTED);

	strcpy(dir->entry.name, entry->d_name);
",unused,bind-9.11.0-lib2Fisc2Funix2Fdir.c
"#endif

	REQUIRE(sockaddr->type.sa.sa_family == AF_UNIX);
	INSIST(strlen(sockaddr->type.sunix.sun_path) < sizeof(path));
	strcpy(path, sockaddr->type.sunix.sun_path);
",1,unused,5487,unused,"#endif

	REQUIRE(sockaddr->type.sa.sa_family == AF_UNIX);
	INSIST(strlen(sockaddr->type.sunix.sun_path) < sizeof(path));
	strcpy(path, sockaddr->type.sunix.sun_path);
",unused,bind-9.11.0-lib2Fisc2Funix2Fsocket.c
"		    strlen(s) <= 15U) {
			char buf[64];
			int i;

			strcpy(buf, s);
",1,unused,2041,unused,"		    strlen(s) <= 15U) {
			char buf[64];
			int i;

			strcpy(buf, s);
",unused,bind-9.11.0-lib2Fisccfg2Fparser.c
"			int i;

			strcpy(buf, s);
			for (i = 0; i < 3; i++) {
				strcat(buf, "".0"");
",1,unused,2043,unused,"			int i;

			strcpy(buf, s);
			for (i = 0; i < 3; i++) {
				strcat(buf, "".0"");
",unused,bind-9.11.0-lib2Fisccfg2Fparser.c
"			char buf[128]; /* see lib/bind9/getaddresses.c */
			char *d; /* zone delimiter */
			isc_uint32_t zone = 0; /* scope zone ID */

			strcpy(buf, s);
",1,unused,2056,unused,"			char buf[128]; /* see lib/bind9/getaddresses.c */
			char *d; /* zone delimiter */
			isc_uint32_t zone = 0; /* scope zone ID */

			strcpy(buf, s);
",unused,bind-9.11.0-lib2Fisccfg2Fparser.c
"
	len = vsnprintf(message, sizeof(message), format, args);
#define ELIPSIS "" ... ""
	if (len >= sizeof(message))
		strcpy(message + sizeof(message) - sizeof(ELIPSIS) - 1,
",1,unused,2663,unused,"
	len = vsnprintf(message, sizeof(message), format, args);
#define ELIPSIS "" ... ""
	if (len >= sizeof(message))
		strcpy(message + sizeof(message) - sizeof(ELIPSIS) - 1,
",unused,bind-9.11.0-lib2Fisccfg2Fparser.c
"	/*
	 * Copy official name.
	 */
	n = strlen(src->h_name) + 1;
	strcpy(cp, src->h_name);
",1,unused,339,unused,"	/*
	 * Copy official name.
	 */
	n = strlen(src->h_name) + 1;
	strcpy(cp, src->h_name);
",unused,bind-9.11.0-lib2Flwres2Fgethost.c
"	 */
	hptr->h_aliases = ptr;
	for (i = 0; src->h_aliases[i]; i++) {
		n = strlen(src->h_aliases[i]) + 1;
		strcpy(cp, src->h_aliases[i]);
",1,unused,349,unused,"	 */
	hptr->h_aliases = ptr;
	for (i = 0; src->h_aliases[i]; i++) {
		n = strlen(src->h_aliases[i]) + 1;
		strcpy(cp, src->h_aliases[i]);
",unused,bind-9.11.0-lib2Flwres2Fgethost.c
"		} u;

		u.const_name = name;
		if (v4 == 1 && af == AF_INET6) {
			strcpy(mappedname, ""::ffff:"");
",1,unused,243,unused,"		} u;

		u.const_name = name;
		if (v4 == 1 && af == AF_INET6) {
			strcpy(mappedname, ""::ffff:"");
",unused,bind-9.11.0-lib2Flwres2Fgetipnode.c
"		len = strlen (*cpp) + 1;
		*npp = malloc(len);
		if (*npp == NULL)
			goto cleanup2;
		strcpy(*npp, *cpp);
",1,unused,954,unused,"		len = strlen (*cpp) + 1;
		*npp = malloc(len);
		if (*npp == NULL)
			goto cleanup2;
		strcpy(*npp, *cpp);
",unused,bind-9.11.0-lib2Flwres2Fgetipnode.c
"	he->h_name = malloc(strlen((he1 != NULL) ?
			    he1->h_name : he2->h_name) + 1);
	if (he->h_name == NULL)
		goto cleanup2;
	strcpy(he->h_name, (he1 != NULL) ? he1->h_name : he2->h_name);
",1,unused,966,unused,"	he->h_name = malloc(strlen((he1 != NULL) ?
			    he1->h_name : he2->h_name) + 1);
	if (he->h_name == NULL)
		goto cleanup2;
	strcpy(he->h_name, (he1 != NULL) ? he1->h_name : he2->h_name);
",unused,bind-9.11.0-lib2Flwres2Fgetipnode.c
"		   (sp = getservbyport(port, proto)) == NULL) {
		snprintf(numserv, sizeof(numserv), ""%d"", ntohs(port));
		if ((strlen(numserv) + 1) > servlen)
			ERR(ENI_MEMORY);
		strcpy(serv, numserv);
",1,unused,227,unused,"		   (sp = getservbyport(port, proto)) == NULL) {
		snprintf(numserv, sizeof(numserv), ""%d"", ntohs(port));
		if ((strlen(numserv) + 1) > servlen)
			ERR(ENI_MEMORY);
		strcpy(serv, numserv);
",unused,bind-9.11.0-lib2Flwres2Fgetnameinfo.c
"		strcpy(serv, numserv);
	} else {
		if ((strlen(sp->s_name) + 1) > servlen)
			ERR(ENI_MEMORY);
		strcpy(serv, sp->s_name);
",1,unused,231,unused,"		strcpy(serv, numserv);
	} else {
		if ((strlen(sp->s_name) + 1) > servlen)
			ERR(ENI_MEMORY);
		strcpy(serv, sp->s_name);
",unused,bind-9.11.0-lib2Flwres2Fgetnameinfo.c
"		}
#endif
		if (strlen(numaddr) + 1 > hostlen)
			ERR(ENI_MEMORY);
		strcpy(host, numaddr);
",1,unused,287,unused,"		}
#endif
		if (strlen(numaddr) + 1 > hostlen)
			ERR(ENI_MEMORY);
		strcpy(host, numaddr);
",unused,bind-9.11.0-lib2Flwres2Fgetnameinfo.c
"					*p = '\0';
			}
			if ((strlen(by->realname) + 1) > hostlen)
				ERR(ENI_MEMORY);
			strcpy(host, by->realname);
",1,unused,316,unused,"					*p = '\0';
			}
			if ((strlen(by->realname) + 1) > hostlen)
				ERR(ENI_MEMORY);
			strcpy(host, by->realname);
",unused,bind-9.11.0-lib2Flwres2Fgetnameinfo.c
"			    == NULL)
				ERR(ENI_NOHOSTNAME);
			if ((strlen(numaddr) + 1) > hostlen)
				ERR(ENI_MEMORY);
			strcpy(host, numaddr);
",1,unused,326,unused,"			    == NULL)
				ERR(ENI_NOHOSTNAME);
			if ((strlen(numaddr) + 1) > hostlen)
				ERR(ENI_MEMORY);
			strcpy(host, numaddr);
",unused,bind-9.11.0-lib2Flwres2Fgetnameinfo.c
"	REQUIRE(strlen(str) > 0U);

	p = CTXMALLOC(strlen(str) + 1);
	if (p != NULL)
		strcpy(p, str);
",1,unused,211,unused,"	REQUIRE(strlen(str) > 0U);

	p = CTXMALLOC(strlen(str) + 1);
	if (p != NULL)
		strcpy(p, str);
",unused,bind-9.11.0-lib2Flwres2Flwconfig.c
"	if (len >= size) {
		errno = ENOSPC;
		return (NULL);
	}
	strcpy(dst, tmp);
",1,unused,87,unused,"	if (len >= size) {
		errno = ENOSPC;
		return (NULL);
	}
	strcpy(dst, tmp);
",unused,bind-9.11.0-lib2Flwres2Flwinetntop.c
"				return (NULL);
			tp += strlen(tp);
			break;
		}
		tp += sprintf(tp, ""%x"", words[i]); /* XXX */
",1,unused,170,unused,"				return (NULL);
			tp += strlen(tp);
			break;
		}
		tp += sprintf(tp, ""%x"", words[i]); /* XXX */
",unused,bind-9.11.0-lib2Flwres2Flwinetntop.c
"	if ((size_t)(tp - tmp) > size) {
		errno = ENOSPC;
		return (NULL);
	}
	strcpy(dst, tmp);
",1,unused,185,unused,"	if ((size_t)(tp - tmp) > size) {
		errno = ENOSPC;
		return (NULL);
	}
	strcpy(dst, tmp);
",unused,bind-9.11.0-lib2Flwres2Flwinetntop.c
"
	target_length = strlen(name);
	if (target_length >= sizeof(target_name))
		return (LWRES_R_FAILURE);
	strcpy(target_name, name); /* strcpy is safe */
",1,unused,266,unused,"
	target_length = strlen(name);
	if (target_length >= sizeof(target_name))
		return (LWRES_R_FAILURE);
	strcpy(target_name, name); /* strcpy is safe */
",unused,bind-9.11.0-lib2Flwres2Flwresutil.c
"
	target_length = strlen(name);
	if (target_length >= sizeof(target_name))
		return (LWRES_R_FAILURE);
	strcpy(target_name, name); /* strcpy is safe */
",1,unused,490,unused,"
	target_length = strlen(name);
	if (target_length >= sizeof(target_name))
		return (LWRES_R_FAILURE);
	strcpy(target_name, name); /* strcpy is safe */
",unused,bind-9.11.0-lib2Flwres2Flwresutil.c
"					else
						head = """";
					tmpui = tmpi;
				}
				sprintf(buf, ""%"" LWRES_PRINT_QUADFORMAT ""u"",
",1,unused,249,unused,"					else
						head = """";
					tmpui = tmpi;
				}
				sprintf(buf, ""%"" LWRES_PRINT_QUADFORMAT ""u"",
",unused,bind-9.11.0-lib2Flwres2Fprint.c
"				else if (z)
					tmpui = va_arg(ap, size_t);
				else
					tmpui = va_arg(ap, int);
				sprintf(buf,
",1,unused,262,unused,"				else if (z)
					tmpui = va_arg(ap, size_t);
				else
					tmpui = va_arg(ap, int);
				sprintf(buf,
",unused,bind-9.11.0-lib2Flwres2Fprint.c
"				else if (z)
					tmpui = va_arg(ap, size_t);
				else
					tmpui = va_arg(ap, unsigned int);
				sprintf(buf, ""%"" LWRES_PRINT_QUADFORMAT ""u"",
",1,unused,277,unused,"				else if (z)
					tmpui = va_arg(ap, size_t);
				else
					tmpui = va_arg(ap, unsigned int);
				sprintf(buf, ""%"" LWRES_PRINT_QUADFORMAT ""u"",
",unused,bind-9.11.0-lib2Flwres2Fprint.c
"					head = ""0x"";
					if (precision > 2U)
						precision -= 2;
				}
				sprintf(buf, ""%"" LWRES_PRINT_QUADFORMAT ""x"",
",1,unused,295,unused,"					head = ""0x"";
					if (precision > 2U)
						precision -= 2;
				}
				sprintf(buf, ""%"" LWRES_PRINT_QUADFORMAT ""x"",
",unused,bind-9.11.0-lib2Flwres2Fprint.c
"					head = ""0X"";
					if (precision > 2U)
						precision -= 2;
				}
				sprintf(buf, ""%"" LWRES_PRINT_QUADFORMAT ""X"",
",1,unused,313,unused,"					head = ""0X"";
					if (precision > 2U)
						precision -= 2;
				}
				sprintf(buf, ""%"" LWRES_PRINT_QUADFORMAT ""X"",
",unused,bind-9.11.0-lib2Flwres2Fprint.c
"			}
			break;
		case 'p':
			v = va_arg(ap, void *);
			sprintf(buf, ""%p"", v);
",1,unused,440,unused,"			}
			break;
		case 'p':
			v = va_arg(ap, void *);
			sprintf(buf, ""%p"", v);
",unused,bind-9.11.0-lib2Flwres2Fprint.c
"			 * overflow buf.
			 */
			if (precision > 512U)
				precision = 512;
			sprintf(fmt, ""%%%s%s.%lu%s%c"", alt ? ""#"" : """",
",1,unused,520,unused,"			 * overflow buf.
			 */
			if (precision > 512U)
				precision = 512;
			sprintf(fmt, ""%%%s%s.%lu%s%c"", alt ? ""#"" : """",
",unused,bind-9.11.0-lib2Flwres2Fprint.c
"				} else
#endif
				{
					dbl = va_arg(ap, double);
					sprintf(buf, fmt, dbl);
",1,unused,537,unused,"				} else
#endif
				{
					dbl = va_arg(ap, double);
					sprintf(buf, fmt, dbl);
",unused,bind-9.11.0-lib2Flwres2Fprint.c
"  if (filename == NULL)
    return NULL;

  strncpy (filename, arch_name, prefix_len);
  strcpy (filename + prefix_len, elt_name);
",1,unused,636,unused,"  if (filename == NULL)
    return NULL;

  strncpy (filename, arch_name, prefix_len);
  strcpy (filename + prefix_len, elt_name);
",unused,binutils-bfd2Farchive.c
"  newp = pathbuf;
  while (dir_up-- > 0)
    {
      /* FIXME: Support Windows style path separators as well.  */
      strcpy (newp, ""../"");
",1,unused,1439,unused,"  newp = pathbuf;
  while (dir_up-- > 0)
    {
      /* FIXME: Support Windows style path separators as well.  */
      strcpy (newp, ""../"");
",unused,binutils-bfd2Farchive.c
"      newp += 3;
    }

  if (down)
    sprintf (newp, ""%s/%s"", down, pathp);
",1,unused,1444,unused,"      newp += 3;
    }

  if (down)
    sprintf (newp, ""%s/%s"", down, pathp);
",unused,binutils-bfd2Farchive.c
"
  if (down)
    sprintf (newp, ""%s/%s"", down, pathp);
  else
    strcpy (newp, pathp);
",1,unused,1446,unused,"
  if (down)
    sprintf (newp, ""%s/%s"", down, pathp);
  else
    strcpy (newp, pathp);
",unused,binutils-bfd2Farchive.c
"	  if (normal == last_filename)
	    stroff = last_stroff;
	  else
	    {
	      strcpy (strptr, normal);
",1,unused,1652,unused,"	  if (normal == last_filename)
	    stroff = last_stroff;
	  else
	    {
	      strcpy (strptr, normal);
",unused,binutils-bfd2Farchive.c
"		      *(map[orl_count].name) = (char *) bfd_alloc (arch,
								   namelen + 1);
		      if (*(map[orl_count].name) == NULL)
			goto error_return;
		      strcpy (*(map[orl_count].name), syms[src_count]->name);
",1,unused,2343,unused,"		      *(map[orl_count].name) = (char *) bfd_alloc (arch,
								   namelen + 1);
		      if (*(map[orl_count].name) == NULL)
			goto error_return;
		      strcpy (*(map[orl_count].name), syms[src_count]->name);
",unused,binutils-bfd2Farchive.c
"		  ptr += 2;
		}
	      value = abs (args[arg_index].i);
	      arg_count++;
	      sptr += sprintf (sptr, ""%d"", value);
",1,unused,720,unused,"		  ptr += 2;
		}
	      value = abs (args[arg_index].i);
	      arg_count++;
	      sptr += sprintf (sptr, ""%d"", value);
",unused,binutils-bfd2Fbfd.c
"		      ptr += 2;
		    }
		  value = abs (args[arg_index].i);
		  arg_count++;
		  sptr += sprintf (sptr, ""%d"", value);
",1,unused,746,unused,"		      ptr += 2;
		    }
		  value = abs (args[arg_index].i);
		  arg_count++;
		  sptr += sprintf (sptr, ""%d"", value);
",unused,binutils-bfd2Fbfd.c
"{
#ifdef BFD64
  if (is32bit (abfd))
    {
      sprintf (buf, ""%08lx"", (unsigned long) value & 0xffffffff);
",1,unused,1999,unused,"{
#ifdef BFD64
  if (is32bit (abfd))
    {
      sprintf (buf, ""%08lx"", (unsigned long) value & 0xffffffff);
",unused,binutils-bfd2Fbfd.c
"  buf = (char *) bfd_alloc (abfd, size);
  if (buf == NULL)
    return """";

  sprintf (buf, ""_binary_%s_%s"", bfd_get_filename (abfd), suffix);
",1,unused,136,unused,"  buf = (char *) bfd_alloc (abfd, size);
  if (buf == NULL)
    return """";

  sprintf (buf, ""_binary_%s_%s"", bfd_get_filename (abfd), suffix);
",unused,binutils-bfd2Fbinary.c
"	  name = (char *) bfd_alloc (abfd,
				     (bfd_size_type) strlen (strings) + 1 + 1);
	  if (name == NULL)
	    return FALSE;
	  strcpy (name, strings);
",1,unused,94,unused,"	  name = (char *) bfd_alloc (abfd,
				     (bfd_size_type) strlen (strings) + 1 + 1);
	  if (name == NULL)
	    return FALSE;
	  strcpy (name, strings);
",unused,binutils-bfd2Fcoffgen.c
"	      amt = strlen (elename) + 1;
	      name_copy = (char *) bfd_alloc (input_bfd, amt);
	      if (name_copy == NULL)
		return FALSE;
	      strcpy (name_copy, elename);
",1,unused,1709,unused,"	      amt = strlen (elename) + 1;
	      name_copy = (char *) bfd_alloc (input_bfd, amt);
	      if (name_copy == NULL)
		return FALSE;
	      strcpy (name_copy, elename);
",unused,binutils-bfd2Fcofflink.c
"    {
      info->filename = (char *) bfd_alloc (table->abfd, strlen (filename) + 1);
      if (info->filename == NULL)
	return FALSE;
      strcpy (info->filename, filename);
",1,unused,1470,unused,"    {
      info->filename = (char *) bfd_alloc (table->abfd, strlen (filename) + 1);
      if (info->filename == NULL)
	return FALSE;
      strcpy (info->filename, filename);
",unused,binutils-bfd2Fdwarf2.c
"	{
	  len += strlen (subdir_name) + 1;
	  name = (char *) bfd_malloc (len);
	  if (name)
	    sprintf (name, ""%s/%s/%s"", dir_name, subdir_name, filename);
",1,unused,1615,unused,"	{
	  len += strlen (subdir_name) + 1;
	  name = (char *) bfd_malloc (len);
	  if (name)
	    sprintf (name, ""%s/%s/%s"", dir_name, subdir_name, filename);
",unused,binutils-bfd2Fdwarf2.c
"      else
	{
	  name = (char *) bfd_malloc (len);
	  if (name)
	    sprintf (name, ""%s/%s"", dir_name, filename);
",1,unused,1621,unused,"      else
	{
	  name = (char *) bfd_malloc (len);
	  if (name)
	    sprintf (name, ""%s/%s"", dir_name, filename);
",unused,binutils-bfd2Fdwarf2.c
"		   || cie->version == 3
		   || cie->version == 4);
	  REQUIRE (strlen ((char *) buf) < sizeof (cie->augmentation));

	  strcpy (cie->augmentation, (char *) buf);
",1,unused,754,unused,"		   || cie->version == 3
		   || cie->version == 4);
	  REQUIRE (strlen ((char *) buf) < sizeof (cie->augmentation));

	  strcpy (cie->augmentation, (char *) buf);
",unused,binutils-bfd2Felf-eh-frame.c
"	  char buf[20];

	  if (pt == NULL)
	    {
	      sprintf (buf, ""0x%lx"", p->p_type);
",1,unused,1630,unused,"	  char buf[20];

	  if (pt == NULL)
	    {
	      sprintf (buf, ""0x%lx"", p->p_type);
",unused,binutils-bfd2Felf.c
"		name = (*bed->elf_backend_get_target_dtag) (dyn.d_tag);

	      if (!strcmp (name, """"))
		{
		  sprintf (ab, ""%#"" BFD_VMA_FMT ""x"", dyn.d_tag);
",1,unused,1705,unused,"		name = (*bed->elf_backend_get_target_dtag) (dyn.d_tag);

	      if (!strcmp (name, """"))
		{
		  sprintf (ab, ""%#"" BFD_VMA_FMT ""x"", dyn.d_tag);
",unused,binutils-bfd2Felf.c
"	    && (hdr->p_memsz > hdr->p_filesz));

  if (hdr->p_filesz > 0)
    {
      sprintf (namebuf, ""%s%d%s"", type_name, hdr_index, split ? ""a"" : """");
",1,unused,2923,unused,"	    && (hdr->p_memsz > hdr->p_filesz));

  if (hdr->p_filesz > 0)
    {
      sprintf (namebuf, ""%s%d%s"", type_name, hdr_index, split ? ""a"" : """");
",unused,binutils-bfd2Felf.c
"  if (hdr->p_memsz > hdr->p_filesz)
    {
      bfd_vma align;

      sprintf (namebuf, ""%s%d%s"", type_name, hdr_index, split ? ""b"" : """");
",1,unused,2959,unused,"  if (hdr->p_memsz > hdr->p_filesz)
    {
      bfd_vma align;

      sprintf (namebuf, ""%s%d%s"", type_name, hdr_index, split ? ""b"" : """");
",unused,binutils-bfd2Felf.c
"				   sizeof "".rela"" + strlen (sec_name));
  if (name == NULL)
    return FALSE;

  sprintf (name, ""%s%s"", use_rela_p ? "".rela"" : "".rel"", sec_name);
",1,unused,3073,unused,"				   sizeof "".rela"" + strlen (sec_name));
  if (name == NULL)
    return FALSE;

  sprintf (name, ""%s%s"", use_rela_p ? "".rela"" : "".rel"", sec_name);
",unused,binutils-bfd2Felf.c
"
  if (pt == NULL)
    {
      if (m->p_type >= PT_LOPROC && m->p_type <= PT_HIPROC)
	sprintf (buf, ""LOPROC+%7.7x"",
",1,unused,5212,unused,"
  if (pt == NULL)
    {
      if (m->p_type >= PT_LOPROC && m->p_type <= PT_HIPROC)
	sprintf (buf, ""LOPROC+%7.7x"",
",unused,binutils-bfd2Felf.c
"      if (m->p_type >= PT_LOPROC && m->p_type <= PT_HIPROC)
	sprintf (buf, ""LOPROC+%7.7x"",
		 (unsigned int) (m->p_type - PT_LOPROC));
      else if (m->p_type >= PT_LOOS && m->p_type <= PT_HIOS)
	sprintf (buf, ""LOOS+%7.7x"",
",1,unused,5215,unused,"      if (m->p_type >= PT_LOPROC && m->p_type <= PT_HIPROC)
	sprintf (buf, ""LOPROC+%7.7x"",
		 (unsigned int) (m->p_type - PT_LOPROC));
      else if (m->p_type >= PT_LOOS && m->p_type <= PT_HIOS)
	sprintf (buf, ""LOOS+%7.7x"",
",unused,binutils-bfd2Felf.c
"  asection *sect;

  /* Build the section name.  */

  sprintf (buf, ""%s/%d"", name, elfcore_make_pid (abfd));
",1,unused,9087,unused,"  asection *sect;

  /* Build the section name.  */

  sprintf (buf, ""%s/%d"", name, elfcore_make_pid (abfd));
",unused,binutils-bfd2Felf.c
"
    case 2 /* NOTE_INFO_THREAD */:
      /* Make a "".reg/999"" section.  */
      /* thread_info.tid */
      sprintf (buf, "".reg/%ld"", (long) bfd_get_32 (abfd, note->descdata + 8));
",1,unused,9599,unused,"
    case 2 /* NOTE_INFO_THREAD */:
      /* Make a "".reg/999"" section.  */
      /* thread_info.tid */
      sprintf (buf, "".reg/%ld"", (long) bfd_get_32 (abfd, note->descdata + 8));
",unused,binutils-bfd2Felf.c
"    case 3 /* NOTE_INFO_MODULE */:
      /* Make a "".module/xxxxxxxx"" section.  */
      /* module_info.base_address */
      base_addr = bfd_get_32 (abfd, note->descdata + 4);
      sprintf (buf, "".module/%08lx"", (unsigned long) base_addr);
",1,unused,9630,unused,"    case 3 /* NOTE_INFO_MODULE */:
      /* Make a "".module/xxxxxxxx"" section.  */
      /* module_info.base_address */
      base_addr = bfd_get_32 (abfd, note->descdata + 4);
      sprintf (buf, "".module/%08lx"", (unsigned long) base_addr);
",unused,binutils-bfd2Felf.c
"  if (flags & 0x00000080)
    elf_tdata (abfd)->core->lwpid = *tid;

  /* Make a "".qnx_core_status/%d"" section.  */
  sprintf (buf, "".qnx_core_status/%ld"", *tid);
",1,unused,10343,unused,"  if (flags & 0x00000080)
    elf_tdata (abfd)->core->lwpid = *tid;

  /* Make a "".qnx_core_status/%d"" section.  */
  sprintf (buf, "".qnx_core_status/%ld"", *tid);
",unused,binutils-bfd2Felf.c
"
  name = (char *) bfd_alloc (abfd, strlen (buf) + 1);
  if (name == NULL)
    return FALSE;
  strcpy (name, buf);
",1,unused,10348,unused,"
  name = (char *) bfd_alloc (abfd, strlen (buf) + 1);
  if (name == NULL)
    return FALSE;
  strcpy (name, buf);
",unused,binutils-bfd2Felf.c
"  char *name;
  asection *sect;

  /* Make a ""(base)/%d"" section.  */
  sprintf (buf, ""%s/%ld"", base, tid);
",1,unused,10372,unused,"  char *name;
  asection *sect;

  /* Make a ""(base)/%d"" section.  */
  sprintf (buf, ""%s/%ld"", base, tid);
",unused,binutils-bfd2Felf.c
"
  name = (char *) bfd_alloc (abfd, strlen (buf) + 1);
  if (name == NULL)
    return FALSE;
  strcpy (name, buf);
",1,unused,10377,unused,"
  name = (char *) bfd_alloc (abfd, strlen (buf) + 1);
  if (name == NULL)
    return FALSE;
  strcpy (name, buf);
",unused,binutils-bfd2Felf.c
"  if (old_name == NULL)
    return NULL;

  name = bfd_alloc (abfd, strlen (prefix) + strlen (old_name) + 1);
  sprintf (name, ""%s%s"", prefix, old_name);
",1,unused,14340,unused,"  if (old_name == NULL)
    return NULL;

  name = bfd_alloc (abfd, strlen (prefix) + strlen (old_name) + 1);
  sprintf (name, ""%s%s"", prefix, old_name);
",unused,binutils-bfd2Felflink.c
"    {
      char buf[10];

      if (! ISPRINT (c))
	sprintf (buf, ""\\%03o"", (unsigned int) c & 0xff);
",1,unused,222,unused,"    {
      char buf[10];

      if (! ISPRINT (c))
	sprintf (buf, ""\\%03o"", (unsigned int) c & 0xff);
",unused,binutils-bfd2Fihex.c
"		  char *secname;
		  bfd_size_type amt;
		  flagword flags;

		  sprintf (secbuf, "".sec%d"", bfd_count_sections (abfd) + 1);
",1,unused,363,unused,"		  char *secname;
		  bfd_size_type amt;
		  flagword flags;

		  sprintf (secbuf, "".sec%d"", bfd_count_sections (abfd) + 1);
",unused,binutils-bfd2Fihex.c
"		  amt = strlen (secbuf) + 1;
		  secname = (char *) bfd_alloc (abfd, amt);
		  if (secname == NULL)
		    goto error_return;
		  strcpy (secname, secbuf);
",1,unused,368,unused,"		  amt = strlen (secbuf) + 1;
		  secname = (char *) bfd_alloc (abfd, amt);
		  if (secname == NULL)
		    goto error_return;
		  strcpy (secname, secbuf);
",unused,binutils-bfd2Fihex.c
"	    return NULL;

	  n[0] = prefix;
	  n[1] = '\0';
	  strcat (n, WRAP);
",1,unused,558,unused,"	    return NULL;

	  n[0] = prefix;
	  n[1] = '\0';
	  strcat (n, WRAP);
",unused,binutils-bfd2Flinker.c
"
	  n[0] = prefix;
	  n[1] = '\0';
	  strcat (n, WRAP);
	  strcat (n, l);
",1,unused,559,unused,"
	  n[0] = prefix;
	  n[1] = '\0';
	  strcat (n, WRAP);
	  strcat (n, l);
",unused,binutils-bfd2Flinker.c
"	    return NULL;

	  n[0] = prefix;
	  n[1] = '\0';
	  strcat (n, l + sizeof REAL - 1);
",1,unused,587,unused,"	    return NULL;

	  n[0] = prefix;
	  n[1] = '\0';
	  strcat (n, l + sizeof REAL - 1);
",unused,binutils-bfd2Flinker.c
"     The check is left in however as this allows the binutils
     testsuite to exercise this feature without having to install
     a file into the root filesystem.  (See binutils/testsuite/
     binutils-all/objdump.exp for the test).  */
  sprintf (debugfile, ""%s%s"", dir, base);
",1,unused,1508,unused,"     The check is left in however as this allows the binutils
     testsuite to exercise this feature without having to install
     a file into the root filesystem.  (See binutils/testsuite/
     binutils-all/objdump.exp for the test).  */
  sprintf (debugfile, ""%s%s"", dir, base);
",unused,binutils-bfd2Fopncls.c
"  if (check_func (debugfile, func_data))
    goto found;

  /* Then try in a subdirectory called .debug.  */
  sprintf (debugfile, ""%s.debug/%s"", dir, base);
",1,unused,1513,unused,"  if (check_func (debugfile, func_data))
    goto found;

  /* Then try in a subdirectory called .debug.  */
  sprintf (debugfile, ""%s.debug/%s"", dir, base);
",unused,binutils-bfd2Fopncls.c
"    goto found;

#ifdef EXTRA_DEBUG_ROOT1
  /* Try the first extra debug file root.  */
  sprintf (debugfile, ""%s%s%s"", EXTRA_DEBUG_ROOT1,
",1,unused,1519,unused,"    goto found;

#ifdef EXTRA_DEBUG_ROOT1
  /* Try the first extra debug file root.  */
  sprintf (debugfile, ""%s%s%s"", EXTRA_DEBUG_ROOT1,
",unused,binutils-bfd2Fopncls.c
"#endif

#ifdef EXTRA_DEBUG_ROOT2
  /* Try the second extra debug file root.  */
  sprintf (debugfile, ""%s%s%s"", EXTRA_DEBUG_ROOT2,
",1,unused,1527,unused,"#endif

#ifdef EXTRA_DEBUG_ROOT2
  /* Try the second extra debug file root.  */
  sprintf (debugfile, ""%s%s%s"", EXTRA_DEBUG_ROOT2,
",unused,binutils-bfd2Fopncls.c
"    goto found;
#endif

  /* Then try in the global debugfile directory.  */
  strcpy (debugfile, debug_file_directory);
",1,unused,1534,unused,"    goto found;
#endif

  /* Then try in the global debugfile directory.  */
  strcpy (debugfile, debug_file_directory);
",unused,binutils-bfd2Fopncls.c
"    {
      if (dirlen > 0
	  && debug_file_directory[dirlen] != '/'
	  && canon_dir[0] != '/')
	strcat (debugfile, ""/"");
",1,unused,1541,unused,"    {
      if (dirlen > 0
	  && debug_file_directory[dirlen] != '/'
	  && canon_dir[0] != '/')
	strcat (debugfile, ""/"");
",unused,binutils-bfd2Fopncls.c
"      if (dirlen > 0
	  && debug_file_directory[dirlen] != '/'
	  && canon_dir[0] != '/')
	strcat (debugfile, ""/"");
      strcat (debugfile, canon_dir);
",1,unused,1542,unused,"      if (dirlen > 0
	  && debug_file_directory[dirlen] != '/'
	  && canon_dir[0] != '/')
	strcat (debugfile, ""/"");
      strcat (debugfile, canon_dir);
",unused,binutils-bfd2Fopncls.c
"    }
  else
    {
      if (dirlen > 0 && debug_file_directory[dirlen] != '/')
	strcat (debugfile, ""/"");
",1,unused,1547,unused,"    }
  else
    {
      if (dirlen > 0 && debug_file_directory[dirlen] != '/')
	strcat (debugfile, ""/"");
",unused,binutils-bfd2Fopncls.c
"    {
      if (dirlen > 0 && debug_file_directory[dirlen] != '/')
	strcat (debugfile, ""/"");
    }
  strcat (debugfile, base);
",1,unused,1549,unused,"    {
      if (dirlen > 0 && debug_file_directory[dirlen] != '/')
	strcat (debugfile, ""/"");
    }
  strcat (debugfile, base);
",unused,binutils-bfd2Fopncls.c
"  n = name;
  d = build_id->data;
  s = build_id->size;

  n += sprintf (n, "".build-id/"");
",1,unused,1959,unused,"  n = name;
  d = build_id->data;
  s = build_id->size;

  n += sprintf (n, "".build-id/"");
",unused,binutils-bfd2Fopncls.c
"  d = build_id->data;
  s = build_id->size;

  n += sprintf (n, "".build-id/"");
  n += sprintf (n, ""%02x"", (unsigned) *d++); s--;
",1,unused,1960,unused,"  d = build_id->data;
  s = build_id->size;

  n += sprintf (n, "".build-id/"");
  n += sprintf (n, ""%02x"", (unsigned) *d++); s--;
",unused,binutils-bfd2Fopncls.c
"  s = build_id->size;

  n += sprintf (n, "".build-id/"");
  n += sprintf (n, ""%02x"", (unsigned) *d++); s--;
  n += sprintf (n, ""/"");
",1,unused,1961,unused,"  s = build_id->size;

  n += sprintf (n, "".build-id/"");
  n += sprintf (n, ""%02x"", (unsigned) *d++); s--;
  n += sprintf (n, ""/"");
",unused,binutils-bfd2Fopncls.c
"  n += sprintf (n, "".build-id/"");
  n += sprintf (n, ""%02x"", (unsigned) *d++); s--;
  n += sprintf (n, ""/"");
  while (s--)
    n += sprintf (n, ""%02x"", (unsigned) *d++);
",1,unused,1963,unused,"  n += sprintf (n, "".build-id/"");
  n += sprintf (n, ""%02x"", (unsigned) *d++); s--;
  n += sprintf (n, ""/"");
  while (s--)
    n += sprintf (n, ""%02x"", (unsigned) *d++);
",unused,binutils-bfd2Fopncls.c
"  n += sprintf (n, ""%02x"", (unsigned) *d++); s--;
  n += sprintf (n, ""/"");
  while (s--)
    n += sprintf (n, ""%02x"", (unsigned) *d++);
  n += sprintf (n, "".debug"");
",1,unused,1964,unused,"  n += sprintf (n, ""%02x"", (unsigned) *d++); s--;
  n += sprintf (n, ""/"");
  while (s--)
    n += sprintf (n, ""%02x"", (unsigned) *d++);
  n += sprintf (n, "".debug"");
",unused,binutils-bfd2Fopncls.c
"		  _bfd_error_handler (_(""%pB: out of memory creating name for empty section""),
				      abfd);
		  return;
		}
	      strcpy ((char *) name, namebuf);
",1,unused,187,unused,"		  _bfd_error_handler (_(""%pB: out of memory creating name for empty section""),
				      abfd);
		  return;
		}
	      strcpy ((char *) name, namebuf);
",unused,binutils-bfd2Fpeigen.c
"					       idd.SizeOfData, cvinfo))
	    continue;

	  for (i = 0; i < cvinfo->SignatureLength; i++)
	    sprintf (&signature[i*2], ""%02x"", cvinfo->Signature[i] & 0xff);
",1,unused,2724,unused,"					       idd.SizeOfData, cvinfo))
	    continue;

	  for (i = 0; i < cvinfo->SignatureLength; i++)
	    sprintf (&signature[i*2], ""%02x"", cvinfo->Signature[i] & 0xff);
",unused,binutils-bfd2Fpeigen.c
"  unsigned int  i;
  bfd_byte *    name = string.string;

  for (i = string.len; i--; name += 2)
    sprintf (buffer + strlen (buffer), ""%.1s"", name);
",1,unused,3712,unused,"  unsigned int  i;
  bfd_byte *    name = string.string;

  for (i = string.len; i--; name += 2)
    sprintf (buffer + strlen (buffer), ""%.1s"", name);
",unused,binutils-bfd2Fpeigen.c
"
  if (dir != NULL && dir->entry != NULL && dir->entry->parent != NULL
      && dir->entry->parent->entry != NULL)
    {
      strcpy (buffer, ""type: "");
",1,unused,3726,unused,"
  if (dir != NULL && dir->entry != NULL && dir->entry->parent != NULL
      && dir->entry->parent->entry != NULL)
    {
      strcpy (buffer, ""type: "");
",unused,binutils-bfd2Fpeigen.c
"      else
	{
	  unsigned int id = dir->entry->parent->entry->name_id.id;

	  sprintf (buffer + strlen (buffer), ""%x"", id);
",1,unused,3734,unused,"      else
	{
	  unsigned int id = dir->entry->parent->entry->name_id.id;

	  sprintf (buffer + strlen (buffer), ""%x"", id);
",unused,binutils-bfd2Fpeigen.c
"
	  sprintf (buffer + strlen (buffer), ""%x"", id);
	  switch (id)
	    {
	    case 1: strcat (buffer, "" (CURSOR)""); break;
",1,unused,3737,unused,"
	  sprintf (buffer + strlen (buffer), ""%x"", id);
	  switch (id)
	    {
	    case 1: strcat (buffer, "" (CURSOR)""); break;
",unused,binutils-bfd2Fpeigen.c
"	  sprintf (buffer + strlen (buffer), ""%x"", id);
	  switch (id)
	    {
	    case 1: strcat (buffer, "" (CURSOR)""); break;
	    case 2: strcat (buffer, "" (BITMAP)""); break;
",1,unused,3738,unused,"	  sprintf (buffer + strlen (buffer), ""%x"", id);
	  switch (id)
	    {
	    case 1: strcat (buffer, "" (CURSOR)""); break;
	    case 2: strcat (buffer, "" (BITMAP)""); break;
",unused,binutils-bfd2Fpeigen.c
"	  switch (id)
	    {
	    case 1: strcat (buffer, "" (CURSOR)""); break;
	    case 2: strcat (buffer, "" (BITMAP)""); break;
	    case 3: strcat (buffer, "" (ICON)""); break;
",1,unused,3739,unused,"	  switch (id)
	    {
	    case 1: strcat (buffer, "" (CURSOR)""); break;
	    case 2: strcat (buffer, "" (BITMAP)""); break;
	    case 3: strcat (buffer, "" (ICON)""); break;
",unused,binutils-bfd2Fpeigen.c
"	    {
	    case 1: strcat (buffer, "" (CURSOR)""); break;
	    case 2: strcat (buffer, "" (BITMAP)""); break;
	    case 3: strcat (buffer, "" (ICON)""); break;
	    case 4: strcat (buffer, "" (MENU)""); break;
",1,unused,3740,unused,"	    {
	    case 1: strcat (buffer, "" (CURSOR)""); break;
	    case 2: strcat (buffer, "" (BITMAP)""); break;
	    case 3: strcat (buffer, "" (ICON)""); break;
	    case 4: strcat (buffer, "" (MENU)""); break;
",unused,binutils-bfd2Fpeigen.c
"	    case 1: strcat (buffer, "" (CURSOR)""); break;
	    case 2: strcat (buffer, "" (BITMAP)""); break;
	    case 3: strcat (buffer, "" (ICON)""); break;
	    case 4: strcat (buffer, "" (MENU)""); break;
	    case 5: strcat (buffer, "" (DIALOG)""); break;
",1,unused,3741,unused,"	    case 1: strcat (buffer, "" (CURSOR)""); break;
	    case 2: strcat (buffer, "" (BITMAP)""); break;
	    case 3: strcat (buffer, "" (ICON)""); break;
	    case 4: strcat (buffer, "" (MENU)""); break;
	    case 5: strcat (buffer, "" (DIALOG)""); break;
",unused,binutils-bfd2Fpeigen.c
"	    case 2: strcat (buffer, "" (BITMAP)""); break;
	    case 3: strcat (buffer, "" (ICON)""); break;
	    case 4: strcat (buffer, "" (MENU)""); break;
	    case 5: strcat (buffer, "" (DIALOG)""); break;
	    case 6: strcat (buffer, "" (STRING)""); is_string = TRUE; break;
",1,unused,3742,unused,"	    case 2: strcat (buffer, "" (BITMAP)""); break;
	    case 3: strcat (buffer, "" (ICON)""); break;
	    case 4: strcat (buffer, "" (MENU)""); break;
	    case 5: strcat (buffer, "" (DIALOG)""); break;
	    case 6: strcat (buffer, "" (STRING)""); is_string = TRUE; break;
",unused,binutils-bfd2Fpeigen.c
"	    case 3: strcat (buffer, "" (ICON)""); break;
	    case 4: strcat (buffer, "" (MENU)""); break;
	    case 5: strcat (buffer, "" (DIALOG)""); break;
	    case 6: strcat (buffer, "" (STRING)""); is_string = TRUE; break;
	    case 7: strcat (buffer, "" (FONTDIR)""); break;
",1,unused,3743,unused,"	    case 3: strcat (buffer, "" (ICON)""); break;
	    case 4: strcat (buffer, "" (MENU)""); break;
	    case 5: strcat (buffer, "" (DIALOG)""); break;
	    case 6: strcat (buffer, "" (STRING)""); is_string = TRUE; break;
	    case 7: strcat (buffer, "" (FONTDIR)""); break;
",unused,binutils-bfd2Fpeigen.c
"	    case 4: strcat (buffer, "" (MENU)""); break;
	    case 5: strcat (buffer, "" (DIALOG)""); break;
	    case 6: strcat (buffer, "" (STRING)""); is_string = TRUE; break;
	    case 7: strcat (buffer, "" (FONTDIR)""); break;
	    case 8: strcat (buffer, "" (FONT)""); break;
",1,unused,3744,unused,"	    case 4: strcat (buffer, "" (MENU)""); break;
	    case 5: strcat (buffer, "" (DIALOG)""); break;
	    case 6: strcat (buffer, "" (STRING)""); is_string = TRUE; break;
	    case 7: strcat (buffer, "" (FONTDIR)""); break;
	    case 8: strcat (buffer, "" (FONT)""); break;
",unused,binutils-bfd2Fpeigen.c
"	    case 5: strcat (buffer, "" (DIALOG)""); break;
	    case 6: strcat (buffer, "" (STRING)""); is_string = TRUE; break;
	    case 7: strcat (buffer, "" (FONTDIR)""); break;
	    case 8: strcat (buffer, "" (FONT)""); break;
	    case 9: strcat (buffer, "" (ACCELERATOR)""); break;
",1,unused,3745,unused,"	    case 5: strcat (buffer, "" (DIALOG)""); break;
	    case 6: strcat (buffer, "" (STRING)""); is_string = TRUE; break;
	    case 7: strcat (buffer, "" (FONTDIR)""); break;
	    case 8: strcat (buffer, "" (FONT)""); break;
	    case 9: strcat (buffer, "" (ACCELERATOR)""); break;
",unused,binutils-bfd2Fpeigen.c
"	    case 6: strcat (buffer, "" (STRING)""); is_string = TRUE; break;
	    case 7: strcat (buffer, "" (FONTDIR)""); break;
	    case 8: strcat (buffer, "" (FONT)""); break;
	    case 9: strcat (buffer, "" (ACCELERATOR)""); break;
	    case 10: strcat (buffer, "" (RCDATA)""); break;
",1,unused,3746,unused,"	    case 6: strcat (buffer, "" (STRING)""); is_string = TRUE; break;
	    case 7: strcat (buffer, "" (FONTDIR)""); break;
	    case 8: strcat (buffer, "" (FONT)""); break;
	    case 9: strcat (buffer, "" (ACCELERATOR)""); break;
	    case 10: strcat (buffer, "" (RCDATA)""); break;
",unused,binutils-bfd2Fpeigen.c
"	    case 7: strcat (buffer, "" (FONTDIR)""); break;
	    case 8: strcat (buffer, "" (FONT)""); break;
	    case 9: strcat (buffer, "" (ACCELERATOR)""); break;
	    case 10: strcat (buffer, "" (RCDATA)""); break;
	    case 11: strcat (buffer, "" (MESSAGETABLE)""); break;
",1,unused,3747,unused,"	    case 7: strcat (buffer, "" (FONTDIR)""); break;
	    case 8: strcat (buffer, "" (FONT)""); break;
	    case 9: strcat (buffer, "" (ACCELERATOR)""); break;
	    case 10: strcat (buffer, "" (RCDATA)""); break;
	    case 11: strcat (buffer, "" (MESSAGETABLE)""); break;
",unused,binutils-bfd2Fpeigen.c
"	    case 8: strcat (buffer, "" (FONT)""); break;
	    case 9: strcat (buffer, "" (ACCELERATOR)""); break;
	    case 10: strcat (buffer, "" (RCDATA)""); break;
	    case 11: strcat (buffer, "" (MESSAGETABLE)""); break;
	    case 12: strcat (buffer, "" (GROUP_CURSOR)""); break;
",1,unused,3748,unused,"	    case 8: strcat (buffer, "" (FONT)""); break;
	    case 9: strcat (buffer, "" (ACCELERATOR)""); break;
	    case 10: strcat (buffer, "" (RCDATA)""); break;
	    case 11: strcat (buffer, "" (MESSAGETABLE)""); break;
	    case 12: strcat (buffer, "" (GROUP_CURSOR)""); break;
",unused,binutils-bfd2Fpeigen.c
"	    case 9: strcat (buffer, "" (ACCELERATOR)""); break;
	    case 10: strcat (buffer, "" (RCDATA)""); break;
	    case 11: strcat (buffer, "" (MESSAGETABLE)""); break;
	    case 12: strcat (buffer, "" (GROUP_CURSOR)""); break;
	    case 14: strcat (buffer, "" (GROUP_ICON)""); break;
",1,unused,3749,unused,"	    case 9: strcat (buffer, "" (ACCELERATOR)""); break;
	    case 10: strcat (buffer, "" (RCDATA)""); break;
	    case 11: strcat (buffer, "" (MESSAGETABLE)""); break;
	    case 12: strcat (buffer, "" (GROUP_CURSOR)""); break;
	    case 14: strcat (buffer, "" (GROUP_ICON)""); break;
",unused,binutils-bfd2Fpeigen.c
"	    case 10: strcat (buffer, "" (RCDATA)""); break;
	    case 11: strcat (buffer, "" (MESSAGETABLE)""); break;
	    case 12: strcat (buffer, "" (GROUP_CURSOR)""); break;
	    case 14: strcat (buffer, "" (GROUP_ICON)""); break;
	    case 16: strcat (buffer, "" (VERSION)""); break;
",1,unused,3750,unused,"	    case 10: strcat (buffer, "" (RCDATA)""); break;
	    case 11: strcat (buffer, "" (MESSAGETABLE)""); break;
	    case 12: strcat (buffer, "" (GROUP_CURSOR)""); break;
	    case 14: strcat (buffer, "" (GROUP_ICON)""); break;
	    case 16: strcat (buffer, "" (VERSION)""); break;
",unused,binutils-bfd2Fpeigen.c
"	    case 11: strcat (buffer, "" (MESSAGETABLE)""); break;
	    case 12: strcat (buffer, "" (GROUP_CURSOR)""); break;
	    case 14: strcat (buffer, "" (GROUP_ICON)""); break;
	    case 16: strcat (buffer, "" (VERSION)""); break;
	    case 17: strcat (buffer, "" (DLGINCLUDE)""); break;
",1,unused,3751,unused,"	    case 11: strcat (buffer, "" (MESSAGETABLE)""); break;
	    case 12: strcat (buffer, "" (GROUP_CURSOR)""); break;
	    case 14: strcat (buffer, "" (GROUP_ICON)""); break;
	    case 16: strcat (buffer, "" (VERSION)""); break;
	    case 17: strcat (buffer, "" (DLGINCLUDE)""); break;
",unused,binutils-bfd2Fpeigen.c
"	    case 12: strcat (buffer, "" (GROUP_CURSOR)""); break;
	    case 14: strcat (buffer, "" (GROUP_ICON)""); break;
	    case 16: strcat (buffer, "" (VERSION)""); break;
	    case 17: strcat (buffer, "" (DLGINCLUDE)""); break;
	    case 19: strcat (buffer, "" (PLUGPLAY)""); break;
",1,unused,3752,unused,"	    case 12: strcat (buffer, "" (GROUP_CURSOR)""); break;
	    case 14: strcat (buffer, "" (GROUP_ICON)""); break;
	    case 16: strcat (buffer, "" (VERSION)""); break;
	    case 17: strcat (buffer, "" (DLGINCLUDE)""); break;
	    case 19: strcat (buffer, "" (PLUGPLAY)""); break;
",unused,binutils-bfd2Fpeigen.c
"	    case 14: strcat (buffer, "" (GROUP_ICON)""); break;
	    case 16: strcat (buffer, "" (VERSION)""); break;
	    case 17: strcat (buffer, "" (DLGINCLUDE)""); break;
	    case 19: strcat (buffer, "" (PLUGPLAY)""); break;
	    case 20: strcat (buffer, "" (VXD)""); break;
",1,unused,3753,unused,"	    case 14: strcat (buffer, "" (GROUP_ICON)""); break;
	    case 16: strcat (buffer, "" (VERSION)""); break;
	    case 17: strcat (buffer, "" (DLGINCLUDE)""); break;
	    case 19: strcat (buffer, "" (PLUGPLAY)""); break;
	    case 20: strcat (buffer, "" (VXD)""); break;
",unused,binutils-bfd2Fpeigen.c
"	    case 16: strcat (buffer, "" (VERSION)""); break;
	    case 17: strcat (buffer, "" (DLGINCLUDE)""); break;
	    case 19: strcat (buffer, "" (PLUGPLAY)""); break;
	    case 20: strcat (buffer, "" (VXD)""); break;
	    case 21: strcat (buffer, "" (ANICURSOR)""); break;
",1,unused,3754,unused,"	    case 16: strcat (buffer, "" (VERSION)""); break;
	    case 17: strcat (buffer, "" (DLGINCLUDE)""); break;
	    case 19: strcat (buffer, "" (PLUGPLAY)""); break;
	    case 20: strcat (buffer, "" (VXD)""); break;
	    case 21: strcat (buffer, "" (ANICURSOR)""); break;
",unused,binutils-bfd2Fpeigen.c
"	    case 17: strcat (buffer, "" (DLGINCLUDE)""); break;
	    case 19: strcat (buffer, "" (PLUGPLAY)""); break;
	    case 20: strcat (buffer, "" (VXD)""); break;
	    case 21: strcat (buffer, "" (ANICURSOR)""); break;
	    case 22: strcat (buffer, "" (ANIICON)""); break;
",1,unused,3755,unused,"	    case 17: strcat (buffer, "" (DLGINCLUDE)""); break;
	    case 19: strcat (buffer, "" (PLUGPLAY)""); break;
	    case 20: strcat (buffer, "" (VXD)""); break;
	    case 21: strcat (buffer, "" (ANICURSOR)""); break;
	    case 22: strcat (buffer, "" (ANIICON)""); break;
",unused,binutils-bfd2Fpeigen.c
"	    case 19: strcat (buffer, "" (PLUGPLAY)""); break;
	    case 20: strcat (buffer, "" (VXD)""); break;
	    case 21: strcat (buffer, "" (ANICURSOR)""); break;
	    case 22: strcat (buffer, "" (ANIICON)""); break;
	    case 23: strcat (buffer, "" (HTML)""); break;
",1,unused,3756,unused,"	    case 19: strcat (buffer, "" (PLUGPLAY)""); break;
	    case 20: strcat (buffer, "" (VXD)""); break;
	    case 21: strcat (buffer, "" (ANICURSOR)""); break;
	    case 22: strcat (buffer, "" (ANIICON)""); break;
	    case 23: strcat (buffer, "" (HTML)""); break;
",unused,binutils-bfd2Fpeigen.c
"	    case 20: strcat (buffer, "" (VXD)""); break;
	    case 21: strcat (buffer, "" (ANICURSOR)""); break;
	    case 22: strcat (buffer, "" (ANIICON)""); break;
	    case 23: strcat (buffer, "" (HTML)""); break;
	    case 24: strcat (buffer, "" (MANIFEST)""); break;
",1,unused,3757,unused,"	    case 20: strcat (buffer, "" (VXD)""); break;
	    case 21: strcat (buffer, "" (ANICURSOR)""); break;
	    case 22: strcat (buffer, "" (ANIICON)""); break;
	    case 23: strcat (buffer, "" (HTML)""); break;
	    case 24: strcat (buffer, "" (MANIFEST)""); break;
",unused,binutils-bfd2Fpeigen.c
"	    case 21: strcat (buffer, "" (ANICURSOR)""); break;
	    case 22: strcat (buffer, "" (ANIICON)""); break;
	    case 23: strcat (buffer, "" (HTML)""); break;
	    case 24: strcat (buffer, "" (MANIFEST)""); break;
	    case 240: strcat (buffer, "" (DLGINIT)""); break;
",1,unused,3758,unused,"	    case 21: strcat (buffer, "" (ANICURSOR)""); break;
	    case 22: strcat (buffer, "" (ANIICON)""); break;
	    case 23: strcat (buffer, "" (HTML)""); break;
	    case 24: strcat (buffer, "" (MANIFEST)""); break;
	    case 240: strcat (buffer, "" (DLGINIT)""); break;
",unused,binutils-bfd2Fpeigen.c
"	    case 22: strcat (buffer, "" (ANIICON)""); break;
	    case 23: strcat (buffer, "" (HTML)""); break;
	    case 24: strcat (buffer, "" (MANIFEST)""); break;
	    case 240: strcat (buffer, "" (DLGINIT)""); break;
	    case 241: strcat (buffer, "" (TOOLBAR)""); break;
",1,unused,3759,unused,"	    case 22: strcat (buffer, "" (ANIICON)""); break;
	    case 23: strcat (buffer, "" (HTML)""); break;
	    case 24: strcat (buffer, "" (MANIFEST)""); break;
	    case 240: strcat (buffer, "" (DLGINIT)""); break;
	    case 241: strcat (buffer, "" (TOOLBAR)""); break;
",unused,binutils-bfd2Fpeigen.c
"    }

  if (dir != NULL && dir->entry != NULL)
    {
      strcat (buffer, "" name: "");
",1,unused,3766,unused,"    }

  if (dir != NULL && dir->entry != NULL)
    {
      strcat (buffer, "" name: "");
",unused,binutils-bfd2Fpeigen.c
"      else
	{
	  unsigned int id = dir->entry->name_id.id;

	  sprintf (buffer + strlen (buffer), ""%x"", id);
",1,unused,3773,unused,"      else
	{
	  unsigned int id = dir->entry->name_id.id;

	  sprintf (buffer + strlen (buffer), ""%x"", id);
",unused,binutils-bfd2Fpeigen.c
"
	  sprintf (buffer + strlen (buffer), ""%x"", id);

	  if (is_string)
	    sprintf (buffer + strlen (buffer), "" (resource id range: %d - %d)"",
",1,unused,3776,unused,"
	  sprintf (buffer + strlen (buffer), ""%x"", id);

	  if (is_string)
	    sprintf (buffer + strlen (buffer), "" (resource id range: %d - %d)"",
",unused,binutils-bfd2Fpeigen.c
"    }

  if (entry != NULL)
    {
      strcat (buffer, "" lang: "");
",1,unused,3783,unused,"    }

  if (entry != NULL)
    {
      strcat (buffer, "" lang: "");
",unused,binutils-bfd2Fpeigen.c
"
      if (entry->is_name)
	rsrc_print_name (buffer + strlen (buffer), entry->name_id.name);
      else
	sprintf (buffer + strlen (buffer), ""%x"", entry->name_id.id);
",1,unused,3788,unused,"
      if (entry->is_name)
	rsrc_print_name (buffer + strlen (buffer), entry->name_id.name);
      else
	sprintf (buffer + strlen (buffer), ""%x"", entry->name_id.id);
",unused,binutils-bfd2Fpeigen.c
"		  _bfd_error_handler (_(""%pB: out of memory creating name for empty section""),
				      abfd);
		  return;
		}
	      strcpy ((char *) name, namebuf);
",1,unused,187,unused,"		  _bfd_error_handler (_(""%pB: out of memory creating name for empty section""),
				      abfd);
		  return;
		}
	      strcpy ((char *) name, namebuf);
",unused,binutils-bfd2Fpex64igen.c
"					       idd.SizeOfData, cvinfo))
	    continue;

	  for (i = 0; i < cvinfo->SignatureLength; i++)
	    sprintf (&signature[i*2], ""%02x"", cvinfo->Signature[i] & 0xff);
",1,unused,2724,unused,"					       idd.SizeOfData, cvinfo))
	    continue;

	  for (i = 0; i < cvinfo->SignatureLength; i++)
	    sprintf (&signature[i*2], ""%02x"", cvinfo->Signature[i] & 0xff);
",unused,binutils-bfd2Fpex64igen.c
"  unsigned int  i;
  bfd_byte *    name = string.string;

  for (i = string.len; i--; name += 2)
    sprintf (buffer + strlen (buffer), ""%.1s"", name);
",1,unused,3712,unused,"  unsigned int  i;
  bfd_byte *    name = string.string;

  for (i = string.len; i--; name += 2)
    sprintf (buffer + strlen (buffer), ""%.1s"", name);
",unused,binutils-bfd2Fpex64igen.c
"
  if (dir != NULL && dir->entry != NULL && dir->entry->parent != NULL
      && dir->entry->parent->entry != NULL)
    {
      strcpy (buffer, ""type: "");
",1,unused,3726,unused,"
  if (dir != NULL && dir->entry != NULL && dir->entry->parent != NULL
      && dir->entry->parent->entry != NULL)
    {
      strcpy (buffer, ""type: "");
",unused,binutils-bfd2Fpex64igen.c
"      else
	{
	  unsigned int id = dir->entry->parent->entry->name_id.id;

	  sprintf (buffer + strlen (buffer), ""%x"", id);
",1,unused,3734,unused,"      else
	{
	  unsigned int id = dir->entry->parent->entry->name_id.id;

	  sprintf (buffer + strlen (buffer), ""%x"", id);
",unused,binutils-bfd2Fpex64igen.c
"
	  sprintf (buffer + strlen (buffer), ""%x"", id);
	  switch (id)
	    {
	    case 1: strcat (buffer, "" (CURSOR)""); break;
",1,unused,3737,unused,"
	  sprintf (buffer + strlen (buffer), ""%x"", id);
	  switch (id)
	    {
	    case 1: strcat (buffer, "" (CURSOR)""); break;
",unused,binutils-bfd2Fpex64igen.c
"	  sprintf (buffer + strlen (buffer), ""%x"", id);
	  switch (id)
	    {
	    case 1: strcat (buffer, "" (CURSOR)""); break;
	    case 2: strcat (buffer, "" (BITMAP)""); break;
",1,unused,3738,unused,"	  sprintf (buffer + strlen (buffer), ""%x"", id);
	  switch (id)
	    {
	    case 1: strcat (buffer, "" (CURSOR)""); break;
	    case 2: strcat (buffer, "" (BITMAP)""); break;
",unused,binutils-bfd2Fpex64igen.c
"	  switch (id)
	    {
	    case 1: strcat (buffer, "" (CURSOR)""); break;
	    case 2: strcat (buffer, "" (BITMAP)""); break;
	    case 3: strcat (buffer, "" (ICON)""); break;
",1,unused,3739,unused,"	  switch (id)
	    {
	    case 1: strcat (buffer, "" (CURSOR)""); break;
	    case 2: strcat (buffer, "" (BITMAP)""); break;
	    case 3: strcat (buffer, "" (ICON)""); break;
",unused,binutils-bfd2Fpex64igen.c
"	    {
	    case 1: strcat (buffer, "" (CURSOR)""); break;
	    case 2: strcat (buffer, "" (BITMAP)""); break;
	    case 3: strcat (buffer, "" (ICON)""); break;
	    case 4: strcat (buffer, "" (MENU)""); break;
",1,unused,3740,unused,"	    {
	    case 1: strcat (buffer, "" (CURSOR)""); break;
	    case 2: strcat (buffer, "" (BITMAP)""); break;
	    case 3: strcat (buffer, "" (ICON)""); break;
	    case 4: strcat (buffer, "" (MENU)""); break;
",unused,binutils-bfd2Fpex64igen.c
"	    case 1: strcat (buffer, "" (CURSOR)""); break;
	    case 2: strcat (buffer, "" (BITMAP)""); break;
	    case 3: strcat (buffer, "" (ICON)""); break;
	    case 4: strcat (buffer, "" (MENU)""); break;
	    case 5: strcat (buffer, "" (DIALOG)""); break;
",1,unused,3741,unused,"	    case 1: strcat (buffer, "" (CURSOR)""); break;
	    case 2: strcat (buffer, "" (BITMAP)""); break;
	    case 3: strcat (buffer, "" (ICON)""); break;
	    case 4: strcat (buffer, "" (MENU)""); break;
	    case 5: strcat (buffer, "" (DIALOG)""); break;
",unused,binutils-bfd2Fpex64igen.c
"	    case 2: strcat (buffer, "" (BITMAP)""); break;
	    case 3: strcat (buffer, "" (ICON)""); break;
	    case 4: strcat (buffer, "" (MENU)""); break;
	    case 5: strcat (buffer, "" (DIALOG)""); break;
	    case 6: strcat (buffer, "" (STRING)""); is_string = TRUE; break;
",1,unused,3742,unused,"	    case 2: strcat (buffer, "" (BITMAP)""); break;
	    case 3: strcat (buffer, "" (ICON)""); break;
	    case 4: strcat (buffer, "" (MENU)""); break;
	    case 5: strcat (buffer, "" (DIALOG)""); break;
	    case 6: strcat (buffer, "" (STRING)""); is_string = TRUE; break;
",unused,binutils-bfd2Fpex64igen.c
"	    case 3: strcat (buffer, "" (ICON)""); break;
	    case 4: strcat (buffer, "" (MENU)""); break;
	    case 5: strcat (buffer, "" (DIALOG)""); break;
	    case 6: strcat (buffer, "" (STRING)""); is_string = TRUE; break;
	    case 7: strcat (buffer, "" (FONTDIR)""); break;
",1,unused,3743,unused,"	    case 3: strcat (buffer, "" (ICON)""); break;
	    case 4: strcat (buffer, "" (MENU)""); break;
	    case 5: strcat (buffer, "" (DIALOG)""); break;
	    case 6: strcat (buffer, "" (STRING)""); is_string = TRUE; break;
	    case 7: strcat (buffer, "" (FONTDIR)""); break;
",unused,binutils-bfd2Fpex64igen.c
"	    case 4: strcat (buffer, "" (MENU)""); break;
	    case 5: strcat (buffer, "" (DIALOG)""); break;
	    case 6: strcat (buffer, "" (STRING)""); is_string = TRUE; break;
	    case 7: strcat (buffer, "" (FONTDIR)""); break;
	    case 8: strcat (buffer, "" (FONT)""); break;
",1,unused,3744,unused,"	    case 4: strcat (buffer, "" (MENU)""); break;
	    case 5: strcat (buffer, "" (DIALOG)""); break;
	    case 6: strcat (buffer, "" (STRING)""); is_string = TRUE; break;
	    case 7: strcat (buffer, "" (FONTDIR)""); break;
	    case 8: strcat (buffer, "" (FONT)""); break;
",unused,binutils-bfd2Fpex64igen.c
"	    case 5: strcat (buffer, "" (DIALOG)""); break;
	    case 6: strcat (buffer, "" (STRING)""); is_string = TRUE; break;
	    case 7: strcat (buffer, "" (FONTDIR)""); break;
	    case 8: strcat (buffer, "" (FONT)""); break;
	    case 9: strcat (buffer, "" (ACCELERATOR)""); break;
",1,unused,3745,unused,"	    case 5: strcat (buffer, "" (DIALOG)""); break;
	    case 6: strcat (buffer, "" (STRING)""); is_string = TRUE; break;
	    case 7: strcat (buffer, "" (FONTDIR)""); break;
	    case 8: strcat (buffer, "" (FONT)""); break;
	    case 9: strcat (buffer, "" (ACCELERATOR)""); break;
",unused,binutils-bfd2Fpex64igen.c
"	    case 6: strcat (buffer, "" (STRING)""); is_string = TRUE; break;
	    case 7: strcat (buffer, "" (FONTDIR)""); break;
	    case 8: strcat (buffer, "" (FONT)""); break;
	    case 9: strcat (buffer, "" (ACCELERATOR)""); break;
	    case 10: strcat (buffer, "" (RCDATA)""); break;
",1,unused,3746,unused,"	    case 6: strcat (buffer, "" (STRING)""); is_string = TRUE; break;
	    case 7: strcat (buffer, "" (FONTDIR)""); break;
	    case 8: strcat (buffer, "" (FONT)""); break;
	    case 9: strcat (buffer, "" (ACCELERATOR)""); break;
	    case 10: strcat (buffer, "" (RCDATA)""); break;
",unused,binutils-bfd2Fpex64igen.c
"	    case 7: strcat (buffer, "" (FONTDIR)""); break;
	    case 8: strcat (buffer, "" (FONT)""); break;
	    case 9: strcat (buffer, "" (ACCELERATOR)""); break;
	    case 10: strcat (buffer, "" (RCDATA)""); break;
	    case 11: strcat (buffer, "" (MESSAGETABLE)""); break;
",1,unused,3747,unused,"	    case 7: strcat (buffer, "" (FONTDIR)""); break;
	    case 8: strcat (buffer, "" (FONT)""); break;
	    case 9: strcat (buffer, "" (ACCELERATOR)""); break;
	    case 10: strcat (buffer, "" (RCDATA)""); break;
	    case 11: strcat (buffer, "" (MESSAGETABLE)""); break;
",unused,binutils-bfd2Fpex64igen.c
"	    case 8: strcat (buffer, "" (FONT)""); break;
	    case 9: strcat (buffer, "" (ACCELERATOR)""); break;
	    case 10: strcat (buffer, "" (RCDATA)""); break;
	    case 11: strcat (buffer, "" (MESSAGETABLE)""); break;
	    case 12: strcat (buffer, "" (GROUP_CURSOR)""); break;
",1,unused,3748,unused,"	    case 8: strcat (buffer, "" (FONT)""); break;
	    case 9: strcat (buffer, "" (ACCELERATOR)""); break;
	    case 10: strcat (buffer, "" (RCDATA)""); break;
	    case 11: strcat (buffer, "" (MESSAGETABLE)""); break;
	    case 12: strcat (buffer, "" (GROUP_CURSOR)""); break;
",unused,binutils-bfd2Fpex64igen.c
"	    case 9: strcat (buffer, "" (ACCELERATOR)""); break;
	    case 10: strcat (buffer, "" (RCDATA)""); break;
	    case 11: strcat (buffer, "" (MESSAGETABLE)""); break;
	    case 12: strcat (buffer, "" (GROUP_CURSOR)""); break;
	    case 14: strcat (buffer, "" (GROUP_ICON)""); break;
",1,unused,3749,unused,"	    case 9: strcat (buffer, "" (ACCELERATOR)""); break;
	    case 10: strcat (buffer, "" (RCDATA)""); break;
	    case 11: strcat (buffer, "" (MESSAGETABLE)""); break;
	    case 12: strcat (buffer, "" (GROUP_CURSOR)""); break;
	    case 14: strcat (buffer, "" (GROUP_ICON)""); break;
",unused,binutils-bfd2Fpex64igen.c
"	    case 10: strcat (buffer, "" (RCDATA)""); break;
	    case 11: strcat (buffer, "" (MESSAGETABLE)""); break;
	    case 12: strcat (buffer, "" (GROUP_CURSOR)""); break;
	    case 14: strcat (buffer, "" (GROUP_ICON)""); break;
	    case 16: strcat (buffer, "" (VERSION)""); break;
",1,unused,3750,unused,"	    case 10: strcat (buffer, "" (RCDATA)""); break;
	    case 11: strcat (buffer, "" (MESSAGETABLE)""); break;
	    case 12: strcat (buffer, "" (GROUP_CURSOR)""); break;
	    case 14: strcat (buffer, "" (GROUP_ICON)""); break;
	    case 16: strcat (buffer, "" (VERSION)""); break;
",unused,binutils-bfd2Fpex64igen.c
"	    case 11: strcat (buffer, "" (MESSAGETABLE)""); break;
	    case 12: strcat (buffer, "" (GROUP_CURSOR)""); break;
	    case 14: strcat (buffer, "" (GROUP_ICON)""); break;
	    case 16: strcat (buffer, "" (VERSION)""); break;
	    case 17: strcat (buffer, "" (DLGINCLUDE)""); break;
",1,unused,3751,unused,"	    case 11: strcat (buffer, "" (MESSAGETABLE)""); break;
	    case 12: strcat (buffer, "" (GROUP_CURSOR)""); break;
	    case 14: strcat (buffer, "" (GROUP_ICON)""); break;
	    case 16: strcat (buffer, "" (VERSION)""); break;
	    case 17: strcat (buffer, "" (DLGINCLUDE)""); break;
",unused,binutils-bfd2Fpex64igen.c
"	    case 12: strcat (buffer, "" (GROUP_CURSOR)""); break;
	    case 14: strcat (buffer, "" (GROUP_ICON)""); break;
	    case 16: strcat (buffer, "" (VERSION)""); break;
	    case 17: strcat (buffer, "" (DLGINCLUDE)""); break;
	    case 19: strcat (buffer, "" (PLUGPLAY)""); break;
",1,unused,3752,unused,"	    case 12: strcat (buffer, "" (GROUP_CURSOR)""); break;
	    case 14: strcat (buffer, "" (GROUP_ICON)""); break;
	    case 16: strcat (buffer, "" (VERSION)""); break;
	    case 17: strcat (buffer, "" (DLGINCLUDE)""); break;
	    case 19: strcat (buffer, "" (PLUGPLAY)""); break;
",unused,binutils-bfd2Fpex64igen.c
"	    case 14: strcat (buffer, "" (GROUP_ICON)""); break;
	    case 16: strcat (buffer, "" (VERSION)""); break;
	    case 17: strcat (buffer, "" (DLGINCLUDE)""); break;
	    case 19: strcat (buffer, "" (PLUGPLAY)""); break;
	    case 20: strcat (buffer, "" (VXD)""); break;
",1,unused,3753,unused,"	    case 14: strcat (buffer, "" (GROUP_ICON)""); break;
	    case 16: strcat (buffer, "" (VERSION)""); break;
	    case 17: strcat (buffer, "" (DLGINCLUDE)""); break;
	    case 19: strcat (buffer, "" (PLUGPLAY)""); break;
	    case 20: strcat (buffer, "" (VXD)""); break;
",unused,binutils-bfd2Fpex64igen.c
"	    case 16: strcat (buffer, "" (VERSION)""); break;
	    case 17: strcat (buffer, "" (DLGINCLUDE)""); break;
	    case 19: strcat (buffer, "" (PLUGPLAY)""); break;
	    case 20: strcat (buffer, "" (VXD)""); break;
	    case 21: strcat (buffer, "" (ANICURSOR)""); break;
",1,unused,3754,unused,"	    case 16: strcat (buffer, "" (VERSION)""); break;
	    case 17: strcat (buffer, "" (DLGINCLUDE)""); break;
	    case 19: strcat (buffer, "" (PLUGPLAY)""); break;
	    case 20: strcat (buffer, "" (VXD)""); break;
	    case 21: strcat (buffer, "" (ANICURSOR)""); break;
",unused,binutils-bfd2Fpex64igen.c
"	    case 17: strcat (buffer, "" (DLGINCLUDE)""); break;
	    case 19: strcat (buffer, "" (PLUGPLAY)""); break;
	    case 20: strcat (buffer, "" (VXD)""); break;
	    case 21: strcat (buffer, "" (ANICURSOR)""); break;
	    case 22: strcat (buffer, "" (ANIICON)""); break;
",1,unused,3755,unused,"	    case 17: strcat (buffer, "" (DLGINCLUDE)""); break;
	    case 19: strcat (buffer, "" (PLUGPLAY)""); break;
	    case 20: strcat (buffer, "" (VXD)""); break;
	    case 21: strcat (buffer, "" (ANICURSOR)""); break;
	    case 22: strcat (buffer, "" (ANIICON)""); break;
",unused,binutils-bfd2Fpex64igen.c
"	    case 19: strcat (buffer, "" (PLUGPLAY)""); break;
	    case 20: strcat (buffer, "" (VXD)""); break;
	    case 21: strcat (buffer, "" (ANICURSOR)""); break;
	    case 22: strcat (buffer, "" (ANIICON)""); break;
	    case 23: strcat (buffer, "" (HTML)""); break;
",1,unused,3756,unused,"	    case 19: strcat (buffer, "" (PLUGPLAY)""); break;
	    case 20: strcat (buffer, "" (VXD)""); break;
	    case 21: strcat (buffer, "" (ANICURSOR)""); break;
	    case 22: strcat (buffer, "" (ANIICON)""); break;
	    case 23: strcat (buffer, "" (HTML)""); break;
",unused,binutils-bfd2Fpex64igen.c
"	    case 20: strcat (buffer, "" (VXD)""); break;
	    case 21: strcat (buffer, "" (ANICURSOR)""); break;
	    case 22: strcat (buffer, "" (ANIICON)""); break;
	    case 23: strcat (buffer, "" (HTML)""); break;
	    case 24: strcat (buffer, "" (MANIFEST)""); break;
",1,unused,3757,unused,"	    case 20: strcat (buffer, "" (VXD)""); break;
	    case 21: strcat (buffer, "" (ANICURSOR)""); break;
	    case 22: strcat (buffer, "" (ANIICON)""); break;
	    case 23: strcat (buffer, "" (HTML)""); break;
	    case 24: strcat (buffer, "" (MANIFEST)""); break;
",unused,binutils-bfd2Fpex64igen.c
"	    case 21: strcat (buffer, "" (ANICURSOR)""); break;
	    case 22: strcat (buffer, "" (ANIICON)""); break;
	    case 23: strcat (buffer, "" (HTML)""); break;
	    case 24: strcat (buffer, "" (MANIFEST)""); break;
	    case 240: strcat (buffer, "" (DLGINIT)""); break;
",1,unused,3758,unused,"	    case 21: strcat (buffer, "" (ANICURSOR)""); break;
	    case 22: strcat (buffer, "" (ANIICON)""); break;
	    case 23: strcat (buffer, "" (HTML)""); break;
	    case 24: strcat (buffer, "" (MANIFEST)""); break;
	    case 240: strcat (buffer, "" (DLGINIT)""); break;
",unused,binutils-bfd2Fpex64igen.c
"	    case 22: strcat (buffer, "" (ANIICON)""); break;
	    case 23: strcat (buffer, "" (HTML)""); break;
	    case 24: strcat (buffer, "" (MANIFEST)""); break;
	    case 240: strcat (buffer, "" (DLGINIT)""); break;
	    case 241: strcat (buffer, "" (TOOLBAR)""); break;
",1,unused,3759,unused,"	    case 22: strcat (buffer, "" (ANIICON)""); break;
	    case 23: strcat (buffer, "" (HTML)""); break;
	    case 24: strcat (buffer, "" (MANIFEST)""); break;
	    case 240: strcat (buffer, "" (DLGINIT)""); break;
	    case 241: strcat (buffer, "" (TOOLBAR)""); break;
",unused,binutils-bfd2Fpex64igen.c
"    }

  if (dir != NULL && dir->entry != NULL)
    {
      strcat (buffer, "" name: "");
",1,unused,3766,unused,"    }

  if (dir != NULL && dir->entry != NULL)
    {
      strcat (buffer, "" name: "");
",unused,binutils-bfd2Fpex64igen.c
"      else
	{
	  unsigned int id = dir->entry->name_id.id;

	  sprintf (buffer + strlen (buffer), ""%x"", id);
",1,unused,3773,unused,"      else
	{
	  unsigned int id = dir->entry->name_id.id;

	  sprintf (buffer + strlen (buffer), ""%x"", id);
",unused,binutils-bfd2Fpex64igen.c
"
	  sprintf (buffer + strlen (buffer), ""%x"", id);

	  if (is_string)
	    sprintf (buffer + strlen (buffer), "" (resource id range: %d - %d)"",
",1,unused,3776,unused,"
	  sprintf (buffer + strlen (buffer), ""%x"", id);

	  if (is_string)
	    sprintf (buffer + strlen (buffer), "" (resource id range: %d - %d)"",
",unused,binutils-bfd2Fpex64igen.c
"    }

  if (entry != NULL)
    {
      strcat (buffer, "" lang: "");
",1,unused,3783,unused,"    }

  if (entry != NULL)
    {
      strcat (buffer, "" lang: "");
",unused,binutils-bfd2Fpex64igen.c
"
      if (entry->is_name)
	rsrc_print_name (buffer + strlen (buffer), entry->name_id.name);
      else
	sprintf (buffer + strlen (buffer), ""%x"", entry->name_id.id);
",1,unused,3788,unused,"
      if (entry->is_name)
	rsrc_print_name (buffer + strlen (buffer), entry->name_id.name);
      else
	sprintf (buffer + strlen (buffer), ""%x"", entry->name_id.id);
",unused,binutils-bfd2Fpex64igen.c
"    {
      /* If we have a million sections, something is badly wrong.  */
      if (num > 999999)
	abort ();
      sprintf (sname + len, "".%d"", num++);
",1,unused,1054,unused,"    {
      /* If we have a million sections, something is badly wrong.  */
      if (num > 999999)
	abort ();
      sprintf (sname + len, "".%d"", num++);
",unused,binutils-bfd2Fsection.c
"    {
      char buf[40];

      if (! ISPRINT (c))
	sprintf (buf, ""\\%03o"", (unsigned int) c & 0xff);
",1,unused,252,unused,"    {
      char buf[40];

      if (! ISPRINT (c))
	sprintf (buf, ""\\%03o"", (unsigned int) c & 0xff);
",unused,binutils-bfd2Fsrec.c
"	      *p++ = '\0';
	      symname = (char *) bfd_alloc (abfd, (bfd_size_type) (p - symbuf));
	      if (symname == NULL)
		goto error_return;
	      strcpy (symname, symbuf);
",1,unused,400,unused,"	      *p++ = '\0';
	      symname = (char *) bfd_alloc (abfd, (bfd_size_type) (p - symbuf));
	      if (symname == NULL)
		goto error_return;
	      strcpy (symname, symbuf);
",unused,binutils-bfd2Fsrec.c
"		    char *secname;
		    bfd_size_type amt;
		    flagword flags;

		    sprintf (secbuf, "".sec%d"", bfd_count_sections (abfd) + 1);
",1,unused,556,unused,"		    char *secname;
		    bfd_size_type amt;
		    flagword flags;

		    sprintf (secbuf, "".sec%d"", bfd_count_sections (abfd) + 1);
",unused,binutils-bfd2Fsrec.c
"
		    sprintf (secbuf, "".sec%d"", bfd_count_sections (abfd) + 1);
		    amt = strlen (secbuf) + 1;
		    secname = (char *) bfd_alloc (abfd, amt);
		    strcpy (secname, secbuf);
",1,unused,559,unused,"
		    sprintf (secbuf, "".sec%d"", bfd_count_sections (abfd) + 1);
		    amt = strlen (secbuf) + 1;
		    secname = (char *) bfd_alloc (abfd, amt);
		    strcpy (secname, secbuf);
",unused,binutils-bfd2Fsrec.c
"	      if (!_bfd_find_arch_match (tname, arches, def_target_arch))
		{
		  char new_tname[50];

		  strcpy (new_tname, hyp);
",1,unused,1593,unused,"	      if (!_bfd_find_arch_match (tname, arches, def_target_arch))
		{
		  char new_tname[50];

		  strcpy (new_tname, hyp);
",unused,binutils-bfd2Ftargets.c
"  char *old_name, *new_name;
  bfd *contents_head = iarch->archive_next;

  old_name = (char *) xmalloc (strlen (bfd_get_filename (iarch)) + 1);
  strcpy (old_name, bfd_get_filename (iarch));
",1,unused,1158,unused,"  char *old_name, *new_name;
  bfd *contents_head = iarch->archive_next;

  old_name = (char *) xmalloc (strlen (bfd_get_filename (iarch)) + 1);
  strcpy (old_name, bfd_get_filename (iarch));
",unused,binutils-binutils2Far.c
"  real_name = name;

  /* Prepend tmp- to the beginning, to avoid file-name clashes after
     truncation on filesystems with limited namespaces (DOS).  */
  sprintf (tname, ""%.*stmp-%s"", (int) (bname - name), name, bname);
",1,unused,158,unused,"  real_name = name;

  /* Prepend tmp- to the beginning, to avoid file-name clashes after
     truncation on filesystems with limited namespaces (DOS).  */
  sprintf (tname, ""%.*stmp-%s"", (int) (bname - name), name, bname);
",unused,binutils-binutils2Farsup.c
"	  bfd_size_type size;

	  /* PR binutils/17605: Check for corrupt time values.  */
	  if (ctime_result == NULL)
	    sprintf (timebuf, _(""<time data corrupt>""));
",1,unused,446,unused,"	  bfd_size_type size;

	  /* PR binutils/17605: Check for corrupt time values.  */
	  if (ctime_result == NULL)
	    sprintf (timebuf, _(""<time data corrupt>""));
",unused,binutils-binutils2Fbucomm.c
"	  if (ctime_result == NULL)
	    sprintf (timebuf, _(""<time data corrupt>""));
	  else
	    /* POSIX format:  skip weekday and seconds from ctime output.  */
	    sprintf (timebuf, ""%.12s %.4s"", ctime_result + 4, ctime_result + 20);
",1,unused,449,unused,"	  if (ctime_result == NULL)
	    sprintf (timebuf, _(""<time data corrupt>""));
	  else
	    /* POSIX format:  skip weekday and seconds from ctime output.  */
	    sprintf (timebuf, ""%.12s %.4s"", ctime_result + 4, ctime_result + 20);
",unused,binutils-binutils2Fbucomm.c
"	free (buf);
      curr = needed + (needed >> 1);
      buf = (char *) xmalloc (curr);
    }
  sprintf (buf, ""%s(%s)"", bfd_get_filename (abfd->my_archive),
",1,unused,648,unused,"	free (buf);
      curr = needed + (needed >> 1);
      buf = (char *) xmalloc (curr);
    }
  sprintf (buf, ""%s(%s)"", bfd_get_filename (abfd->my_archive),
",unused,binutils-binutils2Fbucomm.c
"	    *ptr++ = bfd_get_symbol_leading_char (obfd);

	  if (prefix_symbols_string)
	    {
	      strcpy (ptr, prefix_symbols_string);
",1,unused,1542,unused,"	    *ptr++ = bfd_get_symbol_leading_char (obfd);

	  if (prefix_symbols_string)
	    {
	      strcpy (ptr, prefix_symbols_string);
",unused,binutils-binutils2Fobjcopy.c
"	      strcpy (ptr, prefix_symbols_string);
	      ptr += strlen (prefix_symbols_string);
	    }

	  strcpy (ptr, name);
",1,unused,1546,unused,"	      strcpy (ptr, prefix_symbols_string);
	      ptr += strlen (prefix_symbols_string);
	    }

	  strcpy (ptr, name);
",unused,binutils-binutils2Fobjcopy.c
"    {
      char *n;

      n = (char *) xmalloc (strlen (prefix) + strlen (name) + 1);
      strcpy (n, prefix);
",1,unused,3697,unused,"    {
      char *n;

      n = (char *) xmalloc (strlen (prefix) + strlen (name) + 1);
      strcpy (n, prefix);
",unused,binutils-binutils2Fobjcopy.c
"      char *n;

      n = (char *) xmalloc (strlen (prefix) + strlen (name) + 1);
      strcpy (n, prefix);
      strcat (n, name);
",1,unused,3698,unused,"      char *n;

      n = (char *) xmalloc (strlen (prefix) + strlen (name) + 1);
      strcpy (n, prefix);
      strcat (n, name);
",unused,binutils-binutils2Fobjcopy.c
"
	    nextarg = s + 1;
	    len = strlen (nextarg);
	    target = (char *) xmalloc (len + 1);
	    strcpy (target, nextarg);
",1,unused,5119,unused,"
	    nextarg = s + 1;
	    len = strlen (nextarg);
	    target = (char *) xmalloc (len + 1);
	    strcpy (target, nextarg);
",unused,binutils-binutils2Fobjcopy.c
"    {
      if (prev_functionname != NULL)
	free (prev_functionname);
      prev_functionname = (char *) xmalloc (strlen (functionname) + 1);
      strcpy (prev_functionname, functionname);
",1,unused,1643,unused,"    {
      if (prev_functionname != NULL)
	free (prev_functionname);
      prev_functionname = (char *) xmalloc (strlen (functionname) + 1);
      strcpy (prev_functionname, functionname);
",unused,binutils-binutils2Fobjdump.c
"
  assert (info->stack != NULL);

  n = (char *) xmalloc (strlen (s) + strlen (info->stack->type) + 1);
  sprintf (n, ""%s%s"", s, info->stack->type);
",1,unused,363,unused,"
  assert (info->stack != NULL);

  n = (char *) xmalloc (strlen (s) + strlen (info->stack->type) + 1);
  sprintf (n, ""%s%s"", s, info->stack->type);
",unused,binutils-binutils2Fprdbg.c
"
  len = strlen (info->stack->type);
  info->stack->type = (char *) xrealloc (info->stack->type,
					 len + strlen (s) + 1);
  strcpy (info->stack->type + len, s);
",1,unused,385,unused,"
  len = strlen (info->stack->type);
  info->stack->type = (char *) xrealloc (info->stack->type,
					 len + strlen (s) + 1);
  strcpy (info->stack->type + len, s);
",unused,binutils-binutils2Fprdbg.c
"
  len = info->stack->parents ? strlen (info->stack->parents) : 0;
  info->stack->parents = (char *) xrealloc (info->stack->parents,
					    len + strlen (s) + 1);
  strcpy (info->stack->parents + len, s);
",1,unused,405,unused,"
  len = info->stack->parents ? strlen (info->stack->parents) : 0;
  info->stack->parents = (char *) xrealloc (info->stack->parents,
					    len + strlen (s) + 1);
  strcpy (info->stack->parents + len, s);
",unused,binutils-binutils2Fprdbg.c
"
      n = (char *) xmalloc (strlen (info->stack->type) + strlen (s));

      memcpy (n, info->stack->type, u - info->stack->type);
      strcpy (n + (u - info->stack->type), s);
",1,unused,429,unused,"
      n = (char *) xmalloc (strlen (info->stack->type) + strlen (s));

      memcpy (n, info->stack->type, u - info->stack->type);
      strcpy (n + (u - info->stack->type), s);
",unused,binutils-binutils2Fprdbg.c
"      n = (char *) xmalloc (strlen (info->stack->type) + strlen (s));

      memcpy (n, info->stack->type, u - info->stack->type);
      strcpy (n + (u - info->stack->type), s);
      strcat (n, u + 1);
",1,unused,430,unused,"      n = (char *) xmalloc (strlen (info->stack->type) + strlen (s));

      memcpy (n, info->stack->type, u - info->stack->type);
      strcpy (n + (u - info->stack->type), s);
      strcat (n, u + 1);
",unused,binutils-binutils2Fprdbg.c
"{
  if (sizeof (vma) <= sizeof (unsigned long))
    {
      if (hexp)
	sprintf (buf, ""0x%lx"", (unsigned long) vma);
",1,unused,496,unused,"{
  if (sizeof (vma) <= sizeof (unsigned long))
    {
      if (hexp)
	sprintf (buf, ""0x%lx"", (unsigned long) vma);
",unused,binutils-binutils2Fprdbg.c
"    {
      if (hexp)
	sprintf (buf, ""0x%lx"", (unsigned long) vma);
      else if (unsignedp)
	sprintf (buf, ""%lu"", (unsigned long) vma);
",1,unused,498,unused,"    {
      if (hexp)
	sprintf (buf, ""0x%lx"", (unsigned long) vma);
      else if (unsignedp)
	sprintf (buf, ""%lu"", (unsigned long) vma);
",unused,binutils-binutils2Fprdbg.c
"	sprintf (buf, ""0x%lx"", (unsigned long) vma);
      else if (unsignedp)
	sprintf (buf, ""%lu"", (unsigned long) vma);
      else
	sprintf (buf, ""%ld"", (long) vma);
",1,unused,500,unused,"	sprintf (buf, ""0x%lx"", (unsigned long) vma);
      else if (unsignedp)
	sprintf (buf, ""%lu"", (unsigned long) vma);
      else
	sprintf (buf, ""%ld"", (long) vma);
",unused,binutils-binutils2Fprdbg.c
"{
  struct pr_handle *info = (struct pr_handle *) p;
  char ab[40];

  sprintf (ab, ""%sint%d"", unsignedp ? ""u"" : """", size * 8);
",1,unused,586,unused,"{
  struct pr_handle *info = (struct pr_handle *) p;
  char ab[40];

  sprintf (ab, ""%sint%d"", unsignedp ? ""u"" : """", size * 8);
",unused,binutils-binutils2Fprdbg.c
"    return push_type (info, ""float"");
  else if (size == 8)
    return push_type (info, ""double"");

  sprintf (ab, ""float%d"", size * 8);
",1,unused,603,unused,"    return push_type (info, ""float"");
  else if (size == 8)
    return push_type (info, ""double"");

  sprintf (ab, ""float%d"", size * 8);
",unused,binutils-binutils2Fprdbg.c
"{
  struct pr_handle *info = (struct pr_handle *) p;
  char ab[40];

  sprintf (ab, ""bool%d"", size * 8);
",1,unused,628,unused,"{
  struct pr_handle *info = (struct pr_handle *) p;
  char ab[40];

  sprintf (ab, ""bool%d"", size * 8);
",unused,binutils-binutils2Fprdbg.c
"  s = (char *) xmalloc (len);
  LITSTRCPY (s, ""(|) ("");

  if (argcount < 0)
    strcat (s, ""/* unknown */"");
",1,unused,756,unused,"  s = (char *) xmalloc (len);
  LITSTRCPY (s, ""(|) ("");

  if (argcount < 0)
    strcat (s, ""/* unknown */"");
",unused,binutils-binutils2Fprdbg.c
"
      for (i = 0; i < argcount; i++)
	{
	  if (i > 0)
	    strcat (s, "", "");
",1,unused,764,unused,"
      for (i = 0; i < argcount; i++)
	{
	  if (i > 0)
	    strcat (s, "", "");
",unused,binutils-binutils2Fprdbg.c
"      for (i = 0; i < argcount; i++)
	{
	  if (i > 0)
	    strcat (s, "", "");
	  strcat (s, arg_types[i]);
",1,unused,765,unused,"      for (i = 0; i < argcount; i++)
	{
	  if (i > 0)
	    strcat (s, "", "");
	  strcat (s, arg_types[i]);
",unused,binutils-binutils2Fprdbg.c
"	}
      if (varargs)
	{
	  if (i > 0)
	    strcat (s, "", "");
",1,unused,770,unused,"	}
      if (varargs)
	{
	  if (i > 0)
	    strcat (s, "", "");
",unused,binutils-binutils2Fprdbg.c
"      if (varargs)
	{
	  if (i > 0)
	    strcat (s, "", "");
	  strcat (s, ""..."");
",1,unused,771,unused,"      if (varargs)
	{
	  if (i > 0)
	    strcat (s, "", "");
	  strcat (s, ""..."");
",unused,binutils-binutils2Fprdbg.c
"      if (argcount > 0)
	free (arg_types);
    }

  strcat (s, "")"");
",1,unused,777,unused,"      if (argcount > 0)
	free (arg_types);
    }

  strcat (s, "")"");
",unused,binutils-binutils2Fprdbg.c
"
  if (lower == 0)
    {
      if (upper == -1)
	sprintf (ab, ""|[]"");
",1,unused,839,unused,"
  if (lower == 0)
    {
      if (upper == -1)
	sprintf (ab, ""|[]"");
",unused,binutils-binutils2Fprdbg.c
"	sprintf (ab, ""|[]"");
      else
	{
	  print_vma (upper + 1, abu, FALSE, FALSE);
	  sprintf (ab, ""|[%s]"", abu);
",1,unused,843,unused,"	sprintf (ab, ""|[]"");
      else
	{
	  print_vma (upper + 1, abu, FALSE, FALSE);
	  sprintf (ab, ""|[%s]"", abu);
",unused,binutils-binutils2Fprdbg.c
"  else
    {
      print_vma (lower, abl, FALSE, FALSE);
      print_vma (upper, abu, FALSE, FALSE);
      sprintf (ab, ""|[%s:%s]"", abl, abu);
",1,unused,850,unused,"  else
    {
      print_vma (lower, abl, FALSE, FALSE);
      print_vma (upper, abu, FALSE, FALSE);
      sprintf (ab, ""|[%s:%s]"", abl, abu);
",unused,binutils-binutils2Fprdbg.c
"  s = (char *) xmalloc (len);
  if (! domain)
    *s = '\0';
  else
    strcpy (s, domain_type);
",1,unused,983,unused,"  s = (char *) xmalloc (len);
  if (! domain)
    *s = '\0';
  else
    strcpy (s, domain_type);
",unused,binutils-binutils2Fprdbg.c
"  if (! domain)
    *s = '\0';
  else
    strcpy (s, domain_type);
  strcat (s, ""::| ("");
",1,unused,984,unused,"  if (! domain)
    *s = '\0';
  else
    strcpy (s, domain_type);
  strcat (s, ""::| ("");
",unused,binutils-binutils2Fprdbg.c
"    strcpy (s, domain_type);
  strcat (s, ""::| ("");

  if (argcount < 0)
    strcat (s, ""/* unknown */"");
",1,unused,987,unused,"    strcpy (s, domain_type);
  strcat (s, ""::| ("");

  if (argcount < 0)
    strcat (s, ""/* unknown */"");
",unused,binutils-binutils2Fprdbg.c
"
      for (i = 0; i < argcount; i++)
	{
	  if (i > 0)
	    strcat (s, "", "");
",1,unused,995,unused,"
      for (i = 0; i < argcount; i++)
	{
	  if (i > 0)
	    strcat (s, "", "");
",unused,binutils-binutils2Fprdbg.c
"      for (i = 0; i < argcount; i++)
	{
	  if (i > 0)
	    strcat (s, "", "");
	  strcat (s, arg_types[i]);
",1,unused,996,unused,"      for (i = 0; i < argcount; i++)
	{
	  if (i > 0)
	    strcat (s, "", "");
	  strcat (s, arg_types[i]);
",unused,binutils-binutils2Fprdbg.c
"	}
      if (varargs)
	{
	  if (i > 0)
	    strcat (s, "", "");
",1,unused,1001,unused,"	}
      if (varargs)
	{
	  if (i > 0)
	    strcat (s, "", "");
",unused,binutils-binutils2Fprdbg.c
"      if (varargs)
	{
	  if (i > 0)
	    strcat (s, "", "");
	  strcat (s, ""..."");
",1,unused,1002,unused,"      if (varargs)
	{
	  if (i > 0)
	    strcat (s, "", "");
	  strcat (s, ""..."");
",unused,binutils-binutils2Fprdbg.c
"      if (argcount > 0)
	free (arg_types);
    }

  strcat (s, "")"");
",1,unused,1008,unused,"      if (argcount > 0)
	free (arg_types);
    }

  strcat (s, "")"");
",unused,binutils-binutils2Fprdbg.c
"  else
    {
      char idbuf[20];

      sprintf (idbuf, ""%%anon%u"", id);
",1,unused,1059,unused,"  else
    {
      char idbuf[20];

      sprintf (idbuf, ""%%anon%u"", id);
",unused,binutils-binutils2Fprdbg.c
"	return FALSE;

      if (size != 0)
	{
	  sprintf (ab, "" size %u"", size);
",1,unused,1075,unused,"	return FALSE;

      if (size != 0)
	{
	  sprintf (ab, "" size %u"", size);
",unused,binutils-binutils2Fprdbg.c
"	    return FALSE;
	}
      if (tag != NULL)
	{
	  sprintf (ab, "" id %u"", id);
",1,unused,1081,unused,"	    return FALSE;
	}
      if (tag != NULL)
	{
	  sprintf (ab, "" id %u"", id);
",unused,binutils-binutils2Fprdbg.c
"  else
    {
      char idbuf[20];

      sprintf (idbuf, ""%%anon%u"", id);
",1,unused,1242,unused,"  else
    {
      char idbuf[20];

      sprintf (idbuf, ""%%anon%u"", id);
",unused,binutils-binutils2Fprdbg.c
"      if (size != 0)
	{
	  char ab[20];

	  sprintf (ab, ""%u"", size);
",1,unused,1258,unused,"      if (size != 0)
	{
	  char ab[20];

	  sprintf (ab, ""%u"", size);
",unused,binutils-binutils2Fprdbg.c
"      if (tag != NULL)
	{
	  char ab[30];

	  sprintf (ab, "" id %u"", id);
",1,unused,1285,unused,"      if (tag != NULL)
	{
	  char ab[30];

	  sprintf (ab, "" id %u"", id);
",unused,binutils-binutils2Fprdbg.c
"    return FALSE;

  n = (char *) xmalloc (strlen (info->stack->type) + strlen (t) + 1);
  memcpy (n, info->stack->type, s - info->stack->type);
  strcpy (n + (s - info->stack->type), t);
",1,unused,1414,unused,"    return FALSE;

  n = (char *) xmalloc (strlen (info->stack->type) + strlen (t) + 1);
  memcpy (n, info->stack->type, s - info->stack->type);
  strcpy (n + (s - info->stack->type), t);
",unused,binutils-binutils2Fprdbg.c
"
  n = (char *) xmalloc (strlen (info->stack->type) + strlen (t) + 1);
  memcpy (n, info->stack->type, s - info->stack->type);
  strcpy (n + (s - info->stack->type), t);
  strcat (n, s);
",1,unused,1415,unused,"
  n = (char *) xmalloc (strlen (info->stack->type) + strlen (t) + 1);
  memcpy (n, info->stack->type, s - info->stack->type);
  strcpy (n + (s - info->stack->type), t);
  strcat (n, s);
",unused,binutils-binutils2Fprdbg.c
"  if (name != NULL)
    tag = name;
  else
    {
      sprintf (idbuf, ""%%anon%u"", id);
",1,unused,1635,unused,"  if (name != NULL)
    tag = name;
  else
    {
      sprintf (idbuf, ""%%anon%u"", id);
",unused,binutils-binutils2Fprdbg.c
"  if (! append_type (info, tag))
    return FALSE;
  if (name != NULL && kind != DEBUG_KIND_ENUM)
    {
      sprintf (idbuf, "" /* id %u */"", id);
",1,unused,1643,unused,"  if (! append_type (info, tag))
    return FALSE;
  if (name != NULL && kind != DEBUG_KIND_ENUM)
    {
      sprintf (idbuf, "" /* id %u */"", id);
",unused,binutils-binutils2Fprdbg.c
"    name = tag;
  else
    {
      name = idbuf;
      sprintf (idbuf, ""%%anon%u"", id);
",1,unused,2037,unused,"    name = tag;
  else
    {
      name = idbuf;
      sprintf (idbuf, ""%%anon%u"", id);
",unused,binutils-binutils2Fprdbg.c
"  else
    {
      char idbuf[20];

      sprintf (idbuf, ""%%anon%u"", id);
",1,unused,2134,unused,"  else
    {
      char idbuf[20];

      sprintf (idbuf, ""%%anon%u"", id);
",unused,binutils-binutils2Fprdbg.c
"  len_class = strlen (info->stack->next->type);
  full_name = (char *) xmalloc (len_var + len_class + 3);
  if (! full_name)
    return FALSE;
  sprintf (full_name, ""%s::%s"", info->stack->next->type, name);
",1,unused,2187,unused,"  len_class = strlen (info->stack->next->type);
  full_name = (char *) xmalloc (len_var + len_class + 3);
  if (! full_name)
    return FALSE;
  sprintf (full_name, ""%s::%s"", info->stack->next->type, name);
",unused,binutils-binutils2Fprdbg.c
"  if (name != NULL)
    tag = name;
  else
    {
      sprintf (idbuf, ""%%anon%u"", id);
",1,unused,2490,unused,"  if (name != NULL)
    tag = name;
  else
    {
      sprintf (idbuf, ""%%anon%u"", id);
",unused,binutils-binutils2Fprdbg.c
"
  ret = buf[buf_pos++].place;
  buf_pos %= ARRAY_SIZE (buf);

  sprintf (fmt, ""%%%s%s"", BFD_VMA_FMT, fmtch);
",1,unused,349,unused,"
  ret = buf[buf_pos++].place;
  buf_pos %= ARRAY_SIZE (buf);

  sprintf (fmt, ""%%%s%s"", BFD_VMA_FMT, fmtch);
",unused,binutils-binutils2Freadelf.c
"			       && psym->st_shndx == SHN_IA_64_VMS_SYMVEC)
			sec_name = ""VMS_SYMVEC"";
		      else
			{
			  sprintf (name_buf, ""<section 0x%x>"",
",1,unused,1708,unused,"			       && psym->st_shndx == SHN_IA_64_VMS_SYMVEC)
			sec_name = ""VMS_SYMVEC"";
		      else
			{
			  sprintf (name_buf, ""<section 0x%x>"",
",unused,binutils-binutils2Freadelf.c
"  switch (e_flags & EF_ARC_MACH_MSK)
    {
      /* We only expect these to occur for EM_ARC_COMPACT2.  */
    case EF_ARC_CPU_ARCV2EM:
      strcat (buf, "", ARC EM"");
",1,unused,2531,unused,"  switch (e_flags & EF_ARC_MACH_MSK)
    {
      /* We only expect these to occur for EM_ARC_COMPACT2.  */
    case EF_ARC_CPU_ARCV2EM:
      strcat (buf, "", ARC EM"");
",unused,binutils-binutils2Freadelf.c
"    case EF_ARC_CPU_ARCV2EM:
      strcat (buf, "", ARC EM"");
      break;
    case EF_ARC_CPU_ARCV2HS:
      strcat (buf, "", ARC HS"");
",1,unused,2534,unused,"    case EF_ARC_CPU_ARCV2EM:
      strcat (buf, "", ARC EM"");
      break;
    case EF_ARC_CPU_ARCV2HS:
      strcat (buf, "", ARC HS"");
",unused,binutils-binutils2Freadelf.c
"      break;

      /* We only expect these to occur for EM_ARC_COMPACT.  */
    case E_ARC_MACH_ARC600:
      strcat (buf, "", ARC600"");
",1,unused,2539,unused,"      break;

      /* We only expect these to occur for EM_ARC_COMPACT.  */
    case E_ARC_MACH_ARC600:
      strcat (buf, "", ARC600"");
",unused,binutils-binutils2Freadelf.c
"    case E_ARC_MACH_ARC600:
      strcat (buf, "", ARC600"");
      break;
    case E_ARC_MACH_ARC601:
      strcat (buf, "", ARC601"");
",1,unused,2542,unused,"    case E_ARC_MACH_ARC600:
      strcat (buf, "", ARC600"");
      break;
    case E_ARC_MACH_ARC601:
      strcat (buf, "", ARC601"");
",unused,binutils-binutils2Freadelf.c
"    case E_ARC_MACH_ARC601:
      strcat (buf, "", ARC601"");
      break;
    case E_ARC_MACH_ARC700:
      strcat (buf, "", ARC700"");
",1,unused,2545,unused,"    case E_ARC_MACH_ARC601:
      strcat (buf, "", ARC601"");
      break;
    case E_ARC_MACH_ARC700:
      strcat (buf, "", ARC700"");
",unused,binutils-binutils2Freadelf.c
"         readelf, or (c) An ELF built with non-GNU compiler that does not
         set the architecture in the e_flags.  */
    default:
      if (e_machine == EM_ARC_COMPACT)
        strcat (buf, "", Unknown ARCompact"");
",1,unused,2554,unused,"         readelf, or (c) An ELF built with non-GNU compiler that does not
         set the architecture in the e_flags.  */
    default:
      if (e_machine == EM_ARC_COMPACT)
        strcat (buf, "", Unknown ARCompact"");
",unused,binutils-binutils2Freadelf.c
"    default:
      if (e_machine == EM_ARC_COMPACT)
        strcat (buf, "", Unknown ARCompact"");
      else
        strcat (buf, "", Unknown ARC"");
",1,unused,2556,unused,"    default:
      if (e_machine == EM_ARC_COMPACT)
        strcat (buf, "", Unknown ARCompact"");
      else
        strcat (buf, "", Unknown ARC"");
",unused,binutils-binutils2Freadelf.c
"
  switch (e_flags & EF_ARC_OSABI_MSK)
    {
    case E_ARC_OSABI_ORIG:
      strcat (buf, "", (ABI:legacy)"");
",1,unused,2563,unused,"
  switch (e_flags & EF_ARC_OSABI_MSK)
    {
    case E_ARC_OSABI_ORIG:
      strcat (buf, "", (ABI:legacy)"");
",unused,binutils-binutils2Freadelf.c
"    case E_ARC_OSABI_ORIG:
      strcat (buf, "", (ABI:legacy)"");
      break;
    case E_ARC_OSABI_V2:
      strcat (buf, "", (ABI:v2)"");
",1,unused,2566,unused,"    case E_ARC_OSABI_ORIG:
      strcat (buf, "", (ABI:legacy)"");
      break;
    case E_ARC_OSABI_V2:
      strcat (buf, "", (ABI:v2)"");
",unused,binutils-binutils2Freadelf.c
"      strcat (buf, "", (ABI:v2)"");
      break;
      /* Only upstream 3.9+ kernels will support ARCv2 ISA.  */
    case E_ARC_OSABI_V3:
      strcat (buf, "", v3 no-legacy-syscalls ABI"");
",1,unused,2570,unused,"      strcat (buf, "", (ABI:v2)"");
      break;
      /* Only upstream 3.9+ kernels will support ARCv2 ISA.  */
    case E_ARC_OSABI_V3:
      strcat (buf, "", v3 no-legacy-syscalls ABI"");
",unused,binutils-binutils2Freadelf.c
"    case E_ARC_OSABI_V3:
      strcat (buf, "", v3 no-legacy-syscalls ABI"");
      break;
    case E_ARC_OSABI_V4:
      strcat (buf, "", v4 ABI"");
",1,unused,2573,unused,"    case E_ARC_OSABI_V3:
      strcat (buf, "", v3 no-legacy-syscalls ABI"");
      break;
    case E_ARC_OSABI_V4:
      strcat (buf, "", v4 ABI"");
",unused,binutils-binutils2Freadelf.c
"    case E_ARC_OSABI_V4:
      strcat (buf, "", v4 ABI"");
      break;
    default:
      strcat (buf, "", unrecognised ARC OSABI flag"");
",1,unused,2576,unused,"    case E_ARC_OSABI_V4:
      strcat (buf, "", v4 ABI"");
      break;
    default:
      strcat (buf, "", unrecognised ARC OSABI flag"");
",unused,binutils-binutils2Freadelf.c
"
  /* Handle ""generic"" ARM flags.  */
  if (e_flags & EF_ARM_RELEXEC)
    {
      strcat (buf, "", relocatable executable"");
",1,unused,2593,unused,"
  /* Handle ""generic"" ARM flags.  */
  if (e_flags & EF_ARM_RELEXEC)
    {
      strcat (buf, "", relocatable executable"");
",unused,binutils-binutils2Freadelf.c
"    }

  if (e_flags & EF_ARM_PIC)
    {
      strcat (buf, "", position independent"");
",1,unused,2599,unused,"    }

  if (e_flags & EF_ARM_PIC)
    {
      strcat (buf, "", position independent"");
",unused,binutils-binutils2Freadelf.c
"  /* Now handle EABI specific flags.  */
  switch (eabi)
    {
    default:
      strcat (buf, "", <unrecognized EABI>"");
",1,unused,2607,unused,"  /* Now handle EABI specific flags.  */
  switch (eabi)
    {
    default:
      strcat (buf, "", <unrecognized EABI>"");
",unused,binutils-binutils2Freadelf.c
"	unknown = TRUE;
      break;

    case EF_ARM_EABI_VER1:
      strcat (buf, "", Version1 EABI"");
",1,unused,2613,unused,"	unknown = TRUE;
      break;

    case EF_ARM_EABI_VER1:
      strcat (buf, "", Version1 EABI"");
",unused,binutils-binutils2Freadelf.c
"
	  switch (flag)
	    {
	    case EF_ARM_SYMSARESORTED: /* Conflicts with EF_ARM_INTERWORK.  */
	      strcat (buf, "", sorted symbol tables"");
",1,unused,2625,unused,"
	  switch (flag)
	    {
	    case EF_ARM_SYMSARESORTED: /* Conflicts with EF_ARM_INTERWORK.  */
	      strcat (buf, "", sorted symbol tables"");
",unused,binutils-binutils2Freadelf.c
"	}
      break;

    case EF_ARM_EABI_VER2:
      strcat (buf, "", Version2 EABI"");
",1,unused,2636,unused,"	}
      break;

    case EF_ARM_EABI_VER2:
      strcat (buf, "", Version2 EABI"");
",unused,binutils-binutils2Freadelf.c
"
	  switch (flag)
	    {
	    case EF_ARM_SYMSARESORTED: /* Conflicts with EF_ARM_INTERWORK.  */
	      strcat (buf, "", sorted symbol tables"");
",1,unused,2648,unused,"
	  switch (flag)
	    {
	    case EF_ARM_SYMSARESORTED: /* Conflicts with EF_ARM_INTERWORK.  */
	      strcat (buf, "", sorted symbol tables"");
",unused,binutils-binutils2Freadelf.c
"	      strcat (buf, "", sorted symbol tables"");
	      break;

	    case EF_ARM_DYNSYMSUSESEGIDX:
	      strcat (buf, "", dynamic symbols use segment index"");
",1,unused,2652,unused,"	      strcat (buf, "", sorted symbol tables"");
	      break;

	    case EF_ARM_DYNSYMSUSESEGIDX:
	      strcat (buf, "", dynamic symbols use segment index"");
",unused,binutils-binutils2Freadelf.c
"	      strcat (buf, "", dynamic symbols use segment index"");
	      break;

	    case EF_ARM_MAPSYMSFIRST:
	      strcat (buf, "", mapping symbols precede others"");
",1,unused,2656,unused,"	      strcat (buf, "", dynamic symbols use segment index"");
	      break;

	    case EF_ARM_MAPSYMSFIRST:
	      strcat (buf, "", mapping symbols precede others"");
",unused,binutils-binutils2Freadelf.c
"	}
      break;

    case EF_ARM_EABI_VER3:
      strcat (buf, "", Version3 EABI"");
",1,unused,2667,unused,"	}
      break;

    case EF_ARM_EABI_VER3:
      strcat (buf, "", Version3 EABI"");
",unused,binutils-binutils2Freadelf.c
"      strcat (buf, "", Version3 EABI"");
      break;

    case EF_ARM_EABI_VER4:
      strcat (buf, "", Version4 EABI"");
",1,unused,2671,unused,"      strcat (buf, "", Version3 EABI"");
      break;

    case EF_ARM_EABI_VER4:
      strcat (buf, "", Version4 EABI"");
",unused,binutils-binutils2Freadelf.c
"
	  switch (flag)
	    {
	    case EF_ARM_BE8:
	      strcat (buf, "", BE8"");
",1,unused,2683,unused,"
	  switch (flag)
	    {
	    case EF_ARM_BE8:
	      strcat (buf, "", BE8"");
",unused,binutils-binutils2Freadelf.c
"	      strcat (buf, "", BE8"");
	      break;

	    case EF_ARM_LE8:
	      strcat (buf, "", LE8"");
",1,unused,2687,unused,"	      strcat (buf, "", BE8"");
	      break;

	    case EF_ARM_LE8:
	      strcat (buf, "", LE8"");
",unused,binutils-binutils2Freadelf.c
"	}
      break;

    case EF_ARM_EABI_VER5:
      strcat (buf, "", Version5 EABI"");
",1,unused,2698,unused,"	}
      break;

    case EF_ARM_EABI_VER5:
      strcat (buf, "", Version5 EABI"");
",unused,binutils-binutils2Freadelf.c
"
	  switch (flag)
	    {
	    case EF_ARM_BE8:
	      strcat (buf, "", BE8"");
",1,unused,2710,unused,"
	  switch (flag)
	    {
	    case EF_ARM_BE8:
	      strcat (buf, "", BE8"");
",unused,binutils-binutils2Freadelf.c
"	      strcat (buf, "", BE8"");
	      break;

	    case EF_ARM_LE8:
	      strcat (buf, "", LE8"");
",1,unused,2714,unused,"	      strcat (buf, "", BE8"");
	      break;

	    case EF_ARM_LE8:
	      strcat (buf, "", LE8"");
",unused,binutils-binutils2Freadelf.c
"	      strcat (buf, "", LE8"");
	      break;

	    case EF_ARM_ABI_FLOAT_SOFT: /* Conflicts with EF_ARM_SOFT_FLOAT.  */
	      strcat (buf, "", soft-float ABI"");
",1,unused,2718,unused,"	      strcat (buf, "", LE8"");
	      break;

	    case EF_ARM_ABI_FLOAT_SOFT: /* Conflicts with EF_ARM_SOFT_FLOAT.  */
	      strcat (buf, "", soft-float ABI"");
",unused,binutils-binutils2Freadelf.c
"	      strcat (buf, "", soft-float ABI"");
	      break;

	    case EF_ARM_ABI_FLOAT_HARD: /* Conflicts with EF_ARM_VFP_FLOAT.  */
	      strcat (buf, "", hard-float ABI"");
",1,unused,2722,unused,"	      strcat (buf, "", soft-float ABI"");
	      break;

	    case EF_ARM_ABI_FLOAT_HARD: /* Conflicts with EF_ARM_VFP_FLOAT.  */
	      strcat (buf, "", hard-float ABI"");
",unused,binutils-binutils2Freadelf.c
"	}
      break;

    case EF_ARM_EABI_UNKNOWN:
      strcat (buf, "", GNU EABI"");
",1,unused,2733,unused,"	}
      break;

    case EF_ARM_EABI_UNKNOWN:
      strcat (buf, "", GNU EABI"");
",unused,binutils-binutils2Freadelf.c
"
	  switch (flag)
	    {
	    case EF_ARM_INTERWORK:
	      strcat (buf, "", interworking enabled"");
",1,unused,2745,unused,"
	  switch (flag)
	    {
	    case EF_ARM_INTERWORK:
	      strcat (buf, "", interworking enabled"");
",unused,binutils-binutils2Freadelf.c
"	      strcat (buf, "", interworking enabled"");
	      break;

	    case EF_ARM_APCS_26:
	      strcat (buf, "", uses APCS/26"");
",1,unused,2749,unused,"	      strcat (buf, "", interworking enabled"");
	      break;

	    case EF_ARM_APCS_26:
	      strcat (buf, "", uses APCS/26"");
",unused,binutils-binutils2Freadelf.c
"	      strcat (buf, "", uses APCS/26"");
	      break;

	    case EF_ARM_APCS_FLOAT:
	      strcat (buf, "", uses APCS/float"");
",1,unused,2753,unused,"	      strcat (buf, "", uses APCS/26"");
	      break;

	    case EF_ARM_APCS_FLOAT:
	      strcat (buf, "", uses APCS/float"");
",unused,binutils-binutils2Freadelf.c
"	      strcat (buf, "", uses APCS/float"");
	      break;

	    case EF_ARM_PIC:
	      strcat (buf, "", position independent"");
",1,unused,2757,unused,"	      strcat (buf, "", uses APCS/float"");
	      break;

	    case EF_ARM_PIC:
	      strcat (buf, "", position independent"");
",unused,binutils-binutils2Freadelf.c
"	      strcat (buf, "", position independent"");
	      break;

	    case EF_ARM_ALIGN8:
	      strcat (buf, "", 8 bit structure alignment"");
",1,unused,2761,unused,"	      strcat (buf, "", position independent"");
	      break;

	    case EF_ARM_ALIGN8:
	      strcat (buf, "", 8 bit structure alignment"");
",unused,binutils-binutils2Freadelf.c
"	      strcat (buf, "", 8 bit structure alignment"");
	      break;

	    case EF_ARM_NEW_ABI:
	      strcat (buf, "", uses new ABI"");
",1,unused,2765,unused,"	      strcat (buf, "", 8 bit structure alignment"");
	      break;

	    case EF_ARM_NEW_ABI:
	      strcat (buf, "", uses new ABI"");
",unused,binutils-binutils2Freadelf.c
"	      strcat (buf, "", uses new ABI"");
	      break;

	    case EF_ARM_OLD_ABI:
	      strcat (buf, "", uses old ABI"");
",1,unused,2769,unused,"	      strcat (buf, "", uses new ABI"");
	      break;

	    case EF_ARM_OLD_ABI:
	      strcat (buf, "", uses old ABI"");
",unused,binutils-binutils2Freadelf.c
"	      strcat (buf, "", uses old ABI"");
	      break;

	    case EF_ARM_SOFT_FLOAT:
	      strcat (buf, "", software FP"");
",1,unused,2773,unused,"	      strcat (buf, "", uses old ABI"");
	      break;

	    case EF_ARM_SOFT_FLOAT:
	      strcat (buf, "", software FP"");
",unused,binutils-binutils2Freadelf.c
"	      strcat (buf, "", software FP"");
	      break;

	    case EF_ARM_VFP_FLOAT:
	      strcat (buf, "", VFP"");
",1,unused,2777,unused,"	      strcat (buf, "", software FP"");
	      break;

	    case EF_ARM_VFP_FLOAT:
	      strcat (buf, "", VFP"");
",unused,binutils-binutils2Freadelf.c
"	      strcat (buf, "", VFP"");
	      break;

	    case EF_ARM_MAVERICK_FLOAT:
	      strcat (buf, "", Maverick FP"");
",1,unused,2781,unused,"	      strcat (buf, "", VFP"");
	      break;

	    case EF_ARM_MAVERICK_FLOAT:
	      strcat (buf, "", Maverick FP"");
",unused,binutils-binutils2Freadelf.c
"	}
    }

  if (unknown)
    strcat (buf,_("", <unknown>""));
",1,unused,2792,unused,"	}
    }

  if (unknown)
    strcat (buf,_("", <unknown>""));
",unused,binutils-binutils2Freadelf.c
"          break;

	case EM_BLACKFIN:
	  if (e_flags & EF_BFIN_PIC)
	    strcat (buf, "", PIC"");
",1,unused,3098,unused,"          break;

	case EM_BLACKFIN:
	  if (e_flags & EF_BFIN_PIC)
	    strcat (buf, "", PIC"");
",unused,binutils-binutils2Freadelf.c
"	  if (e_flags & EF_BFIN_PIC)
	    strcat (buf, "", PIC"");

	  if (e_flags & EF_BFIN_FDPIC)
	    strcat (buf, "", FDPIC"");
",1,unused,3101,unused,"	  if (e_flags & EF_BFIN_PIC)
	    strcat (buf, "", PIC"");

	  if (e_flags & EF_BFIN_FDPIC)
	    strcat (buf, "", FDPIC"");
",unused,binutils-binutils2Freadelf.c
"	  if (e_flags & EF_BFIN_FDPIC)
	    strcat (buf, "", FDPIC"");

	  if (e_flags & EF_BFIN_CODE_IN_L1)
	    strcat (buf, "", code in L1"");
",1,unused,3104,unused,"	  if (e_flags & EF_BFIN_FDPIC)
	    strcat (buf, "", FDPIC"");

	  if (e_flags & EF_BFIN_CODE_IN_L1)
	    strcat (buf, "", code in L1"");
",unused,binutils-binutils2Freadelf.c
"	  if (e_flags & EF_BFIN_CODE_IN_L1)
	    strcat (buf, "", code in L1"");

	  if (e_flags & EF_BFIN_DATA_IN_L1)
	    strcat (buf, "", data in L1"");
",1,unused,3107,unused,"	  if (e_flags & EF_BFIN_CODE_IN_L1)
	    strcat (buf, "", code in L1"");

	  if (e_flags & EF_BFIN_DATA_IN_L1)
	    strcat (buf, "", data in L1"");
",unused,binutils-binutils2Freadelf.c
"	    case EF_FRV_CPU_GENERIC:
	      break;

	    default:
	      strcat (buf, "", fr???"");
",1,unused,3118,unused,"	    case EF_FRV_CPU_GENERIC:
	      break;

	    default:
	      strcat (buf, "", fr???"");
",unused,binutils-binutils2Freadelf.c
"	      strcat (buf, "", fr???"");
	      break;

	    case EF_FRV_CPU_FR300:
	      strcat (buf, "", fr300"");
",1,unused,3122,unused,"	      strcat (buf, "", fr???"");
	      break;

	    case EF_FRV_CPU_FR300:
	      strcat (buf, "", fr300"");
",unused,binutils-binutils2Freadelf.c
"	      strcat (buf, "", fr300"");
	      break;

	    case EF_FRV_CPU_FR400:
	      strcat (buf, "", fr400"");
",1,unused,3126,unused,"	      strcat (buf, "", fr300"");
	      break;

	    case EF_FRV_CPU_FR400:
	      strcat (buf, "", fr400"");
",unused,binutils-binutils2Freadelf.c
"	    case EF_FRV_CPU_FR400:
	      strcat (buf, "", fr400"");
	      break;
	    case EF_FRV_CPU_FR405:
	      strcat (buf, "", fr405"");
",1,unused,3129,unused,"	    case EF_FRV_CPU_FR400:
	      strcat (buf, "", fr400"");
	      break;
	    case EF_FRV_CPU_FR405:
	      strcat (buf, "", fr405"");
",unused,binutils-binutils2Freadelf.c
"	      strcat (buf, "", fr405"");
	      break;

	    case EF_FRV_CPU_FR450:
	      strcat (buf, "", fr450"");
",1,unused,3133,unused,"	      strcat (buf, "", fr405"");
	      break;

	    case EF_FRV_CPU_FR450:
	      strcat (buf, "", fr450"");
",unused,binutils-binutils2Freadelf.c
"	      strcat (buf, "", fr450"");
	      break;

	    case EF_FRV_CPU_FR500:
	      strcat (buf, "", fr500"");
",1,unused,3137,unused,"	      strcat (buf, "", fr450"");
	      break;

	    case EF_FRV_CPU_FR500:
	      strcat (buf, "", fr500"");
",unused,binutils-binutils2Freadelf.c
"	    case EF_FRV_CPU_FR500:
	      strcat (buf, "", fr500"");
	      break;
	    case EF_FRV_CPU_FR550:
	      strcat (buf, "", fr550"");
",1,unused,3140,unused,"	    case EF_FRV_CPU_FR500:
	      strcat (buf, "", fr500"");
	      break;
	    case EF_FRV_CPU_FR550:
	      strcat (buf, "", fr550"");
",unused,binutils-binutils2Freadelf.c
"	      strcat (buf, "", fr550"");
	      break;

	    case EF_FRV_CPU_SIMPLE:
	      strcat (buf, "", simple"");
",1,unused,3144,unused,"	      strcat (buf, "", fr550"");
	      break;

	    case EF_FRV_CPU_SIMPLE:
	      strcat (buf, "", simple"");
",unused,binutils-binutils2Freadelf.c
"	    case EF_FRV_CPU_SIMPLE:
	      strcat (buf, "", simple"");
	      break;
	    case EF_FRV_CPU_TOMCAT:
	      strcat (buf, "", tomcat"");
",1,unused,3147,unused,"	    case EF_FRV_CPU_SIMPLE:
	      strcat (buf, "", simple"");
	      break;
	    case EF_FRV_CPU_TOMCAT:
	      strcat (buf, "", tomcat"");
",unused,binutils-binutils2Freadelf.c
"	  break;

	case EM_68K:
	  if ((e_flags & EF_M68K_ARCH_MASK) == EF_M68K_M68000)
	    strcat (buf, "", m68000"");
",1,unused,3154,unused,"	  break;

	case EM_68K:
	  if ((e_flags & EF_M68K_ARCH_MASK) == EF_M68K_M68000)
	    strcat (buf, "", m68000"");
",unused,binutils-binutils2Freadelf.c
"	case EM_68K:
	  if ((e_flags & EF_M68K_ARCH_MASK) == EF_M68K_M68000)
	    strcat (buf, "", m68000"");
	  else if ((e_flags & EF_M68K_ARCH_MASK) == EF_M68K_CPU32)
	    strcat (buf, "", cpu32"");
",1,unused,3156,unused,"	case EM_68K:
	  if ((e_flags & EF_M68K_ARCH_MASK) == EF_M68K_M68000)
	    strcat (buf, "", m68000"");
	  else if ((e_flags & EF_M68K_ARCH_MASK) == EF_M68K_CPU32)
	    strcat (buf, "", cpu32"");
",unused,binutils-binutils2Freadelf.c
"	    strcat (buf, "", m68000"");
	  else if ((e_flags & EF_M68K_ARCH_MASK) == EF_M68K_CPU32)
	    strcat (buf, "", cpu32"");
	  else if ((e_flags & EF_M68K_ARCH_MASK) == EF_M68K_FIDO)
	    strcat (buf, "", fido_a"");
",1,unused,3158,unused,"	    strcat (buf, "", m68000"");
	  else if ((e_flags & EF_M68K_ARCH_MASK) == EF_M68K_CPU32)
	    strcat (buf, "", cpu32"");
	  else if ((e_flags & EF_M68K_ARCH_MASK) == EF_M68K_FIDO)
	    strcat (buf, "", fido_a"");
",unused,binutils-binutils2Freadelf.c
"		  isa = ""C"";
		  additional = "", nodiv"";
		  break;
		}
	      strcat (buf, "", cf, isa "");
",1,unused,3192,unused,"		  isa = ""C"";
		  additional = "", nodiv"";
		  break;
		}
	      strcat (buf, "", cf, isa "");
",unused,binutils-binutils2Freadelf.c
"		  additional = "", nodiv"";
		  break;
		}
	      strcat (buf, "", cf, isa "");
	      strcat (buf, isa);
",1,unused,3193,unused,"		  additional = "", nodiv"";
		  break;
		}
	      strcat (buf, "", cf, isa "");
	      strcat (buf, isa);
",unused,binutils-binutils2Freadelf.c
"		}
	      strcat (buf, "", cf, isa "");
	      strcat (buf, isa);
	      if (additional)
		strcat (buf, additional);
",1,unused,3195,unused,"		}
	      strcat (buf, "", cf, isa "");
	      strcat (buf, isa);
	      if (additional)
		strcat (buf, additional);
",unused,binutils-binutils2Freadelf.c
"	      strcat (buf, isa);
	      if (additional)
		strcat (buf, additional);
	      if (e_flags & EF_M68K_CF_FLOAT)
		strcat (buf, "", float"");
",1,unused,3197,unused,"	      strcat (buf, isa);
	      if (additional)
		strcat (buf, additional);
	      if (e_flags & EF_M68K_CF_FLOAT)
		strcat (buf, "", float"");
",unused,binutils-binutils2Freadelf.c
"		  break;
		}
	      if (mac)
		{
		  strcat (buf, "", "");
",1,unused,3215,unused,"		  break;
		}
	      if (mac)
		{
		  strcat (buf, "", "");
",unused,binutils-binutils2Freadelf.c
"		}
	      if (mac)
		{
		  strcat (buf, "", "");
		  strcat (buf, mac);
",1,unused,3216,unused,"		}
	      if (mac)
		{
		  strcat (buf, "", "");
		  strcat (buf, mac);
",unused,binutils-binutils2Freadelf.c
"
	case EM_CYGNUS_MEP:
	  switch (e_flags & EF_MEP_CPU_MASK)
	    {
	    case EF_MEP_CPU_MEP: strcat (buf, "", generic MeP""); break;
",1,unused,3224,unused,"
	case EM_CYGNUS_MEP:
	  switch (e_flags & EF_MEP_CPU_MASK)
	    {
	    case EF_MEP_CPU_MEP: strcat (buf, "", generic MeP""); break;
",unused,binutils-binutils2Freadelf.c
"	case EM_CYGNUS_MEP:
	  switch (e_flags & EF_MEP_CPU_MASK)
	    {
	    case EF_MEP_CPU_MEP: strcat (buf, "", generic MeP""); break;
	    case EF_MEP_CPU_C2: strcat (buf, "", MeP C2""); break;
",1,unused,3225,unused,"	case EM_CYGNUS_MEP:
	  switch (e_flags & EF_MEP_CPU_MASK)
	    {
	    case EF_MEP_CPU_MEP: strcat (buf, "", generic MeP""); break;
	    case EF_MEP_CPU_C2: strcat (buf, "", MeP C2""); break;
",unused,binutils-binutils2Freadelf.c
"	  switch (e_flags & EF_MEP_CPU_MASK)
	    {
	    case EF_MEP_CPU_MEP: strcat (buf, "", generic MeP""); break;
	    case EF_MEP_CPU_C2: strcat (buf, "", MeP C2""); break;
	    case EF_MEP_CPU_C3: strcat (buf, "", MeP C3""); break;
",1,unused,3226,unused,"	  switch (e_flags & EF_MEP_CPU_MASK)
	    {
	    case EF_MEP_CPU_MEP: strcat (buf, "", generic MeP""); break;
	    case EF_MEP_CPU_C2: strcat (buf, "", MeP C2""); break;
	    case EF_MEP_CPU_C3: strcat (buf, "", MeP C3""); break;
",unused,binutils-binutils2Freadelf.c
"	    {
	    case EF_MEP_CPU_MEP: strcat (buf, "", generic MeP""); break;
	    case EF_MEP_CPU_C2: strcat (buf, "", MeP C2""); break;
	    case EF_MEP_CPU_C3: strcat (buf, "", MeP C3""); break;
	    case EF_MEP_CPU_C4: strcat (buf, "", MeP C4""); break;
",1,unused,3227,unused,"	    {
	    case EF_MEP_CPU_MEP: strcat (buf, "", generic MeP""); break;
	    case EF_MEP_CPU_C2: strcat (buf, "", MeP C2""); break;
	    case EF_MEP_CPU_C3: strcat (buf, "", MeP C3""); break;
	    case EF_MEP_CPU_C4: strcat (buf, "", MeP C4""); break;
",unused,binutils-binutils2Freadelf.c
"	    case EF_MEP_CPU_MEP: strcat (buf, "", generic MeP""); break;
	    case EF_MEP_CPU_C2: strcat (buf, "", MeP C2""); break;
	    case EF_MEP_CPU_C3: strcat (buf, "", MeP C3""); break;
	    case EF_MEP_CPU_C4: strcat (buf, "", MeP C4""); break;
	    case EF_MEP_CPU_C5: strcat (buf, "", MeP C5""); break;
",1,unused,3228,unused,"	    case EF_MEP_CPU_MEP: strcat (buf, "", generic MeP""); break;
	    case EF_MEP_CPU_C2: strcat (buf, "", MeP C2""); break;
	    case EF_MEP_CPU_C3: strcat (buf, "", MeP C3""); break;
	    case EF_MEP_CPU_C4: strcat (buf, "", MeP C4""); break;
	    case EF_MEP_CPU_C5: strcat (buf, "", MeP C5""); break;
",unused,binutils-binutils2Freadelf.c
"	    case EF_MEP_CPU_C2: strcat (buf, "", MeP C2""); break;
	    case EF_MEP_CPU_C3: strcat (buf, "", MeP C3""); break;
	    case EF_MEP_CPU_C4: strcat (buf, "", MeP C4""); break;
	    case EF_MEP_CPU_C5: strcat (buf, "", MeP C5""); break;
	    case EF_MEP_CPU_H1: strcat (buf, "", MeP H1""); break;
",1,unused,3229,unused,"	    case EF_MEP_CPU_C2: strcat (buf, "", MeP C2""); break;
	    case EF_MEP_CPU_C3: strcat (buf, "", MeP C3""); break;
	    case EF_MEP_CPU_C4: strcat (buf, "", MeP C4""); break;
	    case EF_MEP_CPU_C5: strcat (buf, "", MeP C5""); break;
	    case EF_MEP_CPU_H1: strcat (buf, "", MeP H1""); break;
",unused,binutils-binutils2Freadelf.c
"	    case EF_MEP_CPU_C3: strcat (buf, "", MeP C3""); break;
	    case EF_MEP_CPU_C4: strcat (buf, "", MeP C4""); break;
	    case EF_MEP_CPU_C5: strcat (buf, "", MeP C5""); break;
	    case EF_MEP_CPU_H1: strcat (buf, "", MeP H1""); break;
	    default: strcat (buf, _("", <unknown MeP cpu type>"")); break;
",1,unused,3230,unused,"	    case EF_MEP_CPU_C3: strcat (buf, "", MeP C3""); break;
	    case EF_MEP_CPU_C4: strcat (buf, "", MeP C4""); break;
	    case EF_MEP_CPU_C5: strcat (buf, "", MeP C5""); break;
	    case EF_MEP_CPU_H1: strcat (buf, "", MeP H1""); break;
	    default: strcat (buf, _("", <unknown MeP cpu type>"")); break;
",unused,binutils-binutils2Freadelf.c
"
	  switch (e_flags & EF_MEP_COP_MASK)
	    {
	    case EF_MEP_COP_NONE: break;
	    case EF_MEP_COP_AVC: strcat (buf, "", AVC coprocessor""); break;
",1,unused,3236,unused,"
	  switch (e_flags & EF_MEP_COP_MASK)
	    {
	    case EF_MEP_COP_NONE: break;
	    case EF_MEP_COP_AVC: strcat (buf, "", AVC coprocessor""); break;
",unused,binutils-binutils2Freadelf.c
"	  switch (e_flags & EF_MEP_COP_MASK)
	    {
	    case EF_MEP_COP_NONE: break;
	    case EF_MEP_COP_AVC: strcat (buf, "", AVC coprocessor""); break;
	    case EF_MEP_COP_AVC2: strcat (buf, "", AVC2 coprocessor""); break;
",1,unused,3237,unused,"	  switch (e_flags & EF_MEP_COP_MASK)
	    {
	    case EF_MEP_COP_NONE: break;
	    case EF_MEP_COP_AVC: strcat (buf, "", AVC coprocessor""); break;
	    case EF_MEP_COP_AVC2: strcat (buf, "", AVC2 coprocessor""); break;
",unused,binutils-binutils2Freadelf.c
"	    {
	    case EF_MEP_COP_NONE: break;
	    case EF_MEP_COP_AVC: strcat (buf, "", AVC coprocessor""); break;
	    case EF_MEP_COP_AVC2: strcat (buf, "", AVC2 coprocessor""); break;
	    case EF_MEP_COP_FMAX: strcat (buf, "", FMAX coprocessor""); break;
",1,unused,3238,unused,"	    {
	    case EF_MEP_COP_NONE: break;
	    case EF_MEP_COP_AVC: strcat (buf, "", AVC coprocessor""); break;
	    case EF_MEP_COP_AVC2: strcat (buf, "", AVC2 coprocessor""); break;
	    case EF_MEP_COP_FMAX: strcat (buf, "", FMAX coprocessor""); break;
",unused,binutils-binutils2Freadelf.c
"	    case EF_MEP_COP_NONE: break;
	    case EF_MEP_COP_AVC: strcat (buf, "", AVC coprocessor""); break;
	    case EF_MEP_COP_AVC2: strcat (buf, "", AVC2 coprocessor""); break;
	    case EF_MEP_COP_FMAX: strcat (buf, "", FMAX coprocessor""); break;
	    case EF_MEP_COP_IVC2: strcat (buf, "", IVC2 coprocessor""); break;
",1,unused,3239,unused,"	    case EF_MEP_COP_NONE: break;
	    case EF_MEP_COP_AVC: strcat (buf, "", AVC coprocessor""); break;
	    case EF_MEP_COP_AVC2: strcat (buf, "", AVC2 coprocessor""); break;
	    case EF_MEP_COP_FMAX: strcat (buf, "", FMAX coprocessor""); break;
	    case EF_MEP_COP_IVC2: strcat (buf, "", IVC2 coprocessor""); break;
",unused,binutils-binutils2Freadelf.c
"	    case EF_MEP_COP_AVC: strcat (buf, "", AVC coprocessor""); break;
	    case EF_MEP_COP_AVC2: strcat (buf, "", AVC2 coprocessor""); break;
	    case EF_MEP_COP_FMAX: strcat (buf, "", FMAX coprocessor""); break;
	    case EF_MEP_COP_IVC2: strcat (buf, "", IVC2 coprocessor""); break;
	    default: strcat (buf, _(""<unknown MeP copro type>"")); break;
",1,unused,3240,unused,"	    case EF_MEP_COP_AVC: strcat (buf, "", AVC coprocessor""); break;
	    case EF_MEP_COP_AVC2: strcat (buf, "", AVC2 coprocessor""); break;
	    case EF_MEP_COP_FMAX: strcat (buf, "", FMAX coprocessor""); break;
	    case EF_MEP_COP_IVC2: strcat (buf, "", IVC2 coprocessor""); break;
	    default: strcat (buf, _(""<unknown MeP copro type>"")); break;
",unused,binutils-binutils2Freadelf.c
"	    default: strcat (buf, _(""<unknown MeP copro type>"")); break;
	    }

	  if (e_flags & EF_MEP_LIBRARY)
	    strcat (buf, "", Built for Library"");
",1,unused,3244,unused,"	    default: strcat (buf, _(""<unknown MeP copro type>"")); break;
	    }

	  if (e_flags & EF_MEP_LIBRARY)
	    strcat (buf, "", Built for Library"");
",unused,binutils-binutils2Freadelf.c
"	  if (e_flags & EF_MEP_LIBRARY)
	    strcat (buf, "", Built for Library"");

	  if (e_flags & EF_MEP_INDEX_MASK)
	    sprintf (buf + strlen (buf), "", Configuration Index: %#x"",
",1,unused,3247,unused,"	  if (e_flags & EF_MEP_LIBRARY)
	    strcat (buf, "", Built for Library"");

	  if (e_flags & EF_MEP_INDEX_MASK)
	    sprintf (buf + strlen (buf), "", Configuration Index: %#x"",
",unused,binutils-binutils2Freadelf.c
"	    sprintf (buf + strlen (buf), "", Configuration Index: %#x"",
		     e_flags & EF_MEP_INDEX_MASK);

	  if (e_flags & ~ EF_MEP_ALL_FLAGS)
	    sprintf (buf + strlen (buf), _("", unknown flags bits: %#x""),
",1,unused,3251,unused,"	    sprintf (buf + strlen (buf), "", Configuration Index: %#x"",
		     e_flags & EF_MEP_INDEX_MASK);

	  if (e_flags & ~ EF_MEP_ALL_FLAGS)
	    sprintf (buf + strlen (buf), _("", unknown flags bits: %#x""),
",unused,binutils-binutils2Freadelf.c
"	  break;

	case EM_PPC:
	  if (e_flags & EF_PPC_EMB)
	    strcat (buf, "", emb"");
",1,unused,3257,unused,"	  break;

	case EM_PPC:
	  if (e_flags & EF_PPC_EMB)
	    strcat (buf, "", emb"");
",unused,binutils-binutils2Freadelf.c
"	  if (e_flags & EF_PPC_EMB)
	    strcat (buf, "", emb"");

	  if (e_flags & EF_PPC_RELOCATABLE)
	    strcat (buf, _("", relocatable""));
",1,unused,3260,unused,"	  if (e_flags & EF_PPC_EMB)
	    strcat (buf, "", emb"");

	  if (e_flags & EF_PPC_RELOCATABLE)
	    strcat (buf, _("", relocatable""));
",unused,binutils-binutils2Freadelf.c
"	  if (e_flags & EF_PPC_RELOCATABLE)
	    strcat (buf, _("", relocatable""));

	  if (e_flags & EF_PPC_RELOCATABLE_LIB)
	    strcat (buf, _("", relocatable-lib""));
",1,unused,3263,unused,"	  if (e_flags & EF_PPC_RELOCATABLE)
	    strcat (buf, _("", relocatable""));

	  if (e_flags & EF_PPC_RELOCATABLE_LIB)
	    strcat (buf, _("", relocatable-lib""));
",unused,binutils-binutils2Freadelf.c
"	    {
	      char abi[] = "", abiv0"";

	      abi[6] += e_flags & EF_PPC64_ABI;
	      strcat (buf, abi);
",1,unused,3272,unused,"	    {
	      char abi[] = "", abiv0"";

	      abi[6] += e_flags & EF_PPC64_ABI;
	      strcat (buf, abi);
",unused,binutils-binutils2Freadelf.c
"	  break;

	case EM_V800:
	  if ((e_flags & EF_RH850_ABI) == EF_RH850_ABI)
	    strcat (buf, "", RH850 ABI"");
",1,unused,3278,unused,"	  break;

	case EM_V800:
	  if ((e_flags & EF_RH850_ABI) == EF_RH850_ABI)
	    strcat (buf, "", RH850 ABI"");
",unused,binutils-binutils2Freadelf.c
"	  if ((e_flags & EF_RH850_ABI) == EF_RH850_ABI)
	    strcat (buf, "", RH850 ABI"");

	  if (e_flags & EF_V800_850E3)
	    strcat (buf, "", V3 architecture"");
",1,unused,3281,unused,"	  if ((e_flags & EF_RH850_ABI) == EF_RH850_ABI)
	    strcat (buf, "", RH850 ABI"");

	  if (e_flags & EF_V800_850E3)
	    strcat (buf, "", V3 architecture"");
",unused,binutils-binutils2Freadelf.c
"	  if (e_flags & EF_V800_850E3)
	    strcat (buf, "", V3 architecture"");

	  if ((e_flags & (EF_RH850_FPU_DOUBLE | EF_RH850_FPU_SINGLE)) == 0)
	    strcat (buf, "", FPU not used"");
",1,unused,3284,unused,"	  if (e_flags & EF_V800_850E3)
	    strcat (buf, "", V3 architecture"");

	  if ((e_flags & (EF_RH850_FPU_DOUBLE | EF_RH850_FPU_SINGLE)) == 0)
	    strcat (buf, "", FPU not used"");
",unused,binutils-binutils2Freadelf.c
"	  if ((e_flags & (EF_RH850_FPU_DOUBLE | EF_RH850_FPU_SINGLE)) == 0)
	    strcat (buf, "", FPU not used"");

	  if ((e_flags & (EF_RH850_REGMODE22 | EF_RH850_REGMODE32)) == 0)
	    strcat (buf, "", regmode: COMMON"");
",1,unused,3287,unused,"	  if ((e_flags & (EF_RH850_FPU_DOUBLE | EF_RH850_FPU_SINGLE)) == 0)
	    strcat (buf, "", FPU not used"");

	  if ((e_flags & (EF_RH850_REGMODE22 | EF_RH850_REGMODE32)) == 0)
	    strcat (buf, "", regmode: COMMON"");
",unused,binutils-binutils2Freadelf.c
"	  if ((e_flags & (EF_RH850_REGMODE22 | EF_RH850_REGMODE32)) == 0)
	    strcat (buf, "", regmode: COMMON"");

	  if ((e_flags & (EF_RH850_GP_FIX | EF_RH850_GP_NOFIX)) == 0)
	    strcat (buf, "", r4 not used"");
",1,unused,3290,unused,"	  if ((e_flags & (EF_RH850_REGMODE22 | EF_RH850_REGMODE32)) == 0)
	    strcat (buf, "", regmode: COMMON"");

	  if ((e_flags & (EF_RH850_GP_FIX | EF_RH850_GP_NOFIX)) == 0)
	    strcat (buf, "", r4 not used"");
",unused,binutils-binutils2Freadelf.c
"	  if ((e_flags & (EF_RH850_GP_FIX | EF_RH850_GP_NOFIX)) == 0)
	    strcat (buf, "", r4 not used"");

	  if ((e_flags & (EF_RH850_EP_FIX | EF_RH850_EP_NOFIX)) == 0)
	    strcat (buf, "", r30 not used"");
",1,unused,3293,unused,"	  if ((e_flags & (EF_RH850_GP_FIX | EF_RH850_GP_NOFIX)) == 0)
	    strcat (buf, "", r4 not used"");

	  if ((e_flags & (EF_RH850_EP_FIX | EF_RH850_EP_NOFIX)) == 0)
	    strcat (buf, "", r30 not used"");
",unused,binutils-binutils2Freadelf.c
"	  if ((e_flags & (EF_RH850_EP_FIX | EF_RH850_EP_NOFIX)) == 0)
	    strcat (buf, "", r30 not used"");

	  if ((e_flags & (EF_RH850_TP_FIX | EF_RH850_TP_NOFIX)) == 0)
	    strcat (buf, "", r5 not used"");
",1,unused,3296,unused,"	  if ((e_flags & (EF_RH850_EP_FIX | EF_RH850_EP_NOFIX)) == 0)
	    strcat (buf, "", r30 not used"");

	  if ((e_flags & (EF_RH850_TP_FIX | EF_RH850_TP_NOFIX)) == 0)
	    strcat (buf, "", r5 not used"");
",unused,binutils-binutils2Freadelf.c
"	  if ((e_flags & (EF_RH850_TP_FIX | EF_RH850_TP_NOFIX)) == 0)
	    strcat (buf, "", r5 not used"");

	  if ((e_flags & (EF_RH850_REG2_RESERVE | EF_RH850_REG2_NORESERVE)) == 0)
	    strcat (buf, "", r2 not used"");
",1,unused,3299,unused,"	  if ((e_flags & (EF_RH850_TP_FIX | EF_RH850_TP_NOFIX)) == 0)
	    strcat (buf, "", r5 not used"");

	  if ((e_flags & (EF_RH850_REG2_RESERVE | EF_RH850_REG2_NORESERVE)) == 0)
	    strcat (buf, "", r2 not used"");
",unused,binutils-binutils2Freadelf.c
"	  for (e_flags &= 0xFFFF; e_flags; e_flags &= ~ (e_flags & - e_flags))
	    {
	      switch (e_flags & - e_flags)
		{
		case EF_RH850_FPU_DOUBLE: strcat (buf, "", double precision FPU""); break;
",1,unused,3305,unused,"	  for (e_flags &= 0xFFFF; e_flags; e_flags &= ~ (e_flags & - e_flags))
	    {
	      switch (e_flags & - e_flags)
		{
		case EF_RH850_FPU_DOUBLE: strcat (buf, "", double precision FPU""); break;
",unused,binutils-binutils2Freadelf.c
"	    {
	      switch (e_flags & - e_flags)
		{
		case EF_RH850_FPU_DOUBLE: strcat (buf, "", double precision FPU""); break;
		case EF_RH850_FPU_SINGLE: strcat (buf, "", single precision FPU""); break;
",1,unused,3306,unused,"	    {
	      switch (e_flags & - e_flags)
		{
		case EF_RH850_FPU_DOUBLE: strcat (buf, "", double precision FPU""); break;
		case EF_RH850_FPU_SINGLE: strcat (buf, "", single precision FPU""); break;
",unused,binutils-binutils2Freadelf.c
"	      switch (e_flags & - e_flags)
		{
		case EF_RH850_FPU_DOUBLE: strcat (buf, "", double precision FPU""); break;
		case EF_RH850_FPU_SINGLE: strcat (buf, "", single precision FPU""); break;
		case EF_RH850_REGMODE22: strcat (buf, "", regmode:22""); break;
",1,unused,3307,unused,"	      switch (e_flags & - e_flags)
		{
		case EF_RH850_FPU_DOUBLE: strcat (buf, "", double precision FPU""); break;
		case EF_RH850_FPU_SINGLE: strcat (buf, "", single precision FPU""); break;
		case EF_RH850_REGMODE22: strcat (buf, "", regmode:22""); break;
",unused,binutils-binutils2Freadelf.c
"		{
		case EF_RH850_FPU_DOUBLE: strcat (buf, "", double precision FPU""); break;
		case EF_RH850_FPU_SINGLE: strcat (buf, "", single precision FPU""); break;
		case EF_RH850_REGMODE22: strcat (buf, "", regmode:22""); break;
		case EF_RH850_REGMODE32: strcat (buf, "", regmode:23""); break;
",1,unused,3308,unused,"		{
		case EF_RH850_FPU_DOUBLE: strcat (buf, "", double precision FPU""); break;
		case EF_RH850_FPU_SINGLE: strcat (buf, "", single precision FPU""); break;
		case EF_RH850_REGMODE22: strcat (buf, "", regmode:22""); break;
		case EF_RH850_REGMODE32: strcat (buf, "", regmode:23""); break;
",unused,binutils-binutils2Freadelf.c
"		case EF_RH850_FPU_DOUBLE: strcat (buf, "", double precision FPU""); break;
		case EF_RH850_FPU_SINGLE: strcat (buf, "", single precision FPU""); break;
		case EF_RH850_REGMODE22: strcat (buf, "", regmode:22""); break;
		case EF_RH850_REGMODE32: strcat (buf, "", regmode:23""); break;
		case EF_RH850_GP_FIX: strcat (buf, "", r4 fixed""); break;
",1,unused,3309,unused,"		case EF_RH850_FPU_DOUBLE: strcat (buf, "", double precision FPU""); break;
		case EF_RH850_FPU_SINGLE: strcat (buf, "", single precision FPU""); break;
		case EF_RH850_REGMODE22: strcat (buf, "", regmode:22""); break;
		case EF_RH850_REGMODE32: strcat (buf, "", regmode:23""); break;
		case EF_RH850_GP_FIX: strcat (buf, "", r4 fixed""); break;
",unused,binutils-binutils2Freadelf.c
"		case EF_RH850_FPU_SINGLE: strcat (buf, "", single precision FPU""); break;
		case EF_RH850_REGMODE22: strcat (buf, "", regmode:22""); break;
		case EF_RH850_REGMODE32: strcat (buf, "", regmode:23""); break;
		case EF_RH850_GP_FIX: strcat (buf, "", r4 fixed""); break;
		case EF_RH850_GP_NOFIX: strcat (buf, "", r4 free""); break;
",1,unused,3310,unused,"		case EF_RH850_FPU_SINGLE: strcat (buf, "", single precision FPU""); break;
		case EF_RH850_REGMODE22: strcat (buf, "", regmode:22""); break;
		case EF_RH850_REGMODE32: strcat (buf, "", regmode:23""); break;
		case EF_RH850_GP_FIX: strcat (buf, "", r4 fixed""); break;
		case EF_RH850_GP_NOFIX: strcat (buf, "", r4 free""); break;
",unused,binutils-binutils2Freadelf.c
"		case EF_RH850_REGMODE22: strcat (buf, "", regmode:22""); break;
		case EF_RH850_REGMODE32: strcat (buf, "", regmode:23""); break;
		case EF_RH850_GP_FIX: strcat (buf, "", r4 fixed""); break;
		case EF_RH850_GP_NOFIX: strcat (buf, "", r4 free""); break;
		case EF_RH850_EP_FIX: strcat (buf, "", r30 fixed""); break;
",1,unused,3311,unused,"		case EF_RH850_REGMODE22: strcat (buf, "", regmode:22""); break;
		case EF_RH850_REGMODE32: strcat (buf, "", regmode:23""); break;
		case EF_RH850_GP_FIX: strcat (buf, "", r4 fixed""); break;
		case EF_RH850_GP_NOFIX: strcat (buf, "", r4 free""); break;
		case EF_RH850_EP_FIX: strcat (buf, "", r30 fixed""); break;
",unused,binutils-binutils2Freadelf.c
"		case EF_RH850_REGMODE32: strcat (buf, "", regmode:23""); break;
		case EF_RH850_GP_FIX: strcat (buf, "", r4 fixed""); break;
		case EF_RH850_GP_NOFIX: strcat (buf, "", r4 free""); break;
		case EF_RH850_EP_FIX: strcat (buf, "", r30 fixed""); break;
		case EF_RH850_EP_NOFIX: strcat (buf, "", r30 free""); break;
",1,unused,3312,unused,"		case EF_RH850_REGMODE32: strcat (buf, "", regmode:23""); break;
		case EF_RH850_GP_FIX: strcat (buf, "", r4 fixed""); break;
		case EF_RH850_GP_NOFIX: strcat (buf, "", r4 free""); break;
		case EF_RH850_EP_FIX: strcat (buf, "", r30 fixed""); break;
		case EF_RH850_EP_NOFIX: strcat (buf, "", r30 free""); break;
",unused,binutils-binutils2Freadelf.c
"		case EF_RH850_GP_FIX: strcat (buf, "", r4 fixed""); break;
		case EF_RH850_GP_NOFIX: strcat (buf, "", r4 free""); break;
		case EF_RH850_EP_FIX: strcat (buf, "", r30 fixed""); break;
		case EF_RH850_EP_NOFIX: strcat (buf, "", r30 free""); break;
		case EF_RH850_TP_FIX: strcat (buf, "", r5 fixed""); break;
",1,unused,3313,unused,"		case EF_RH850_GP_FIX: strcat (buf, "", r4 fixed""); break;
		case EF_RH850_GP_NOFIX: strcat (buf, "", r4 free""); break;
		case EF_RH850_EP_FIX: strcat (buf, "", r30 fixed""); break;
		case EF_RH850_EP_NOFIX: strcat (buf, "", r30 free""); break;
		case EF_RH850_TP_FIX: strcat (buf, "", r5 fixed""); break;
",unused,binutils-binutils2Freadelf.c
"		case EF_RH850_GP_NOFIX: strcat (buf, "", r4 free""); break;
		case EF_RH850_EP_FIX: strcat (buf, "", r30 fixed""); break;
		case EF_RH850_EP_NOFIX: strcat (buf, "", r30 free""); break;
		case EF_RH850_TP_FIX: strcat (buf, "", r5 fixed""); break;
		case EF_RH850_TP_NOFIX: strcat (buf, "", r5 free""); break;
",1,unused,3314,unused,"		case EF_RH850_GP_NOFIX: strcat (buf, "", r4 free""); break;
		case EF_RH850_EP_FIX: strcat (buf, "", r30 fixed""); break;
		case EF_RH850_EP_NOFIX: strcat (buf, "", r30 free""); break;
		case EF_RH850_TP_FIX: strcat (buf, "", r5 fixed""); break;
		case EF_RH850_TP_NOFIX: strcat (buf, "", r5 free""); break;
",unused,binutils-binutils2Freadelf.c
"		case EF_RH850_EP_FIX: strcat (buf, "", r30 fixed""); break;
		case EF_RH850_EP_NOFIX: strcat (buf, "", r30 free""); break;
		case EF_RH850_TP_FIX: strcat (buf, "", r5 fixed""); break;
		case EF_RH850_TP_NOFIX: strcat (buf, "", r5 free""); break;
		case EF_RH850_REG2_RESERVE: strcat (buf, "", r2 fixed""); break;
",1,unused,3315,unused,"		case EF_RH850_EP_FIX: strcat (buf, "", r30 fixed""); break;
		case EF_RH850_EP_NOFIX: strcat (buf, "", r30 free""); break;
		case EF_RH850_TP_FIX: strcat (buf, "", r5 fixed""); break;
		case EF_RH850_TP_NOFIX: strcat (buf, "", r5 free""); break;
		case EF_RH850_REG2_RESERVE: strcat (buf, "", r2 fixed""); break;
",unused,binutils-binutils2Freadelf.c
"		case EF_RH850_EP_NOFIX: strcat (buf, "", r30 free""); break;
		case EF_RH850_TP_FIX: strcat (buf, "", r5 fixed""); break;
		case EF_RH850_TP_NOFIX: strcat (buf, "", r5 free""); break;
		case EF_RH850_REG2_RESERVE: strcat (buf, "", r2 fixed""); break;
		case EF_RH850_REG2_NORESERVE: strcat (buf, "", r2 free""); break;
",1,unused,3316,unused,"		case EF_RH850_EP_NOFIX: strcat (buf, "", r30 free""); break;
		case EF_RH850_TP_FIX: strcat (buf, "", r5 fixed""); break;
		case EF_RH850_TP_NOFIX: strcat (buf, "", r5 free""); break;
		case EF_RH850_REG2_RESERVE: strcat (buf, "", r2 fixed""); break;
		case EF_RH850_REG2_NORESERVE: strcat (buf, "", r2 free""); break;
",unused,binutils-binutils2Freadelf.c
"	case EM_CYGNUS_V850:
	  switch (e_flags & EF_V850_ARCH)
	    {
	    case E_V850E3V5_ARCH:
	      strcat (buf, "", v850e3v5"");
",1,unused,3327,unused,"	case EM_CYGNUS_V850:
	  switch (e_flags & EF_V850_ARCH)
	    {
	    case E_V850E3V5_ARCH:
	      strcat (buf, "", v850e3v5"");
",unused,binutils-binutils2Freadelf.c
"	    case E_V850E3V5_ARCH:
	      strcat (buf, "", v850e3v5"");
	      break;
	    case E_V850E2V3_ARCH:
	      strcat (buf, "", v850e2v3"");
",1,unused,3330,unused,"	    case E_V850E3V5_ARCH:
	      strcat (buf, "", v850e3v5"");
	      break;
	    case E_V850E2V3_ARCH:
	      strcat (buf, "", v850e2v3"");
",unused,binutils-binutils2Freadelf.c
"	    case E_V850E2V3_ARCH:
	      strcat (buf, "", v850e2v3"");
	      break;
	    case E_V850E2_ARCH:
	      strcat (buf, "", v850e2"");
",1,unused,3333,unused,"	    case E_V850E2V3_ARCH:
	      strcat (buf, "", v850e2v3"");
	      break;
	    case E_V850E2_ARCH:
	      strcat (buf, "", v850e2"");
",unused,binutils-binutils2Freadelf.c
"	    case E_V850E2_ARCH:
	      strcat (buf, "", v850e2"");
	      break;
            case E_V850E1_ARCH:
              strcat (buf, "", v850e1"");
",1,unused,3336,unused,"	    case E_V850E2_ARCH:
	      strcat (buf, "", v850e2"");
	      break;
            case E_V850E1_ARCH:
              strcat (buf, "", v850e1"");
",unused,binutils-binutils2Freadelf.c
"            case E_V850E1_ARCH:
              strcat (buf, "", v850e1"");
	      break;
	    case E_V850E_ARCH:
	      strcat (buf, "", v850e"");
",1,unused,3339,unused,"            case E_V850E1_ARCH:
              strcat (buf, "", v850e1"");
	      break;
	    case E_V850E_ARCH:
	      strcat (buf, "", v850e"");
",unused,binutils-binutils2Freadelf.c
"	    case E_V850E_ARCH:
	      strcat (buf, "", v850e"");
	      break;
	    case E_V850_ARCH:
	      strcat (buf, "", v850"");
",1,unused,3342,unused,"	    case E_V850E_ARCH:
	      strcat (buf, "", v850e"");
	      break;
	    case E_V850_ARCH:
	      strcat (buf, "", v850"");
",unused,binutils-binutils2Freadelf.c
"	    case E_V850_ARCH:
	      strcat (buf, "", v850"");
	      break;
	    default:
	      strcat (buf, _("", unknown v850 architecture variant""));
",1,unused,3345,unused,"	    case E_V850_ARCH:
	      strcat (buf, "", v850"");
	      break;
	    default:
	      strcat (buf, _("", unknown v850 architecture variant""));
",unused,binutils-binutils2Freadelf.c
"
	case EM_M32R:
	case EM_CYGNUS_M32R:
	  if ((e_flags & EF_M32R_ARCH) == E_M32R_ARCH)
	    strcat (buf, "", m32r"");
",1,unused,3353,unused,"
	case EM_M32R:
	case EM_CYGNUS_M32R:
	  if ((e_flags & EF_M32R_ARCH) == E_M32R_ARCH)
	    strcat (buf, "", m32r"");
",unused,binutils-binutils2Freadelf.c
"
	case EM_MIPS:
	case EM_MIPS_RS3_LE:
	  if (e_flags & EF_MIPS_NOREORDER)
	    strcat (buf, "", noreorder"");
",1,unused,3359,unused,"
	case EM_MIPS:
	case EM_MIPS_RS3_LE:
	  if (e_flags & EF_MIPS_NOREORDER)
	    strcat (buf, "", noreorder"");
",unused,binutils-binutils2Freadelf.c
"	  if (e_flags & EF_MIPS_NOREORDER)
	    strcat (buf, "", noreorder"");

	  if (e_flags & EF_MIPS_PIC)
	    strcat (buf, "", pic"");
",1,unused,3362,unused,"	  if (e_flags & EF_MIPS_NOREORDER)
	    strcat (buf, "", noreorder"");

	  if (e_flags & EF_MIPS_PIC)
	    strcat (buf, "", pic"");
",unused,binutils-binutils2Freadelf.c
"	  if (e_flags & EF_MIPS_PIC)
	    strcat (buf, "", pic"");

	  if (e_flags & EF_MIPS_CPIC)
	    strcat (buf, "", cpic"");
",1,unused,3365,unused,"	  if (e_flags & EF_MIPS_PIC)
	    strcat (buf, "", pic"");

	  if (e_flags & EF_MIPS_CPIC)
	    strcat (buf, "", cpic"");
",unused,binutils-binutils2Freadelf.c
"	  if (e_flags & EF_MIPS_CPIC)
	    strcat (buf, "", cpic"");

	  if (e_flags & EF_MIPS_UCODE)
	    strcat (buf, "", ugen_reserved"");
",1,unused,3368,unused,"	  if (e_flags & EF_MIPS_CPIC)
	    strcat (buf, "", cpic"");

	  if (e_flags & EF_MIPS_UCODE)
	    strcat (buf, "", ugen_reserved"");
",unused,binutils-binutils2Freadelf.c
"	  if (e_flags & EF_MIPS_UCODE)
	    strcat (buf, "", ugen_reserved"");

	  if (e_flags & EF_MIPS_ABI2)
	    strcat (buf, "", abi2"");
",1,unused,3371,unused,"	  if (e_flags & EF_MIPS_UCODE)
	    strcat (buf, "", ugen_reserved"");

	  if (e_flags & EF_MIPS_ABI2)
	    strcat (buf, "", abi2"");
",unused,binutils-binutils2Freadelf.c
"	  if (e_flags & EF_MIPS_ABI2)
	    strcat (buf, "", abi2"");

	  if (e_flags & EF_MIPS_OPTIONS_FIRST)
	    strcat (buf, "", odk first"");
",1,unused,3374,unused,"	  if (e_flags & EF_MIPS_ABI2)
	    strcat (buf, "", abi2"");

	  if (e_flags & EF_MIPS_OPTIONS_FIRST)
	    strcat (buf, "", odk first"");
",unused,binutils-binutils2Freadelf.c
"	  if (e_flags & EF_MIPS_OPTIONS_FIRST)
	    strcat (buf, "", odk first"");

	  if (e_flags & EF_MIPS_32BITMODE)
	    strcat (buf, "", 32bitmode"");
",1,unused,3377,unused,"	  if (e_flags & EF_MIPS_OPTIONS_FIRST)
	    strcat (buf, "", odk first"");

	  if (e_flags & EF_MIPS_32BITMODE)
	    strcat (buf, "", 32bitmode"");
",unused,binutils-binutils2Freadelf.c
"	  if (e_flags & EF_MIPS_32BITMODE)
	    strcat (buf, "", 32bitmode"");

	  if (e_flags & EF_MIPS_NAN2008)
	    strcat (buf, "", nan2008"");
",1,unused,3380,unused,"	  if (e_flags & EF_MIPS_32BITMODE)
	    strcat (buf, "", 32bitmode"");

	  if (e_flags & EF_MIPS_NAN2008)
	    strcat (buf, "", nan2008"");
",unused,binutils-binutils2Freadelf.c
"	  if (e_flags & EF_MIPS_NAN2008)
	    strcat (buf, "", nan2008"");

	  if (e_flags & EF_MIPS_FP64)
	    strcat (buf, "", fp64"");
",1,unused,3383,unused,"	  if (e_flags & EF_MIPS_NAN2008)
	    strcat (buf, "", nan2008"");

	  if (e_flags & EF_MIPS_FP64)
	    strcat (buf, "", fp64"");
",unused,binutils-binutils2Freadelf.c
"	    strcat (buf, "", fp64"");

	  switch ((e_flags & EF_MIPS_MACH))
	    {
	    case E_MIPS_MACH_3900: strcat (buf, "", 3900""); break;
",1,unused,3387,unused,"	    strcat (buf, "", fp64"");

	  switch ((e_flags & EF_MIPS_MACH))
	    {
	    case E_MIPS_MACH_3900: strcat (buf, "", 3900""); break;
",unused,binutils-binutils2Freadelf.c
"
	  switch ((e_flags & EF_MIPS_MACH))
	    {
	    case E_MIPS_MACH_3900: strcat (buf, "", 3900""); break;
	    case E_MIPS_MACH_4010: strcat (buf, "", 4010""); break;
",1,unused,3388,unused,"
	  switch ((e_flags & EF_MIPS_MACH))
	    {
	    case E_MIPS_MACH_3900: strcat (buf, "", 3900""); break;
	    case E_MIPS_MACH_4010: strcat (buf, "", 4010""); break;
",unused,binutils-binutils2Freadelf.c
"	  switch ((e_flags & EF_MIPS_MACH))
	    {
	    case E_MIPS_MACH_3900: strcat (buf, "", 3900""); break;
	    case E_MIPS_MACH_4010: strcat (buf, "", 4010""); break;
	    case E_MIPS_MACH_4100: strcat (buf, "", 4100""); break;
",1,unused,3389,unused,"	  switch ((e_flags & EF_MIPS_MACH))
	    {
	    case E_MIPS_MACH_3900: strcat (buf, "", 3900""); break;
	    case E_MIPS_MACH_4010: strcat (buf, "", 4010""); break;
	    case E_MIPS_MACH_4100: strcat (buf, "", 4100""); break;
",unused,binutils-binutils2Freadelf.c
"	    {
	    case E_MIPS_MACH_3900: strcat (buf, "", 3900""); break;
	    case E_MIPS_MACH_4010: strcat (buf, "", 4010""); break;
	    case E_MIPS_MACH_4100: strcat (buf, "", 4100""); break;
	    case E_MIPS_MACH_4111: strcat (buf, "", 4111""); break;
",1,unused,3390,unused,"	    {
	    case E_MIPS_MACH_3900: strcat (buf, "", 3900""); break;
	    case E_MIPS_MACH_4010: strcat (buf, "", 4010""); break;
	    case E_MIPS_MACH_4100: strcat (buf, "", 4100""); break;
	    case E_MIPS_MACH_4111: strcat (buf, "", 4111""); break;
",unused,binutils-binutils2Freadelf.c
"	    case E_MIPS_MACH_3900: strcat (buf, "", 3900""); break;
	    case E_MIPS_MACH_4010: strcat (buf, "", 4010""); break;
	    case E_MIPS_MACH_4100: strcat (buf, "", 4100""); break;
	    case E_MIPS_MACH_4111: strcat (buf, "", 4111""); break;
	    case E_MIPS_MACH_4120: strcat (buf, "", 4120""); break;
",1,unused,3391,unused,"	    case E_MIPS_MACH_3900: strcat (buf, "", 3900""); break;
	    case E_MIPS_MACH_4010: strcat (buf, "", 4010""); break;
	    case E_MIPS_MACH_4100: strcat (buf, "", 4100""); break;
	    case E_MIPS_MACH_4111: strcat (buf, "", 4111""); break;
	    case E_MIPS_MACH_4120: strcat (buf, "", 4120""); break;
",unused,binutils-binutils2Freadelf.c
"	    case E_MIPS_MACH_4010: strcat (buf, "", 4010""); break;
	    case E_MIPS_MACH_4100: strcat (buf, "", 4100""); break;
	    case E_MIPS_MACH_4111: strcat (buf, "", 4111""); break;
	    case E_MIPS_MACH_4120: strcat (buf, "", 4120""); break;
	    case E_MIPS_MACH_4650: strcat (buf, "", 4650""); break;
",1,unused,3392,unused,"	    case E_MIPS_MACH_4010: strcat (buf, "", 4010""); break;
	    case E_MIPS_MACH_4100: strcat (buf, "", 4100""); break;
	    case E_MIPS_MACH_4111: strcat (buf, "", 4111""); break;
	    case E_MIPS_MACH_4120: strcat (buf, "", 4120""); break;
	    case E_MIPS_MACH_4650: strcat (buf, "", 4650""); break;
",unused,binutils-binutils2Freadelf.c
"	    case E_MIPS_MACH_4100: strcat (buf, "", 4100""); break;
	    case E_MIPS_MACH_4111: strcat (buf, "", 4111""); break;
	    case E_MIPS_MACH_4120: strcat (buf, "", 4120""); break;
	    case E_MIPS_MACH_4650: strcat (buf, "", 4650""); break;
	    case E_MIPS_MACH_5400: strcat (buf, "", 5400""); break;
",1,unused,3393,unused,"	    case E_MIPS_MACH_4100: strcat (buf, "", 4100""); break;
	    case E_MIPS_MACH_4111: strcat (buf, "", 4111""); break;
	    case E_MIPS_MACH_4120: strcat (buf, "", 4120""); break;
	    case E_MIPS_MACH_4650: strcat (buf, "", 4650""); break;
	    case E_MIPS_MACH_5400: strcat (buf, "", 5400""); break;
",unused,binutils-binutils2Freadelf.c
"	    case E_MIPS_MACH_4111: strcat (buf, "", 4111""); break;
	    case E_MIPS_MACH_4120: strcat (buf, "", 4120""); break;
	    case E_MIPS_MACH_4650: strcat (buf, "", 4650""); break;
	    case E_MIPS_MACH_5400: strcat (buf, "", 5400""); break;
	    case E_MIPS_MACH_5500: strcat (buf, "", 5500""); break;
",1,unused,3394,unused,"	    case E_MIPS_MACH_4111: strcat (buf, "", 4111""); break;
	    case E_MIPS_MACH_4120: strcat (buf, "", 4120""); break;
	    case E_MIPS_MACH_4650: strcat (buf, "", 4650""); break;
	    case E_MIPS_MACH_5400: strcat (buf, "", 5400""); break;
	    case E_MIPS_MACH_5500: strcat (buf, "", 5500""); break;
",unused,binutils-binutils2Freadelf.c
"	    case E_MIPS_MACH_4120: strcat (buf, "", 4120""); break;
	    case E_MIPS_MACH_4650: strcat (buf, "", 4650""); break;
	    case E_MIPS_MACH_5400: strcat (buf, "", 5400""); break;
	    case E_MIPS_MACH_5500: strcat (buf, "", 5500""); break;
	    case E_MIPS_MACH_5900: strcat (buf, "", 5900""); break;
",1,unused,3395,unused,"	    case E_MIPS_MACH_4120: strcat (buf, "", 4120""); break;
	    case E_MIPS_MACH_4650: strcat (buf, "", 4650""); break;
	    case E_MIPS_MACH_5400: strcat (buf, "", 5400""); break;
	    case E_MIPS_MACH_5500: strcat (buf, "", 5500""); break;
	    case E_MIPS_MACH_5900: strcat (buf, "", 5900""); break;
",unused,binutils-binutils2Freadelf.c
"	    case E_MIPS_MACH_4650: strcat (buf, "", 4650""); break;
	    case E_MIPS_MACH_5400: strcat (buf, "", 5400""); break;
	    case E_MIPS_MACH_5500: strcat (buf, "", 5500""); break;
	    case E_MIPS_MACH_5900: strcat (buf, "", 5900""); break;
	    case E_MIPS_MACH_SB1:  strcat (buf, "", sb1"");  break;
",1,unused,3396,unused,"	    case E_MIPS_MACH_4650: strcat (buf, "", 4650""); break;
	    case E_MIPS_MACH_5400: strcat (buf, "", 5400""); break;
	    case E_MIPS_MACH_5500: strcat (buf, "", 5500""); break;
	    case E_MIPS_MACH_5900: strcat (buf, "", 5900""); break;
	    case E_MIPS_MACH_SB1:  strcat (buf, "", sb1"");  break;
",unused,binutils-binutils2Freadelf.c
"	    case E_MIPS_MACH_5400: strcat (buf, "", 5400""); break;
	    case E_MIPS_MACH_5500: strcat (buf, "", 5500""); break;
	    case E_MIPS_MACH_5900: strcat (buf, "", 5900""); break;
	    case E_MIPS_MACH_SB1:  strcat (buf, "", sb1"");  break;
	    case E_MIPS_MACH_9000: strcat (buf, "", 9000""); break;
",1,unused,3397,unused,"	    case E_MIPS_MACH_5400: strcat (buf, "", 5400""); break;
	    case E_MIPS_MACH_5500: strcat (buf, "", 5500""); break;
	    case E_MIPS_MACH_5900: strcat (buf, "", 5900""); break;
	    case E_MIPS_MACH_SB1:  strcat (buf, "", sb1"");  break;
	    case E_MIPS_MACH_9000: strcat (buf, "", 9000""); break;
",unused,binutils-binutils2Freadelf.c
"	    case E_MIPS_MACH_5500: strcat (buf, "", 5500""); break;
	    case E_MIPS_MACH_5900: strcat (buf, "", 5900""); break;
	    case E_MIPS_MACH_SB1:  strcat (buf, "", sb1"");  break;
	    case E_MIPS_MACH_9000: strcat (buf, "", 9000""); break;
  	    case E_MIPS_MACH_LS2E: strcat (buf, "", loongson-2e""); break;
",1,unused,3398,unused,"	    case E_MIPS_MACH_5500: strcat (buf, "", 5500""); break;
	    case E_MIPS_MACH_5900: strcat (buf, "", 5900""); break;
	    case E_MIPS_MACH_SB1:  strcat (buf, "", sb1"");  break;
	    case E_MIPS_MACH_9000: strcat (buf, "", 9000""); break;
  	    case E_MIPS_MACH_LS2E: strcat (buf, "", loongson-2e""); break;
",unused,binutils-binutils2Freadelf.c
"	    case E_MIPS_MACH_5900: strcat (buf, "", 5900""); break;
	    case E_MIPS_MACH_SB1:  strcat (buf, "", sb1"");  break;
	    case E_MIPS_MACH_9000: strcat (buf, "", 9000""); break;
  	    case E_MIPS_MACH_LS2E: strcat (buf, "", loongson-2e""); break;
  	    case E_MIPS_MACH_LS2F: strcat (buf, "", loongson-2f""); break;
",1,unused,3399,unused,"	    case E_MIPS_MACH_5900: strcat (buf, "", 5900""); break;
	    case E_MIPS_MACH_SB1:  strcat (buf, "", sb1"");  break;
	    case E_MIPS_MACH_9000: strcat (buf, "", 9000""); break;
  	    case E_MIPS_MACH_LS2E: strcat (buf, "", loongson-2e""); break;
  	    case E_MIPS_MACH_LS2F: strcat (buf, "", loongson-2f""); break;
",unused,binutils-binutils2Freadelf.c
"	    case E_MIPS_MACH_SB1:  strcat (buf, "", sb1"");  break;
	    case E_MIPS_MACH_9000: strcat (buf, "", 9000""); break;
  	    case E_MIPS_MACH_LS2E: strcat (buf, "", loongson-2e""); break;
  	    case E_MIPS_MACH_LS2F: strcat (buf, "", loongson-2f""); break;
  	    case E_MIPS_MACH_LS3A: strcat (buf, "", loongson-3a""); break;
",1,unused,3400,unused,"	    case E_MIPS_MACH_SB1:  strcat (buf, "", sb1"");  break;
	    case E_MIPS_MACH_9000: strcat (buf, "", 9000""); break;
  	    case E_MIPS_MACH_LS2E: strcat (buf, "", loongson-2e""); break;
  	    case E_MIPS_MACH_LS2F: strcat (buf, "", loongson-2f""); break;
  	    case E_MIPS_MACH_LS3A: strcat (buf, "", loongson-3a""); break;
",unused,binutils-binutils2Freadelf.c
"	    case E_MIPS_MACH_9000: strcat (buf, "", 9000""); break;
  	    case E_MIPS_MACH_LS2E: strcat (buf, "", loongson-2e""); break;
  	    case E_MIPS_MACH_LS2F: strcat (buf, "", loongson-2f""); break;
  	    case E_MIPS_MACH_LS3A: strcat (buf, "", loongson-3a""); break;
	    case E_MIPS_MACH_OCTEON: strcat (buf, "", octeon""); break;
",1,unused,3401,unused,"	    case E_MIPS_MACH_9000: strcat (buf, "", 9000""); break;
  	    case E_MIPS_MACH_LS2E: strcat (buf, "", loongson-2e""); break;
  	    case E_MIPS_MACH_LS2F: strcat (buf, "", loongson-2f""); break;
  	    case E_MIPS_MACH_LS3A: strcat (buf, "", loongson-3a""); break;
	    case E_MIPS_MACH_OCTEON: strcat (buf, "", octeon""); break;
",unused,binutils-binutils2Freadelf.c
"  	    case E_MIPS_MACH_LS2E: strcat (buf, "", loongson-2e""); break;
  	    case E_MIPS_MACH_LS2F: strcat (buf, "", loongson-2f""); break;
  	    case E_MIPS_MACH_LS3A: strcat (buf, "", loongson-3a""); break;
	    case E_MIPS_MACH_OCTEON: strcat (buf, "", octeon""); break;
	    case E_MIPS_MACH_OCTEON2: strcat (buf, "", octeon2""); break;
",1,unused,3402,unused,"  	    case E_MIPS_MACH_LS2E: strcat (buf, "", loongson-2e""); break;
  	    case E_MIPS_MACH_LS2F: strcat (buf, "", loongson-2f""); break;
  	    case E_MIPS_MACH_LS3A: strcat (buf, "", loongson-3a""); break;
	    case E_MIPS_MACH_OCTEON: strcat (buf, "", octeon""); break;
	    case E_MIPS_MACH_OCTEON2: strcat (buf, "", octeon2""); break;
",unused,binutils-binutils2Freadelf.c
"  	    case E_MIPS_MACH_LS2F: strcat (buf, "", loongson-2f""); break;
  	    case E_MIPS_MACH_LS3A: strcat (buf, "", loongson-3a""); break;
	    case E_MIPS_MACH_OCTEON: strcat (buf, "", octeon""); break;
	    case E_MIPS_MACH_OCTEON2: strcat (buf, "", octeon2""); break;
	    case E_MIPS_MACH_OCTEON3: strcat (buf, "", octeon3""); break;
",1,unused,3403,unused,"  	    case E_MIPS_MACH_LS2F: strcat (buf, "", loongson-2f""); break;
  	    case E_MIPS_MACH_LS3A: strcat (buf, "", loongson-3a""); break;
	    case E_MIPS_MACH_OCTEON: strcat (buf, "", octeon""); break;
	    case E_MIPS_MACH_OCTEON2: strcat (buf, "", octeon2""); break;
	    case E_MIPS_MACH_OCTEON3: strcat (buf, "", octeon3""); break;
",unused,binutils-binutils2Freadelf.c
"  	    case E_MIPS_MACH_LS3A: strcat (buf, "", loongson-3a""); break;
	    case E_MIPS_MACH_OCTEON: strcat (buf, "", octeon""); break;
	    case E_MIPS_MACH_OCTEON2: strcat (buf, "", octeon2""); break;
	    case E_MIPS_MACH_OCTEON3: strcat (buf, "", octeon3""); break;
	    case E_MIPS_MACH_XLR:  strcat (buf, "", xlr""); break;
",1,unused,3404,unused,"  	    case E_MIPS_MACH_LS3A: strcat (buf, "", loongson-3a""); break;
	    case E_MIPS_MACH_OCTEON: strcat (buf, "", octeon""); break;
	    case E_MIPS_MACH_OCTEON2: strcat (buf, "", octeon2""); break;
	    case E_MIPS_MACH_OCTEON3: strcat (buf, "", octeon3""); break;
	    case E_MIPS_MACH_XLR:  strcat (buf, "", xlr""); break;
",unused,binutils-binutils2Freadelf.c
"	    case E_MIPS_MACH_OCTEON: strcat (buf, "", octeon""); break;
	    case E_MIPS_MACH_OCTEON2: strcat (buf, "", octeon2""); break;
	    case E_MIPS_MACH_OCTEON3: strcat (buf, "", octeon3""); break;
	    case E_MIPS_MACH_XLR:  strcat (buf, "", xlr""); break;
	    case E_MIPS_MACH_IAMR2:  strcat (buf, "", interaptiv-mr2""); break;
",1,unused,3405,unused,"	    case E_MIPS_MACH_OCTEON: strcat (buf, "", octeon""); break;
	    case E_MIPS_MACH_OCTEON2: strcat (buf, "", octeon2""); break;
	    case E_MIPS_MACH_OCTEON3: strcat (buf, "", octeon3""); break;
	    case E_MIPS_MACH_XLR:  strcat (buf, "", xlr""); break;
	    case E_MIPS_MACH_IAMR2:  strcat (buf, "", interaptiv-mr2""); break;
",unused,binutils-binutils2Freadelf.c
"	    /* We simply ignore the field in this case to avoid confusion:
	       MIPS ELF does not specify EF_MIPS_MACH, it is a GNU
	       extension.  */
	      break;
	    default: strcat (buf, _("", unknown CPU"")); break;
",1,unused,3411,unused,"	    /* We simply ignore the field in this case to avoid confusion:
	       MIPS ELF does not specify EF_MIPS_MACH, it is a GNU
	       extension.  */
	      break;
	    default: strcat (buf, _("", unknown CPU"")); break;
",unused,binutils-binutils2Freadelf.c
"	    }

	  switch ((e_flags & EF_MIPS_ABI))
	    {
	    case E_MIPS_ABI_O32: strcat (buf, "", o32""); break;
",1,unused,3416,unused,"	    }

	  switch ((e_flags & EF_MIPS_ABI))
	    {
	    case E_MIPS_ABI_O32: strcat (buf, "", o32""); break;
",unused,binutils-binutils2Freadelf.c
"
	  switch ((e_flags & EF_MIPS_ABI))
	    {
	    case E_MIPS_ABI_O32: strcat (buf, "", o32""); break;
	    case E_MIPS_ABI_O64: strcat (buf, "", o64""); break;
",1,unused,3417,unused,"
	  switch ((e_flags & EF_MIPS_ABI))
	    {
	    case E_MIPS_ABI_O32: strcat (buf, "", o32""); break;
	    case E_MIPS_ABI_O64: strcat (buf, "", o64""); break;
",unused,binutils-binutils2Freadelf.c
"	  switch ((e_flags & EF_MIPS_ABI))
	    {
	    case E_MIPS_ABI_O32: strcat (buf, "", o32""); break;
	    case E_MIPS_ABI_O64: strcat (buf, "", o64""); break;
	    case E_MIPS_ABI_EABI32: strcat (buf, "", eabi32""); break;
",1,unused,3418,unused,"	  switch ((e_flags & EF_MIPS_ABI))
	    {
	    case E_MIPS_ABI_O32: strcat (buf, "", o32""); break;
	    case E_MIPS_ABI_O64: strcat (buf, "", o64""); break;
	    case E_MIPS_ABI_EABI32: strcat (buf, "", eabi32""); break;
",unused,binutils-binutils2Freadelf.c
"	    {
	    case E_MIPS_ABI_O32: strcat (buf, "", o32""); break;
	    case E_MIPS_ABI_O64: strcat (buf, "", o64""); break;
	    case E_MIPS_ABI_EABI32: strcat (buf, "", eabi32""); break;
	    case E_MIPS_ABI_EABI64: strcat (buf, "", eabi64""); break;
",1,unused,3419,unused,"	    {
	    case E_MIPS_ABI_O32: strcat (buf, "", o32""); break;
	    case E_MIPS_ABI_O64: strcat (buf, "", o64""); break;
	    case E_MIPS_ABI_EABI32: strcat (buf, "", eabi32""); break;
	    case E_MIPS_ABI_EABI64: strcat (buf, "", eabi64""); break;
",unused,binutils-binutils2Freadelf.c
"	       MIPS ELF does not specify EF_MIPS_ABI, it is a GNU extension.
	       This means it is likely to be an o32 file, but not for
	       sure.  */
	      break;
	    default: strcat (buf, _("", unknown ABI"")); break;
",1,unused,3426,unused,"	       MIPS ELF does not specify EF_MIPS_ABI, it is a GNU extension.
	       This means it is likely to be an o32 file, but not for
	       sure.  */
	      break;
	    default: strcat (buf, _("", unknown ABI"")); break;
",unused,binutils-binutils2Freadelf.c
"	    default: strcat (buf, _("", unknown ABI"")); break;
	    }

	  if (e_flags & EF_MIPS_ARCH_ASE_MDMX)
	    strcat (buf, "", mdmx"");
",1,unused,3430,unused,"	    default: strcat (buf, _("", unknown ABI"")); break;
	    }

	  if (e_flags & EF_MIPS_ARCH_ASE_MDMX)
	    strcat (buf, "", mdmx"");
",unused,binutils-binutils2Freadelf.c
"	  if (e_flags & EF_MIPS_ARCH_ASE_MDMX)
	    strcat (buf, "", mdmx"");

	  if (e_flags & EF_MIPS_ARCH_ASE_M16)
	    strcat (buf, "", mips16"");
",1,unused,3433,unused,"	  if (e_flags & EF_MIPS_ARCH_ASE_MDMX)
	    strcat (buf, "", mdmx"");

	  if (e_flags & EF_MIPS_ARCH_ASE_M16)
	    strcat (buf, "", mips16"");
",unused,binutils-binutils2Freadelf.c
"	  if (e_flags & EF_MIPS_ARCH_ASE_M16)
	    strcat (buf, "", mips16"");

	  if (e_flags & EF_MIPS_ARCH_ASE_MICROMIPS)
	    strcat (buf, "", micromips"");
",1,unused,3436,unused,"	  if (e_flags & EF_MIPS_ARCH_ASE_M16)
	    strcat (buf, "", mips16"");

	  if (e_flags & EF_MIPS_ARCH_ASE_MICROMIPS)
	    strcat (buf, "", micromips"");
",unused,binutils-binutils2Freadelf.c
"	    strcat (buf, "", micromips"");

	  switch ((e_flags & EF_MIPS_ARCH))
	    {
	    case E_MIPS_ARCH_1: strcat (buf, "", mips1""); break;
",1,unused,3440,unused,"	    strcat (buf, "", micromips"");

	  switch ((e_flags & EF_MIPS_ARCH))
	    {
	    case E_MIPS_ARCH_1: strcat (buf, "", mips1""); break;
",unused,binutils-binutils2Freadelf.c
"
	  switch ((e_flags & EF_MIPS_ARCH))
	    {
	    case E_MIPS_ARCH_1: strcat (buf, "", mips1""); break;
	    case E_MIPS_ARCH_2: strcat (buf, "", mips2""); break;
",1,unused,3441,unused,"
	  switch ((e_flags & EF_MIPS_ARCH))
	    {
	    case E_MIPS_ARCH_1: strcat (buf, "", mips1""); break;
	    case E_MIPS_ARCH_2: strcat (buf, "", mips2""); break;
",unused,binutils-binutils2Freadelf.c
"	  switch ((e_flags & EF_MIPS_ARCH))
	    {
	    case E_MIPS_ARCH_1: strcat (buf, "", mips1""); break;
	    case E_MIPS_ARCH_2: strcat (buf, "", mips2""); break;
	    case E_MIPS_ARCH_3: strcat (buf, "", mips3""); break;
",1,unused,3442,unused,"	  switch ((e_flags & EF_MIPS_ARCH))
	    {
	    case E_MIPS_ARCH_1: strcat (buf, "", mips1""); break;
	    case E_MIPS_ARCH_2: strcat (buf, "", mips2""); break;
	    case E_MIPS_ARCH_3: strcat (buf, "", mips3""); break;
",unused,binutils-binutils2Freadelf.c
"	    {
	    case E_MIPS_ARCH_1: strcat (buf, "", mips1""); break;
	    case E_MIPS_ARCH_2: strcat (buf, "", mips2""); break;
	    case E_MIPS_ARCH_3: strcat (buf, "", mips3""); break;
	    case E_MIPS_ARCH_4: strcat (buf, "", mips4""); break;
",1,unused,3443,unused,"	    {
	    case E_MIPS_ARCH_1: strcat (buf, "", mips1""); break;
	    case E_MIPS_ARCH_2: strcat (buf, "", mips2""); break;
	    case E_MIPS_ARCH_3: strcat (buf, "", mips3""); break;
	    case E_MIPS_ARCH_4: strcat (buf, "", mips4""); break;
",unused,binutils-binutils2Freadelf.c
"	    case E_MIPS_ARCH_1: strcat (buf, "", mips1""); break;
	    case E_MIPS_ARCH_2: strcat (buf, "", mips2""); break;
	    case E_MIPS_ARCH_3: strcat (buf, "", mips3""); break;
	    case E_MIPS_ARCH_4: strcat (buf, "", mips4""); break;
	    case E_MIPS_ARCH_5: strcat (buf, "", mips5""); break;
",1,unused,3444,unused,"	    case E_MIPS_ARCH_1: strcat (buf, "", mips1""); break;
	    case E_MIPS_ARCH_2: strcat (buf, "", mips2""); break;
	    case E_MIPS_ARCH_3: strcat (buf, "", mips3""); break;
	    case E_MIPS_ARCH_4: strcat (buf, "", mips4""); break;
	    case E_MIPS_ARCH_5: strcat (buf, "", mips5""); break;
",unused,binutils-binutils2Freadelf.c
"	    case E_MIPS_ARCH_2: strcat (buf, "", mips2""); break;
	    case E_MIPS_ARCH_3: strcat (buf, "", mips3""); break;
	    case E_MIPS_ARCH_4: strcat (buf, "", mips4""); break;
	    case E_MIPS_ARCH_5: strcat (buf, "", mips5""); break;
	    case E_MIPS_ARCH_32: strcat (buf, "", mips32""); break;
",1,unused,3445,unused,"	    case E_MIPS_ARCH_2: strcat (buf, "", mips2""); break;
	    case E_MIPS_ARCH_3: strcat (buf, "", mips3""); break;
	    case E_MIPS_ARCH_4: strcat (buf, "", mips4""); break;
	    case E_MIPS_ARCH_5: strcat (buf, "", mips5""); break;
	    case E_MIPS_ARCH_32: strcat (buf, "", mips32""); break;
",unused,binutils-binutils2Freadelf.c
"	    case E_MIPS_ARCH_3: strcat (buf, "", mips3""); break;
	    case E_MIPS_ARCH_4: strcat (buf, "", mips4""); break;
	    case E_MIPS_ARCH_5: strcat (buf, "", mips5""); break;
	    case E_MIPS_ARCH_32: strcat (buf, "", mips32""); break;
	    case E_MIPS_ARCH_32R2: strcat (buf, "", mips32r2""); break;
",1,unused,3446,unused,"	    case E_MIPS_ARCH_3: strcat (buf, "", mips3""); break;
	    case E_MIPS_ARCH_4: strcat (buf, "", mips4""); break;
	    case E_MIPS_ARCH_5: strcat (buf, "", mips5""); break;
	    case E_MIPS_ARCH_32: strcat (buf, "", mips32""); break;
	    case E_MIPS_ARCH_32R2: strcat (buf, "", mips32r2""); break;
",unused,binutils-binutils2Freadelf.c
"	    case E_MIPS_ARCH_4: strcat (buf, "", mips4""); break;
	    case E_MIPS_ARCH_5: strcat (buf, "", mips5""); break;
	    case E_MIPS_ARCH_32: strcat (buf, "", mips32""); break;
	    case E_MIPS_ARCH_32R2: strcat (buf, "", mips32r2""); break;
	    case E_MIPS_ARCH_32R6: strcat (buf, "", mips32r6""); break;
",1,unused,3447,unused,"	    case E_MIPS_ARCH_4: strcat (buf, "", mips4""); break;
	    case E_MIPS_ARCH_5: strcat (buf, "", mips5""); break;
	    case E_MIPS_ARCH_32: strcat (buf, "", mips32""); break;
	    case E_MIPS_ARCH_32R2: strcat (buf, "", mips32r2""); break;
	    case E_MIPS_ARCH_32R6: strcat (buf, "", mips32r6""); break;
",unused,binutils-binutils2Freadelf.c
"	    case E_MIPS_ARCH_5: strcat (buf, "", mips5""); break;
	    case E_MIPS_ARCH_32: strcat (buf, "", mips32""); break;
	    case E_MIPS_ARCH_32R2: strcat (buf, "", mips32r2""); break;
	    case E_MIPS_ARCH_32R6: strcat (buf, "", mips32r6""); break;
	    case E_MIPS_ARCH_64: strcat (buf, "", mips64""); break;
",1,unused,3448,unused,"	    case E_MIPS_ARCH_5: strcat (buf, "", mips5""); break;
	    case E_MIPS_ARCH_32: strcat (buf, "", mips32""); break;
	    case E_MIPS_ARCH_32R2: strcat (buf, "", mips32r2""); break;
	    case E_MIPS_ARCH_32R6: strcat (buf, "", mips32r6""); break;
	    case E_MIPS_ARCH_64: strcat (buf, "", mips64""); break;
",unused,binutils-binutils2Freadelf.c
"	    case E_MIPS_ARCH_32: strcat (buf, "", mips32""); break;
	    case E_MIPS_ARCH_32R2: strcat (buf, "", mips32r2""); break;
	    case E_MIPS_ARCH_32R6: strcat (buf, "", mips32r6""); break;
	    case E_MIPS_ARCH_64: strcat (buf, "", mips64""); break;
	    case E_MIPS_ARCH_64R2: strcat (buf, "", mips64r2""); break;
",1,unused,3449,unused,"	    case E_MIPS_ARCH_32: strcat (buf, "", mips32""); break;
	    case E_MIPS_ARCH_32R2: strcat (buf, "", mips32r2""); break;
	    case E_MIPS_ARCH_32R6: strcat (buf, "", mips32r6""); break;
	    case E_MIPS_ARCH_64: strcat (buf, "", mips64""); break;
	    case E_MIPS_ARCH_64R2: strcat (buf, "", mips64r2""); break;
",unused,binutils-binutils2Freadelf.c
"	    case E_MIPS_ARCH_32R2: strcat (buf, "", mips32r2""); break;
	    case E_MIPS_ARCH_32R6: strcat (buf, "", mips32r6""); break;
	    case E_MIPS_ARCH_64: strcat (buf, "", mips64""); break;
	    case E_MIPS_ARCH_64R2: strcat (buf, "", mips64r2""); break;
	    case E_MIPS_ARCH_64R6: strcat (buf, "", mips64r6""); break;
",1,unused,3450,unused,"	    case E_MIPS_ARCH_32R2: strcat (buf, "", mips32r2""); break;
	    case E_MIPS_ARCH_32R6: strcat (buf, "", mips32r6""); break;
	    case E_MIPS_ARCH_64: strcat (buf, "", mips64""); break;
	    case E_MIPS_ARCH_64R2: strcat (buf, "", mips64r2""); break;
	    case E_MIPS_ARCH_64R6: strcat (buf, "", mips64r6""); break;
",unused,binutils-binutils2Freadelf.c
"	    case E_MIPS_ARCH_32R6: strcat (buf, "", mips32r6""); break;
	    case E_MIPS_ARCH_64: strcat (buf, "", mips64""); break;
	    case E_MIPS_ARCH_64R2: strcat (buf, "", mips64r2""); break;
	    case E_MIPS_ARCH_64R6: strcat (buf, "", mips64r6""); break;
	    default: strcat (buf, _("", unknown ISA"")); break;
",1,unused,3451,unused,"	    case E_MIPS_ARCH_32R6: strcat (buf, "", mips32r6""); break;
	    case E_MIPS_ARCH_64: strcat (buf, "", mips64""); break;
	    case E_MIPS_ARCH_64R2: strcat (buf, "", mips64r2""); break;
	    case E_MIPS_ARCH_64R6: strcat (buf, "", mips64r6""); break;
	    default: strcat (buf, _("", unknown ISA"")); break;
",unused,binutils-binutils2Freadelf.c
"	case EM_NFP:
	  switch (EF_NFP_MACH (e_flags))
	    {
	    case E_NFP_MACH_3200:
	      strcat (buf, "", NFP-32xx"");
",1,unused,3463,unused,"	case EM_NFP:
	  switch (EF_NFP_MACH (e_flags))
	    {
	    case E_NFP_MACH_3200:
	      strcat (buf, "", NFP-32xx"");
",unused,binutils-binutils2Freadelf.c
"	    case E_NFP_MACH_3200:
	      strcat (buf, "", NFP-32xx"");
	      break;
	    case E_NFP_MACH_6000:
	      strcat (buf, "", NFP-6xxx"");
",1,unused,3466,unused,"	    case E_NFP_MACH_3200:
	      strcat (buf, "", NFP-32xx"");
	      break;
	    case E_NFP_MACH_6000:
	      strcat (buf, "", NFP-6xxx"");
",unused,binutils-binutils2Freadelf.c
"	  break;

	case EM_RISCV:
	  if (e_flags & EF_RISCV_RVC)
	    strcat (buf, "", RVC"");
",1,unused,3473,unused,"	  break;

	case EM_RISCV:
	  if (e_flags & EF_RISCV_RVC)
	    strcat (buf, "", RVC"");
",unused,binutils-binutils2Freadelf.c
"	  if (e_flags & EF_RISCV_RVC)
	    strcat (buf, "", RVC"");

	  if (e_flags & EF_RISCV_RVE)
	    strcat (buf, "", RVE"");
",1,unused,3476,unused,"	  if (e_flags & EF_RISCV_RVC)
	    strcat (buf, "", RVC"");

	  if (e_flags & EF_RISCV_RVE)
	    strcat (buf, "", RVE"");
",unused,binutils-binutils2Freadelf.c
"
	  switch (e_flags & EF_RISCV_FLOAT_ABI)
	    {
	    case EF_RISCV_FLOAT_ABI_SOFT:
	      strcat (buf, "", soft-float ABI"");
",1,unused,3481,unused,"
	  switch (e_flags & EF_RISCV_FLOAT_ABI)
	    {
	    case EF_RISCV_FLOAT_ABI_SOFT:
	      strcat (buf, "", soft-float ABI"");
",unused,binutils-binutils2Freadelf.c
"	      strcat (buf, "", soft-float ABI"");
	      break;

	    case EF_RISCV_FLOAT_ABI_SINGLE:
	      strcat (buf, "", single-float ABI"");
",1,unused,3485,unused,"	      strcat (buf, "", soft-float ABI"");
	      break;

	    case EF_RISCV_FLOAT_ABI_SINGLE:
	      strcat (buf, "", single-float ABI"");
",unused,binutils-binutils2Freadelf.c
"	      strcat (buf, "", single-float ABI"");
	      break;

	    case EF_RISCV_FLOAT_ABI_DOUBLE:
	      strcat (buf, "", double-float ABI"");
",1,unused,3489,unused,"	      strcat (buf, "", single-float ABI"");
	      break;

	    case EF_RISCV_FLOAT_ABI_DOUBLE:
	      strcat (buf, "", double-float ABI"");
",unused,binutils-binutils2Freadelf.c
"	      strcat (buf, "", double-float ABI"");
	      break;

	    case EF_RISCV_FLOAT_ABI_QUAD:
	      strcat (buf, "", quad-float ABI"");
",1,unused,3493,unused,"	      strcat (buf, "", double-float ABI"");
	      break;

	    case EF_RISCV_FLOAT_ABI_QUAD:
	      strcat (buf, "", quad-float ABI"");
",unused,binutils-binutils2Freadelf.c
"
	case EM_SH:
	  switch ((e_flags & EF_SH_MACH_MASK))
	    {
	    case EF_SH1: strcat (buf, "", sh1""); break;
",1,unused,3501,unused,"
	case EM_SH:
	  switch ((e_flags & EF_SH_MACH_MASK))
	    {
	    case EF_SH1: strcat (buf, "", sh1""); break;
",unused,binutils-binutils2Freadelf.c
"	case EM_SH:
	  switch ((e_flags & EF_SH_MACH_MASK))
	    {
	    case EF_SH1: strcat (buf, "", sh1""); break;
	    case EF_SH2: strcat (buf, "", sh2""); break;
",1,unused,3502,unused,"	case EM_SH:
	  switch ((e_flags & EF_SH_MACH_MASK))
	    {
	    case EF_SH1: strcat (buf, "", sh1""); break;
	    case EF_SH2: strcat (buf, "", sh2""); break;
",unused,binutils-binutils2Freadelf.c
"	  switch ((e_flags & EF_SH_MACH_MASK))
	    {
	    case EF_SH1: strcat (buf, "", sh1""); break;
	    case EF_SH2: strcat (buf, "", sh2""); break;
	    case EF_SH3: strcat (buf, "", sh3""); break;
",1,unused,3503,unused,"	  switch ((e_flags & EF_SH_MACH_MASK))
	    {
	    case EF_SH1: strcat (buf, "", sh1""); break;
	    case EF_SH2: strcat (buf, "", sh2""); break;
	    case EF_SH3: strcat (buf, "", sh3""); break;
",unused,binutils-binutils2Freadelf.c
"	    {
	    case EF_SH1: strcat (buf, "", sh1""); break;
	    case EF_SH2: strcat (buf, "", sh2""); break;
	    case EF_SH3: strcat (buf, "", sh3""); break;
	    case EF_SH_DSP: strcat (buf, "", sh-dsp""); break;
",1,unused,3504,unused,"	    {
	    case EF_SH1: strcat (buf, "", sh1""); break;
	    case EF_SH2: strcat (buf, "", sh2""); break;
	    case EF_SH3: strcat (buf, "", sh3""); break;
	    case EF_SH_DSP: strcat (buf, "", sh-dsp""); break;
",unused,binutils-binutils2Freadelf.c
"	    case EF_SH1: strcat (buf, "", sh1""); break;
	    case EF_SH2: strcat (buf, "", sh2""); break;
	    case EF_SH3: strcat (buf, "", sh3""); break;
	    case EF_SH_DSP: strcat (buf, "", sh-dsp""); break;
	    case EF_SH3_DSP: strcat (buf, "", sh3-dsp""); break;
",1,unused,3505,unused,"	    case EF_SH1: strcat (buf, "", sh1""); break;
	    case EF_SH2: strcat (buf, "", sh2""); break;
	    case EF_SH3: strcat (buf, "", sh3""); break;
	    case EF_SH_DSP: strcat (buf, "", sh-dsp""); break;
	    case EF_SH3_DSP: strcat (buf, "", sh3-dsp""); break;
",unused,binutils-binutils2Freadelf.c
"	    case EF_SH2: strcat (buf, "", sh2""); break;
	    case EF_SH3: strcat (buf, "", sh3""); break;
	    case EF_SH_DSP: strcat (buf, "", sh-dsp""); break;
	    case EF_SH3_DSP: strcat (buf, "", sh3-dsp""); break;
	    case EF_SH4AL_DSP: strcat (buf, "", sh4al-dsp""); break;
",1,unused,3506,unused,"	    case EF_SH2: strcat (buf, "", sh2""); break;
	    case EF_SH3: strcat (buf, "", sh3""); break;
	    case EF_SH_DSP: strcat (buf, "", sh-dsp""); break;
	    case EF_SH3_DSP: strcat (buf, "", sh3-dsp""); break;
	    case EF_SH4AL_DSP: strcat (buf, "", sh4al-dsp""); break;
",unused,binutils-binutils2Freadelf.c
"	    case EF_SH3: strcat (buf, "", sh3""); break;
	    case EF_SH_DSP: strcat (buf, "", sh-dsp""); break;
	    case EF_SH3_DSP: strcat (buf, "", sh3-dsp""); break;
	    case EF_SH4AL_DSP: strcat (buf, "", sh4al-dsp""); break;
	    case EF_SH3E: strcat (buf, "", sh3e""); break;
",1,unused,3507,unused,"	    case EF_SH3: strcat (buf, "", sh3""); break;
	    case EF_SH_DSP: strcat (buf, "", sh-dsp""); break;
	    case EF_SH3_DSP: strcat (buf, "", sh3-dsp""); break;
	    case EF_SH4AL_DSP: strcat (buf, "", sh4al-dsp""); break;
	    case EF_SH3E: strcat (buf, "", sh3e""); break;
",unused,binutils-binutils2Freadelf.c
"	    case EF_SH_DSP: strcat (buf, "", sh-dsp""); break;
	    case EF_SH3_DSP: strcat (buf, "", sh3-dsp""); break;
	    case EF_SH4AL_DSP: strcat (buf, "", sh4al-dsp""); break;
	    case EF_SH3E: strcat (buf, "", sh3e""); break;
	    case EF_SH4: strcat (buf, "", sh4""); break;
",1,unused,3508,unused,"	    case EF_SH_DSP: strcat (buf, "", sh-dsp""); break;
	    case EF_SH3_DSP: strcat (buf, "", sh3-dsp""); break;
	    case EF_SH4AL_DSP: strcat (buf, "", sh4al-dsp""); break;
	    case EF_SH3E: strcat (buf, "", sh3e""); break;
	    case EF_SH4: strcat (buf, "", sh4""); break;
",unused,binutils-binutils2Freadelf.c
"	    case EF_SH3_DSP: strcat (buf, "", sh3-dsp""); break;
	    case EF_SH4AL_DSP: strcat (buf, "", sh4al-dsp""); break;
	    case EF_SH3E: strcat (buf, "", sh3e""); break;
	    case EF_SH4: strcat (buf, "", sh4""); break;
	    case EF_SH5: strcat (buf, "", sh5""); break;
",1,unused,3509,unused,"	    case EF_SH3_DSP: strcat (buf, "", sh3-dsp""); break;
	    case EF_SH4AL_DSP: strcat (buf, "", sh4al-dsp""); break;
	    case EF_SH3E: strcat (buf, "", sh3e""); break;
	    case EF_SH4: strcat (buf, "", sh4""); break;
	    case EF_SH5: strcat (buf, "", sh5""); break;
",unused,binutils-binutils2Freadelf.c
"	    case EF_SH4AL_DSP: strcat (buf, "", sh4al-dsp""); break;
	    case EF_SH3E: strcat (buf, "", sh3e""); break;
	    case EF_SH4: strcat (buf, "", sh4""); break;
	    case EF_SH5: strcat (buf, "", sh5""); break;
	    case EF_SH2E: strcat (buf, "", sh2e""); break;
",1,unused,3510,unused,"	    case EF_SH4AL_DSP: strcat (buf, "", sh4al-dsp""); break;
	    case EF_SH3E: strcat (buf, "", sh3e""); break;
	    case EF_SH4: strcat (buf, "", sh4""); break;
	    case EF_SH5: strcat (buf, "", sh5""); break;
	    case EF_SH2E: strcat (buf, "", sh2e""); break;
",unused,binutils-binutils2Freadelf.c
"	    case EF_SH3E: strcat (buf, "", sh3e""); break;
	    case EF_SH4: strcat (buf, "", sh4""); break;
	    case EF_SH5: strcat (buf, "", sh5""); break;
	    case EF_SH2E: strcat (buf, "", sh2e""); break;
	    case EF_SH4A: strcat (buf, "", sh4a""); break;
",1,unused,3511,unused,"	    case EF_SH3E: strcat (buf, "", sh3e""); break;
	    case EF_SH4: strcat (buf, "", sh4""); break;
	    case EF_SH5: strcat (buf, "", sh5""); break;
	    case EF_SH2E: strcat (buf, "", sh2e""); break;
	    case EF_SH4A: strcat (buf, "", sh4a""); break;
",unused,binutils-binutils2Freadelf.c
"	    case EF_SH4: strcat (buf, "", sh4""); break;
	    case EF_SH5: strcat (buf, "", sh5""); break;
	    case EF_SH2E: strcat (buf, "", sh2e""); break;
	    case EF_SH4A: strcat (buf, "", sh4a""); break;
	    case EF_SH2A: strcat (buf, "", sh2a""); break;
",1,unused,3512,unused,"	    case EF_SH4: strcat (buf, "", sh4""); break;
	    case EF_SH5: strcat (buf, "", sh5""); break;
	    case EF_SH2E: strcat (buf, "", sh2e""); break;
	    case EF_SH4A: strcat (buf, "", sh4a""); break;
	    case EF_SH2A: strcat (buf, "", sh2a""); break;
",unused,binutils-binutils2Freadelf.c
"	    case EF_SH5: strcat (buf, "", sh5""); break;
	    case EF_SH2E: strcat (buf, "", sh2e""); break;
	    case EF_SH4A: strcat (buf, "", sh4a""); break;
	    case EF_SH2A: strcat (buf, "", sh2a""); break;
	    case EF_SH4_NOFPU: strcat (buf, "", sh4-nofpu""); break;
",1,unused,3513,unused,"	    case EF_SH5: strcat (buf, "", sh5""); break;
	    case EF_SH2E: strcat (buf, "", sh2e""); break;
	    case EF_SH4A: strcat (buf, "", sh4a""); break;
	    case EF_SH2A: strcat (buf, "", sh2a""); break;
	    case EF_SH4_NOFPU: strcat (buf, "", sh4-nofpu""); break;
",unused,binutils-binutils2Freadelf.c
"	    case EF_SH2E: strcat (buf, "", sh2e""); break;
	    case EF_SH4A: strcat (buf, "", sh4a""); break;
	    case EF_SH2A: strcat (buf, "", sh2a""); break;
	    case EF_SH4_NOFPU: strcat (buf, "", sh4-nofpu""); break;
	    case EF_SH4A_NOFPU: strcat (buf, "", sh4a-nofpu""); break;
",1,unused,3514,unused,"	    case EF_SH2E: strcat (buf, "", sh2e""); break;
	    case EF_SH4A: strcat (buf, "", sh4a""); break;
	    case EF_SH2A: strcat (buf, "", sh2a""); break;
	    case EF_SH4_NOFPU: strcat (buf, "", sh4-nofpu""); break;
	    case EF_SH4A_NOFPU: strcat (buf, "", sh4a-nofpu""); break;
",unused,binutils-binutils2Freadelf.c
"	    case EF_SH4A: strcat (buf, "", sh4a""); break;
	    case EF_SH2A: strcat (buf, "", sh2a""); break;
	    case EF_SH4_NOFPU: strcat (buf, "", sh4-nofpu""); break;
	    case EF_SH4A_NOFPU: strcat (buf, "", sh4a-nofpu""); break;
	    case EF_SH2A_NOFPU: strcat (buf, "", sh2a-nofpu""); break;
",1,unused,3515,unused,"	    case EF_SH4A: strcat (buf, "", sh4a""); break;
	    case EF_SH2A: strcat (buf, "", sh2a""); break;
	    case EF_SH4_NOFPU: strcat (buf, "", sh4-nofpu""); break;
	    case EF_SH4A_NOFPU: strcat (buf, "", sh4a-nofpu""); break;
	    case EF_SH2A_NOFPU: strcat (buf, "", sh2a-nofpu""); break;
",unused,binutils-binutils2Freadelf.c
"	    case EF_SH2A: strcat (buf, "", sh2a""); break;
	    case EF_SH4_NOFPU: strcat (buf, "", sh4-nofpu""); break;
	    case EF_SH4A_NOFPU: strcat (buf, "", sh4a-nofpu""); break;
	    case EF_SH2A_NOFPU: strcat (buf, "", sh2a-nofpu""); break;
	    case EF_SH3_NOMMU: strcat (buf, "", sh3-nommu""); break;
",1,unused,3516,unused,"	    case EF_SH2A: strcat (buf, "", sh2a""); break;
	    case EF_SH4_NOFPU: strcat (buf, "", sh4-nofpu""); break;
	    case EF_SH4A_NOFPU: strcat (buf, "", sh4a-nofpu""); break;
	    case EF_SH2A_NOFPU: strcat (buf, "", sh2a-nofpu""); break;
	    case EF_SH3_NOMMU: strcat (buf, "", sh3-nommu""); break;
",unused,binutils-binutils2Freadelf.c
"	    case EF_SH4_NOFPU: strcat (buf, "", sh4-nofpu""); break;
	    case EF_SH4A_NOFPU: strcat (buf, "", sh4a-nofpu""); break;
	    case EF_SH2A_NOFPU: strcat (buf, "", sh2a-nofpu""); break;
	    case EF_SH3_NOMMU: strcat (buf, "", sh3-nommu""); break;
	    case EF_SH4_NOMMU_NOFPU: strcat (buf, "", sh4-nommu-nofpu""); break;
",1,unused,3517,unused,"	    case EF_SH4_NOFPU: strcat (buf, "", sh4-nofpu""); break;
	    case EF_SH4A_NOFPU: strcat (buf, "", sh4a-nofpu""); break;
	    case EF_SH2A_NOFPU: strcat (buf, "", sh2a-nofpu""); break;
	    case EF_SH3_NOMMU: strcat (buf, "", sh3-nommu""); break;
	    case EF_SH4_NOMMU_NOFPU: strcat (buf, "", sh4-nommu-nofpu""); break;
",unused,binutils-binutils2Freadelf.c
"	    case EF_SH4A_NOFPU: strcat (buf, "", sh4a-nofpu""); break;
	    case EF_SH2A_NOFPU: strcat (buf, "", sh2a-nofpu""); break;
	    case EF_SH3_NOMMU: strcat (buf, "", sh3-nommu""); break;
	    case EF_SH4_NOMMU_NOFPU: strcat (buf, "", sh4-nommu-nofpu""); break;
	    case EF_SH2A_SH4_NOFPU: strcat (buf, "", sh2a-nofpu-or-sh4-nommu-nofpu""); break;
",1,unused,3518,unused,"	    case EF_SH4A_NOFPU: strcat (buf, "", sh4a-nofpu""); break;
	    case EF_SH2A_NOFPU: strcat (buf, "", sh2a-nofpu""); break;
	    case EF_SH3_NOMMU: strcat (buf, "", sh3-nommu""); break;
	    case EF_SH4_NOMMU_NOFPU: strcat (buf, "", sh4-nommu-nofpu""); break;
	    case EF_SH2A_SH4_NOFPU: strcat (buf, "", sh2a-nofpu-or-sh4-nommu-nofpu""); break;
",unused,binutils-binutils2Freadelf.c
"	    case EF_SH2A_NOFPU: strcat (buf, "", sh2a-nofpu""); break;
	    case EF_SH3_NOMMU: strcat (buf, "", sh3-nommu""); break;
	    case EF_SH4_NOMMU_NOFPU: strcat (buf, "", sh4-nommu-nofpu""); break;
	    case EF_SH2A_SH4_NOFPU: strcat (buf, "", sh2a-nofpu-or-sh4-nommu-nofpu""); break;
	    case EF_SH2A_SH3_NOFPU: strcat (buf, "", sh2a-nofpu-or-sh3-nommu""); break;
",1,unused,3519,unused,"	    case EF_SH2A_NOFPU: strcat (buf, "", sh2a-nofpu""); break;
	    case EF_SH3_NOMMU: strcat (buf, "", sh3-nommu""); break;
	    case EF_SH4_NOMMU_NOFPU: strcat (buf, "", sh4-nommu-nofpu""); break;
	    case EF_SH2A_SH4_NOFPU: strcat (buf, "", sh2a-nofpu-or-sh4-nommu-nofpu""); break;
	    case EF_SH2A_SH3_NOFPU: strcat (buf, "", sh2a-nofpu-or-sh3-nommu""); break;
",unused,binutils-binutils2Freadelf.c
"	    case EF_SH3_NOMMU: strcat (buf, "", sh3-nommu""); break;
	    case EF_SH4_NOMMU_NOFPU: strcat (buf, "", sh4-nommu-nofpu""); break;
	    case EF_SH2A_SH4_NOFPU: strcat (buf, "", sh2a-nofpu-or-sh4-nommu-nofpu""); break;
	    case EF_SH2A_SH3_NOFPU: strcat (buf, "", sh2a-nofpu-or-sh3-nommu""); break;
	    case EF_SH2A_SH4: strcat (buf, "", sh2a-or-sh4""); break;
",1,unused,3520,unused,"	    case EF_SH3_NOMMU: strcat (buf, "", sh3-nommu""); break;
	    case EF_SH4_NOMMU_NOFPU: strcat (buf, "", sh4-nommu-nofpu""); break;
	    case EF_SH2A_SH4_NOFPU: strcat (buf, "", sh2a-nofpu-or-sh4-nommu-nofpu""); break;
	    case EF_SH2A_SH3_NOFPU: strcat (buf, "", sh2a-nofpu-or-sh3-nommu""); break;
	    case EF_SH2A_SH4: strcat (buf, "", sh2a-or-sh4""); break;
",unused,binutils-binutils2Freadelf.c
"	    case EF_SH4_NOMMU_NOFPU: strcat (buf, "", sh4-nommu-nofpu""); break;
	    case EF_SH2A_SH4_NOFPU: strcat (buf, "", sh2a-nofpu-or-sh4-nommu-nofpu""); break;
	    case EF_SH2A_SH3_NOFPU: strcat (buf, "", sh2a-nofpu-or-sh3-nommu""); break;
	    case EF_SH2A_SH4: strcat (buf, "", sh2a-or-sh4""); break;
	    case EF_SH2A_SH3E: strcat (buf, "", sh2a-or-sh3e""); break;
",1,unused,3521,unused,"	    case EF_SH4_NOMMU_NOFPU: strcat (buf, "", sh4-nommu-nofpu""); break;
	    case EF_SH2A_SH4_NOFPU: strcat (buf, "", sh2a-nofpu-or-sh4-nommu-nofpu""); break;
	    case EF_SH2A_SH3_NOFPU: strcat (buf, "", sh2a-nofpu-or-sh3-nommu""); break;
	    case EF_SH2A_SH4: strcat (buf, "", sh2a-or-sh4""); break;
	    case EF_SH2A_SH3E: strcat (buf, "", sh2a-or-sh3e""); break;
",unused,binutils-binutils2Freadelf.c
"	    case EF_SH2A_SH4_NOFPU: strcat (buf, "", sh2a-nofpu-or-sh4-nommu-nofpu""); break;
	    case EF_SH2A_SH3_NOFPU: strcat (buf, "", sh2a-nofpu-or-sh3-nommu""); break;
	    case EF_SH2A_SH4: strcat (buf, "", sh2a-or-sh4""); break;
	    case EF_SH2A_SH3E: strcat (buf, "", sh2a-or-sh3e""); break;
	    default: strcat (buf, _("", unknown ISA"")); break;
",1,unused,3522,unused,"	    case EF_SH2A_SH4_NOFPU: strcat (buf, "", sh2a-nofpu-or-sh4-nommu-nofpu""); break;
	    case EF_SH2A_SH3_NOFPU: strcat (buf, "", sh2a-nofpu-or-sh3-nommu""); break;
	    case EF_SH2A_SH4: strcat (buf, "", sh2a-or-sh4""); break;
	    case EF_SH2A_SH3E: strcat (buf, "", sh2a-or-sh3e""); break;
	    default: strcat (buf, _("", unknown ISA"")); break;
",unused,binutils-binutils2Freadelf.c
"	    default: strcat (buf, _("", unknown ISA"")); break;
	    }

	  if (e_flags & EF_SH_PIC)
	    strcat (buf, "", pic"");
",1,unused,3526,unused,"	    default: strcat (buf, _("", unknown ISA"")); break;
	    }

	  if (e_flags & EF_SH_PIC)
	    strcat (buf, "", pic"");
",unused,binutils-binutils2Freadelf.c
"	  if (e_flags & EF_SH_PIC)
	    strcat (buf, "", pic"");

	  if (e_flags & EF_SH_FDPIC)
	    strcat (buf, "", fdpic"");
",1,unused,3529,unused,"	  if (e_flags & EF_SH_PIC)
	    strcat (buf, "", pic"");

	  if (e_flags & EF_SH_FDPIC)
	    strcat (buf, "", fdpic"");
",unused,binutils-binutils2Freadelf.c
"	  break;

        case EM_OR1K:
          if (e_flags & EF_OR1K_NODELAY)
            strcat (buf, "", no delay"");
",1,unused,3534,unused,"	  break;

        case EM_OR1K:
          if (e_flags & EF_OR1K_NODELAY)
            strcat (buf, "", no delay"");
",unused,binutils-binutils2Freadelf.c
"          break;

	case EM_SPARCV9:
	  if (e_flags & EF_SPARC_32PLUS)
	    strcat (buf, "", v8+"");
",1,unused,3539,unused,"          break;

	case EM_SPARCV9:
	  if (e_flags & EF_SPARC_32PLUS)
	    strcat (buf, "", v8+"");
",unused,binutils-binutils2Freadelf.c
"	  if (e_flags & EF_SPARC_32PLUS)
	    strcat (buf, "", v8+"");

	  if (e_flags & EF_SPARC_SUN_US1)
	    strcat (buf, "", ultrasparcI"");
",1,unused,3542,unused,"	  if (e_flags & EF_SPARC_32PLUS)
	    strcat (buf, "", v8+"");

	  if (e_flags & EF_SPARC_SUN_US1)
	    strcat (buf, "", ultrasparcI"");
",unused,binutils-binutils2Freadelf.c
"	  if (e_flags & EF_SPARC_SUN_US1)
	    strcat (buf, "", ultrasparcI"");

	  if (e_flags & EF_SPARC_SUN_US3)
	    strcat (buf, "", ultrasparcIII"");
",1,unused,3545,unused,"	  if (e_flags & EF_SPARC_SUN_US1)
	    strcat (buf, "", ultrasparcI"");

	  if (e_flags & EF_SPARC_SUN_US3)
	    strcat (buf, "", ultrasparcIII"");
",unused,binutils-binutils2Freadelf.c
"	  if (e_flags & EF_SPARC_SUN_US3)
	    strcat (buf, "", ultrasparcIII"");

	  if (e_flags & EF_SPARC_HAL_R1)
	    strcat (buf, "", halr1"");
",1,unused,3548,unused,"	  if (e_flags & EF_SPARC_SUN_US3)
	    strcat (buf, "", ultrasparcIII"");

	  if (e_flags & EF_SPARC_HAL_R1)
	    strcat (buf, "", halr1"");
",unused,binutils-binutils2Freadelf.c
"	  if (e_flags & EF_SPARC_HAL_R1)
	    strcat (buf, "", halr1"");

	  if (e_flags & EF_SPARC_LEDATA)
	    strcat (buf, "", ledata"");
",1,unused,3551,unused,"	  if (e_flags & EF_SPARC_HAL_R1)
	    strcat (buf, "", halr1"");

	  if (e_flags & EF_SPARC_LEDATA)
	    strcat (buf, "", ledata"");
",unused,binutils-binutils2Freadelf.c
"	  if (e_flags & EF_SPARC_LEDATA)
	    strcat (buf, "", ledata"");

	  if ((e_flags & EF_SPARCV9_MM) == EF_SPARCV9_TSO)
	    strcat (buf, "", tso"");
",1,unused,3554,unused,"	  if (e_flags & EF_SPARC_LEDATA)
	    strcat (buf, "", ledata"");

	  if ((e_flags & EF_SPARCV9_MM) == EF_SPARCV9_TSO)
	    strcat (buf, "", tso"");
",unused,binutils-binutils2Freadelf.c
"	  if ((e_flags & EF_SPARCV9_MM) == EF_SPARCV9_TSO)
	    strcat (buf, "", tso"");

	  if ((e_flags & EF_SPARCV9_MM) == EF_SPARCV9_PSO)
	    strcat (buf, "", pso"");
",1,unused,3557,unused,"	  if ((e_flags & EF_SPARCV9_MM) == EF_SPARCV9_TSO)
	    strcat (buf, "", tso"");

	  if ((e_flags & EF_SPARCV9_MM) == EF_SPARCV9_PSO)
	    strcat (buf, "", pso"");
",unused,binutils-binutils2Freadelf.c
"	  if ((e_flags & EF_SPARCV9_MM) == EF_SPARCV9_PSO)
	    strcat (buf, "", pso"");

	  if ((e_flags & EF_SPARCV9_MM) == EF_SPARCV9_RMO)
	    strcat (buf, "", rmo"");
",1,unused,3560,unused,"	  if ((e_flags & EF_SPARCV9_MM) == EF_SPARCV9_PSO)
	    strcat (buf, "", pso"");

	  if ((e_flags & EF_SPARCV9_MM) == EF_SPARCV9_RMO)
	    strcat (buf, "", rmo"");
",unused,binutils-binutils2Freadelf.c
"	case EM_PARISC:
	  switch (e_flags & EF_PARISC_ARCH)
	    {
	    case EFA_PARISC_1_0:
	      strcpy (buf, "", PA-RISC 1.0"");
",1,unused,3567,unused,"	case EM_PARISC:
	  switch (e_flags & EF_PARISC_ARCH)
	    {
	    case EFA_PARISC_1_0:
	      strcpy (buf, "", PA-RISC 1.0"");
",unused,binutils-binutils2Freadelf.c
"	    case EFA_PARISC_1_0:
	      strcpy (buf, "", PA-RISC 1.0"");
	      break;
	    case EFA_PARISC_1_1:
	      strcpy (buf, "", PA-RISC 1.1"");
",1,unused,3570,unused,"	    case EFA_PARISC_1_0:
	      strcpy (buf, "", PA-RISC 1.0"");
	      break;
	    case EFA_PARISC_1_1:
	      strcpy (buf, "", PA-RISC 1.1"");
",unused,binutils-binutils2Freadelf.c
"	    case EFA_PARISC_1_1:
	      strcpy (buf, "", PA-RISC 1.1"");
	      break;
	    case EFA_PARISC_2_0:
	      strcpy (buf, "", PA-RISC 2.0"");
",1,unused,3573,unused,"	    case EFA_PARISC_1_1:
	      strcpy (buf, "", PA-RISC 1.1"");
	      break;
	    case EFA_PARISC_2_0:
	      strcpy (buf, "", PA-RISC 2.0"");
",unused,binutils-binutils2Freadelf.c
"	    default:
	      break;
	    }
	  if (e_flags & EF_PARISC_TRAPNIL)
	    strcat (buf, "", trapnil"");
",1,unused,3579,unused,"	    default:
	      break;
	    }
	  if (e_flags & EF_PARISC_TRAPNIL)
	    strcat (buf, "", trapnil"");
",unused,binutils-binutils2Freadelf.c
"	    }
	  if (e_flags & EF_PARISC_TRAPNIL)
	    strcat (buf, "", trapnil"");
	  if (e_flags & EF_PARISC_EXT)
	    strcat (buf, "", ext"");
",1,unused,3581,unused,"	    }
	  if (e_flags & EF_PARISC_TRAPNIL)
	    strcat (buf, "", trapnil"");
	  if (e_flags & EF_PARISC_EXT)
	    strcat (buf, "", ext"");
",unused,binutils-binutils2Freadelf.c
"	    strcat (buf, "", trapnil"");
	  if (e_flags & EF_PARISC_EXT)
	    strcat (buf, "", ext"");
	  if (e_flags & EF_PARISC_LSB)
	    strcat (buf, "", lsb"");
",1,unused,3583,unused,"	    strcat (buf, "", trapnil"");
	  if (e_flags & EF_PARISC_EXT)
	    strcat (buf, "", ext"");
	  if (e_flags & EF_PARISC_LSB)
	    strcat (buf, "", lsb"");
",unused,binutils-binutils2Freadelf.c
"	    strcat (buf, "", ext"");
	  if (e_flags & EF_PARISC_LSB)
	    strcat (buf, "", lsb"");
	  if (e_flags & EF_PARISC_WIDE)
	    strcat (buf, "", wide"");
",1,unused,3585,unused,"	    strcat (buf, "", ext"");
	  if (e_flags & EF_PARISC_LSB)
	    strcat (buf, "", lsb"");
	  if (e_flags & EF_PARISC_WIDE)
	    strcat (buf, "", wide"");
",unused,binutils-binutils2Freadelf.c
"	    strcat (buf, "", lsb"");
	  if (e_flags & EF_PARISC_WIDE)
	    strcat (buf, "", wide"");
	  if (e_flags & EF_PARISC_NO_KABP)
	    strcat (buf, "", no kabp"");
",1,unused,3587,unused,"	    strcat (buf, "", lsb"");
	  if (e_flags & EF_PARISC_WIDE)
	    strcat (buf, "", wide"");
	  if (e_flags & EF_PARISC_NO_KABP)
	    strcat (buf, "", no kabp"");
",unused,binutils-binutils2Freadelf.c
"	    strcat (buf, "", wide"");
	  if (e_flags & EF_PARISC_NO_KABP)
	    strcat (buf, "", no kabp"");
	  if (e_flags & EF_PARISC_LAZYSWAP)
	    strcat (buf, "", lazyswap"");
",1,unused,3589,unused,"	    strcat (buf, "", wide"");
	  if (e_flags & EF_PARISC_NO_KABP)
	    strcat (buf, "", no kabp"");
	  if (e_flags & EF_PARISC_LAZYSWAP)
	    strcat (buf, "", lazyswap"");
",unused,binutils-binutils2Freadelf.c
"
	case EM_PJ:
	case EM_PJ_OLD:
	  if ((e_flags & EF_PICOJAVA_NEWCALLS) == EF_PICOJAVA_NEWCALLS)
	    strcat (buf, "", new calling convention"");
",1,unused,3595,unused,"
	case EM_PJ:
	case EM_PJ_OLD:
	  if ((e_flags & EF_PICOJAVA_NEWCALLS) == EF_PICOJAVA_NEWCALLS)
	    strcat (buf, "", new calling convention"");
",unused,binutils-binutils2Freadelf.c
"	  if ((e_flags & EF_PICOJAVA_NEWCALLS) == EF_PICOJAVA_NEWCALLS)
	    strcat (buf, "", new calling convention"");

	  if ((e_flags & EF_PICOJAVA_GNUCALLS) == EF_PICOJAVA_GNUCALLS)
	    strcat (buf, "", gnu calling convention"");
",1,unused,3598,unused,"	  if ((e_flags & EF_PICOJAVA_NEWCALLS) == EF_PICOJAVA_NEWCALLS)
	    strcat (buf, "", new calling convention"");

	  if ((e_flags & EF_PICOJAVA_GNUCALLS) == EF_PICOJAVA_GNUCALLS)
	    strcat (buf, "", gnu calling convention"");
",unused,binutils-binutils2Freadelf.c
"	  break;

	case EM_IA_64:
	  if ((e_flags & EF_IA_64_ABI64))
	    strcat (buf, "", 64-bit"");
",1,unused,3603,unused,"	  break;

	case EM_IA_64:
	  if ((e_flags & EF_IA_64_ABI64))
	    strcat (buf, "", 64-bit"");
",unused,binutils-binutils2Freadelf.c
"	case EM_IA_64:
	  if ((e_flags & EF_IA_64_ABI64))
	    strcat (buf, "", 64-bit"");
	  else
	    strcat (buf, "", 32-bit"");
",1,unused,3605,unused,"	case EM_IA_64:
	  if ((e_flags & EF_IA_64_ABI64))
	    strcat (buf, "", 64-bit"");
	  else
	    strcat (buf, "", 32-bit"");
",unused,binutils-binutils2Freadelf.c
"	    strcat (buf, "", 64-bit"");
	  else
	    strcat (buf, "", 32-bit"");
	  if ((e_flags & EF_IA_64_REDUCEDFP))
	    strcat (buf, "", reduced fp model"");
",1,unused,3607,unused,"	    strcat (buf, "", 64-bit"");
	  else
	    strcat (buf, "", 32-bit"");
	  if ((e_flags & EF_IA_64_REDUCEDFP))
	    strcat (buf, "", reduced fp model"");
",unused,binutils-binutils2Freadelf.c
"	    strcat (buf, "", 32-bit"");
	  if ((e_flags & EF_IA_64_REDUCEDFP))
	    strcat (buf, "", reduced fp model"");
	  if ((e_flags & EF_IA_64_NOFUNCDESC_CONS_GP))
	    strcat (buf, "", no function descriptors, constant gp"");
",1,unused,3609,unused,"	    strcat (buf, "", 32-bit"");
	  if ((e_flags & EF_IA_64_REDUCEDFP))
	    strcat (buf, "", reduced fp model"");
	  if ((e_flags & EF_IA_64_NOFUNCDESC_CONS_GP))
	    strcat (buf, "", no function descriptors, constant gp"");
",unused,binutils-binutils2Freadelf.c
"	    strcat (buf, "", reduced fp model"");
	  if ((e_flags & EF_IA_64_NOFUNCDESC_CONS_GP))
	    strcat (buf, "", no function descriptors, constant gp"");
	  else if ((e_flags & EF_IA_64_CONS_GP))
	    strcat (buf, "", constant gp"");
",1,unused,3611,unused,"	    strcat (buf, "", reduced fp model"");
	  if ((e_flags & EF_IA_64_NOFUNCDESC_CONS_GP))
	    strcat (buf, "", no function descriptors, constant gp"");
	  else if ((e_flags & EF_IA_64_CONS_GP))
	    strcat (buf, "", constant gp"");
",unused,binutils-binutils2Freadelf.c
"	    strcat (buf, "", no function descriptors, constant gp"");
	  else if ((e_flags & EF_IA_64_CONS_GP))
	    strcat (buf, "", constant gp"");
	  if ((e_flags & EF_IA_64_ABSOLUTE))
	    strcat (buf, "", absolute"");
",1,unused,3613,unused,"	    strcat (buf, "", no function descriptors, constant gp"");
	  else if ((e_flags & EF_IA_64_CONS_GP))
	    strcat (buf, "", constant gp"");
	  if ((e_flags & EF_IA_64_ABSOLUTE))
	    strcat (buf, "", absolute"");
",unused,binutils-binutils2Freadelf.c
"	    strcat (buf, "", absolute"");
          if (filedata->file_header.e_ident[EI_OSABI] == ELFOSABI_OPENVMS)
            {
              if ((e_flags & EF_IA_64_VMS_LINKAGES))
                strcat (buf, "", vms_linkages"");
",1,unused,3617,unused,"	    strcat (buf, "", absolute"");
          if (filedata->file_header.e_ident[EI_OSABI] == ELFOSABI_OPENVMS)
            {
              if ((e_flags & EF_IA_64_VMS_LINKAGES))
                strcat (buf, "", vms_linkages"");
",unused,binutils-binutils2Freadelf.c
"                {
                case EF_IA_64_VMS_COMCOD_SUCCESS:
                  break;
                case EF_IA_64_VMS_COMCOD_WARNING:
                  strcat (buf, "", warning"");
",1,unused,3623,unused,"                {
                case EF_IA_64_VMS_COMCOD_SUCCESS:
                  break;
                case EF_IA_64_VMS_COMCOD_WARNING:
                  strcat (buf, "", warning"");
",unused,binutils-binutils2Freadelf.c
"                case EF_IA_64_VMS_COMCOD_WARNING:
                  strcat (buf, "", warning"");
                  break;
                case EF_IA_64_VMS_COMCOD_ERROR:
                  strcat (buf, "", error"");
",1,unused,3626,unused,"                case EF_IA_64_VMS_COMCOD_WARNING:
                  strcat (buf, "", warning"");
                  break;
                case EF_IA_64_VMS_COMCOD_ERROR:
                  strcat (buf, "", error"");
",unused,binutils-binutils2Freadelf.c
"                case EF_IA_64_VMS_COMCOD_ERROR:
                  strcat (buf, "", error"");
                  break;
                case EF_IA_64_VMS_COMCOD_ABORT:
                  strcat (buf, "", abort"");
",1,unused,3629,unused,"                case EF_IA_64_VMS_COMCOD_ERROR:
                  strcat (buf, "", error"");
                  break;
                case EF_IA_64_VMS_COMCOD_ABORT:
                  strcat (buf, "", abort"");
",unused,binutils-binutils2Freadelf.c
"                  break;
                default:
		  warn (_(""Unrecognised IA64 VMS Command Code: %x\n""),
			e_flags & EF_IA_64_VMS_COMCOD);
		  strcat (buf, "", <unknown>"");
",1,unused,3634,unused,"                  break;
                default:
		  warn (_(""Unrecognised IA64 VMS Command Code: %x\n""),
			e_flags & EF_IA_64_VMS_COMCOD);
		  strcat (buf, "", <unknown>"");
",unused,binutils-binutils2Freadelf.c
"	  break;

	case EM_VAX:
	  if ((e_flags & EF_VAX_NONPIC))
	    strcat (buf, "", non-PIC"");
",1,unused,3641,unused,"	  break;

	case EM_VAX:
	  if ((e_flags & EF_VAX_NONPIC))
	    strcat (buf, "", non-PIC"");
",unused,binutils-binutils2Freadelf.c
"	case EM_VAX:
	  if ((e_flags & EF_VAX_NONPIC))
	    strcat (buf, "", non-PIC"");
	  if ((e_flags & EF_VAX_DFLOAT))
	    strcat (buf, "", D-Float"");
",1,unused,3643,unused,"	case EM_VAX:
	  if ((e_flags & EF_VAX_NONPIC))
	    strcat (buf, "", non-PIC"");
	  if ((e_flags & EF_VAX_DFLOAT))
	    strcat (buf, "", D-Float"");
",unused,binutils-binutils2Freadelf.c
"	    strcat (buf, "", non-PIC"");
	  if ((e_flags & EF_VAX_DFLOAT))
	    strcat (buf, "", D-Float"");
	  if ((e_flags & EF_VAX_GFLOAT))
	    strcat (buf, "", G-Float"");
",1,unused,3645,unused,"	    strcat (buf, "", non-PIC"");
	  if ((e_flags & EF_VAX_DFLOAT))
	    strcat (buf, "", D-Float"");
	  if ((e_flags & EF_VAX_GFLOAT))
	    strcat (buf, "", G-Float"");
",unused,binutils-binutils2Freadelf.c
"	  break;

        case EM_VISIUM:
	  if (e_flags & EF_VISIUM_ARCH_MCM)
	    strcat (buf, "", mcm"");
",1,unused,3650,unused,"	  break;

        case EM_VISIUM:
	  if (e_flags & EF_VISIUM_ARCH_MCM)
	    strcat (buf, "", mcm"");
",unused,binutils-binutils2Freadelf.c
"        case EM_VISIUM:
	  if (e_flags & EF_VISIUM_ARCH_MCM)
	    strcat (buf, "", mcm"");
	  else if (e_flags & EF_VISIUM_ARCH_MCM24)
	    strcat (buf, "", mcm24"");
",1,unused,3652,unused,"        case EM_VISIUM:
	  if (e_flags & EF_VISIUM_ARCH_MCM)
	    strcat (buf, "", mcm"");
	  else if (e_flags & EF_VISIUM_ARCH_MCM24)
	    strcat (buf, "", mcm24"");
",unused,binutils-binutils2Freadelf.c
"	    strcat (buf, "", mcm"");
	  else if (e_flags & EF_VISIUM_ARCH_MCM24)
	    strcat (buf, "", mcm24"");
	  if (e_flags & EF_VISIUM_ARCH_GR6)
	    strcat (buf, "", gr6"");
",1,unused,3654,unused,"	    strcat (buf, "", mcm"");
	  else if (e_flags & EF_VISIUM_ARCH_MCM24)
	    strcat (buf, "", mcm24"");
	  if (e_flags & EF_VISIUM_ARCH_GR6)
	    strcat (buf, "", gr6"");
",unused,binutils-binutils2Freadelf.c
"	case EM_RL78:
	  switch (e_flags & E_FLAG_RL78_CPU_MASK)
	    {
	    case E_FLAG_RL78_ANY_CPU: break;
	    case E_FLAG_RL78_G10: strcat (buf, "", G10""); break;
",1,unused,3661,unused,"	case EM_RL78:
	  switch (e_flags & E_FLAG_RL78_CPU_MASK)
	    {
	    case E_FLAG_RL78_ANY_CPU: break;
	    case E_FLAG_RL78_G10: strcat (buf, "", G10""); break;
",unused,binutils-binutils2Freadelf.c
"	  switch (e_flags & E_FLAG_RL78_CPU_MASK)
	    {
	    case E_FLAG_RL78_ANY_CPU: break;
	    case E_FLAG_RL78_G10: strcat (buf, "", G10""); break;
	    case E_FLAG_RL78_G13: strcat (buf, "", G13""); break;
",1,unused,3662,unused,"	  switch (e_flags & E_FLAG_RL78_CPU_MASK)
	    {
	    case E_FLAG_RL78_ANY_CPU: break;
	    case E_FLAG_RL78_G10: strcat (buf, "", G10""); break;
	    case E_FLAG_RL78_G13: strcat (buf, "", G13""); break;
",unused,binutils-binutils2Freadelf.c
"	    {
	    case E_FLAG_RL78_ANY_CPU: break;
	    case E_FLAG_RL78_G10: strcat (buf, "", G10""); break;
	    case E_FLAG_RL78_G13: strcat (buf, "", G13""); break;
	    case E_FLAG_RL78_G14: strcat (buf, "", G14""); break;
",1,unused,3663,unused,"	    {
	    case E_FLAG_RL78_ANY_CPU: break;
	    case E_FLAG_RL78_G10: strcat (buf, "", G10""); break;
	    case E_FLAG_RL78_G13: strcat (buf, "", G13""); break;
	    case E_FLAG_RL78_G14: strcat (buf, "", G14""); break;
",unused,binutils-binutils2Freadelf.c
"	    case E_FLAG_RL78_G13: strcat (buf, "", G13""); break;
	    case E_FLAG_RL78_G14: strcat (buf, "", G14""); break;
	    }
	  if (e_flags & E_FLAG_RL78_64BIT_DOUBLES)
	    strcat (buf, "", 64-bit doubles"");
",1,unused,3666,unused,"	    case E_FLAG_RL78_G13: strcat (buf, "", G13""); break;
	    case E_FLAG_RL78_G14: strcat (buf, "", G14""); break;
	    }
	  if (e_flags & E_FLAG_RL78_64BIT_DOUBLES)
	    strcat (buf, "", 64-bit doubles"");
",unused,binutils-binutils2Freadelf.c
"	  break;

	case EM_RX:
	  if (e_flags & E_FLAG_RX_64BIT_DOUBLES)
	    strcat (buf, "", 64-bit doubles"");
",1,unused,3671,unused,"	  break;

	case EM_RX:
	  if (e_flags & E_FLAG_RX_64BIT_DOUBLES)
	    strcat (buf, "", 64-bit doubles"");
",unused,binutils-binutils2Freadelf.c
"	case EM_RX:
	  if (e_flags & E_FLAG_RX_64BIT_DOUBLES)
	    strcat (buf, "", 64-bit doubles"");
	  if (e_flags & E_FLAG_RX_DSP)
	    strcat (buf, "", dsp"");
",1,unused,3673,unused,"	case EM_RX:
	  if (e_flags & E_FLAG_RX_64BIT_DOUBLES)
	    strcat (buf, "", 64-bit doubles"");
	  if (e_flags & E_FLAG_RX_DSP)
	    strcat (buf, "", dsp"");
",unused,binutils-binutils2Freadelf.c
"	    strcat (buf, "", 64-bit doubles"");
	  if (e_flags & E_FLAG_RX_DSP)
	    strcat (buf, "", dsp"");
	  if (e_flags & E_FLAG_RX_PID)
	    strcat (buf, "", pid"");
",1,unused,3675,unused,"	    strcat (buf, "", 64-bit doubles"");
	  if (e_flags & E_FLAG_RX_DSP)
	    strcat (buf, "", dsp"");
	  if (e_flags & E_FLAG_RX_PID)
	    strcat (buf, "", pid"");
",unused,binutils-binutils2Freadelf.c
"	    strcat (buf, "", dsp"");
	  if (e_flags & E_FLAG_RX_PID)
	    strcat (buf, "", pid"");
	  if (e_flags & E_FLAG_RX_ABI)
	    strcat (buf, "", RX ABI"");
",1,unused,3677,unused,"	    strcat (buf, "", dsp"");
	  if (e_flags & E_FLAG_RX_PID)
	    strcat (buf, "", pid"");
	  if (e_flags & E_FLAG_RX_ABI)
	    strcat (buf, "", RX ABI"");
",unused,binutils-binutils2Freadelf.c
"	    strcat (buf, "", pid"");
	  if (e_flags & E_FLAG_RX_ABI)
	    strcat (buf, "", RX ABI"");
	  if (e_flags & E_FLAG_RX_SINSNS_SET)
	    strcat (buf, e_flags & E_FLAG_RX_SINSNS_YES
",1,unused,3679,unused,"	    strcat (buf, "", pid"");
	  if (e_flags & E_FLAG_RX_ABI)
	    strcat (buf, "", RX ABI"");
	  if (e_flags & E_FLAG_RX_SINSNS_SET)
	    strcat (buf, e_flags & E_FLAG_RX_SINSNS_YES
",unused,binutils-binutils2Freadelf.c
"	  if (e_flags & E_FLAG_RX_SINSNS_SET)
	    strcat (buf, e_flags & E_FLAG_RX_SINSNS_YES
		    ? "", uses String instructions"" : "", bans String instructions"");
	  if (e_flags & E_FLAG_RX_V2)
	    strcat (buf, "", V2"");
",1,unused,3682,unused,"	  if (e_flags & E_FLAG_RX_SINSNS_SET)
	    strcat (buf, e_flags & E_FLAG_RX_SINSNS_YES
		    ? "", uses String instructions"" : "", bans String instructions"");
	  if (e_flags & E_FLAG_RX_V2)
	    strcat (buf, "", V2"");
",unused,binutils-binutils2Freadelf.c
"	  break;

	case EM_S390:
	  if (e_flags & EF_S390_HIGH_GPRS)
	    strcat (buf, "", highgprs"");
",1,unused,3687,unused,"	  break;

	case EM_S390:
	  if (e_flags & EF_S390_HIGH_GPRS)
	    strcat (buf, "", highgprs"");
",unused,binutils-binutils2Freadelf.c
"	  break;

	case EM_TI_C6000:
	  if ((e_flags & EF_C6000_REL))
	    strcat (buf, "", relocatable module"");
",1,unused,3692,unused,"	  break;

	case EM_TI_C6000:
	  if ((e_flags & EF_C6000_REL))
	    strcat (buf, "", relocatable module"");
",unused,binutils-binutils2Freadelf.c
"	    strcat (buf, "", relocatable module"");
	  break;

	case EM_MSP430:
	  strcat (buf, _("": architecture variant: ""));
",1,unused,3696,unused,"	    strcat (buf, "", relocatable module"");
	  break;

	case EM_MSP430:
	  strcat (buf, _("": architecture variant: ""));
",unused,binutils-binutils2Freadelf.c
"	case EM_MSP430:
	  strcat (buf, _("": architecture variant: ""));
	  switch (e_flags & EF_MSP430_MACH)
	    {
	    case E_MSP430_MACH_MSP430x11: strcat (buf, ""MSP430x11""); break;
",1,unused,3699,unused,"	case EM_MSP430:
	  strcat (buf, _("": architecture variant: ""));
	  switch (e_flags & EF_MSP430_MACH)
	    {
	    case E_MSP430_MACH_MSP430x11: strcat (buf, ""MSP430x11""); break;
",unused,binutils-binutils2Freadelf.c
"	  strcat (buf, _("": architecture variant: ""));
	  switch (e_flags & EF_MSP430_MACH)
	    {
	    case E_MSP430_MACH_MSP430x11: strcat (buf, ""MSP430x11""); break;
	    case E_MSP430_MACH_MSP430x11x1 : strcat (buf, ""MSP430x11x1 ""); break;
",1,unused,3700,unused,"	  strcat (buf, _("": architecture variant: ""));
	  switch (e_flags & EF_MSP430_MACH)
	    {
	    case E_MSP430_MACH_MSP430x11: strcat (buf, ""MSP430x11""); break;
	    case E_MSP430_MACH_MSP430x11x1 : strcat (buf, ""MSP430x11x1 ""); break;
",unused,binutils-binutils2Freadelf.c
"	  switch (e_flags & EF_MSP430_MACH)
	    {
	    case E_MSP430_MACH_MSP430x11: strcat (buf, ""MSP430x11""); break;
	    case E_MSP430_MACH_MSP430x11x1 : strcat (buf, ""MSP430x11x1 ""); break;
	    case E_MSP430_MACH_MSP430x12: strcat (buf, ""MSP430x12""); break;
",1,unused,3701,unused,"	  switch (e_flags & EF_MSP430_MACH)
	    {
	    case E_MSP430_MACH_MSP430x11: strcat (buf, ""MSP430x11""); break;
	    case E_MSP430_MACH_MSP430x11x1 : strcat (buf, ""MSP430x11x1 ""); break;
	    case E_MSP430_MACH_MSP430x12: strcat (buf, ""MSP430x12""); break;
",unused,binutils-binutils2Freadelf.c
"	    {
	    case E_MSP430_MACH_MSP430x11: strcat (buf, ""MSP430x11""); break;
	    case E_MSP430_MACH_MSP430x11x1 : strcat (buf, ""MSP430x11x1 ""); break;
	    case E_MSP430_MACH_MSP430x12: strcat (buf, ""MSP430x12""); break;
	    case E_MSP430_MACH_MSP430x13: strcat (buf, ""MSP430x13""); break;
",1,unused,3702,unused,"	    {
	    case E_MSP430_MACH_MSP430x11: strcat (buf, ""MSP430x11""); break;
	    case E_MSP430_MACH_MSP430x11x1 : strcat (buf, ""MSP430x11x1 ""); break;
	    case E_MSP430_MACH_MSP430x12: strcat (buf, ""MSP430x12""); break;
	    case E_MSP430_MACH_MSP430x13: strcat (buf, ""MSP430x13""); break;
",unused,binutils-binutils2Freadelf.c
"	    case E_MSP430_MACH_MSP430x11: strcat (buf, ""MSP430x11""); break;
	    case E_MSP430_MACH_MSP430x11x1 : strcat (buf, ""MSP430x11x1 ""); break;
	    case E_MSP430_MACH_MSP430x12: strcat (buf, ""MSP430x12""); break;
	    case E_MSP430_MACH_MSP430x13: strcat (buf, ""MSP430x13""); break;
	    case E_MSP430_MACH_MSP430x14: strcat (buf, ""MSP430x14""); break;
",1,unused,3703,unused,"	    case E_MSP430_MACH_MSP430x11: strcat (buf, ""MSP430x11""); break;
	    case E_MSP430_MACH_MSP430x11x1 : strcat (buf, ""MSP430x11x1 ""); break;
	    case E_MSP430_MACH_MSP430x12: strcat (buf, ""MSP430x12""); break;
	    case E_MSP430_MACH_MSP430x13: strcat (buf, ""MSP430x13""); break;
	    case E_MSP430_MACH_MSP430x14: strcat (buf, ""MSP430x14""); break;
",unused,binutils-binutils2Freadelf.c
"	    case E_MSP430_MACH_MSP430x11x1 : strcat (buf, ""MSP430x11x1 ""); break;
	    case E_MSP430_MACH_MSP430x12: strcat (buf, ""MSP430x12""); break;
	    case E_MSP430_MACH_MSP430x13: strcat (buf, ""MSP430x13""); break;
	    case E_MSP430_MACH_MSP430x14: strcat (buf, ""MSP430x14""); break;
	    case E_MSP430_MACH_MSP430x15: strcat (buf, ""MSP430x15""); break;
",1,unused,3704,unused,"	    case E_MSP430_MACH_MSP430x11x1 : strcat (buf, ""MSP430x11x1 ""); break;
	    case E_MSP430_MACH_MSP430x12: strcat (buf, ""MSP430x12""); break;
	    case E_MSP430_MACH_MSP430x13: strcat (buf, ""MSP430x13""); break;
	    case E_MSP430_MACH_MSP430x14: strcat (buf, ""MSP430x14""); break;
	    case E_MSP430_MACH_MSP430x15: strcat (buf, ""MSP430x15""); break;
",unused,binutils-binutils2Freadelf.c
"	    case E_MSP430_MACH_MSP430x12: strcat (buf, ""MSP430x12""); break;
	    case E_MSP430_MACH_MSP430x13: strcat (buf, ""MSP430x13""); break;
	    case E_MSP430_MACH_MSP430x14: strcat (buf, ""MSP430x14""); break;
	    case E_MSP430_MACH_MSP430x15: strcat (buf, ""MSP430x15""); break;
	    case E_MSP430_MACH_MSP430x16: strcat (buf, ""MSP430x16""); break;
",1,unused,3705,unused,"	    case E_MSP430_MACH_MSP430x12: strcat (buf, ""MSP430x12""); break;
	    case E_MSP430_MACH_MSP430x13: strcat (buf, ""MSP430x13""); break;
	    case E_MSP430_MACH_MSP430x14: strcat (buf, ""MSP430x14""); break;
	    case E_MSP430_MACH_MSP430x15: strcat (buf, ""MSP430x15""); break;
	    case E_MSP430_MACH_MSP430x16: strcat (buf, ""MSP430x16""); break;
",unused,binutils-binutils2Freadelf.c
"	    case E_MSP430_MACH_MSP430x13: strcat (buf, ""MSP430x13""); break;
	    case E_MSP430_MACH_MSP430x14: strcat (buf, ""MSP430x14""); break;
	    case E_MSP430_MACH_MSP430x15: strcat (buf, ""MSP430x15""); break;
	    case E_MSP430_MACH_MSP430x16: strcat (buf, ""MSP430x16""); break;
	    case E_MSP430_MACH_MSP430x31: strcat (buf, ""MSP430x31""); break;
",1,unused,3706,unused,"	    case E_MSP430_MACH_MSP430x13: strcat (buf, ""MSP430x13""); break;
	    case E_MSP430_MACH_MSP430x14: strcat (buf, ""MSP430x14""); break;
	    case E_MSP430_MACH_MSP430x15: strcat (buf, ""MSP430x15""); break;
	    case E_MSP430_MACH_MSP430x16: strcat (buf, ""MSP430x16""); break;
	    case E_MSP430_MACH_MSP430x31: strcat (buf, ""MSP430x31""); break;
",unused,binutils-binutils2Freadelf.c
"	    case E_MSP430_MACH_MSP430x14: strcat (buf, ""MSP430x14""); break;
	    case E_MSP430_MACH_MSP430x15: strcat (buf, ""MSP430x15""); break;
	    case E_MSP430_MACH_MSP430x16: strcat (buf, ""MSP430x16""); break;
	    case E_MSP430_MACH_MSP430x31: strcat (buf, ""MSP430x31""); break;
	    case E_MSP430_MACH_MSP430x32: strcat (buf, ""MSP430x32""); break;
",1,unused,3707,unused,"	    case E_MSP430_MACH_MSP430x14: strcat (buf, ""MSP430x14""); break;
	    case E_MSP430_MACH_MSP430x15: strcat (buf, ""MSP430x15""); break;
	    case E_MSP430_MACH_MSP430x16: strcat (buf, ""MSP430x16""); break;
	    case E_MSP430_MACH_MSP430x31: strcat (buf, ""MSP430x31""); break;
	    case E_MSP430_MACH_MSP430x32: strcat (buf, ""MSP430x32""); break;
",unused,binutils-binutils2Freadelf.c
"	    case E_MSP430_MACH_MSP430x15: strcat (buf, ""MSP430x15""); break;
	    case E_MSP430_MACH_MSP430x16: strcat (buf, ""MSP430x16""); break;
	    case E_MSP430_MACH_MSP430x31: strcat (buf, ""MSP430x31""); break;
	    case E_MSP430_MACH_MSP430x32: strcat (buf, ""MSP430x32""); break;
	    case E_MSP430_MACH_MSP430x33: strcat (buf, ""MSP430x33""); break;
",1,unused,3708,unused,"	    case E_MSP430_MACH_MSP430x15: strcat (buf, ""MSP430x15""); break;
	    case E_MSP430_MACH_MSP430x16: strcat (buf, ""MSP430x16""); break;
	    case E_MSP430_MACH_MSP430x31: strcat (buf, ""MSP430x31""); break;
	    case E_MSP430_MACH_MSP430x32: strcat (buf, ""MSP430x32""); break;
	    case E_MSP430_MACH_MSP430x33: strcat (buf, ""MSP430x33""); break;
",unused,binutils-binutils2Freadelf.c
"	    case E_MSP430_MACH_MSP430x16: strcat (buf, ""MSP430x16""); break;
	    case E_MSP430_MACH_MSP430x31: strcat (buf, ""MSP430x31""); break;
	    case E_MSP430_MACH_MSP430x32: strcat (buf, ""MSP430x32""); break;
	    case E_MSP430_MACH_MSP430x33: strcat (buf, ""MSP430x33""); break;
	    case E_MSP430_MACH_MSP430x41: strcat (buf, ""MSP430x41""); break;
",1,unused,3709,unused,"	    case E_MSP430_MACH_MSP430x16: strcat (buf, ""MSP430x16""); break;
	    case E_MSP430_MACH_MSP430x31: strcat (buf, ""MSP430x31""); break;
	    case E_MSP430_MACH_MSP430x32: strcat (buf, ""MSP430x32""); break;
	    case E_MSP430_MACH_MSP430x33: strcat (buf, ""MSP430x33""); break;
	    case E_MSP430_MACH_MSP430x41: strcat (buf, ""MSP430x41""); break;
",unused,binutils-binutils2Freadelf.c
"	    case E_MSP430_MACH_MSP430x31: strcat (buf, ""MSP430x31""); break;
	    case E_MSP430_MACH_MSP430x32: strcat (buf, ""MSP430x32""); break;
	    case E_MSP430_MACH_MSP430x33: strcat (buf, ""MSP430x33""); break;
	    case E_MSP430_MACH_MSP430x41: strcat (buf, ""MSP430x41""); break;
	    case E_MSP430_MACH_MSP430x42: strcat (buf, ""MSP430x42""); break;
",1,unused,3710,unused,"	    case E_MSP430_MACH_MSP430x31: strcat (buf, ""MSP430x31""); break;
	    case E_MSP430_MACH_MSP430x32: strcat (buf, ""MSP430x32""); break;
	    case E_MSP430_MACH_MSP430x33: strcat (buf, ""MSP430x33""); break;
	    case E_MSP430_MACH_MSP430x41: strcat (buf, ""MSP430x41""); break;
	    case E_MSP430_MACH_MSP430x42: strcat (buf, ""MSP430x42""); break;
",unused,binutils-binutils2Freadelf.c
"	    case E_MSP430_MACH_MSP430x32: strcat (buf, ""MSP430x32""); break;
	    case E_MSP430_MACH_MSP430x33: strcat (buf, ""MSP430x33""); break;
	    case E_MSP430_MACH_MSP430x41: strcat (buf, ""MSP430x41""); break;
	    case E_MSP430_MACH_MSP430x42: strcat (buf, ""MSP430x42""); break;
	    case E_MSP430_MACH_MSP430x43: strcat (buf, ""MSP430x43""); break;
",1,unused,3711,unused,"	    case E_MSP430_MACH_MSP430x32: strcat (buf, ""MSP430x32""); break;
	    case E_MSP430_MACH_MSP430x33: strcat (buf, ""MSP430x33""); break;
	    case E_MSP430_MACH_MSP430x41: strcat (buf, ""MSP430x41""); break;
	    case E_MSP430_MACH_MSP430x42: strcat (buf, ""MSP430x42""); break;
	    case E_MSP430_MACH_MSP430x43: strcat (buf, ""MSP430x43""); break;
",unused,binutils-binutils2Freadelf.c
"	    case E_MSP430_MACH_MSP430x33: strcat (buf, ""MSP430x33""); break;
	    case E_MSP430_MACH_MSP430x41: strcat (buf, ""MSP430x41""); break;
	    case E_MSP430_MACH_MSP430x42: strcat (buf, ""MSP430x42""); break;
	    case E_MSP430_MACH_MSP430x43: strcat (buf, ""MSP430x43""); break;
	    case E_MSP430_MACH_MSP430x44: strcat (buf, ""MSP430x44""); break;
",1,unused,3712,unused,"	    case E_MSP430_MACH_MSP430x33: strcat (buf, ""MSP430x33""); break;
	    case E_MSP430_MACH_MSP430x41: strcat (buf, ""MSP430x41""); break;
	    case E_MSP430_MACH_MSP430x42: strcat (buf, ""MSP430x42""); break;
	    case E_MSP430_MACH_MSP430x43: strcat (buf, ""MSP430x43""); break;
	    case E_MSP430_MACH_MSP430x44: strcat (buf, ""MSP430x44""); break;
",unused,binutils-binutils2Freadelf.c
"	    case E_MSP430_MACH_MSP430x41: strcat (buf, ""MSP430x41""); break;
	    case E_MSP430_MACH_MSP430x42: strcat (buf, ""MSP430x42""); break;
	    case E_MSP430_MACH_MSP430x43: strcat (buf, ""MSP430x43""); break;
	    case E_MSP430_MACH_MSP430x44: strcat (buf, ""MSP430x44""); break;
	    case E_MSP430_MACH_MSP430X  : strcat (buf, ""MSP430X""); break;
",1,unused,3713,unused,"	    case E_MSP430_MACH_MSP430x41: strcat (buf, ""MSP430x41""); break;
	    case E_MSP430_MACH_MSP430x42: strcat (buf, ""MSP430x42""); break;
	    case E_MSP430_MACH_MSP430x43: strcat (buf, ""MSP430x43""); break;
	    case E_MSP430_MACH_MSP430x44: strcat (buf, ""MSP430x44""); break;
	    case E_MSP430_MACH_MSP430X  : strcat (buf, ""MSP430X""); break;
",unused,binutils-binutils2Freadelf.c
"	    case E_MSP430_MACH_MSP430x43: strcat (buf, ""MSP430x43""); break;
	    case E_MSP430_MACH_MSP430x44: strcat (buf, ""MSP430x44""); break;
	    case E_MSP430_MACH_MSP430X  : strcat (buf, ""MSP430X""); break;
	    default:
	      strcat (buf, _("": unknown"")); break;
",1,unused,3715,unused,"	    case E_MSP430_MACH_MSP430x43: strcat (buf, ""MSP430x43""); break;
	    case E_MSP430_MACH_MSP430x44: strcat (buf, ""MSP430x44""); break;
	    case E_MSP430_MACH_MSP430X  : strcat (buf, ""MSP430X""); break;
	    default:
	      strcat (buf, _("": unknown"")); break;
",unused,binutils-binutils2Freadelf.c
"	      strcat (buf, _("": unknown"")); break;
	    }

	  if (e_flags & ~ EF_MSP430_MACH)
	    strcat (buf, _("": unknown extra flag bits also present""));
",1,unused,3719,unused,"	      strcat (buf, _("": unknown"")); break;
	    }

	  if (e_flags & ~ EF_MSP430_MACH)
	    strcat (buf, _("": unknown extra flag bits also present""));
",unused,binutils-binutils2Freadelf.c
"
    default:
      if (p_type >= PT_GNU_MBIND_LO && p_type <= PT_GNU_MBIND_HI)
	{
	  sprintf (buff, ""GNU_MBIND+%#lx"",
",1,unused,3928,unused,"
    default:
      if (p_type >= PT_GNU_MBIND_LO && p_type <= PT_GNU_MBIND_HI)
	{
	  sprintf (buff, ""GNU_MBIND+%#lx"",
",unused,binutils-binutils2Freadelf.c
"
	  if (result != NULL)
	    return result;

	  sprintf (buff, ""LOPROC+%#lx"", p_type - PT_LOPROC);
",1,unused,3968,unused,"
	  if (result != NULL)
	    return result;

	  sprintf (buff, ""LOPROC+%#lx"", p_type - PT_LOPROC);
",unused,binutils-binutils2Freadelf.c
"
	  if (result != NULL)
	    return result;

	  sprintf (buff, ""LOOS+%#lx"", p_type - PT_LOOS);
",1,unused,3993,unused,"
	  if (result != NULL)
	    return result;

	  sprintf (buff, ""LOOS+%#lx"", p_type - PT_LOOS);
",unused,binutils-binutils2Freadelf.c
"
	  if (result != NULL)
	    return result;

	  sprintf (buff, ""LOPROC+%#x"", sh_type - SHT_LOPROC);
",1,unused,4283,unused,"
	  if (result != NULL)
	    return result;

	  sprintf (buff, ""LOPROC+%#x"", sh_type - SHT_LOPROC);
",unused,binutils-binutils2Freadelf.c
"
	  if (result != NULL)
	    return result;

	  sprintf (buff, ""LOOS+%#x"", sh_type - SHT_LOOS);
",1,unused,4314,unused,"
	  if (result != NULL)
	    return result;

	  sprintf (buff, ""LOOS+%#x"", sh_type - SHT_LOOS);
",unused,binutils-binutils2Freadelf.c
"
	  if (result != NULL)
	    return result;

	  sprintf (buff, ""LOUSER+%#x"", sh_type - SHT_LOUSER);
",1,unused,4333,unused,"
	  if (result != NULL)
	    return result;

	  sprintf (buff, ""LOUSER+%#x"", sh_type - SHT_LOUSER);
",unused,binutils-binutils2Freadelf.c
"    };

  if (do_section_details)
    {
      sprintf (buff, ""[%*.*lx]: "",
",1,unused,5709,unused,"    };

  if (do_section_details)
    {
      sprintf (buff, ""[%*.*lx]: "",
",unused,binutils-binutils2Freadelf.c
"	      size -= 2;
	      *p++ = ',';
	      *p++ = ' ';
	    }
	  sprintf (p, ""OS (%*.*lx)"", field_size, field_size,
",1,unused,5883,unused,"	      size -= 2;
	      *p++ = ',';
	      *p++ = ' ';
	    }
	  sprintf (p, ""OS (%*.*lx)"", field_size, field_size,
",unused,binutils-binutils2Freadelf.c
"	      size -= 2;
	      *p++ = ',';
	      *p++ = ' ';
	    }
	  sprintf (p, ""PROC (%*.*lx)"", field_size, field_size,
",1,unused,5901,unused,"	      size -= 2;
	      *p++ = ',';
	      *p++ = ' ';
	    }
	  sprintf (p, ""PROC (%*.*lx)"", field_size, field_size,
",unused,binutils-binutils2Freadelf.c
"	      size -= 2;
	      *p++ = ',';
	      *p++ = ' ';
	    }
	  sprintf (p, _(""UNKNOWN (%*.*lx)""), field_size, field_size,
",1,unused,5919,unused,"	      size -= 2;
	      *p++ = ',';
	      *p++ = ' ';
	    }
	  sprintf (p, _(""UNKNOWN (%*.*lx)""), field_size, field_size,
",unused,binutils-binutils2Freadelf.c
"
  flags &= ~ GRP_COMDAT;
  if (flags & GRP_MASKOS)
    {
      strcat (buff, ""<OS specific>"");
",1,unused,6621,unused,"
  flags &= ~ GRP_COMDAT;
  if (flags & GRP_MASKOS)
    {
      strcat (buff, ""<OS specific>"");
",unused,binutils-binutils2Freadelf.c
"    }

  if (flags & GRP_MASKPROC)
    {
      strcat (buff, ""<PROC specific>"");
",1,unused,6627,unused,"    }

  if (flags & GRP_MASKPROC)
    {
      strcat (buff, ""<PROC specific>"");
",unused,binutils-binutils2Freadelf.c
"      flags &= ~ GRP_MASKPROC;
    }

  if (flags)
    strcat (buff, ""<unknown>"");
",1,unused,6632,unused,"      flags &= ~ GRP_MASKPROC;
    }

  if (flags)
    strcat (buff, ""<unknown>"");
",unused,binutils-binutils2Freadelf.c
"
  if (flags)
    strcat (buff, ""<unknown>"");

  strcat (buff, ""]"");
",1,unused,6634,unused,"
  if (flags)
    strcat (buff, ""<unknown>"");

  strcat (buff, ""]"");
",unused,binutils-binutils2Freadelf.c
"  if (flags == 0)
    return _(""none"");

  if (flags & VER_FLG_BASE)
    strcat (buff, ""BASE"");
",1,unused,10292,unused,"  if (flags == 0)
    return _(""none"");

  if (flags & VER_FLG_BASE)
    strcat (buff, ""BASE"");
",unused,binutils-binutils2Freadelf.c
"
  if (flags & VER_FLG_WEAK)
    {
      if (flags & VER_FLG_BASE)
	strcat (buff, "" | "");
",1,unused,10297,unused,"
  if (flags & VER_FLG_WEAK)
    {
      if (flags & VER_FLG_BASE)
	strcat (buff, "" | "");
",unused,binutils-binutils2Freadelf.c
"    {
      if (flags & VER_FLG_BASE)
	strcat (buff, "" | "");

      strcat (buff, ""WEAK"");
",1,unused,10299,unused,"    {
      if (flags & VER_FLG_BASE)
	strcat (buff, "" | "");

      strcat (buff, ""WEAK"");
",unused,binutils-binutils2Freadelf.c
"
  if (flags & VER_FLG_INFO)
    {
      if (flags & (VER_FLG_BASE|VER_FLG_WEAK))
	strcat (buff, "" | "");
",1,unused,10305,unused,"
  if (flags & VER_FLG_INFO)
    {
      if (flags & (VER_FLG_BASE|VER_FLG_WEAK))
	strcat (buff, "" | "");
",unused,binutils-binutils2Freadelf.c
"    {
      if (flags & (VER_FLG_BASE|VER_FLG_WEAK))
	strcat (buff, "" | "");

      strcat (buff, ""INFO"");
",1,unused,10307,unused,"    {
      if (flags & (VER_FLG_BASE|VER_FLG_WEAK))
	strcat (buff, "" | "");

      strcat (buff, ""INFO"");
",unused,binutils-binutils2Freadelf.c
"
  if (flags & ~(VER_FLG_BASE | VER_FLG_WEAK | VER_FLG_INFO))
    {
      if (flags & (VER_FLG_BASE | VER_FLG_WEAK | VER_FLG_INFO))
	strcat (buff, "" | "");
",1,unused,10313,unused,"
  if (flags & ~(VER_FLG_BASE | VER_FLG_WEAK | VER_FLG_INFO))
    {
      if (flags & (VER_FLG_BASE | VER_FLG_WEAK | VER_FLG_INFO))
	strcat (buff, "" | "");
",unused,binutils-binutils2Freadelf.c
"    {
      if (flags & (VER_FLG_BASE | VER_FLG_WEAK | VER_FLG_INFO))
	strcat (buff, "" | "");

      strcat (buff, _(""<unknown>""));
",1,unused,10315,unused,"    {
      if (flags & (VER_FLG_BASE | VER_FLG_WEAK | VER_FLG_INFO))
	strcat (buff, "" | "");

      strcat (buff, _(""<unknown>""));
",unused,binutils-binutils2Freadelf.c
"        case ET_EXEC:
          switch (VMS_ST_FUNC_TYPE (other))
            {
            case VMS_SFT_CODE_ADDR:
              strcat (res, "" CA"");
",1,unused,10995,unused,"        case ET_EXEC:
          switch (VMS_ST_FUNC_TYPE (other))
            {
            case VMS_SFT_CODE_ADDR:
              strcat (res, "" CA"");
",unused,binutils-binutils2Freadelf.c
"            case VMS_SFT_CODE_ADDR:
              strcat (res, "" CA"");
              break;
            case VMS_SFT_SYMV_IDX:
              strcat (res, "" VEC"");
",1,unused,10998,unused,"            case VMS_SFT_CODE_ADDR:
              strcat (res, "" CA"");
              break;
            case VMS_SFT_SYMV_IDX:
              strcat (res, "" VEC"");
",unused,binutils-binutils2Freadelf.c
"            case VMS_SFT_SYMV_IDX:
              strcat (res, "" VEC"");
              break;
            case VMS_SFT_FD:
              strcat (res, "" FD"");
",1,unused,11001,unused,"            case VMS_SFT_SYMV_IDX:
              strcat (res, "" VEC"");
              break;
            case VMS_SFT_FD:
              strcat (res, "" FD"");
",unused,binutils-binutils2Freadelf.c
"            case VMS_SFT_FD:
              strcat (res, "" FD"");
              break;
            case VMS_SFT_RESERVE:
              strcat (res, "" RSV"");
",1,unused,11004,unused,"            case VMS_SFT_FD:
              strcat (res, "" FD"");
              break;
            case VMS_SFT_RESERVE:
              strcat (res, "" RSV"");
",unused,binutils-binutils2Freadelf.c
"              break;
            default:
	      warn (_(""Unrecognized IA64 VMS ST Function type: %d\n""),
		    VMS_ST_FUNC_TYPE (other));
	      strcat (res, "" <unknown>"");
",1,unused,11009,unused,"              break;
            default:
	      warn (_(""Unrecognized IA64 VMS ST Function type: %d\n""),
		    VMS_ST_FUNC_TYPE (other));
	      strcat (res, "" <unknown>"");
",unused,binutils-binutils2Freadelf.c
"        }
      switch (VMS_ST_LINKAGE (other))
        {
        case VMS_STL_IGNORE:
          strcat (res, "" IGN"");
",1,unused,11019,unused,"        }
      switch (VMS_ST_LINKAGE (other))
        {
        case VMS_STL_IGNORE:
          strcat (res, "" IGN"");
",unused,binutils-binutils2Freadelf.c
"        case VMS_STL_IGNORE:
          strcat (res, "" IGN"");
          break;
        case VMS_STL_RESERVE:
          strcat (res, "" RSV"");
",1,unused,11022,unused,"        case VMS_STL_IGNORE:
          strcat (res, "" IGN"");
          break;
        case VMS_STL_RESERVE:
          strcat (res, "" RSV"");
",unused,binutils-binutils2Freadelf.c
"        case VMS_STL_RESERVE:
          strcat (res, "" RSV"");
          break;
        case VMS_STL_STD:
          strcat (res, "" STD"");
",1,unused,11025,unused,"        case VMS_STL_RESERVE:
          strcat (res, "" RSV"");
          break;
        case VMS_STL_STD:
          strcat (res, "" STD"");
",unused,binutils-binutils2Freadelf.c
"        case VMS_STL_STD:
          strcat (res, "" STD"");
          break;
        case VMS_STL_LNK:
          strcat (res, "" LNK"");
",1,unused,11028,unused,"        case VMS_STL_STD:
          strcat (res, "" STD"");
          break;
        case VMS_STL_LNK:
          strcat (res, "" LNK"");
",unused,binutils-binutils2Freadelf.c
"          break;
        default:
	  warn (_(""Unrecognized IA64 VMS ST Linkage: %d\n""),
		VMS_ST_LINKAGE (other));
	  strcat (res, "" <unknown>"");
",1,unused,11033,unused,"          break;
        default:
	  warn (_(""Unrecognized IA64 VMS ST Linkage: %d\n""),
		VMS_ST_LINKAGE (other));
	  strcat (res, "" <unknown>"");
",unused,binutils-binutils2Freadelf.c
"      else if (type == SHN_MIPS_SUNDEFINED
	       && filedata->file_header.e_machine == EM_MIPS)
	return ""SUND"";
      else if (type >= SHN_LOPROC && type <= SHN_HIPROC)
	sprintf (buff, ""PRC[0x%04x]"", type & 0xffff);
",1,unused,11119,unused,"      else if (type == SHN_MIPS_SUNDEFINED
	       && filedata->file_header.e_machine == EM_MIPS)
	return ""SUND"";
      else if (type >= SHN_LOPROC && type <= SHN_HIPROC)
	sprintf (buff, ""PRC[0x%04x]"", type & 0xffff);
",unused,binutils-binutils2Freadelf.c
"	return ""SUND"";
      else if (type >= SHN_LOPROC && type <= SHN_HIPROC)
	sprintf (buff, ""PRC[0x%04x]"", type & 0xffff);
      else if (type >= SHN_LOOS && type <= SHN_HIOS)
	sprintf (buff, ""OS [0x%04x]"", type & 0xffff);
",1,unused,11121,unused,"	return ""SUND"";
      else if (type >= SHN_LOPROC && type <= SHN_HIPROC)
	sprintf (buff, ""PRC[0x%04x]"", type & 0xffff);
      else if (type >= SHN_LOOS && type <= SHN_HIOS)
	sprintf (buff, ""OS [0x%04x]"", type & 0xffff);
",unused,binutils-binutils2Freadelf.c
"	sprintf (buff, ""PRC[0x%04x]"", type & 0xffff);
      else if (type >= SHN_LOOS && type <= SHN_HIOS)
	sprintf (buff, ""OS [0x%04x]"", type & 0xffff);
      else if (type >= SHN_LORESERVE)
	sprintf (buff, ""RSV[0x%04x]"", type & 0xffff);
",1,unused,11123,unused,"	sprintf (buff, ""PRC[0x%04x]"", type & 0xffff);
      else if (type >= SHN_LOOS && type <= SHN_HIOS)
	sprintf (buff, ""OS [0x%04x]"", type & 0xffff);
      else if (type >= SHN_LORESERVE)
	sprintf (buff, ""RSV[0x%04x]"", type & 0xffff);
",unused,binutils-binutils2Freadelf.c
"	sprintf (buff, ""OS [0x%04x]"", type & 0xffff);
      else if (type >= SHN_LORESERVE)
	sprintf (buff, ""RSV[0x%04x]"", type & 0xffff);
      else if (type >= filedata->file_header.e_shnum)
	sprintf (buff, _(""bad section index[%3d]""), type);
",1,unused,11125,unused,"	sprintf (buff, ""OS [0x%04x]"", type & 0xffff);
      else if (type >= SHN_LORESERVE)
	sprintf (buff, ""RSV[0x%04x]"", type & 0xffff);
      else if (type >= filedata->file_header.e_shnum)
	sprintf (buff, _(""bad section index[%3d]""), type);
",unused,binutils-binutils2Freadelf.c
"	sprintf (buff, ""RSV[0x%04x]"", type & 0xffff);
      else if (type >= filedata->file_header.e_shnum)
	sprintf (buff, _(""bad section index[%3d]""), type);
      else
	sprintf (buff, ""%3d"", type);
",1,unused,11127,unused,"	sprintf (buff, ""RSV[0x%04x]"", type & 0xffff);
      else if (type >= filedata->file_header.e_shnum)
	sprintf (buff, _(""bad section index[%3d]""), type);
      else
	sprintf (buff, ""%3d"", type);
",unused,binutils-binutils2Freadelf.c
"	{
	  static char tmpbuf [128];

	  error (_(""unrecognised byte in name field: %d\n""), * name);
	  sprintf (tmpbuf, _(""<unknown:_%d>""), * name);
",1,unused,17938,unused,"	{
	  static char tmpbuf [128];

	  error (_(""unrecognised byte in name field: %d\n""), * name);
	  sprintf (tmpbuf, _(""<unknown:_%d>""), * name);
",unused,binutils-binutils2Freadelf.c
"size_number (bfd_size_type num)
{
  char buffer[40];

  sprintf (buffer,
",1,unused,421,unused,"size_number (bfd_size_type num)
{
  char buffer[40];

  sprintf (buffer,
",unused,binutils-binutils2Fsize.c
"rprint_number (int width, bfd_size_type num)
{
  char buffer[40];

  sprintf (buffer,
",1,unused,434,unused,"rprint_number (int width, bfd_size_type num)
{
  char buffer[40];

  sprintf (buffer,
",unused,binutils-binutils2Fsize.c
"      const_prefix = constp ? ""C"" : """";
      volatile_prefix = volatilep ? ""V"" : """";

      if (len == 0)
	sprintf (buf, ""__%s%s"", const_prefix, volatile_prefix);
",1,unused,3017,unused,"      const_prefix = constp ? ""C"" : """";
      volatile_prefix = volatilep ? ""V"" : """";

      if (len == 0)
	sprintf (buf, ""__%s%s"", const_prefix, volatile_prefix);
",unused,binutils-binutils2Fstabs.c
"	sprintf (buf, ""__%s%s"", const_prefix, volatile_prefix);
      else if (tagname != NULL && strchr (tagname, '<') != NULL)
	{
	  /* Template methods are fully mangled.  */
	  sprintf (buf, ""__%s%s"", const_prefix, volatile_prefix);
",1,unused,3021,unused,"	sprintf (buf, ""__%s%s"", const_prefix, volatile_prefix);
      else if (tagname != NULL && strchr (tagname, '<') != NULL)
	{
	  /* Template methods are fully mangled.  */
	  sprintf (buf, ""__%s%s"", const_prefix, volatile_prefix);
",unused,binutils-binutils2Fstabs.c
"	  tagname = NULL;
	  len = 0;
	}
      else
	sprintf (buf, ""__%s%s%d"", const_prefix, volatile_prefix, len);
",1,unused,3026,unused,"	  tagname = NULL;
	  len = 0;
	}
      else
	sprintf (buf, ""__%s%s%d"", const_prefix, volatile_prefix, len);
",unused,binutils-binutils2Fstabs.c
"	    }
	  mangled_name_len += strlen (opname);
	  physname = (char *) xmalloc (mangled_name_len);
	  strncpy (physname, fieldname, 3);
	  strcpy (physname + 3, opname);
",1,unused,3049,unused,"	    }
	  mangled_name_len += strlen (opname);
	  physname = (char *) xmalloc (mangled_name_len);
	  strncpy (physname, fieldname, 3);
	  strcpy (physname + 3, opname);
",unused,binutils-binutils2Fstabs.c
"	  physname = (char *) xmalloc (mangled_name_len);
	  if (is_constructor)
	    physname[0] = '\0';
	  else
	    strcpy (physname, fieldname);
",1,unused,3057,unused,"	  physname = (char *) xmalloc (mangled_name_len);
	  if (is_constructor)
	    physname[0] = '\0';
	  else
	    strcpy (physname, fieldname);
",unused,binutils-binutils2Fstabs.c
"	    strcpy (physname, fieldname);
	}

      physname_len = strlen (physname);
      strcat (physname, buf);
",1,unused,3061,unused,"	    strcpy (physname, fieldname);
	}

      physname_len = strlen (physname);
      strcat (physname, buf);
",unused,binutils-binutils2Fstabs.c
"
      physname_len = strlen (physname);
      strcat (physname, buf);
      if (tagname != NULL)
	strcat (physname, tagname);
",1,unused,3063,unused,"
      physname_len = strlen (physname);
      strcat (physname, buf);
      if (tagname != NULL)
	strcat (physname, tagname);
",unused,binutils-binutils2Fstabs.c
"      physname_len = strlen (physname);
      strcat (physname, buf);
      if (tagname != NULL)
	strcat (physname, tagname);
      strcat (physname, argtypes);
",1,unused,3064,unused,"      physname_len = strlen (physname);
      strcat (physname, buf);
      if (tagname != NULL)
	strcat (physname, tagname);
      strcat (physname, argtypes);
",unused,binutils-binutils2Fstabs.c
"
  switch ((abreg >> 5) & 0x3)
    {
    case 0: /* gr */
      sprintf (cp, ""r%u"", (abreg & 0x1f));
",1,unused,127,unused,"
  switch ((abreg >> 5) & 0x3)
    {
    case 0: /* gr */
      sprintf (cp, ""r%u"", (abreg & 0x1f));
",unused,binutils-binutils2Funwind-ia64.c
"      sprintf (cp, ""r%u"", (abreg & 0x1f));
      break;

    case 1: /* fr */
      sprintf (cp, ""f%u"", (abreg & 0x1f));
",1,unused,131,unused,"      sprintf (cp, ""r%u"", (abreg & 0x1f));
      break;

    case 1: /* fr */
      sprintf (cp, ""f%u"", (abreg & 0x1f));
",unused,binutils-binutils2Funwind-ia64.c
"      sprintf (cp, ""f%u"", (abreg & 0x1f));
      break;

    case 2: /* br */
      sprintf (cp, ""b%u"", (abreg & 0x1f));
",1,unused,135,unused,"      sprintf (cp, ""f%u"", (abreg & 0x1f));
      break;

    case 2: /* br */
      sprintf (cp, ""b%u"", (abreg & 0x1f));
",unused,binutils-binutils2Funwind-ia64.c
"      sprintf (cp, ""b%u"", (abreg & 0x1f));
      break;

    case 3: /* special */
      strcpy (cp, special_reg[abreg & 0xf]);
",1,unused,139,unused,"      sprintf (cp, ""b%u"", (abreg & 0x1f));
      break;

    case 3: /* special */
      strcpy (cp, special_reg[abreg & 0xf]);
",unused,binutils-binutils2Funwind-ia64.c
"{
  switch ((x << 1) | ((ytreg >> 7) & 1))
    {
    case 0: /* gr */
      sprintf (cp, ""r%u"", (ytreg & 0x1f));
",1,unused,150,unused,"{
  switch ((x << 1) | ((ytreg >> 7) & 1))
    {
    case 0: /* gr */
      sprintf (cp, ""r%u"", (ytreg & 0x1f));
",unused,binutils-binutils2Funwind-ia64.c
"      sprintf (cp, ""r%u"", (ytreg & 0x1f));
      break;

    case 1: /* fr */
      sprintf (cp, ""f%u"", (ytreg & 0x1f));
",1,unused,154,unused,"      sprintf (cp, ""r%u"", (ytreg & 0x1f));
      break;

    case 1: /* fr */
      sprintf (cp, ""f%u"", (ytreg & 0x1f));
",unused,binutils-binutils2Funwind-ia64.c
"      sprintf (cp, ""f%u"", (ytreg & 0x1f));
      break;

    case 2: /* br */
      sprintf (cp, ""b%u"", (ytreg & 0x1f));
",1,unused,158,unused,"      sprintf (cp, ""f%u"", (ytreg & 0x1f));
      break;

    case 2: /* br */
      sprintf (cp, ""b%u"", (ytreg & 0x1f));
",unused,binutils-binutils2Funwind-ia64.c
"		}
	      else
		ch = process_escape (ch);
	    }
	  sprintf (out_buf, ""%d"", (int) (unsigned char) ch);
",1,unused,1091,unused,"		}
	      else
		ch = process_escape (ch);
	    }
	  sprintf (out_buf, ""%d"", (int) (unsigned char) ch);
",unused,binutils-gas2Fapp.c
"
      n_warns = had_warnings ();
      n_errs = had_errors ();

      sprintf (warn_msg,
",1,unused,1372,unused,"
      n_warns = had_warnings ();
      n_errs = had_errors ();

      sprintf (warn_msg,
",unused,binutils-gas2Fas.c
"      n_errs = had_errors ();

      sprintf (warn_msg,
	       ngettext (""%d warning"", ""%d warnings"", n_warns), n_warns);
      sprintf (err_msg,
",1,unused,1374,unused,"      n_errs = had_errors ();

      sprintf (warn_msg,
	       ngettext (""%d warning"", ""%d warnings"", n_warns), n_warns);
      sprintf (err_msg,
",unused,binutils-gas2Fas.c
"	  obstack_grow (&notes, s, name_length + 1);
	  S_SET_NAME (sym, (const char *) obstack_finish (&notes));
	}
      else
	strcpy ((char *) S_GET_NAME (sym), s);
",1,unused,282,unused,"	  obstack_grow (&notes, s, name_length + 1);
	  S_SET_NAME (sym, (const char *) obstack_finish (&notes));
	}
      else
	strcpy ((char *) S_GET_NAME (sym), s);
",unused,binutils-gas2Fconfig2Fobj-elf.c
"	      int newlen = oldlen - 2 + substlen;
	      char *newname = XNEWVEC (char, newlen + 1);
	      int headlen = subst - name;
	      memcpy (newname, name, headlen);
	      strcpy (newname + headlen, now_seg->name);
",1,unused,988,unused,"	      int newlen = oldlen - 2 + substlen;
	      char *newname = XNEWVEC (char, newlen + 1);
	      int headlen = subst - name;
	      memcpy (newname, name, headlen);
	      strcpy (newname + headlen, now_seg->name);
",unused,binutils-gas2Fconfig2Fobj-elf.c
"	      char *newname = XNEWVEC (char, newlen + 1);
	      int headlen = subst - name;
	      memcpy (newname, name, headlen);
	      strcpy (newname + headlen, now_seg->name);
	      strcat (newname + headlen, subst + 2);
",1,unused,989,unused,"	      char *newname = XNEWVEC (char, newlen + 1);
	      int headlen = subst - name;
	      memcpy (newname, name, headlen);
	      strcpy (newname + headlen, now_seg->name);
	      strcat (newname + headlen, subst + 2);
",unused,binutils-gas2Fconfig2Fobj-elf.c
"      char name[120];

      /* Use a non-fake name for the line number location,
	 so that it can be referred to by relocations.  */
      sprintf (name, "".Loc.%u.%u"", line, filenum);
",1,unused,521,unused,"      char name[120];

      /* Use a non-fake name for the line number location,
	 so that it can be referred to by relocations.  */
      sprintf (name, "".Loc.%u.%u"", line, filenum);
",unused,binutils-gas2Fdwarf2dbg.c
"  memcpy (p, comp_dir, len);

  /* DW_AT_producer */
  *producer_sym = symbol_temp_new_now ();
  sprintf (producer, ""GNU AS %s"", VERSION);
",1,unused,2124,unused,"  memcpy (p, comp_dir, len);

  /* DW_AT_producer */
  *producer_sym = symbol_temp_new_now ();
  sprintf (producer, ""GNU AS %s"", VERSION);
",unused,binutils-gas2Fdwarf2dbg.c
"	{
	  if (address == ~(unsigned int) 0)
	    address = frag_ptr->fr_address / OCTETS_PER_BYTE;

	  sprintf (data_buffer + data_buffer_size,
",1,unused,792,unused,"	{
	  if (address == ~(unsigned int) 0)
	    address = frag_ptr->fr_address / OCTETS_PER_BYTE;

	  sprintf (data_buffer + data_buffer_size,
",unused,binutils-gas2Flisting.c
"	    {
	      if (address == ~(unsigned int) 0)
		address = frag_ptr->fr_address / OCTETS_PER_BYTE;

	      sprintf (data_buffer + data_buffer_size,
",1,unused,811,unused,"	    {
	      if (address == ~(unsigned int) 0)
		address = frag_ptr->fr_address / OCTETS_PER_BYTE;

	      sprintf (data_buffer + data_buffer_size,
",unused,binutils-gas2Flisting.c
"
	      /* @@ Note that this is dependent on the compilation options,
		 not solely on the target characteristics.  */
	      if (sizeof (val) == 4 && sizeof (int) == 4)
		sprintf (buf, ""%08lx"", (unsigned long) val);
",1,unused,950,unused,"
	      /* @@ Note that this is dependent on the compilation options,
		 not solely on the target characteristics.  */
	      if (sizeof (val) == 4 && sizeof (int) == 4)
		sprintf (buf, ""%08lx"", (unsigned long) val);
",unused,binutils-gas2Flisting.c
"	      if (sizeof (val) == 4 && sizeof (int) == 4)
		sprintf (buf, ""%08lx"", (unsigned long) val);
	      else if (sizeof (val) <= sizeof (unsigned long))
		{
		  sprintf (fmt, ""%%0%lulx"",
",1,unused,953,unused,"	      if (sizeof (val) == 4 && sizeof (int) == 4)
		sprintf (buf, ""%08lx"", (unsigned long) val);
	      else if (sizeof (val) <= sizeof (unsigned long))
		{
		  sprintf (fmt, ""%%0%lulx"",
",unused,binutils-gas2Flisting.c
"	      else if (sizeof (val) <= sizeof (unsigned long))
		{
		  sprintf (fmt, ""%%0%lulx"",
			   (unsigned long) (sizeof (val) * 2));
		  sprintf (buf, fmt, (unsigned long) val);
",1,unused,955,unused,"	      else if (sizeof (val) <= sizeof (unsigned long))
		{
		  sprintf (fmt, ""%%0%lulx"",
			   (unsigned long) (sizeof (val) * 2));
		  sprintf (buf, fmt, (unsigned long) val);
",unused,binutils-gas2Flisting.c
"	  idx = (*macro_expr) (_(""% operator needs absolute expression""),
			       idx + 1,
			       in,
			       &val);
	  sprintf (buf, ""%"" BFD_VMA_FMT ""d"", val);
",1,unused,386,unused,"	  idx = (*macro_expr) (_(""% operator needs absolute expression""),
			       idx + 1,
			       in,
			       &val);
	  sprintf (buf, ""%"" BFD_VMA_FMT ""d"", val);
",unused,binutils-gas2Fmacro.c
"		    --in_br;
		  else
		    {
		      br_buf = XNEWVEC (char, strlen (in_br) + 2);
		      strcpy (br_buf + 1, in_br);
",1,unused,442,unused,"		    --in_br;
		  else
		    {
		      br_buf = XNEWVEC (char, strlen (in_br) + 2);
		      strcpy (br_buf + 1, in_br);
",unused,binutils-gas2Fmacro.c
"	      /* Sub in the macro invocation number.  */

	      char buffer[12];
	      src++;
	      sprintf (buffer, ""%d"", macro_number);
",1,unused,847,unused,"	      /* Sub in the macro invocation number.  */

	      char buffer[12];
	      src++;
	      sprintf (buffer, ""%d"", macro_number);
",unused,binutils-gas2Fmacro.c
"		      f->index = LOCAL_INDEX;
		      f->next = loclist;
		      loclist = f;

		      sprintf (buf, IS_ELF ? "".LL%04x"" : ""LL%04x"", ++loccnt);
",1,unused,925,unused,"		      f->index = LOCAL_INDEX;
		      f->next = loclist;
		      loclist = f;

		      sprintf (buf, IS_ELF ? "".LL%04x"" : ""LL%04x"", ++loccnt);
",unused,binutils-gas2Fmacro.c
"
	  sb_reset (&t);
	  sb_add_string (&t, macro_strip_at ? ""$NARG"" : ""NARG"");
	  ptr = (formal_entry *) hash_find (m->formal_hash, sb_terminate (&t));
	  sprintf (buffer, ""%d"", narg);
",1,unused,1198,unused,"
	  sb_reset (&t);
	  sb_add_string (&t, macro_strip_at ? ""$NARG"" : ""NARG"");
	  ptr = (formal_entry *) hash_find (m->formal_hash, sb_terminate (&t));
	  sprintf (buffer, ""%d"", narg);
",unused,binutils-gas2Fmacro.c
"
  if (length > 0)
    {				/* Ordinary case.  */
      p = frag_more (length + 1);
      strcpy (p, string);
",1,unused,118,unused,"
  if (length > 0)
    {				/* Ordinary case.  */
      p = frag_more (length + 1);
      strcpy (p, string);
",unused,binutils-gas2Fstabs.c
"  /* Rather than try to do this in some efficient fashion, we just
     generate a string and then parse it again.  That lets us use the
     existing stabs hook, which expect to see a string, rather than
     inventing new ones.  */
  sprintf (sym, ""%sF%d"", FAKE_LABEL_NAME, label_count);
",1,unused,533,unused,"  /* Rather than try to do this in some efficient fashion, we just
     generate a string and then parse it again.  That lets us use the
     existing stabs hook, which expect to see a string, rather than
     inventing new ones.  */
  sprintf (sym, ""%sF%d"", FAKE_LABEL_NAME, label_count);
",unused,binutils-gas2Fstabs.c
"      if (bslash != NULL)
	*bufp++ = '\\';
    }

  sprintf (bufp, ""\"",%d,0,0,%s\n"", type, sym);
",1,unused,560,unused,"      if (bslash != NULL)
	*bufp++ = '\\';
    }

  sprintf (bufp, ""\"",%d,0,0,%s\n"", type, sym);
",unused,binutils-gas2Fstabs.c
"  outputting_stabs_line_debug = 1;

  generate_asm_file (N_SOL, file);

  sprintf (sym, ""%sL%d"", FAKE_LABEL_NAME, label_count);
",1,unused,627,unused,"  outputting_stabs_line_debug = 1;

  generate_asm_file (N_SOL, file);

  sprintf (sym, ""%sL%d"", FAKE_LABEL_NAME, label_count);
",unused,binutils-gas2Fstabs.c
"
  if (in_dot_func_p)
    {
      buf = XNEWVEC (char, 100 + strlen (current_function_label));
      sprintf (buf, ""%d,0,%d,%s-%s\n"", N_SLINE, lineno,
",1,unused,633,unused,"
  if (in_dot_func_p)
    {
      buf = XNEWVEC (char, 100 + strlen (current_function_label));
      sprintf (buf, ""%d,0,%d,%s-%s\n"", N_SLINE, lineno,
",unused,binutils-gas2Fstabs.c
"    }
  else
    {
      buf = XNEWVEC (char, 100);
      sprintf (buf, ""%d,0,%d,%s\n"", N_SLINE, lineno, sym);
",1,unused,639,unused,"    }
  else
    {
      buf = XNEWVEC (char, 100);
      sprintf (buf, ""%d,0,%d,%s\n"", N_SLINE, lineno, sym);
",unused,binutils-gas2Fstabs.c
"  static int label_count;
  char *buf;
  char sym[30];

  sprintf (sym, ""%sendfunc%d"", FAKE_LABEL_NAME, label_count);
",1,unused,694,unused,"  static int label_count;
  char *buf;
  char sym[30];

  sprintf (sym, ""%sendfunc%d"", FAKE_LABEL_NAME, label_count);
",unused,binutils-gas2Fstabs.c
"    instance_number = (10 * instance_number) + *p - '0';

  message_format = _(""\""%d\"" (instance number %d of a %s label)"");
  symbol_decode = (char *) obstack_alloc (&notes, strlen (message_format) + 30);
  sprintf (symbol_decode, message_format, label_number, instance_number, type);
",1,unused,1949,unused,"    instance_number = (10 * instance_number) + *p - '0';

  message_format = _(""\""%d\"" (instance number %d of a %s label)"");
  symbol_decode = (char *) obstack_alloc (&notes, strlen (message_format) + 30);
  sprintf (symbol_decode, message_format, label_number, instance_number, type);
",unused,binutils-gas2Fsymbols.c
"		  sprint_value (buf, fragP->fr_address + fixP->fx_where);
		  if (add_number > 1000)
		    sprint_value (buf2, add_number);
		  else
		    sprintf (buf2, ""%ld"", (long) add_number);
",1,unused,1112,unused,"		  sprint_value (buf, fragP->fr_address + fixP->fx_where);
		  if (add_number > 1000)
		    sprint_value (buf2, add_number);
		  else
		    sprintf (buf2, ""%ld"", (long) add_number);
",unused,binutils-gas2Fwrite.c
"	 a portion of the previous basic-block, so print that prior
	 execution count (if bb_annotate_all_lines is set).  */
      if (b->is_func)
	{
	  sprintf (p, ""%lu"", b->ncalls);
",1,unused,363,unused,"	 a portion of the previous basic-block, so print that prior
	 execution count (if bb_annotate_all_lines is set).  */
      if (b->is_func)
	{
	  sprintf (p, ""%lu"", b->ncalls);
",unused,binutils-gprof2Fbasic_blocks.c
"	}
      else if (bb_annotate_all_lines
	       && b->bb_addr[0] && b->bb_addr[0] > b->addr)
	{
	  sprintf (p, ""%lu"", last_count);
",1,unused,373,unused,"	}
      else if (bb_annotate_all_lines
	       && b->bb_addr[0] && b->bb_addr[0] > b->addr)
	{
	  sprintf (p, ""%lu"", last_count);
",unused,binutils-gprof2Fbasic_blocks.c
"	    continue;

	  if (p > tmpbuf)
	    *p++ = ',';
	  sprintf (p, ""%lu"", last_count);
",1,unused,399,unused,"	    continue;

	  if (p > tmpbuf)
	    *p++ = ',';
	  sprintf (p, ""%lu"", last_count);
",unused,binutils-gprof2Fbasic_blocks.c
"	 counts were compressed out because they were identical).  */

      if (bb_annotate_all_lines && p == tmpbuf)
	{
	  sprintf (p, ""%lu"", last_count);
",1,unused,413,unused,"	 counts were compressed out because they were identical).  */

      if (bb_annotate_all_lines && p == tmpbuf)
	{
	  sprintf (p, ""%lu"", last_count);
",unused,binutils-gprof2Fbasic_blocks.c
"      ++num_lines_executed;

      if (ncalls < bb_min_calls)
	{
	  strcpy (tmpbuf, ""#####"");
",1,unused,433,unused,"      ++num_lines_executed;

      if (ncalls < bb_min_calls)
	{
	  strcpy (tmpbuf, ""#####"");
",unused,binutils-gprof2Fbasic_blocks.c
"	  strcpy (tmpbuf, ""#####"");
	  p = tmpbuf + 5;
	}

      strcpy (p, "" -> "");
",1,unused,437,unused,"	  strcpy (tmpbuf, ""#####"");
	  p = tmpbuf + 5;
	}

      strcpy (p, "" -> "");
",unused,binutils-gprof2Fbasic_blocks.c
"      else
	{
	  unsigned int c;

	  strcpy (buf + width - len, tmpbuf);
",1,unused,450,unused,"      else
	{
	  unsigned int c;

	  strcpy (buf + width - len, tmpbuf);
",unused,binutils-gprof2Fbasic_blocks.c
"print_cycle (Sym *cyc)
{
  char buf[BUFSIZ];

  sprintf (buf, ""[%d]"", cyc->cg.index);
",1,unused,120,unused,"print_cycle (Sym *cyc)
{
  char buf[BUFSIZ];

  sprintf (buf, ""[%d]"", cyc->cg.index);
",unused,binutils-gprof2Fcg_print.c
"print_line (Sym *np)
{
  char buf[BUFSIZ];

  sprintf (buf, ""[%d]"", np->cg.index);
",1,unused,474,unused,"print_line (Sym *np)
{
  char buf[BUFSIZ];

  sprintf (buf, ""[%d]"", np->cg.index);
",unused,binutils-gprof2Fcg_print.c
"	{
	  sym = name_sorted_syms[j];

	  if (sym->cg.print_flag)
	    sprintf (buf, ""[%d]"", sym->cg.index);
",1,unused,606,unused,"	{
	  sym = name_sorted_syms[j];

	  if (sym->cg.print_flag)
	    sprintf (buf, ""[%d]"", sym->cg.index);
",unused,binutils-gprof2Fcg_print.c
"
	  if (sym->cg.print_flag)
	    sprintf (buf, ""[%d]"", sym->cg.index);
	  else
	    sprintf (buf, ""(%d)"", sym->cg.index);
",1,unused,608,unused,"
	  if (sym->cg.print_flag)
	    sprintf (buf, ""[%d]"", sym->cg.index);
	  else
	    sprintf (buf, ""(%d)"", sym->cg.index);
",unused,binutils-gprof2Fcg_print.c
"	    {
	      if (bsd_style_output)
		{
		  printf (""%6.6s "", buf);
		  sprintf (buf, _(""<cycle %d>""), sym->cg.cyc.num);
",1,unused,650,unused,"	    {
	      if (bsd_style_output)
		{
		  printf (""%6.6s "", buf);
		  sprintf (buf, _(""<cycle %d>""), sym->cg.cyc.num);
",unused,binutils-gprof2Fcg_print.c
"		  col += strlen (buf);
		  for (; col < starting_col + 5; ++col)
		    putchar (' ');
		  printf ("" %s "", buf);
		  sprintf (buf, _(""<cycle %d>""), sym->cg.cyc.num);
",1,unused,659,unused,"		  col += strlen (buf);
		  for (; col < starting_col + 5; ++col)
		    putchar (' ');
		  printf ("" %s "", buf);
		  sprintf (buf, _(""<cycle %d>""), sym->cg.cyc.num);
",unused,binutils-gprof2Fcg_print.c
"	}

      /* dummy has the filename, go ahead and copy it.  */
      symbol_map[count].file_name = (char *) xmalloc (strlen (dummy) + 1);
      strcpy (symbol_map[count].file_name, dummy);
",1,unused,149,unused,"	}

      /* dummy has the filename, go ahead and copy it.  */
      symbol_map[count].file_name = (char *) xmalloc (strlen (dummy) + 1);
      strcpy (symbol_map[count].file_name, dummy);
",unused,binutils-gprof2Fcorefile.c
"      if (!matches)
	parse_error (filename);
      tmp = strrchr (dummy, ' ') + 1;
      symbol_map[count].function_name = (char *) xmalloc (strlen (tmp) + 1);
      strcpy (symbol_map[count].function_name, tmp);
",1,unused,157,unused,"      if (!matches)
	parse_error (filename);
      tmp = strrchr (dummy, ' ') + 1;
      symbol_map[count].function_name = (char *) xmalloc (strlen (tmp) + 1);
      strcpy (symbol_map[count].function_name, tmp);
",unused,binutils-gprof2Fcorefile.c
"
      sscanf (address, ""%"" BFD_VMA_FMT ""x"", &(symtab.limit->addr) );

      symtab.limit->name = (char *) xmalloc (strlen (name) + 1);
      strcpy ((char *) symtab.limit->name, name);
",1,unused,563,unused,"
      sscanf (address, ""%"" BFD_VMA_FMT ""x"", &(symtab.limit->addr) );

      symtab.limit->name = (char *) xmalloc (strlen (name) + 1);
      strcpy ((char *) symtab.limit->name, name);
",unused,binutils-gprof2Fcorefile.c
"	  free (prev_name);
	  prev_name = (char *) xmalloc (prev_name_len);
	}

      strcpy (prev_name, dummy.name);
",1,unused,811,unused,"	  free (prev_name);
	  prev_name = (char *) xmalloc (prev_name_len);
	}

      strcpy (prev_name, dummy.name);
",unused,binutils-gprof2Fcorefile.c
"	  free (prev_filename);
	  prev_filename = (char *) xmalloc (prev_filename_len);
	}

      strcpy (prev_filename, filename);
",1,unused,821,unused,"	  free (prev_filename);
	  prev_filename = (char *) xmalloc (prev_filename_len);
	}

      strcpy (prev_filename, filename);
",unused,binutils-gprof2Fcorefile.c
"print_header (int prefix)
{
  char unit[64];

  sprintf (unit, _(""%c%c/call""), prefix, hist_dimension_abbrev);
",1,unused,466,unused,"print_header (int prefix)
{
  char unit[64];

  sprintf (unit, _(""%c%c/call""), prefix, hist_dimension_abbrev);
",unused,binutils-gprof2Fhist.c
"  id = (struct sym_id *) xmalloc (sizeof (*id) + len + 1);
  memset (id, 0, sizeof (*id));

  id->spec = (char *) id + sizeof (*id);
  strcpy (id->spec, spec);
",1,unused,99,unused,"  id = (struct sym_id *) xmalloc (sizeof (*id) + len + 1);
  memset (id, 0, sizeof (*id));

  id->spec = (char *) id + sizeof (*id);
  strcpy (id->spec, spec);
",unused,binutils-gprof2Fsym_ids.c
"		}
	    }
	  if (line_granularity)
	    {
	      sprintf (buf, "" (%s:%d @ %lx)"", filename, self->line_num,
",1,unused,78,unused,"		}
	    }
	  if (line_granularity)
	    {
	      sprintf (buf, "" (%s:%d @ %lx)"", filename, self->line_num,
",unused,binutils-gprof2Futils.c
"		       (unsigned long) self->addr);
	    }
	  else
	    {
	      sprintf (buf, "" (%s:%d)"", filename, self->line_num);
",1,unused,83,unused,"		       (unsigned long) self->addr);
	    }
	  else
	    {
	      sprintf (buf, "" (%s:%d)"", filename, self->line_num);
",unused,binutils-gprof2Futils.c
"	  memcpy (filename, path, s - path);
	  filename[s - path] = '/';
	  sset = filename + (s - path) + 1;
	}
      strcpy (sset, name);
",1,unused,520,unused,"	  memcpy (filename, path, s - path);
	  filename[s - path] = '/';
	  sset = filename + (s - path) + 1;
	}
      strcpy (sset, name);
",unused,binutils-ld2Feelf32_x86_64.c
"			{
			  char * current_dir = getpwd ();

			  freeme = xmalloc (strlen (replacement) + strlen (current_dir) + 2);
			  sprintf (freeme, ""%s/%s"", current_dir, replacement);
",1,unused,583,unused,"			{
			  char * current_dir = getpwd ();

			  freeme = xmalloc (strlen (replacement) + strlen (current_dir) + 2);
			  sprintf (freeme, ""%s/%s"", current_dir, replacement);
",unused,binutils-ld2Feelf32_x86_64.c
"	      char * filename2 = xmalloc (flen + strlen (replacement));

	      if (end)
		{
		  sprintf (filename2, ""%.*s%s/%s"",
",1,unused,631,unused,"	      char * filename2 = xmalloc (flen + strlen (replacement));

	      if (end)
		{
		  sprintf (filename2, ""%.*s%s/%s"",
",unused,binutils-ld2Feelf32_x86_64.c
"		  offset = (var - filename) + 1 + strlen (replacement);
		}
	      else
		{
		  sprintf (filename2, ""%.*s%s"",
",1,unused,638,unused,"		  offset = (var - filename) + 1 + strlen (replacement);
		}
	      else
		{
		  sprintf (filename2, ""%.*s%s"",
",unused,binutils-ld2Feelf32_x86_64.c
"		  && ld_sysroot[0] == p[-2])))
	{
	  if (dos_drive && dos_drive_sysroot)
	    {
	      strcpy (q, ld_sysroot + 2);
",1,unused,740,unused,"		  && ld_sysroot[0] == p[-2])))
	{
	  if (dos_drive && dos_drive_sysroot)
	    {
	      strcpy (q, ld_sysroot + 2);
",unused,binutils-ld2Feelf32_x86_64.c
"	      q += len - 2;
	    }
	  else
	    {
	      strcpy (q, ld_sysroot);
",1,unused,745,unused,"	      q += len - 2;
	    }
	  else
	    {
	      strcpy (q, ld_sysroot);
",unused,binutils-ld2Feelf32_x86_64.c
"	  p += n;
	}
      else
	{
	  strcpy (q, p);
",1,unused,759,unused,"	  p += n;
	}
      else
	{
	  strcpy (q, p);
",unused,binutils-ld2Feelf32_x86_64.c
"
	      if (search->cmdline)
		continue;
	      filename = (char *) xmalloc (strlen (search->name) + len + 2);
	      sprintf (filename, ""%s/%s"", search->name, l->name);
",1,unused,1396,unused,"
	      if (search->cmdline)
		continue;
	      filename = (char *) xmalloc (strlen (search->name) + len + 2);
	      sprintf (filename, ""%s/%s"", search->name, l->name);
",unused,binutils-ld2Feelf32_x86_64.c
"
      if (cp == NULL)
	{
	  buf = xmalloc (to_len + op_arg_len + 2);
	  sprintf (buf, ""%s%c%s"", *to,
",1,unused,1519,unused,"
      if (cp == NULL)
	{
	  buf = xmalloc (to_len + op_arg_len + 2);
	  sprintf (buf, ""%s%c%s"", *to,
",unused,binutils-ld2Feelf32_x86_64.c
"  if (entry->flags.full_name_provided)
    {
      len += sizeof ""/"";
      string = (char *) xmalloc (len);
      sprintf (string, ""%s/%s"", search->name, filename);
",1,unused,1730,unused,"  if (entry->flags.full_name_provided)
    {
      len += sizeof ""/"";
      string = (char *) xmalloc (len);
      sprintf (string, ""%s/%s"", search->name, filename);
",unused,binutils-ld2Feelf32_x86_64.c
"	      ? strlen (EXTRA_SHLIB_EXTENSION) - 3
	      : 0);
#endif
      string = (char *) xmalloc (len + xlen);
      sprintf (string, ""%s/lib%s%s.so"", search->name, filename, arch);
",1,unused,1743,unused,"	      ? strlen (EXTRA_SHLIB_EXTENSION) - 3
	      : 0);
#endif
      string = (char *) xmalloc (len + xlen);
      sprintf (string, ""%s/lib%s%s.so"", search->name, filename, arch);
",unused,binutils-ld2Feelf32_x86_64.c
"	  memcpy (filename, path, s - path);
	  filename[s - path] = '/';
	  sset = filename + (s - path) + 1;
	}
      strcpy (sset, name);
",1,unused,520,unused,"	  memcpy (filename, path, s - path);
	  filename[s - path] = '/';
	  sset = filename + (s - path) + 1;
	}
      strcpy (sset, name);
",unused,binutils-ld2Feelf_i386.c
"			{
			  char * current_dir = getpwd ();

			  freeme = xmalloc (strlen (replacement) + strlen (current_dir) + 2);
			  sprintf (freeme, ""%s/%s"", current_dir, replacement);
",1,unused,583,unused,"			{
			  char * current_dir = getpwd ();

			  freeme = xmalloc (strlen (replacement) + strlen (current_dir) + 2);
			  sprintf (freeme, ""%s/%s"", current_dir, replacement);
",unused,binutils-ld2Feelf_i386.c
"	      char * filename2 = xmalloc (flen + strlen (replacement));

	      if (end)
		{
		  sprintf (filename2, ""%.*s%s/%s"",
",1,unused,631,unused,"	      char * filename2 = xmalloc (flen + strlen (replacement));

	      if (end)
		{
		  sprintf (filename2, ""%.*s%s/%s"",
",unused,binutils-ld2Feelf_i386.c
"		  offset = (var - filename) + 1 + strlen (replacement);
		}
	      else
		{
		  sprintf (filename2, ""%.*s%s"",
",1,unused,638,unused,"		  offset = (var - filename) + 1 + strlen (replacement);
		}
	      else
		{
		  sprintf (filename2, ""%.*s%s"",
",unused,binutils-ld2Feelf_i386.c
"		  && ld_sysroot[0] == p[-2])))
	{
	  if (dos_drive && dos_drive_sysroot)
	    {
	      strcpy (q, ld_sysroot + 2);
",1,unused,740,unused,"		  && ld_sysroot[0] == p[-2])))
	{
	  if (dos_drive && dos_drive_sysroot)
	    {
	      strcpy (q, ld_sysroot + 2);
",unused,binutils-ld2Feelf_i386.c
"	      q += len - 2;
	    }
	  else
	    {
	      strcpy (q, ld_sysroot);
",1,unused,745,unused,"	      q += len - 2;
	    }
	  else
	    {
	      strcpy (q, ld_sysroot);
",unused,binutils-ld2Feelf_i386.c
"	  p += n;
	}
      else
	{
	  strcpy (q, p);
",1,unused,759,unused,"	  p += n;
	}
      else
	{
	  strcpy (q, p);
",unused,binutils-ld2Feelf_i386.c
"
	      if (search->cmdline)
		continue;
	      filename = (char *) xmalloc (strlen (search->name) + len + 2);
	      sprintf (filename, ""%s/%s"", search->name, l->name);
",1,unused,1396,unused,"
	      if (search->cmdline)
		continue;
	      filename = (char *) xmalloc (strlen (search->name) + len + 2);
	      sprintf (filename, ""%s/%s"", search->name, l->name);
",unused,binutils-ld2Feelf_i386.c
"
      if (cp == NULL)
	{
	  buf = xmalloc (to_len + op_arg_len + 2);
	  sprintf (buf, ""%s%c%s"", *to,
",1,unused,1519,unused,"
      if (cp == NULL)
	{
	  buf = xmalloc (to_len + op_arg_len + 2);
	  sprintf (buf, ""%s%c%s"", *to,
",unused,binutils-ld2Feelf_i386.c
"  if (entry->flags.full_name_provided)
    {
      len += sizeof ""/"";
      string = (char *) xmalloc (len);
      sprintf (string, ""%s/%s"", search->name, filename);
",1,unused,1730,unused,"  if (entry->flags.full_name_provided)
    {
      len += sizeof ""/"";
      string = (char *) xmalloc (len);
      sprintf (string, ""%s/%s"", search->name, filename);
",unused,binutils-ld2Feelf_i386.c
"	      ? strlen (EXTRA_SHLIB_EXTENSION) - 3
	      : 0);
#endif
      string = (char *) xmalloc (len + xlen);
      sprintf (string, ""%s/lib%s%s.so"", search->name, filename, arch);
",1,unused,1743,unused,"	      ? strlen (EXTRA_SHLIB_EXTENSION) - 3
	      : 0);
#endif
      string = (char *) xmalloc (len + xlen);
      sprintf (string, ""%s/lib%s%s.so"", search->name, filename, arch);
",unused,binutils-ld2Feelf_i386.c
"	  memcpy (filename, path, s - path);
	  filename[s - path] = '/';
	  sset = filename + (s - path) + 1;
	}
      strcpy (sset, name);
",1,unused,517,unused,"	  memcpy (filename, path, s - path);
	  filename[s - path] = '/';
	  sset = filename + (s - path) + 1;
	}
      strcpy (sset, name);
",unused,binutils-ld2Feelf_iamcu.c
"			{
			  char * current_dir = getpwd ();

			  freeme = xmalloc (strlen (replacement) + strlen (current_dir) + 2);
			  sprintf (freeme, ""%s/%s"", current_dir, replacement);
",1,unused,580,unused,"			{
			  char * current_dir = getpwd ();

			  freeme = xmalloc (strlen (replacement) + strlen (current_dir) + 2);
			  sprintf (freeme, ""%s/%s"", current_dir, replacement);
",unused,binutils-ld2Feelf_iamcu.c
"	      char * filename2 = xmalloc (flen + strlen (replacement));

	      if (end)
		{
		  sprintf (filename2, ""%.*s%s/%s"",
",1,unused,628,unused,"	      char * filename2 = xmalloc (flen + strlen (replacement));

	      if (end)
		{
		  sprintf (filename2, ""%.*s%s/%s"",
",unused,binutils-ld2Feelf_iamcu.c
"		  offset = (var - filename) + 1 + strlen (replacement);
		}
	      else
		{
		  sprintf (filename2, ""%.*s%s"",
",1,unused,635,unused,"		  offset = (var - filename) + 1 + strlen (replacement);
		}
	      else
		{
		  sprintf (filename2, ""%.*s%s"",
",unused,binutils-ld2Feelf_iamcu.c
"
	      if (search->cmdline)
		continue;
	      filename = (char *) xmalloc (strlen (search->name) + len + 2);
	      sprintf (filename, ""%s/%s"", search->name, l->name);
",1,unused,1064,unused,"
	      if (search->cmdline)
		continue;
	      filename = (char *) xmalloc (strlen (search->name) + len + 2);
	      sprintf (filename, ""%s/%s"", search->name, l->name);
",unused,binutils-ld2Feelf_iamcu.c
"
      if (cp == NULL)
	{
	  buf = xmalloc (to_len + op_arg_len + 2);
	  sprintf (buf, ""%s%c%s"", *to,
",1,unused,1187,unused,"
      if (cp == NULL)
	{
	  buf = xmalloc (to_len + op_arg_len + 2);
	  sprintf (buf, ""%s%c%s"", *to,
",unused,binutils-ld2Feelf_iamcu.c
"  if (entry->flags.full_name_provided)
    {
      len += sizeof ""/"";
      string = (char *) xmalloc (len);
      sprintf (string, ""%s/%s"", search->name, filename);
",1,unused,1398,unused,"  if (entry->flags.full_name_provided)
    {
      len += sizeof ""/"";
      string = (char *) xmalloc (len);
      sprintf (string, ""%s/%s"", search->name, filename);
",unused,binutils-ld2Feelf_iamcu.c
"	      ? strlen (EXTRA_SHLIB_EXTENSION) - 3
	      : 0);
#endif
      string = (char *) xmalloc (len + xlen);
      sprintf (string, ""%s/lib%s%s.so"", search->name, filename, arch);
",1,unused,1411,unused,"	      ? strlen (EXTRA_SHLIB_EXTENSION) - 3
	      : 0);
#endif
      string = (char *) xmalloc (len + xlen);
      sprintf (string, ""%s/lib%s%s.so"", search->name, filename, arch);
",unused,binutils-ld2Feelf_iamcu.c
"	  memcpy (filename, path, s - path);
	  filename[s - path] = '/';
	  sset = filename + (s - path) + 1;
	}
      strcpy (sset, name);
",1,unused,520,unused,"	  memcpy (filename, path, s - path);
	  filename[s - path] = '/';
	  sset = filename + (s - path) + 1;
	}
      strcpy (sset, name);
",unused,binutils-ld2Feelf_k1om.c
"			{
			  char * current_dir = getpwd ();

			  freeme = xmalloc (strlen (replacement) + strlen (current_dir) + 2);
			  sprintf (freeme, ""%s/%s"", current_dir, replacement);
",1,unused,583,unused,"			{
			  char * current_dir = getpwd ();

			  freeme = xmalloc (strlen (replacement) + strlen (current_dir) + 2);
			  sprintf (freeme, ""%s/%s"", current_dir, replacement);
",unused,binutils-ld2Feelf_k1om.c
"	      char * filename2 = xmalloc (flen + strlen (replacement));

	      if (end)
		{
		  sprintf (filename2, ""%.*s%s/%s"",
",1,unused,631,unused,"	      char * filename2 = xmalloc (flen + strlen (replacement));

	      if (end)
		{
		  sprintf (filename2, ""%.*s%s/%s"",
",unused,binutils-ld2Feelf_k1om.c
"		  offset = (var - filename) + 1 + strlen (replacement);
		}
	      else
		{
		  sprintf (filename2, ""%.*s%s"",
",1,unused,638,unused,"		  offset = (var - filename) + 1 + strlen (replacement);
		}
	      else
		{
		  sprintf (filename2, ""%.*s%s"",
",unused,binutils-ld2Feelf_k1om.c
"		  && ld_sysroot[0] == p[-2])))
	{
	  if (dos_drive && dos_drive_sysroot)
	    {
	      strcpy (q, ld_sysroot + 2);
",1,unused,740,unused,"		  && ld_sysroot[0] == p[-2])))
	{
	  if (dos_drive && dos_drive_sysroot)
	    {
	      strcpy (q, ld_sysroot + 2);
",unused,binutils-ld2Feelf_k1om.c
"	      q += len - 2;
	    }
	  else
	    {
	      strcpy (q, ld_sysroot);
",1,unused,745,unused,"	      q += len - 2;
	    }
	  else
	    {
	      strcpy (q, ld_sysroot);
",unused,binutils-ld2Feelf_k1om.c
"	  p += n;
	}
      else
	{
	  strcpy (q, p);
",1,unused,759,unused,"	  p += n;
	}
      else
	{
	  strcpy (q, p);
",unused,binutils-ld2Feelf_k1om.c
"
	      if (search->cmdline)
		continue;
	      filename = (char *) xmalloc (strlen (search->name) + len + 2);
	      sprintf (filename, ""%s/%s"", search->name, l->name);
",1,unused,1396,unused,"
	      if (search->cmdline)
		continue;
	      filename = (char *) xmalloc (strlen (search->name) + len + 2);
	      sprintf (filename, ""%s/%s"", search->name, l->name);
",unused,binutils-ld2Feelf_k1om.c
"
      if (cp == NULL)
	{
	  buf = xmalloc (to_len + op_arg_len + 2);
	  sprintf (buf, ""%s%c%s"", *to,
",1,unused,1519,unused,"
      if (cp == NULL)
	{
	  buf = xmalloc (to_len + op_arg_len + 2);
	  sprintf (buf, ""%s%c%s"", *to,
",unused,binutils-ld2Feelf_k1om.c
"  if (entry->flags.full_name_provided)
    {
      len += sizeof ""/"";
      string = (char *) xmalloc (len);
      sprintf (string, ""%s/%s"", search->name, filename);
",1,unused,1730,unused,"  if (entry->flags.full_name_provided)
    {
      len += sizeof ""/"";
      string = (char *) xmalloc (len);
      sprintf (string, ""%s/%s"", search->name, filename);
",unused,binutils-ld2Feelf_k1om.c
"	      ? strlen (EXTRA_SHLIB_EXTENSION) - 3
	      : 0);
#endif
      string = (char *) xmalloc (len + xlen);
      sprintf (string, ""%s/lib%s%s.so"", search->name, filename, arch);
",1,unused,1743,unused,"	      ? strlen (EXTRA_SHLIB_EXTENSION) - 3
	      : 0);
#endif
      string = (char *) xmalloc (len + xlen);
      sprintf (string, ""%s/lib%s%s.so"", search->name, filename, arch);
",unused,binutils-ld2Feelf_k1om.c
"	  memcpy (filename, path, s - path);
	  filename[s - path] = '/';
	  sset = filename + (s - path) + 1;
	}
      strcpy (sset, name);
",1,unused,520,unused,"	  memcpy (filename, path, s - path);
	  filename[s - path] = '/';
	  sset = filename + (s - path) + 1;
	}
      strcpy (sset, name);
",unused,binutils-ld2Feelf_l1om.c
"			{
			  char * current_dir = getpwd ();

			  freeme = xmalloc (strlen (replacement) + strlen (current_dir) + 2);
			  sprintf (freeme, ""%s/%s"", current_dir, replacement);
",1,unused,583,unused,"			{
			  char * current_dir = getpwd ();

			  freeme = xmalloc (strlen (replacement) + strlen (current_dir) + 2);
			  sprintf (freeme, ""%s/%s"", current_dir, replacement);
",unused,binutils-ld2Feelf_l1om.c
"	      char * filename2 = xmalloc (flen + strlen (replacement));

	      if (end)
		{
		  sprintf (filename2, ""%.*s%s/%s"",
",1,unused,631,unused,"	      char * filename2 = xmalloc (flen + strlen (replacement));

	      if (end)
		{
		  sprintf (filename2, ""%.*s%s/%s"",
",unused,binutils-ld2Feelf_l1om.c
"		  offset = (var - filename) + 1 + strlen (replacement);
		}
	      else
		{
		  sprintf (filename2, ""%.*s%s"",
",1,unused,638,unused,"		  offset = (var - filename) + 1 + strlen (replacement);
		}
	      else
		{
		  sprintf (filename2, ""%.*s%s"",
",unused,binutils-ld2Feelf_l1om.c
"		  && ld_sysroot[0] == p[-2])))
	{
	  if (dos_drive && dos_drive_sysroot)
	    {
	      strcpy (q, ld_sysroot + 2);
",1,unused,740,unused,"		  && ld_sysroot[0] == p[-2])))
	{
	  if (dos_drive && dos_drive_sysroot)
	    {
	      strcpy (q, ld_sysroot + 2);
",unused,binutils-ld2Feelf_l1om.c
"	      q += len - 2;
	    }
	  else
	    {
	      strcpy (q, ld_sysroot);
",1,unused,745,unused,"	      q += len - 2;
	    }
	  else
	    {
	      strcpy (q, ld_sysroot);
",unused,binutils-ld2Feelf_l1om.c
"	  p += n;
	}
      else
	{
	  strcpy (q, p);
",1,unused,759,unused,"	  p += n;
	}
      else
	{
	  strcpy (q, p);
",unused,binutils-ld2Feelf_l1om.c
"
	      if (search->cmdline)
		continue;
	      filename = (char *) xmalloc (strlen (search->name) + len + 2);
	      sprintf (filename, ""%s/%s"", search->name, l->name);
",1,unused,1396,unused,"
	      if (search->cmdline)
		continue;
	      filename = (char *) xmalloc (strlen (search->name) + len + 2);
	      sprintf (filename, ""%s/%s"", search->name, l->name);
",unused,binutils-ld2Feelf_l1om.c
"
      if (cp == NULL)
	{
	  buf = xmalloc (to_len + op_arg_len + 2);
	  sprintf (buf, ""%s%c%s"", *to,
",1,unused,1519,unused,"
      if (cp == NULL)
	{
	  buf = xmalloc (to_len + op_arg_len + 2);
	  sprintf (buf, ""%s%c%s"", *to,
",unused,binutils-ld2Feelf_l1om.c
"  if (entry->flags.full_name_provided)
    {
      len += sizeof ""/"";
      string = (char *) xmalloc (len);
      sprintf (string, ""%s/%s"", search->name, filename);
",1,unused,1730,unused,"  if (entry->flags.full_name_provided)
    {
      len += sizeof ""/"";
      string = (char *) xmalloc (len);
      sprintf (string, ""%s/%s"", search->name, filename);
",unused,binutils-ld2Feelf_l1om.c
"	      ? strlen (EXTRA_SHLIB_EXTENSION) - 3
	      : 0);
#endif
      string = (char *) xmalloc (len + xlen);
      sprintf (string, ""%s/lib%s%s.so"", search->name, filename, arch);
",1,unused,1743,unused,"	      ? strlen (EXTRA_SHLIB_EXTENSION) - 3
	      : 0);
#endif
      string = (char *) xmalloc (len + xlen);
      sprintf (string, ""%s/lib%s%s.so"", search->name, filename, arch);
",unused,binutils-ld2Feelf_l1om.c
"	  memcpy (filename, path, s - path);
	  filename[s - path] = '/';
	  sset = filename + (s - path) + 1;
	}
      strcpy (sset, name);
",1,unused,520,unused,"	  memcpy (filename, path, s - path);
	  filename[s - path] = '/';
	  sset = filename + (s - path) + 1;
	}
      strcpy (sset, name);
",unused,binutils-ld2Feelf_x86_64.c
"			{
			  char * current_dir = getpwd ();

			  freeme = xmalloc (strlen (replacement) + strlen (current_dir) + 2);
			  sprintf (freeme, ""%s/%s"", current_dir, replacement);
",1,unused,583,unused,"			{
			  char * current_dir = getpwd ();

			  freeme = xmalloc (strlen (replacement) + strlen (current_dir) + 2);
			  sprintf (freeme, ""%s/%s"", current_dir, replacement);
",unused,binutils-ld2Feelf_x86_64.c
"	      char * filename2 = xmalloc (flen + strlen (replacement));

	      if (end)
		{
		  sprintf (filename2, ""%.*s%s/%s"",
",1,unused,631,unused,"	      char * filename2 = xmalloc (flen + strlen (replacement));

	      if (end)
		{
		  sprintf (filename2, ""%.*s%s/%s"",
",unused,binutils-ld2Feelf_x86_64.c
"		  offset = (var - filename) + 1 + strlen (replacement);
		}
	      else
		{
		  sprintf (filename2, ""%.*s%s"",
",1,unused,638,unused,"		  offset = (var - filename) + 1 + strlen (replacement);
		}
	      else
		{
		  sprintf (filename2, ""%.*s%s"",
",unused,binutils-ld2Feelf_x86_64.c
"		  && ld_sysroot[0] == p[-2])))
	{
	  if (dos_drive && dos_drive_sysroot)
	    {
	      strcpy (q, ld_sysroot + 2);
",1,unused,740,unused,"		  && ld_sysroot[0] == p[-2])))
	{
	  if (dos_drive && dos_drive_sysroot)
	    {
	      strcpy (q, ld_sysroot + 2);
",unused,binutils-ld2Feelf_x86_64.c
"	      q += len - 2;
	    }
	  else
	    {
	      strcpy (q, ld_sysroot);
",1,unused,745,unused,"	      q += len - 2;
	    }
	  else
	    {
	      strcpy (q, ld_sysroot);
",unused,binutils-ld2Feelf_x86_64.c
"	  p += n;
	}
      else
	{
	  strcpy (q, p);
",1,unused,759,unused,"	  p += n;
	}
      else
	{
	  strcpy (q, p);
",unused,binutils-ld2Feelf_x86_64.c
"
	      if (search->cmdline)
		continue;
	      filename = (char *) xmalloc (strlen (search->name) + len + 2);
	      sprintf (filename, ""%s/%s"", search->name, l->name);
",1,unused,1396,unused,"
	      if (search->cmdline)
		continue;
	      filename = (char *) xmalloc (strlen (search->name) + len + 2);
	      sprintf (filename, ""%s/%s"", search->name, l->name);
",unused,binutils-ld2Feelf_x86_64.c
"
      if (cp == NULL)
	{
	  buf = xmalloc (to_len + op_arg_len + 2);
	  sprintf (buf, ""%s%c%s"", *to,
",1,unused,1519,unused,"
      if (cp == NULL)
	{
	  buf = xmalloc (to_len + op_arg_len + 2);
	  sprintf (buf, ""%s%c%s"", *to,
",unused,binutils-ld2Feelf_x86_64.c
"  if (entry->flags.full_name_provided)
    {
      len += sizeof ""/"";
      string = (char *) xmalloc (len);
      sprintf (string, ""%s/%s"", search->name, filename);
",1,unused,1730,unused,"  if (entry->flags.full_name_provided)
    {
      len += sizeof ""/"";
      string = (char *) xmalloc (len);
      sprintf (string, ""%s/%s"", search->name, filename);
",unused,binutils-ld2Feelf_x86_64.c
"	      ? strlen (EXTRA_SHLIB_EXTENSION) - 3
	      : 0);
#endif
      string = (char *) xmalloc (len + xlen);
      sprintf (string, ""%s/lib%s%s.so"", search->name, filename, arch);
",1,unused,1743,unused,"	      ? strlen (EXTRA_SHLIB_EXTENSION) - 3
	      : 0);
#endif
      string = (char *) xmalloc (len + xlen);
      sprintf (string, ""%s/lib%s%s.so"", search->name, filename, arch);
",unused,binutils-ld2Feelf_x86_64.c
"	  {
	    char *symbol = (char *) xmalloc (10 + strlen (secname));

	    symbol[0] = leading_char;
	    sprintf (symbol + (leading_char != 0), ""__start_%s"", secname);
",1,unused,6054,unused,"	  {
	    char *symbol = (char *) xmalloc (10 + strlen (secname));

	    symbol[0] = leading_char;
	    sprintf (symbol + (leading_char != 0), ""__start_%s"", secname);
",unused,binutils-ld2Fldlang.c
"    {
      const char *secname = s->name;
      char *symbol = (char *) xmalloc (10 + strlen (secname));

      sprintf (symbol, "".startof.%s"", secname);
",1,unused,6119,unused,"    {
      const char *secname = s->name;
      char *symbol = (char *) xmalloc (10 + strlen (secname));

      sprintf (symbol, "".startof.%s"", secname);
",unused,binutils-ld2Fldlang.c
"	}

      minfo (""0x"");
      if (size <= 0xffffffff)
	sprintf (buf, ""%lx"", (unsigned long) size);
",1,unused,6447,unused,"	}

      minfo (""0x"");
      if (size <= 0xffffffff)
	sprintf (buf, ""%lx"", (unsigned long) size);
",unused,binutils-ld2Fldlang.c
"      *s2++ = *s1;
  *s2 = '\0';

  buf = (char *) xmalloc (strlen (clean) + sizeof ""__load_start_"");
  sprintf (buf, ""__load_start_%s"", clean);
",1,unused,8022,unused,"      *s2++ = *s1;
  *s2 = '\0';

  buf = (char *) xmalloc (strlen (clean) + sizeof ""__load_start_"");
  sprintf (buf, ""__load_start_%s"", clean);
",unused,binutils-ld2Fldlang.c
"				    exp_nameop (LOADADDR, name),
				    FALSE));

  buf = (char *) xmalloc (strlen (clean) + sizeof ""__load_stop_"");
  sprintf (buf, ""__load_stop_%s"", clean);
",1,unused,8028,unused,"				    exp_nameop (LOADADDR, name),
				    FALSE));

  buf = (char *) xmalloc (strlen (clean) + sizeof ""__load_stop_"");
  sprintf (buf, ""__load_stop_%s"", clean);
",unused,binutils-ld2Fldlang.c
"     we need to put in 2 end-of-buffer characters.  */
  b->yy_ch_buf = malloc ((unsigned) (b->yy_buf_size + 3));

  b->yy_ch_buf[0] = '\n';
  strcpy (b->yy_ch_buf+1, string);
",1,unused,4278,unused,"     we need to put in 2 end-of-buffer characters.  */
  b->yy_ch_buf = malloc ((unsigned) (b->yy_buf_size + 3));

  b->yy_ch_buf[0] = '\n';
  strcpy (b->yy_ch_buf+1, string);
",unused,binutils-ld2Fldlex.c
"    }

  if (! ISPRINT (*what))
    {
      sprintf (buf, ""\\%03o"", *(unsigned char *) what);
",1,unused,4476,unused,"    }

  if (! ISPRINT (*what))
    {
      sprintf (buf, ""\\%03o"", *(unsigned char *) what);
",unused,binutils-ld2Fldlex.c
"	      char *buf = (char *) xmalloc (bsize);
	      int l;
	      char *dst_name = (char *) xmalloc (len + 5);

	      strcpy (dst_name, output_filename);
",1,unused,511,unused,"	      char *buf = (char *) xmalloc (bsize);
	      int l;
	      char *dst_name = (char *) xmalloc (len + 5);

	      strcpy (dst_name, output_filename);
",unused,binutils-ld2Fldmain.c
"	      int l;
	      char *dst_name = (char *) xmalloc (len + 5);

	      strcpy (dst_name, output_filename);
	      strcat (dst_name, "".exe"");
",1,unused,512,unused,"	      int l;
	      char *dst_name = (char *) xmalloc (len + 5);

	      strcpy (dst_name, output_filename);
	      strcat (dst_name, "".exe"");
",unused,binutils-ld2Fldmain.c
"  s = set_name;
  if (bfd_get_symbol_leading_char (abfd) != '\0')
    *s++ = bfd_get_symbol_leading_char (abfd);
  if (constructor)
    strcpy (s, ""__CTOR_LIST__"");
",1,unused,1172,unused,"  s = set_name;
  if (bfd_get_symbol_leading_char (abfd) != '\0')
    *s++ = bfd_get_symbol_leading_char (abfd);
  if (constructor)
    strcpy (s, ""__CTOR_LIST__"");
",unused,binutils-ld2Fldmain.c
"    *s++ = bfd_get_symbol_leading_char (abfd);
  if (constructor)
    strcpy (s, ""__CTOR_LIST__"");
  else
    strcpy (s, ""__DTOR_LIST__"");
",1,unused,1174,unused,"    *s++ = bfd_get_symbol_leading_char (abfd);
  if (constructor)
    strcpy (s, ""__CTOR_LIST__"");
  else
    strcpy (s, ""__DTOR_LIST__"");
",unused,binutils-ld2Fldmain.c
"	{
	  char *n;

	  n = (char *) xmalloc (strlen (argv[i]) + 20);
	  sprintf (n, ""--library=%s"", argv[i] + 2);
",1,unused,653,unused,"	{
	  char *n;

	  n = (char *) xmalloc (strlen (argv[i]) + 20);
	  sprintf (n, ""--library=%s"", argv[i] + 2);
",unused,binutils-ld2Flexsup.c
"
	      if (cp == NULL)
		{
		  buf = (char *) xmalloc (rpath_len + optarg_len + 2);
		  sprintf (buf, ""%s%c%s"", command_line.rpath,
",1,unused,1123,unused,"
	      if (cp == NULL)
		{
		  buf = (char *) xmalloc (rpath_len + optarg_len + 2);
		  sprintf (buf, ""%s%c%s"", command_line.rpath,
",unused,binutils-ld2Flexsup.c
"
	      buf = (char *) xmalloc (strlen (command_line.rpath_link)
				      + strlen (optarg)
				      + 2);
	      sprintf (buf, ""%s%c%s"", command_line.rpath_link,
",1,unused,1140,unused,"
	      buf = (char *) xmalloc (strlen (command_line.rpath_link)
				      + strlen (optarg)
				      + 2);
	      sprintf (buf, ""%s%c%s"", command_line.rpath_link,
",unused,binutils-ld2Flexsup.c
"    {
      char buf[20];

      /* Some sections are digits.  */
      sprintf (buf, ""%d"", isn);
",1,unused,265,unused,"    {
      char buf[20];

      /* Some sections are digits.  */
      sprintf (buf, ""%d"", isn);
",unused,binutils-ld2Fmri.c
"    {
      sym->comdat_key = malloc (strlen (colon5 + 1) + 1);
      if (!sym->comdat_key)
	return LDPS_ERR;
      strcpy (sym->comdat_key, colon5 + 1);
",1,unused,269,unused,"    {
      sym->comdat_key = malloc (strlen (colon5 + 1) + 1);
      if (!sym->comdat_key)
	return LDPS_ERR;
      strcpy (sym->comdat_key, colon5 + 1);
",unused,binutils-ld2Ftestplug.c
"
  for (tag = 0; tag < ARRAY_SIZE (tag_names); tag++)
    if (tag_names[tag].tag == tv->tv_tag)
      break;
  sprintf (unknownbuf, ""unknown tag #%d"", tv->tv_tag);
",1,unused,381,unused,"
  for (tag = 0; tag < ARRAY_SIZE (tag_names); tag++)
    if (tag_names[tag].tag == tv->tv_tag)
      break;
  sprintf (unknownbuf, ""unknown tag #%d"", tv->tv_tag);
",unused,binutils-ld2Ftestplug.c
"    {
      sym->comdat_key = malloc (strlen (colon5 + 1) + 1);
      if (!sym->comdat_key)
	return LDPS_ERR;
      strcpy (sym->comdat_key, colon5 + 1);
",1,unused,248,unused,"    {
      sym->comdat_key = malloc (strlen (colon5 + 1) + 1);
      if (!sym->comdat_key)
	return LDPS_ERR;
      strcpy (sym->comdat_key, colon5 + 1);
",unused,binutils-ld2Ftestplug2.c
"    {
      sym->comdat_key = malloc (strlen (colon5 + 1) + 1);
      if (!sym->comdat_key)
	return LDPS_ERR;
      strcpy (sym->comdat_key, colon5 + 1);
",1,unused,247,unused,"    {
      sym->comdat_key = malloc (strlen (colon5 + 1) + 1);
      if (!sym->comdat_key)
	return LDPS_ERR;
      strcpy (sym->comdat_key, colon5 + 1);
",unused,binutils-ld2Ftestplug3.c
"    {
      sym->comdat_key = malloc (strlen (colon5 + 1) + 1);
      if (!sym->comdat_key)
	return LDPS_ERR;
      strcpy (sym->comdat_key, colon5 + 1);
",1,unused,248,unused,"    {
      sym->comdat_key = malloc (strlen (colon5 + 1) + 1);
      if (!sym->comdat_key)
	return LDPS_ERR;
      strcpy (sym->comdat_key, colon5 + 1);
",unused,binutils-ld2Ftestplug4.c
"static inline void
d_append_num (struct d_print_info *dpi, int l)
{
  char buf[25];
  sprintf (buf,""%d"", l);
",1,unused,4258,unused,"static inline void
d_append_num (struct d_print_info *dpi, int l)
{
  char buf[25];
  sprintf (buf,""%d"", l);
",unused,binutils-libiberty2Fcp-demangle.c
"      /* type conversion operator.  */
      tem = opname + 4;
      if (do_type (work, &tem, &type))
	{
	  strcat (result, ""operator "");
",1,unused,675,unused,"      /* type conversion operator.  */
      tem = opname + 4;
      if (do_type (work, &tem, &type))
	{
	  strcat (result, ""operator "");
",unused,binutils-libiberty2Fcplus-dem.c
"	    {
	      if (strlen (optable[i].in) == 2
		  && memcmp (optable[i].in, opname + 2, 2) == 0)
		{
		  strcat (result, ""operator"");
",1,unused,694,unused,"	    {
	      if (strlen (optable[i].in) == 2
		  && memcmp (optable[i].in, opname + 2, 2) == 0)
		{
		  strcat (result, ""operator"");
",unused,binutils-libiberty2Fcplus-dem.c
"	      if (strlen (optable[i].in) == 2
		  && memcmp (optable[i].in, opname + 2, 2) == 0)
		{
		  strcat (result, ""operator"");
		  strcat (result, optable[i].out);
",1,unused,695,unused,"	      if (strlen (optable[i].in) == 2
		  && memcmp (optable[i].in, opname + 2, 2) == 0)
		{
		  strcat (result, ""operator"");
		  strcat (result, optable[i].out);
",unused,binutils-libiberty2Fcplus-dem.c
"		{
		  if (strlen (optable[i].in) == 3
		      && memcmp (optable[i].in, opname + 2, 3) == 0)
		    {
		      strcat (result, ""operator"");
",1,unused,712,unused,"		{
		  if (strlen (optable[i].in) == 3
		      && memcmp (optable[i].in, opname + 2, 3) == 0)
		    {
		      strcat (result, ""operator"");
",unused,binutils-libiberty2Fcplus-dem.c
"		  if (strlen (optable[i].in) == 3
		      && memcmp (optable[i].in, opname + 2, 3) == 0)
		    {
		      strcat (result, ""operator"");
		      strcat (result, optable[i].out);
",1,unused,713,unused,"		  if (strlen (optable[i].in) == 3
		      && memcmp (optable[i].in, opname + 2, 3) == 0)
		    {
		      strcat (result, ""operator"");
		      strcat (result, optable[i].out);
",unused,binutils-libiberty2Fcplus-dem.c
"	      len1 = len - 10;
	      if ((int) strlen (optable[i].in) == len1
		  && memcmp (optable[i].in, opname + 10, len1) == 0)
		{
		  strcat (result, ""operator"");
",1,unused,737,unused,"	      len1 = len - 10;
	      if ((int) strlen (optable[i].in) == len1
		  && memcmp (optable[i].in, opname + 10, len1) == 0)
		{
		  strcat (result, ""operator"");
",unused,binutils-libiberty2Fcplus-dem.c
"	      if ((int) strlen (optable[i].in) == len1
		  && memcmp (optable[i].in, opname + 10, len1) == 0)
		{
		  strcat (result, ""operator"");
		  strcat (result, optable[i].out);
",1,unused,738,unused,"	      if ((int) strlen (optable[i].in) == len1
		  && memcmp (optable[i].in, opname + 10, len1) == 0)
		{
		  strcat (result, ""operator"");
		  strcat (result, optable[i].out);
",unused,binutils-libiberty2Fcplus-dem.c
"		  && memcmp (optable[i].in, opname + 10, len1) == 0)
		{
		  strcat (result, ""operator"");
		  strcat (result, optable[i].out);
		  strcat (result, ""="");
",1,unused,739,unused,"		  && memcmp (optable[i].in, opname + 10, len1) == 0)
		{
		  strcat (result, ""operator"");
		  strcat (result, optable[i].out);
		  strcat (result, ""="");
",unused,binutils-libiberty2Fcplus-dem.c
"	      len1 = len - 3;
	      if ((int) strlen (optable[i].in) == len1
		  && memcmp (optable[i].in, opname + 3, len1) == 0)
		{
		  strcat (result, ""operator"");
",1,unused,754,unused,"	      len1 = len - 3;
	      if ((int) strlen (optable[i].in) == len1
		  && memcmp (optable[i].in, opname + 3, len1) == 0)
		{
		  strcat (result, ""operator"");
",unused,binutils-libiberty2Fcplus-dem.c
"	      if ((int) strlen (optable[i].in) == len1
		  && memcmp (optable[i].in, opname + 3, len1) == 0)
		{
		  strcat (result, ""operator"");
		  strcat (result, optable[i].out);
",1,unused,755,unused,"	      if ((int) strlen (optable[i].in) == len1
		  && memcmp (optable[i].in, opname + 3, len1) == 0)
		{
		  strcat (result, ""operator"");
		  strcat (result, optable[i].out);
",unused,binutils-libiberty2Fcplus-dem.c
"      /* type conversion operator */
      tem = opname + 5;
      if (do_type (work, &tem, &type))
	{
	  strcat (result, ""operator "");
",1,unused,769,unused,"      /* type conversion operator */
      tem = opname + 5;
      if (do_type (work, &tem, &type))
	{
	  strcat (result, ""operator "");
",unused,binutils-libiberty2Fcplus-dem.c
"            default:
              goto unknown;
            }
          p += 2;
          strcpy (d, name);
",1,unused,1083,unused,"            default:
              goto unknown;
            }
          p += 2;
          strcpy (d, name);
",unused,binutils-libiberty2Fcplus-dem.c
"              break;
            default:
              goto unknown;
            }
          strcpy (d, name);
",1,unused,1101,unused,"              break;
            default:
              goto unknown;
            }
          strcpy (d, name);
",unused,binutils-libiberty2Fcplus-dem.c
"  len0 = strlen (mangled);
  demangled = XNEWVEC (char, len0 + 3);

  if (mangled[0] == '<')
     strcpy (demangled, mangled);
",1,unused,1202,unused,"  len0 = strlen (mangled);
  demangled = XNEWVEC (char, len0 + 3);

  if (mangled[0] == '<')
     strcpy (demangled, mangled);
",unused,binutils-libiberty2Fcplus-dem.c
"
  if (mangled[0] == '<')
     strcpy (demangled, mangled);
  else
    sprintf (demangled, ""<%s>"", mangled);
",1,unused,1204,unused,"
  if (mangled[0] == '<')
     strcpy (demangled, mangled);
  else
    sprintf (demangled, ""<%s>"", mangled);
",unused,binutils-libiberty2Fcplus-dem.c
"
      if (value != -1)
	{
	  char buf[INTBUF_SIZE];
	  sprintf (buf, ""%d"", value);
",1,unused,1980,unused,"
      if (value != -1)
	{
	  char buf[INTBUF_SIZE];
	  sprintf (buf, ""%d"", value);
",unused,binutils-libiberty2Fcplus-dem.c
"
	  if (method)
	    {
	      char buf[50];
	      sprintf (buf, ""virtual function thunk (delta:%d) for "", -delta);
",1,unused,3181,unused,"
	  if (method)
	    {
	      char buf[50];
	      sprintf (buf, ""virtual function thunk (delta:%d) for "", -delta);
",unused,binutils-libiberty2Fcplus-dem.c
"	  buf[2] = '\0';
	  *mangled += min (strlen (*mangled), 2);
	}
      sscanf (buf, ""%x"", &dec);
      sprintf (buf, ""int%u_t"", dec);
",1,unused,4097,unused,"	  buf[2] = '\0';
	  *mangled += min (strlen (*mangled), 2);
	}
      sscanf (buf, ""%x"", &dec);
      sprintf (buf, ""int%u_t"", dec);
",unused,binutils-libiberty2Fcplus-dem.c
"static void
string_append_template_idx (string *s, int idx)
{
  char buf[INTBUF_SIZE + 1 /* 'T' */];
  sprintf(buf, ""T%d"", idx);
",1,unused,5030,unused,"static void
string_append_template_idx (string *s, int idx)
{
  char buf[INTBUF_SIZE + 1 /* 'T' */];
  sprintf(buf, ""T%d"", idx);
",unused,binutils-libiberty2Fcplus-dem.c
"  /* Make room in DEST.  */
  if (dyn_string_resize (dest, src->length) == NULL)
    return 0;
  /* Copy DEST into SRC.  */
  strcpy (dest->s, src->s);
",1,unused,193,unused,"  /* Make room in DEST.  */
  if (dyn_string_resize (dest, src->length) == NULL)
    return 0;
  /* Copy DEST into SRC.  */
  strcpy (dest->s, src->s);
",unused,binutils-libiberty2Fdyn-string.c
"  /* Make room in DEST.  */
  if (dyn_string_resize (dest, length) == NULL)
    return 0;
  /* Copy DEST into SRC.  */
  strcpy (dest->s, src);
",1,unused,211,unused,"  /* Make room in DEST.  */
  if (dyn_string_resize (dest, length) == NULL)
    return 0;
  /* Copy DEST into SRC.  */
  strcpy (dest->s, src);
",unused,binutils-libiberty2Fdyn-string.c
"dyn_string_append (dyn_string_t dest, dyn_string_t s)
{
  if (dyn_string_resize (dest, dest->length + s->length) == 0)
    return 0;
  strcpy (dest->s + dest->length, s->s);
",1,unused,316,unused,"dyn_string_append (dyn_string_t dest, dyn_string_t s)
{
  if (dyn_string_resize (dest, dest->length + s->length) == 0)
    return 0;
  strcpy (dest->s + dest->length, s->s);
",unused,binutils-libiberty2Fdyn-string.c
"  /* The new length is the old length plus the size of our string, plus
     one for the null at the end.  */
  if (dyn_string_resize (dest, dest->length + len) == NULL)
    return 0;
  strcpy (dest->s + dest->length, s);
",1,unused,334,unused,"  /* The new length is the old length plus the size of our string, plus
     one for the null at the end.  */
  if (dyn_string_resize (dest, dest->length + len) == NULL)
    return 0;
  strcpy (dest->s + dest->length, s);
",unused,binutils-libiberty2Fdyn-string.c
"			}
		      else
			nstore[endp - startp] = 0;
		    }
		  strcat (nstore, progname);
",1,unused,286,unused,"			}
		      else
			nstore[endp - startp] = 0;
		    }
		  strcat (nstore, progname);
",unused,binutils-libiberty2Fmake-relative-prefix.c
"
  /* Build up the pathnames in argv[0].  */
  *ret = '\0';
  for (i = 0; i < prog_num; i++)
    strcat (ret, prog_dirs[i]);
",1,unused,381,unused,"
  /* Build up the pathnames in argv[0].  */
  *ret = '\0';
  for (i = 0; i < prog_num; i++)
    strcat (ret, prog_dirs[i]);
",unused,binutils-libiberty2Fmake-relative-prefix.c
"  /* Now build up the ..'s.  */
  ptr = ret + strlen(ret);
  for (i = common; i < bin_num; i++)
    {
      strcpy (ptr, DIR_UP);
",1,unused,387,unused,"  /* Now build up the ..'s.  */
  ptr = ret + strlen(ret);
  for (i = common; i < bin_num; i++)
    {
      strcpy (ptr, DIR_UP);
",unused,binutils-libiberty2Fmake-relative-prefix.c
"  *ptr = '\0';

  /* Put in directories to move over to prefix.  */
  for (i = common; i < prefix_num; i++)
    strcat (ret, prefix_dirs[i]);
",1,unused,395,unused,"  *ptr = '\0';

  /* Put in directories to move over to prefix.  */
  for (i = common; i < prefix_num; i++)
    strcat (ret, prefix_dirs[i]);
",unused,binutils-libiberty2Fmake-relative-prefix.c
"      /* Append DIR_SEPARATOR to the directory we've chosen
	 and return it.  */
      len = strlen (base);
      tmpdir = XNEWVEC (char, len + 2);
      strcpy (tmpdir, base);
",1,unused,144,unused,"      /* Append DIR_SEPARATOR to the directory we've chosen
	 and return it.  */
      len = strlen (base);
      tmpdir = XNEWVEC (char, len + 2);
      strcpy (tmpdir, base);
",unused,binutils-libiberty2Fmake-temp-file.c
"
  temp_filename = XNEWVEC (char, base_len
			   + TEMP_FILE_LEN
			   + suffix_len + 1);
  strcpy (temp_filename, base);
",1,unused,200,unused,"
  temp_filename = XNEWVEC (char, base_len
			   + TEMP_FILE_LEN
			   + suffix_len + 1);
  strcpy (temp_filename, base);
",unused,binutils-libiberty2Fmake-temp-file.c
"  temp_filename = XNEWVEC (char, base_len
			   + TEMP_FILE_LEN
			   + suffix_len + 1);
  strcpy (temp_filename, base);
  strcpy (temp_filename + base_len, TEMP_FILE);
",1,unused,201,unused,"  temp_filename = XNEWVEC (char, base_len
			   + TEMP_FILE_LEN
			   + suffix_len + 1);
  strcpy (temp_filename, base);
  strcpy (temp_filename + base_len, TEMP_FILE);
",unused,binutils-libiberty2Fmake-temp-file.c
"			   + TEMP_FILE_LEN
			   + suffix_len + 1);
  strcpy (temp_filename, base);
  strcpy (temp_filename + base_len, TEMP_FILE);
  strcpy (temp_filename + base_len + TEMP_FILE_LEN, suffix);
",1,unused,202,unused,"			   + TEMP_FILE_LEN
			   + suffix_len + 1);
  strcpy (temp_filename, base);
  strcpy (temp_filename + base_len, TEMP_FILE);
  strcpy (temp_filename + base_len + TEMP_FILE_LEN, suffix);
",unused,binutils-libiberty2Fmake-temp-file.c
"  offset += nsyms * sizeof (struct external_syment);

  /* Write out file symbol.  */
  memset (&syms[0], 0, sizeof (syms));
  strcpy ((char *)&syms[0].sym.e.e_name[0], "".file"");
",1,unused,698,unused,"  offset += nsyms * sizeof (struct external_syment);

  /* Write out file symbol.  */
  memset (&syms[0], 0, sizeof (syms));
  strcpy ((char *)&syms[0].sym.e.e_name[0], "".file"");
",unused,binutils-libiberty2Fsimple-object-coff.c
"
  /* Write out file symbol.  */
  memset (&syms[0], 0, sizeof (syms));
  if (!u64)
    strcpy ((char *)&syms[0].sym.u.xcoff32.n.n_name[0], "".file"");
",1,unused,955,unused,"
  /* Write out file symbol.  */
  memset (&syms[0], 0, sizeof (syms));
  if (!u64)
    strcpy ((char *)&syms[0].sym.u.xcoff32.n.n_name[0], "".file"");
",unused,binutils-libiberty2Fsimple-object-xcoff.c
"  /* ???  For now this handles both .gnu.lto_ and .gnu.debuglto_ prefixed
     sections.  */
  /* Copy LTO debug sections and rename them to their non-LTO name.  */
  if (strncmp (name, "".gnu.debuglto_"", sizeof ("".gnu.debuglto_"") - 1) == 0)
    return rename ? strcat (newname, name + sizeof ("".gnu.debuglto_"") - 1) : newname;
",1,unused,285,unused,"  /* ???  For now this handles both .gnu.lto_ and .gnu.debuglto_ prefixed
     sections.  */
  /* Copy LTO debug sections and rename them to their non-LTO name.  */
  if (strncmp (name, "".gnu.debuglto_"", sizeof ("".gnu.debuglto_"") - 1) == 0)
    return rename ? strcat (newname, name + sizeof ("".gnu.debuglto_"") - 1) : newname;
",unused,binutils-libiberty2Fsimple-object.c
"  if (strncmp (name, "".gnu.debuglto_"", sizeof ("".gnu.debuglto_"") - 1) == 0)
    return rename ? strcat (newname, name + sizeof ("".gnu.debuglto_"") - 1) : newname;
  else if (strncmp (name, "".gnu.lto_.debug_"",
		    sizeof ("".gnu.lto_.debug_"") -1) == 0)
    return rename ? strcat (newname, name + sizeof ("".gnu.lto_"") - 1) : newname;
",1,unused,288,unused,"  if (strncmp (name, "".gnu.debuglto_"", sizeof ("".gnu.debuglto_"") - 1) == 0)
    return rename ? strcat (newname, name + sizeof ("".gnu.debuglto_"") - 1) : newname;
  else if (strncmp (name, "".gnu.lto_.debug_"",
		    sizeof ("".gnu.lto_.debug_"") -1) == 0)
    return rename ? strcat (newname, name + sizeof ("".gnu.lto_"") - 1) : newname;
",unused,binutils-libiberty2Fsimple-object.c
"		    sizeof ("".gnu.lto_.debug_"") -1) == 0)
    return rename ? strcat (newname, name + sizeof ("".gnu.lto_"") - 1) : newname;
  /* Copy over .note.GNU-stack section under the same name if present.  */
  else if (strcmp (name, "".note.GNU-stack"") == 0)
    return strcpy (newname, name);
",1,unused,291,unused,"		    sizeof ("".gnu.lto_.debug_"") -1) == 0)
    return rename ? strcat (newname, name + sizeof ("".gnu.lto_"") - 1) : newname;
  /* Copy over .note.GNU-stack section under the same name if present.  */
  else if (strcmp (name, "".note.GNU-stack"") == 0)
    return strcpy (newname, name);
",unused,binutils-libiberty2Fsimple-object.c
"  /* Copy over .comment section under the same name if present.  Solaris
     ld uses them to relax its checking of ELF gABI access rules for
     COMDAT sections in objects produced by GCC.  */
  else if (strcmp (name, "".comment"") == 0)
    return strcpy (newname, name);
",1,unused,296,unused,"  /* Copy over .comment section under the same name if present.  Solaris
     ld uses them to relax its checking of ELF gABI access rules for
     COMDAT sections in objects produced by GCC.  */
  else if (strcmp (name, "".comment"") == 0)
    return strcpy (newname, name);
",unused,binutils-libiberty2Fsimple-object.c
"    }
  else if ((error_names == NULL) || (error_names[errnoval] == NULL))
    {
      /* In range, but no error_names or no entry at this index. */
      sprintf (buf, ""Error %d"", errnoval);
",1,unused,720,unused,"    }
  else if ((error_names == NULL) || (error_names[errnoval] == NULL))
    {
      /* In range, but no error_names or no entry at this index. */
      sprintf (buf, ""Error %d"", errnoval);
",unused,binutils-libiberty2Fstrerror.c
"    }
  else if ((signal_names == NULL) || (signal_names[signo] == NULL))
    {
      /* In range, but no signal_names or no entry at this index. */
      sprintf (buf, ""Signal %d"", signo);
",1,unused,487,unused,"    }
  else if ((signal_names == NULL) || (signal_names[signo] == NULL))
    {
      /* In range, but no signal_names or no entry at this index. */
      sprintf (buf, ""Signal %d"", signo);
",unused,binutils-libiberty2Fstrsignal.c
"
  /* If `errnum' is out of range, result might be NULL.  We'll fix that.  */
  if (!errstr)
    {
      sprintf (xstrerror_buf, ERRSTR_FMT, errnum);
",1,unused,75,unused,"
  /* If `errnum' is out of range, result might be NULL.  We'll fix that.  */
  if (!errstr)
    {
      sprintf (xstrerror_buf, ERRSTR_FMT, errnum);
",unused,binutils-libiberty2Fxstrerror.c
"      putop (fgrps[dp->op[0].bytemode][modrm.rm], sizeflag);

      /* Instruction fnstsw is only one with strange arg.  */
      if (floatop == 0xdf && codep[-1] == 0xe0)
	strcpy (op_out[0], names16[0]);
",1,unused,13941,unused,"      putop (fgrps[dp->op[0].bytemode][modrm.rm], sizeflag);

      /* Instruction fnstsw is only one with strange arg.  */
      if (floatop == 0xdf && codep[-1] == 0xe0)
	strcpy (op_out[0], names16[0]);
",unused,binutils-opcodes2Fi386-dis.c
"
static void
OP_STi (int bytemode ATTRIBUTE_UNUSED, int sizeflag ATTRIBUTE_UNUSED)
{
  sprintf (scratchbuf, ""%%st(%d)"", modrm.rm);
",1,unused,13976,unused,"
static void
OP_STi (int bytemode ATTRIBUTE_UNUSED, int sizeflag ATTRIBUTE_UNUSED)
{
  sprintf (scratchbuf, ""%%st(%d)"", modrm.rm);
",unused,binutils-opcodes2Fi386-dis.c
"	  buf[0] = '0';
	  buf[1] = 'x';
	  sprintf_vma (tmp, disp);
	  for (i = 0; tmp[i] == '0' && tmp[i + 1]; i++);
	  strcpy (buf + 2, tmp + i);
",1,unused,14634,unused,"	  buf[0] = '0';
	  buf[1] = 'x';
	  sprintf_vma (tmp, disp);
	  for (i = 0; tmp[i] == '0' && tmp[i + 1]; i++);
	  strcpy (buf + 2, tmp + i);
",unused,binutils-opcodes2Fi386-dis.c
"	      v = -disp;
	      /* Check for possible overflow on 0x8000000000000000.  */
	      if (v < 0)
		{
		  strcpy (buf, ""9223372036854775808"");
",1,unused,14648,unused,"	      v = -disp;
	      /* Check for possible overflow on 0x8000000000000000.  */
	      if (v < 0)
		{
		  strcpy (buf, ""9223372036854775808"");
",unused,binutils-opcodes2Fi386-dis.c
"		}
	    }
	  if (!v)
	    {
	      strcpy (buf, ""0"");
",1,unused,14654,unused,"		}
	    }
	  if (!v)
	    {
	      strcpy (buf, ""0"");
",unused,binutils-opcodes2Fi386-dis.c
"	      tmp[28 - i] = (v % 10) + '0';
	      v /= 10;
	      i++;
	    }
	  strcpy (buf, tmp + 29 - i);
",1,unused,14666,unused,"	      tmp[28 - i] = (v % 10) + '0';
	      v /= 10;
	      i++;
	    }
	  strcpy (buf, tmp + 29 - i);
",unused,binutils-opcodes2Fi386-dis.c
"    }
  else
    {
      if (hex)
	sprintf (buf, ""0x%x"", (unsigned int) disp);
",1,unused,14672,unused,"    }
  else
    {
      if (hex)
	sprintf (buf, ""0x%x"", (unsigned int) disp);
",unused,binutils-opcodes2Fi386-dis.c
"    {
      if (hex)
	sprintf (buf, ""0x%x"", (unsigned int) disp);
      else
	sprintf (buf, ""%d"", (int) disp);
",1,unused,14674,unused,"    {
      if (hex)
	sprintf (buf, ""0x%x"", (unsigned int) disp);
      else
	sprintf (buf, ""%d"", (int) disp);
",unused,binutils-opcodes2Fi386-dis.c
"	{
	  switch (address_mode)
	    {
	    case mode_64bit:
	      strcpy (buf + j, ""0x8000000000000000"");
",1,unused,14698,unused,"	{
	  switch (address_mode)
	    {
	    case mode_64bit:
	      strcpy (buf + j, ""0x8000000000000000"");
",unused,binutils-opcodes2Fi386-dis.c
"	    case mode_64bit:
	      strcpy (buf + j, ""0x8000000000000000"");
	      break;
	    case mode_32bit:
	      strcpy (buf + j, ""0x80000000"");
",1,unused,14701,unused,"	    case mode_64bit:
	      strcpy (buf + j, ""0x8000000000000000"");
	      break;
	    case mode_32bit:
	      strcpy (buf + j, ""0x80000000"");
",unused,binutils-opcodes2Fi386-dis.c
"	    case mode_32bit:
	      strcpy (buf + j, ""0x80000000"");
	      break;
	    case mode_16bit:
	      strcpy (buf + j, ""0x8000"");
",1,unused,14704,unused,"	    case mode_32bit:
	      strcpy (buf + j, ""0x80000000"");
	      break;
	    case mode_16bit:
	      strcpy (buf + j, ""0x8000"");
",unused,binutils-opcodes2Fi386-dis.c
"  for (i = 0; tmp[i] == '0'; i++)
    continue;
  if (tmp[i] == '\0')
    i--;
  strcpy (buf + j, tmp + i);
",1,unused,14719,unused,"  for (i = 0; tmp[i] == '0'; i++)
    continue;
  if (tmp[i] == '\0')
    i--;
  strcpy (buf + j, tmp + i);
",unused,binutils-opcodes2Fi386-dis.c
"			     ? index64 : index32);

		  *obufp++ = scale_char;
		  *obufp = '\0';
		  sprintf (scratchbuf, ""%d"", 1 << scale);
",1,unused,15502,unused,"			     ? index64 : index32);

		  *obufp++ = scale_char;
		  *obufp = '\0';
		  sprintf (scratchbuf, ""%d"", 1 << scale);
",unused,binutils-opcodes2Fi386-dis.c
"      seg = get16 ();
    }
  used_prefixes |= (prefixes & PREFIX_DATA);
  if (intel_syntax)
    sprintf (scratchbuf, ""0x%x:0x%x"", seg, offset);
",1,unused,16215,unused,"      seg = get16 ();
    }
  used_prefixes |= (prefixes & PREFIX_DATA);
  if (intel_syntax)
    sprintf (scratchbuf, ""0x%x:0x%x"", seg, offset);
",unused,binutils-opcodes2Fi386-dis.c
"  used_prefixes |= (prefixes & PREFIX_DATA);
  if (intel_syntax)
    sprintf (scratchbuf, ""0x%x:0x%x"", seg, offset);
  else
    sprintf (scratchbuf, ""$0x%x,$0x%x"", seg, offset);
",1,unused,16217,unused,"  used_prefixes |= (prefixes & PREFIX_DATA);
  if (intel_syntax)
    sprintf (scratchbuf, ""0x%x:0x%x"", seg, offset);
  else
    sprintf (scratchbuf, ""$0x%x,$0x%x"", seg, offset);
",unused,binutils-opcodes2Fi386-dis.c
"      add = 8;
    }
  else
    add = 0;
  sprintf (scratchbuf, ""%%cr%d"", modrm.reg + add);
",1,unused,16368,unused,"      add = 8;
    }
  else
    add = 0;
  sprintf (scratchbuf, ""%%cr%d"", modrm.reg + add);
",unused,binutils-opcodes2Fi386-dis.c
"    add = 8;
  else
    add = 0;
  if (intel_syntax)
    sprintf (scratchbuf, ""db%d"", modrm.reg + add);
",1,unused,16382,unused,"    add = 8;
  else
    add = 0;
  if (intel_syntax)
    sprintf (scratchbuf, ""db%d"", modrm.reg + add);
",unused,binutils-opcodes2Fi386-dis.c
"    add = 0;
  if (intel_syntax)
    sprintf (scratchbuf, ""db%d"", modrm.reg + add);
  else
    sprintf (scratchbuf, ""%%db%d"", modrm.reg + add);
",1,unused,16384,unused,"    add = 0;
  if (intel_syntax)
    sprintf (scratchbuf, ""db%d"", modrm.reg + add);
  else
    sprintf (scratchbuf, ""%%db%d"", modrm.reg + add);
",unused,binutils-opcodes2Fi386-dis.c
"
static void
OP_T (int dummy ATTRIBUTE_UNUSED, int sizeflag ATTRIBUTE_UNUSED)
{
  sprintf (scratchbuf, ""%%tr%d"", modrm.reg);
",1,unused,16391,unused,"
static void
OP_T (int dummy ATTRIBUTE_UNUSED, int sizeflag ATTRIBUTE_UNUSED)
{
  sprintf (scratchbuf, ""%%tr%d"", modrm.reg);
",unused,binutils-opcodes2Fi386-dis.c
"	  && rex != 0x48
	  && address_mode == mode_64bit))
    OP_REG (bytemode, sizeflag);
  else
    strcpy (obuf, ""nop"");
",1,unused,16699,unused,"	  && rex != 0x48
	  && address_mode == mode_64bit))
    OP_REG (bytemode, sizeflag);
  else
    strcpy (obuf, ""nop"");
",unused,binutils-opcodes2Fi386-dis.c
"      char *p = mnemonicendp - 2;
      suffix[0] = p[0];
      suffix[1] = p[1];
      suffix[2] = '\0';
      sprintf (p, ""%s%s"", simd_cmp_op[cmp_type].name, suffix);
",1,unused,16831,unused,"      char *p = mnemonicendp - 2;
      suffix[0] = p[0];
      suffix[1] = p[1];
      suffix[2] = '\0';
      sprintf (p, ""%s%s"", simd_cmp_op[cmp_type].name, suffix);
",unused,binutils-opcodes2Fi386-dis.c
"  if (!intel_syntax)
    {
      const char **names = (address_mode == mode_64bit
			    ? names64 : names32);
      strcpy (op_out[0], names[0]);
",1,unused,16853,unused,"  if (!intel_syntax)
    {
      const char **names = (address_mode == mode_64bit
			    ? names64 : names32);
      strcpy (op_out[0], names[0]);
",unused,binutils-opcodes2Fi386-dis.c
"    {
      const char **names = (address_mode == mode_64bit
			    ? names64 : names32);
      strcpy (op_out[0], names[0]);
      strcpy (op_out[1], names[1]);
",1,unused,16854,unused,"    {
      const char **names = (address_mode == mode_64bit
			    ? names64 : names32);
      strcpy (op_out[0], names[0]);
      strcpy (op_out[1], names[1]);
",unused,binutils-opcodes2Fi386-dis.c
"      const char **names = (address_mode == mode_64bit
			    ? names64 : names32);
      strcpy (op_out[0], names[0]);
      strcpy (op_out[1], names[1]);
      strcpy (op_out[2], names[3]);
",1,unused,16855,unused,"      const char **names = (address_mode == mode_64bit
			    ? names64 : names32);
      strcpy (op_out[0], names[0]);
      strcpy (op_out[1], names[1]);
      strcpy (op_out[2], names[3]);
",unused,binutils-opcodes2Fi386-dis.c
"  if (!intel_syntax)
    {
      const char **names = (address_mode == mode_64bit
			    ? names64 : names32);
      strcpy (op_out[0], names[0]);
",1,unused,16872,unused,"  if (!intel_syntax)
    {
      const char **names = (address_mode == mode_64bit
			    ? names64 : names32);
      strcpy (op_out[0], names[0]);
",unused,binutils-opcodes2Fi386-dis.c
"    {
      const char **names = (address_mode == mode_64bit
			    ? names64 : names32);
      strcpy (op_out[0], names[0]);
      strcpy (op_out[1], names[1]);
",1,unused,16873,unused,"    {
      const char **names = (address_mode == mode_64bit
			    ? names64 : names32);
      strcpy (op_out[0], names[0]);
      strcpy (op_out[1], names[1]);
",unused,binutils-opcodes2Fi386-dis.c
"	  op1_names = (address_mode != mode_32bit
		       ? names32 : names16);
	  used_prefixes |= PREFIX_ADDR;
	}
      strcpy (op_out[0], op1_names[0]);
",1,unused,16903,unused,"	  op1_names = (address_mode != mode_32bit
		       ? names32 : names16);
	  used_prefixes |= PREFIX_ADDR;
	}
      strcpy (op_out[0], op1_names[0]);
",unused,binutils-opcodes2Fi386-dis.c
"		       ? names32 : names16);
	  used_prefixes |= PREFIX_ADDR;
	}
      strcpy (op_out[0], op1_names[0]);
      strcpy (op_out[1], names[1]);
",1,unused,16904,unused,"		       ? names32 : names16);
	  used_prefixes |= PREFIX_ADDR;
	}
      strcpy (op_out[0], op1_names[0]);
      strcpy (op_out[1], names[1]);
",unused,binutils-opcodes2Fi386-dis.c
"	  used_prefixes |= PREFIX_ADDR;
	}
      strcpy (op_out[0], op1_names[0]);
      strcpy (op_out[1], names[1]);
      strcpy (op_out[2], names[2]);
",1,unused,16905,unused,"	  used_prefixes |= PREFIX_ADDR;
	}
      strcpy (op_out[0], op1_names[0]);
      strcpy (op_out[1], names[1]);
      strcpy (op_out[2], names[2]);
",unused,binutils-opcodes2Fi386-dis.c
"      char *p = mnemonicendp - 2;
      suffix[0] = p[0];
      suffix[1] = p[1];
      suffix[2] = '\0';
      sprintf (p, ""%s%s"", vex_cmp_op[cmp_type].name, suffix);
",1,unused,17659,unused,"      char *p = mnemonicendp - 2;
      suffix[0] = p[0];
      suffix[1] = p[1];
      suffix[2] = '\0';
      sprintf (p, ""%s%s"", vex_cmp_op[cmp_type].name, suffix);
",unused,binutils-opcodes2Fi386-dis.c
"	  suffix[1] = p[1];
	  suffix[2] = '\0';
	}

      sprintf (p, ""%s%s"", simd_cmp_op[cmp_type].name, suffix);
",1,unused,17706,unused,"	  suffix[1] = p[1];
	  suffix[2] = '\0';
	}

      sprintf (p, ""%s%s"", simd_cmp_op[cmp_type].name, suffix);
",unused,binutils-opcodes2Fi386-dis.c
"	  suffix[1] = p[1];
	  suffix[2] = '\0';
	}

      sprintf (p, ""%s%s"", xop_cmp_op[cmp_type].name, suffix);
",1,unused,17758,unused,"	  suffix[1] = p[1];
	  suffix[2] = '\0';
	}

      sprintf (p, ""%s%s"", xop_cmp_op[cmp_type].name, suffix);
",unused,binutils-opcodes2Fi386-dis.c
"      suffix[0] = p[0];
      suffix[1] = p[1];
      suffix[2] = p[2];
      suffix[3] = '\0';
      sprintf (p, ""%s%s"", pclmul_op[pclmul_type].name, suffix);
",1,unused,17806,unused,"      suffix[0] = p[0];
      suffix[1] = p[1];
      suffix[2] = p[2];
      suffix[3] = '\0';
      sprintf (p, ""%s%s"", pclmul_op[pclmul_type].name, suffix);
",unused,binutils-opcodes2Fi386-dis.c
"		  _bfd_error_handler (_(""%B: out of memory creating name for empty section""),
				      abfd);
		  return;
		}
	      strcpy ((char *) name, namebuf);
",1,unused,187,unused,"		  _bfd_error_handler (_(""%B: out of memory creating name for empty section""),
				      abfd);
		  return;
		}
	      strcpy ((char *) name, namebuf);
",unused,binutils1-bfd2Fpeigen.c
"					       idd.SizeOfData, cvinfo))
            continue;

          for (i = 0; i < cvinfo->SignatureLength; i++)
            sprintf (&signature[i*2], ""%02x"", cvinfo->Signature[i] & 0xff);
",1,unused,2718,unused,"					       idd.SizeOfData, cvinfo))
            continue;

          for (i = 0; i < cvinfo->SignatureLength; i++)
            sprintf (&signature[i*2], ""%02x"", cvinfo->Signature[i] & 0xff);
",unused,binutils1-bfd2Fpeigen.c
"  unsigned int  i;
  bfd_byte *    name = string.string;

  for (i = string.len; i--; name += 2)
    sprintf (buffer + strlen (buffer), ""%.1s"", name);
",1,unused,3695,unused,"  unsigned int  i;
  bfd_byte *    name = string.string;

  for (i = string.len; i--; name += 2)
    sprintf (buffer + strlen (buffer), ""%.1s"", name);
",unused,binutils1-bfd2Fpeigen.c
"
  if (dir != NULL && dir->entry != NULL && dir->entry->parent != NULL
      && dir->entry->parent->entry != NULL)
    {
      strcpy (buffer, ""type: "");
",1,unused,3709,unused,"
  if (dir != NULL && dir->entry != NULL && dir->entry->parent != NULL
      && dir->entry->parent->entry != NULL)
    {
      strcpy (buffer, ""type: "");
",unused,binutils1-bfd2Fpeigen.c
"      else
	{
	  unsigned int id = dir->entry->parent->entry->name_id.id;

	  sprintf (buffer + strlen (buffer), ""%x"", id);
",1,unused,3717,unused,"      else
	{
	  unsigned int id = dir->entry->parent->entry->name_id.id;

	  sprintf (buffer + strlen (buffer), ""%x"", id);
",unused,binutils1-bfd2Fpeigen.c
"
	  sprintf (buffer + strlen (buffer), ""%x"", id);
	  switch (id)
	    {
	    case 1: strcat (buffer, "" (CURSOR)""); break;
",1,unused,3720,unused,"
	  sprintf (buffer + strlen (buffer), ""%x"", id);
	  switch (id)
	    {
	    case 1: strcat (buffer, "" (CURSOR)""); break;
",unused,binutils1-bfd2Fpeigen.c
"	  sprintf (buffer + strlen (buffer), ""%x"", id);
	  switch (id)
	    {
	    case 1: strcat (buffer, "" (CURSOR)""); break;
	    case 2: strcat (buffer, "" (BITMAP)""); break;
",1,unused,3721,unused,"	  sprintf (buffer + strlen (buffer), ""%x"", id);
	  switch (id)
	    {
	    case 1: strcat (buffer, "" (CURSOR)""); break;
	    case 2: strcat (buffer, "" (BITMAP)""); break;
",unused,binutils1-bfd2Fpeigen.c
"	  switch (id)
	    {
	    case 1: strcat (buffer, "" (CURSOR)""); break;
	    case 2: strcat (buffer, "" (BITMAP)""); break;
	    case 3: strcat (buffer, "" (ICON)""); break;
",1,unused,3722,unused,"	  switch (id)
	    {
	    case 1: strcat (buffer, "" (CURSOR)""); break;
	    case 2: strcat (buffer, "" (BITMAP)""); break;
	    case 3: strcat (buffer, "" (ICON)""); break;
",unused,binutils1-bfd2Fpeigen.c
"	    {
	    case 1: strcat (buffer, "" (CURSOR)""); break;
	    case 2: strcat (buffer, "" (BITMAP)""); break;
	    case 3: strcat (buffer, "" (ICON)""); break;
            case 4: strcat (buffer, "" (MENU)""); break;
",1,unused,3723,unused,"	    {
	    case 1: strcat (buffer, "" (CURSOR)""); break;
	    case 2: strcat (buffer, "" (BITMAP)""); break;
	    case 3: strcat (buffer, "" (ICON)""); break;
            case 4: strcat (buffer, "" (MENU)""); break;
",unused,binutils1-bfd2Fpeigen.c
"	    case 1: strcat (buffer, "" (CURSOR)""); break;
	    case 2: strcat (buffer, "" (BITMAP)""); break;
	    case 3: strcat (buffer, "" (ICON)""); break;
            case 4: strcat (buffer, "" (MENU)""); break;
	    case 5: strcat (buffer, "" (DIALOG)""); break;
",1,unused,3724,unused,"	    case 1: strcat (buffer, "" (CURSOR)""); break;
	    case 2: strcat (buffer, "" (BITMAP)""); break;
	    case 3: strcat (buffer, "" (ICON)""); break;
            case 4: strcat (buffer, "" (MENU)""); break;
	    case 5: strcat (buffer, "" (DIALOG)""); break;
",unused,binutils1-bfd2Fpeigen.c
"	    case 2: strcat (buffer, "" (BITMAP)""); break;
	    case 3: strcat (buffer, "" (ICON)""); break;
            case 4: strcat (buffer, "" (MENU)""); break;
	    case 5: strcat (buffer, "" (DIALOG)""); break;
	    case 6: strcat (buffer, "" (STRING)""); is_string = TRUE; break;
",1,unused,3725,unused,"	    case 2: strcat (buffer, "" (BITMAP)""); break;
	    case 3: strcat (buffer, "" (ICON)""); break;
            case 4: strcat (buffer, "" (MENU)""); break;
	    case 5: strcat (buffer, "" (DIALOG)""); break;
	    case 6: strcat (buffer, "" (STRING)""); is_string = TRUE; break;
",unused,binutils1-bfd2Fpeigen.c
"	    case 3: strcat (buffer, "" (ICON)""); break;
            case 4: strcat (buffer, "" (MENU)""); break;
	    case 5: strcat (buffer, "" (DIALOG)""); break;
	    case 6: strcat (buffer, "" (STRING)""); is_string = TRUE; break;
	    case 7: strcat (buffer, "" (FONTDIR)""); break;
",1,unused,3726,unused,"	    case 3: strcat (buffer, "" (ICON)""); break;
            case 4: strcat (buffer, "" (MENU)""); break;
	    case 5: strcat (buffer, "" (DIALOG)""); break;
	    case 6: strcat (buffer, "" (STRING)""); is_string = TRUE; break;
	    case 7: strcat (buffer, "" (FONTDIR)""); break;
",unused,binutils1-bfd2Fpeigen.c
"            case 4: strcat (buffer, "" (MENU)""); break;
	    case 5: strcat (buffer, "" (DIALOG)""); break;
	    case 6: strcat (buffer, "" (STRING)""); is_string = TRUE; break;
	    case 7: strcat (buffer, "" (FONTDIR)""); break;
	    case 8: strcat (buffer, "" (FONT)""); break;
",1,unused,3727,unused,"            case 4: strcat (buffer, "" (MENU)""); break;
	    case 5: strcat (buffer, "" (DIALOG)""); break;
	    case 6: strcat (buffer, "" (STRING)""); is_string = TRUE; break;
	    case 7: strcat (buffer, "" (FONTDIR)""); break;
	    case 8: strcat (buffer, "" (FONT)""); break;
",unused,binutils1-bfd2Fpeigen.c
"	    case 5: strcat (buffer, "" (DIALOG)""); break;
	    case 6: strcat (buffer, "" (STRING)""); is_string = TRUE; break;
	    case 7: strcat (buffer, "" (FONTDIR)""); break;
	    case 8: strcat (buffer, "" (FONT)""); break;
	    case 9: strcat (buffer, "" (ACCELERATOR)""); break;
",1,unused,3728,unused,"	    case 5: strcat (buffer, "" (DIALOG)""); break;
	    case 6: strcat (buffer, "" (STRING)""); is_string = TRUE; break;
	    case 7: strcat (buffer, "" (FONTDIR)""); break;
	    case 8: strcat (buffer, "" (FONT)""); break;
	    case 9: strcat (buffer, "" (ACCELERATOR)""); break;
",unused,binutils1-bfd2Fpeigen.c
"	    case 6: strcat (buffer, "" (STRING)""); is_string = TRUE; break;
	    case 7: strcat (buffer, "" (FONTDIR)""); break;
	    case 8: strcat (buffer, "" (FONT)""); break;
	    case 9: strcat (buffer, "" (ACCELERATOR)""); break;
	    case 10: strcat (buffer, "" (RCDATA)""); break;
",1,unused,3729,unused,"	    case 6: strcat (buffer, "" (STRING)""); is_string = TRUE; break;
	    case 7: strcat (buffer, "" (FONTDIR)""); break;
	    case 8: strcat (buffer, "" (FONT)""); break;
	    case 9: strcat (buffer, "" (ACCELERATOR)""); break;
	    case 10: strcat (buffer, "" (RCDATA)""); break;
",unused,binutils1-bfd2Fpeigen.c
"	    case 7: strcat (buffer, "" (FONTDIR)""); break;
	    case 8: strcat (buffer, "" (FONT)""); break;
	    case 9: strcat (buffer, "" (ACCELERATOR)""); break;
	    case 10: strcat (buffer, "" (RCDATA)""); break;
	    case 11: strcat (buffer, "" (MESSAGETABLE)""); break;
",1,unused,3730,unused,"	    case 7: strcat (buffer, "" (FONTDIR)""); break;
	    case 8: strcat (buffer, "" (FONT)""); break;
	    case 9: strcat (buffer, "" (ACCELERATOR)""); break;
	    case 10: strcat (buffer, "" (RCDATA)""); break;
	    case 11: strcat (buffer, "" (MESSAGETABLE)""); break;
",unused,binutils1-bfd2Fpeigen.c
"	    case 8: strcat (buffer, "" (FONT)""); break;
	    case 9: strcat (buffer, "" (ACCELERATOR)""); break;
	    case 10: strcat (buffer, "" (RCDATA)""); break;
	    case 11: strcat (buffer, "" (MESSAGETABLE)""); break;
	    case 12: strcat (buffer, "" (GROUP_CURSOR)""); break;
",1,unused,3731,unused,"	    case 8: strcat (buffer, "" (FONT)""); break;
	    case 9: strcat (buffer, "" (ACCELERATOR)""); break;
	    case 10: strcat (buffer, "" (RCDATA)""); break;
	    case 11: strcat (buffer, "" (MESSAGETABLE)""); break;
	    case 12: strcat (buffer, "" (GROUP_CURSOR)""); break;
",unused,binutils1-bfd2Fpeigen.c
"	    case 9: strcat (buffer, "" (ACCELERATOR)""); break;
	    case 10: strcat (buffer, "" (RCDATA)""); break;
	    case 11: strcat (buffer, "" (MESSAGETABLE)""); break;
	    case 12: strcat (buffer, "" (GROUP_CURSOR)""); break;
	    case 14: strcat (buffer, "" (GROUP_ICON)""); break;
",1,unused,3732,unused,"	    case 9: strcat (buffer, "" (ACCELERATOR)""); break;
	    case 10: strcat (buffer, "" (RCDATA)""); break;
	    case 11: strcat (buffer, "" (MESSAGETABLE)""); break;
	    case 12: strcat (buffer, "" (GROUP_CURSOR)""); break;
	    case 14: strcat (buffer, "" (GROUP_ICON)""); break;
",unused,binutils1-bfd2Fpeigen.c
"	    case 10: strcat (buffer, "" (RCDATA)""); break;
	    case 11: strcat (buffer, "" (MESSAGETABLE)""); break;
	    case 12: strcat (buffer, "" (GROUP_CURSOR)""); break;
	    case 14: strcat (buffer, "" (GROUP_ICON)""); break;
	    case 16: strcat (buffer, "" (VERSION)""); break;
",1,unused,3733,unused,"	    case 10: strcat (buffer, "" (RCDATA)""); break;
	    case 11: strcat (buffer, "" (MESSAGETABLE)""); break;
	    case 12: strcat (buffer, "" (GROUP_CURSOR)""); break;
	    case 14: strcat (buffer, "" (GROUP_ICON)""); break;
	    case 16: strcat (buffer, "" (VERSION)""); break;
",unused,binutils1-bfd2Fpeigen.c
"	    case 11: strcat (buffer, "" (MESSAGETABLE)""); break;
	    case 12: strcat (buffer, "" (GROUP_CURSOR)""); break;
	    case 14: strcat (buffer, "" (GROUP_ICON)""); break;
	    case 16: strcat (buffer, "" (VERSION)""); break;
	    case 17: strcat (buffer, "" (DLGINCLUDE)""); break;
",1,unused,3734,unused,"	    case 11: strcat (buffer, "" (MESSAGETABLE)""); break;
	    case 12: strcat (buffer, "" (GROUP_CURSOR)""); break;
	    case 14: strcat (buffer, "" (GROUP_ICON)""); break;
	    case 16: strcat (buffer, "" (VERSION)""); break;
	    case 17: strcat (buffer, "" (DLGINCLUDE)""); break;
",unused,binutils1-bfd2Fpeigen.c
"	    case 12: strcat (buffer, "" (GROUP_CURSOR)""); break;
	    case 14: strcat (buffer, "" (GROUP_ICON)""); break;
	    case 16: strcat (buffer, "" (VERSION)""); break;
	    case 17: strcat (buffer, "" (DLGINCLUDE)""); break;
	    case 19: strcat (buffer, "" (PLUGPLAY)""); break;
",1,unused,3735,unused,"	    case 12: strcat (buffer, "" (GROUP_CURSOR)""); break;
	    case 14: strcat (buffer, "" (GROUP_ICON)""); break;
	    case 16: strcat (buffer, "" (VERSION)""); break;
	    case 17: strcat (buffer, "" (DLGINCLUDE)""); break;
	    case 19: strcat (buffer, "" (PLUGPLAY)""); break;
",unused,binutils1-bfd2Fpeigen.c
"	    case 14: strcat (buffer, "" (GROUP_ICON)""); break;
	    case 16: strcat (buffer, "" (VERSION)""); break;
	    case 17: strcat (buffer, "" (DLGINCLUDE)""); break;
	    case 19: strcat (buffer, "" (PLUGPLAY)""); break;
	    case 20: strcat (buffer, "" (VXD)""); break;
",1,unused,3736,unused,"	    case 14: strcat (buffer, "" (GROUP_ICON)""); break;
	    case 16: strcat (buffer, "" (VERSION)""); break;
	    case 17: strcat (buffer, "" (DLGINCLUDE)""); break;
	    case 19: strcat (buffer, "" (PLUGPLAY)""); break;
	    case 20: strcat (buffer, "" (VXD)""); break;
",unused,binutils1-bfd2Fpeigen.c
"	    case 16: strcat (buffer, "" (VERSION)""); break;
	    case 17: strcat (buffer, "" (DLGINCLUDE)""); break;
	    case 19: strcat (buffer, "" (PLUGPLAY)""); break;
	    case 20: strcat (buffer, "" (VXD)""); break;
	    case 21: strcat (buffer, "" (ANICURSOR)""); break;
",1,unused,3737,unused,"	    case 16: strcat (buffer, "" (VERSION)""); break;
	    case 17: strcat (buffer, "" (DLGINCLUDE)""); break;
	    case 19: strcat (buffer, "" (PLUGPLAY)""); break;
	    case 20: strcat (buffer, "" (VXD)""); break;
	    case 21: strcat (buffer, "" (ANICURSOR)""); break;
",unused,binutils1-bfd2Fpeigen.c
"	    case 17: strcat (buffer, "" (DLGINCLUDE)""); break;
	    case 19: strcat (buffer, "" (PLUGPLAY)""); break;
	    case 20: strcat (buffer, "" (VXD)""); break;
	    case 21: strcat (buffer, "" (ANICURSOR)""); break;
	    case 22: strcat (buffer, "" (ANIICON)""); break;
",1,unused,3738,unused,"	    case 17: strcat (buffer, "" (DLGINCLUDE)""); break;
	    case 19: strcat (buffer, "" (PLUGPLAY)""); break;
	    case 20: strcat (buffer, "" (VXD)""); break;
	    case 21: strcat (buffer, "" (ANICURSOR)""); break;
	    case 22: strcat (buffer, "" (ANIICON)""); break;
",unused,binutils1-bfd2Fpeigen.c
"	    case 19: strcat (buffer, "" (PLUGPLAY)""); break;
	    case 20: strcat (buffer, "" (VXD)""); break;
	    case 21: strcat (buffer, "" (ANICURSOR)""); break;
	    case 22: strcat (buffer, "" (ANIICON)""); break;
	    case 23: strcat (buffer, "" (HTML)""); break;
",1,unused,3739,unused,"	    case 19: strcat (buffer, "" (PLUGPLAY)""); break;
	    case 20: strcat (buffer, "" (VXD)""); break;
	    case 21: strcat (buffer, "" (ANICURSOR)""); break;
	    case 22: strcat (buffer, "" (ANIICON)""); break;
	    case 23: strcat (buffer, "" (HTML)""); break;
",unused,binutils1-bfd2Fpeigen.c
"	    case 20: strcat (buffer, "" (VXD)""); break;
	    case 21: strcat (buffer, "" (ANICURSOR)""); break;
	    case 22: strcat (buffer, "" (ANIICON)""); break;
	    case 23: strcat (buffer, "" (HTML)""); break;
	    case 24: strcat (buffer, "" (MANIFEST)""); break;
",1,unused,3740,unused,"	    case 20: strcat (buffer, "" (VXD)""); break;
	    case 21: strcat (buffer, "" (ANICURSOR)""); break;
	    case 22: strcat (buffer, "" (ANIICON)""); break;
	    case 23: strcat (buffer, "" (HTML)""); break;
	    case 24: strcat (buffer, "" (MANIFEST)""); break;
",unused,binutils1-bfd2Fpeigen.c
"	    case 21: strcat (buffer, "" (ANICURSOR)""); break;
	    case 22: strcat (buffer, "" (ANIICON)""); break;
	    case 23: strcat (buffer, "" (HTML)""); break;
	    case 24: strcat (buffer, "" (MANIFEST)""); break;
	    case 240: strcat (buffer, "" (DLGINIT)""); break;
",1,unused,3741,unused,"	    case 21: strcat (buffer, "" (ANICURSOR)""); break;
	    case 22: strcat (buffer, "" (ANIICON)""); break;
	    case 23: strcat (buffer, "" (HTML)""); break;
	    case 24: strcat (buffer, "" (MANIFEST)""); break;
	    case 240: strcat (buffer, "" (DLGINIT)""); break;
",unused,binutils1-bfd2Fpeigen.c
"	    case 22: strcat (buffer, "" (ANIICON)""); break;
	    case 23: strcat (buffer, "" (HTML)""); break;
	    case 24: strcat (buffer, "" (MANIFEST)""); break;
	    case 240: strcat (buffer, "" (DLGINIT)""); break;
	    case 241: strcat (buffer, "" (TOOLBAR)""); break;
",1,unused,3742,unused,"	    case 22: strcat (buffer, "" (ANIICON)""); break;
	    case 23: strcat (buffer, "" (HTML)""); break;
	    case 24: strcat (buffer, "" (MANIFEST)""); break;
	    case 240: strcat (buffer, "" (DLGINIT)""); break;
	    case 241: strcat (buffer, "" (TOOLBAR)""); break;
",unused,binutils1-bfd2Fpeigen.c
"    }

  if (dir != NULL && dir->entry != NULL)
    {
      strcat (buffer, "" name: "");
",1,unused,3749,unused,"    }

  if (dir != NULL && dir->entry != NULL)
    {
      strcat (buffer, "" name: "");
",unused,binutils1-bfd2Fpeigen.c
"      else
	{
	  unsigned int id = dir->entry->name_id.id;

	  sprintf (buffer + strlen (buffer), ""%x"", id);
",1,unused,3756,unused,"      else
	{
	  unsigned int id = dir->entry->name_id.id;

	  sprintf (buffer + strlen (buffer), ""%x"", id);
",unused,binutils1-bfd2Fpeigen.c
"
	  sprintf (buffer + strlen (buffer), ""%x"", id);

	  if (is_string)
	    sprintf (buffer + strlen (buffer), "" (resource id range: %d - %d)"",
",1,unused,3759,unused,"
	  sprintf (buffer + strlen (buffer), ""%x"", id);

	  if (is_string)
	    sprintf (buffer + strlen (buffer), "" (resource id range: %d - %d)"",
",unused,binutils1-bfd2Fpeigen.c
"    }

  if (entry != NULL)
    {
      strcat (buffer, "" lang: "");
",1,unused,3766,unused,"    }

  if (entry != NULL)
    {
      strcat (buffer, "" lang: "");
",unused,binutils1-bfd2Fpeigen.c
"
      if (entry->is_name)
	rsrc_print_name (buffer + strlen (buffer), entry->name_id.name);
      else
	sprintf (buffer + strlen (buffer), ""%x"", entry->name_id.id);
",1,unused,3771,unused,"
      if (entry->is_name)
	rsrc_print_name (buffer + strlen (buffer), entry->name_id.name);
      else
	sprintf (buffer + strlen (buffer), ""%x"", entry->name_id.id);
",unused,binutils1-bfd2Fpeigen.c
"		  _bfd_error_handler (_(""%B: out of memory creating name for empty section""),
				      abfd);
		  return;
		}
	      strcpy ((char *) name, namebuf);
",1,unused,187,unused,"		  _bfd_error_handler (_(""%B: out of memory creating name for empty section""),
				      abfd);
		  return;
		}
	      strcpy ((char *) name, namebuf);
",unused,binutils1-bfd2Fpex64igen.c
"					       idd.SizeOfData, cvinfo))
            continue;

          for (i = 0; i < cvinfo->SignatureLength; i++)
            sprintf (&signature[i*2], ""%02x"", cvinfo->Signature[i] & 0xff);
",1,unused,2718,unused,"					       idd.SizeOfData, cvinfo))
            continue;

          for (i = 0; i < cvinfo->SignatureLength; i++)
            sprintf (&signature[i*2], ""%02x"", cvinfo->Signature[i] & 0xff);
",unused,binutils1-bfd2Fpex64igen.c
"  unsigned int  i;
  bfd_byte *    name = string.string;

  for (i = string.len; i--; name += 2)
    sprintf (buffer + strlen (buffer), ""%.1s"", name);
",1,unused,3695,unused,"  unsigned int  i;
  bfd_byte *    name = string.string;

  for (i = string.len; i--; name += 2)
    sprintf (buffer + strlen (buffer), ""%.1s"", name);
",unused,binutils1-bfd2Fpex64igen.c
"
  if (dir != NULL && dir->entry != NULL && dir->entry->parent != NULL
      && dir->entry->parent->entry != NULL)
    {
      strcpy (buffer, ""type: "");
",1,unused,3709,unused,"
  if (dir != NULL && dir->entry != NULL && dir->entry->parent != NULL
      && dir->entry->parent->entry != NULL)
    {
      strcpy (buffer, ""type: "");
",unused,binutils1-bfd2Fpex64igen.c
"      else
	{
	  unsigned int id = dir->entry->parent->entry->name_id.id;

	  sprintf (buffer + strlen (buffer), ""%x"", id);
",1,unused,3717,unused,"      else
	{
	  unsigned int id = dir->entry->parent->entry->name_id.id;

	  sprintf (buffer + strlen (buffer), ""%x"", id);
",unused,binutils1-bfd2Fpex64igen.c
"
	  sprintf (buffer + strlen (buffer), ""%x"", id);
	  switch (id)
	    {
	    case 1: strcat (buffer, "" (CURSOR)""); break;
",1,unused,3720,unused,"
	  sprintf (buffer + strlen (buffer), ""%x"", id);
	  switch (id)
	    {
	    case 1: strcat (buffer, "" (CURSOR)""); break;
",unused,binutils1-bfd2Fpex64igen.c
"	  sprintf (buffer + strlen (buffer), ""%x"", id);
	  switch (id)
	    {
	    case 1: strcat (buffer, "" (CURSOR)""); break;
	    case 2: strcat (buffer, "" (BITMAP)""); break;
",1,unused,3721,unused,"	  sprintf (buffer + strlen (buffer), ""%x"", id);
	  switch (id)
	    {
	    case 1: strcat (buffer, "" (CURSOR)""); break;
	    case 2: strcat (buffer, "" (BITMAP)""); break;
",unused,binutils1-bfd2Fpex64igen.c
"	  switch (id)
	    {
	    case 1: strcat (buffer, "" (CURSOR)""); break;
	    case 2: strcat (buffer, "" (BITMAP)""); break;
	    case 3: strcat (buffer, "" (ICON)""); break;
",1,unused,3722,unused,"	  switch (id)
	    {
	    case 1: strcat (buffer, "" (CURSOR)""); break;
	    case 2: strcat (buffer, "" (BITMAP)""); break;
	    case 3: strcat (buffer, "" (ICON)""); break;
",unused,binutils1-bfd2Fpex64igen.c
"	    {
	    case 1: strcat (buffer, "" (CURSOR)""); break;
	    case 2: strcat (buffer, "" (BITMAP)""); break;
	    case 3: strcat (buffer, "" (ICON)""); break;
            case 4: strcat (buffer, "" (MENU)""); break;
",1,unused,3723,unused,"	    {
	    case 1: strcat (buffer, "" (CURSOR)""); break;
	    case 2: strcat (buffer, "" (BITMAP)""); break;
	    case 3: strcat (buffer, "" (ICON)""); break;
            case 4: strcat (buffer, "" (MENU)""); break;
",unused,binutils1-bfd2Fpex64igen.c
"	    case 1: strcat (buffer, "" (CURSOR)""); break;
	    case 2: strcat (buffer, "" (BITMAP)""); break;
	    case 3: strcat (buffer, "" (ICON)""); break;
            case 4: strcat (buffer, "" (MENU)""); break;
	    case 5: strcat (buffer, "" (DIALOG)""); break;
",1,unused,3724,unused,"	    case 1: strcat (buffer, "" (CURSOR)""); break;
	    case 2: strcat (buffer, "" (BITMAP)""); break;
	    case 3: strcat (buffer, "" (ICON)""); break;
            case 4: strcat (buffer, "" (MENU)""); break;
	    case 5: strcat (buffer, "" (DIALOG)""); break;
",unused,binutils1-bfd2Fpex64igen.c
"	    case 2: strcat (buffer, "" (BITMAP)""); break;
	    case 3: strcat (buffer, "" (ICON)""); break;
            case 4: strcat (buffer, "" (MENU)""); break;
	    case 5: strcat (buffer, "" (DIALOG)""); break;
	    case 6: strcat (buffer, "" (STRING)""); is_string = TRUE; break;
",1,unused,3725,unused,"	    case 2: strcat (buffer, "" (BITMAP)""); break;
	    case 3: strcat (buffer, "" (ICON)""); break;
            case 4: strcat (buffer, "" (MENU)""); break;
	    case 5: strcat (buffer, "" (DIALOG)""); break;
	    case 6: strcat (buffer, "" (STRING)""); is_string = TRUE; break;
",unused,binutils1-bfd2Fpex64igen.c
"	    case 3: strcat (buffer, "" (ICON)""); break;
            case 4: strcat (buffer, "" (MENU)""); break;
	    case 5: strcat (buffer, "" (DIALOG)""); break;
	    case 6: strcat (buffer, "" (STRING)""); is_string = TRUE; break;
	    case 7: strcat (buffer, "" (FONTDIR)""); break;
",1,unused,3726,unused,"	    case 3: strcat (buffer, "" (ICON)""); break;
            case 4: strcat (buffer, "" (MENU)""); break;
	    case 5: strcat (buffer, "" (DIALOG)""); break;
	    case 6: strcat (buffer, "" (STRING)""); is_string = TRUE; break;
	    case 7: strcat (buffer, "" (FONTDIR)""); break;
",unused,binutils1-bfd2Fpex64igen.c
"            case 4: strcat (buffer, "" (MENU)""); break;
	    case 5: strcat (buffer, "" (DIALOG)""); break;
	    case 6: strcat (buffer, "" (STRING)""); is_string = TRUE; break;
	    case 7: strcat (buffer, "" (FONTDIR)""); break;
	    case 8: strcat (buffer, "" (FONT)""); break;
",1,unused,3727,unused,"            case 4: strcat (buffer, "" (MENU)""); break;
	    case 5: strcat (buffer, "" (DIALOG)""); break;
	    case 6: strcat (buffer, "" (STRING)""); is_string = TRUE; break;
	    case 7: strcat (buffer, "" (FONTDIR)""); break;
	    case 8: strcat (buffer, "" (FONT)""); break;
",unused,binutils1-bfd2Fpex64igen.c
"	    case 5: strcat (buffer, "" (DIALOG)""); break;
	    case 6: strcat (buffer, "" (STRING)""); is_string = TRUE; break;
	    case 7: strcat (buffer, "" (FONTDIR)""); break;
	    case 8: strcat (buffer, "" (FONT)""); break;
	    case 9: strcat (buffer, "" (ACCELERATOR)""); break;
",1,unused,3728,unused,"	    case 5: strcat (buffer, "" (DIALOG)""); break;
	    case 6: strcat (buffer, "" (STRING)""); is_string = TRUE; break;
	    case 7: strcat (buffer, "" (FONTDIR)""); break;
	    case 8: strcat (buffer, "" (FONT)""); break;
	    case 9: strcat (buffer, "" (ACCELERATOR)""); break;
",unused,binutils1-bfd2Fpex64igen.c
"	    case 6: strcat (buffer, "" (STRING)""); is_string = TRUE; break;
	    case 7: strcat (buffer, "" (FONTDIR)""); break;
	    case 8: strcat (buffer, "" (FONT)""); break;
	    case 9: strcat (buffer, "" (ACCELERATOR)""); break;
	    case 10: strcat (buffer, "" (RCDATA)""); break;
",1,unused,3729,unused,"	    case 6: strcat (buffer, "" (STRING)""); is_string = TRUE; break;
	    case 7: strcat (buffer, "" (FONTDIR)""); break;
	    case 8: strcat (buffer, "" (FONT)""); break;
	    case 9: strcat (buffer, "" (ACCELERATOR)""); break;
	    case 10: strcat (buffer, "" (RCDATA)""); break;
",unused,binutils1-bfd2Fpex64igen.c
"	    case 7: strcat (buffer, "" (FONTDIR)""); break;
	    case 8: strcat (buffer, "" (FONT)""); break;
	    case 9: strcat (buffer, "" (ACCELERATOR)""); break;
	    case 10: strcat (buffer, "" (RCDATA)""); break;
	    case 11: strcat (buffer, "" (MESSAGETABLE)""); break;
",1,unused,3730,unused,"	    case 7: strcat (buffer, "" (FONTDIR)""); break;
	    case 8: strcat (buffer, "" (FONT)""); break;
	    case 9: strcat (buffer, "" (ACCELERATOR)""); break;
	    case 10: strcat (buffer, "" (RCDATA)""); break;
	    case 11: strcat (buffer, "" (MESSAGETABLE)""); break;
",unused,binutils1-bfd2Fpex64igen.c
"	    case 8: strcat (buffer, "" (FONT)""); break;
	    case 9: strcat (buffer, "" (ACCELERATOR)""); break;
	    case 10: strcat (buffer, "" (RCDATA)""); break;
	    case 11: strcat (buffer, "" (MESSAGETABLE)""); break;
	    case 12: strcat (buffer, "" (GROUP_CURSOR)""); break;
",1,unused,3731,unused,"	    case 8: strcat (buffer, "" (FONT)""); break;
	    case 9: strcat (buffer, "" (ACCELERATOR)""); break;
	    case 10: strcat (buffer, "" (RCDATA)""); break;
	    case 11: strcat (buffer, "" (MESSAGETABLE)""); break;
	    case 12: strcat (buffer, "" (GROUP_CURSOR)""); break;
",unused,binutils1-bfd2Fpex64igen.c
"	    case 9: strcat (buffer, "" (ACCELERATOR)""); break;
	    case 10: strcat (buffer, "" (RCDATA)""); break;
	    case 11: strcat (buffer, "" (MESSAGETABLE)""); break;
	    case 12: strcat (buffer, "" (GROUP_CURSOR)""); break;
	    case 14: strcat (buffer, "" (GROUP_ICON)""); break;
",1,unused,3732,unused,"	    case 9: strcat (buffer, "" (ACCELERATOR)""); break;
	    case 10: strcat (buffer, "" (RCDATA)""); break;
	    case 11: strcat (buffer, "" (MESSAGETABLE)""); break;
	    case 12: strcat (buffer, "" (GROUP_CURSOR)""); break;
	    case 14: strcat (buffer, "" (GROUP_ICON)""); break;
",unused,binutils1-bfd2Fpex64igen.c
"	    case 10: strcat (buffer, "" (RCDATA)""); break;
	    case 11: strcat (buffer, "" (MESSAGETABLE)""); break;
	    case 12: strcat (buffer, "" (GROUP_CURSOR)""); break;
	    case 14: strcat (buffer, "" (GROUP_ICON)""); break;
	    case 16: strcat (buffer, "" (VERSION)""); break;
",1,unused,3733,unused,"	    case 10: strcat (buffer, "" (RCDATA)""); break;
	    case 11: strcat (buffer, "" (MESSAGETABLE)""); break;
	    case 12: strcat (buffer, "" (GROUP_CURSOR)""); break;
	    case 14: strcat (buffer, "" (GROUP_ICON)""); break;
	    case 16: strcat (buffer, "" (VERSION)""); break;
",unused,binutils1-bfd2Fpex64igen.c
"	    case 11: strcat (buffer, "" (MESSAGETABLE)""); break;
	    case 12: strcat (buffer, "" (GROUP_CURSOR)""); break;
	    case 14: strcat (buffer, "" (GROUP_ICON)""); break;
	    case 16: strcat (buffer, "" (VERSION)""); break;
	    case 17: strcat (buffer, "" (DLGINCLUDE)""); break;
",1,unused,3734,unused,"	    case 11: strcat (buffer, "" (MESSAGETABLE)""); break;
	    case 12: strcat (buffer, "" (GROUP_CURSOR)""); break;
	    case 14: strcat (buffer, "" (GROUP_ICON)""); break;
	    case 16: strcat (buffer, "" (VERSION)""); break;
	    case 17: strcat (buffer, "" (DLGINCLUDE)""); break;
",unused,binutils1-bfd2Fpex64igen.c
"	    case 12: strcat (buffer, "" (GROUP_CURSOR)""); break;
	    case 14: strcat (buffer, "" (GROUP_ICON)""); break;
	    case 16: strcat (buffer, "" (VERSION)""); break;
	    case 17: strcat (buffer, "" (DLGINCLUDE)""); break;
	    case 19: strcat (buffer, "" (PLUGPLAY)""); break;
",1,unused,3735,unused,"	    case 12: strcat (buffer, "" (GROUP_CURSOR)""); break;
	    case 14: strcat (buffer, "" (GROUP_ICON)""); break;
	    case 16: strcat (buffer, "" (VERSION)""); break;
	    case 17: strcat (buffer, "" (DLGINCLUDE)""); break;
	    case 19: strcat (buffer, "" (PLUGPLAY)""); break;
",unused,binutils1-bfd2Fpex64igen.c
"	    case 14: strcat (buffer, "" (GROUP_ICON)""); break;
	    case 16: strcat (buffer, "" (VERSION)""); break;
	    case 17: strcat (buffer, "" (DLGINCLUDE)""); break;
	    case 19: strcat (buffer, "" (PLUGPLAY)""); break;
	    case 20: strcat (buffer, "" (VXD)""); break;
",1,unused,3736,unused,"	    case 14: strcat (buffer, "" (GROUP_ICON)""); break;
	    case 16: strcat (buffer, "" (VERSION)""); break;
	    case 17: strcat (buffer, "" (DLGINCLUDE)""); break;
	    case 19: strcat (buffer, "" (PLUGPLAY)""); break;
	    case 20: strcat (buffer, "" (VXD)""); break;
",unused,binutils1-bfd2Fpex64igen.c
"	    case 16: strcat (buffer, "" (VERSION)""); break;
	    case 17: strcat (buffer, "" (DLGINCLUDE)""); break;
	    case 19: strcat (buffer, "" (PLUGPLAY)""); break;
	    case 20: strcat (buffer, "" (VXD)""); break;
	    case 21: strcat (buffer, "" (ANICURSOR)""); break;
",1,unused,3737,unused,"	    case 16: strcat (buffer, "" (VERSION)""); break;
	    case 17: strcat (buffer, "" (DLGINCLUDE)""); break;
	    case 19: strcat (buffer, "" (PLUGPLAY)""); break;
	    case 20: strcat (buffer, "" (VXD)""); break;
	    case 21: strcat (buffer, "" (ANICURSOR)""); break;
",unused,binutils1-bfd2Fpex64igen.c
"	    case 17: strcat (buffer, "" (DLGINCLUDE)""); break;
	    case 19: strcat (buffer, "" (PLUGPLAY)""); break;
	    case 20: strcat (buffer, "" (VXD)""); break;
	    case 21: strcat (buffer, "" (ANICURSOR)""); break;
	    case 22: strcat (buffer, "" (ANIICON)""); break;
",1,unused,3738,unused,"	    case 17: strcat (buffer, "" (DLGINCLUDE)""); break;
	    case 19: strcat (buffer, "" (PLUGPLAY)""); break;
	    case 20: strcat (buffer, "" (VXD)""); break;
	    case 21: strcat (buffer, "" (ANICURSOR)""); break;
	    case 22: strcat (buffer, "" (ANIICON)""); break;
",unused,binutils1-bfd2Fpex64igen.c
"	    case 19: strcat (buffer, "" (PLUGPLAY)""); break;
	    case 20: strcat (buffer, "" (VXD)""); break;
	    case 21: strcat (buffer, "" (ANICURSOR)""); break;
	    case 22: strcat (buffer, "" (ANIICON)""); break;
	    case 23: strcat (buffer, "" (HTML)""); break;
",1,unused,3739,unused,"	    case 19: strcat (buffer, "" (PLUGPLAY)""); break;
	    case 20: strcat (buffer, "" (VXD)""); break;
	    case 21: strcat (buffer, "" (ANICURSOR)""); break;
	    case 22: strcat (buffer, "" (ANIICON)""); break;
	    case 23: strcat (buffer, "" (HTML)""); break;
",unused,binutils1-bfd2Fpex64igen.c
"	    case 20: strcat (buffer, "" (VXD)""); break;
	    case 21: strcat (buffer, "" (ANICURSOR)""); break;
	    case 22: strcat (buffer, "" (ANIICON)""); break;
	    case 23: strcat (buffer, "" (HTML)""); break;
	    case 24: strcat (buffer, "" (MANIFEST)""); break;
",1,unused,3740,unused,"	    case 20: strcat (buffer, "" (VXD)""); break;
	    case 21: strcat (buffer, "" (ANICURSOR)""); break;
	    case 22: strcat (buffer, "" (ANIICON)""); break;
	    case 23: strcat (buffer, "" (HTML)""); break;
	    case 24: strcat (buffer, "" (MANIFEST)""); break;
",unused,binutils1-bfd2Fpex64igen.c
"	    case 21: strcat (buffer, "" (ANICURSOR)""); break;
	    case 22: strcat (buffer, "" (ANIICON)""); break;
	    case 23: strcat (buffer, "" (HTML)""); break;
	    case 24: strcat (buffer, "" (MANIFEST)""); break;
	    case 240: strcat (buffer, "" (DLGINIT)""); break;
",1,unused,3741,unused,"	    case 21: strcat (buffer, "" (ANICURSOR)""); break;
	    case 22: strcat (buffer, "" (ANIICON)""); break;
	    case 23: strcat (buffer, "" (HTML)""); break;
	    case 24: strcat (buffer, "" (MANIFEST)""); break;
	    case 240: strcat (buffer, "" (DLGINIT)""); break;
",unused,binutils1-bfd2Fpex64igen.c
"	    case 22: strcat (buffer, "" (ANIICON)""); break;
	    case 23: strcat (buffer, "" (HTML)""); break;
	    case 24: strcat (buffer, "" (MANIFEST)""); break;
	    case 240: strcat (buffer, "" (DLGINIT)""); break;
	    case 241: strcat (buffer, "" (TOOLBAR)""); break;
",1,unused,3742,unused,"	    case 22: strcat (buffer, "" (ANIICON)""); break;
	    case 23: strcat (buffer, "" (HTML)""); break;
	    case 24: strcat (buffer, "" (MANIFEST)""); break;
	    case 240: strcat (buffer, "" (DLGINIT)""); break;
	    case 241: strcat (buffer, "" (TOOLBAR)""); break;
",unused,binutils1-bfd2Fpex64igen.c
"    }

  if (dir != NULL && dir->entry != NULL)
    {
      strcat (buffer, "" name: "");
",1,unused,3749,unused,"    }

  if (dir != NULL && dir->entry != NULL)
    {
      strcat (buffer, "" name: "");
",unused,binutils1-bfd2Fpex64igen.c
"      else
	{
	  unsigned int id = dir->entry->name_id.id;

	  sprintf (buffer + strlen (buffer), ""%x"", id);
",1,unused,3756,unused,"      else
	{
	  unsigned int id = dir->entry->name_id.id;

	  sprintf (buffer + strlen (buffer), ""%x"", id);
",unused,binutils1-bfd2Fpex64igen.c
"
	  sprintf (buffer + strlen (buffer), ""%x"", id);

	  if (is_string)
	    sprintf (buffer + strlen (buffer), "" (resource id range: %d - %d)"",
",1,unused,3759,unused,"
	  sprintf (buffer + strlen (buffer), ""%x"", id);

	  if (is_string)
	    sprintf (buffer + strlen (buffer), "" (resource id range: %d - %d)"",
",unused,binutils1-bfd2Fpex64igen.c
"    }

  if (entry != NULL)
    {
      strcat (buffer, "" lang: "");
",1,unused,3766,unused,"    }

  if (entry != NULL)
    {
      strcat (buffer, "" lang: "");
",unused,binutils1-bfd2Fpex64igen.c
"
      if (entry->is_name)
	rsrc_print_name (buffer + strlen (buffer), entry->name_id.name);
      else
	sprintf (buffer + strlen (buffer), ""%x"", entry->name_id.id);
",1,unused,3771,unused,"
      if (entry->is_name)
	rsrc_print_name (buffer + strlen (buffer), entry->name_id.name);
      else
	sprintf (buffer + strlen (buffer), ""%x"", entry->name_id.id);
",unused,binutils1-bfd2Fpex64igen.c
"	  memcpy (filename, path, s - path);
	  filename[s - path] = '/';
	  sset = filename + (s - path) + 1;
	}
      strcpy (sset, name);
",1,unused,512,unused,"	  memcpy (filename, path, s - path);
	  filename[s - path] = '/';
	  sset = filename + (s - path) + 1;
	}
      strcpy (sset, name);
",unused,binutils1-ld2Feelf32_x86_64.c
"			{
			  char * current_dir = getpwd ();

			  freeme = xmalloc (strlen (replacement) + strlen (current_dir) + 2);
			  sprintf (freeme, ""%s/%s"", current_dir, replacement);
",1,unused,575,unused,"			{
			  char * current_dir = getpwd ();

			  freeme = xmalloc (strlen (replacement) + strlen (current_dir) + 2);
			  sprintf (freeme, ""%s/%s"", current_dir, replacement);
",unused,binutils1-ld2Feelf32_x86_64.c
"	      char * filename2 = xmalloc (flen + strlen (replacement));

	      if (end)
		{
		  sprintf (filename2, ""%.*s%s/%s"",
",1,unused,623,unused,"	      char * filename2 = xmalloc (flen + strlen (replacement));

	      if (end)
		{
		  sprintf (filename2, ""%.*s%s/%s"",
",unused,binutils1-ld2Feelf32_x86_64.c
"		  offset = (var - filename) + 1 + strlen (replacement);
		}
	      else
		{
		  sprintf (filename2, ""%.*s%s"",
",1,unused,630,unused,"		  offset = (var - filename) + 1 + strlen (replacement);
		}
	      else
		{
		  sprintf (filename2, ""%.*s%s"",
",unused,binutils1-ld2Feelf32_x86_64.c
"    colons++;

  len = len + (colons + 1) * strlen (ld_sysroot);
  ret = xmalloc (len + 1);
  strcpy (ret, ld_sysroot);
",1,unused,698,unused,"    colons++;

  len = len + (colons + 1) * strlen (ld_sysroot);
  ret = xmalloc (len + 1);
  strcpy (ret, ld_sysroot);
",unused,binutils1-ld2Feelf32_x86_64.c
"  while (path[i])
    if (path[i] == config.rpath_separator)
      {
	*p++ = path[i++];
	strcpy (p, ld_sysroot);
",1,unused,705,unused,"  while (path[i])
    if (path[i] == config.rpath_separator)
      {
	*p++ = path[i++];
	strcpy (p, ld_sysroot);
",unused,binutils1-ld2Feelf32_x86_64.c
"
	      if (search->cmdline)
		continue;
	      filename = (char *) xmalloc (strlen (search->name) + len + 2);
	      sprintf (filename, ""%s/%s"", search->name, l->name);
",1,unused,1340,unused,"
	      if (search->cmdline)
		continue;
	      filename = (char *) xmalloc (strlen (search->name) + len + 2);
	      sprintf (filename, ""%s/%s"", search->name, l->name);
",unused,binutils1-ld2Feelf32_x86_64.c
"
      if (cp == NULL)
	{
	  buf = xmalloc (to_len + op_arg_len + 2);
	  sprintf (buf, ""%s%c%s"", *to,
",1,unused,1462,unused,"
      if (cp == NULL)
	{
	  buf = xmalloc (to_len + op_arg_len + 2);
	  sprintf (buf, ""%s%c%s"", *to,
",unused,binutils1-ld2Feelf32_x86_64.c
"  if (entry->flags.full_name_provided)
    {
      len += sizeof ""/"";
      string = (char *) xmalloc (len);
      sprintf (string, ""%s/%s"", search->name, filename);
",1,unused,1671,unused,"  if (entry->flags.full_name_provided)
    {
      len += sizeof ""/"";
      string = (char *) xmalloc (len);
      sprintf (string, ""%s/%s"", search->name, filename);
",unused,binutils1-ld2Feelf32_x86_64.c
"	      ? strlen (EXTRA_SHLIB_EXTENSION) - 3
	      : 0);
#endif
      string = (char *) xmalloc (len + xlen);
      sprintf (string, ""%s/lib%s%s.so"", search->name, filename, arch);
",1,unused,1684,unused,"	      ? strlen (EXTRA_SHLIB_EXTENSION) - 3
	      : 0);
#endif
      string = (char *) xmalloc (len + xlen);
      sprintf (string, ""%s/lib%s%s.so"", search->name, filename, arch);
",unused,binutils1-ld2Feelf32_x86_64.c
"	  memcpy (filename, path, s - path);
	  filename[s - path] = '/';
	  sset = filename + (s - path) + 1;
	}
      strcpy (sset, name);
",1,unused,512,unused,"	  memcpy (filename, path, s - path);
	  filename[s - path] = '/';
	  sset = filename + (s - path) + 1;
	}
      strcpy (sset, name);
",unused,binutils1-ld2Feelf_i386.c
"			{
			  char * current_dir = getpwd ();

			  freeme = xmalloc (strlen (replacement) + strlen (current_dir) + 2);
			  sprintf (freeme, ""%s/%s"", current_dir, replacement);
",1,unused,575,unused,"			{
			  char * current_dir = getpwd ();

			  freeme = xmalloc (strlen (replacement) + strlen (current_dir) + 2);
			  sprintf (freeme, ""%s/%s"", current_dir, replacement);
",unused,binutils1-ld2Feelf_i386.c
"	      char * filename2 = xmalloc (flen + strlen (replacement));

	      if (end)
		{
		  sprintf (filename2, ""%.*s%s/%s"",
",1,unused,623,unused,"	      char * filename2 = xmalloc (flen + strlen (replacement));

	      if (end)
		{
		  sprintf (filename2, ""%.*s%s/%s"",
",unused,binutils1-ld2Feelf_i386.c
"		  offset = (var - filename) + 1 + strlen (replacement);
		}
	      else
		{
		  sprintf (filename2, ""%.*s%s"",
",1,unused,630,unused,"		  offset = (var - filename) + 1 + strlen (replacement);
		}
	      else
		{
		  sprintf (filename2, ""%.*s%s"",
",unused,binutils1-ld2Feelf_i386.c
"    colons++;

  len = len + (colons + 1) * strlen (ld_sysroot);
  ret = xmalloc (len + 1);
  strcpy (ret, ld_sysroot);
",1,unused,698,unused,"    colons++;

  len = len + (colons + 1) * strlen (ld_sysroot);
  ret = xmalloc (len + 1);
  strcpy (ret, ld_sysroot);
",unused,binutils1-ld2Feelf_i386.c
"  while (path[i])
    if (path[i] == config.rpath_separator)
      {
	*p++ = path[i++];
	strcpy (p, ld_sysroot);
",1,unused,705,unused,"  while (path[i])
    if (path[i] == config.rpath_separator)
      {
	*p++ = path[i++];
	strcpy (p, ld_sysroot);
",unused,binutils1-ld2Feelf_i386.c
"
	      if (search->cmdline)
		continue;
	      filename = (char *) xmalloc (strlen (search->name) + len + 2);
	      sprintf (filename, ""%s/%s"", search->name, l->name);
",1,unused,1340,unused,"
	      if (search->cmdline)
		continue;
	      filename = (char *) xmalloc (strlen (search->name) + len + 2);
	      sprintf (filename, ""%s/%s"", search->name, l->name);
",unused,binutils1-ld2Feelf_i386.c
"
      if (cp == NULL)
	{
	  buf = xmalloc (to_len + op_arg_len + 2);
	  sprintf (buf, ""%s%c%s"", *to,
",1,unused,1462,unused,"
      if (cp == NULL)
	{
	  buf = xmalloc (to_len + op_arg_len + 2);
	  sprintf (buf, ""%s%c%s"", *to,
",unused,binutils1-ld2Feelf_i386.c
"  if (entry->flags.full_name_provided)
    {
      len += sizeof ""/"";
      string = (char *) xmalloc (len);
      sprintf (string, ""%s/%s"", search->name, filename);
",1,unused,1671,unused,"  if (entry->flags.full_name_provided)
    {
      len += sizeof ""/"";
      string = (char *) xmalloc (len);
      sprintf (string, ""%s/%s"", search->name, filename);
",unused,binutils1-ld2Feelf_i386.c
"	      ? strlen (EXTRA_SHLIB_EXTENSION) - 3
	      : 0);
#endif
      string = (char *) xmalloc (len + xlen);
      sprintf (string, ""%s/lib%s%s.so"", search->name, filename, arch);
",1,unused,1684,unused,"	      ? strlen (EXTRA_SHLIB_EXTENSION) - 3
	      : 0);
#endif
      string = (char *) xmalloc (len + xlen);
      sprintf (string, ""%s/lib%s%s.so"", search->name, filename, arch);
",unused,binutils1-ld2Feelf_i386.c
"	  memcpy (filename, path, s - path);
	  filename[s - path] = '/';
	  sset = filename + (s - path) + 1;
	}
      strcpy (sset, name);
",1,unused,509,unused,"	  memcpy (filename, path, s - path);
	  filename[s - path] = '/';
	  sset = filename + (s - path) + 1;
	}
      strcpy (sset, name);
",unused,binutils1-ld2Feelf_iamcu.c
"			{
			  char * current_dir = getpwd ();

			  freeme = xmalloc (strlen (replacement) + strlen (current_dir) + 2);
			  sprintf (freeme, ""%s/%s"", current_dir, replacement);
",1,unused,572,unused,"			{
			  char * current_dir = getpwd ();

			  freeme = xmalloc (strlen (replacement) + strlen (current_dir) + 2);
			  sprintf (freeme, ""%s/%s"", current_dir, replacement);
",unused,binutils1-ld2Feelf_iamcu.c
"	      char * filename2 = xmalloc (flen + strlen (replacement));

	      if (end)
		{
		  sprintf (filename2, ""%.*s%s/%s"",
",1,unused,620,unused,"	      char * filename2 = xmalloc (flen + strlen (replacement));

	      if (end)
		{
		  sprintf (filename2, ""%.*s%s/%s"",
",unused,binutils1-ld2Feelf_iamcu.c
"		  offset = (var - filename) + 1 + strlen (replacement);
		}
	      else
		{
		  sprintf (filename2, ""%.*s%s"",
",1,unused,627,unused,"		  offset = (var - filename) + 1 + strlen (replacement);
		}
	      else
		{
		  sprintf (filename2, ""%.*s%s"",
",unused,binutils1-ld2Feelf_iamcu.c
"
	      if (search->cmdline)
		continue;
	      filename = (char *) xmalloc (strlen (search->name) + len + 2);
	      sprintf (filename, ""%s/%s"", search->name, l->name);
",1,unused,1053,unused,"
	      if (search->cmdline)
		continue;
	      filename = (char *) xmalloc (strlen (search->name) + len + 2);
	      sprintf (filename, ""%s/%s"", search->name, l->name);
",unused,binutils1-ld2Feelf_iamcu.c
"
      if (cp == NULL)
	{
	  buf = xmalloc (to_len + op_arg_len + 2);
	  sprintf (buf, ""%s%c%s"", *to,
",1,unused,1175,unused,"
      if (cp == NULL)
	{
	  buf = xmalloc (to_len + op_arg_len + 2);
	  sprintf (buf, ""%s%c%s"", *to,
",unused,binutils1-ld2Feelf_iamcu.c
"  if (entry->flags.full_name_provided)
    {
      len += sizeof ""/"";
      string = (char *) xmalloc (len);
      sprintf (string, ""%s/%s"", search->name, filename);
",1,unused,1384,unused,"  if (entry->flags.full_name_provided)
    {
      len += sizeof ""/"";
      string = (char *) xmalloc (len);
      sprintf (string, ""%s/%s"", search->name, filename);
",unused,binutils1-ld2Feelf_iamcu.c
"	      ? strlen (EXTRA_SHLIB_EXTENSION) - 3
	      : 0);
#endif
      string = (char *) xmalloc (len + xlen);
      sprintf (string, ""%s/lib%s%s.so"", search->name, filename, arch);
",1,unused,1397,unused,"	      ? strlen (EXTRA_SHLIB_EXTENSION) - 3
	      : 0);
#endif
      string = (char *) xmalloc (len + xlen);
      sprintf (string, ""%s/lib%s%s.so"", search->name, filename, arch);
",unused,binutils1-ld2Feelf_iamcu.c
"	  memcpy (filename, path, s - path);
	  filename[s - path] = '/';
	  sset = filename + (s - path) + 1;
	}
      strcpy (sset, name);
",1,unused,512,unused,"	  memcpy (filename, path, s - path);
	  filename[s - path] = '/';
	  sset = filename + (s - path) + 1;
	}
      strcpy (sset, name);
",unused,binutils1-ld2Feelf_k1om.c
"			{
			  char * current_dir = getpwd ();

			  freeme = xmalloc (strlen (replacement) + strlen (current_dir) + 2);
			  sprintf (freeme, ""%s/%s"", current_dir, replacement);
",1,unused,575,unused,"			{
			  char * current_dir = getpwd ();

			  freeme = xmalloc (strlen (replacement) + strlen (current_dir) + 2);
			  sprintf (freeme, ""%s/%s"", current_dir, replacement);
",unused,binutils1-ld2Feelf_k1om.c
"	      char * filename2 = xmalloc (flen + strlen (replacement));

	      if (end)
		{
		  sprintf (filename2, ""%.*s%s/%s"",
",1,unused,623,unused,"	      char * filename2 = xmalloc (flen + strlen (replacement));

	      if (end)
		{
		  sprintf (filename2, ""%.*s%s/%s"",
",unused,binutils1-ld2Feelf_k1om.c
"		  offset = (var - filename) + 1 + strlen (replacement);
		}
	      else
		{
		  sprintf (filename2, ""%.*s%s"",
",1,unused,630,unused,"		  offset = (var - filename) + 1 + strlen (replacement);
		}
	      else
		{
		  sprintf (filename2, ""%.*s%s"",
",unused,binutils1-ld2Feelf_k1om.c
"    colons++;

  len = len + (colons + 1) * strlen (ld_sysroot);
  ret = xmalloc (len + 1);
  strcpy (ret, ld_sysroot);
",1,unused,698,unused,"    colons++;

  len = len + (colons + 1) * strlen (ld_sysroot);
  ret = xmalloc (len + 1);
  strcpy (ret, ld_sysroot);
",unused,binutils1-ld2Feelf_k1om.c
"  while (path[i])
    if (path[i] == config.rpath_separator)
      {
	*p++ = path[i++];
	strcpy (p, ld_sysroot);
",1,unused,705,unused,"  while (path[i])
    if (path[i] == config.rpath_separator)
      {
	*p++ = path[i++];
	strcpy (p, ld_sysroot);
",unused,binutils1-ld2Feelf_k1om.c
"
	      if (search->cmdline)
		continue;
	      filename = (char *) xmalloc (strlen (search->name) + len + 2);
	      sprintf (filename, ""%s/%s"", search->name, l->name);
",1,unused,1340,unused,"
	      if (search->cmdline)
		continue;
	      filename = (char *) xmalloc (strlen (search->name) + len + 2);
	      sprintf (filename, ""%s/%s"", search->name, l->name);
",unused,binutils1-ld2Feelf_k1om.c
"
      if (cp == NULL)
	{
	  buf = xmalloc (to_len + op_arg_len + 2);
	  sprintf (buf, ""%s%c%s"", *to,
",1,unused,1462,unused,"
      if (cp == NULL)
	{
	  buf = xmalloc (to_len + op_arg_len + 2);
	  sprintf (buf, ""%s%c%s"", *to,
",unused,binutils1-ld2Feelf_k1om.c
"  if (entry->flags.full_name_provided)
    {
      len += sizeof ""/"";
      string = (char *) xmalloc (len);
      sprintf (string, ""%s/%s"", search->name, filename);
",1,unused,1671,unused,"  if (entry->flags.full_name_provided)
    {
      len += sizeof ""/"";
      string = (char *) xmalloc (len);
      sprintf (string, ""%s/%s"", search->name, filename);
",unused,binutils1-ld2Feelf_k1om.c
"	      ? strlen (EXTRA_SHLIB_EXTENSION) - 3
	      : 0);
#endif
      string = (char *) xmalloc (len + xlen);
      sprintf (string, ""%s/lib%s%s.so"", search->name, filename, arch);
",1,unused,1684,unused,"	      ? strlen (EXTRA_SHLIB_EXTENSION) - 3
	      : 0);
#endif
      string = (char *) xmalloc (len + xlen);
      sprintf (string, ""%s/lib%s%s.so"", search->name, filename, arch);
",unused,binutils1-ld2Feelf_k1om.c
"	  memcpy (filename, path, s - path);
	  filename[s - path] = '/';
	  sset = filename + (s - path) + 1;
	}
      strcpy (sset, name);
",1,unused,512,unused,"	  memcpy (filename, path, s - path);
	  filename[s - path] = '/';
	  sset = filename + (s - path) + 1;
	}
      strcpy (sset, name);
",unused,binutils1-ld2Feelf_x86_64.c
"			{
			  char * current_dir = getpwd ();

			  freeme = xmalloc (strlen (replacement) + strlen (current_dir) + 2);
			  sprintf (freeme, ""%s/%s"", current_dir, replacement);
",1,unused,575,unused,"			{
			  char * current_dir = getpwd ();

			  freeme = xmalloc (strlen (replacement) + strlen (current_dir) + 2);
			  sprintf (freeme, ""%s/%s"", current_dir, replacement);
",unused,binutils1-ld2Feelf_x86_64.c
"	      char * filename2 = xmalloc (flen + strlen (replacement));

	      if (end)
		{
		  sprintf (filename2, ""%.*s%s/%s"",
",1,unused,623,unused,"	      char * filename2 = xmalloc (flen + strlen (replacement));

	      if (end)
		{
		  sprintf (filename2, ""%.*s%s/%s"",
",unused,binutils1-ld2Feelf_x86_64.c
"		  offset = (var - filename) + 1 + strlen (replacement);
		}
	      else
		{
		  sprintf (filename2, ""%.*s%s"",
",1,unused,630,unused,"		  offset = (var - filename) + 1 + strlen (replacement);
		}
	      else
		{
		  sprintf (filename2, ""%.*s%s"",
",unused,binutils1-ld2Feelf_x86_64.c
"    colons++;

  len = len + (colons + 1) * strlen (ld_sysroot);
  ret = xmalloc (len + 1);
  strcpy (ret, ld_sysroot);
",1,unused,698,unused,"    colons++;

  len = len + (colons + 1) * strlen (ld_sysroot);
  ret = xmalloc (len + 1);
  strcpy (ret, ld_sysroot);
",unused,binutils1-ld2Feelf_x86_64.c
"  while (path[i])
    if (path[i] == config.rpath_separator)
      {
	*p++ = path[i++];
	strcpy (p, ld_sysroot);
",1,unused,705,unused,"  while (path[i])
    if (path[i] == config.rpath_separator)
      {
	*p++ = path[i++];
	strcpy (p, ld_sysroot);
",unused,binutils1-ld2Feelf_x86_64.c
"
	      if (search->cmdline)
		continue;
	      filename = (char *) xmalloc (strlen (search->name) + len + 2);
	      sprintf (filename, ""%s/%s"", search->name, l->name);
",1,unused,1340,unused,"
	      if (search->cmdline)
		continue;
	      filename = (char *) xmalloc (strlen (search->name) + len + 2);
	      sprintf (filename, ""%s/%s"", search->name, l->name);
",unused,binutils1-ld2Feelf_x86_64.c
"
      if (cp == NULL)
	{
	  buf = xmalloc (to_len + op_arg_len + 2);
	  sprintf (buf, ""%s%c%s"", *to,
",1,unused,1462,unused,"
      if (cp == NULL)
	{
	  buf = xmalloc (to_len + op_arg_len + 2);
	  sprintf (buf, ""%s%c%s"", *to,
",unused,binutils1-ld2Feelf_x86_64.c
"  if (entry->flags.full_name_provided)
    {
      len += sizeof ""/"";
      string = (char *) xmalloc (len);
      sprintf (string, ""%s/%s"", search->name, filename);
",1,unused,1671,unused,"  if (entry->flags.full_name_provided)
    {
      len += sizeof ""/"";
      string = (char *) xmalloc (len);
      sprintf (string, ""%s/%s"", search->name, filename);
",unused,binutils1-ld2Feelf_x86_64.c
"	      ? strlen (EXTRA_SHLIB_EXTENSION) - 3
	      : 0);
#endif
      string = (char *) xmalloc (len + xlen);
      sprintf (string, ""%s/lib%s%s.so"", search->name, filename, arch);
",1,unused,1684,unused,"	      ? strlen (EXTRA_SHLIB_EXTENSION) - 3
	      : 0);
#endif
      string = (char *) xmalloc (len + xlen);
      sprintf (string, ""%s/lib%s%s.so"", search->name, filename, arch);
",unused,binutils1-ld2Feelf_x86_64.c
"			     + strlen (entry->filename)
			     + strlen (arch)
			     + sizeof ""/lib.sa"");

  sprintf (string, ""%s/lib%s%s.sa"", search->name, entry->filename, arch);
",1,unused,65,unused,"			     + strlen (entry->filename)
			     + strlen (arch)
			     + sizeof ""/lib.sa"");

  sprintf (string, ""%s/lib%s%s.sa"", search->name, entry->filename, arch);
",unused,binutils1-ld2Fei386linux.c
"                text[i] = '.';
        }
        text[i] = '\0';

        out = line + sprintf (line, ""%08tx  "", ptr - (u_char*)buf);
",1,unused,183,unused,"                text[i] = '.';
        }
        text[i] = '\0';

        out = line + sprintf (line, ""%08tx  "", ptr - (u_char*)buf);
",unused,blu-corner_sbf-src2Fcommon2FsbfLog.c
"        out = line + sprintf (line, ""%08tx  "", ptr - (u_char*)buf);
        for (i = 0; i < 16; i++)
        {
            if (i == 8)
                out += sprintf (out, "" "");
",1,unused,187,unused,"        out = line + sprintf (line, ""%08tx  "", ptr - (u_char*)buf);
        for (i = 0; i < 16; i++)
        {
            if (i == 8)
                out += sprintf (out, "" "");
",unused,blu-corner_sbf-src2Fcommon2FsbfLog.c
"        {
            if (i == 8)
                out += sprintf (out, "" "");
            if (ptr + i >= end)
                out += sprintf (out, ""   "");
",1,unused,189,unused,"        {
            if (i == 8)
                out += sprintf (out, "" "");
            if (ptr + i >= end)
                out += sprintf (out, ""   "");
",unused,blu-corner_sbf-src2Fcommon2FsbfLog.c
"                out += sprintf (out, "" "");
            if (ptr + i >= end)
                out += sprintf (out, ""   "");
            else
                out += sprintf (out, ""%02hhx "", ptr[i]);
",1,unused,191,unused,"                out += sprintf (out, "" "");
            if (ptr + i >= end)
                out += sprintf (out, ""   "");
            else
                out += sprintf (out, ""%02hhx "", ptr[i]);
",unused,blu-corner_sbf-src2Fcommon2FsbfLog.c
"                out += sprintf (out, ""   "");
            else
                out += sprintf (out, ""%02hhx "", ptr[i]);
        }
        sprintf (out, "" |%s|"", text);
",1,unused,193,unused,"                out += sprintf (out, ""   "");
            else
                out += sprintf (out, ""%02hhx "", ptr[i]);
        }
        sprintf (out, "" |%s|"", text);
",unused,blu-corner_sbf-src2Fcommon2FsbfLog.c
"			ret = -ENOMEM;
			goto exit;
		}

		strcpy(entry, line);
",1,unused,901,unused,"			ret = -ENOMEM;
			goto exit;
		}

		strcpy(entry, line);
",unused,bluca_dpdk-app2Ftest-bbdev2Ftest_bbdev_vector.c
"				}

				entry = entry_extended;
				/* entry has been allocated accordingly */
				strcpy(&entry[strlen(entry)], line);
",1,unused,924,unused,"				}

				entry = entry_extended;
				/* entry has been allocated accordingly */
				strcpy(&entry[strlen(entry)], line);
",unused,bluca_dpdk-app2Ftest-bbdev2Ftest_bbdev_vector.c
"					sizeof(char) * strlen(line) + 1, 0);
		if (entry == NULL)
			return -1;

		strcpy(entry, line);
",1,unused,509,unused,"					sizeof(char) * strlen(line) + 1, 0);
		if (entry == NULL)
			return -1;

		strcpy(entry, line);
",unused,bluca_dpdk-app2Ftest-crypto-perf2Fcperf_test_vector_parsing.c
"				if (entry_extended == NULL)
					goto err;
				entry = entry_extended;
				/* entry has been allocated accordingly */
				strcpy(&entry[strlen(entry)], line);
",1,unused,527,unused,"				if (entry_extended == NULL)
					goto err;
				entry = entry_extended;
				/* entry has been allocated accordingly */
				strcpy(&entry[strlen(entry)], line);
",unused,bluca_dpdk-app2Ftest-crypto-perf2Fcperf_test_vector_parsing.c
"
	/* add the max port for rx_adapter */
	port_index = rte_eth_dev_count_total();
	for (; port_index < RTE_MAX_ETHPORTS; port_index += 1) {
		sprintf(driver_name, ""%s%u"", ""net_null"", drv_id);
",1,unused,482,unused,"
	/* add the max port for rx_adapter */
	port_index = rte_eth_dev_count_total();
	for (; port_index < RTE_MAX_ETHPORTS; port_index += 1) {
		sprintf(driver_name, ""%s%u"", ""net_null"", drv_id);
",unused,bluca_dpdk-app2Ftest2Ftest_event_eth_rx_adapter.c
"			char fm_name[16];
			snprintf(fm_name, 16, ""fm%d-mac%d"", i, j);
			if (strcmp(fm_name, sep) == 0) {
				if (out_name)
					strcpy(out_name, sep);
",1,unused,410,unused,"			char fm_name[16];
			snprintf(fm_name, 16, ""fm%d-mac%d"", i, j);
			if (strcmp(fm_name, sep) == 0) {
				if (out_name)
					strcpy(out_name, sep);
",unused,bluca_dpdk-drivers2Fbus2Fdpaa2Fdpaa_bus.c
"
		snprintf(sec_name, 16, ""dpaa-sec%d"", i);
		if (strcmp(sec_name, sep) == 0) {
			if (out_name)
				strcpy(out_name, sep);
",1,unused,422,unused,"
		snprintf(sec_name, 16, ""dpaa-sec%d"", i);
		if (strcmp(sec_name, sep) == 0) {
			if (out_name)
				strcpy(out_name, sep);
",unused,bluca_dpdk-drivers2Fbus2Fdpaa2Fdpaa_bus.c
"	}
	free(dname);

	if (addr)
		strcpy(addr, name);
",1,unused,270,unused,"	}
	free(dname);

	if (addr)
		strcpy(addr, name);
",unused,bluca_dpdk-drivers2Fbus2Ffslmc2Ffslmc_bus.c
"	EVENTDEV_INIT_FUNC_TRACE();

	RTE_SET_USED(port_conf);

	sprintf(event_port_name, ""event-port-%d"", port_id);
",1,unused,539,unused,"	EVENTDEV_INIT_FUNC_TRACE();

	RTE_SET_USED(port_conf);

	sprintf(event_port_name, ""event-port-%d"", port_id);
",unused,bluca_dpdk-drivers2Fevent2Fdpaa22Fdpaa2_eventdev.c
"	unsigned int i;

	for (i = 0; i < RTE_DIM(dsw_dev_xstats) && i < size; i++) {
		ids[i] = i;
		strcpy(xstats_names[i].name, dsw_dev_xstats[i].name);
",1,unused,161,unused,"	unsigned int i;

	for (i = 0; i < RTE_DIM(dsw_dev_xstats) && i < size; i++) {
		ids[i] = i;
		strcpy(xstats_names[i].name, dsw_dev_xstats[i].name);
",unused,bluca_dpdk-drivers2Fevent2Fdsw2Fdsw_xstats.c
"	if (n < xstats_count || !xstats_names)
		return xstats_count;

	for (stat = 0; stat < ENA_STATS_ARRAY_GLOBAL; stat++, count++)
		strcpy(xstats_names[count].name,
",1,unused,2472,unused,"	if (n < xstats_count || !xstats_names)
		return xstats_count;

	for (stat = 0; stat < ENA_STATS_ARRAY_GLOBAL; stat++, count++)
		strcpy(xstats_names[count].name,
",unused,bluca_dpdk-drivers2Fnet2Fena2Fena_ethdev.c
"
	memset(&address, 0, sizeof(struct sockaddr));

	address.sa_family = AF_UNIX;
	strcpy(address.sa_data, ""/tmp/nfp_cpp"");
",1,unused,3250,unused,"
	memset(&address, 0, sizeof(struct sockaddr));

	address.sa_family = AF_UNIX;
	strcpy(address.sa_data, ""/tmp/nfp_cpp"");
",unused,bluca_dpdk-drivers2Fnet2Fnfp2Fnfp_net.c
"
	/* Looking for firmware file in order of priority */

	/* First try to find a firmware image specific for this device */
	sprintf(serial, ""serial-%02x-%02x-%02x-%02x-%02x-%02x-%02x-%02x"",
",1,unused,3436,unused,"
	/* Looking for firmware file in order of priority */

	/* First try to find a firmware image specific for this device */
	sprintf(serial, ""serial-%02x-%02x-%02x-%02x-%02x-%02x-%02x-%02x"",
",unused,bluca_dpdk-drivers2Fnet2Fnfp2Fnfp_net.c
"		cpp->serial[0], cpp->serial[1], cpp->serial[2], cpp->serial[3],
		cpp->serial[4], cpp->serial[5], cpp->interface >> 8,
		cpp->interface & 0xff);

	sprintf(fw_name, ""%s/%s.nffw"", DEFAULT_FW_PATH, serial);
",1,unused,3441,unused,"		cpp->serial[0], cpp->serial[1], cpp->serial[2], cpp->serial[3],
		cpp->serial[4], cpp->serial[5], cpp->interface >> 8,
		cpp->interface & 0xff);

	sprintf(fw_name, ""%s/%s.nffw"", DEFAULT_FW_PATH, serial);
",unused,bluca_dpdk-drivers2Fnet2Fnfp2Fnfp_net.c
"	if (fw_f > 0)
		goto read_fw;

	/* Then try the PCI name */
	sprintf(fw_name, ""%s/pci-%s.nffw"", DEFAULT_FW_PATH, dev->device.name);
",1,unused,3449,unused,"	if (fw_f > 0)
		goto read_fw;

	/* Then try the PCI name */
	sprintf(fw_name, ""%s/pci-%s.nffw"", DEFAULT_FW_PATH, dev->device.name);
",unused,bluca_dpdk-drivers2Fnet2Fnfp2Fnfp_net.c
"	if (fw_f > 0)
		goto read_fw;

	/* Finally try the card type and media */
	sprintf(fw_name, ""%s/%s"", DEFAULT_FW_PATH, card);
",1,unused,3457,unused,"	if (fw_f > 0)
		goto read_fw;

	/* Finally try the card type and media */
	sprintf(fw_name, ""%s/%s"", DEFAULT_FW_PATH, card);
",unused,bluca_dpdk-drivers2Fnet2Fnfp2Fnfp_net.c
"			   nfp_eth_table->count);

	PMD_DRV_LOG(INFO, ""Port speed: %u"", nfp_eth_table->ports[0].speed);

	sprintf(card_desc, ""nic_%s_%dx%d.nffw"", nfp_fw_model,
",1,unused,3533,unused,"			   nfp_eth_table->count);

	PMD_DRV_LOG(INFO, ""Port speed: %u"", nfp_eth_table->ports[0].speed);

	sprintf(card_desc, ""nic_%s_%dx%d.nffw"", nfp_fw_model,
",unused,bluca_dpdk-drivers2Fnet2Fnfp2Fnfp_net.c
"	home_path = getenv(""HOME"");
	lockfile = calloc(strlen(home_path) + strlen(lockname) + 1,
			  sizeof(char));

	strcat(lockfile, home_path);
",1,unused,691,unused,"	home_path = getenv(""HOME"");
	lockfile = calloc(strlen(home_path) + strlen(lockname) + 1,
			  sizeof(char));

	strcat(lockfile, home_path);
",unused,bluca_dpdk-drivers2Fnet2Fnfp2Fnfpcore2Fnfp_cpp_pcie_ops.c
"	lockfile = calloc(strlen(home_path) + strlen(lockname) + 1,
			  sizeof(char));

	strcat(lockfile, home_path);
	strcat(lockfile, ""/.lock_nfp_secondary"");
",1,unused,692,unused,"	lockfile = calloc(strlen(home_path) + strlen(lockname) + 1,
			  sizeof(char));

	strcat(lockfile, home_path);
	strcat(lockfile, ""/.lock_nfp_secondary"");
",unused,bluca_dpdk-drivers2Fnet2Fnfp2Fnfpcore2Fnfp_cpp_pcie_ops.c
"	for (j = 0; j < RTE_DIM(qede_tunn_types); j++) {
		if (filter == qede_tunn_types[j].rte_filter_type) {
			*type = qede_tunn_types[j].qede_type;
			*clss = qede_tunn_types[j].qede_tunn_clss;
			strcpy(str, qede_tunn_types[j].string);
",1,unused,969,unused,"	for (j = 0; j < RTE_DIM(qede_tunn_types); j++) {
		if (filter == qede_tunn_types[j].rte_filter_type) {
			*type = qede_tunn_types[j].qede_type;
			*clss = qede_tunn_types[j].qede_tunn_clss;
			strcpy(str, qede_tunn_types[j].string);
",unused,bluca_dpdk-drivers2Fnet2Fqede2Fqede_filter.c
"	struct stat st;
	const char *fw = RTE_LIBRTE_QEDE_FW;

	if (strcmp(fw, """") == 0)
		strcpy(qede_fw_file, QEDE_DEFAULT_FIRMWARE);
",1,unused,129,unused,"	struct stat st;
	const char *fw = RTE_LIBRTE_QEDE_FW;

	if (strcmp(fw, """") == 0)
		strcpy(qede_fw_file, QEDE_DEFAULT_FIRMWARE);
",unused,bluca_dpdk-drivers2Fnet2Fqede2Fqede_main.c
"
	if (strcmp(fw, """") == 0)
		strcpy(qede_fw_file, QEDE_DEFAULT_FIRMWARE);
	else
		strcpy(qede_fw_file, fw);
",1,unused,131,unused,"
	if (strcmp(fw, """") == 0)
		strcpy(qede_fw_file, QEDE_DEFAULT_FIRMWARE);
	else
		strcpy(qede_fw_file, fw);
",unused,bluca_dpdk-drivers2Fnet2Fqede2Fqede_main.c
"	}

	/* find default container's IOMMU type */
	p->req = SOCKET_REQ_IOMMU_TYPE;
	strcpy(mp_req.name, EAL_VFIO_MP);
",1,unused,575,unused,"	}

	/* find default container's IOMMU type */
	p->req = SOCKET_REQ_IOMMU_TYPE;
	strcpy(mp_req.name, EAL_VFIO_MP);
",unused,bluca_dpdk-lib2Flibrte_eal2Flinuxapp2Feal2Feal_vfio.c
"		return -1;
	}

	p->req = SOCKET_REQ_DEFAULT_CONTAINER;
	strcpy(mp_req.name, EAL_VFIO_MP);
",1,unused,1041,unused,"		return -1;
	}

	p->req = SOCKET_REQ_DEFAULT_CONTAINER;
	strcpy(mp_req.name, EAL_VFIO_MP);
",unused,bluca_dpdk-lib2Flibrte_eal2Flinuxapp2Feal2Feal_vfio.c
"	 * process via mp channel.
	 */
	p->req = SOCKET_REQ_GROUP;
	p->group_num = iommu_group_num;
	strcpy(mp_req.name, EAL_VFIO_MP);
",1,unused,307,unused,"	 * process via mp channel.
	 */
	p->req = SOCKET_REQ_GROUP;
	p->group_num = iommu_group_num;
	strcpy(mp_req.name, EAL_VFIO_MP);
",unused,bluca_dpdk-lib2Flibrte_eal2Flinuxapp2Feal2Feal_vfio.c
"	 * if we're in a secondary process, request container fd from the
	 * primary process via mp channel
	 */
	p->req = SOCKET_REQ_CONTAINER;
	strcpy(mp_req.name, EAL_VFIO_MP);
",1,unused,1171,unused,"	 * if we're in a secondary process, request container fd from the
	 * primary process via mp channel
	 */
	p->req = SOCKET_REQ_CONTAINER;
	strcpy(mp_req.name, EAL_VFIO_MP);
",unused,bluca_dpdk-lib2Flibrte_eal2Flinuxapp2Feal2Feal_vfio.c
"		RTE_LOG(ERR, EAL, ""vfio received invalid message!\n"");
		return -1;
	}

	strcpy(reply.name, EAL_VFIO_MP);
",1,unused,101,unused,"		RTE_LOG(ERR, EAL, ""vfio received invalid message!\n"");
		return -1;
	}

	strcpy(reply.name, EAL_VFIO_MP);
",unused,bluca_dpdk-lib2Flibrte_eal2Flinuxapp2Feal2Feal_vfio_mp_sync.c
"
	char pfi_str[32];
	uint64_t p0_empty_deq;

	sprintf(pfi_str, ""%02d"", freq);
",1,unused,162,unused,"
	char pfi_str[32];
	uint64_t p0_empty_deq;

	sprintf(pfi_str, ""%02d"", freq);
",unused,bluca_dpdk-lib2Flibrte_power2Frte_power_empty_poll.c
"	struct sdb_component *c = &i->sdb_component;
	struct sdb_product *p = &c->product;
	char fn[PATH_MAX];

	strcpy(fn, dir);
",1,unused,73,unused,"	struct sdb_component *c = &i->sdb_component;
	struct sdb_product *p = &c->product;
	char fn[PATH_MAX];

	strcpy(fn, dir);
",unused,br.com.lnls.dig.halcs-timing-devel-foreign2Flibsdbfs2Ftools2Fgensdbfs.c
"	struct sdb_product *p = &c->product;
	char fn[PATH_MAX];

	strcpy(fn, dir);
	strcat(fn, ""/."");
",1,unused,74,unused,"	struct sdb_product *p = &c->product;
	char fn[PATH_MAX];

	strcpy(fn, dir);
	strcat(fn, ""/."");
",unused,br.com.lnls.dig.halcs-timing-devel-foreign2Flibsdbfs2Ftools2Fgensdbfs.c
"	struct sdb_component *c = &d->sdb_component;
	struct sdb_product *p = &c->product;
	int flags;

	strcpy(fn, dir);
",1,unused,107,unused,"	struct sdb_component *c = &d->sdb_component;
	struct sdb_product *p = &c->product;
	int flags;

	strcpy(fn, dir);
",unused,br.com.lnls.dig.halcs-timing-devel-foreign2Flibsdbfs2Ftools2Fgensdbfs.c
"	struct sdb_product *p = &c->product;
	int flags;

	strcpy(fn, dir);
	strcat(fn, ""/"");
",1,unused,108,unused,"	struct sdb_product *p = &c->product;
	int flags;

	strcpy(fn, dir);
	strcat(fn, ""/"");
",unused,br.com.lnls.dig.halcs-timing-devel-foreign2Flibsdbfs2Ftools2Fgensdbfs.c
"	int flags;

	strcpy(fn, dir);
	strcat(fn, ""/"");
	strcat(fn, fname);
",1,unused,109,unused,"	int flags;

	strcpy(fn, dir);
	strcat(fn, ""/"");
	strcat(fn, fname);
",unused,br.com.lnls.dig.halcs-timing-devel-foreign2Flibsdbfs2Ftools2Fgensdbfs.c
"			continue; /* no dot-dot */
		if (!strcmp(de->d_name, CFG_NAME)) {
			char s[PATH_MAX];

			strcpy(s, name);
",1,unused,261,unused,"			continue; /* no dot-dot */
		if (!strcmp(de->d_name, CFG_NAME)) {
			char s[PATH_MAX];

			strcpy(s, name);
",unused,br.com.lnls.dig.halcs-timing-devel-foreign2Flibsdbfs2Ftools2Fgensdbfs.c
"		if (!strcmp(de->d_name, CFG_NAME)) {
			char s[PATH_MAX];

			strcpy(s, name);
			strcat(s, ""/"");
",1,unused,262,unused,"		if (!strcmp(de->d_name, CFG_NAME)) {
			char s[PATH_MAX];

			strcpy(s, name);
			strcat(s, ""/"");
",unused,br.com.lnls.dig.halcs-timing-devel-foreign2Flibsdbfs2Ftools2Fgensdbfs.c
"			char s[PATH_MAX];

			strcpy(s, name);
			strcat(s, ""/"");
			strcat(s, de->d_name);
",1,unused,263,unused,"			char s[PATH_MAX];

			strcpy(s, name);
			strcat(s, ""/"");
			strcat(s, de->d_name);
",unused,br.com.lnls.dig.halcs-timing-devel-foreign2Flibsdbfs2Ftools2Fgensdbfs.c
"                 const Char* newSuffix )
{
   if (!hasSuffix(name,oldSuffix)) return False;
   name[strlen(name)-strlen(oldSuffix)] = 0;
   strcat ( name, newSuffix );
",1,unused,1126,unused,"                 const Char* newSuffix )
{
   if (!hasSuffix(name,oldSuffix)) return False;
   name[strlen(name)-strlen(oldSuffix)] = 0;
   strcat ( name, newSuffix );
",unused,bzip2debianstretche1.0.6-bzip2.c
"         break;
      case SM_F2F: 
         copyFileName ( inName, name );
         copyFileName ( outName, name );
         strcat ( outName, "".bz2"" ); 
",1,unused,1153,unused,"         break;
      case SM_F2F: 
         copyFileName ( inName, name );
         copyFileName ( outName, name );
         strcat ( outName, "".bz2"" ); 
",unused,bzip2debianstretche1.0.6-bzip2.c
"         for (i = 0; i < BZ_N_SUFFIX_PAIRS; i++)
            if (mapSuffix(outName,zSuffix[i],unzSuffix[i]))
               goto zzz; 
         cantGuess = True;
         strcat ( outName, "".out"" );
",1,unused,1341,unused,"         for (i = 0; i < BZ_N_SUFFIX_PAIRS; i++)
            if (mapSuffix(outName,zSuffix[i],unzSuffix[i]))
               goto zzz; 
         cantGuess = True;
         strcat ( outName, "".out"" );
",unused,bzip2debianstretche1.0.6-bzip2.c
"{
   if (root == NULL) {
      Cell *tmp = mkCell();
      tmp->name = (Char*) myMalloc ( 5 + strlen(name) );
      strcpy ( tmp->name, name );
",1,unused,1734,unused,"{
   if (root == NULL) {
      Cell *tmp = mkCell();
      tmp->name = (Char*) myMalloc ( 5 + strlen(name) );
      strcpy ( tmp->name, name );
",unused,bzip2debianstretche1.0.6-bzip2.c
"         }
      }
      mode++;
   }
   strcat(mode2, writing ? ""w"" : ""r"" );
",1,unused,1417,unused,"         }
      }
      mode++;
   }
   strcat(mode2, writing ? ""w"" : ""r"" );
",unused,bzip2debianstretche1.0.6-bzlib.c
"      }
      mode++;
   }
   strcat(mode2, writing ? ""w"" : ""r"" );
   strcat(mode2,""b"");   /* binary mode */
",1,unused,1418,unused,"      }
      mode++;
   }
   strcat(mode2, writing ? ""w"" : ""r"" );
   strcat(mode2,""b"");   /* binary mode */
",unused,bzip2debianstretche1.0.6-bzlib.c
"
   UInt32      buffHi, buffLo, blockCRC;
   Char*       p;

   strcpy ( progName, argv[0] );
",1,unused,312,unused,"
   UInt32      buffHi, buffLo, blockCRC;
   Char*       p;

   strcpy ( progName, argv[0] );
",unused,bzip2jessie-bzip2recover.c
"                progName, (int)strlen(argv[1]) );
      exit(1);
   }

   strcpy ( inFileName, argv[1] );
",1,unused,349,unused,"                progName, (int)strlen(argv[1]) );
      exit(1);
   }

   strcpy ( inFileName, argv[1] );
",unused,bzip2jessie-bzip2recover.c
"         Char* split;
         Int32 ofs, k;
         for (k = 0; k < BZ_MAX_FILENAME; k++) 
            outFileName[k] = 0;
         strcpy (outFileName, inFileName);
",1,unused,471,unused,"         Char* split;
         Int32 ofs, k;
         for (k = 0; k < BZ_MAX_FILENAME; k++) 
            outFileName[k] = 0;
         strcpy (outFileName, inFileName);
",unused,bzip2jessie-bzip2recover.c
"            ++split;
	 }
	 /* Now split points to the start of the basename. */
         ofs  = split - outFileName;
         sprintf (split, ""rec%5d"", wrBlock+1);
",1,unused,480,unused,"            ++split;
	 }
	 /* Now split points to the start of the basename. */
         ofs  = split - outFileName;
         sprintf (split, ""rec%5d"", wrBlock+1);
",unused,bzip2jessie-bzip2recover.c
"	 /* Now split points to the start of the basename. */
         ofs  = split - outFileName;
         sprintf (split, ""rec%5d"", wrBlock+1);
         for (p = split; *p != 0; p++) if (*p == ' ') *p = '0';
         strcat (outFileName, inFileName + ofs);
",1,unused,482,unused,"	 /* Now split points to the start of the basename. */
         ofs  = split - outFileName;
         sprintf (split, ""rec%5d"", wrBlock+1);
         for (p = split; *p != 0; p++) if (*p == ' ') *p = '0';
         strcat (outFileName, inFileName + ofs);
",unused,bzip2jessie-bzip2recover.c
"         sprintf (split, ""rec%5d"", wrBlock+1);
         for (p = split; *p != 0; p++) if (*p == ' ') *p = '0';
         strcat (outFileName, inFileName + ofs);

         if ( !endsInBz2(outFileName)) strcat ( outFileName, "".bz2"" );
",1,unused,484,unused,"         sprintf (split, ""rec%5d"", wrBlock+1);
         for (p = split; *p != 0; p++) if (*p == ' ') *p = '0';
         strcat (outFileName, inFileName + ofs);

         if ( !endsInBz2(outFileName)) strcat ( outFileName, "".bz2"" );
",unused,bzip2jessie-bzip2recover.c
"         }
      }
      mode++;
   }
   strcat(mode2, writing ? ""w"" : ""r"" );
",1,unused,1417,unused,"         }
      }
      mode++;
   }
   strcat(mode2, writing ? ""w"" : ""r"" );
",unused,bzip2jessie-bzlib.c
"      }
      mode++;
   }
   strcat(mode2, writing ? ""w"" : ""r"" );
   strcat(mode2,""b"");   /* binary mode */
",1,unused,1418,unused,"      }
      mode++;
   }
   strcat(mode2, writing ? ""w"" : ""r"" );
   strcat(mode2,""b"");   /* binary mode */
",unused,bzip2jessie-bzlib.c
"                 const Char* newSuffix )
{
   if (!hasSuffix(name,oldSuffix)) return False;
   name[strlen(name)-strlen(oldSuffix)] = 0;
   strcat ( name, newSuffix );
",1,unused,1126,unused,"                 const Char* newSuffix )
{
   if (!hasSuffix(name,oldSuffix)) return False;
   name[strlen(name)-strlen(oldSuffix)] = 0;
   strcat ( name, newSuffix );
",unused,bzip2patchxen-bzip2.c
"         break;
      case SM_F2F: 
         copyFileName ( inName, name );
         copyFileName ( outName, name );
         strcat ( outName, "".bz2"" ); 
",1,unused,1153,unused,"         break;
      case SM_F2F: 
         copyFileName ( inName, name );
         copyFileName ( outName, name );
         strcat ( outName, "".bz2"" ); 
",unused,bzip2patchxen-bzip2.c
"         for (i = 0; i < BZ_N_SUFFIX_PAIRS; i++)
            if (mapSuffix(outName,zSuffix[i],unzSuffix[i]))
               goto zzz; 
         cantGuess = True;
         strcat ( outName, "".out"" );
",1,unused,1341,unused,"         for (i = 0; i < BZ_N_SUFFIX_PAIRS; i++)
            if (mapSuffix(outName,zSuffix[i],unzSuffix[i]))
               goto zzz; 
         cantGuess = True;
         strcat ( outName, "".out"" );
",unused,bzip2patchxen-bzip2.c
"{
   if (root == NULL) {
      Cell *tmp = mkCell();
      tmp->name = (Char*) myMalloc ( 5 + strlen(name) );
      strcpy ( tmp->name, name );
",1,unused,1734,unused,"{
   if (root == NULL) {
      Cell *tmp = mkCell();
      tmp->name = (Char*) myMalloc ( 5 + strlen(name) );
      strcpy ( tmp->name, name );
",unused,bzip2patchxen-bzip2.c
"
   UInt32      buffHi, buffLo, blockCRC;
   Char*       p;

   strcpy ( progName, argv[0] );
",1,unused,327,unused,"
   UInt32      buffHi, buffLo, blockCRC;
   Char*       p;

   strcpy ( progName, argv[0] );
",unused,bzip2patchxen-bzip2recover.c
"                progName, (int)strlen(argv[1]) );
      exit(1);
   }

   strcpy ( inFileName, argv[1] );
",1,unused,364,unused,"                progName, (int)strlen(argv[1]) );
      exit(1);
   }

   strcpy ( inFileName, argv[1] );
",unused,bzip2patchxen-bzip2recover.c
"         Char* split;
         Int32 ofs, k;
         for (k = 0; k < BZ_MAX_FILENAME; k++) 
            outFileName[k] = 0;
         strcpy (outFileName, inFileName);
",1,unused,486,unused,"         Char* split;
         Int32 ofs, k;
         for (k = 0; k < BZ_MAX_FILENAME; k++) 
            outFileName[k] = 0;
         strcpy (outFileName, inFileName);
",unused,bzip2patchxen-bzip2recover.c
"            ++split;
	 }
	 /* Now split points to the start of the basename. */
         ofs  = split - outFileName;
         sprintf (split, ""rec%5d"", wrBlock+1);
",1,unused,495,unused,"            ++split;
	 }
	 /* Now split points to the start of the basename. */
         ofs  = split - outFileName;
         sprintf (split, ""rec%5d"", wrBlock+1);
",unused,bzip2patchxen-bzip2recover.c
"	 /* Now split points to the start of the basename. */
         ofs  = split - outFileName;
         sprintf (split, ""rec%5d"", wrBlock+1);
         for (p = split; *p != 0; p++) if (*p == ' ') *p = '0';
         strcat (outFileName, inFileName + ofs);
",1,unused,497,unused,"	 /* Now split points to the start of the basename. */
         ofs  = split - outFileName;
         sprintf (split, ""rec%5d"", wrBlock+1);
         for (p = split; *p != 0; p++) if (*p == ' ') *p = '0';
         strcat (outFileName, inFileName + ofs);
",unused,bzip2patchxen-bzip2recover.c
"         sprintf (split, ""rec%5d"", wrBlock+1);
         for (p = split; *p != 0; p++) if (*p == ' ') *p = '0';
         strcat (outFileName, inFileName + ofs);

         if ( !endsInBz2(outFileName)) strcat ( outFileName, "".bz2"" );
",1,unused,499,unused,"         sprintf (split, ""rec%5d"", wrBlock+1);
         for (p = split; *p != 0; p++) if (*p == ' ') *p = '0';
         strcat (outFileName, inFileName + ofs);

         if ( !endsInBz2(outFileName)) strcat ( outFileName, "".bz2"" );
",unused,bzip2patchxen-bzip2recover.c
"         }
      }
      mode++;
   }
   strcat(mode2, writing ? ""w"" : ""r"" );
",1,unused,1417,unused,"         }
      }
      mode++;
   }
   strcat(mode2, writing ? ""w"" : ""r"" );
",unused,bzip2patchxen-bzlib.c
"      }
      mode++;
   }
   strcat(mode2, writing ? ""w"" : ""r"" );
   strcat(mode2,""b"");   /* binary mode */
",1,unused,1418,unused,"      }
      mode++;
   }
   strcat(mode2, writing ? ""w"" : ""r"" );
   strcat(mode2,""b"");   /* binary mode */
",unused,bzip2patchxen-bzlib.c
"                 const Char* newSuffix )
{
   if (!hasSuffix(name,oldSuffix)) return False;
   name[strlen(name)-strlen(oldSuffix)] = 0;
   strcat ( name, newSuffix );
",1,unused,1126,unused,"                 const Char* newSuffix )
{
   if (!hasSuffix(name,oldSuffix)) return False;
   name[strlen(name)-strlen(oldSuffix)] = 0;
   strcat ( name, newSuffix );
",unused,bzip2sources1.0.6-bzip2.c
"         break;
      case SM_F2F: 
         copyFileName ( inName, name );
         copyFileName ( outName, name );
         strcat ( outName, "".bz2"" ); 
",1,unused,1153,unused,"         break;
      case SM_F2F: 
         copyFileName ( inName, name );
         copyFileName ( outName, name );
         strcat ( outName, "".bz2"" ); 
",unused,bzip2sources1.0.6-bzip2.c
"         for (i = 0; i < BZ_N_SUFFIX_PAIRS; i++)
            if (mapSuffix(outName,zSuffix[i],unzSuffix[i]))
               goto zzz; 
         cantGuess = True;
         strcat ( outName, "".out"" );
",1,unused,1341,unused,"         for (i = 0; i < BZ_N_SUFFIX_PAIRS; i++)
            if (mapSuffix(outName,zSuffix[i],unzSuffix[i]))
               goto zzz; 
         cantGuess = True;
         strcat ( outName, "".out"" );
",unused,bzip2sources1.0.6-bzip2.c
"{
   if (root == NULL) {
      Cell *tmp = mkCell();
      tmp->name = (Char*) myMalloc ( 5 + strlen(name) );
      strcpy ( tmp->name, name );
",1,unused,1734,unused,"{
   if (root == NULL) {
      Cell *tmp = mkCell();
      tmp->name = (Char*) myMalloc ( 5 + strlen(name) );
      strcpy ( tmp->name, name );
",unused,bzip2sources1.0.6-bzip2.c
"
   UInt32      buffHi, buffLo, blockCRC;
   Char*       p;

   strcpy ( progName, argv[0] );
",1,unused,312,unused,"
   UInt32      buffHi, buffLo, blockCRC;
   Char*       p;

   strcpy ( progName, argv[0] );
",unused,bzip2sources1.0.6-bzip2recover.c
"                progName, (int)strlen(argv[1]) );
      exit(1);
   }

   strcpy ( inFileName, argv[1] );
",1,unused,349,unused,"                progName, (int)strlen(argv[1]) );
      exit(1);
   }

   strcpy ( inFileName, argv[1] );
",unused,bzip2sources1.0.6-bzip2recover.c
"         Char* split;
         Int32 ofs, k;
         for (k = 0; k < BZ_MAX_FILENAME; k++) 
            outFileName[k] = 0;
         strcpy (outFileName, inFileName);
",1,unused,471,unused,"         Char* split;
         Int32 ofs, k;
         for (k = 0; k < BZ_MAX_FILENAME; k++) 
            outFileName[k] = 0;
         strcpy (outFileName, inFileName);
",unused,bzip2sources1.0.6-bzip2recover.c
"            ++split;
	 }
	 /* Now split points to the start of the basename. */
         ofs  = split - outFileName;
         sprintf (split, ""rec%5d"", wrBlock+1);
",1,unused,480,unused,"            ++split;
	 }
	 /* Now split points to the start of the basename. */
         ofs  = split - outFileName;
         sprintf (split, ""rec%5d"", wrBlock+1);
",unused,bzip2sources1.0.6-bzip2recover.c
"	 /* Now split points to the start of the basename. */
         ofs  = split - outFileName;
         sprintf (split, ""rec%5d"", wrBlock+1);
         for (p = split; *p != 0; p++) if (*p == ' ') *p = '0';
         strcat (outFileName, inFileName + ofs);
",1,unused,482,unused,"	 /* Now split points to the start of the basename. */
         ofs  = split - outFileName;
         sprintf (split, ""rec%5d"", wrBlock+1);
         for (p = split; *p != 0; p++) if (*p == ' ') *p = '0';
         strcat (outFileName, inFileName + ofs);
",unused,bzip2sources1.0.6-bzip2recover.c
"         sprintf (split, ""rec%5d"", wrBlock+1);
         for (p = split; *p != 0; p++) if (*p == ' ') *p = '0';
         strcat (outFileName, inFileName + ofs);

         if ( !endsInBz2(outFileName)) strcat ( outFileName, "".bz2"" );
",1,unused,484,unused,"         sprintf (split, ""rec%5d"", wrBlock+1);
         for (p = split; *p != 0; p++) if (*p == ' ') *p = '0';
         strcat (outFileName, inFileName + ofs);

         if ( !endsInBz2(outFileName)) strcat ( outFileName, "".bz2"" );
",unused,bzip2sources1.0.6-bzip2recover.c
"         }
      }
      mode++;
   }
   strcat(mode2, writing ? ""w"" : ""r"" );
",1,unused,1417,unused,"         }
      }
      mode++;
   }
   strcat(mode2, writing ? ""w"" : ""r"" );
",unused,bzip2sources1.0.6-bzlib.c
"      }
      mode++;
   }
   strcat(mode2, writing ? ""w"" : ""r"" );
   strcat(mode2,""b"");   /* binary mode */
",1,unused,1418,unused,"      }
      mode++;
   }
   strcat(mode2, writing ? ""w"" : ""r"" );
   strcat(mode2,""b"");   /* binary mode */
",unused,bzip2sources1.0.6-bzlib.c
"                 const Char* newSuffix )
{
   if (!hasSuffix(name,oldSuffix)) return False;
   name[strlen(name)-strlen(oldSuffix)] = 0;
   strcat ( name, newSuffix );
",1,unused,1126,unused,"                 const Char* newSuffix )
{
   if (!hasSuffix(name,oldSuffix)) return False;
   name[strlen(name)-strlen(oldSuffix)] = 0;
   strcat ( name, newSuffix );
",unused,bzip2ubuntuartful1.0.6-bzip2.c
"         break;
      case SM_F2F: 
         copyFileName ( inName, name );
         copyFileName ( outName, name );
         strcat ( outName, "".bz2"" ); 
",1,unused,1153,unused,"         break;
      case SM_F2F: 
         copyFileName ( inName, name );
         copyFileName ( outName, name );
         strcat ( outName, "".bz2"" ); 
",unused,bzip2ubuntuartful1.0.6-bzip2.c
"         for (i = 0; i < BZ_N_SUFFIX_PAIRS; i++)
            if (mapSuffix(outName,zSuffix[i],unzSuffix[i]))
               goto zzz; 
         cantGuess = True;
         strcat ( outName, "".out"" );
",1,unused,1341,unused,"         for (i = 0; i < BZ_N_SUFFIX_PAIRS; i++)
            if (mapSuffix(outName,zSuffix[i],unzSuffix[i]))
               goto zzz; 
         cantGuess = True;
         strcat ( outName, "".out"" );
",unused,bzip2ubuntuartful1.0.6-bzip2.c
"{
   if (root == NULL) {
      Cell *tmp = mkCell();
      tmp->name = (Char*) myMalloc ( 5 + strlen(name) );
      strcpy ( tmp->name, name );
",1,unused,1734,unused,"{
   if (root == NULL) {
      Cell *tmp = mkCell();
      tmp->name = (Char*) myMalloc ( 5 + strlen(name) );
      strcpy ( tmp->name, name );
",unused,bzip2ubuntuartful1.0.6-bzip2.c
"
   UInt32      buffHi, buffLo, blockCRC;
   Char*       p;

   strcpy ( progName, argv[0] );
",1,unused,312,unused,"
   UInt32      buffHi, buffLo, blockCRC;
   Char*       p;

   strcpy ( progName, argv[0] );
",unused,bzip2ubuntuartful1.0.6-bzip2recover.c
"                progName, (int)strlen(argv[1]) );
      exit(1);
   }

   strcpy ( inFileName, argv[1] );
",1,unused,349,unused,"                progName, (int)strlen(argv[1]) );
      exit(1);
   }

   strcpy ( inFileName, argv[1] );
",unused,bzip2ubuntuartful1.0.6-bzip2recover.c
"         Char* split;
         Int32 ofs, k;
         for (k = 0; k < BZ_MAX_FILENAME; k++) 
            outFileName[k] = 0;
         strcpy (outFileName, inFileName);
",1,unused,471,unused,"         Char* split;
         Int32 ofs, k;
         for (k = 0; k < BZ_MAX_FILENAME; k++) 
            outFileName[k] = 0;
         strcpy (outFileName, inFileName);
",unused,bzip2ubuntuartful1.0.6-bzip2recover.c
"            ++split;
	 }
	 /* Now split points to the start of the basename. */
         ofs  = split - outFileName;
         sprintf (split, ""rec%5d"", wrBlock+1);
",1,unused,480,unused,"            ++split;
	 }
	 /* Now split points to the start of the basename. */
         ofs  = split - outFileName;
         sprintf (split, ""rec%5d"", wrBlock+1);
",unused,bzip2ubuntuartful1.0.6-bzip2recover.c
"	 /* Now split points to the start of the basename. */
         ofs  = split - outFileName;
         sprintf (split, ""rec%5d"", wrBlock+1);
         for (p = split; *p != 0; p++) if (*p == ' ') *p = '0';
         strcat (outFileName, inFileName + ofs);
",1,unused,482,unused,"	 /* Now split points to the start of the basename. */
         ofs  = split - outFileName;
         sprintf (split, ""rec%5d"", wrBlock+1);
         for (p = split; *p != 0; p++) if (*p == ' ') *p = '0';
         strcat (outFileName, inFileName + ofs);
",unused,bzip2ubuntuartful1.0.6-bzip2recover.c
"         sprintf (split, ""rec%5d"", wrBlock+1);
         for (p = split; *p != 0; p++) if (*p == ' ') *p = '0';
         strcat (outFileName, inFileName + ofs);

         if ( !endsInBz2(outFileName)) strcat ( outFileName, "".bz2"" );
",1,unused,484,unused,"         sprintf (split, ""rec%5d"", wrBlock+1);
         for (p = split; *p != 0; p++) if (*p == ' ') *p = '0';
         strcat (outFileName, inFileName + ofs);

         if ( !endsInBz2(outFileName)) strcat ( outFileName, "".bz2"" );
",unused,bzip2ubuntuartful1.0.6-bzip2recover.c
"         }
      }
      mode++;
   }
   strcat(mode2, writing ? ""w"" : ""r"" );
",1,unused,1417,unused,"         }
      }
      mode++;
   }
   strcat(mode2, writing ? ""w"" : ""r"" );
",unused,bzip2ubuntuartful1.0.6-bzlib.c
"      }
      mode++;
   }
   strcat(mode2, writing ? ""w"" : ""r"" );
   strcat(mode2,""b"");   /* binary mode */
",1,unused,1418,unused,"      }
      mode++;
   }
   strcat(mode2, writing ? ""w"" : ""r"" );
   strcat(mode2,""b"");   /* binary mode */
",unused,bzip2ubuntuartful1.0.6-bzlib.c
"                 const Char* newSuffix )
{
   if (!hasSuffix(name,oldSuffix)) return False;
   name[strlen(name)-strlen(oldSuffix)] = 0;
   strcat ( name, newSuffix );
",1,unused,1126,unused,"                 const Char* newSuffix )
{
   if (!hasSuffix(name,oldSuffix)) return False;
   name[strlen(name)-strlen(oldSuffix)] = 0;
   strcat ( name, newSuffix );
",unused,bzipstretch-bzip2.c
"         break;
      case SM_F2F: 
         copyFileName ( inName, name );
         copyFileName ( outName, name );
         strcat ( outName, "".bz2"" ); 
",1,unused,1153,unused,"         break;
      case SM_F2F: 
         copyFileName ( inName, name );
         copyFileName ( outName, name );
         strcat ( outName, "".bz2"" ); 
",unused,bzipstretch-bzip2.c
"         for (i = 0; i < BZ_N_SUFFIX_PAIRS; i++)
            if (mapSuffix(outName,zSuffix[i],unzSuffix[i]))
               goto zzz; 
         cantGuess = True;
         strcat ( outName, "".out"" );
",1,unused,1341,unused,"         for (i = 0; i < BZ_N_SUFFIX_PAIRS; i++)
            if (mapSuffix(outName,zSuffix[i],unzSuffix[i]))
               goto zzz; 
         cantGuess = True;
         strcat ( outName, "".out"" );
",unused,bzipstretch-bzip2.c
"{
   if (root == NULL) {
      Cell *tmp = mkCell();
      tmp->name = (Char*) myMalloc ( 5 + strlen(name) );
      strcpy ( tmp->name, name );
",1,unused,1734,unused,"{
   if (root == NULL) {
      Cell *tmp = mkCell();
      tmp->name = (Char*) myMalloc ( 5 + strlen(name) );
      strcpy ( tmp->name, name );
",unused,bzipstretch-bzip2.c
"
   UInt32      buffHi, buffLo, blockCRC;
   Char*       p;

   strcpy ( progName, argv[0] );
",1,unused,327,unused,"
   UInt32      buffHi, buffLo, blockCRC;
   Char*       p;

   strcpy ( progName, argv[0] );
",unused,bzipstretch-bzip2recover.c
"                progName, (int)strlen(argv[1]) );
      exit(1);
   }

   strcpy ( inFileName, argv[1] );
",1,unused,364,unused,"                progName, (int)strlen(argv[1]) );
      exit(1);
   }

   strcpy ( inFileName, argv[1] );
",unused,bzipstretch-bzip2recover.c
"         Char* split;
         Int32 ofs, k;
         for (k = 0; k < BZ_MAX_FILENAME; k++) 
            outFileName[k] = 0;
         strcpy (outFileName, inFileName);
",1,unused,487,unused,"         Char* split;
         Int32 ofs, k;
         for (k = 0; k < BZ_MAX_FILENAME; k++) 
            outFileName[k] = 0;
         strcpy (outFileName, inFileName);
",unused,bzipstretch-bzip2recover.c
"            ++split;
	 }
	 /* Now split points to the start of the basename. */
         ofs  = split - outFileName;
         sprintf (split, ""rec%5d"", wrBlock+1);
",1,unused,496,unused,"            ++split;
	 }
	 /* Now split points to the start of the basename. */
         ofs  = split - outFileName;
         sprintf (split, ""rec%5d"", wrBlock+1);
",unused,bzipstretch-bzip2recover.c
"	 /* Now split points to the start of the basename. */
         ofs  = split - outFileName;
         sprintf (split, ""rec%5d"", wrBlock+1);
         for (p = split; *p != 0; p++) if (*p == ' ') *p = '0';
         strcat (outFileName, inFileName + ofs);
",1,unused,498,unused,"	 /* Now split points to the start of the basename. */
         ofs  = split - outFileName;
         sprintf (split, ""rec%5d"", wrBlock+1);
         for (p = split; *p != 0; p++) if (*p == ' ') *p = '0';
         strcat (outFileName, inFileName + ofs);
",unused,bzipstretch-bzip2recover.c
"         sprintf (split, ""rec%5d"", wrBlock+1);
         for (p = split; *p != 0; p++) if (*p == ' ') *p = '0';
         strcat (outFileName, inFileName + ofs);

         if ( !endsInBz2(outFileName)) strcat ( outFileName, "".bz2"" );
",1,unused,500,unused,"         sprintf (split, ""rec%5d"", wrBlock+1);
         for (p = split; *p != 0; p++) if (*p == ' ') *p = '0';
         strcat (outFileName, inFileName + ofs);

         if ( !endsInBz2(outFileName)) strcat ( outFileName, "".bz2"" );
",unused,bzipstretch-bzip2recover.c
"         }
      }
      mode++;
   }
   strcat(mode2, writing ? ""w"" : ""r"" );
",1,unused,1417,unused,"         }
      }
      mode++;
   }
   strcat(mode2, writing ? ""w"" : ""r"" );
",unused,bzipstretch-bzlib.c
"      }
      mode++;
   }
   strcat(mode2, writing ? ""w"" : ""r"" );
   strcat(mode2,""b"");   /* binary mode */
",1,unused,1418,unused,"      }
      mode++;
   }
   strcat(mode2, writing ? ""w"" : ""r"" );
   strcat(mode2,""b"");   /* binary mode */
",unused,bzipstretch-bzlib.c
"static void GetVersionedLibFileName(const char* baseFileName, int majorVer, int minorVer, int subVer, const char* versionPrefix, char* result)
{
    assert(majorVer != -1);

    int nameLen = sprintf(result, ""%s.%s%d"", baseFileName, versionPrefix, majorVer);
",1,unused,73,unused,"static void GetVersionedLibFileName(const char* baseFileName, int majorVer, int minorVer, int subVer, const char* versionPrefix, char* result)
{
    assert(majorVer != -1);

    int nameLen = sprintf(result, ""%s.%s%d"", baseFileName, versionPrefix, majorVer);
",unused,c-family-CoreCLR-src2Fcorefx2FSystem.Globalization.Native2Fpal_icushim.c
"    }
    
    if (port != 0) {
        char port_str[20];
        int port_str_len = sprintf(port_str, "":%u"", port);
",1,unused,5512,unused,"    }
    
    if (port != 0) {
        char port_str[20];
        int port_str_len = sprintf(port_str, "":%u"", port);
",unused,chaosframework-chaos2Fcommon2Fadditional_lib2Fmongoose.c
"      /* Temporarily modify the buffer into its parent directory name,
	 invoke pathconf on the directory, and then restore the buffer.  */
      char tmp[sizeof "".""];
      memcpy (tmp, base, sizeof ""."");
      strcpy (base, ""."");
",1,unused,109,unused,"      /* Temporarily modify the buffer into its parent directory name,
	 invoke pathconf on the directory, and then restore the buffer.  */
      char tmp[sizeof "".""];
      memcpy (tmp, base, sizeof ""."");
      strcpy (base, ""."");
",unused,coreutilssources8.26-lib2Fbackupfile.c
"  /* Temporarily modify the buffer into its parent directory name,
     open the directory, and then restore the buffer.  */
  char tmp[sizeof "".""];
  memcpy (tmp, base, sizeof ""."");
  strcpy (base, ""."");
",1,unused,189,unused,"  /* Temporarily modify the buffer into its parent directory name,
     open the directory, and then restore the buffer.  */
  char tmp[sizeof "".""];
  memcpy (tmp, base, sizeof ""."");
  strcpy (base, ""."");
",unused,coreutilssources8.26-lib2Fbackupfile.c
"  memcpy (tmp, base, sizeof ""."");
  strcpy (base, ""."");
  dirp = opendir (buf);
  memcpy (base, tmp, sizeof ""."");
  strcpy (base + baselen, "".~1~"");
",1,unused,192,unused,"  memcpy (tmp, base, sizeof ""."");
  strcpy (base, ""."");
  dirp = opendir (buf);
  memcpy (base, tmp, sizeof ""."");
  strcpy (base + baselen, "".~1~"");
",unused,coreutilssources8.26-lib2Fbackupfile.c
"	      char tz1buf[sizeof ""XXX+0:00""
			  + sizeof pc.time_zone * CHAR_BIT / 3];
	      if (!tz_was_altered)
		tz0 = get_tz (tz0buf);
	      sprintf (tz1buf, ""XXX%s%ld:%02d"", ""-"" + (time_zone < 0),
",1,unused,3349,unused,"	      char tz1buf[sizeof ""XXX+0:00""
			  + sizeof pc.time_zone * CHAR_BIT / 3];
	      if (!tz_was_altered)
		tz0 = get_tz (tz0buf);
	      sprintf (tz1buf, ""XXX%s%ld:%02d"", ""-"" + (time_zone < 0),
",unused,coreutilssources8.26-lib2Fgetdate.c
"    size_t nonintegerlen;

    if (! (opts & human_autoscale))
      {
	sprintf (buf, ""%.0Lf"", adjust_value (inexact_style, damt));
",1,unused,232,unused,"    size_t nonintegerlen;

    if (! (opts & human_autoscale))
      {
	sprintf (buf, ""%.0Lf"", adjust_value (inexact_style, damt));
",unused,coreutilssources8.26-lib2Fhuman.c
"	while (e * base <= damt && exponent < exponent_max);

	damt /= e;

	sprintf (buf, ""%.1Lf"", adjust_value (inexact_style, damt));
",1,unused,250,unused,"	while (e * base <= damt && exponent < exponent_max);

	damt /= e;

	sprintf (buf, ""%.1Lf"", adjust_value (inexact_style, damt));
",unused,coreutilssources8.26-lib2Fhuman.c
"	if (1 + nonintegerlen + ! (opts & human_base_1024) < buflen
	    || ((opts & human_suppress_point_zero)
		&& buf[buflen - 1] == '0'))
	  {
	    sprintf (buf, ""%.0Lf"",
",1,unused,258,unused,"	if (1 + nonintegerlen + ! (opts & human_base_1024) < buflen
	    || ((opts & human_suppress_point_zero)
		&& buf[buflen - 1] == '0'))
	  {
	    sprintf (buf, ""%.0Lf"",
",unused,coreutilssources8.26-lib2Fhuman.c
"      struct passwd *pwent = getpwuid (uid);
      char const *name = pwent ? pwent->pw_name : """";
      match = xmalloc (offsetof (struct userid, name) + strlen (name) + 1);
      match->id.u = uid;
      strcpy (match->name, name);
",1,unused,88,unused,"      struct passwd *pwent = getpwuid (uid);
      char const *name = pwent ? pwent->pw_name : """";
      match = xmalloc (offsetof (struct userid, name) + strlen (name) + 1);
      match->id.u = uid;
      strcpy (match->name, name);
",unused,coreutilssources8.26-lib2Fidcache.c
"    }
#endif

  tail = xmalloc (offsetof (struct userid, name) + strlen (user) + 1);
  strcpy (tail->name, user);
",1,unused,131,unused,"    }
#endif

  tail = xmalloc (offsetof (struct userid, name) + strlen (user) + 1);
  strcpy (tail->name, user);
",unused,coreutilssources8.26-lib2Fidcache.c
"      struct group *grent = getgrgid (gid);
      char const *name = grent ? grent->gr_name : """";
      match = xmalloc (offsetof (struct userid, name) + strlen (name) + 1);
      match->id.g = gid;
      strcpy (match->name, name);
",1,unused,170,unused,"      struct group *grent = getgrgid (gid);
      char const *name = grent ? grent->gr_name : """";
      match = xmalloc (offsetof (struct userid, name) + strlen (name) + 1);
      match->id.g = gid;
      strcpy (match->name, name);
",unused,coreutilssources8.26-lib2Fidcache.c
"    }
#endif

  tail = xmalloc (offsetof (struct userid, name) + strlen (group) + 1);
  strcpy (tail->name, group);
",1,unused,213,unused,"    }
#endif

  tail = xmalloc (offsetof (struct userid, name) + strlen (group) + 1);
  strcpy (tail->name, group);
",unused,coreutilssources8.26-lib2Fidcache.c
"			  if (old_res_ptr != NULL)
			    free (old_res_ptr);
			  break;
			}
		      strcpy (res_ptr + res_size - (l2 + 1) - (l1 + 1), buf1);
",1,unused,238,unused,"			  if (old_res_ptr != NULL)
			    free (old_res_ptr);
			  break;
			}
		      strcpy (res_ptr + res_size - (l2 + 1) - (l1 + 1), buf1);
",unused,coreutilssources8.26-lib2Flocalcharset.c
"			    free (old_res_ptr);
			  break;
			}
		      strcpy (res_ptr + res_size - (l2 + 1) - (l1 + 1), buf1);
		      strcpy (res_ptr + res_size - (l2 + 1), buf2);
",1,unused,239,unused,"			    free (old_res_ptr);
			  break;
			}
		      strcpy (res_ptr + res_size - (l2 + 1) - (l1 + 1), buf1);
		      strcpy (res_ptr + res_size - (l2 + 1), buf2);
",unused,coreutilssources8.26-lib2Flocalcharset.c
"	{
	  struct stat proc_self_fd_dotdot_st;
	  struct stat proc_self_st;
	  char dotdot_buf[PROC_SELF_FD_NAME_SIZE_BOUND (sizeof "".."" - 1)];
	  sprintf (dotdot_buf, PROC_SELF_FD_FORMAT, proc_self_fd, "".."");
",1,unused,85,unused,"	{
	  struct stat proc_self_fd_dotdot_st;
	  struct stat proc_self_st;
	  char dotdot_buf[PROC_SELF_FD_NAME_SIZE_BOUND (sizeof "".."" - 1)];
	  sprintf (dotdot_buf, PROC_SELF_FD_FORMAT, proc_self_fd, "".."");
",unused,coreutilssources8.26-lib2Fopenat-proc.c
"  else
    {
      size_t bufsize = PROC_SELF_FD_NAME_SIZE_BOUND (strlen (file));
      char *result = (bufsize < OPENAT_BUFFER_SIZE ? buf : xmalloc (bufsize));
      sprintf (result, PROC_SELF_FD_FORMAT, fd, file);
",1,unused,101,unused,"  else
    {
      size_t bufsize = PROC_SELF_FD_NAME_SIZE_BOUND (strlen (file));
      char *result = (bufsize < OPENAT_BUFFER_SIZE ? buf : xmalloc (bufsize));
      sprintf (result, PROC_SELF_FD_FORMAT, fd, file);
",unused,coreutilssources8.26-lib2Fopenat-proc.c
"        /* Allow times like 01:35:60 or 23:59:60.  */
        time_t dummy;
        char buf[16];
        char *b = stpcpy (buf, s);
        strcpy (b - 2, ""59"");
",1,unused,228,unused,"        /* Allow times like 01:35:60 or 23:59:60.  */
        time_t dummy;
        char buf[16];
        char *b = stpcpy (buf, s);
        strcpy (b - 2, ""59"");
",unused,coreutilssources8.26-lib2Fposixtm.c
"  unsigned int i;
  for (i = 0; i < NUMNAME_ENTRIES; i++)
    if (numname_table[i].num == signum)
      {
	strcpy (signame, numname_table[i].name);
",1,unused,319,unused,"  unsigned int i;
  for (i = 0; i < NUMNAME_ENTRIES; i++)
    if (numname_table[i].num == signum)
      {
	strcpy (signame, numname_table[i].name);
",unused,coreutilssources8.26-lib2Fsig2str.c
"
    if (signum <= rtmin + (rtmax - rtmin) / 2)
      {
	int delta = signum - rtmin;
	sprintf (signame, delta ? ""RTMIN+%d"" : ""RTMIN"", delta);
",1,unused,333,unused,"
    if (signum <= rtmin + (rtmax - rtmin) / 2)
      {
	int delta = signum - rtmin;
	sprintf (signame, delta ? ""RTMIN+%d"" : ""RTMIN"", delta);
",unused,coreutilssources8.26-lib2Fsig2str.c
"      }
    else
      {
	int delta = rtmax - signum;
	sprintf (signame, delta ? ""RTMAX-%d"" : ""RTMAX"", delta);
",1,unused,338,unused,"      }
    else
      {
	int delta = rtmax - signum;
	sprintf (signame, delta ? ""RTMAX-%d"" : ""RTMAX"", delta);
",unused,coreutilssources8.26-lib2Fsig2str.c
"  for(; c > filename && *c != '.' && *c != '/'; c--)
    ;
  if(c <= filename || *c == '/') c = filename + strlen(filename);

  sprintf(c, "".%s"", ext);
",1,unused,285,unused,"  for(; c > filename && *c != '.' && *c != '/'; c--)
    ;
  if(c <= filename || *c == '/') c = filename + strlen(filename);

  sprintf(c, "".%s"", ext);
",unused,costalfy_darktable-src2Fimageio2Fstorage2Fgallery.c
"  c = relthumbfilename + strlen(relthumbfilename);
  for(; c > relthumbfilename && *c != '.'; c--)
    ;
  if(c <= relthumbfilename) c = relthumbfilename + strlen(relthumbfilename);
  sprintf(c, ""-thumb.%s"", ext);
",1,unused,317,unused,"  c = relthumbfilename + strlen(relthumbfilename);
  for(; c > relthumbfilename && *c != '.'; c--)
    ;
  if(c <= relthumbfilename) c = relthumbfilename + strlen(relthumbfilename);
  sprintf(c, ""-thumb.%s"", ext);
",unused,costalfy_darktable-src2Fimageio2Fstorage2Fgallery.c
"
  char subfilename[PATH_MAX] = { 0 }, relsubfilename[PATH_MAX] = { 0 };
  snprintf(subfilename, sizeof(subfilename), ""%s"", d->cached_dirname);
  char *sc = subfilename + strlen(subfilename);
  sprintf(sc, ""/img_%d.html"", num);
",1,unused,322,unused,"
  char subfilename[PATH_MAX] = { 0 }, relsubfilename[PATH_MAX] = { 0 };
  snprintf(subfilename, sizeof(subfilename), ""%s"", d->cached_dirname);
  char *sc = subfilename + strlen(subfilename);
  sprintf(sc, ""/img_%d.html"", num);
",unused,costalfy_darktable-src2Fimageio2Fstorage2Fgallery.c
"  for(; c > filename && *c != '.' && *c != '/'; c--)
    ;
  if(c <= filename || *c == '/') c = filename + strlen(filename);
  ext = format->extension(fdata);
  sprintf(c, ""-thumb.%s"", ext);
",1,unused,378,unused,"  for(; c > filename && *c != '.' && *c != '/'; c--)
    ;
  if(c <= filename || *c == '/') c = filename + strlen(filename);
  ext = format->extension(fdata);
  sprintf(c, ""-thumb.%s"", ext);
",unused,costalfy_darktable-src2Fimageio2Fstorage2Fgallery.c
"  snprintf(filename, sizeof(filename), ""%s"", d->cached_dirname);
  char *c = filename + strlen(filename);

  // also create style/ subdir:
  sprintf(c, ""/style"");
",1,unused,432,unused,"  snprintf(filename, sizeof(filename), ""%s"", d->cached_dirname);
  char *c = filename + strlen(filename);

  // also create style/ subdir:
  sprintf(c, ""/style"");
",unused,costalfy_darktable-src2Fimageio2Fstorage2Fgallery.c
"
  // also create style/ subdir:
  sprintf(c, ""/style"");
  g_mkdir_with_parents(filename, 0755);
  sprintf(c, ""/style/style.css"");
",1,unused,434,unused,"
  // also create style/ subdir:
  sprintf(c, ""/style"");
  g_mkdir_with_parents(filename, 0755);
  sprintf(c, ""/style/style.css"");
",unused,costalfy_darktable-src2Fimageio2Fstorage2Fgallery.c
"  sprintf(c, ""/style"");
  g_mkdir_with_parents(filename, 0755);
  sprintf(c, ""/style/style.css"");
  copy_res(""/style/style.css"", filename);
  sprintf(c, ""/style/favicon.ico"");
",1,unused,436,unused,"  sprintf(c, ""/style"");
  g_mkdir_with_parents(filename, 0755);
  sprintf(c, ""/style/style.css"");
  copy_res(""/style/style.css"", filename);
  sprintf(c, ""/style/favicon.ico"");
",unused,costalfy_darktable-src2Fimageio2Fstorage2Fgallery.c
"  sprintf(c, ""/style/favicon.ico"");
  copy_res(""/style/favicon.ico"", filename);

  // create subdir pswp for photoswipe scripts
  sprintf(c, ""/pswp/default-skin/"");
",1,unused,440,unused,"  sprintf(c, ""/style/favicon.ico"");
  copy_res(""/style/favicon.ico"", filename);

  // create subdir pswp for photoswipe scripts
  sprintf(c, ""/pswp/default-skin/"");
",unused,costalfy_darktable-src2Fimageio2Fstorage2Fgallery.c
"
  // create subdir pswp for photoswipe scripts
  sprintf(c, ""/pswp/default-skin/"");
  g_mkdir_with_parents(filename, 0755);
  sprintf(c, ""/pswp/photoswipe.js"");
",1,unused,442,unused,"
  // create subdir pswp for photoswipe scripts
  sprintf(c, ""/pswp/default-skin/"");
  g_mkdir_with_parents(filename, 0755);
  sprintf(c, ""/pswp/photoswipe.js"");
",unused,costalfy_darktable-src2Fimageio2Fstorage2Fgallery.c
"  sprintf(c, ""/pswp/default-skin/"");
  g_mkdir_with_parents(filename, 0755);
  sprintf(c, ""/pswp/photoswipe.js"");
  copy_res(""/pswp/photoswipe.js"", filename);
  sprintf(c, ""/pswp/photoswipe.min.js"");
",1,unused,444,unused,"  sprintf(c, ""/pswp/default-skin/"");
  g_mkdir_with_parents(filename, 0755);
  sprintf(c, ""/pswp/photoswipe.js"");
  copy_res(""/pswp/photoswipe.js"", filename);
  sprintf(c, ""/pswp/photoswipe.min.js"");
",unused,costalfy_darktable-src2Fimageio2Fstorage2Fgallery.c
"  sprintf(c, ""/pswp/photoswipe.js"");
  copy_res(""/pswp/photoswipe.js"", filename);
  sprintf(c, ""/pswp/photoswipe.min.js"");
  copy_res(""/pswp/photoswipe.min.js"", filename);
  sprintf(c, ""/pswp/photoswipe-ui-default.js"");
",1,unused,446,unused,"  sprintf(c, ""/pswp/photoswipe.js"");
  copy_res(""/pswp/photoswipe.js"", filename);
  sprintf(c, ""/pswp/photoswipe.min.js"");
  copy_res(""/pswp/photoswipe.min.js"", filename);
  sprintf(c, ""/pswp/photoswipe-ui-default.js"");
",unused,costalfy_darktable-src2Fimageio2Fstorage2Fgallery.c
"  sprintf(c, ""/pswp/photoswipe.min.js"");
  copy_res(""/pswp/photoswipe.min.js"", filename);
  sprintf(c, ""/pswp/photoswipe-ui-default.js"");
  copy_res(""/pswp/photoswipe-ui-default.js"", filename);
  sprintf(c, ""/pswp/photoswipe.css"");
",1,unused,448,unused,"  sprintf(c, ""/pswp/photoswipe.min.js"");
  copy_res(""/pswp/photoswipe.min.js"", filename);
  sprintf(c, ""/pswp/photoswipe-ui-default.js"");
  copy_res(""/pswp/photoswipe-ui-default.js"", filename);
  sprintf(c, ""/pswp/photoswipe.css"");
",unused,costalfy_darktable-src2Fimageio2Fstorage2Fgallery.c
"  sprintf(c, ""/pswp/photoswipe-ui-default.js"");
  copy_res(""/pswp/photoswipe-ui-default.js"", filename);
  sprintf(c, ""/pswp/photoswipe.css"");
  copy_res(""/pswp/photoswipe.css"", filename);
  sprintf(c, ""/pswp/photoswipe-ui-default.min.js"");
",1,unused,450,unused,"  sprintf(c, ""/pswp/photoswipe-ui-default.js"");
  copy_res(""/pswp/photoswipe-ui-default.js"", filename);
  sprintf(c, ""/pswp/photoswipe.css"");
  copy_res(""/pswp/photoswipe.css"", filename);
  sprintf(c, ""/pswp/photoswipe-ui-default.min.js"");
",unused,costalfy_darktable-src2Fimageio2Fstorage2Fgallery.c
"  sprintf(c, ""/pswp/photoswipe.css"");
  copy_res(""/pswp/photoswipe.css"", filename);
  sprintf(c, ""/pswp/photoswipe-ui-default.min.js"");
  copy_res(""/pswp/photoswipe-ui-default.min.js"", filename);
  sprintf(c, ""/pswp/default-skin/default-skin.css"");
",1,unused,452,unused,"  sprintf(c, ""/pswp/photoswipe.css"");
  copy_res(""/pswp/photoswipe.css"", filename);
  sprintf(c, ""/pswp/photoswipe-ui-default.min.js"");
  copy_res(""/pswp/photoswipe-ui-default.min.js"", filename);
  sprintf(c, ""/pswp/default-skin/default-skin.css"");
",unused,costalfy_darktable-src2Fimageio2Fstorage2Fgallery.c
"  sprintf(c, ""/pswp/photoswipe-ui-default.min.js"");
  copy_res(""/pswp/photoswipe-ui-default.min.js"", filename);
  sprintf(c, ""/pswp/default-skin/default-skin.css"");
  copy_res(""/pswp/default-skin/default-skin.css"", filename);
  sprintf(c, ""/pswp/default-skin/default-skin.png"");
",1,unused,454,unused,"  sprintf(c, ""/pswp/photoswipe-ui-default.min.js"");
  copy_res(""/pswp/photoswipe-ui-default.min.js"", filename);
  sprintf(c, ""/pswp/default-skin/default-skin.css"");
  copy_res(""/pswp/default-skin/default-skin.css"", filename);
  sprintf(c, ""/pswp/default-skin/default-skin.png"");
",unused,costalfy_darktable-src2Fimageio2Fstorage2Fgallery.c
"  sprintf(c, ""/pswp/default-skin/default-skin.css"");
  copy_res(""/pswp/default-skin/default-skin.css"", filename);
  sprintf(c, ""/pswp/default-skin/default-skin.png"");
  copy_res(""/pswp/default-skin/default-skin.png"", filename);
  sprintf(c, ""/pswp/default-skin/default-skin.svg"");
",1,unused,456,unused,"  sprintf(c, ""/pswp/default-skin/default-skin.css"");
  copy_res(""/pswp/default-skin/default-skin.css"", filename);
  sprintf(c, ""/pswp/default-skin/default-skin.png"");
  copy_res(""/pswp/default-skin/default-skin.png"", filename);
  sprintf(c, ""/pswp/default-skin/default-skin.svg"");
",unused,costalfy_darktable-src2Fimageio2Fstorage2Fgallery.c
"  sprintf(c, ""/pswp/default-skin/default-skin.png"");
  copy_res(""/pswp/default-skin/default-skin.png"", filename);
  sprintf(c, ""/pswp/default-skin/default-skin.svg"");
  copy_res(""/pswp/default-skin/default-skin.svg"", filename);
  sprintf(c, ""/pswp/default-skin/preloader.gif"");
",1,unused,458,unused,"  sprintf(c, ""/pswp/default-skin/default-skin.png"");
  copy_res(""/pswp/default-skin/default-skin.png"", filename);
  sprintf(c, ""/pswp/default-skin/default-skin.svg"");
  copy_res(""/pswp/default-skin/default-skin.svg"", filename);
  sprintf(c, ""/pswp/default-skin/preloader.gif"");
",unused,costalfy_darktable-src2Fimageio2Fstorage2Fgallery.c
"  copy_res(""/pswp/default-skin/default-skin.svg"", filename);
  sprintf(c, ""/pswp/default-skin/preloader.gif"");
  copy_res(""/pswp/default-skin/preloader.gif"", filename);

  sprintf(c, ""/index.html"");
",1,unused,461,unused,"  copy_res(""/pswp/default-skin/default-skin.svg"", filename);
  sprintf(c, ""/pswp/default-skin/preloader.gif"");
  copy_res(""/pswp/default-skin/preloader.gif"", filename);

  sprintf(c, ""/index.html"");
",unused,costalfy_darktable-src2Fimageio2Fstorage2Fgallery.c
"    c = filename + strlen(filename);
    //     for(; c>filename && *c != '.' && *c != '/' ; c--);
    //     if(c <= filename || *c=='/') c = filename + strlen(filename);

    sprintf(c, "".%s"", ext);
",1,unused,284,unused,"    c = filename + strlen(filename);
    //     for(; c>filename && *c != '.' && *c != '/' ; c--);
    //     if(c <= filename || *c=='/') c = filename + strlen(filename);

    sprintf(c, "".%s"", ext);
",unused,costalfy_darktable-src2Fimageio2Fstorage2Flatex.c
"  char filename[PATH_MAX] = { 0 };
  snprintf(filename, sizeof(filename), ""%s"", d->cached_dirname);
  char *c = filename + strlen(filename);

  sprintf(c, ""/photobook.cls"");
",1,unused,401,unused,"  char filename[PATH_MAX] = { 0 };
  snprintf(filename, sizeof(filename), ""%s"", d->cached_dirname);
  char *c = filename + strlen(filename);

  sprintf(c, ""/photobook.cls"");
",unused,costalfy_darktable-src2Fimageio2Fstorage2Flatex.c
"
  sprintf(c, ""/photobook.cls"");
  copy_res(""/latex/photobook.cls"", filename);

  sprintf(c, ""/main.tex"");
",1,unused,404,unused,"
  sprintf(c, ""/photobook.cls"");
  copy_res(""/latex/photobook.cls"", filename);

  sprintf(c, ""/main.tex"");
",unused,costalfy_darktable-src2Fimageio2Fstorage2Flatex.c
"                fp = bgzf_open(""-"", ""w"");
            else
            {
                char *name = malloc(strlen(argv[optind]) + 5);
                strcpy(name, argv[optind]);
",1,unused,166,unused,"                fp = bgzf_open(""-"", ""w"");
            else
            {
                char *name = malloc(strlen(argv[optind]) + 5);
                strcpy(name, argv[optind]);
",unused,delly1-src2Fhtslib2Fbgzip.c
"            else
            {
                char *name = malloc(strlen(argv[optind]) + 5);
                strcpy(name, argv[optind]);
                strcat(name, "".gz"");
",1,unused,167,unused,"            else
            {
                char *name = malloc(strlen(argv[optind]) + 5);
                strcpy(name, argv[optind]);
                strcat(name, "".gz"");
",unused,delly1-src2Fhtslib2Fbgzip.c
"	    continue;
	}

	if (ref != -2) {
	    sprintf(buf, ""%d\t%d\t%d\t%""PRId64""\t%d\t%d\n"",
",1,unused,478,unused,"	    continue;
	}

	if (ref != -2) {
	    sprintf(buf, ""%d\t%d\t%d\t%""PRId64""\t%d\t%d\n"",
",unused,delly1-src2Fhtslib2Fcram2Fcram_index.c
"	ref_end   = s->crecs[i].aend;
    }

    if (ref != -2) {
	sprintf(buf, ""%d\t%d\t%d\t%""PRId64""\t%d\t%d\n"",
",1,unused,491,unused,"	ref_end   = s->crecs[i].aend;
    }

    if (ref != -2) {
	sprintf(buf, ""%d\t%d\t%d\t%""PRId64""\t%d\t%d\n"",
",unused,delly1-src2Fhtslib2Fcram2Fcram_index.c
"	    if (s->hdr->ref_seq_id == -2) {
		ret = cram_index_build_multiref(fd, c, s, fp,
						cpos, c->landmark[j], sz);
	    } else {
		sprintf(buf, ""%d\t%d\t%d\t%""PRId64""\t%d\t%d\n"",
",1,unused,571,unused,"	    if (s->hdr->ref_seq_id == -2) {
		ret = cram_index_build_multiref(fd, c, s, fp,
						cpos, c->landmark[j], sz);
	    } else {
		sprintf(buf, ""%d\t%d\t%d\t%""PRId64""\t%d\t%d\n"",
",unused,delly1-src2Fhtslib2Fcram2Fcram_index.c
"    if (!(r->fp = bgzf_open_ref(r->fn, ""r"", 0)))
	goto err;

    /* Parse .fai file and load meta-data */
    sprintf(fai_fn, ""%.*s.fai"", PATH_MAX-5, r->fn);
",1,unused,1651,unused,"    if (!(r->fp = bgzf_open_ref(r->fn, ""r"", 0)))
	goto err;

    /* Parse .fai file and load meta-data */
    sprintf(fai_fn, ""%.*s.fai"", PATH_MAX-5, r->fn);
",unused,delly1-src2Fhtslib2Fcram2Fcram_io.c
"	strncpy(path, dir, cp-dir);
	path += cp-dir;

	if (*++cp == 's') {
	    strcpy(path, fn);
",1,unused,1913,unused,"	strncpy(path, dir, cp-dir);
	path += cp-dir;

	if (*++cp == 's') {
	    strcpy(path, fn);
",unused,delly1-src2Fhtslib2Fcram2Fcram_io.c
"	    *path++ = *cp++;
	}
	dir = cp;
    }
    strcpy(path, dir);
",1,unused,1939,unused,"	    *path++ = *cp++;
	}
	dir = cp;
    }
    strcpy(path, dir);
",unused,delly1-src2Fhtslib2Fcram2Fcram_io.c
"    strcpy(path, dir);
    path += strlen(dir);
    if (*fn && path[-1] != '/')
	*path++ = '/';
    strcpy(path, fn);
",1,unused,1943,unused,"    strcpy(path, dir);
    path += strlen(dir);
    if (*fn && path[-1] != '/')
	*path++ = '/';
    strcpy(path, fn);
",unused,delly1-src2Fhtslib2Fcram2Fcram_io.c
"	    // Attempt to further uniquify the temporary filename
	    unsigned t = ((unsigned) time(NULL)) ^ ((unsigned) clock());
	    thrid++; // Ensure filename changes even if time/clock haven't

	    sprintf(path_tmp, ""%s.tmp_%d_%u_%u"", path, pid, thrid, t);
",1,unused,2174,unused,"	    // Attempt to further uniquify the temporary filename
	    unsigned t = ((unsigned) time(NULL)) ^ ((unsigned) clock());
	    thrid++; // Ensure filename changes even if time/clock haven't

	    sprintf(path_tmp, ""%s.tmp_%d_%u_%u"", path, pid, thrid, t);
",unused,delly1-src2Fhtslib2Fcram2Fcram_io.c
"	    out[PATH_MAX-1] = 0;
	    return;
	}

	sprintf(out+len, ""/%.*s"", PATH_MAX - len, in);
",1,unused,3678,unused,"	    out[PATH_MAX-1] = 0;
	    return;
	}

	sprintf(out+len, ""/%.*s"", PATH_MAX - len, in);
",unused,delly1-src2Fhtslib2Fcram2Fcram_io.c
"    /* Expand %s for the trace name */
    for (cp = buf; *url && cp - buf < maxlen; url++) {
	if (*url == '%' && *(url+1) == 's') {
	    url++;
	    cp += strlen(strcpy(cp, file));
",1,unused,176,unused,"    /* Expand %s for the trace name */
    for (cp = buf; *url && cp - buf < maxlen; url++) {
	if (*url == '%' && *(url+1) == 's') {
	    url++;
	    cp += strlen(strcpy(cp, file));
",unused,delly1-src2Fhtslib2Fcram2Fopen_trace_file.c
"	len--;

    /* Special case for ""./"" or absolute filenames */
    if (*file == '/' || (len==1 && *dirname == '.')) {
	sprintf(path, ""%s"", file);
",1,unused,224,unused,"	len--;

    /* Special case for ""./"" or absolute filenames */
    if (*file == '/' || (len==1 && *dirname == '.')) {
	sprintf(path, ""%s"", file);
",unused,delly1-src2Fhtslib2Fcram2Fopen_trace_file.c
"		strncpy(path_end, file, l);
		path_end += MIN(strlen(file), l);
		file     += MIN(strlen(file), l);
	    } else {
		strcpy(path_end, file);
",1,unused,246,unused,"		strncpy(path_end, file, l);
		path_end += MIN(strlen(file), l);
		file     += MIN(strlen(file), l);
	    } else {
		strcpy(path_end, file);
",unused,delly1-src2Fhtslib2Fcram2Fopen_trace_file.c
"	path_end += MIN(strlen(dirname), len);
	*path_end = 0;
	if (*file) {
	    *path_end++ = '/';
	    strcpy(path_end, file);
",1,unused,258,unused,"	path_end += MIN(strlen(dirname), len);
	*path_end = 0;
	if (*file) {
	    *path_end++ = '/';
	    strcpy(path_end, file);
",unused,delly1-src2Fhtslib2Fcram2Fopen_trace_file.c
"    /* Look in the same location as the incoming 'relative_to' filename */
    if (relative_to) {
	char *cp;
	char relative_path[PATH_MAX+1];
	strcpy(relative_path, relative_to);
",1,unused,362,unused,"    /* Look in the same location as the incoming 'relative_to' filename */
    if (relative_to) {
	char *cp;
	char relative_path[PATH_MAX+1];
	strcpy(relative_path, relative_to);
",unused,delly1-src2Fhtslib2Fcram2Fopen_trace_file.c
"    if (k == kh_end(sh->pg_hash))
	return name;

    do {
	sprintf(sh->ID_buf, ""%.1000s.%d"", name, sh->ID_cnt++);
",1,unused,1167,unused,"    if (k == kh_end(sh->pg_hash))
	return name;

    do {
	sprintf(sh->ID_buf, ""%.1000s.%d"", name, sh->ID_cnt++);
",unused,delly1-src2Fhtslib2Fcram2Fsam_header.c
"    int ret, save;
    char *fnidx = (char*)calloc(1, strlen(fn) + 5);
    if (fnidx == NULL) return -1;

    strcpy(fnidx, fn);
",1,unused,1693,unused,"    int ret, save;
    char *fnidx = (char*)calloc(1, strlen(fn) + 5);
    if (fnidx == NULL) return -1;

    strcpy(fnidx, fn);
",unused,delly1-src2Fhtslib2Fhts.c
"    if (fnidx == NULL) return -1;

    strcpy(fnidx, fn);
    switch (fmt) {
    case HTS_FMT_BAI: strcat(fnidx, "".bai""); break;
",1,unused,1695,unused,"    if (fnidx == NULL) return -1;

    strcpy(fnidx, fn);
    switch (fmt) {
    case HTS_FMT_BAI: strcat(fnidx, "".bai""); break;
",unused,delly1-src2Fhtslib2Fhts.c
"
    strcpy(fnidx, fn);
    switch (fmt) {
    case HTS_FMT_BAI: strcat(fnidx, "".bai""); break;
    case HTS_FMT_CSI: strcat(fnidx, "".csi""); break;
",1,unused,1696,unused,"
    strcpy(fnidx, fn);
    switch (fmt) {
    case HTS_FMT_BAI: strcat(fnidx, "".bai""); break;
    case HTS_FMT_CSI: strcat(fnidx, "".csi""); break;
",unused,delly1-src2Fhtslib2Fhts.c
"    strcpy(fnidx, fn);
    switch (fmt) {
    case HTS_FMT_BAI: strcat(fnidx, "".bai""); break;
    case HTS_FMT_CSI: strcat(fnidx, "".csi""); break;
    case HTS_FMT_TBI: strcat(fnidx, "".tbi""); break;
",1,unused,1697,unused,"    strcpy(fnidx, fn);
    switch (fmt) {
    case HTS_FMT_BAI: strcat(fnidx, "".bai""); break;
    case HTS_FMT_CSI: strcat(fnidx, "".csi""); break;
    case HTS_FMT_TBI: strcat(fnidx, "".tbi""); break;
",unused,delly1-src2Fhtslib2Fhts.c
"    l_fn = strlen(fn); l_ext = strlen(ext);
    fnidx = (char*)calloc(l_fn + l_ext + 1, 1);
    if (!fnidx) return NULL;
    // First try : append `ext` to `fn`
    strcpy(fnidx, fn); strcpy(fnidx + l_fn, ext);
",1,unused,2336,unused,"    l_fn = strlen(fn); l_ext = strlen(ext);
    fnidx = (char*)calloc(l_fn + l_ext + 1, 1);
    if (!fnidx) return NULL;
    // First try : append `ext` to `fn`
    strcpy(fnidx, fn); strcpy(fnidx + l_fn, ext);
",unused,delly1-src2Fhtslib2Fhts.c
"    l_fn = strlen(fn); l_ext = strlen(ext);
    fnidx = (char*)calloc(l_fn + l_ext + 1, 1);
    if (!fnidx) return NULL;
    // First try : append `ext` to `fn`
    strcpy(fnidx, fn); strcpy(fnidx + l_fn, ext);
",1,unused,2336,unused,"    l_fn = strlen(fn); l_ext = strlen(ext);
    fnidx = (char*)calloc(l_fn + l_ext + 1, 1);
    if (!fnidx) return NULL;
    // First try : append `ext` to `fn`
    strcpy(fnidx, fn); strcpy(fnidx + l_fn, ext);
",unused,delly1-src2Fhtslib2Fhts.c
"        // Second try : replace suffix of `fn` with `ext`
        for (i = l_fn - 1; i > 0; --i)
            if (fnidx[i] == '.' || fnidx[i] == '/') break;
        if (fnidx[i] == '.') {
            strcpy(fnidx + i, ext);
",1,unused,2342,unused,"        // Second try : replace suffix of `fn` with `ext`
        for (i = l_fn - 1; i > 0; --i)
            if (fnidx[i] == '.' || fnidx[i] == '/') break;
        if (fnidx[i] == '.') {
            strcpy(fnidx + i, ext);
",unused,delly1-src2Fhtslib2Fhts.c
"	if (ftp->pasv_port == 0) {
		hts_log_error(""Must call kftp_pasv_prep() first"");
		return -1;
	}
	sprintf(host, ""%d.%d.%d.%d"", ftp->pasv_ip[0], ftp->pasv_ip[1], ftp->pasv_ip[2], ftp->pasv_ip[3]);
",1,unused,267,unused,"	if (ftp->pasv_port == 0) {
		hts_log_error(""Must call kftp_pasv_prep() first"");
		return -1;
	}
	sprintf(host, ""%d.%d.%d.%d"", ftp->pasv_ip[0], ftp->pasv_ip[1], ftp->pasv_ip[2], ftp->pasv_ip[3]);
",unused,delly1-src2Fhtslib2Fknetfile.c
"		hts_log_error(""Must call kftp_pasv_prep() first"");
		return -1;
	}
	sprintf(host, ""%d.%d.%d.%d"", ftp->pasv_ip[0], ftp->pasv_ip[1], ftp->pasv_ip[2], ftp->pasv_ip[3]);
	sprintf(port, ""%d"", ftp->pasv_port);
",1,unused,268,unused,"		hts_log_error(""Must call kftp_pasv_prep() first"");
		return -1;
	}
	sprintf(host, ""%d.%d.%d.%d"", ftp->pasv_ip[0], ftp->pasv_ip[1], ftp->pasv_ip[2], ftp->pasv_ip[3]);
	sprintf(port, ""%d"", ftp->pasv_port);
",unused,delly1-src2Fhtslib2Fknetfile.c
"	fp->host = (char*)calloc(l + 1, 1);
	if (strchr(mode, 'c')) fp->no_reconnect = 1;
	strncpy(fp->host, fn + 6, l);
	fp->retr = (char*)calloc(strlen(p) + 8, 1);
	sprintf(fp->retr, ""RETR %s\r\n"", p);
",1,unused,316,unused,"	fp->host = (char*)calloc(l + 1, 1);
	if (strchr(mode, 'c')) fp->no_reconnect = 1;
	strncpy(fp->host, fn + 6, l);
	fp->retr = (char*)calloc(strlen(p) + 8, 1);
	sprintf(fp->retr, ""RETR %s\r\n"", p);
",unused,delly1-src2Fhtslib2Fknetfile.c
"	strncpy(fp->host, fn + 6, l);
	fp->retr = (char*)calloc(strlen(p) + 8, 1);
	sprintf(fp->retr, ""RETR %s\r\n"", p);
    fp->size_cmd = (char*)calloc(strlen(p) + 8, 1);
    sprintf(fp->size_cmd, ""SIZE %s\r\n"", p);
",1,unused,318,unused,"	strncpy(fp->host, fn + 6, l);
	fp->retr = (char*)calloc(strlen(p) + 8, 1);
	sprintf(fp->retr, ""RETR %s\r\n"", p);
    fp->size_cmd = (char*)calloc(strlen(p) + 8, 1);
    sprintf(fp->size_cmd, ""SIZE %s\r\n"", p);
",unused,delly1-src2Fhtslib2Fknetfile.c
"	fp->file_size = file_size;
	if (fp->offset>=0) {
		char tmp[32];
#ifndef _WIN32
		sprintf(tmp, ""REST %lld\r\n"", (long long)fp->offset);
",1,unused,347,unused,"	fp->file_size = file_size;
	if (fp->offset>=0) {
		char tmp[32];
#ifndef _WIN32
		sprintf(tmp, ""REST %lld\r\n"", (long long)fp->offset);
",unused,delly1-src2Fhtslib2Fknetfile.c
"	char *buf, *p;
	if (fp->fd != -1) netclose(fp->fd);
	fp->fd = socket_connect(fp->host, fp->port);
	buf = (char*)calloc(0x10000, 1); // FIXME: I am lazy... But in principle, 64KB should be large enough.
	l += sprintf(buf + l, ""GET %s HTTP/1.0\r\nHost: %s\r\n"", fp->path, fp->http_host);
",1,unused,415,unused,"	char *buf, *p;
	if (fp->fd != -1) netclose(fp->fd);
	fp->fd = socket_connect(fp->host, fp->port);
	buf = (char*)calloc(0x10000, 1); // FIXME: I am lazy... But in principle, 64KB should be large enough.
	l += sprintf(buf + l, ""GET %s HTTP/1.0\r\nHost: %s\r\n"", fp->path, fp->http_host);
",unused,delly1-src2Fhtslib2Fknetfile.c
"	if (fp->fd != -1) netclose(fp->fd);
	fp->fd = socket_connect(fp->host, fp->port);
	buf = (char*)calloc(0x10000, 1); // FIXME: I am lazy... But in principle, 64KB should be large enough.
	l += sprintf(buf + l, ""GET %s HTTP/1.0\r\nHost: %s\r\n"", fp->path, fp->http_host);
	if (fp->offset != 0) l += sprintf(buf + l, ""Range: bytes=%lld-\r\n"", (long long)fp->offset);
",1,unused,416,unused,"	if (fp->fd != -1) netclose(fp->fd);
	fp->fd = socket_connect(fp->host, fp->port);
	buf = (char*)calloc(0x10000, 1); // FIXME: I am lazy... But in principle, 64KB should be large enough.
	l += sprintf(buf + l, ""GET %s HTTP/1.0\r\nHost: %s\r\n"", fp->path, fp->http_host);
	if (fp->offset != 0) l += sprintf(buf + l, ""Range: bytes=%lld-\r\n"", (long long)fp->offset);
",unused,delly1-src2Fhtslib2Fknetfile.c
"	fp->fd = socket_connect(fp->host, fp->port);
	buf = (char*)calloc(0x10000, 1); // FIXME: I am lazy... But in principle, 64KB should be large enough.
	l += sprintf(buf + l, ""GET %s HTTP/1.0\r\nHost: %s\r\n"", fp->path, fp->http_host);
	if (fp->offset != 0) l += sprintf(buf + l, ""Range: bytes=%lld-\r\n"", (long long)fp->offset);
	l += sprintf(buf + l, ""\r\n"");
",1,unused,417,unused,"	fp->fd = socket_connect(fp->host, fp->port);
	buf = (char*)calloc(0x10000, 1); // FIXME: I am lazy... But in principle, 64KB should be large enough.
	l += sprintf(buf + l, ""GET %s HTTP/1.0\r\nHost: %s\r\n"", fp->path, fp->http_host);
	if (fp->offset != 0) l += sprintf(buf + l, ""Range: bytes=%lld-\r\n"", (long long)fp->offset);
	l += sprintf(buf + l, ""\r\n"");
",unused,delly1-src2Fhtslib2Fknetfile.c
"	if (!(d >= 0.0001 && d <= 999999)) {
		if (ks_resize(s, s->l + 50) < 0)
			return EOF;
		// We let stdio handle the exponent cases
		int s2 = sprintf(s->s + s->l, ""%g"", d);
",1,unused,58,unused,"	if (!(d >= 0.0001 && d <= 999999)) {
		if (ks_resize(s, s->l + 50) < 0)
			return EOF;
		// We let stdio handle the exponent cases
		int s2 = sprintf(s->s + s->l, ""%g"", d);
",unused,delly1-src2Fhtslib2Fkstring.c
"        const char *ext = fn? strrchr(fn, '.') : NULL;
        if (ext == NULL || strchr(ext, '/')) return -1;
        return sam_open_mode(mode, fn, ext+1);
    }
    else if (strcmp(format, ""bam"") == 0) strcpy(mode, ""b"");
",1,unused,1674,unused,"        const char *ext = fn? strrchr(fn, '.') : NULL;
        if (ext == NULL || strchr(ext, '/')) return -1;
        return sam_open_mode(mode, fn, ext+1);
    }
    else if (strcmp(format, ""bam"") == 0) strcpy(mode, ""b"");
",unused,delly1-src2Fhtslib2Fsam.c
"        if (ext == NULL || strchr(ext, '/')) return -1;
        return sam_open_mode(mode, fn, ext+1);
    }
    else if (strcmp(format, ""bam"") == 0) strcpy(mode, ""b"");
    else if (strcmp(format, ""cram"") == 0) strcpy(mode, ""c"");
",1,unused,1675,unused,"        if (ext == NULL || strchr(ext, '/')) return -1;
        return sam_open_mode(mode, fn, ext+1);
    }
    else if (strcmp(format, ""bam"") == 0) strcpy(mode, ""b"");
    else if (strcmp(format, ""cram"") == 0) strcpy(mode, ""c"");
",unused,delly1-src2Fhtslib2Fsam.c
"        return sam_open_mode(mode, fn, ext+1);
    }
    else if (strcmp(format, ""bam"") == 0) strcpy(mode, ""b"");
    else if (strcmp(format, ""cram"") == 0) strcpy(mode, ""c"");
    else if (strcmp(format, ""sam"") == 0) strcpy(mode, """");
",1,unused,1676,unused,"        return sam_open_mode(mode, fn, ext+1);
    }
    else if (strcmp(format, ""bam"") == 0) strcpy(mode, ""b"");
    else if (strcmp(format, ""cram"") == 0) strcpy(mode, ""c"");
    else if (strcmp(format, ""sam"") == 0) strcpy(mode, """");
",unused,delly1-src2Fhtslib2Fsam.c
"
    if (!mode_opts)
        return NULL;

    strcpy(mode_opts, mode ? mode : ""r"");
",1,unused,1697,unused,"
    if (!mode_opts)
        return NULL;

    strcpy(mode_opts, mode ? mode : ""r"");
",unused,delly1-src2Fhtslib2Fsam.c
"    } else if (strncmp(format, ""cram"", format_len) == 0) {
        *cp++ = 'c';
    } else if (strncmp(format, ""cram2"", format_len) == 0) {
        *cp++ = 'c';
        strcpy(cp, "",VERSION=2.1"");
",1,unused,1725,unused,"    } else if (strncmp(format, ""cram"", format_len) == 0) {
        *cp++ = 'c';
    } else if (strncmp(format, ""cram2"", format_len) == 0) {
        *cp++ = 'c';
        strcpy(cp, "",VERSION=2.1"");
",unused,delly1-src2Fhtslib2Fsam.c
"        strcpy(cp, "",VERSION=2.1"");
        cp += 12;
    } else if (strncmp(format, ""cram3"", format_len) == 0) {
        *cp++ = 'c';
        strcpy(cp, "",VERSION=3.0"");
",1,unused,1729,unused,"        strcpy(cp, "",VERSION=2.1"");
        cp += 12;
    } else if (strncmp(format, ""cram3"", format_len) == 0) {
        *cp++ = 'c';
        strcpy(cp, "",VERSION=3.0"");
",unused,delly1-src2Fhtslib2Fsam.c
"        free(mode_opts);
        return NULL;
    }

    strcpy(cp, opts);
",1,unused,1738,unused,"        free(mode_opts);
        return NULL;
    }

    strcpy(cp, opts);
",unused,delly1-src2Fhtslib2Fsam.c
"    else if ( ftype==IS_BAM ) suffix = "".bai"";
    else if ( ftype==IS_CRAM ) suffix = "".crai"";

    char *idx_fname = calloc(strlen(fname) + 5, 1);
    strcat(strcpy(idx_fname, fname), suffix);
",1,unused,506,unused,"    else if ( ftype==IS_BAM ) suffix = "".bai"";
    else if ( ftype==IS_CRAM ) suffix = "".crai"";

    char *idx_fname = calloc(strlen(fname) + 5, 1);
    strcat(strcpy(idx_fname, fname), suffix);
",unused,delly1-src2Fhtslib2Ftabix.c
"    else if ( ftype==IS_BAM ) suffix = "".bai"";
    else if ( ftype==IS_CRAM ) suffix = "".crai"";

    char *idx_fname = calloc(strlen(fname) + 5, 1);
    strcat(strcpy(idx_fname, fname), suffix);
",1,unused,506,unused,"    else if ( ftype==IS_BAM ) suffix = "".bai"";
    else if ( ftype==IS_CRAM ) suffix = "".crai"";

    char *idx_fname = calloc(strlen(fname) + 5, 1);
    strcat(strcpy(idx_fname, fname), suffix);
",unused,delly1-src2Fhtslib2Ftabix.c
"
    original = slurp(""vcf.c"");
    for (i = 1; i <= 6; i++) {
        char *text;
        sprintf(buffer, ""test/hfile%d.tmp"", i);
",1,unused,178,unused,"
    original = slurp(""vcf.c"");
    for (i = 1; i <= 6; i++) {
        char *text;
        sprintf(buffer, ""test/hfile%d.tmp"", i);
",unused,delly1-src2Fhtslib2Ftest2Fhfile.c
"    faidx_t *fai;

    fin = fopen(filename, ""r"");
    if (fin == NULL) fail(""can't open %s\n"", filename);
    sprintf(tmpfilename, ""%s.tmp"", filename);
",1,unused,332,unused,"    faidx_t *fai;

    fin = fopen(filename, ""r"");
    if (fin == NULL) fail(""can't open %s\n"", filename);
    sprintf(tmpfilename, ""%s.tmp"", filename);
",unused,delly1-src2Fhtslib2Ftest2Fsam.c
"        fprintf(stderr, ""-Z hdr_nuls: append specified number of null bytes to the SAM header\n"");
        fprintf(stderr, ""-@ num_threads: use thread pool with specified number of threads\n"");
        return 1;
    }
    strcpy(moder, ""r"");
",1,unused,99,unused,"        fprintf(stderr, ""-Z hdr_nuls: append specified number of null bytes to the SAM header\n"");
        fprintf(stderr, ""-@ num_threads: use thread pool with specified number of threads\n"");
        return 1;
    }
    strcpy(moder, ""r"");
",unused,delly1-src2Fhtslib2Ftest2Ftest_view.c
"        fprintf(stderr, ""-@ num_threads: use thread pool with specified number of threads\n"");
        return 1;
    }
    strcpy(moder, ""r"");
    if (flag & READ_CRAM) strcat(moder, ""c"");
",1,unused,100,unused,"        fprintf(stderr, ""-@ num_threads: use thread pool with specified number of threads\n"");
        return 1;
    }
    strcpy(moder, ""r"");
    if (flag & READ_CRAM) strcat(moder, ""c"");
",unused,delly1-src2Fhtslib2Ftest2Ftest_view.c
"        return 1;
    }
    strcpy(moder, ""r"");
    if (flag & READ_CRAM) strcat(moder, ""c"");
    else if ((flag & READ_COMPRESSED) == 0) strcat(moder, ""b"");
",1,unused,101,unused,"        return 1;
    }
    strcpy(moder, ""r"");
    if (flag & READ_CRAM) strcat(moder, ""c"");
    else if ((flag & READ_COMPRESSED) == 0) strcat(moder, ""b"");
",unused,delly1-src2Fhtslib2Ftest2Ftest_view.c
"    }

    b = bam_init1();

    strcpy(modew, ""w"");
",1,unused,127,unused,"    }

    b = bam_init1();

    strcpy(modew, ""w"");
",unused,delly1-src2Fhtslib2Ftest2Ftest_view.c
"
    b = bam_init1();

    strcpy(modew, ""w"");
    if (clevel >= 0 && clevel <= 9) sprintf(modew + 1, ""%d"", clevel);
",1,unused,128,unused,"
    b = bam_init1();

    strcpy(modew, ""w"");
    if (clevel >= 0 && clevel <= 9) sprintf(modew + 1, ""%d"", clevel);
",unused,delly1-src2Fhtslib2Ftest2Ftest_view.c
"    b = bam_init1();

    strcpy(modew, ""w"");
    if (clevel >= 0 && clevel <= 9) sprintf(modew + 1, ""%d"", clevel);
    if (flag & WRITE_CRAM) strcat(modew, ""c"");
",1,unused,129,unused,"    b = bam_init1();

    strcpy(modew, ""w"");
    if (clevel >= 0 && clevel <= 9) sprintf(modew + 1, ""%d"", clevel);
    if (flag & WRITE_CRAM) strcat(modew, ""c"");
",unused,delly1-src2Fhtslib2Ftest2Ftest_view.c
"
    strcpy(modew, ""w"");
    if (clevel >= 0 && clevel <= 9) sprintf(modew + 1, ""%d"", clevel);
    if (flag & WRITE_CRAM) strcat(modew, ""c"");
    else if (flag & WRITE_COMPRESSED) strcat(modew, ""b"");
",1,unused,130,unused,"
    strcpy(modew, ""w"");
    if (clevel >= 0 && clevel <= 9) sprintf(modew + 1, ""%d"", clevel);
    if (flag & WRITE_CRAM) strcat(modew, ""c"");
    else if (flag & WRITE_COMPRESSED) strcat(modew, ""b"");
",unused,delly1-src2Fhtslib2Ftest2Ftest_view.c
"
static const char *dump_char(char *buffer, char c)
{
    switch (c) {
    case '\n': strcpy(buffer, ""\\n""); break;
",1,unused,61,unused,"
static const char *dump_char(char *buffer, char c)
{
    switch (c) {
    case '\n': strcpy(buffer, ""\\n""); break;
",unused,delly1-src2Fhtslib2Fvcf.c
"static const char *dump_char(char *buffer, char c)
{
    switch (c) {
    case '\n': strcpy(buffer, ""\\n""); break;
    case '\r': strcpy(buffer, ""\\r""); break;
",1,unused,62,unused,"static const char *dump_char(char *buffer, char c)
{
    switch (c) {
    case '\n': strcpy(buffer, ""\\n""); break;
    case '\r': strcpy(buffer, ""\\r""); break;
",unused,delly1-src2Fhtslib2Fvcf.c
"{
    switch (c) {
    case '\n': strcpy(buffer, ""\\n""); break;
    case '\r': strcpy(buffer, ""\\r""); break;
    case '\t': strcpy(buffer, ""\\t""); break;
",1,unused,63,unused,"{
    switch (c) {
    case '\n': strcpy(buffer, ""\\n""); break;
    case '\r': strcpy(buffer, ""\\r""); break;
    case '\t': strcpy(buffer, ""\\t""); break;
",unused,delly1-src2Fhtslib2Fvcf.c
"    case '\t': strcpy(buffer, ""\\t""); break;
    case '\'':
    case '\""':
    case '\\':
        sprintf(buffer, ""\\%c"", c);
",1,unused,67,unused,"    case '\t': strcpy(buffer, ""\\t""); break;
    case '\'':
    case '\""':
    case '\\':
        sprintf(buffer, ""\\%c"", c);
",unused,delly1-src2Fhtslib2Fvcf.c
"    case '\\':
        sprintf(buffer, ""\\%c"", c);
        break;
    default:
        if (isprint_c(c)) sprintf(buffer, ""%c"", c);
",1,unused,70,unused,"    case '\\':
        sprintf(buffer, ""\\%c"", c);
        break;
    default:
        if (isprint_c(c)) sprintf(buffer, ""%c"", c);
",unused,delly1-src2Fhtslib2Fvcf.c
"        sprintf(buffer, ""\\%c"", c);
        break;
    default:
        if (isprint_c(c)) sprintf(buffer, ""%c"", c);
        else sprintf(buffer, ""\\x%02X"", (unsigned char) c);
",1,unused,71,unused,"        sprintf(buffer, ""\\%c"", c);
        break;
    default:
        if (isprint_c(c)) sprintf(buffer, ""%c"", c);
        else sprintf(buffer, ""\\x%02X"", (unsigned char) c);
",unused,delly1-src2Fhtslib2Fvcf.c
"	    automatedTest(&colaCDE, atoi(argv[2]));
    }else{
    	for(;;){
		printf(""Ingrese el nombre del equipo %d:\n"", IDEquipo);
		scanf(""%s"", nombreEquipo);
",1,unused,110,unused,"	    automatedTest(&colaCDE, atoi(argv[2]));
    }else{
    	for(;;){
		printf(""Ingrese el nombre del equipo %d:\n"", IDEquipo);
		scanf(""%s"", nombreEquipo);
",unused,demoSonar-heap.c
"
  do
    {
      /* initialize the pattern */
      strcpy (buffer, f);
",1,unused,435,unused,"
  do
    {
      /* initialize the pattern */
      strcpy (buffer, f);
",unused,diffutilsdebstretche-lib2Fexclude.c
"	      else
		{
		  tmp = xmalloc (len + 7);
		  memcpy (tmp, pattern, len);
		  strcpy (tmp + len, ""(/.*)?"");
",1,unused,561,unused,"	      else
		{
		  tmp = xmalloc (len + 7);
		  memcpy (tmp, pattern, len);
		  strcpy (tmp + len, ""(/.*)?"");
",unused,diffutilsdebstretche-lib2Fexclude.c
"                          res_size = 0;
                          free (old_res_ptr);
                          break;
                        }
                      strcpy (res_ptr + res_size - (l2 + 1) - (l1 + 1), buf1);
",1,unused,239,unused,"                          res_size = 0;
                          free (old_res_ptr);
                          break;
                        }
                      strcpy (res_ptr + res_size - (l2 + 1) - (l1 + 1), buf1);
",unused,diffutilsdebstretche-lib2Flocalcharset.c
"                          free (old_res_ptr);
                          break;
                        }
                      strcpy (res_ptr + res_size - (l2 + 1) - (l1 + 1), buf1);
                      strcpy (res_ptr + res_size - (l2 + 1), buf2);
",1,unused,240,unused,"                          free (old_res_ptr);
                          break;
                        }
                      strcpy (res_ptr + res_size - (l2 + 1) - (l1 + 1), buf1);
                      strcpy (res_ptr + res_size - (l2 + 1), buf2);
",unused,diffutilsdebstretche-lib2Flocalcharset.c
"          /* Return ""TRANSLATION (NAME)"".  */
          char *result =
            XNMALLOC (strlen (translation) + 2 + strlen (name) + 1 + 1, char);

          sprintf (result, ""%s (%s)"", translation, name);
",1,unused,174,unused,"          /* Return ""TRANSLATION (NAME)"".  */
          char *result =
            XNMALLOC (strlen (translation) + 2 + strlen (name) + 1 + 1, char);

          sprintf (result, ""%s (%s)"", translation, name);
",unused,diffutilsdebstretche-lib2Fpropername.c
"          /* Return ""TRANSLATION (NAME)"".  */
          char *result =
            XNMALLOC (strlen (translation) + 2 + strlen (name) + 1 + 1, char);

          sprintf (result, ""%s (%s)"", translation, name);
",1,unused,276,unused,"          /* Return ""TRANSLATION (NAME)"".  */
          char *result =
            XNMALLOC (strlen (translation) + 2 + strlen (name) + 1 + 1, char);

          sprintf (result, ""%s (%s)"", translation, name);
",unused,diffutilsdebstretche-lib2Fpropername.c
"
  do
    {
      /* initialize the pattern */
      strcpy (buffer, f);
",1,unused,435,unused,"
  do
    {
      /* initialize the pattern */
      strcpy (buffer, f);
",unused,diffutilssources-lib2Fexclude.c
"	      else
		{
		  tmp = xmalloc (len + 7);
		  memcpy (tmp, pattern, len);
		  strcpy (tmp + len, ""(/.*)?"");
",1,unused,561,unused,"	      else
		{
		  tmp = xmalloc (len + 7);
		  memcpy (tmp, pattern, len);
		  strcpy (tmp + len, ""(/.*)?"");
",unused,diffutilssources-lib2Fexclude.c
"                          res_size = 0;
                          free (old_res_ptr);
                          break;
                        }
                      strcpy (res_ptr + res_size - (l2 + 1) - (l1 + 1), buf1);
",1,unused,239,unused,"                          res_size = 0;
                          free (old_res_ptr);
                          break;
                        }
                      strcpy (res_ptr + res_size - (l2 + 1) - (l1 + 1), buf1);
",unused,diffutilssources-lib2Flocalcharset.c
"                          free (old_res_ptr);
                          break;
                        }
                      strcpy (res_ptr + res_size - (l2 + 1) - (l1 + 1), buf1);
                      strcpy (res_ptr + res_size - (l2 + 1), buf2);
",1,unused,240,unused,"                          free (old_res_ptr);
                          break;
                        }
                      strcpy (res_ptr + res_size - (l2 + 1) - (l1 + 1), buf1);
                      strcpy (res_ptr + res_size - (l2 + 1), buf2);
",unused,diffutilssources-lib2Flocalcharset.c
"          /* Return ""TRANSLATION (NAME)"".  */
          char *result =
            XNMALLOC (strlen (translation) + 2 + strlen (name) + 1 + 1, char);

          sprintf (result, ""%s (%s)"", translation, name);
",1,unused,174,unused,"          /* Return ""TRANSLATION (NAME)"".  */
          char *result =
            XNMALLOC (strlen (translation) + 2 + strlen (name) + 1 + 1, char);

          sprintf (result, ""%s (%s)"", translation, name);
",unused,diffutilssources-lib2Fpropername.c
"          /* Return ""TRANSLATION (NAME)"".  */
          char *result =
            XNMALLOC (strlen (translation) + 2 + strlen (name) + 1 + 1, char);

          sprintf (result, ""%s (%s)"", translation, name);
",1,unused,276,unused,"          /* Return ""TRANSLATION (NAME)"".  */
          char *result =
            XNMALLOC (strlen (translation) + 2 + strlen (name) + 1 + 1, char);

          sprintf (result, ""%s (%s)"", translation, name);
",unused,diffutilssources-lib2Fpropername.c
"
  do
    {
      /* initialize the pattern */
      strcpy (buffer, f);
",1,unused,371,unused,"
  do
    {
      /* initialize the pattern */
      strcpy (buffer, f);
",unused,diffutilstrusty-lib2Fexclude.c
"                          res_size = 0;
                          free (old_res_ptr);
                          break;
                        }
                      strcpy (res_ptr + res_size - (l2 + 1) - (l1 + 1), buf1);
",1,unused,233,unused,"                          res_size = 0;
                          free (old_res_ptr);
                          break;
                        }
                      strcpy (res_ptr + res_size - (l2 + 1) - (l1 + 1), buf1);
",unused,diffutilstrusty-lib2Flocalcharset.c
"                          free (old_res_ptr);
                          break;
                        }
                      strcpy (res_ptr + res_size - (l2 + 1) - (l1 + 1), buf1);
                      strcpy (res_ptr + res_size - (l2 + 1), buf2);
",1,unused,234,unused,"                          free (old_res_ptr);
                          break;
                        }
                      strcpy (res_ptr + res_size - (l2 + 1) - (l1 + 1), buf1);
                      strcpy (res_ptr + res_size - (l2 + 1), buf2);
",unused,diffutilstrusty-lib2Flocalcharset.c
"          /* Return ""TRANSLATION (NAME)"".  */
          char *result =
            XNMALLOC (strlen (translation) + 2 + strlen (name) + 1 + 1, char);

          sprintf (result, ""%s (%s)"", translation, name);
",1,unused,174,unused,"          /* Return ""TRANSLATION (NAME)"".  */
          char *result =
            XNMALLOC (strlen (translation) + 2 + strlen (name) + 1 + 1, char);

          sprintf (result, ""%s (%s)"", translation, name);
",unused,diffutilstrusty-lib2Fpropername.c
"          /* Return ""TRANSLATION (NAME)"".  */
          char *result =
            XNMALLOC (strlen (translation) + 2 + strlen (name) + 1 + 1, char);

          sprintf (result, ""%s (%s)"", translation, name);
",1,unused,276,unused,"          /* Return ""TRANSLATION (NAME)"".  */
          char *result =
            XNMALLOC (strlen (translation) + 2 + strlen (name) + 1 + 1, char);

          sprintf (result, ""%s (%s)"", translation, name);
",unused,diffutilstrusty-lib2Fpropername.c
"
  do
    {
      /* initialize the pattern */
      strcpy (buffer, f);
",1,unused,435,unused,"
  do
    {
      /* initialize the pattern */
      strcpy (buffer, f);
",unused,diffutilsxenial-lib2Fexclude.c
"	      else
		{
		  tmp = xmalloc (len + 7);
		  memcpy (tmp, pattern, len);
		  strcpy (tmp + len, ""(/.*)?"");
",1,unused,561,unused,"	      else
		{
		  tmp = xmalloc (len + 7);
		  memcpy (tmp, pattern, len);
		  strcpy (tmp + len, ""(/.*)?"");
",unused,diffutilsxenial-lib2Fexclude.c
"                          res_size = 0;
                          free (old_res_ptr);
                          break;
                        }
                      strcpy (res_ptr + res_size - (l2 + 1) - (l1 + 1), buf1);
",1,unused,243,unused,"                          res_size = 0;
                          free (old_res_ptr);
                          break;
                        }
                      strcpy (res_ptr + res_size - (l2 + 1) - (l1 + 1), buf1);
",unused,diffutilsxenial-lib2Flocalcharset.c
"                          free (old_res_ptr);
                          break;
                        }
                      strcpy (res_ptr + res_size - (l2 + 1) - (l1 + 1), buf1);
                      strcpy (res_ptr + res_size - (l2 + 1), buf2);
",1,unused,244,unused,"                          free (old_res_ptr);
                          break;
                        }
                      strcpy (res_ptr + res_size - (l2 + 1) - (l1 + 1), buf1);
                      strcpy (res_ptr + res_size - (l2 + 1), buf2);
",unused,diffutilsxenial-lib2Flocalcharset.c
"          /* Return ""TRANSLATION (NAME)"".  */
          char *result =
            XNMALLOC (strlen (translation) + 2 + strlen (name) + 1 + 1, char);

          sprintf (result, ""%s (%s)"", translation, name);
",1,unused,174,unused,"          /* Return ""TRANSLATION (NAME)"".  */
          char *result =
            XNMALLOC (strlen (translation) + 2 + strlen (name) + 1 + 1, char);

          sprintf (result, ""%s (%s)"", translation, name);
",unused,diffutilsxenial-lib2Fpropername.c
"          /* Return ""TRANSLATION (NAME)"".  */
          char *result =
            XNMALLOC (strlen (translation) + 2 + strlen (name) + 1 + 1, char);

          sprintf (result, ""%s (%s)"", translation, name);
",1,unused,276,unused,"          /* Return ""TRANSLATION (NAME)"".  */
          char *result =
            XNMALLOC (strlen (translation) + 2 + strlen (name) + 1 + 1, char);

          sprintf (result, ""%s (%s)"", translation, name);
",unused,diffutilsxenial-lib2Fpropername.c
"                          res_size = 0;
                          free (old_res_ptr);
                          break;
                        }
                      strcpy (res_ptr + res_size - (l2 + 1) - (l1 + 1), buf1);
",1,unused,233,unused,"                          res_size = 0;
                          free (old_res_ptr);
                          break;
                        }
                      strcpy (res_ptr + res_size - (l2 + 1) - (l1 + 1), buf1);
",unused,diffutilsxenpatch-lib2Flocalcharset.c
"                          free (old_res_ptr);
                          break;
                        }
                      strcpy (res_ptr + res_size - (l2 + 1) - (l1 + 1), buf1);
                      strcpy (res_ptr + res_size - (l2 + 1), buf2);
",1,unused,234,unused,"                          free (old_res_ptr);
                          break;
                        }
                      strcpy (res_ptr + res_size - (l2 + 1) - (l1 + 1), buf1);
                      strcpy (res_ptr + res_size - (l2 + 1), buf2);
",unused,diffutilsxenpatch-lib2Flocalcharset.c
"          /* Return ""TRANSLATION (NAME)"".  */
          char *result =
            XNMALLOC (strlen (translation) + 2 + strlen (name) + 1 + 1, char);

          sprintf (result, ""%s (%s)"", translation, name);
",1,unused,174,unused,"          /* Return ""TRANSLATION (NAME)"".  */
          char *result =
            XNMALLOC (strlen (translation) + 2 + strlen (name) + 1 + 1, char);

          sprintf (result, ""%s (%s)"", translation, name);
",unused,diffutilsxenpatch-lib2Fpropername.c
"          /* Return ""TRANSLATION (NAME)"".  */
          char *result =
            XNMALLOC (strlen (translation) + 2 + strlen (name) + 1 + 1, char);

          sprintf (result, ""%s (%s)"", translation, name);
",1,unused,276,unused,"          /* Return ""TRANSLATION (NAME)"".  */
          char *result =
            XNMALLOC (strlen (translation) + 2 + strlen (name) + 1 + 1, char);

          sprintf (result, ""%s (%s)"", translation, name);
",unused,diffutilsxenpatch-lib2Fpropername.c
"	if (!tdb_file) {
		free(tmp_name);
		goto errout;
	}
	sprintf(tdb_file, ""%s/debugfs-%s.e2undo"", tdb_dir, dev_name);
",1,unused,103,unused,"	if (!tdb_file) {
		free(tmp_name);
		goto errout;
	}
	sprintf(tdb_file, ""%s/debugfs-%s.e2undo"", tdb_dir, dev_name);
",unused,e2fsprogartful-debugfs2Fdebugfs.c
"	char buf[200];
	unsigned long v;
	char *tmp;

	sprintf(buf, format, *val);
",1,unused,1270,unused,"	char buf[200];
	unsigned long v;
	char *tmp;

	sprintf(buf, format, *val);
",unused,e2fsprogartful-debugfs2Fdebugfs.c
"	char buf[200];
	unsigned long v;
	char *tmp;

	sprintf(buf, format, *val);
",1,unused,1292,unused,"	char buf[200];
	unsigned long v;
	char *tmp;

	sprintf(buf, format, *val);
",unused,e2fsprogartful-debugfs2Fdebugfs.c
"	char buf[200];
	unsigned long v;
	char *tmp;

	sprintf(buf, format, *val);
",1,unused,1314,unused,"	char buf[200];
	unsigned long v;
	char *tmp;

	sprintf(buf, format, *val);
",unused,e2fsprogartful-debugfs2Fdebugfs.c
"	if (fsize)
		modify_u8(argv[0], ""Fragment size"", decimal_format, fsize);

	for (i=0;  i < EXT2_NDIR_BLOCKS; i++) {
		sprintf(buf, ""Direct Block #%d"", i);
",1,unused,1394,unused,"	if (fsize)
		modify_u8(argv[0], ""Fragment size"", decimal_format, fsize);

	for (i=0;  i < EXT2_NDIR_BLOCKS; i++) {
		sprintf(buf, ""Direct Block #%d"", i);
",unused,e2fsprogartful-debugfs2Fdebugfs.c
"
	/* Apparently, this is the right way to detect and handle fast
	 * symlinks; see do_stat() in debugfs.c. */
	if (ext2fs_inode_data_blocks2(current_fs, inode) == 0)
		strcpy(buf, (char *) inode->i_block);
",1,unused,214,unused,"
	/* Apparently, this is the right way to detect and handle fast
	 * symlinks; see do_stat() in debugfs.c. */
	if (ext2fs_inode_data_blocks2(current_fs, inode) == 0)
		strcpy(buf, (char *) inode->i_block);
",unused,e2fsprogartful-debugfs2Fdump.c
"	if (!fullname) {
		com_err(""rdump"", errno, ""while allocating memory"");
		return;
	}
	sprintf(fullname, ""%s/%s"", dumproot, name);
",1,unused,264,unused,"	if (!fullname) {
		com_err(""rdump"", errno, ""while allocating memory"");
		return;
	}
	sprintf(fullname, ""%s/%s"", dumproot, name);
",unused,e2fsprogartful-debugfs2Fdump.c
"		com_err(argv[1], retval, ""out of memory"");
		return;
	}

	strcpy(extent_prompt, orig_prompt);
",1,unused,105,unused,"		com_err(argv[1], retval, ""out of memory"");
		return;
	}

	strcpy(extent_prompt, orig_prompt);
",unused,e2fsprogartful-debugfs2Fextent_inode.c
"	strcpy(extent_prompt, orig_prompt);
	cp = strchr(extent_prompt, ':');
	if (cp)
		*cp = 0;
	sprintf(extent_prompt + strlen(extent_prompt), "" (extent ino %d): "",
",1,unused,109,unused,"	strcpy(extent_prompt, orig_prompt);
	cp = strchr(extent_prompt, ':');
	if (cp)
		*cp = 0;
	sprintf(extent_prompt + strlen(extent_prompt), "" (extent ino %d): "",
",unused,e2fsprogartful-debugfs2Fextent_inode.c
"			fs->dir_name, name);
		return 0;
	}

	sprintf(cp, ""%s/%s"", fs->dir_name, name);
",1,unused,202,unused,"			fs->dir_name, name);
		return 0;
	}

	sprintf(cp, ""%s/%s"", fs->dir_name, name);
",unused,e2fsprogartful-debugfs2Ffilefrag.c
"			if (debugfs_read_inode(ino, &inode, ""ls""))
				return 0;
			modtime = inode.i_mtime;
			tm_p = localtime(&modtime);
			sprintf(datestr, ""%2d-%s-%4d %02d:%02d"",
",1,unused,138,unused,"			if (debugfs_read_inode(ino, &inode, ""ls""))
				return 0;
			modtime = inode.i_mtime;
			tm_p = localtime(&modtime);
			sprintf(datestr, ""%2d-%s-%4d %02d:%02d"",
",unused,e2fsprogartful-debugfs2Fls.c
"				tm_p->tm_mday, monstr[tm_p->tm_mon],
				1900 + tm_p->tm_year, tm_p->tm_hour,
				tm_p->tm_min);
		} else {
			strcpy(datestr, ""                 "");
",1,unused,143,unused,"				tm_p->tm_mday, monstr[tm_p->tm_mon],
				1900 + tm_p->tm_year, tm_p->tm_hour,
				tm_p->tm_min);
		} else {
			strcpy(datestr, ""                 "");
",unused,e2fsprogartful-debugfs2Fls.c
"		print_filename(ls->f, dirent, options);
		fputc('\n', ls->f);
	} else {
		if (entry == DIRENT_CHECKSUM) {
			sprintf(tmp, ""%c%u%c (dirblock checksum: 0x%08x)   "",
",1,unused,164,unused,"		print_filename(ls->f, dirent, options);
		fputc('\n', ls->f);
	} else {
		if (entry == DIRENT_CHECKSUM) {
			sprintf(tmp, ""%c%u%c (dirblock checksum: 0x%08x)   "",
",unused,e2fsprogartful-debugfs2Fls.c
"			fprintf(ls->f, ""%s"", tmp);
			ls->col += thislen;
			return 0;
		}
		sprintf(tmp, ""%c%u%c (%d) "", lbr, dirent->inode, rbr,
",1,unused,175,unused,"			fprintf(ls->f, ""%s"", tmp);
			ls->col += thislen;
			return 0;
		}
		sprintf(tmp, ""%c%u%c (%d) "", lbr, dirent->inode, rbr,
",unused,e2fsprogartful-debugfs2Fls.c
"
	arg = malloc(strlen(field)+1);
	if (!arg)
		return NULL;
	strcpy(arg, field);
",1,unused,382,unused,"
	arg = malloc(strlen(field)+1);
	if (!arg)
		return NULL;
	strcpy(arg, field);
",unused,e2fsprogartful-debugfs2Fset_fields.c
"		fprintf(stderr, ""Error maximum size for %s is %d.\n"",
			info->name, info->size);
		return EINVAL;
	}
	strcpy(cp, arg);
",1,unused,562,unused,"		fprintf(stderr, ""Error maximum size for %s is %d.\n"",
			info->name, info->size);
		return EINVAL;
	}
	strcpy(cp, arg);
",unused,e2fsprogartful-debugfs2Fset_fields.c
"		else if (ss->func == parse_bmap)
			type = ""set physical->logical block map"";
		else if (ss->func == parse_gd_csum)
			type = ""unsigned integer OR \""calc\"""";
		strcpy(name, ss->name);
",1,unused,707,unused,"		else if (ss->func == parse_bmap)
			type = ""set physical->logical block map"";
		else if (ss->func == parse_gd_csum)
			type = ""unsigned integer OR \""calc\"""";
		strcpy(name, ss->name);
",unused,e2fsprogartful-debugfs2Fset_fields.c
"			type = ""unsigned integer OR \""calc\"""";
		strcpy(name, ss->name);
		if (ss->flags & FLAG_ARRAY) {
			if (ss->max_idx > 0)
				sprintf(idx, ""[%d]"", ss->max_idx);
",1,unused,710,unused,"			type = ""unsigned integer OR \""calc\"""";
		strcpy(name, ss->name);
		if (ss->flags & FLAG_ARRAY) {
			if (ss->max_idx > 0)
				sprintf(idx, ""[%d]"", ss->max_idx);
",unused,e2fsprogartful-debugfs2Fset_fields.c
"		if (ss->flags & FLAG_ARRAY) {
			if (ss->max_idx > 0)
				sprintf(idx, ""[%d]"", ss->max_idx);
			else
				strcpy(idx, ""[]"");
",1,unused,712,unused,"		if (ss->flags & FLAG_ARRAY) {
			if (ss->max_idx > 0)
				sprintf(idx, ""[%d]"", ss->max_idx);
			else
				strcpy(idx, ""[]"");
",unused,e2fsprogartful-debugfs2Fset_fields.c
"			if (ss->max_idx > 0)
				sprintf(idx, ""[%d]"", ss->max_idx);
			else
				strcpy(idx, ""[]"");
			strcat(name, idx);
",1,unused,713,unused,"			if (ss->max_idx > 0)
				sprintf(idx, ""[%d]"", ss->max_idx);
			else
				strcpy(idx, ""[]"");
			strcat(name, idx);
",unused,e2fsprogartful-debugfs2Fset_fields.c
"				strcpy(idx, ""[]"");
			strcat(name, idx);
		}
		if (ss->ptr2)
			strcat(name, ""[_hi|_lo]"");
",1,unused,716,unused,"				strcpy(idx, ""[]"");
			strcat(name, idx);
		}
		if (ss->ptr2)
			strcat(name, ""[_hi|_lo]"");
",unused,e2fsprogartful-debugfs2Fset_fields.c
"	const char **i, **j;

	for (i = pager_search_list; *i; i++) {
		for (j = pager_dir_list; *j; j++) {
			sprintf(buf, ""%s/%s"", *j, *i);
",1,unused,72,unused,"	const char **i, **j;

	for (i = pager_search_list; *i; i++) {
		for (j = pager_dir_list; *j; j++) {
			sprintf(buf, ""%s/%s"", *j, *i);
",unused,e2fsprogartful-debugfs2Futil.c
"				_(""while trying to open %s""), bad_blocks_file);
			goto fatal;
		}
	} else {
		sprintf(buf, ""badblocks -b %d -X %s%s%s %llu"", fs->blocksize,
",1,unused,76,unused,"				_(""while trying to open %s""), bad_blocks_file);
			goto fatal;
		}
	} else {
		sprintf(buf, ""badblocks -b %d -X %s%s%s %llu"", fs->blocksize,
",unused,e2fsprogartful-e2fsck2Fbadblocks.c
"	if (retval)
		return;

	uuid_unparse(ctx->fs->super->s_uuid, uuid);
	sprintf(db->tdb_fn, ""%s/%s-dirinfo-XXXXXX"", tdb_dir, uuid);
",1,unused,71,unused,"	if (retval)
		return;

	uuid_unparse(ctx->fs->super->s_uuid, uuid);
	sprintf(db->tdb_fn, ""%s/%s-dirinfo-XXXXXX"", tdb_dir, uuid);
",unused,e2fsprogartful-e2fsck2Fdirinfo.c
"	case '%':
		append_string(s, ""%"", 1);
		return;
	case 'd':
		sprintf(buf, ""%02d"", tm->tm_mday);
",1,unused,90,unused,"	case '%':
		append_string(s, ""%"", 1);
		return;
	case 'd':
		sprintf(buf, ""%02d"", tm->tm_mday);
",unused,e2fsprogartful-e2fsck2Flogfile.c
"	case 'd':
		sprintf(buf, ""%02d"", tm->tm_mday);
		break;
	case 'D':
		sprintf(buf, ""%d%02d%02d"", tm->tm_year + 1900, tm->tm_mon + 1,
",1,unused,93,unused,"	case 'd':
		sprintf(buf, ""%02d"", tm->tm_mday);
		break;
	case 'D':
		sprintf(buf, ""%d%02d%02d"", tm->tm_year + 1900, tm->tm_mon + 1,
",unused,e2fsprogartful-e2fsck2Flogfile.c
"		buf[sizeof(buf)-1] = 0;
#endif
		break;
	case 'H':
		sprintf(buf, ""%02d"", tm->tm_hour);
",1,unused,106,unused,"		buf[sizeof(buf)-1] = 0;
#endif
		break;
	case 'H':
		sprintf(buf, ""%02d"", tm->tm_hour);
",unused,e2fsprogartful-e2fsck2Flogfile.c
"	case 'H':
		sprintf(buf, ""%02d"", tm->tm_hour);
		break;
	case 'm':
		sprintf(buf, ""%02d"", tm->tm_mon + 1);
",1,unused,109,unused,"	case 'H':
		sprintf(buf, ""%02d"", tm->tm_hour);
		break;
	case 'm':
		sprintf(buf, ""%02d"", tm->tm_mon + 1);
",unused,e2fsprogartful-e2fsck2Flogfile.c
"	case 'm':
		sprintf(buf, ""%02d"", tm->tm_mon + 1);
		break;
	case 'M':
		sprintf(buf, ""%02d"", tm->tm_min);
",1,unused,112,unused,"	case 'm':
		sprintf(buf, ""%02d"", tm->tm_mon + 1);
		break;
	case 'M':
		sprintf(buf, ""%02d"", tm->tm_min);
",unused,e2fsprogartful-e2fsck2Flogfile.c
"			cp = ctx->filesystem_name;
		append_string(s, cp, 0);
		return;
	case 'p':
		sprintf(buf, ""%lu"", (unsigned long) getpid());
",1,unused,123,unused,"			cp = ctx->filesystem_name;
		append_string(s, cp, 0);
		return;
	case 'p':
		sprintf(buf, ""%lu"", (unsigned long) getpid());
",unused,e2fsprogartful-e2fsck2Flogfile.c
"	case 'p':
		sprintf(buf, ""%lu"", (unsigned long) getpid());
		break;
	case 's':
		sprintf(buf, ""%lu"", (unsigned long) ctx->now);
",1,unused,126,unused,"	case 'p':
		sprintf(buf, ""%lu"", (unsigned long) getpid());
		break;
	case 's':
		sprintf(buf, ""%lu"", (unsigned long) ctx->now);
",unused,e2fsprogartful-e2fsck2Flogfile.c
"	case 's':
		sprintf(buf, ""%lu"", (unsigned long) ctx->now);
		break;
	case 'S':
		sprintf(buf, ""%02d"", tm->tm_sec);
",1,unused,129,unused,"	case 's':
		sprintf(buf, ""%lu"", (unsigned long) ctx->now);
		break;
	case 'S':
		sprintf(buf, ""%02d"", tm->tm_sec);
",unused,e2fsprogartful-e2fsck2Flogfile.c
"	case 'S':
		sprintf(buf, ""%02d"", tm->tm_sec);
		break;
	case 'T':
		sprintf(buf, ""%02d%02d%02d"", tm->tm_hour, tm->tm_min,
",1,unused,132,unused,"	case 'S':
		sprintf(buf, ""%02d"", tm->tm_sec);
		break;
	case 'T':
		sprintf(buf, ""%02d%02d%02d"", tm->tm_hour, tm->tm_min,
",unused,e2fsprogartful-e2fsck2Flogfile.c
"	case 'U':
		*flags |= FLAG_UTC;
		return;
	case 'y':
		sprintf(buf, ""%02d"", tm->tm_year % 100);
",1,unused,153,unused,"	case 'U':
		*flags |= FLAG_UTC;
		return;
	case 'y':
		sprintf(buf, ""%02d"", tm->tm_year % 100);
",unused,e2fsprogartful-e2fsck2Flogfile.c
"	case 'y':
		sprintf(buf, ""%02d"", tm->tm_year % 100);
		break;
	case 'Y':
		sprintf(buf, ""%d"", tm->tm_year + 1900);
",1,unused,156,unused,"	case 'y':
		sprintf(buf, ""%02d"", tm->tm_year % 100);
		break;
	case 'Y':
		sprintf(buf, ""%d"", tm->tm_year + 1900);
",unused,e2fsprogartful-e2fsck2Flogfile.c
"
#if 0
		printf(""%u "", pctx.ino);
#endif
		sprintf(buf, _(""reading indirect blocks of inode %u""),
",1,unused,2002,unused,"
#if 0
		printf(""%u "", pctx.ino);
#endif
		sprintf(buf, _(""reading indirect blocks of inode %u""),
",unused,e2fsprogartful-e2fsck2Fpass1.c
"		fix_problem(ctx, PR_3_NO_LPF, &pctx);
		return 1;
	}

	sprintf(name, ""#%u"", ino);
",1,unused,613,unused,"		fix_problem(ctx, PR_3_NO_LPF, &pctx);
		return 1;
	}

	sprintf(name, ""#%u"", ino);
",unused,e2fsprogartful-e2fsck2Fpass3.c
"	}
	if (!(ptr->flags & PR_CONFIG)) {
		char	key[9], *new_desc = NULL;

		sprintf(key, ""0x%06x"", code);
",1,unused,2159,unused,"	}
	if (!(ptr->flags & PR_CONFIG)) {
		char	key[9], *new_desc = NULL;

		sprintf(key, ""0x%06x"", code);
",unused,e2fsprogartful-e2fsck2Fproblem.c
"
		newpath = malloc(len);
		if (!newpath)
			fatal_error(ctx, ""Couldn't malloc() newpath"");
		strcpy(newpath, PATH_SET);
",1,unused,1087,unused,"
		newpath = malloc(len);
		if (!newpath)
			fatal_error(ctx, ""Couldn't malloc() newpath"");
		strcpy(newpath, PATH_SET);
",unused,e2fsprogartful-e2fsck2Funix.c
"			fatal_error(ctx, ""Couldn't malloc() newpath"");
		strcpy(newpath, PATH_SET);

		if (oldpath) {
			strcat(newpath, "":"");
",1,unused,1090,unused,"			fatal_error(ctx, ""Couldn't malloc() newpath"");
		strcpy(newpath, PATH_SET);

		if (oldpath) {
			strcat(newpath, "":"");
",unused,e2fsprogartful-e2fsck2Funix.c
"		strcpy(newpath, PATH_SET);

		if (oldpath) {
			strcat(newpath, "":"");
			strcat(newpath, oldpath);
",1,unused,1091,unused,"		strcpy(newpath, PATH_SET);

		if (oldpath) {
			strcat(newpath, "":"");
			strcat(newpath, oldpath);
",unused,e2fsprogartful-e2fsck2Funix.c
"	if (!tdb_file) {
		free(tmp_name);
		goto errout;
	}
	sprintf(tdb_file, ""%s/e2fsck-%s.e2undo"", tdb_dir, dev_name);
",1,unused,1295,unused,"	if (!tdb_file) {
		free(tmp_name);
		goto errout;
	}
	sprintf(tdb_file, ""%s/e2fsck-%s.e2undo"", tdb_dir, dev_name);
",unused,e2fsprogartful-e2fsck2Funix.c
"	printf(""Allocating %u bytes for %s...\n"", size, description);
#endif
	ret = malloc(size);
	if (!ret) {
		sprintf(buf, ""Can't allocate %u bytes for %s\n"",
",1,unused,130,unused,"	printf(""Allocating %u bytes for %s...\n"", size, description);
#endif
	ret = malloc(size);
	if (!ret) {
		sprintf(buf, ""Can't allocate %u bytes for %s\n"",
",unused,e2fsprogartful-e2fsck2Futil.c
"		free(new_type);
		free(new_value);
		return -1;
	}
	strcpy(new_type, search_type);
",1,unused,144,unused,"		free(new_type);
		free(new_value);
		return -1;
	}
	strcpy(new_type, search_type);
",unused,e2fsprogartful-lib2Fblkid2Fdev.c
"		free(new_value);
		return -1;
	}
	strcpy(new_type, search_type);
	strcpy(new_value, search_value);
",1,unused,145,unused,"		free(new_value);
		return -1;
	}
	strcpy(new_type, search_type);
	strcpy(new_value, search_value);
",unused,e2fsprogartful-lib2Fblkid2Fdev.c
"		    !strcmp(de->d_name, devname) ||
		    strncmp(de->d_name, ""dm-"", 3) ||
		    strlen(de->d_name) > sizeof(path)-32)
			continue;
		sprintf(path, ""/sys/block/%s/slaves"", de->d_name);
",1,unused,140,unused,"		    !strcmp(de->d_name, devname) ||
		    strncmp(de->d_name, ""dm-"", 3) ||
		    strlen(de->d_name) > sizeof(path)-32)
			continue;
		sprintf(path, ""/sys/block/%s/slaves"", de->d_name);
",unused,e2fsprogartful-lib2Fblkid2Fdevname.c
"	for (dir = dirlist; *dir; dir++) {
		struct stat st;
		char device[256];

		sprintf(device, ""%s/%s"", *dir, ptname);
",1,unused,229,unused,"	for (dir = dirlist; *dir; dir++) {
		struct stat st;
		char device[256];

		sprintf(device, ""%s/%s"", *dir, ptname);
",unused,e2fsprogartful-lib2Fblkid2Fdevname.c
"			continue;
		vdirname = malloc(vg_len + strlen(vg_name) + 8);
		if (!vdirname)
			goto exit;
		sprintf(vdirname, ""%s/%s/LVs"", VG_DIR, vg_name);
",1,unused,326,unused,"			continue;
		vdirname = malloc(vg_len + strlen(vg_name) + 8);
		if (!vdirname)
			goto exit;
		sprintf(vdirname, ""%s/%s/LVs"", VG_DIR, vg_name);
",unused,e2fsprogartful-lib2Fblkid2Fdevname.c
"			if (!lvm_device) {
				closedir(lv_list);
				goto exit;
			}
			sprintf(lvm_device, ""%s/%s/LVs/%s"", VG_DIR, vg_name,
",1,unused,346,unused,"			if (!lvm_device) {
				closedir(lv_list);
				goto exit;
			}
			sprintf(lvm_device, ""%s/%s/LVs/%s"", VG_DIR, vg_name,
",unused,e2fsprogartful-lib2Fblkid2Fdevname.c
"			}
			sprintf(lvm_device, ""%s/%s/LVs/%s"", VG_DIR, vg_name,
				lv_name);
			dev = lvm_get_devno(lvm_device);
			sprintf(lvm_device, ""%s/%s"", vg_name, lv_name);
",1,unused,349,unused,"			}
			sprintf(lvm_device, ""%s/%s/LVs/%s"", VG_DIR, vg_name,
				lv_name);
			dev = lvm_get_devno(lvm_device);
			sprintf(lvm_device, ""%s/%s"", vg_name, lv_name);
",unused,e2fsprogartful-lib2Fblkid2Fdevname.c
"		    ((dp->d_name[1] == 0) ||
		     ((dp->d_name[1] == '.') && (dp->d_name[2] == 0))))
			continue;

		sprintf(path, ""%s/%s"", dirname, dp->d_name);
",1,unused,118,unused,"		    ((dp->d_name[1] == 0) ||
		     ((dp->d_name[1] == '.') && (dp->d_name[2] == 0))))
			continue;

		sprintf(path, ""%s/%s"", dirname, dp->d_name);
",unused,e2fsprogartful-lib2Fblkid2Fdevno.c
"			label = vol_label;
	}

	/* We can't just print them as %04X, because they are unaligned */
	sprintf(serno, ""%02X%02X-%02X%02X"", vol_serno[3], vol_serno[2],
",1,unused,626,unused,"			label = vol_label;
	}

	/* We can't just print them as %04X, because they are unaligned */
	sprintf(serno, ""%02X%02X-%02X%02X"", vol_serno[3], vol_serno[2],
",unused,e2fsprogartful-lib2Fblkid2Fprobe.c
"			*cp = 0;
		}
	}

	sprintf(uuid_str, ""%016llX"", blkid_le64(ns->volume_serial));
",1,unused,782,unused,"			*cp = 0;
		}
	}

	sprintf(uuid_str, ""%016llX"", blkid_le64(ns->volume_serial));
",unused,e2fsprogartful-lib2Fblkid2Fprobe.c
"
	uuid_ptr = (unsigned long long *)hfs->finder_info.id;
	uuid = blkid_le64(*uuid_ptr);
	if (uuid) {
		sprintf(uuid_str, ""%016llX"", uuid);
",1,unused,1179,unused,"
	uuid_ptr = (unsigned long long *)hfs->finder_info.id;
	uuid = blkid_le64(*uuid_ptr);
	if (uuid) {
		sprintf(uuid_str, ""%016llX"", uuid);
",unused,e2fsprogartful-lib2Fblkid2Fprobe.c
"
	uuid_ptr = (unsigned long long *)hfsplus->finder_info.id;
	uuid = blkid_le64(*uuid_ptr);
	if (uuid) {
		sprintf(uuid_str, ""%016llX"", uuid);
",1,unused,1245,unused,"
	uuid_ptr = (unsigned long long *)hfsplus->finder_info.id;
	uuid = blkid_le64(*uuid_ptr);
	if (uuid) {
		sprintf(uuid_str, ""%016llX"", uuid);
",unused,e2fsprogartful-lib2Fblkid2Fprobe.c
"	if (ret == 0 && S_ISREG(st.st_mode)) {
		tmp = malloc(strlen(filename) + 8);
		if (tmp) {
			mode_t save_umask = umask(022);
			sprintf(tmp, ""%s-XXXXXX"", filename);
",1,unused,98,unused,"	if (ret == 0 && S_ISREG(st.st_mode)) {
		tmp = malloc(strlen(filename) + 8);
		if (tmp) {
			mode_t save_umask = umask(022);
			sprintf(tmp, ""%s-XXXXXX"", filename);
",unused,e2fsprogartful-lib2Fblkid2Fsave.c
"			char *backup;

			backup = malloc(strlen(filename) + 5);
			if (backup) {
				sprintf(backup, ""%s.old"", filename);
",1,unused,147,unused,"			char *backup;

			backup = malloc(strlen(filename) + 5);
			if (backup) {
				sprintf(backup, ""%s.old"", filename);
",unused,e2fsprogartful-lib2Fblkid2Fsave.c
"	for (p = mode_list; p->string; p++) {
		if (num == p->num)
			return p->string;
	}
	sprintf(buf, ""ENC_MODE_%d"", num);
",1,unused,44,unused,"	for (p = mode_list; p->string; p++) {
		if (num == p->num)
			return p->string;
	}
	sprintf(buf, ""ENC_MODE_%d"", num);
",unused,e2fsprogartful-lib2Fe2p2Fcrypto_mode.c
"		fchar = '?';
		break;
	}
	for (fnum = 0; mask >>= 1; fnum++);
	sprintf(buf, ""FEATURE_%c%d"", fchar, fnum);
",1,unused,155,unused,"		fchar = '?';
		break;
	}
	for (fnum = 0; mask >>= 1; fnum++);
	sprintf(buf, ""FEATURE_%c%d"", fchar, fnum);
",unused,e2fsprogartful-lib2Fe2p2Ffeature.c
"		fchar = '?';
		break;
	}
	for (fnum = 0; mask >>= 1; fnum++);
	sprintf(buf, ""FEATURE_%c%d"", fchar, fnum);
",1,unused,229,unused,"		fchar = '?';
		break;
	}
	for (fnum = 0; mask >>= 1; fnum++);
	sprintf(buf, ""FEATURE_%c%d"", fchar, fnum);
",unused,e2fsprogartful-lib2Fe2p2Ffeature.c
"
	buf = malloc(strlen(str)+1);
	if (!buf)
		return 1;
	strcpy(buf, str);
",1,unused,316,unused,"
	buf = malloc(strlen(str)+1);
	if (!buf)
		return 1;
	strcpy(buf, str);
",unused,e2fsprogartful-lib2Fe2p2Ffeature.c
"	for (p = hash_list; p->string; p++) {
		if (num == p->num)
			return p->string;
	}
	sprintf(buf, ""HASHALG_%d"", num);
",1,unused,42,unused,"	for (p = hash_list; p->string; p++) {
		if (num == p->num)
			return p->string;
	}
	sprintf(buf, ""HASHALG_%d"", num);
",unused,e2fsprogartful-lib2Fe2p2Fhashstr.c
"
	if (secs >= MONTH_INT) {
		num = secs / MONTH_INT;
		secs -= num*MONTH_INT;
		sprintf(buf, ""%d month%s"", num, (num>1) ? ""s"" : """");
",1,unused,71,unused,"
	if (secs >= MONTH_INT) {
		num = secs / MONTH_INT;
		secs -= num*MONTH_INT;
		sprintf(buf, ""%d month%s"", num, (num>1) ? ""s"" : """");
",unused,e2fsprogartful-lib2Fe2p2Fls.c
"	}
	if (secs >= WEEK_INT) {
		num = secs / WEEK_INT;
		secs -= num*WEEK_INT;
		sprintf(tmp, ""%s%d week%s"", buf[0] ? "", "" : """",
",1,unused,76,unused,"	}
	if (secs >= WEEK_INT) {
		num = secs / WEEK_INT;
		secs -= num*WEEK_INT;
		sprintf(tmp, ""%s%d week%s"", buf[0] ? "", "" : """",
",unused,e2fsprogartful-lib2Fe2p2Fls.c
"		num = secs / WEEK_INT;
		secs -= num*WEEK_INT;
		sprintf(tmp, ""%s%d week%s"", buf[0] ? "", "" : """",
			num, (num>1) ? ""s"" : """");
		strcat(buf, tmp);
",1,unused,78,unused,"		num = secs / WEEK_INT;
		secs -= num*WEEK_INT;
		sprintf(tmp, ""%s%d week%s"", buf[0] ? "", "" : """",
			num, (num>1) ? ""s"" : """");
		strcat(buf, tmp);
",unused,e2fsprogartful-lib2Fe2p2Fls.c
"	}
	if (secs >= DAY_INT) {
		num = secs / DAY_INT;
		secs -= num*DAY_INT;
		sprintf(tmp, ""%s%d day%s"", buf[0] ? "", "" : """",
",1,unused,83,unused,"	}
	if (secs >= DAY_INT) {
		num = secs / DAY_INT;
		secs -= num*DAY_INT;
		sprintf(tmp, ""%s%d day%s"", buf[0] ? "", "" : """",
",unused,e2fsprogartful-lib2Fe2p2Fls.c
"		num = secs / DAY_INT;
		secs -= num*DAY_INT;
		sprintf(tmp, ""%s%d day%s"", buf[0] ? "", "" : """",
			num, (num>1) ? ""s"" : """");
		strcat(buf, tmp);
",1,unused,85,unused,"		num = secs / DAY_INT;
		secs -= num*DAY_INT;
		sprintf(tmp, ""%s%d day%s"", buf[0] ? "", "" : """",
			num, (num>1) ? ""s"" : """");
		strcat(buf, tmp);
",unused,e2fsprogartful-lib2Fe2p2Fls.c
"		hr = secs / HOUR_INT;
		secs -= hr*HOUR_INT;
		min = secs / MINUTE_INT;
		secs -= min*MINUTE_INT;
		sprintf(tmp, ""%s%d:%02d:%02d"", buf[0] ? "", "" : """",
",1,unused,92,unused,"		hr = secs / HOUR_INT;
		secs -= hr*HOUR_INT;
		min = secs / MINUTE_INT;
		secs -= min*MINUTE_INT;
		sprintf(tmp, ""%s%d:%02d:%02d"", buf[0] ? "", "" : """",
",unused,e2fsprogartful-lib2Fe2p2Fls.c
"		min = secs / MINUTE_INT;
		secs -= min*MINUTE_INT;
		sprintf(tmp, ""%s%d:%02d:%02d"", buf[0] ? "", "" : """",
			hr, min, secs);
		strcat(buf, tmp);
",1,unused,94,unused,"		min = secs / MINUTE_INT;
		secs -= min*MINUTE_INT;
		sprintf(tmp, ""%s%d:%02d:%02d"", buf[0] ? "", "" : """",
			hr, min, secs);
		strcat(buf, tmp);
",unused,e2fsprogartful-lib2Fe2p2Fls.c
"	if (sb->s_volume_name[0]) {
		memset(buf, 0, sizeof(buf));
		strncpy(buf, sb->s_volume_name, sizeof(sb->s_volume_name));
	} else
		strcpy(buf, ""<none>"");
",1,unused,239,unused,"	if (sb->s_volume_name[0]) {
		memset(buf, 0, sizeof(buf));
		strncpy(buf, sb->s_volume_name, sizeof(sb->s_volume_name));
	} else
		strcpy(buf, ""<none>"");
",unused,e2fsprogartful-lib2Fe2p2Fls.c
"	if (sb->s_last_mounted[0]) {
		memset(buf, 0, sizeof(buf));
		strncpy(buf, sb->s_last_mounted, sizeof(sb->s_last_mounted));
	} else
		strcpy(buf, ""<not available>"");
",1,unused,245,unused,"	if (sb->s_last_mounted[0]) {
		memset(buf, 0, sizeof(buf));
		strncpy(buf, sb->s_last_mounted, sizeof(sb->s_last_mounted));
	} else
		strcpy(buf, ""<not available>"");
",unused,e2fsprogartful-lib2Fe2p2Fls.c
"		if (mask == f->mask)
			return f->string;
	}
	for (fnum = 0; mask >>= 1; fnum++);
	sprintf(buf, ""MNTOPT_%d"", fnum);
",1,unused,54,unused,"		if (mask == f->mask)
			return f->string;
	}
	for (fnum = 0; mask >>= 1; fnum++);
	sprintf(buf, ""MNTOPT_%d"", fnum);
",unused,e2fsprogartful-lib2Fe2p2Fmntopts.c
"
	buf = malloc(strlen(str)+1);
	if (!buf)
		return 1;
	strcpy(buf, str);
",1,unused,113,unused,"
	buf = malloc(strlen(str)+1);
	if (!buf)
		return 1;
	strcpy(buf, str);
",unused,e2fsprogartful-lib2Fe2p2Fmntopts.c
"		os = ""(unknown os)"";

        ret = malloc(strlen(os)+1);
	if (ret)
		strcpy(ret, os);
",1,unused,40,unused,"		os = ""(unknown os)"";

        ret = malloc(strlen(os)+1);
	if (ret)
		strcpy(ret, os);
",unused,e2fsprogartful-lib2Fe2p2Fostype.c
"{
	struct uuid uuid;

	e2p_unpack_uuid(uu, &uuid);
	sprintf(out,
",1,unused,68,unused,"{
	struct uuid uuid;

	e2p_unpack_uuid(uu, &uuid);
	sprintf(out,
",unused,e2fsprogartful-lib2Fe2p2Fuuid.c
"	}
    }
    et_list_unlock();
oops:
    strcpy (buffer, ""Unknown code "");
",1,unused,172,unused,"	}
    }
    et_list_unlock();
oops:
    strcpy (buffer, ""Unknown code "");
",unused,e2fsprogartful-lib2Fet2Ferror_message.c
"    et_list_unlock();
oops:
    strcpy (buffer, ""Unknown code "");
    if (table_num) {
	strcat (buffer, error_table_name (table_num));
",1,unused,174,unused,"    et_list_unlock();
oops:
    strcpy (buffer, ""Unknown code "");
    if (table_num) {
	strcat (buffer, error_table_name (table_num));
",unused,e2fsprogartful-lib2Fet2Ferror_message.c
"oops:
    strcpy (buffer, ""Unknown code "");
    if (table_num) {
	strcat (buffer, error_table_name (table_num));
	strcat (buffer, "" "");
",1,unused,175,unused,"oops:
    strcpy (buffer, ""Unknown code "");
    if (table_num) {
	strcat (buffer, error_table_name (table_num));
	strcat (buffer, "" "");
",unused,e2fsprogartful-lib2Fet2Ferror_message.c
"
	retval = ext2fs_get_mem(strlen(src->device_name)+1, &fs->device_name);
	if (retval)
		goto errout;
	strcpy(fs->device_name, src->device_name);
",1,unused,54,unused,"
	retval = ext2fs_get_mem(strlen(src->device_name)+1, &fs->device_name);
	if (retval)
		goto errout;
	strcpy(fs->device_name, src->device_name);
",unused,e2fsprogartful-lib2Fext2fs2Fdupfs.c
"	if (last_empty) {
		err = ext2fs_get_mem(strlen(key) + 1, &last_empty->name);
		if (err)
			goto errout;
		strcpy(last_empty->name, key);
",1,unused,1176,unused,"	if (last_empty) {
		err = ext2fs_get_mem(strlen(key) + 1, &last_empty->name);
		if (err)
			goto errout;
		strcpy(last_empty->name, key);
",unused,e2fsprogartful-lib2Fext2fs2Fext_attr.c
"	x = handle->attrs + handle->length - 4;
	err = ext2fs_get_mem(strlen(key) + 1, &x->name);
	if (err)
		goto errout;
	strcpy(x->name, key);
",1,unused,1193,unused,"	x = handle->attrs + handle->length - 4;
	err = ext2fs_get_mem(strlen(key) + 1, &x->name);
	if (err)
		goto errout;
	strcpy(x->name, key);
",unused,e2fsprogartful-lib2Fext2fs2Fext_attr.c
"	if (!dp->name) {
		free(dp);
		return;
	}
	strcpy(dp->name, name);
",1,unused,62,unused,"	if (!dp->name) {
		free(dp);
		return;
	}
	strcpy(dp->name, name);
",unused,e2fsprogartful-lib2Fext2fs2Ffinddev.c
"		if (dp->d_name[0] == '.' &&
		    ((dp->d_name[1] == 0) ||
		     ((dp->d_name[1] == '.') && (dp->d_name[2] == 0))))
			goto skip_to_next;
		sprintf(path, ""%s/%s"", dirname, dp->d_name);
",1,unused,102,unused,"		if (dp->d_name[0] == '.' &&
		    ((dp->d_name[1] == 0) ||
		     ((dp->d_name[1] == '.') && (dp->d_name[2] == 0))))
			goto skip_to_next;
		sprintf(path, ""%s/%s"", dirname, dp->d_name);
",unused,e2fsprogartful-lib2Fext2fs2Ffinddev.c
"			if (!cp) {
				closedir(dir);
				return ENOMEM;
			}
			strcpy(cp, path);
",1,unused,113,unused,"			if (!cp) {
				closedir(dir);
				return ENOMEM;
			}
			strcpy(cp, path);
",unused,e2fsprogartful-lib2Fext2fs2Ffinddev.c
"		if (retval) {
			ext2fs_free_mem(&bitmap);
			return retval;
		}
		strcpy(bitmap->description, descr);
",1,unused,112,unused,"		if (retval) {
			ext2fs_free_mem(&bitmap);
			return retval;
		}
		strcpy(bitmap->description, descr);
",unused,e2fsprogartful-lib2Fext2fs2Fgen_bitmap.c
"		if (retval) {
			ext2fs_free_mem(&bitmap);
			return retval;
		}
		strcpy(bitmap->description, descr);
",1,unused,162,unused,"		if (retval) {
			ext2fs_free_mem(&bitmap);
			return retval;
		}
		strcpy(bitmap->description, descr);
",unused,e2fsprogartful-lib2Fext2fs2Fgen_bitmap64.c
"		if (retval) {
			ext2fs_free_mem(&new_bmap);
			return retval;
		}
		strcpy(new_descr, ""copy of "");
",1,unused,327,unused,"		if (retval) {
			ext2fs_free_mem(&new_bmap);
			return retval;
		}
		strcpy(new_descr, ""copy of "");
",unused,e2fsprogartful-lib2Fext2fs2Fgen_bitmap64.c
"			ext2fs_free_mem(&new_bmap);
			return retval;
		}
		strcpy(new_descr, ""copy of "");
		strcat(new_descr, descr);
",1,unused,328,unused,"			ext2fs_free_mem(&new_bmap);
			return retval;
		}
		strcpy(new_descr, ""copy of "");
		strcat(new_descr, descr);
",unused,e2fsprogartful-lib2Fext2fs2Fgen_bitmap64.c
"	if (dir == ino) {
		retval = ext2fs_get_mem(2, name);
		if (retval)
			return retval;
		strcpy(*name, (dir == EXT2_ROOT_INO) ? ""/"" : ""."");
",1,unused,83,unused,"	if (dir == ino) {
		retval = ext2fs_get_mem(2, name);
		if (retval)
			return retval;
		strcpy(*name, (dir == EXT2_ROOT_INO) ? ""/"" : ""."");
",unused,e2fsprogartful-lib2Fext2fs2Fget_pathname.c
"	if (!dir || (maxdepth < 0)) {
		retval = ext2fs_get_mem(4, name);
		if (retval)
			return retval;
		strcpy(*name, ""..."");
",1,unused,91,unused,"	if (!dir || (maxdepth < 0)) {
		retval = ext2fs_get_mem(4, name);
		if (retval)
			return retval;
		strcpy(*name, ""..."");
",unused,e2fsprogartful-lib2Fext2fs2Fget_pathname.c
"			snprintf(tmp, sizeof(tmp), ""<%u>"", dir);
		retval = ext2fs_get_mem(strlen(tmp)+1, name);
		if (retval)
			goto cleanup;
		strcpy(*name, tmp);
",1,unused,111,unused,"			snprintf(tmp, sizeof(tmp), ""<%u>"", dir);
		retval = ext2fs_get_mem(strlen(tmp)+1, name);
		if (retval)
			goto cleanup;
		strcpy(*name, tmp);
",unused,e2fsprogartful-lib2Fext2fs2Fget_pathname.c
"		goto cleanup;

	ret[0] = 0;
	if (parent_name[1])
		strcat(ret, parent_name);
",1,unused,139,unused,"		goto cleanup;

	ret[0] = 0;
	if (parent_name[1])
		strcat(ret, parent_name);
",unused,e2fsprogartful-lib2Fext2fs2Fget_pathname.c
"
	ret[0] = 0;
	if (parent_name[1])
		strcat(ret, parent_name);
	strcat(ret, ""/"");
",1,unused,140,unused,"
	ret[0] = 0;
	if (parent_name[1])
		strcat(ret, parent_name);
	strcat(ret, ""/"");
",unused,e2fsprogartful-lib2Fext2fs2Fget_pathname.c
"	if (parent_name[1])
		strcat(ret, parent_name);
	strcat(ret, ""/"");
	if (gp.name)
		strcat(ret, gp.name);
",1,unused,142,unused,"	if (parent_name[1])
		strcat(ret, parent_name);
	strcat(ret, ""/"");
	if (gp.name)
		strcat(ret, gp.name);
",unused,e2fsprogartful-lib2Fext2fs2Fget_pathname.c
"	strcat(ret, ""/"");
	if (gp.name)
		strcat(ret, gp.name);
	else
		strcat(ret, ""???"");
",1,unused,144,unused,"	strcat(ret, ""/"");
	if (gp.name)
		strcat(ret, gp.name);
	else
		strcat(ret, ""???"");
",unused,e2fsprogartful-lib2Fext2fs2Fget_pathname.c
"{
	struct uuid uuid;

	unpack_uuid(uu, &uuid);
	sprintf(out,
",1,unused,174,unused,"{
	struct uuid uuid;

	unpack_uuid(uu, &uuid);
	sprintf(out,
",unused,e2fsprogartful-lib2Fext2fs2Ficount.c
"	retval = ext2fs_get_mem(strlen(tdb_dir) + 64, &fn);
	if (retval)
		goto errout;
	uuid_unparse(fs->super->s_uuid, uuid);
	sprintf(fn, ""%s/%s-icount-XXXXXX"", tdb_dir, uuid);
",1,unused,204,unused,"	retval = ext2fs_get_mem(strlen(tdb_dir) + 64, &fn);
	if (retval)
		goto errout;
	uuid_unparse(fs->super->s_uuid, uuid);
	sprintf(fn, ""%s/%s-icount-XXXXXX"", tdb_dir, uuid);
",unused,e2fsprogartful-lib2Fext2fs2Ficount.c
"	retval = ext2fs_get_mem(strlen(name)+1, &fs->device_name);
	if (retval)
		goto cleanup;

	strcpy(fs->device_name, name);
",1,unused,136,unused,"	retval = ext2fs_get_mem(strlen(name)+1, &fs->device_name);
	if (retval)
		goto cleanup;

	strcpy(fs->device_name, name);
",unused,e2fsprogartful-lib2Fext2fs2Finitialize.c
"	retval = ext2fs_get_mem(strlen(fs->device_name) + 80, &buf);
	if (retval)
		goto cleanup;

	strcpy(buf, ""block bitmap for "");
",1,unused,468,unused,"	retval = ext2fs_get_mem(strlen(fs->device_name) + 80, &buf);
	if (retval)
		goto cleanup;

	strcpy(buf, ""block bitmap for "");
",unused,e2fsprogartful-lib2Fext2fs2Finitialize.c
"	if (retval)
		goto cleanup;

	strcpy(buf, ""block bitmap for "");
	strcat(buf, fs->device_name);
",1,unused,469,unused,"	if (retval)
		goto cleanup;

	strcpy(buf, ""block bitmap for "");
	strcat(buf, fs->device_name);
",unused,e2fsprogartful-lib2Fext2fs2Finitialize.c
"	retval = ext2fs_allocate_subcluster_bitmap(fs, buf, &fs->block_map);
	if (retval)
		goto cleanup;

	strcpy(buf, ""inode bitmap for "");
",1,unused,474,unused,"	retval = ext2fs_allocate_subcluster_bitmap(fs, buf, &fs->block_map);
	if (retval)
		goto cleanup;

	strcpy(buf, ""inode bitmap for "");
",unused,e2fsprogartful-lib2Fext2fs2Finitialize.c
"	if (retval)
		goto cleanup;

	strcpy(buf, ""inode bitmap for "");
	strcat(buf, fs->device_name);
",1,unused,475,unused,"	if (retval)
		goto cleanup;

	strcpy(buf, ""inode bitmap for "");
	strcat(buf, fs->device_name);
",unused,e2fsprogartful-lib2Fext2fs2Finitialize.c
"	if ((retval = ext2fs_get_mem(sizeof(struct inode_private_data),
				     &data)))
		return retval;
	data->magic = EXT2_ET_MAGIC_INODE_IO_CHANNEL;
	sprintf(data->name, ""%u:%d"", ino, ino_unique++);
",1,unused,92,unused,"	if ((retval = ext2fs_get_mem(sizeof(struct inode_private_data),
				     &data)))
		return retval;
	data->magic = EXT2_ET_MAGIC_INODE_IO_CHANNEL;
	sprintf(data->name, ""%u:%d"", ino, ino_unique++);
",unused,e2fsprogartful-lib2Fext2fs2Finode_io.c
"	retval = ext2fs_get_mem(strlen(name)+1, &io->name);
	if (retval)
		goto cleanup;

	strcpy(io->name, name);
",1,unused,146,unused,"	retval = ext2fs_get_mem(strlen(name)+1, &io->name);
	if (retval)
		goto cleanup;

	strcpy(io->name, name);
",unused,e2fsprogartful-lib2Fext2fs2Finode_io.c
"
	options = malloc(strlen(opts)+1);
	if (!options)
		return EXT2_ET_NO_MEMORY;
	strcpy(options, opts);
",1,unused,39,unused,"
	options = malloc(strlen(opts)+1);
	if (!options)
		return EXT2_ET_NO_MEMORY;
	strcpy(options, opts);
",unused,e2fsprogartful-lib2Fext2fs2Fio_manager.c
"	if (mount_flags & EXT2_MF_MOUNTED) {
#if HAVE_EXT2_IOCTLS
		int f = 0;
#endif
		strcat(jfile, ""/.journal"");
",1,unused,456,unused,"	if (mount_flags & EXT2_MF_MOUNTED) {
#if HAVE_EXT2_IOCTLS
		int f = 0;
#endif
		strcat(jfile, ""/.journal"");
",unused,e2fsprogartful-lib2Fext2fs2Fmkjournal.c
"	fs->umask = 022;
	retval = ext2fs_get_mem(strlen(name)+1, &fs->device_name);
	if (retval)
		goto cleanup;
	strcpy(fs->device_name, name);
",1,unused,146,unused,"	fs->umask = 022;
	retval = ext2fs_get_mem(strlen(name)+1, &fs->device_name);
	if (retval)
		goto cleanup;
	strcpy(fs->device_name, name);
",unused,e2fsprogartful-lib2Fext2fs2Fopenfs.c
"		return retval;
	if (do_block) {
		if (fs->block_map)
			ext2fs_free_block_bitmap(fs->block_map);
		strcpy(buf, ""block bitmap for "");
",1,unused,228,unused,"		return retval;
	if (do_block) {
		if (fs->block_map)
			ext2fs_free_block_bitmap(fs->block_map);
		strcpy(buf, ""block bitmap for "");
",unused,e2fsprogartful-lib2Fext2fs2Frw_bitmaps.c
"	if (do_block) {
		if (fs->block_map)
			ext2fs_free_block_bitmap(fs->block_map);
		strcpy(buf, ""block bitmap for "");
		strcat(buf, fs->device_name);
",1,unused,229,unused,"	if (do_block) {
		if (fs->block_map)
			ext2fs_free_block_bitmap(fs->block_map);
		strcpy(buf, ""block bitmap for "");
		strcat(buf, fs->device_name);
",unused,e2fsprogartful-lib2Fext2fs2Frw_bitmaps.c
"		block_nbytes = 0;
	if (do_inode) {
		if (fs->inode_map)
			ext2fs_free_inode_bitmap(fs->inode_map);
		strcpy(buf, ""inode bitmap for "");
",1,unused,241,unused,"		block_nbytes = 0;
	if (do_inode) {
		if (fs->inode_map)
			ext2fs_free_inode_bitmap(fs->inode_map);
		strcpy(buf, ""inode bitmap for "");
",unused,e2fsprogartful-lib2Fext2fs2Frw_bitmaps.c
"	if (do_inode) {
		if (fs->inode_map)
			ext2fs_free_inode_bitmap(fs->inode_map);
		strcpy(buf, ""inode bitmap for "");
		strcat(buf, fs->device_name);
",1,unused,242,unused,"	if (do_inode) {
		if (fs->inode_map)
			ext2fs_free_inode_bitmap(fs->inode_map);
		strcpy(buf, ""inode bitmap for "");
		strcat(buf, fs->device_name);
",unused,e2fsprogartful-lib2Fext2fs2Frw_bitmaps.c
"	retval = ext2fs_get_mem(strlen(name)+1, &io->name);
	if (retval)
		goto cleanup;

	strcpy(io->name, name);
",1,unused,192,unused,"	retval = ext2fs_get_mem(strlen(name)+1, &io->name);
	if (retval)
		goto cleanup;

	strcpy(io->name, name);
",unused,e2fsprogartful-lib2Fext2fs2Ftest_io.c
"	retval = ext2fs_get_mem(strlen(name)+1, &io->name);
	if (retval)
		goto cleanup;

	strcpy(io->name, name);
",1,unused,717,unused,"	retval = ext2fs_get_mem(strlen(name)+1, &io->name);
	if (retval)
		goto cleanup;

	strcpy(io->name, name);
",unused,e2fsprogartful-lib2Fext2fs2Fundo_io.c
"	retval = ext2fs_get_mem(strlen(name)+1, &io->name);
	if (retval)
		goto cleanup;

	strcpy(io->name, name);
",1,unused,582,unused,"	retval = ext2fs_get_mem(strlen(name)+1, &io->name);
	if (retval)
		goto cleanup;

	strcpy(io->name, name);
",unused,e2fsprogartful-lib2Fext2fs2Funix_io.c
"			 (strlen(infop->subsystem_name)+1)
			 * sizeof(char));
	if (ret_val == (char *)NULL)
	    return((char *)NULL);
	strcpy(ret_val, infop->subsystem_name);
",1,unused,35,unused,"			 (strlen(infop->subsystem_name)+1)
			 * sizeof(char));
	if (ret_val == (char *)NULL)
	    return((char *)NULL);
	strcpy(ret_val, infop->subsystem_name);
",unused,e2fsprogartful-lib2Fss2Ferror.c
"
	tmp = malloc(strlen(libpath)+1);
	if (!tmp)
		return;
	strcpy(tmp, libpath);
",1,unused,63,unused,"
	tmp = malloc(strlen(libpath)+1);
	if (!tmp)
		return;
	strcpy(tmp, libpath);
",unused,e2fsprogartful-lib2Fss2Fget_readline.c
"		ss_perror(sci_idx, 0,
			  ""couldn't allocate memory to print usage message"");
		return;
	}
	sprintf(buffer, ""usage:\n\t%s [topic|command]\nor\t%s\n"",
",1,unused,65,unused,"		ss_perror(sci_idx, 0,
			  ""couldn't allocate memory to print usage message"");
		return;
	}
	sprintf(buffer, ""usage:\n\t%s [topic|command]\nor\t%s\n"",
",unused,e2fsprogartful-lib2Fss2Fhelp.c
"	    ss_perror(sci_idx, 0,
		      ""couldn't allocate memory for help filename"");
	    return;
	}
	(void) strcpy(buffer, info->info_dirs[idx]);
",1,unused,88,unused,"	    ss_perror(sci_idx, 0,
		      ""couldn't allocate memory for help filename"");
	    return;
	}
	(void) strcpy(buffer, info->info_dirs[idx]);
",unused,e2fsprogartful-lib2Fss2Fhelp.c
"		      ""couldn't allocate memory for help filename"");
	    return;
	}
	(void) strcpy(buffer, info->info_dirs[idx]);
	(void) strcat(buffer, ""/"");
",1,unused,89,unused,"		      ""couldn't allocate memory for help filename"");
	    return;
	}
	(void) strcpy(buffer, info->info_dirs[idx]);
	(void) strcat(buffer, ""/"");
",unused,e2fsprogartful-lib2Fss2Fhelp.c
"	    return;
	}
	(void) strcpy(buffer, info->info_dirs[idx]);
	(void) strcat(buffer, ""/"");
	(void) strcat(buffer, argv[1]);
",1,unused,90,unused,"	    return;
	}
	(void) strcpy(buffer, info->info_dirs[idx]);
	(void) strcat(buffer, ""/"");
	(void) strcat(buffer, argv[1]);
",unused,e2fsprogartful-lib2Fss2Fhelp.c
"	}
	(void) strcpy(buffer, info->info_dirs[idx]);
	(void) strcat(buffer, ""/"");
	(void) strcat(buffer, argv[1]);
	(void) strcat(buffer, "".info"");
",1,unused,91,unused,"	}
	(void) strcpy(buffer, info->info_dirs[idx]);
	(void) strcat(buffer, ""/"");
	(void) strcat(buffer, argv[1]);
	(void) strcat(buffer, "".info"");
",unused,e2fsprogartful-lib2Fss2Fhelp.c
"    }
    if (fd < 0) {
#define MSG ""No info found for ""
        char *buf = malloc(strlen (MSG) + strlen (argv[1]) + 1);
	strcpy(buf, MSG);
",1,unused,100,unused,"    }
    if (fd < 0) {
#define MSG ""No info found for ""
        char *buf = malloc(strlen (MSG) + strlen (argv[1]) + 1);
	strcpy(buf, MSG);
",unused,e2fsprogartful-lib2Fss2Fhelp.c
"    if (fd < 0) {
#define MSG ""No info found for ""
        char *buf = malloc(strlen (MSG) + strlen (argv[1]) + 1);
	strcpy(buf, MSG);
	strcat(buf, argv[1]);
",1,unused,101,unused,"    if (fd < 0) {
#define MSG ""No info found for ""
        char *buf = malloc(strlen (MSG) + strlen (argv[1]) + 1);
	strcpy(buf, MSG);
	strcat(buf, argv[1]);
",unused,e2fsprogartful-lib2Fss2Fhelp.c
"    }
    info->info_dirs = dirs;
    dirs[n_dirs + 1] = (char *)NULL;
    dirs[n_dirs] = malloc((unsigned)strlen(info_dir)+1);
    strcpy(dirs[n_dirs], info_dir);
",1,unused,158,unused,"    }
    info->info_dirs = dirs;
    dirs[n_dirs + 1] = (char *)NULL;
    dirs[n_dirs] = malloc((unsigned)strlen(info_dir)+1);
    strcpy(dirs[n_dirs], info_dir);
",unused,e2fsprogartful-lib2Fss2Fhelp.c
"	new_table->info_dirs = (char **)malloc(sizeof(char *));
	*new_table->info_dirs = (char *)NULL;
	new_table->info_ptr = info_ptr;
	new_table->prompt = malloc((unsigned)strlen(subsystem_name)+4);
	strcpy(new_table->prompt, subsystem_name);
",1,unused,63,unused,"	new_table->info_dirs = (char **)malloc(sizeof(char *));
	*new_table->info_dirs = (char *)NULL;
	new_table->info_ptr = info_ptr;
	new_table->prompt = malloc((unsigned)strlen(subsystem_name)+4);
	strcpy(new_table->prompt, subsystem_name);
",unused,e2fsprogartful-lib2Fss2Finvocation.c
"	*new_table->info_dirs = (char *)NULL;
	new_table->info_ptr = info_ptr;
	new_table->prompt = malloc((unsigned)strlen(subsystem_name)+4);
	strcpy(new_table->prompt, subsystem_name);
	strcat(new_table->prompt, "":  "");
",1,unused,64,unused,"	*new_table->info_dirs = (char *)NULL;
	new_table->info_ptr = info_ptr;
	new_table->prompt = malloc((unsigned)strlen(subsystem_name)+4);
	strcpy(new_table->prompt, subsystem_name);
	strcat(new_table->prompt, "":  "");
",unused,e2fsprogartful-lib2Fss2Finvocation.c
"		}
		if (strncmp(*name, text, len) == 0) {
			ret = malloc(strlen(*name)+1);
			if (ret)
				strcpy(ret, *name);
",1,unused,181,unused,"		}
		if (strncmp(*name, text, len) == 0) {
			ret = malloc(strlen(*name)+1);
			if (ret)
				strcpy(ret, *name);
",unused,e2fsprogartful-lib2Fss2Flisten.c
"		fprintf(stderr,
			""Couldn't allocate memory to parse quota options!\n"");
		return -ENOMEM;
	}
	strcpy(buf, opts);
",1,unused,692,unused,"		fprintf(stderr,
			""Couldn't allocate memory to parse quota options!\n"");
		return -ENOMEM;
	}
	strcpy(buf, opts);
",unused,e2fsprogartful-lib2Fsupport2Fmkquota.c
"	len = strlen(in_str);
	buf = malloc(len + 1);
	if (!buf)
		return ENOMEM;
	strcpy(buf, in_str);
",1,unused,31,unused,"	len = strlen(in_str);
	buf = malloc(len + 1);
	if (!buf)
		return ENOMEM;
	strcpy(buf, in_str);
",unused,e2fsprogartful-lib2Fsupport2Fparse_qtype.c
"		} else {
			if (err_token) {
				*err_token = malloc(strlen(token) + 1);
				if (*err_token)
					strcpy(*err_token, token);
",1,unused,61,unused,"		} else {
			if (err_token) {
				*err_token = malloc(strlen(token) + 1);
				if (*err_token)
					strcpy(*err_token, token);
",unused,e2fsprogartful-lib2Fsupport2Fparse_qtype.c
"	if ((s = socket(AF_UNIX, SOCK_STREAM, 0)) < 0)
		return -1;

	srv_addr.sun_family = AF_UNIX;
	strcpy(srv_addr.sun_path, UUIDD_SOCKET_PATH);
",1,unused,510,unused,"	if ((s = socket(AF_UNIX, SOCK_STREAM, 0)) < 0)
		return -1;

	srv_addr.sun_family = AF_UNIX;
	strcpy(srv_addr.sun_path, UUIDD_SOCKET_PATH);
",unused,e2fsprogartful-lib2Fuuid2Fgen_uuid.c
"{
	struct uuid uuid;

	uuid_unpack(uu, &uuid);
	sprintf(out, fmt,
",1,unused,57,unused,"{
	struct uuid uuid;

	uuid_unpack(uu, &uuid);
	sprintf(out, fmt,
",unused,e2fsprogartful-lib2Fuuid2Funparse.c
"	min = diff % 60;
	hr = diff / 60;

	if (hr)
		sprintf(buf, ""%d:%02d:%02d"", hr, min, sec);
",1,unused,200,unused,"	min = diff % 60;
	hr = diff / 60;

	if (hr)
		sprintf(buf, ""%d:%02d:%02d"", hr, min, sec);
",unused,e2fsprogartful-misc2Fbadblocks.c
"
	if (hr)
		sprintf(buf, ""%d:%02d:%02d"", hr, min, sec);
	else
		sprintf(buf, ""%d:%02d"", min, sec);
",1,unused,202,unused,"
	if (hr)
		sprintf(buf, ""%d:%02d:%02d"", hr, min, sec);
	else
		sprintf(buf, ""%d:%02d"", min, sec);
",unused,e2fsprogartful-misc2Fbadblocks.c
"
	str = malloc(strlen(device)+1);
	if (!str)
		return NULL;
	strcpy(str, device);
",1,unused,51,unused,"
	str = malloc(strlen(device)+1);
	if (!str)
		return NULL;
	strcpy(str, device);
",unused,e2fsprogartful-misc2Fbase_device.c
"				_(""Couldn't allocate path variable ""
				  ""in chattr_dir_proc""));
			return -1;
		}
		sprintf(path, ""%s/%s"", dir_name, de->d_name);
",1,unused,301,unused,"				_(""Couldn't allocate path variable ""
				  ""in chattr_dir_proc""));
			return -1;
		}
		sprintf(path, ""%s/%s"", dir_name, de->d_name);
",unused,e2fsprogartful-misc2Fchattr.c
"		fprintf(stderr, ""%s"",
			_(""Couldn't allocate memory to parse options!\n""));
		exit(1);
	}
	strcpy(buf, opts);
",1,unused,437,unused,"		fprintf(stderr, ""%s"",
			_(""Couldn't allocate memory to parse options!\n""));
		exit(1);
	}
	strcpy(buf, opts);
",unused,e2fsprogartful-misc2Fdumpe2fs.c
"	if (!s)
		return 0;
	ret = malloc(strlen(s)+1);
	if (ret)
		strcpy(ret, s);
",1,unused,165,unused,"	if (!s)
		return 0;
	ret = malloc(strlen(s)+1);
	if (ret)
		strcpy(ret, s);
",unused,e2fsprogartful-misc2Fe2initrd_helper.c
"	if (!tdb_file) {
		free(tmp_name);
		goto errout;
	}
	sprintf(tdb_file, ""%s/e2undo-%s.e2undo"", tdb_dir, dev_name);
",1,unused,258,unused,"	if (!tdb_file) {
		free(tmp_name);
		goto errout;
	}
	sprintf(tdb_file, ""%s/e2undo-%s.e2undo"", tdb_dir, dev_name);
",unused,e2fsprogartful-misc2Fe2undo.c
"	ext2fs_sha512(salt->key, EXT4_MAX_KEY_SIZE, key_ref1);
	ext2fs_sha512(key_ref1, SHA512_LENGTH, key_ref2);
	memcpy(salt->key_desc, key_ref2, EXT4_KEY_DESCRIPTOR_SIZE);
	for (x = 0; x < EXT4_KEY_DESCRIPTOR_SIZE; ++x) {
		sprintf(&salt->key_ref_str[x * 2], ""%02x"",
",1,unused,540,unused,"	ext2fs_sha512(salt->key, EXT4_MAX_KEY_SIZE, key_ref1);
	ext2fs_sha512(key_ref1, SHA512_LENGTH, key_ref2);
	memcpy(salt->key_desc, key_ref2, EXT4_KEY_DESCRIPTOR_SIZE);
	for (x = 0; x < EXT4_KEY_DESCRIPTOR_SIZE; ++x) {
		sprintf(&salt->key_ref_str[x * 2], ""%02x"",
",unused,e2fsprogartful-misc2Fe4crypt.c
"	if (keyring_id == 0) {
		printf(""Invalid keyring [%s].\n"", keyring);
		exit(1);
	}
	sprintf(key_ref_full, ""%s%s"", EXT2FS_KEY_DESC_PREFIX,
",1,unused,558,unused,"	if (keyring_id == 0) {
		printf(""Invalid keyring [%s].\n"", keyring);
		exit(1);
	}
	sprintf(key_ref_full, ""%s%s"", EXT2FS_KEY_DESC_PREFIX,
",unused,e2fsprogartful-misc2Fe4crypt.c
"		       argv[optind], (EXT4_KEY_DESCRIPTOR_SIZE * 2));
			exit(1);
	}
	validate_paths(argc, argv, optind+1);
	strcpy(saltbuf.key_ref_str, argv[optind]);
",1,unused,748,unused,"		       argv[optind], (EXT4_KEY_DESCRIPTOR_SIZE * 2));
			exit(1);
	}
	validate_paths(argc, argv, optind+1);
	strcpy(saltbuf.key_ref_str, argv[optind]);
",unused,e2fsprogartful-misc2Fe4crypt.c
"	}

	if (mode_flag & DETAIL) {
		/* Print statistic info */
		sprintf(msg_buffer, ""[%u/%u]%s"",
",1,unused,1213,unused,"	}

	if (mode_flag & DETAIL) {
		/* Print statistic info */
		sprintf(msg_buffer, ""[%u/%u]%s"",
",unused,e2fsprogartful-misc2Fe4defrag.c
"	}

	/* Create donor inode */
	memset(tmp_inode_name, 0, PATH_MAX + 8);
	sprintf(tmp_inode_name, ""%.*s.defrag"",
",1,unused,1531,unused,"	}

	/* Create donor inode */
	memset(tmp_inode_name, 0, PATH_MAX + 8);
	sprintf(tmp_inode_name, ""%.*s.defrag"",
",unused,e2fsprogartful-misc2Fe4defrag.c
"{
	if ((*flags & mask) == 0)
		return;

	strcat(buf, name);
",1,unused,134,unused,"{
	if ((*flags & mask) == 0)
		return;

	strcat(buf, name);
",unused,e2fsprogartful-misc2Ffilefrag.c
"		physical_blk = fm_extent->fe_physical >> blk_shift;
	}

	if (expected)
		sprintf(flags, ext_fmt == hex_fmt ? ""%*llx: "" : ""%*llu: "",
",1,unused,163,unused,"		physical_blk = fm_extent->fe_physical >> blk_shift;
	}

	if (expected)
		sprintf(flags, ext_fmt == hex_fmt ? ""%*llx: "" : ""%*llu: "",
",unused,e2fsprogartful-misc2Ffilefrag.c
"	if (expected)
		sprintf(flags, ext_fmt == hex_fmt ? ""%*llx: "" : ""%*llu: "",
			physical_width, expected >> blk_shift);
	else
		sprintf(flags, ""%.*s  "", physical_width, ""                   "");
",1,unused,166,unused,"	if (expected)
		sprintf(flags, ext_fmt == hex_fmt ? ""%*llx: "" : ""%*llu: "",
			physical_width, expected >> blk_shift);
	else
		sprintf(flags, ""%.*s  "", physical_width, ""                   "");
",unused,e2fsprogartful-misc2Ffilefrag.c
"		char hex[6];

		if ((fe_flags & mask) == 0)
			continue;
		sprintf(hex, ""%#04x,"", mask);
",1,unused,186,unused,"		char hex[6];

		if ((fe_flags & mask) == 0)
			continue;
		sprintf(hex, ""%#04x,"", mask);
",unused,e2fsprogartful-misc2Ffilefrag.c
"	}

	if (fm_extent->fe_logical + fm_extent->fe_length >=
	    (unsigned long long) st->st_size)
		strcat(flags, ""eof,"");
",1,unused,192,unused,"	}

	if (fm_extent->fe_logical + fm_extent->fe_length >=
	    (unsigned long long) st->st_size)
		strcat(flags, ""eof,"");
",unused,e2fsprogartful-misc2Ffilefrag.c
"	if (!s)
		return 0;
	ret = malloc(strlen(s)+1);
	if (ret)
		strcpy(ret, s);
",1,unused,135,unused,"	if (!s)
		return 0;
	ret = malloc(strlen(s)+1);
	if (ret)
		strcpy(ret, s);
",unused,e2fsprogartful-misc2Ffsck.c
"  /* Are we looking for a program or just a type? */
  tpl = (strncmp(type, ""fsck."", 5) ? ""%s/fsck.%s"" : ""%s/%s"");

  for(s = strtok(p, "":""); s; s = strtok(NULL, "":"")) {
	sprintf(prog, tpl, s, type);
",1,unused,411,unused,"  /* Are we looking for a program or just a type? */
  tpl = (strncmp(type, ""fsck."", 5) ? ""%s/fsck.%s"" : ""%s/%s"");

  for(s = strtok(p, "":""); s; s = strtok(NULL, "":"")) {
	sprintf(prog, tpl, s, type);
",unused,e2fsprogartful-misc2Ffsck.c
"	if (!inst)
		return ENOMEM;
	memset(inst, 0, sizeof(struct fsck_instance));

	sprintf(prog, ""fsck.%s"", type);
",1,unused,448,unused,"	if (!inst)
		return ENOMEM;
	memset(inst, 0, sizeof(struct fsck_instance));

	sprintf(prog, ""fsck.%s"", type);
",unused,e2fsprogartful-misc2Ffsck.c
"		if (!fsck_path) {
			fprintf(stderr, ""%s: Unable to allocate memory for fsck_path\n"", progname);
			exit(EXIT_ERROR);
		}
		strcpy (fsck_path, fsck_prefix_path);
",1,unused,1289,unused,"		if (!fsck_path) {
			fprintf(stderr, ""%s: Unable to allocate memory for fsck_path\n"", progname);
			exit(EXIT_ERROR);
		}
		strcpy (fsck_path, fsck_prefix_path);
",unused,e2fsprogartful-misc2Ffsck.c
"			fprintf(stderr, ""%s: Unable to allocate memory for fsck_path\n"", progname);
			exit(EXIT_ERROR);
		}
		strcpy (fsck_path, fsck_prefix_path);
		strcat (fsck_path, "":"");
",1,unused,1290,unused,"			fprintf(stderr, ""%s: Unable to allocate memory for fsck_path\n"", progname);
			exit(EXIT_ERROR);
		}
		strcpy (fsck_path, fsck_prefix_path);
		strcat (fsck_path, "":"");
",unused,e2fsprogartful-misc2Ffsck.c
"			exit(EXIT_ERROR);
		}
		strcpy (fsck_path, fsck_prefix_path);
		strcat (fsck_path, "":"");
		strcat (fsck_path, oldpath);
",1,unused,1291,unused,"			exit(EXIT_ERROR);
		}
		strcpy (fsck_path, fsck_prefix_path);
		strcat (fsck_path, "":"");
		strcat (fsck_path, oldpath);
",unused,e2fsprogartful-misc2Ffsck.c
"	if ( WIFEXITED(status) ) {
		rc = WEXITSTATUS(status);
		if (rc) {
			send_output(argv[0], 0, SEND_BOTH);
			sprintf(buffer, "" exited with status code %d\n"", rc);
",1,unused,213,unused,"	if ( WIFEXITED(status) ) {
		rc = WEXITSTATUS(status);
		if (rc) {
			send_output(argv[0], 0, SEND_BOTH);
			sprintf(buffer, "" exited with status code %d\n"", rc);
",unused,e2fsprogartful-misc2Flogsave.c
"		}
	} else {
		if (WIFSIGNALED(status)) {
			send_output(argv[0], 0, SEND_BOTH);
			sprintf(buffer, ""died with signal %d\n"",
",1,unused,219,unused,"		}
	} else {
		if (WIFSIGNALED(status)) {
			send_output(argv[0], 0, SEND_BOTH);
			sprintf(buffer, ""died with signal %d\n"",
",unused,e2fsprogartful-misc2Flogsave.c
"
	path = malloc(dir_len + strlen (de->d_name) + 2);

	if (dir_len && dir_name[dir_len-1] == '/')
		sprintf (path, ""%s%s"", dir_name, de->d_name);
",1,unused,149,unused,"
	path = malloc(dir_len + strlen (de->d_name) + 2);

	if (dir_len && dir_name[dir_len-1] == '/')
		sprintf (path, ""%s%s"", dir_name, de->d_name);
",unused,e2fsprogartful-misc2Flsattr.c
"
	if (dir_len && dir_name[dir_len-1] == '/')
		sprintf (path, ""%s%s"", dir_name, de->d_name);
	else
		sprintf (path, ""%s/%s"", dir_name, de->d_name);
",1,unused,151,unused,"
	if (dir_len && dir_name[dir_len-1] == '/')
		sprintf (path, ""%s%s"", dir_name, de->d_name);
	else
		sprintf (path, ""%s/%s"", dir_name, de->d_name);
",unused,e2fsprogartful-misc2Flsattr.c
"	if (!cp)
		return 0;
	if (strlen(path) > SYSFS_PATH_LEN - sizeof(""/start""))
		return 0;
	strcat(path, ""/start"");
",1,unused,197,unused,"	if (!cp)
		return 0;
	if (strlen(path) > SYSFS_PATH_LEN - sizeof(""/start""))
		return 0;
	strcat(path, ""/start"");
",unused,e2fsprogartful-misc2Fmk_hugefiles.c
"	fn = malloc(strlen(dir) + 1);
	if (fn == NULL)
		return ENOMEM;

	strcpy(fn, dir);
",1,unused,220,unused,"	fn = malloc(strlen(dir) + 1);
	if (fn == NULL)
		return ENOMEM;

	strcpy(fn, dir);
",unused,e2fsprogartful-misc2Fmk_hugefiles.c
"	if (retval)
		goto errout;

	if (idx_digits)
		sprintf(fn_numbuf, ""%0*lu"", idx_digits, idx);
",1,unused,381,unused,"	if (retval)
		goto errout;

	if (idx_digits)
		sprintf(fn_numbuf, ""%0*lu"", idx_digits, idx);
",unused,e2fsprogartful-misc2Fmk_hugefiles.c
"
	if (idx_digits)
		sprintf(fn_numbuf, ""%0*lu"", idx_digits, idx);
	else if (num_files > 1)
		sprintf(fn_numbuf, ""%lu"", idx);
",1,unused,383,unused,"
	if (idx_digits)
		sprintf(fn_numbuf, ""%0*lu"", idx_digits, idx);
	else if (num_files > 1)
		sprintf(fn_numbuf, ""%lu"", idx);
",unused,e2fsprogartful-misc2Fmk_hugefiles.c
"	if (!fn_buf) {
		free(fn_prefix);
		return ENOMEM;
	}
	strcpy(fn_buf, fn_prefix);
",1,unused,541,unused,"	if (!fn_buf) {
		free(fn_prefix);
		return ENOMEM;
	}
	strcpy(fn_buf, fn_prefix);
",unused,e2fsprogartful-misc2Fmk_hugefiles.c
"	FILE		*f;
	errcode_t	retval;
	char		buf[1024];

	sprintf(buf, ""badblocks -b %d -X %s%s%s %llu"", fs->blocksize,
",1,unused,251,unused,"	FILE		*f;
	errcode_t	retval;
	char		buf[1024];

	sprintf(buf, ""badblocks -b %d -X %s%s%s %llu"", fs->blocksize,
",unused,e2fsprogartful-misc2Fmke2fs.c
"		fprintf(stderr, ""%s"",
			_(""Couldn't allocate memory to parse options!\n""));
		exit(1);
	}
	strcpy(buf, opts);
",1,unused,789,unused,"		fprintf(stderr, ""%s"",
			_(""Couldn't allocate memory to parse options!\n""));
		exit(1);
	}
	strcpy(buf, opts);
",unused,e2fsprogartful-misc2Fmke2fs.c
"	}
	sl->list[sl->num] = malloc(strlen(str)+1);
	if (sl->list[sl->num] == 0)
		return ENOMEM;
	strcpy(sl->list[sl->num], str);
",1,unused,1164,unused,"	}
	sl->list[sl->num] = malloc(strlen(str)+1);
	if (sl->list[sl->num] == 0)
		return ENOMEM;
	strcpy(sl->list[sl->num], str);
",unused,e2fsprogartful-misc2Fmke2fs.c
"		free(profile_type);
		free(list.list);
		return 0;
	}
	strcpy(parse_str, usage_types);
",1,unused,1297,unused,"		free(profile_type);
		free(list.list);
		return 0;
	}
	strcpy(parse_str, usage_types);
",unused,e2fsprogartful-misc2Fmke2fs.c
"		fprintf(stderr, ""%s"",
			_(""Couldn't allocate memory for new PATH.\n""));
		exit(1);
	}
	strcpy(newpath, PATH_SET);
",1,unused,1497,unused,"		fprintf(stderr, ""%s"",
			_(""Couldn't allocate memory for new PATH.\n""));
		exit(1);
	}
	strcpy(newpath, PATH_SET);
",unused,e2fsprogartful-misc2Fmke2fs.c
"	strcpy(newpath, PATH_SET);

	/* Update our PATH to include /sbin  */
	if (oldpath) {
		strcat (newpath, "":"");
",1,unused,1501,unused,"	strcpy(newpath, PATH_SET);

	/* Update our PATH to include /sbin  */
	if (oldpath) {
		strcat (newpath, "":"");
",unused,e2fsprogartful-misc2Fmke2fs.c
"
	/* Update our PATH to include /sbin  */
	if (oldpath) {
		strcat (newpath, "":"");
		strcat (newpath, oldpath);
",1,unused,1502,unused,"
	/* Update our PATH to include /sbin  */
	if (oldpath) {
		strcat (newpath, "":"");
		strcat (newpath, oldpath);
",unused,e2fsprogartful-misc2Fmke2fs.c
"				com_err(program_name, ENOMEM, ""%s"",
					_(""in malloc for bad_blocks_filename""));
				exit(1);
			}
			strcpy(bad_blocks_filename, optarg);
",1,unused,1698,unused,"				com_err(program_name, ENOMEM, ""%s"",
					_(""in malloc for bad_blocks_filename""));
				exit(1);
			}
			strcpy(bad_blocks_filename, optarg);
",unused,e2fsprogartful-misc2Fmke2fs.c
"				     _(""while allocating fs_feature string""));
				exit(1);
			}
			if (fs_features_size)
				strcat(fs_features, "","");
",1,unused,1745,unused,"				     _(""while allocating fs_feature string""));
				exit(1);
			}
			if (fs_features_size)
				strcat(fs_features, "","");
",unused,e2fsprogartful-misc2Fmke2fs.c
"			if (fs_features_size)
				strcat(fs_features, "","");
			else
				fs_features[0] = 0;
			strcat(fs_features, optarg);
",1,unused,1748,unused,"			if (fs_features_size)
				strcat(fs_features, "","");
			else
				fs_features[0] = 0;
			strcat(fs_features, optarg);
",unused,e2fsprogartful-misc2Fmke2fs.c
"	if (!tdb_file) {
		free(tmp_name);
		goto errout;
	}
	sprintf(tdb_file, ""%s/mke2fs-%s.e2undo"", tdb_dir, dev_name);
",1,unused,2594,unused,"	if (!tdb_file) {
		free(tmp_name);
		goto errout;
	}
	sprintf(tdb_file, ""%s/mke2fs-%s.e2undo"", tdb_dir, dev_name);
",unused,e2fsprogartful-misc2Fmke2fs.c
"	if (!journal_device && ((journal_size) ||
	    ext2fs_has_feature_journal(&fs_param)))
		journal_blocks = figure_journal_size(journal_size, fs);

	sprintf(opt_string, ""tdb_data_size=%d"", fs->blocksize <= 4096 ?
",1,unused,2874,unused,"	if (!journal_device && ((journal_size) ||
	    ext2fs_has_feature_journal(&fs_param)))
		journal_blocks = figure_journal_size(journal_size, fs);

	sprintf(opt_string, ""tdb_data_size=%d"", fs->blocksize <= 4096 ?
",unused,e2fsprogartful-misc2Fmke2fs.c
"	sprintf(opt_string, ""tdb_data_size=%d"", fs->blocksize <= 4096 ?
		32768 : fs->blocksize * 8);
	io_channel_set_options(fs->io, opt_string);
	if (offset) {
		sprintf(opt_string, ""offset=%llu"", offset);
",1,unused,2878,unused,"	sprintf(opt_string, ""tdb_data_size=%d"", fs->blocksize <= 4096 ?
		32768 : fs->blocksize * 8);
	io_channel_set_options(fs->io, opt_string);
	if (offset) {
		sprintf(opt_string, ""offset=%llu"", offset);
",unused,e2fsprogartful-misc2Fmke2fs.c
"
	i = 0;
	memset (name, 'x', 246);
	do {
		sprintf (name + 246, ""%08d"", i);
",1,unused,61,unused,"
	i = 0;
	memset (name, 'x', 246);
	do {
		sprintf (name + 246, ""%08d"", i);
",unused,e2fsprogartful-misc2Fmklost+found.c
"	i = 0;
	memset (name, 'x', 246);
	do {
		sprintf (name + 246, ""%08d"", i);
		strcpy (path, LPF);
",1,unused,62,unused,"	i = 0;
	memset (name, 'x', 246);
	do {
		sprintf (name + 246, ""%08d"", i);
		strcpy (path, LPF);
",unused,e2fsprogartful-misc2Fmklost+found.c
"	memset (name, 'x', 246);
	do {
		sprintf (name + 246, ""%08d"", i);
		strcpy (path, LPF);
		strcat (path, ""/"");
",1,unused,63,unused,"	memset (name, 'x', 246);
	do {
		sprintf (name + 246, ""%08d"", i);
		strcpy (path, LPF);
		strcat (path, ""/"");
",unused,e2fsprogartful-misc2Fmklost+found.c
"	do {
		sprintf (name + 246, ""%08d"", i);
		strcpy (path, LPF);
		strcat (path, ""/"");
		strcat (path, name);
",1,unused,64,unused,"	do {
		sprintf (name + 246, ""%08d"", i);
		strcpy (path, LPF);
		strcat (path, ""/"");
		strcat (path, name);
",unused,e2fsprogartful-misc2Fmklost+found.c
"			exit (1);
		}
	} while (st.st_size <= (EXT2_NDIR_BLOCKS - 1) * st.st_blksize);
	for (j = 0; j < i; j++) {
		sprintf (name + 246, ""%08d"", j);
",1,unused,77,unused,"			exit (1);
		}
	} while (st.st_size <= (EXT2_NDIR_BLOCKS - 1) * st.st_blksize);
	for (j = 0; j < i; j++) {
		sprintf (name + 246, ""%08d"", j);
",unused,e2fsprogartful-misc2Fmklost+found.c
"		}
	} while (st.st_size <= (EXT2_NDIR_BLOCKS - 1) * st.st_blksize);
	for (j = 0; j < i; j++) {
		sprintf (name + 246, ""%08d"", j);
		strcpy (path, LPF);
",1,unused,78,unused,"		}
	} while (st.st_size <= (EXT2_NDIR_BLOCKS - 1) * st.st_blksize);
	for (j = 0; j < i; j++) {
		sprintf (name + 246, ""%08d"", j);
		strcpy (path, LPF);
",unused,e2fsprogartful-misc2Fmklost+found.c
"	} while (st.st_size <= (EXT2_NDIR_BLOCKS - 1) * st.st_blksize);
	for (j = 0; j < i; j++) {
		sprintf (name + 246, ""%08d"", j);
		strcpy (path, LPF);
		strcat (path, ""/"");
",1,unused,79,unused,"	} while (st.st_size <= (EXT2_NDIR_BLOCKS - 1) * st.st_blksize);
	for (j = 0; j < i; j++) {
		sprintf (name + 246, ""%08d"", j);
		strcpy (path, LPF);
		strcat (path, ""/"");
",unused,e2fsprogartful-misc2Fmklost+found.c
"	for (j = 0; j < i; j++) {
		sprintf (name + 246, ""%08d"", j);
		strcpy (path, LPF);
		strcat (path, ""/"");
		strcat (path, name);
",1,unused,80,unused,"	for (j = 0; j < i; j++) {
		sprintf (name + 246, ""%08d"", j);
		strcpy (path, LPF);
		strcat (path, ""/"");
		strcat (path, name);
",unused,e2fsprogartful-misc2Fmklost+found.c
"		fprintf(stderr, ""%s"",
			_(""Couldn't allocate memory to parse options!\n""));
		return 1;
	}
	strcpy(buf, opts);
",1,unused,1950,unused,"		fprintf(stderr, ""%s"",
			_(""Couldn't allocate memory to parse options!\n""));
		return 1;
	}
	strcpy(buf, opts);
",unused,e2fsprogartful-misc2Ftune2fs.c
"	if (!tdb_file) {
		free(tmp_name);
		goto errout;
	}
	sprintf(tdb_file, ""%s/tune2fs-%s.e2undo"", tdb_dir, dev_name);
",1,unused,2655,unused,"	if (!tdb_file) {
		free(tmp_name);
		goto errout;
	}
	sprintf(tdb_file, ""%s/tune2fs-%s.e2undo"", tdb_dir, dev_name);
",unused,e2fsprogartful-misc2Ftune2fs.c
"		fputs(_(""Couldn't allocate memory to parse journal ""
			""options!\n""), stderr);
		exit(1);
	}
	strcpy(buf, opts);
",1,unused,165,unused,"		fputs(_(""Couldn't allocate memory to parse journal ""
			""options!\n""), stderr);
		exit(1);
	}
	strcpy(buf, opts);
",unused,e2fsprogartful-misc2Futil.c
"	signal(SIGTERM, terminate_intr);
	signal(SIGALRM, terminate_intr);
	signal(SIGPIPE, SIG_IGN);

	sprintf(reply_buf, ""%8d\n"", getpid());
",1,unused,331,unused,"	signal(SIGTERM, terminate_intr);
	signal(SIGALRM, terminate_intr);
	signal(SIGPIPE, SIG_IGN);

	sprintf(reply_buf, ""%8d\n"", getpid());
",unused,e2fsprogartful-misc2Fuuidd.c
"			printf(""operation %d\n"", op);

		switch(op) {
		case UUIDD_OP_GETPID:
			sprintf(reply_buf, ""%d"", getpid());
",1,unused,369,unused,"			printf(""operation %d\n"", op);

		switch(op) {
		case UUIDD_OP_GETPID:
			sprintf(reply_buf, ""%d"", getpid());
",unused,e2fsprogartful-misc2Fuuidd.c
"			sprintf(reply_buf, ""%d"", getpid());
			reply_len = strlen(reply_buf)+1;
			break;
		case UUIDD_OP_GET_MAXOP:
			sprintf(reply_buf, ""%d"", UUIDD_MAX_OP);
",1,unused,373,unused,"			sprintf(reply_buf, ""%d"", getpid());
			reply_len = strlen(reply_buf)+1;
			break;
		case UUIDD_OP_GET_MAXOP:
			sprintf(reply_buf, ""%d"", UUIDD_MAX_OP);
",unused,e2fsprogartful-misc2Fuuidd.c
"	if (!tdb_file) {
		free(tmp_name);
		goto errout;
	}
	sprintf(tdb_file, ""%s/resize2fs-%s.e2undo"", tdb_dir, dev_name);
",1,unused,215,unused,"	if (!tdb_file) {
		free(tmp_name);
		goto errout;
	}
	sprintf(tdb_file, ""%s/resize2fs-%s.e2undo"", tdb_dir, dev_name);
",unused,e2fsprogartful-resize2Fmain.c
"	if (retval) {
		free(prog);
		return retval;
	}
	strcpy(prog->label, label);
",1,unused,96,unused,"	if (retval) {
		free(prog);
		return retval;
	}
	strcpy(prog->label, label);
",unused,e2fsprogartful-resize2Fsim_progress.c
"		goto fail;
	ent->value = (char *) malloc(strlen(value)+1);
	if (!ent->value)
		goto fail;
	strcpy(ent->name, name);
",1,unused,64,unused,"		goto fail;
	ent->value = (char *) malloc(strlen(value)+1);
	if (!ent->value)
		goto fail;
	strcpy(ent->name, name);
",unused,e2fsprogartful-util2Fsubst.c
"	ent->value = (char *) malloc(strlen(value)+1);
	if (!ent->value)
		goto fail;
	strcpy(ent->name, name);
	strcpy(ent->value, value);
",1,unused,65,unused,"	ent->value = (char *) malloc(strlen(value)+1);
	if (!ent->value)
		goto fail;
	strcpy(ent->name, name);
	strcpy(ent->value, value);
",unused,e2fsprogartful-util2Fsubst.c
"		if (!newfn) {
			fprintf(stderr, ""Memory error!  Exiting.\n"");
			exit(1);
		}
		strcpy(newfn, outfn);
",1,unused,375,unused,"		if (!newfn) {
			fprintf(stderr, ""Memory error!  Exiting.\n"");
			exit(1);
		}
		strcpy(newfn, outfn);
",unused,e2fsprogartful-util2Fsubst.c
"			fprintf(stderr, ""Memory error!  Exiting.\n"");
			exit(1);
		}
		strcpy(newfn, outfn);
		strcat(newfn, "".new"");
",1,unused,376,unused,"			fprintf(stderr, ""Memory error!  Exiting.\n"");
			exit(1);
		}
		strcpy(newfn, outfn);
		strcat(newfn, "".new"");
",unused,e2fsprogartful-util2Fsubst.c
"	if (!tdb_file) {
		free(tmp_name);
		goto errout;
	}
	sprintf(tdb_file, ""%s/debugfs-%s.e2undo"", tdb_dir, dev_name);
",1,unused,100,unused,"	if (!tdb_file) {
		free(tmp_name);
		goto errout;
	}
	sprintf(tdb_file, ""%s/debugfs-%s.e2undo"", tdb_dir, dev_name);
",unused,e2fsprogdebstretche-debugfs2Fdebugfs.c
"	char buf[200];
	unsigned long v;
	char *tmp;

	sprintf(buf, format, *val);
",1,unused,1250,unused,"	char buf[200];
	unsigned long v;
	char *tmp;

	sprintf(buf, format, *val);
",unused,e2fsprogdebstretche-debugfs2Fdebugfs.c
"	char buf[200];
	unsigned long v;
	char *tmp;

	sprintf(buf, format, *val);
",1,unused,1272,unused,"	char buf[200];
	unsigned long v;
	char *tmp;

	sprintf(buf, format, *val);
",unused,e2fsprogdebstretche-debugfs2Fdebugfs.c
"	char buf[200];
	unsigned long v;
	char *tmp;

	sprintf(buf, format, *val);
",1,unused,1294,unused,"	char buf[200];
	unsigned long v;
	char *tmp;

	sprintf(buf, format, *val);
",unused,e2fsprogdebstretche-debugfs2Fdebugfs.c
"	if (fsize)
		modify_u8(argv[0], ""Fragment size"", decimal_format, fsize);

	for (i=0;  i < EXT2_NDIR_BLOCKS; i++) {
		sprintf(buf, ""Direct Block #%d"", i);
",1,unused,1374,unused,"	if (fsize)
		modify_u8(argv[0], ""Fragment size"", decimal_format, fsize);

	for (i=0;  i < EXT2_NDIR_BLOCKS; i++) {
		sprintf(buf, ""Direct Block #%d"", i);
",unused,e2fsprogdebstretche-debugfs2Fdebugfs.c
"
	/* Apparently, this is the right way to detect and handle fast
	 * symlinks; see do_stat() in debugfs.c. */
	if (ext2fs_inode_data_blocks2(current_fs, inode) == 0)
		strcpy(buf, (char *) inode->i_block);
",1,unused,214,unused,"
	/* Apparently, this is the right way to detect and handle fast
	 * symlinks; see do_stat() in debugfs.c. */
	if (ext2fs_inode_data_blocks2(current_fs, inode) == 0)
		strcpy(buf, (char *) inode->i_block);
",unused,e2fsprogdebstretche-debugfs2Fdump.c
"	if (!fullname) {
		com_err(""rdump"", errno, ""while allocating memory"");
		return;
	}
	sprintf(fullname, ""%s/%s"", dumproot, name);
",1,unused,264,unused,"	if (!fullname) {
		com_err(""rdump"", errno, ""while allocating memory"");
		return;
	}
	sprintf(fullname, ""%s/%s"", dumproot, name);
",unused,e2fsprogdebstretche-debugfs2Fdump.c
"		com_err(argv[1], retval, ""out of memory"");
		return;
	}

	strcpy(extent_prompt, orig_prompt);
",1,unused,105,unused,"		com_err(argv[1], retval, ""out of memory"");
		return;
	}

	strcpy(extent_prompt, orig_prompt);
",unused,e2fsprogdebstretche-debugfs2Fextent_inode.c
"	strcpy(extent_prompt, orig_prompt);
	cp = strchr(extent_prompt, ':');
	if (cp)
		*cp = 0;
	sprintf(extent_prompt + strlen(extent_prompt), "" (extent ino %d): "",
",1,unused,109,unused,"	strcpy(extent_prompt, orig_prompt);
	cp = strchr(extent_prompt, ':');
	if (cp)
		*cp = 0;
	sprintf(extent_prompt + strlen(extent_prompt), "" (extent ino %d): "",
",unused,e2fsprogdebstretche-debugfs2Fextent_inode.c
"			fs->dir_name, name);
		return 0;
	}

	sprintf(cp, ""%s/%s"", fs->dir_name, name);
",1,unused,202,unused,"			fs->dir_name, name);
		return 0;
	}

	sprintf(cp, ""%s/%s"", fs->dir_name, name);
",unused,e2fsprogdebstretche-debugfs2Ffilefrag.c
"			if (debugfs_read_inode(ino, &inode, ""ls""))
				return 0;
			modtime = inode.i_mtime;
			tm_p = localtime(&modtime);
			sprintf(datestr, ""%2d-%s-%4d %02d:%02d"",
",1,unused,138,unused,"			if (debugfs_read_inode(ino, &inode, ""ls""))
				return 0;
			modtime = inode.i_mtime;
			tm_p = localtime(&modtime);
			sprintf(datestr, ""%2d-%s-%4d %02d:%02d"",
",unused,e2fsprogdebstretche-debugfs2Fls.c
"				tm_p->tm_mday, monstr[tm_p->tm_mon],
				1900 + tm_p->tm_year, tm_p->tm_hour,
				tm_p->tm_min);
		} else {
			strcpy(datestr, ""                 "");
",1,unused,143,unused,"				tm_p->tm_mday, monstr[tm_p->tm_mon],
				1900 + tm_p->tm_year, tm_p->tm_hour,
				tm_p->tm_min);
		} else {
			strcpy(datestr, ""                 "");
",unused,e2fsprogdebstretche-debugfs2Fls.c
"		print_filename(ls->f, dirent, options);
		fputc('\n', ls->f);
	} else {
		if (entry == DIRENT_CHECKSUM) {
			sprintf(tmp, ""%c%u%c (dirblock checksum: 0x%08x)   "",
",1,unused,165,unused,"		print_filename(ls->f, dirent, options);
		fputc('\n', ls->f);
	} else {
		if (entry == DIRENT_CHECKSUM) {
			sprintf(tmp, ""%c%u%c (dirblock checksum: 0x%08x)   "",
",unused,e2fsprogdebstretche-debugfs2Fls.c
"			fprintf(ls->f, ""%s"", tmp);
			ls->col += thislen;
			return 0;
		}
		sprintf(tmp, ""%c%u%c (%d) "", lbr, dirent->inode, rbr,
",1,unused,176,unused,"			fprintf(ls->f, ""%s"", tmp);
			ls->col += thislen;
			return 0;
		}
		sprintf(tmp, ""%c%u%c (%d) "", lbr, dirent->inode, rbr,
",unused,e2fsprogdebstretche-debugfs2Fls.c
"
	arg = malloc(strlen(field)+1);
	if (!arg)
		return NULL;
	strcpy(arg, field);
",1,unused,382,unused,"
	arg = malloc(strlen(field)+1);
	if (!arg)
		return NULL;
	strcpy(arg, field);
",unused,e2fsprogdebstretche-debugfs2Fset_fields.c
"		fprintf(stderr, ""Error maximum size for %s is %d.\n"",
			info->name, info->size);
		return EINVAL;
	}
	strcpy(cp, arg);
",1,unused,562,unused,"		fprintf(stderr, ""Error maximum size for %s is %d.\n"",
			info->name, info->size);
		return EINVAL;
	}
	strcpy(cp, arg);
",unused,e2fsprogdebstretche-debugfs2Fset_fields.c
"		else if (ss->func == parse_bmap)
			type = ""set physical->logical block map"";
		else if (ss->func == parse_gd_csum)
			type = ""unsigned integer OR \""calc\"""";
		strcpy(name, ss->name);
",1,unused,707,unused,"		else if (ss->func == parse_bmap)
			type = ""set physical->logical block map"";
		else if (ss->func == parse_gd_csum)
			type = ""unsigned integer OR \""calc\"""";
		strcpy(name, ss->name);
",unused,e2fsprogdebstretche-debugfs2Fset_fields.c
"			type = ""unsigned integer OR \""calc\"""";
		strcpy(name, ss->name);
		if (ss->flags & FLAG_ARRAY) {
			if (ss->max_idx > 0)
				sprintf(idx, ""[%d]"", ss->max_idx);
",1,unused,710,unused,"			type = ""unsigned integer OR \""calc\"""";
		strcpy(name, ss->name);
		if (ss->flags & FLAG_ARRAY) {
			if (ss->max_idx > 0)
				sprintf(idx, ""[%d]"", ss->max_idx);
",unused,e2fsprogdebstretche-debugfs2Fset_fields.c
"		if (ss->flags & FLAG_ARRAY) {
			if (ss->max_idx > 0)
				sprintf(idx, ""[%d]"", ss->max_idx);
			else
				strcpy(idx, ""[]"");
",1,unused,712,unused,"		if (ss->flags & FLAG_ARRAY) {
			if (ss->max_idx > 0)
				sprintf(idx, ""[%d]"", ss->max_idx);
			else
				strcpy(idx, ""[]"");
",unused,e2fsprogdebstretche-debugfs2Fset_fields.c
"			if (ss->max_idx > 0)
				sprintf(idx, ""[%d]"", ss->max_idx);
			else
				strcpy(idx, ""[]"");
			strcat(name, idx);
",1,unused,713,unused,"			if (ss->max_idx > 0)
				sprintf(idx, ""[%d]"", ss->max_idx);
			else
				strcpy(idx, ""[]"");
			strcat(name, idx);
",unused,e2fsprogdebstretche-debugfs2Fset_fields.c
"				strcpy(idx, ""[]"");
			strcat(name, idx);
		}
		if (ss->ptr2)
			strcat(name, ""[_hi|_lo]"");
",1,unused,716,unused,"				strcpy(idx, ""[]"");
			strcat(name, idx);
		}
		if (ss->ptr2)
			strcat(name, ""[_hi|_lo]"");
",unused,e2fsprogdebstretche-debugfs2Fset_fields.c
"	const char **i, **j;

	for (i = pager_search_list; *i; i++) {
		for (j = pager_dir_list; *j; j++) {
			sprintf(buf, ""%s/%s"", *j, *i);
",1,unused,72,unused,"	const char **i, **j;

	for (i = pager_search_list; *i; i++) {
		for (j = pager_dir_list; *j; j++) {
			sprintf(buf, ""%s/%s"", *j, *i);
",unused,e2fsprogdebstretche-debugfs2Futil.c
"				_(""while trying to open %s""), bad_blocks_file);
			goto fatal;
		}
	} else {
		sprintf(buf, ""badblocks -b %d -X %s%s%s %llu"", fs->blocksize,
",1,unused,76,unused,"				_(""while trying to open %s""), bad_blocks_file);
			goto fatal;
		}
	} else {
		sprintf(buf, ""badblocks -b %d -X %s%s%s %llu"", fs->blocksize,
",unused,e2fsprogdebstretche-e2fsck2Fbadblocks.c
"	if (retval)
		return;

	uuid_unparse(ctx->fs->super->s_uuid, uuid);
	sprintf(db->tdb_fn, ""%s/%s-dirinfo-XXXXXX"", tdb_dir, uuid);
",1,unused,71,unused,"	if (retval)
		return;

	uuid_unparse(ctx->fs->super->s_uuid, uuid);
	sprintf(db->tdb_fn, ""%s/%s-dirinfo-XXXXXX"", tdb_dir, uuid);
",unused,e2fsprogdebstretche-e2fsck2Fdirinfo.c
"	case '%':
		append_string(s, ""%"", 1);
		return;
	case 'd':
		sprintf(buf, ""%02d"", tm->tm_mday);
",1,unused,90,unused,"	case '%':
		append_string(s, ""%"", 1);
		return;
	case 'd':
		sprintf(buf, ""%02d"", tm->tm_mday);
",unused,e2fsprogdebstretche-e2fsck2Flogfile.c
"	case 'd':
		sprintf(buf, ""%02d"", tm->tm_mday);
		break;
	case 'D':
		sprintf(buf, ""%d%02d%02d"", tm->tm_year + 1900, tm->tm_mon + 1,
",1,unused,93,unused,"	case 'd':
		sprintf(buf, ""%02d"", tm->tm_mday);
		break;
	case 'D':
		sprintf(buf, ""%d%02d%02d"", tm->tm_year + 1900, tm->tm_mon + 1,
",unused,e2fsprogdebstretche-e2fsck2Flogfile.c
"		buf[sizeof(buf)-1] = 0;
#endif
		break;
	case 'H':
		sprintf(buf, ""%02d"", tm->tm_hour);
",1,unused,106,unused,"		buf[sizeof(buf)-1] = 0;
#endif
		break;
	case 'H':
		sprintf(buf, ""%02d"", tm->tm_hour);
",unused,e2fsprogdebstretche-e2fsck2Flogfile.c
"	case 'H':
		sprintf(buf, ""%02d"", tm->tm_hour);
		break;
	case 'm':
		sprintf(buf, ""%02d"", tm->tm_mon + 1);
",1,unused,109,unused,"	case 'H':
		sprintf(buf, ""%02d"", tm->tm_hour);
		break;
	case 'm':
		sprintf(buf, ""%02d"", tm->tm_mon + 1);
",unused,e2fsprogdebstretche-e2fsck2Flogfile.c
"	case 'm':
		sprintf(buf, ""%02d"", tm->tm_mon + 1);
		break;
	case 'M':
		sprintf(buf, ""%02d"", tm->tm_min);
",1,unused,112,unused,"	case 'm':
		sprintf(buf, ""%02d"", tm->tm_mon + 1);
		break;
	case 'M':
		sprintf(buf, ""%02d"", tm->tm_min);
",unused,e2fsprogdebstretche-e2fsck2Flogfile.c
"			cp = ctx->filesystem_name;
		append_string(s, cp, 0);
		return;
	case 'p':
		sprintf(buf, ""%lu"", (unsigned long) getpid());
",1,unused,123,unused,"			cp = ctx->filesystem_name;
		append_string(s, cp, 0);
		return;
	case 'p':
		sprintf(buf, ""%lu"", (unsigned long) getpid());
",unused,e2fsprogdebstretche-e2fsck2Flogfile.c
"	case 'p':
		sprintf(buf, ""%lu"", (unsigned long) getpid());
		break;
	case 's':
		sprintf(buf, ""%lu"", (unsigned long) ctx->now);
",1,unused,126,unused,"	case 'p':
		sprintf(buf, ""%lu"", (unsigned long) getpid());
		break;
	case 's':
		sprintf(buf, ""%lu"", (unsigned long) ctx->now);
",unused,e2fsprogdebstretche-e2fsck2Flogfile.c
"	case 's':
		sprintf(buf, ""%lu"", (unsigned long) ctx->now);
		break;
	case 'S':
		sprintf(buf, ""%02d"", tm->tm_sec);
",1,unused,129,unused,"	case 's':
		sprintf(buf, ""%lu"", (unsigned long) ctx->now);
		break;
	case 'S':
		sprintf(buf, ""%02d"", tm->tm_sec);
",unused,e2fsprogdebstretche-e2fsck2Flogfile.c
"	case 'S':
		sprintf(buf, ""%02d"", tm->tm_sec);
		break;
	case 'T':
		sprintf(buf, ""%02d%02d%02d"", tm->tm_hour, tm->tm_min,
",1,unused,132,unused,"	case 'S':
		sprintf(buf, ""%02d"", tm->tm_sec);
		break;
	case 'T':
		sprintf(buf, ""%02d%02d%02d"", tm->tm_hour, tm->tm_min,
",unused,e2fsprogdebstretche-e2fsck2Flogfile.c
"	case 'U':
		*flags |= FLAG_UTC;
		return;
	case 'y':
		sprintf(buf, ""%02d"", tm->tm_year % 100);
",1,unused,153,unused,"	case 'U':
		*flags |= FLAG_UTC;
		return;
	case 'y':
		sprintf(buf, ""%02d"", tm->tm_year % 100);
",unused,e2fsprogdebstretche-e2fsck2Flogfile.c
"	case 'y':
		sprintf(buf, ""%02d"", tm->tm_year % 100);
		break;
	case 'Y':
		sprintf(buf, ""%d"", tm->tm_year + 1900);
",1,unused,156,unused,"	case 'y':
		sprintf(buf, ""%02d"", tm->tm_year % 100);
		break;
	case 'Y':
		sprintf(buf, ""%d"", tm->tm_year + 1900);
",unused,e2fsprogdebstretche-e2fsck2Flogfile.c
"
#if 0
		printf(""%u "", pctx.ino);
#endif
		sprintf(buf, _(""reading indirect blocks of inode %u""),
",1,unused,1997,unused,"
#if 0
		printf(""%u "", pctx.ino);
#endif
		sprintf(buf, _(""reading indirect blocks of inode %u""),
",unused,e2fsprogdebstretche-e2fsck2Fpass1.c
"		fix_problem(ctx, PR_3_NO_LPF, &pctx);
		return 1;
	}

	sprintf(name, ""#%u"", ino);
",1,unused,613,unused,"		fix_problem(ctx, PR_3_NO_LPF, &pctx);
		return 1;
	}

	sprintf(name, ""#%u"", ino);
",unused,e2fsprogdebstretche-e2fsck2Fpass3.c
"	}
	if (!(ptr->flags & PR_CONFIG)) {
		char	key[9], *new_desc = NULL;

		sprintf(key, ""0x%06x"", code);
",1,unused,2153,unused,"	}
	if (!(ptr->flags & PR_CONFIG)) {
		char	key[9], *new_desc = NULL;

		sprintf(key, ""0x%06x"", code);
",unused,e2fsprogdebstretche-e2fsck2Fproblem.c
"
		newpath = malloc(len);
		if (!newpath)
			fatal_error(ctx, ""Couldn't malloc() newpath"");
		strcpy(newpath, PATH_SET);
",1,unused,1079,unused,"
		newpath = malloc(len);
		if (!newpath)
			fatal_error(ctx, ""Couldn't malloc() newpath"");
		strcpy(newpath, PATH_SET);
",unused,e2fsprogdebstretche-e2fsck2Funix.c
"			fatal_error(ctx, ""Couldn't malloc() newpath"");
		strcpy(newpath, PATH_SET);

		if (oldpath) {
			strcat(newpath, "":"");
",1,unused,1082,unused,"			fatal_error(ctx, ""Couldn't malloc() newpath"");
		strcpy(newpath, PATH_SET);

		if (oldpath) {
			strcat(newpath, "":"");
",unused,e2fsprogdebstretche-e2fsck2Funix.c
"		strcpy(newpath, PATH_SET);

		if (oldpath) {
			strcat(newpath, "":"");
			strcat(newpath, oldpath);
",1,unused,1083,unused,"		strcpy(newpath, PATH_SET);

		if (oldpath) {
			strcat(newpath, "":"");
			strcat(newpath, oldpath);
",unused,e2fsprogdebstretche-e2fsck2Funix.c
"	if (!tdb_file) {
		free(tmp_name);
		goto errout;
	}
	sprintf(tdb_file, ""%s/e2fsck-%s.e2undo"", tdb_dir, dev_name);
",1,unused,1287,unused,"	if (!tdb_file) {
		free(tmp_name);
		goto errout;
	}
	sprintf(tdb_file, ""%s/e2fsck-%s.e2undo"", tdb_dir, dev_name);
",unused,e2fsprogdebstretche-e2fsck2Funix.c
"	printf(""Allocating %u bytes for %s...\n"", size, description);
#endif
	ret = malloc(size);
	if (!ret) {
		sprintf(buf, ""Can't allocate %u bytes for %s\n"",
",1,unused,128,unused,"	printf(""Allocating %u bytes for %s...\n"", size, description);
#endif
	ret = malloc(size);
	if (!ret) {
		sprintf(buf, ""Can't allocate %u bytes for %s\n"",
",unused,e2fsprogdebstretche-e2fsck2Futil.c
"		free(new_type);
		free(new_value);
		return -1;
	}
	strcpy(new_type, search_type);
",1,unused,144,unused,"		free(new_type);
		free(new_value);
		return -1;
	}
	strcpy(new_type, search_type);
",unused,e2fsprogdebstretche-lib2Fblkid2Fdev.c
"		free(new_value);
		return -1;
	}
	strcpy(new_type, search_type);
	strcpy(new_value, search_value);
",1,unused,145,unused,"		free(new_value);
		return -1;
	}
	strcpy(new_type, search_type);
	strcpy(new_value, search_value);
",unused,e2fsprogdebstretche-lib2Fblkid2Fdev.c
"		    !strcmp(de->d_name, devname) ||
		    strncmp(de->d_name, ""dm-"", 3) ||
		    strlen(de->d_name) > sizeof(path)-32)
			continue;
		sprintf(path, ""/sys/block/%s/slaves"", de->d_name);
",1,unused,137,unused,"		    !strcmp(de->d_name, devname) ||
		    strncmp(de->d_name, ""dm-"", 3) ||
		    strlen(de->d_name) > sizeof(path)-32)
			continue;
		sprintf(path, ""/sys/block/%s/slaves"", de->d_name);
",unused,e2fsprogdebstretche-lib2Fblkid2Fdevname.c
"	for (dir = dirlist; *dir; dir++) {
		struct stat st;
		char device[256];

		sprintf(device, ""%s/%s"", *dir, ptname);
",1,unused,226,unused,"	for (dir = dirlist; *dir; dir++) {
		struct stat st;
		char device[256];

		sprintf(device, ""%s/%s"", *dir, ptname);
",unused,e2fsprogdebstretche-lib2Fblkid2Fdevname.c
"			continue;
		vdirname = malloc(vg_len + strlen(vg_name) + 8);
		if (!vdirname)
			goto exit;
		sprintf(vdirname, ""%s/%s/LVs"", VG_DIR, vg_name);
",1,unused,323,unused,"			continue;
		vdirname = malloc(vg_len + strlen(vg_name) + 8);
		if (!vdirname)
			goto exit;
		sprintf(vdirname, ""%s/%s/LVs"", VG_DIR, vg_name);
",unused,e2fsprogdebstretche-lib2Fblkid2Fdevname.c
"			if (!lvm_device) {
				closedir(lv_list);
				goto exit;
			}
			sprintf(lvm_device, ""%s/%s/LVs/%s"", VG_DIR, vg_name,
",1,unused,343,unused,"			if (!lvm_device) {
				closedir(lv_list);
				goto exit;
			}
			sprintf(lvm_device, ""%s/%s/LVs/%s"", VG_DIR, vg_name,
",unused,e2fsprogdebstretche-lib2Fblkid2Fdevname.c
"			}
			sprintf(lvm_device, ""%s/%s/LVs/%s"", VG_DIR, vg_name,
				lv_name);
			dev = lvm_get_devno(lvm_device);
			sprintf(lvm_device, ""%s/%s"", vg_name, lv_name);
",1,unused,346,unused,"			}
			sprintf(lvm_device, ""%s/%s/LVs/%s"", VG_DIR, vg_name,
				lv_name);
			dev = lvm_get_devno(lvm_device);
			sprintf(lvm_device, ""%s/%s"", vg_name, lv_name);
",unused,e2fsprogdebstretche-lib2Fblkid2Fdevname.c
"		    ((dp->d_name[1] == 0) ||
		     ((dp->d_name[1] == '.') && (dp->d_name[2] == 0))))
			continue;

		sprintf(path, ""%s/%s"", dirname, dp->d_name);
",1,unused,115,unused,"		    ((dp->d_name[1] == 0) ||
		     ((dp->d_name[1] == '.') && (dp->d_name[2] == 0))))
			continue;

		sprintf(path, ""%s/%s"", dirname, dp->d_name);
",unused,e2fsprogdebstretche-lib2Fblkid2Fdevno.c
"			label = vol_label;
	}

	/* We can't just print them as %04X, because they are unaligned */
	sprintf(serno, ""%02X%02X-%02X%02X"", vol_serno[3], vol_serno[2],
",1,unused,627,unused,"			label = vol_label;
	}

	/* We can't just print them as %04X, because they are unaligned */
	sprintf(serno, ""%02X%02X-%02X%02X"", vol_serno[3], vol_serno[2],
",unused,e2fsprogdebstretche-lib2Fblkid2Fprobe.c
"			*cp = 0;
		}
	}

	sprintf(uuid_str, ""%016llX"", blkid_le64(ns->volume_serial));
",1,unused,783,unused,"			*cp = 0;
		}
	}

	sprintf(uuid_str, ""%016llX"", blkid_le64(ns->volume_serial));
",unused,e2fsprogdebstretche-lib2Fblkid2Fprobe.c
"
	uuid_ptr = (unsigned long long *)hfs->finder_info.id;
	uuid = blkid_le64(*uuid_ptr);
	if (uuid) {
		sprintf(uuid_str, ""%016llX"", uuid);
",1,unused,1180,unused,"
	uuid_ptr = (unsigned long long *)hfs->finder_info.id;
	uuid = blkid_le64(*uuid_ptr);
	if (uuid) {
		sprintf(uuid_str, ""%016llX"", uuid);
",unused,e2fsprogdebstretche-lib2Fblkid2Fprobe.c
"
	uuid_ptr = (unsigned long long *)hfsplus->finder_info.id;
	uuid = blkid_le64(*uuid_ptr);
	if (uuid) {
		sprintf(uuid_str, ""%016llX"", uuid);
",1,unused,1246,unused,"
	uuid_ptr = (unsigned long long *)hfsplus->finder_info.id;
	uuid = blkid_le64(*uuid_ptr);
	if (uuid) {
		sprintf(uuid_str, ""%016llX"", uuid);
",unused,e2fsprogdebstretche-lib2Fblkid2Fprobe.c
"	if (ret == 0 && S_ISREG(st.st_mode)) {
		tmp = malloc(strlen(filename) + 8);
		if (tmp) {
			mode_t save_umask = umask(022);
			sprintf(tmp, ""%s-XXXXXX"", filename);
",1,unused,98,unused,"	if (ret == 0 && S_ISREG(st.st_mode)) {
		tmp = malloc(strlen(filename) + 8);
		if (tmp) {
			mode_t save_umask = umask(022);
			sprintf(tmp, ""%s-XXXXXX"", filename);
",unused,e2fsprogdebstretche-lib2Fblkid2Fsave.c
"			char *backup;

			backup = malloc(strlen(filename) + 5);
			if (backup) {
				sprintf(backup, ""%s.old"", filename);
",1,unused,147,unused,"			char *backup;

			backup = malloc(strlen(filename) + 5);
			if (backup) {
				sprintf(backup, ""%s.old"", filename);
",unused,e2fsprogdebstretche-lib2Fblkid2Fsave.c
"	for (p = mode_list; p->string; p++) {
		if (num == p->num)
			return p->string;
	}
	sprintf(buf, ""ENC_MODE_%d"", num);
",1,unused,44,unused,"	for (p = mode_list; p->string; p++) {
		if (num == p->num)
			return p->string;
	}
	sprintf(buf, ""ENC_MODE_%d"", num);
",unused,e2fsprogdebstretche-lib2Fe2p2Fcrypto_mode.c
"		fchar = '?';
		break;
	}
	for (fnum = 0; mask >>= 1; fnum++);
	sprintf(buf, ""FEATURE_%c%d"", fchar, fnum);
",1,unused,155,unused,"		fchar = '?';
		break;
	}
	for (fnum = 0; mask >>= 1; fnum++);
	sprintf(buf, ""FEATURE_%c%d"", fchar, fnum);
",unused,e2fsprogdebstretche-lib2Fe2p2Ffeature.c
"		fchar = '?';
		break;
	}
	for (fnum = 0; mask >>= 1; fnum++);
	sprintf(buf, ""FEATURE_%c%d"", fchar, fnum);
",1,unused,229,unused,"		fchar = '?';
		break;
	}
	for (fnum = 0; mask >>= 1; fnum++);
	sprintf(buf, ""FEATURE_%c%d"", fchar, fnum);
",unused,e2fsprogdebstretche-lib2Fe2p2Ffeature.c
"
	buf = malloc(strlen(str)+1);
	if (!buf)
		return 1;
	strcpy(buf, str);
",1,unused,316,unused,"
	buf = malloc(strlen(str)+1);
	if (!buf)
		return 1;
	strcpy(buf, str);
",unused,e2fsprogdebstretche-lib2Fe2p2Ffeature.c
"	for (p = hash_list; p->string; p++) {
		if (num == p->num)
			return p->string;
	}
	sprintf(buf, ""HASHALG_%d"", num);
",1,unused,42,unused,"	for (p = hash_list; p->string; p++) {
		if (num == p->num)
			return p->string;
	}
	sprintf(buf, ""HASHALG_%d"", num);
",unused,e2fsprogdebstretche-lib2Fe2p2Fhashstr.c
"
	if (secs >= MONTH_INT) {
		num = secs / MONTH_INT;
		secs -= num*MONTH_INT;
		sprintf(buf, ""%d month%s"", num, (num>1) ? ""s"" : """");
",1,unused,71,unused,"
	if (secs >= MONTH_INT) {
		num = secs / MONTH_INT;
		secs -= num*MONTH_INT;
		sprintf(buf, ""%d month%s"", num, (num>1) ? ""s"" : """");
",unused,e2fsprogdebstretche-lib2Fe2p2Fls.c
"	}
	if (secs >= WEEK_INT) {
		num = secs / WEEK_INT;
		secs -= num*WEEK_INT;
		sprintf(tmp, ""%s%d week%s"", buf[0] ? "", "" : """",
",1,unused,76,unused,"	}
	if (secs >= WEEK_INT) {
		num = secs / WEEK_INT;
		secs -= num*WEEK_INT;
		sprintf(tmp, ""%s%d week%s"", buf[0] ? "", "" : """",
",unused,e2fsprogdebstretche-lib2Fe2p2Fls.c
"		num = secs / WEEK_INT;
		secs -= num*WEEK_INT;
		sprintf(tmp, ""%s%d week%s"", buf[0] ? "", "" : """",
			num, (num>1) ? ""s"" : """");
		strcat(buf, tmp);
",1,unused,78,unused,"		num = secs / WEEK_INT;
		secs -= num*WEEK_INT;
		sprintf(tmp, ""%s%d week%s"", buf[0] ? "", "" : """",
			num, (num>1) ? ""s"" : """");
		strcat(buf, tmp);
",unused,e2fsprogdebstretche-lib2Fe2p2Fls.c
"	}
	if (secs >= DAY_INT) {
		num = secs / DAY_INT;
		secs -= num*DAY_INT;
		sprintf(tmp, ""%s%d day%s"", buf[0] ? "", "" : """",
",1,unused,83,unused,"	}
	if (secs >= DAY_INT) {
		num = secs / DAY_INT;
		secs -= num*DAY_INT;
		sprintf(tmp, ""%s%d day%s"", buf[0] ? "", "" : """",
",unused,e2fsprogdebstretche-lib2Fe2p2Fls.c
"		num = secs / DAY_INT;
		secs -= num*DAY_INT;
		sprintf(tmp, ""%s%d day%s"", buf[0] ? "", "" : """",
			num, (num>1) ? ""s"" : """");
		strcat(buf, tmp);
",1,unused,85,unused,"		num = secs / DAY_INT;
		secs -= num*DAY_INT;
		sprintf(tmp, ""%s%d day%s"", buf[0] ? "", "" : """",
			num, (num>1) ? ""s"" : """");
		strcat(buf, tmp);
",unused,e2fsprogdebstretche-lib2Fe2p2Fls.c
"		hr = secs / HOUR_INT;
		secs -= hr*HOUR_INT;
		min = secs / MINUTE_INT;
		secs -= min*MINUTE_INT;
		sprintf(tmp, ""%s%d:%02d:%02d"", buf[0] ? "", "" : """",
",1,unused,92,unused,"		hr = secs / HOUR_INT;
		secs -= hr*HOUR_INT;
		min = secs / MINUTE_INT;
		secs -= min*MINUTE_INT;
		sprintf(tmp, ""%s%d:%02d:%02d"", buf[0] ? "", "" : """",
",unused,e2fsprogdebstretche-lib2Fe2p2Fls.c
"		min = secs / MINUTE_INT;
		secs -= min*MINUTE_INT;
		sprintf(tmp, ""%s%d:%02d:%02d"", buf[0] ? "", "" : """",
			hr, min, secs);
		strcat(buf, tmp);
",1,unused,94,unused,"		min = secs / MINUTE_INT;
		secs -= min*MINUTE_INT;
		sprintf(tmp, ""%s%d:%02d:%02d"", buf[0] ? "", "" : """",
			hr, min, secs);
		strcat(buf, tmp);
",unused,e2fsprogdebstretche-lib2Fe2p2Fls.c
"	if (sb->s_volume_name[0]) {
		memset(buf, 0, sizeof(buf));
		strncpy(buf, sb->s_volume_name, sizeof(sb->s_volume_name));
	} else
		strcpy(buf, ""<none>"");
",1,unused,239,unused,"	if (sb->s_volume_name[0]) {
		memset(buf, 0, sizeof(buf));
		strncpy(buf, sb->s_volume_name, sizeof(sb->s_volume_name));
	} else
		strcpy(buf, ""<none>"");
",unused,e2fsprogdebstretche-lib2Fe2p2Fls.c
"	if (sb->s_last_mounted[0]) {
		memset(buf, 0, sizeof(buf));
		strncpy(buf, sb->s_last_mounted, sizeof(sb->s_last_mounted));
	} else
		strcpy(buf, ""<not available>"");
",1,unused,245,unused,"	if (sb->s_last_mounted[0]) {
		memset(buf, 0, sizeof(buf));
		strncpy(buf, sb->s_last_mounted, sizeof(sb->s_last_mounted));
	} else
		strcpy(buf, ""<not available>"");
",unused,e2fsprogdebstretche-lib2Fe2p2Fls.c
"		if (mask == f->mask)
			return f->string;
	}
	for (fnum = 0; mask >>= 1; fnum++);
	sprintf(buf, ""MNTOPT_%d"", fnum);
",1,unused,54,unused,"		if (mask == f->mask)
			return f->string;
	}
	for (fnum = 0; mask >>= 1; fnum++);
	sprintf(buf, ""MNTOPT_%d"", fnum);
",unused,e2fsprogdebstretche-lib2Fe2p2Fmntopts.c
"
	buf = malloc(strlen(str)+1);
	if (!buf)
		return 1;
	strcpy(buf, str);
",1,unused,113,unused,"
	buf = malloc(strlen(str)+1);
	if (!buf)
		return 1;
	strcpy(buf, str);
",unused,e2fsprogdebstretche-lib2Fe2p2Fmntopts.c
"		os = ""(unknown os)"";

        ret = malloc(strlen(os)+1);
	if (ret)
		strcpy(ret, os);
",1,unused,40,unused,"		os = ""(unknown os)"";

        ret = malloc(strlen(os)+1);
	if (ret)
		strcpy(ret, os);
",unused,e2fsprogdebstretche-lib2Fe2p2Fostype.c
"{
	struct uuid uuid;

	e2p_unpack_uuid(uu, &uuid);
	sprintf(out,
",1,unused,68,unused,"{
	struct uuid uuid;

	e2p_unpack_uuid(uu, &uuid);
	sprintf(out,
",unused,e2fsprogdebstretche-lib2Fe2p2Fuuid.c
"	}
    }
    et_list_unlock();
oops:
    strcpy (buffer, ""Unknown code "");
",1,unused,172,unused,"	}
    }
    et_list_unlock();
oops:
    strcpy (buffer, ""Unknown code "");
",unused,e2fsprogdebstretche-lib2Fet2Ferror_message.c
"    et_list_unlock();
oops:
    strcpy (buffer, ""Unknown code "");
    if (table_num) {
	strcat (buffer, error_table_name (table_num));
",1,unused,174,unused,"    et_list_unlock();
oops:
    strcpy (buffer, ""Unknown code "");
    if (table_num) {
	strcat (buffer, error_table_name (table_num));
",unused,e2fsprogdebstretche-lib2Fet2Ferror_message.c
"oops:
    strcpy (buffer, ""Unknown code "");
    if (table_num) {
	strcat (buffer, error_table_name (table_num));
	strcat (buffer, "" "");
",1,unused,175,unused,"oops:
    strcpy (buffer, ""Unknown code "");
    if (table_num) {
	strcat (buffer, error_table_name (table_num));
	strcat (buffer, "" "");
",unused,e2fsprogdebstretche-lib2Fet2Ferror_message.c
"
	retval = ext2fs_get_mem(strlen(src->device_name)+1, &fs->device_name);
	if (retval)
		goto errout;
	strcpy(fs->device_name, src->device_name);
",1,unused,54,unused,"
	retval = ext2fs_get_mem(strlen(src->device_name)+1, &fs->device_name);
	if (retval)
		goto errout;
	strcpy(fs->device_name, src->device_name);
",unused,e2fsprogdebstretche-lib2Fext2fs2Fdupfs.c
"	if (last_empty) {
		err = ext2fs_get_mem(strlen(key) + 1, &last_empty->name);
		if (err)
			goto errout;
		strcpy(last_empty->name, key);
",1,unused,1178,unused,"	if (last_empty) {
		err = ext2fs_get_mem(strlen(key) + 1, &last_empty->name);
		if (err)
			goto errout;
		strcpy(last_empty->name, key);
",unused,e2fsprogdebstretche-lib2Fext2fs2Fext_attr.c
"	x = handle->attrs + handle->length - 4;
	err = ext2fs_get_mem(strlen(key) + 1, &x->name);
	if (err)
		goto errout;
	strcpy(x->name, key);
",1,unused,1195,unused,"	x = handle->attrs + handle->length - 4;
	err = ext2fs_get_mem(strlen(key) + 1, &x->name);
	if (err)
		goto errout;
	strcpy(x->name, key);
",unused,e2fsprogdebstretche-lib2Fext2fs2Fext_attr.c
"	if (!dp->name) {
		free(dp);
		return;
	}
	strcpy(dp->name, name);
",1,unused,59,unused,"	if (!dp->name) {
		free(dp);
		return;
	}
	strcpy(dp->name, name);
",unused,e2fsprogdebstretche-lib2Fext2fs2Ffinddev.c
"		if (dp->d_name[0] == '.' &&
		    ((dp->d_name[1] == 0) ||
		     ((dp->d_name[1] == '.') && (dp->d_name[2] == 0))))
			goto skip_to_next;
		sprintf(path, ""%s/%s"", dirname, dp->d_name);
",1,unused,99,unused,"		if (dp->d_name[0] == '.' &&
		    ((dp->d_name[1] == 0) ||
		     ((dp->d_name[1] == '.') && (dp->d_name[2] == 0))))
			goto skip_to_next;
		sprintf(path, ""%s/%s"", dirname, dp->d_name);
",unused,e2fsprogdebstretche-lib2Fext2fs2Ffinddev.c
"			if (!cp) {
				closedir(dir);
				return ENOMEM;
			}
			strcpy(cp, path);
",1,unused,110,unused,"			if (!cp) {
				closedir(dir);
				return ENOMEM;
			}
			strcpy(cp, path);
",unused,e2fsprogdebstretche-lib2Fext2fs2Ffinddev.c
"		if (retval) {
			ext2fs_free_mem(&bitmap);
			return retval;
		}
		strcpy(bitmap->description, descr);
",1,unused,112,unused,"		if (retval) {
			ext2fs_free_mem(&bitmap);
			return retval;
		}
		strcpy(bitmap->description, descr);
",unused,e2fsprogdebstretche-lib2Fext2fs2Fgen_bitmap.c
"		if (retval) {
			ext2fs_free_mem(&bitmap);
			return retval;
		}
		strcpy(bitmap->description, descr);
",1,unused,162,unused,"		if (retval) {
			ext2fs_free_mem(&bitmap);
			return retval;
		}
		strcpy(bitmap->description, descr);
",unused,e2fsprogdebstretche-lib2Fext2fs2Fgen_bitmap64.c
"		if (retval) {
			ext2fs_free_mem(&new_bmap);
			return retval;
		}
		strcpy(new_descr, ""copy of "");
",1,unused,327,unused,"		if (retval) {
			ext2fs_free_mem(&new_bmap);
			return retval;
		}
		strcpy(new_descr, ""copy of "");
",unused,e2fsprogdebstretche-lib2Fext2fs2Fgen_bitmap64.c
"			ext2fs_free_mem(&new_bmap);
			return retval;
		}
		strcpy(new_descr, ""copy of "");
		strcat(new_descr, descr);
",1,unused,328,unused,"			ext2fs_free_mem(&new_bmap);
			return retval;
		}
		strcpy(new_descr, ""copy of "");
		strcat(new_descr, descr);
",unused,e2fsprogdebstretche-lib2Fext2fs2Fgen_bitmap64.c
"	if (dir == ino) {
		retval = ext2fs_get_mem(2, name);
		if (retval)
			return retval;
		strcpy(*name, (dir == EXT2_ROOT_INO) ? ""/"" : ""."");
",1,unused,83,unused,"	if (dir == ino) {
		retval = ext2fs_get_mem(2, name);
		if (retval)
			return retval;
		strcpy(*name, (dir == EXT2_ROOT_INO) ? ""/"" : ""."");
",unused,e2fsprogdebstretche-lib2Fext2fs2Fget_pathname.c
"	if (!dir || (maxdepth < 0)) {
		retval = ext2fs_get_mem(4, name);
		if (retval)
			return retval;
		strcpy(*name, ""..."");
",1,unused,91,unused,"	if (!dir || (maxdepth < 0)) {
		retval = ext2fs_get_mem(4, name);
		if (retval)
			return retval;
		strcpy(*name, ""..."");
",unused,e2fsprogdebstretche-lib2Fext2fs2Fget_pathname.c
"			snprintf(tmp, sizeof(tmp), ""<%u>"", dir);
		retval = ext2fs_get_mem(strlen(tmp)+1, name);
		if (retval)
			goto cleanup;
		strcpy(*name, tmp);
",1,unused,111,unused,"			snprintf(tmp, sizeof(tmp), ""<%u>"", dir);
		retval = ext2fs_get_mem(strlen(tmp)+1, name);
		if (retval)
			goto cleanup;
		strcpy(*name, tmp);
",unused,e2fsprogdebstretche-lib2Fext2fs2Fget_pathname.c
"		goto cleanup;

	ret[0] = 0;
	if (parent_name[1])
		strcat(ret, parent_name);
",1,unused,139,unused,"		goto cleanup;

	ret[0] = 0;
	if (parent_name[1])
		strcat(ret, parent_name);
",unused,e2fsprogdebstretche-lib2Fext2fs2Fget_pathname.c
"
	ret[0] = 0;
	if (parent_name[1])
		strcat(ret, parent_name);
	strcat(ret, ""/"");
",1,unused,140,unused,"
	ret[0] = 0;
	if (parent_name[1])
		strcat(ret, parent_name);
	strcat(ret, ""/"");
",unused,e2fsprogdebstretche-lib2Fext2fs2Fget_pathname.c
"	if (parent_name[1])
		strcat(ret, parent_name);
	strcat(ret, ""/"");
	if (gp.name)
		strcat(ret, gp.name);
",1,unused,142,unused,"	if (parent_name[1])
		strcat(ret, parent_name);
	strcat(ret, ""/"");
	if (gp.name)
		strcat(ret, gp.name);
",unused,e2fsprogdebstretche-lib2Fext2fs2Fget_pathname.c
"	strcat(ret, ""/"");
	if (gp.name)
		strcat(ret, gp.name);
	else
		strcat(ret, ""???"");
",1,unused,144,unused,"	strcat(ret, ""/"");
	if (gp.name)
		strcat(ret, gp.name);
	else
		strcat(ret, ""???"");
",unused,e2fsprogdebstretche-lib2Fext2fs2Fget_pathname.c
"{
	struct uuid uuid;

	unpack_uuid(uu, &uuid);
	sprintf(out,
",1,unused,174,unused,"{
	struct uuid uuid;

	unpack_uuid(uu, &uuid);
	sprintf(out,
",unused,e2fsprogdebstretche-lib2Fext2fs2Ficount.c
"	retval = ext2fs_get_mem(strlen(tdb_dir) + 64, &fn);
	if (retval)
		goto errout;
	uuid_unparse(fs->super->s_uuid, uuid);
	sprintf(fn, ""%s/%s-icount-XXXXXX"", tdb_dir, uuid);
",1,unused,204,unused,"	retval = ext2fs_get_mem(strlen(tdb_dir) + 64, &fn);
	if (retval)
		goto errout;
	uuid_unparse(fs->super->s_uuid, uuid);
	sprintf(fn, ""%s/%s-icount-XXXXXX"", tdb_dir, uuid);
",unused,e2fsprogdebstretche-lib2Fext2fs2Ficount.c
"	retval = ext2fs_get_mem(strlen(name)+1, &fs->device_name);
	if (retval)
		goto cleanup;

	strcpy(fs->device_name, name);
",1,unused,136,unused,"	retval = ext2fs_get_mem(strlen(name)+1, &fs->device_name);
	if (retval)
		goto cleanup;

	strcpy(fs->device_name, name);
",unused,e2fsprogdebstretche-lib2Fext2fs2Finitialize.c
"	retval = ext2fs_get_mem(strlen(fs->device_name) + 80, &buf);
	if (retval)
		goto cleanup;

	strcpy(buf, ""block bitmap for "");
",1,unused,468,unused,"	retval = ext2fs_get_mem(strlen(fs->device_name) + 80, &buf);
	if (retval)
		goto cleanup;

	strcpy(buf, ""block bitmap for "");
",unused,e2fsprogdebstretche-lib2Fext2fs2Finitialize.c
"	if (retval)
		goto cleanup;

	strcpy(buf, ""block bitmap for "");
	strcat(buf, fs->device_name);
",1,unused,469,unused,"	if (retval)
		goto cleanup;

	strcpy(buf, ""block bitmap for "");
	strcat(buf, fs->device_name);
",unused,e2fsprogdebstretche-lib2Fext2fs2Finitialize.c
"	retval = ext2fs_allocate_subcluster_bitmap(fs, buf, &fs->block_map);
	if (retval)
		goto cleanup;

	strcpy(buf, ""inode bitmap for "");
",1,unused,474,unused,"	retval = ext2fs_allocate_subcluster_bitmap(fs, buf, &fs->block_map);
	if (retval)
		goto cleanup;

	strcpy(buf, ""inode bitmap for "");
",unused,e2fsprogdebstretche-lib2Fext2fs2Finitialize.c
"	if (retval)
		goto cleanup;

	strcpy(buf, ""inode bitmap for "");
	strcat(buf, fs->device_name);
",1,unused,475,unused,"	if (retval)
		goto cleanup;

	strcpy(buf, ""inode bitmap for "");
	strcat(buf, fs->device_name);
",unused,e2fsprogdebstretche-lib2Fext2fs2Finitialize.c
"	if ((retval = ext2fs_get_mem(sizeof(struct inode_private_data),
				     &data)))
		return retval;
	data->magic = EXT2_ET_MAGIC_INODE_IO_CHANNEL;
	sprintf(data->name, ""%u:%d"", ino, ino_unique++);
",1,unused,92,unused,"	if ((retval = ext2fs_get_mem(sizeof(struct inode_private_data),
				     &data)))
		return retval;
	data->magic = EXT2_ET_MAGIC_INODE_IO_CHANNEL;
	sprintf(data->name, ""%u:%d"", ino, ino_unique++);
",unused,e2fsprogdebstretche-lib2Fext2fs2Finode_io.c
"	retval = ext2fs_get_mem(strlen(name)+1, &io->name);
	if (retval)
		goto cleanup;

	strcpy(io->name, name);
",1,unused,146,unused,"	retval = ext2fs_get_mem(strlen(name)+1, &io->name);
	if (retval)
		goto cleanup;

	strcpy(io->name, name);
",unused,e2fsprogdebstretche-lib2Fext2fs2Finode_io.c
"
	options = malloc(strlen(opts)+1);
	if (!options)
		return EXT2_ET_NO_MEMORY;
	strcpy(options, opts);
",1,unused,39,unused,"
	options = malloc(strlen(opts)+1);
	if (!options)
		return EXT2_ET_NO_MEMORY;
	strcpy(options, opts);
",unused,e2fsprogdebstretche-lib2Fext2fs2Fio_manager.c
"	if (mount_flags & EXT2_MF_MOUNTED) {
#if HAVE_EXT2_IOCTLS
		int f = 0;
#endif
		strcat(jfile, ""/.journal"");
",1,unused,456,unused,"	if (mount_flags & EXT2_MF_MOUNTED) {
#if HAVE_EXT2_IOCTLS
		int f = 0;
#endif
		strcat(jfile, ""/.journal"");
",unused,e2fsprogdebstretche-lib2Fext2fs2Fmkjournal.c
"	fs->umask = 022;
	retval = ext2fs_get_mem(strlen(name)+1, &fs->device_name);
	if (retval)
		goto cleanup;
	strcpy(fs->device_name, name);
",1,unused,145,unused,"	fs->umask = 022;
	retval = ext2fs_get_mem(strlen(name)+1, &fs->device_name);
	if (retval)
		goto cleanup;
	strcpy(fs->device_name, name);
",unused,e2fsprogdebstretche-lib2Fext2fs2Fopenfs.c
"		return retval;
	if (do_block) {
		if (fs->block_map)
			ext2fs_free_block_bitmap(fs->block_map);
		strcpy(buf, ""block bitmap for "");
",1,unused,228,unused,"		return retval;
	if (do_block) {
		if (fs->block_map)
			ext2fs_free_block_bitmap(fs->block_map);
		strcpy(buf, ""block bitmap for "");
",unused,e2fsprogdebstretche-lib2Fext2fs2Frw_bitmaps.c
"	if (do_block) {
		if (fs->block_map)
			ext2fs_free_block_bitmap(fs->block_map);
		strcpy(buf, ""block bitmap for "");
		strcat(buf, fs->device_name);
",1,unused,229,unused,"	if (do_block) {
		if (fs->block_map)
			ext2fs_free_block_bitmap(fs->block_map);
		strcpy(buf, ""block bitmap for "");
		strcat(buf, fs->device_name);
",unused,e2fsprogdebstretche-lib2Fext2fs2Frw_bitmaps.c
"		block_nbytes = 0;
	if (do_inode) {
		if (fs->inode_map)
			ext2fs_free_inode_bitmap(fs->inode_map);
		strcpy(buf, ""inode bitmap for "");
",1,unused,241,unused,"		block_nbytes = 0;
	if (do_inode) {
		if (fs->inode_map)
			ext2fs_free_inode_bitmap(fs->inode_map);
		strcpy(buf, ""inode bitmap for "");
",unused,e2fsprogdebstretche-lib2Fext2fs2Frw_bitmaps.c
"	if (do_inode) {
		if (fs->inode_map)
			ext2fs_free_inode_bitmap(fs->inode_map);
		strcpy(buf, ""inode bitmap for "");
		strcat(buf, fs->device_name);
",1,unused,242,unused,"	if (do_inode) {
		if (fs->inode_map)
			ext2fs_free_inode_bitmap(fs->inode_map);
		strcpy(buf, ""inode bitmap for "");
		strcat(buf, fs->device_name);
",unused,e2fsprogdebstretche-lib2Fext2fs2Frw_bitmaps.c
"		     ext2fs_has_feature_inline_data(fs->super) &&
		     (target_len < fs->blocksize);
	if (fastlink) {
		/* Fast symlinks, target stored in inode */
		strcpy((char *)&inode.i_block, target);
",1,unused,95,unused,"		     ext2fs_has_feature_inline_data(fs->super) &&
		     (target_len < fs->blocksize);
	if (fastlink) {
		/* Fast symlinks, target stored in inode */
		strcpy((char *)&inode.i_block, target);
",unused,e2fsprogdebstretche-lib2Fext2fs2Fsymlink.c
"	retval = ext2fs_get_mem(strlen(name)+1, &io->name);
	if (retval)
		goto cleanup;

	strcpy(io->name, name);
",1,unused,192,unused,"	retval = ext2fs_get_mem(strlen(name)+1, &io->name);
	if (retval)
		goto cleanup;

	strcpy(io->name, name);
",unused,e2fsprogdebstretche-lib2Fext2fs2Ftest_io.c
"	retval = ext2fs_get_mem(strlen(name)+1, &io->name);
	if (retval)
		goto cleanup;

	strcpy(io->name, name);
",1,unused,717,unused,"	retval = ext2fs_get_mem(strlen(name)+1, &io->name);
	if (retval)
		goto cleanup;

	strcpy(io->name, name);
",unused,e2fsprogdebstretche-lib2Fext2fs2Fundo_io.c
"	retval = ext2fs_get_mem(strlen(name)+1, &io->name);
	if (retval)
		goto cleanup;

	strcpy(io->name, name);
",1,unused,582,unused,"	retval = ext2fs_get_mem(strlen(name)+1, &io->name);
	if (retval)
		goto cleanup;

	strcpy(io->name, name);
",unused,e2fsprogdebstretche-lib2Fext2fs2Funix_io.c
"			 (strlen(infop->subsystem_name)+1)
			 * sizeof(char));
	if (ret_val == (char *)NULL)
	    return((char *)NULL);
	strcpy(ret_val, infop->subsystem_name);
",1,unused,35,unused,"			 (strlen(infop->subsystem_name)+1)
			 * sizeof(char));
	if (ret_val == (char *)NULL)
	    return((char *)NULL);
	strcpy(ret_val, infop->subsystem_name);
",unused,e2fsprogdebstretche-lib2Fss2Ferror.c
"
	tmp = malloc(strlen(libpath)+1);
	if (!tmp)
		return;
	strcpy(tmp, libpath);
",1,unused,63,unused,"
	tmp = malloc(strlen(libpath)+1);
	if (!tmp)
		return;
	strcpy(tmp, libpath);
",unused,e2fsprogdebstretche-lib2Fss2Fget_readline.c
"		ss_perror(sci_idx, 0,
			  ""couldn't allocate memory to print usage message"");
		return;
	}
	sprintf(buffer, ""usage:\n\t%s [topic|command]\nor\t%s\n"",
",1,unused,65,unused,"		ss_perror(sci_idx, 0,
			  ""couldn't allocate memory to print usage message"");
		return;
	}
	sprintf(buffer, ""usage:\n\t%s [topic|command]\nor\t%s\n"",
",unused,e2fsprogdebstretche-lib2Fss2Fhelp.c
"	    ss_perror(sci_idx, 0,
		      ""couldn't allocate memory for help filename"");
	    return;
	}
	(void) strcpy(buffer, info->info_dirs[idx]);
",1,unused,88,unused,"	    ss_perror(sci_idx, 0,
		      ""couldn't allocate memory for help filename"");
	    return;
	}
	(void) strcpy(buffer, info->info_dirs[idx]);
",unused,e2fsprogdebstretche-lib2Fss2Fhelp.c
"		      ""couldn't allocate memory for help filename"");
	    return;
	}
	(void) strcpy(buffer, info->info_dirs[idx]);
	(void) strcat(buffer, ""/"");
",1,unused,89,unused,"		      ""couldn't allocate memory for help filename"");
	    return;
	}
	(void) strcpy(buffer, info->info_dirs[idx]);
	(void) strcat(buffer, ""/"");
",unused,e2fsprogdebstretche-lib2Fss2Fhelp.c
"	    return;
	}
	(void) strcpy(buffer, info->info_dirs[idx]);
	(void) strcat(buffer, ""/"");
	(void) strcat(buffer, argv[1]);
",1,unused,90,unused,"	    return;
	}
	(void) strcpy(buffer, info->info_dirs[idx]);
	(void) strcat(buffer, ""/"");
	(void) strcat(buffer, argv[1]);
",unused,e2fsprogdebstretche-lib2Fss2Fhelp.c
"	}
	(void) strcpy(buffer, info->info_dirs[idx]);
	(void) strcat(buffer, ""/"");
	(void) strcat(buffer, argv[1]);
	(void) strcat(buffer, "".info"");
",1,unused,91,unused,"	}
	(void) strcpy(buffer, info->info_dirs[idx]);
	(void) strcat(buffer, ""/"");
	(void) strcat(buffer, argv[1]);
	(void) strcat(buffer, "".info"");
",unused,e2fsprogdebstretche-lib2Fss2Fhelp.c
"    }
    if (fd < 0) {
#define MSG ""No info found for ""
        char *buf = malloc(strlen (MSG) + strlen (argv[1]) + 1);
	strcpy(buf, MSG);
",1,unused,100,unused,"    }
    if (fd < 0) {
#define MSG ""No info found for ""
        char *buf = malloc(strlen (MSG) + strlen (argv[1]) + 1);
	strcpy(buf, MSG);
",unused,e2fsprogdebstretche-lib2Fss2Fhelp.c
"    if (fd < 0) {
#define MSG ""No info found for ""
        char *buf = malloc(strlen (MSG) + strlen (argv[1]) + 1);
	strcpy(buf, MSG);
	strcat(buf, argv[1]);
",1,unused,101,unused,"    if (fd < 0) {
#define MSG ""No info found for ""
        char *buf = malloc(strlen (MSG) + strlen (argv[1]) + 1);
	strcpy(buf, MSG);
	strcat(buf, argv[1]);
",unused,e2fsprogdebstretche-lib2Fss2Fhelp.c
"    }
    info->info_dirs = dirs;
    dirs[n_dirs + 1] = (char *)NULL;
    dirs[n_dirs] = malloc((unsigned)strlen(info_dir)+1);
    strcpy(dirs[n_dirs], info_dir);
",1,unused,158,unused,"    }
    info->info_dirs = dirs;
    dirs[n_dirs + 1] = (char *)NULL;
    dirs[n_dirs] = malloc((unsigned)strlen(info_dir)+1);
    strcpy(dirs[n_dirs], info_dir);
",unused,e2fsprogdebstretche-lib2Fss2Fhelp.c
"	new_table->info_dirs = (char **)malloc(sizeof(char *));
	*new_table->info_dirs = (char *)NULL;
	new_table->info_ptr = info_ptr;
	new_table->prompt = malloc((unsigned)strlen(subsystem_name)+4);
	strcpy(new_table->prompt, subsystem_name);
",1,unused,63,unused,"	new_table->info_dirs = (char **)malloc(sizeof(char *));
	*new_table->info_dirs = (char *)NULL;
	new_table->info_ptr = info_ptr;
	new_table->prompt = malloc((unsigned)strlen(subsystem_name)+4);
	strcpy(new_table->prompt, subsystem_name);
",unused,e2fsprogdebstretche-lib2Fss2Finvocation.c
"	*new_table->info_dirs = (char *)NULL;
	new_table->info_ptr = info_ptr;
	new_table->prompt = malloc((unsigned)strlen(subsystem_name)+4);
	strcpy(new_table->prompt, subsystem_name);
	strcat(new_table->prompt, "":  "");
",1,unused,64,unused,"	*new_table->info_dirs = (char *)NULL;
	new_table->info_ptr = info_ptr;
	new_table->prompt = malloc((unsigned)strlen(subsystem_name)+4);
	strcpy(new_table->prompt, subsystem_name);
	strcat(new_table->prompt, "":  "");
",unused,e2fsprogdebstretche-lib2Fss2Finvocation.c
"		}
		if (strncmp(*name, text, len) == 0) {
			ret = malloc(strlen(*name)+1);
			if (ret)
				strcpy(ret, *name);
",1,unused,181,unused,"		}
		if (strncmp(*name, text, len) == 0) {
			ret = malloc(strlen(*name)+1);
			if (ret)
				strcpy(ret, *name);
",unused,e2fsprogdebstretche-lib2Fss2Flisten.c
"		fprintf(stderr,
			""Couldn't allocate memory to parse quota options!\n"");
		return -ENOMEM;
	}
	strcpy(buf, opts);
",1,unused,691,unused,"		fprintf(stderr,
			""Couldn't allocate memory to parse quota options!\n"");
		return -ENOMEM;
	}
	strcpy(buf, opts);
",unused,e2fsprogdebstretche-lib2Fsupport2Fmkquota.c
"	len = strlen(in_str);
	buf = malloc(len + 1);
	if (!buf)
		return ENOMEM;
	strcpy(buf, in_str);
",1,unused,31,unused,"	len = strlen(in_str);
	buf = malloc(len + 1);
	if (!buf)
		return ENOMEM;
	strcpy(buf, in_str);
",unused,e2fsprogdebstretche-lib2Fsupport2Fparse_qtype.c
"		} else {
			if (err_token) {
				*err_token = malloc(strlen(token) + 1);
				if (*err_token)
					strcpy(*err_token, token);
",1,unused,61,unused,"		} else {
			if (err_token) {
				*err_token = malloc(strlen(token) + 1);
				if (*err_token)
					strcpy(*err_token, token);
",unused,e2fsprogdebstretche-lib2Fsupport2Fparse_qtype.c
"{
	struct uuid uuid;

	uuid_unpack(uu, &uuid);
	sprintf(out, fmt,
",1,unused,57,unused,"{
	struct uuid uuid;

	uuid_unpack(uu, &uuid);
	sprintf(out, fmt,
",unused,e2fsprogdebstretche-lib2Fuuid2Funparse.c
"	min = diff % 60;
	hr = diff / 60;

	if (hr)
		sprintf(buf, ""%d:%02d:%02d"", hr, min, sec);
",1,unused,197,unused,"	min = diff % 60;
	hr = diff / 60;

	if (hr)
		sprintf(buf, ""%d:%02d:%02d"", hr, min, sec);
",unused,e2fsprogdebstretche-misc2Fbadblocks.c
"
	if (hr)
		sprintf(buf, ""%d:%02d:%02d"", hr, min, sec);
	else
		sprintf(buf, ""%d:%02d"", min, sec);
",1,unused,199,unused,"
	if (hr)
		sprintf(buf, ""%d:%02d:%02d"", hr, min, sec);
	else
		sprintf(buf, ""%d:%02d"", min, sec);
",unused,e2fsprogdebstretche-misc2Fbadblocks.c
"
	str = malloc(strlen(device)+1);
	if (!str)
		return NULL;
	strcpy(str, device);
",1,unused,51,unused,"
	str = malloc(strlen(device)+1);
	if (!str)
		return NULL;
	strcpy(str, device);
",unused,e2fsprogdebstretche-misc2Fbase_device.c
"					  mtpt, sizeof(mtpt));
	if (retval == 0) {
		if (mount_flags & EXT2_MF_MOUNTED) {
			if (!mtpt[0])
				strcpy(mtpt, ""(mounted, mtpt unknown)"");
",1,unused,219,unused,"					  mtpt, sizeof(mtpt));
	if (retval == 0) {
		if (mount_flags & EXT2_MF_MOUNTED) {
			if (!mtpt[0])
				strcpy(mtpt, ""(mounted, mtpt unknown)"");
",unused,e2fsprogdebstretche-misc2Fblkid.c
"		if (mount_flags & EXT2_MF_MOUNTED) {
			if (!mtpt[0])
				strcpy(mtpt, ""(mounted, mtpt unknown)"");
		} else if (mount_flags & EXT2_MF_BUSY)
			strcpy(mtpt, ""(in use)"");
",1,unused,221,unused,"		if (mount_flags & EXT2_MF_MOUNTED) {
			if (!mtpt[0])
				strcpy(mtpt, ""(mounted, mtpt unknown)"");
		} else if (mount_flags & EXT2_MF_BUSY)
			strcpy(mtpt, ""(in use)"");
",unused,e2fsprogdebstretche-misc2Fblkid.c
"				strcpy(mtpt, ""(mounted, mtpt unknown)"");
		} else if (mount_flags & EXT2_MF_BUSY)
			strcpy(mtpt, ""(in use)"");
		else
			strcpy(mtpt, ""(not mounted)"");
",1,unused,223,unused,"				strcpy(mtpt, ""(mounted, mtpt unknown)"");
		} else if (mount_flags & EXT2_MF_BUSY)
			strcpy(mtpt, ""(in use)"");
		else
			strcpy(mtpt, ""(not mounted)"");
",unused,e2fsprogdebstretche-misc2Fblkid.c
"				_(""Couldn't allocate path variable ""
				  ""in chattr_dir_proc""));
			return -1;
		}
		sprintf(path, ""%s/%s"", dir_name, de->d_name);
",1,unused,301,unused,"				_(""Couldn't allocate path variable ""
				  ""in chattr_dir_proc""));
			return -1;
		}
		sprintf(path, ""%s/%s"", dir_name, de->d_name);
",unused,e2fsprogdebstretche-misc2Fchattr.c
"		fprintf(stderr, ""%s"",
			_(""Couldn't allocate memory to parse options!\n""));
		exit(1);
	}
	strcpy(buf, opts);
",1,unused,533,unused,"		fprintf(stderr, ""%s"",
			_(""Couldn't allocate memory to parse options!\n""));
		exit(1);
	}
	strcpy(buf, opts);
",unused,e2fsprogdebstretche-misc2Fdumpe2fs.c
"		end = 1 << (i + info->blocksize_bits - units);
		if (info->histogram.fc_chunks[i] != 0) {
			char end_str[32];

			sprintf(end_str, ""%5lu%c-"", end, *unitp);
",1,unused,195,unused,"		end = 1 << (i + info->blocksize_bits - units);
		if (info->histogram.fc_chunks[i] != 0) {
			char end_str[32];

			sprintf(end_str, ""%5lu%c-"", end, *unitp);
",unused,e2fsprogdebstretche-misc2Fe2freefrag.c
"			char end_str[32];

			sprintf(end_str, ""%5lu%c-"", end, *unitp);
			if (i == MAX_HIST-1)
				strcpy(end_str, ""max "");
",1,unused,197,unused,"			char end_str[32];

			sprintf(end_str, ""%5lu%c-"", end, *unitp);
			if (i == MAX_HIST-1)
				strcpy(end_str, ""max "");
",unused,e2fsprogdebstretche-misc2Fe2freefrag.c
"		exit(1);
	}

	hdr.magic_number = EXT2_ET_MAGIC_E2IMAGE;
	strcpy(hdr.magic_descriptor, ""Ext2 Image 1.0"");
",1,unused,276,unused,"		exit(1);
	}

	hdr.magic_number = EXT2_ET_MAGIC_E2IMAGE;
	strcpy(hdr.magic_descriptor, ""Ext2 Image 1.0"");
",unused,e2fsprogdebstretche-misc2Fe2image.c
"			flags |= E2IMAGE_IS_QCOW2_FLAG;
			goto skip_device;
		}
	}
	sprintf(offset_opt, ""offset=%llu"", source_offset);
",1,unused,1580,unused,"			flags |= E2IMAGE_IS_QCOW2_FLAG;
			goto skip_device;
		}
	}
	sprintf(offset_opt, ""offset=%llu"", source_offset);
",unused,e2fsprogdebstretche-misc2Fe2image.c
"	if (!s)
		return 0;
	ret = malloc(strlen(s)+1);
	if (ret)
		strcpy(ret, s);
",1,unused,165,unused,"	if (!s)
		return 0;
	ret = malloc(strlen(s)+1);
	if (ret)
		strcpy(ret, s);
",unused,e2fsprogdebstretche-misc2Fe2initrd_helper.c
"	if (!tdb_file) {
		free(tmp_name);
		goto errout;
	}
	sprintf(tdb_file, ""%s/e2undo-%s.e2undo"", tdb_dir, dev_name);
",1,unused,258,unused,"	if (!tdb_file) {
		free(tmp_name);
		goto errout;
	}
	sprintf(tdb_file, ""%s/e2undo-%s.e2undo"", tdb_dir, dev_name);
",unused,e2fsprogdebstretche-misc2Fe2undo.c
"	ext2fs_sha512(salt->key, EXT4_MAX_KEY_SIZE, key_ref1);
	ext2fs_sha512(key_ref1, SHA512_LENGTH, key_ref2);
	memcpy(salt->key_desc, key_ref2, EXT4_KEY_DESCRIPTOR_SIZE);
	for (x = 0; x < EXT4_KEY_DESCRIPTOR_SIZE; ++x) {
		sprintf(&salt->key_ref_str[x * 2], ""%02x"",
",1,unused,552,unused,"	ext2fs_sha512(salt->key, EXT4_MAX_KEY_SIZE, key_ref1);
	ext2fs_sha512(key_ref1, SHA512_LENGTH, key_ref2);
	memcpy(salt->key_desc, key_ref2, EXT4_KEY_DESCRIPTOR_SIZE);
	for (x = 0; x < EXT4_KEY_DESCRIPTOR_SIZE; ++x) {
		sprintf(&salt->key_ref_str[x * 2], ""%02x"",
",unused,e2fsprogdebstretche-misc2Fe4crypt.c
"	if (keyring_id == 0) {
		printf(""Invalid keyring [%s].\n"", keyring);
		exit(1);
	}
	sprintf(key_ref_full, ""%s%s"", EXT2FS_KEY_DESC_PREFIX,
",1,unused,570,unused,"	if (keyring_id == 0) {
		printf(""Invalid keyring [%s].\n"", keyring);
		exit(1);
	}
	sprintf(key_ref_full, ""%s%s"", EXT2FS_KEY_DESC_PREFIX,
",unused,e2fsprogdebstretche-misc2Fe4crypt.c
"		       argv[optind], (EXT4_KEY_DESCRIPTOR_SIZE * 2));
			exit(1);
	}
	validate_paths(argc, argv, optind+1);
	strcpy(saltbuf.key_ref_str, argv[optind]);
",1,unused,739,unused,"		       argv[optind], (EXT4_KEY_DESCRIPTOR_SIZE * 2));
			exit(1);
	}
	validate_paths(argc, argv, optind+1);
	strcpy(saltbuf.key_ref_str, argv[optind]);
",unused,e2fsprogdebstretche-misc2Fe4crypt.c
"	}

	if (mode_flag & DETAIL) {
		/* Print statistic info */
		sprintf(msg_buffer, ""[%u/%u]%s"",
",1,unused,1211,unused,"	}

	if (mode_flag & DETAIL) {
		/* Print statistic info */
		sprintf(msg_buffer, ""[%u/%u]%s"",
",unused,e2fsprogdebstretche-misc2Fe4defrag.c
"	}

	/* Create donor inode */
	memset(tmp_inode_name, 0, PATH_MAX + 8);
	sprintf(tmp_inode_name, ""%.*s.defrag"",
",1,unused,1529,unused,"	}

	/* Create donor inode */
	memset(tmp_inode_name, 0, PATH_MAX + 8);
	sprintf(tmp_inode_name, ""%.*s.defrag"",
",unused,e2fsprogdebstretche-misc2Fe4defrag.c
"{
	if ((*flags & mask) == 0)
		return;

	strcat(buf, name);
",1,unused,134,unused,"{
	if ((*flags & mask) == 0)
		return;

	strcat(buf, name);
",unused,e2fsprogdebstretche-misc2Ffilefrag.c
"		physical_blk = fm_extent->fe_physical >> blk_shift;
	}

	if (expected)
		sprintf(flags, ext_fmt == hex_fmt ? ""%*llx: "" : ""%*llu: "",
",1,unused,163,unused,"		physical_blk = fm_extent->fe_physical >> blk_shift;
	}

	if (expected)
		sprintf(flags, ext_fmt == hex_fmt ? ""%*llx: "" : ""%*llu: "",
",unused,e2fsprogdebstretche-misc2Ffilefrag.c
"	if (expected)
		sprintf(flags, ext_fmt == hex_fmt ? ""%*llx: "" : ""%*llu: "",
			physical_width, expected >> blk_shift);
	else
		sprintf(flags, ""%.*s  "", physical_width, ""                   "");
",1,unused,166,unused,"	if (expected)
		sprintf(flags, ext_fmt == hex_fmt ? ""%*llx: "" : ""%*llu: "",
			physical_width, expected >> blk_shift);
	else
		sprintf(flags, ""%.*s  "", physical_width, ""                   "");
",unused,e2fsprogdebstretche-misc2Ffilefrag.c
"		char hex[6];

		if ((fe_flags & mask) == 0)
			continue;
		sprintf(hex, ""%#04x,"", mask);
",1,unused,186,unused,"		char hex[6];

		if ((fe_flags & mask) == 0)
			continue;
		sprintf(hex, ""%#04x,"", mask);
",unused,e2fsprogdebstretche-misc2Ffilefrag.c
"	}

	if (fm_extent->fe_logical + fm_extent->fe_length >=
	    (unsigned long long) st->st_size)
		strcat(flags, ""eof,"");
",1,unused,192,unused,"	}

	if (fm_extent->fe_logical + fm_extent->fe_length >=
	    (unsigned long long) st->st_size)
		strcat(flags, ""eof,"");
",unused,e2fsprogdebstretche-misc2Ffilefrag.c
"	if ( WIFEXITED(status) ) {
		rc = WEXITSTATUS(status);
		if (rc) {
			send_output(argv[0], 0, SEND_BOTH);
			sprintf(buffer, "" exited with status code %d\n"", rc);
",1,unused,213,unused,"	if ( WIFEXITED(status) ) {
		rc = WEXITSTATUS(status);
		if (rc) {
			send_output(argv[0], 0, SEND_BOTH);
			sprintf(buffer, "" exited with status code %d\n"", rc);
",unused,e2fsprogdebstretche-misc2Flogsave.c
"		}
	} else {
		if (WIFSIGNALED(status)) {
			send_output(argv[0], 0, SEND_BOTH);
			sprintf(buffer, ""died with signal %d\n"",
",1,unused,219,unused,"		}
	} else {
		if (WIFSIGNALED(status)) {
			send_output(argv[0], 0, SEND_BOTH);
			sprintf(buffer, ""died with signal %d\n"",
",unused,e2fsprogdebstretche-misc2Flogsave.c
"
	path = malloc(dir_len + strlen (de->d_name) + 2);

	if (dir_len && dir_name[dir_len-1] == '/')
		sprintf (path, ""%s%s"", dir_name, de->d_name);
",1,unused,149,unused,"
	path = malloc(dir_len + strlen (de->d_name) + 2);

	if (dir_len && dir_name[dir_len-1] == '/')
		sprintf (path, ""%s%s"", dir_name, de->d_name);
",unused,e2fsprogdebstretche-misc2Flsattr.c
"
	if (dir_len && dir_name[dir_len-1] == '/')
		sprintf (path, ""%s%s"", dir_name, de->d_name);
	else
		sprintf (path, ""%s/%s"", dir_name, de->d_name);
",1,unused,151,unused,"
	if (dir_len && dir_name[dir_len-1] == '/')
		sprintf (path, ""%s%s"", dir_name, de->d_name);
	else
		sprintf (path, ""%s/%s"", dir_name, de->d_name);
",unused,e2fsprogdebstretche-misc2Flsattr.c
"	if (!cp)
		return 0;
	if (strlen(path) > SYSFS_PATH_LEN - sizeof(""/start""))
		return 0;
	strcat(path, ""/start"");
",1,unused,194,unused,"	if (!cp)
		return 0;
	if (strlen(path) > SYSFS_PATH_LEN - sizeof(""/start""))
		return 0;
	strcat(path, ""/start"");
",unused,e2fsprogdebstretche-misc2Fmk_hugefiles.c
"	fn = malloc(strlen(dir) + 1);
	if (fn == NULL)
		return ENOMEM;

	strcpy(fn, dir);
",1,unused,217,unused,"	fn = malloc(strlen(dir) + 1);
	if (fn == NULL)
		return ENOMEM;

	strcpy(fn, dir);
",unused,e2fsprogdebstretche-misc2Fmk_hugefiles.c
"	if (retval)
		goto errout;

	if (idx_digits)
		sprintf(fn_numbuf, ""%0*lu"", idx_digits, idx);
",1,unused,299,unused,"	if (retval)
		goto errout;

	if (idx_digits)
		sprintf(fn_numbuf, ""%0*lu"", idx_digits, idx);
",unused,e2fsprogdebstretche-misc2Fmk_hugefiles.c
"
	if (idx_digits)
		sprintf(fn_numbuf, ""%0*lu"", idx_digits, idx);
	else if (num_files > 1)
		sprintf(fn_numbuf, ""%lu"", idx);
",1,unused,301,unused,"
	if (idx_digits)
		sprintf(fn_numbuf, ""%0*lu"", idx_digits, idx);
	else if (num_files > 1)
		sprintf(fn_numbuf, ""%lu"", idx);
",unused,e2fsprogdebstretche-misc2Fmk_hugefiles.c
"	if (!fn_buf) {
		free(fn_prefix);
		return ENOMEM;
	}
	strcpy(fn_buf, fn_prefix);
",1,unused,453,unused,"	if (!fn_buf) {
		free(fn_prefix);
		return ENOMEM;
	}
	strcpy(fn_buf, fn_prefix);
",unused,e2fsprogdebstretche-misc2Fmk_hugefiles.c
"	FILE		*f;
	errcode_t	retval;
	char		buf[1024];

	sprintf(buf, ""badblocks -b %d -X %s%s%s %llu"", fs->blocksize,
",1,unused,251,unused,"	FILE		*f;
	errcode_t	retval;
	char		buf[1024];

	sprintf(buf, ""badblocks -b %d -X %s%s%s %llu"", fs->blocksize,
",unused,e2fsprogdebstretche-misc2Fmke2fs.c
"		fprintf(stderr, ""%s"",
			_(""Couldn't allocate memory to parse options!\n""));
		exit(1);
	}
	strcpy(buf, opts);
",1,unused,789,unused,"		fprintf(stderr, ""%s"",
			_(""Couldn't allocate memory to parse options!\n""));
		exit(1);
	}
	strcpy(buf, opts);
",unused,e2fsprogdebstretche-misc2Fmke2fs.c
"	}
	sl->list[sl->num] = malloc(strlen(str)+1);
	if (sl->list[sl->num] == 0)
		return ENOMEM;
	strcpy(sl->list[sl->num], str);
",1,unused,1164,unused,"	}
	sl->list[sl->num] = malloc(strlen(str)+1);
	if (sl->list[sl->num] == 0)
		return ENOMEM;
	strcpy(sl->list[sl->num], str);
",unused,e2fsprogdebstretche-misc2Fmke2fs.c
"		free(profile_type);
		free(list.list);
		return 0;
	}
	strcpy(parse_str, usage_types);
",1,unused,1297,unused,"		free(profile_type);
		free(list.list);
		return 0;
	}
	strcpy(parse_str, usage_types);
",unused,e2fsprogdebstretche-misc2Fmke2fs.c
"		fprintf(stderr, ""%s"",
			_(""Couldn't allocate memory for new PATH.\n""));
		exit(1);
	}
	strcpy(newpath, PATH_SET);
",1,unused,1497,unused,"		fprintf(stderr, ""%s"",
			_(""Couldn't allocate memory for new PATH.\n""));
		exit(1);
	}
	strcpy(newpath, PATH_SET);
",unused,e2fsprogdebstretche-misc2Fmke2fs.c
"	strcpy(newpath, PATH_SET);

	/* Update our PATH to include /sbin  */
	if (oldpath) {
		strcat (newpath, "":"");
",1,unused,1501,unused,"	strcpy(newpath, PATH_SET);

	/* Update our PATH to include /sbin  */
	if (oldpath) {
		strcat (newpath, "":"");
",unused,e2fsprogdebstretche-misc2Fmke2fs.c
"
	/* Update our PATH to include /sbin  */
	if (oldpath) {
		strcat (newpath, "":"");
		strcat (newpath, oldpath);
",1,unused,1502,unused,"
	/* Update our PATH to include /sbin  */
	if (oldpath) {
		strcat (newpath, "":"");
		strcat (newpath, oldpath);
",unused,e2fsprogdebstretche-misc2Fmke2fs.c
"				com_err(program_name, ENOMEM, ""%s"",
					_(""in malloc for bad_blocks_filename""));
				exit(1);
			}
			strcpy(bad_blocks_filename, optarg);
",1,unused,1698,unused,"				com_err(program_name, ENOMEM, ""%s"",
					_(""in malloc for bad_blocks_filename""));
				exit(1);
			}
			strcpy(bad_blocks_filename, optarg);
",unused,e2fsprogdebstretche-misc2Fmke2fs.c
"				     _(""while allocating fs_feature string""));
				exit(1);
			}
			if (fs_features_size)
				strcat(fs_features, "","");
",1,unused,1745,unused,"				     _(""while allocating fs_feature string""));
				exit(1);
			}
			if (fs_features_size)
				strcat(fs_features, "","");
",unused,e2fsprogdebstretche-misc2Fmke2fs.c
"			if (fs_features_size)
				strcat(fs_features, "","");
			else
				fs_features[0] = 0;
			strcat(fs_features, optarg);
",1,unused,1748,unused,"			if (fs_features_size)
				strcat(fs_features, "","");
			else
				fs_features[0] = 0;
			strcat(fs_features, optarg);
",unused,e2fsprogdebstretche-misc2Fmke2fs.c
"	if (!tdb_file) {
		free(tmp_name);
		goto errout;
	}
	sprintf(tdb_file, ""%s/mke2fs-%s.e2undo"", tdb_dir, dev_name);
",1,unused,2594,unused,"	if (!tdb_file) {
		free(tmp_name);
		goto errout;
	}
	sprintf(tdb_file, ""%s/mke2fs-%s.e2undo"", tdb_dir, dev_name);
",unused,e2fsprogdebstretche-misc2Fmke2fs.c
"	if (!journal_device && ((journal_size) ||
	    ext2fs_has_feature_journal(&fs_param)))
		journal_blocks = figure_journal_size(journal_size, fs);

	sprintf(opt_string, ""tdb_data_size=%d"", fs->blocksize <= 4096 ?
",1,unused,2874,unused,"	if (!journal_device && ((journal_size) ||
	    ext2fs_has_feature_journal(&fs_param)))
		journal_blocks = figure_journal_size(journal_size, fs);

	sprintf(opt_string, ""tdb_data_size=%d"", fs->blocksize <= 4096 ?
",unused,e2fsprogdebstretche-misc2Fmke2fs.c
"	sprintf(opt_string, ""tdb_data_size=%d"", fs->blocksize <= 4096 ?
		32768 : fs->blocksize * 8);
	io_channel_set_options(fs->io, opt_string);
	if (offset) {
		sprintf(opt_string, ""offset=%llu"", offset);
",1,unused,2878,unused,"	sprintf(opt_string, ""tdb_data_size=%d"", fs->blocksize <= 4096 ?
		32768 : fs->blocksize * 8);
	io_channel_set_options(fs->io, opt_string);
	if (offset) {
		sprintf(opt_string, ""offset=%llu"", offset);
",unused,e2fsprogdebstretche-misc2Fmke2fs.c
"		fprintf(stderr, ""%s"",
			_(""Couldn't allocate memory to parse options!\n""));
		return 1;
	}
	strcpy(buf, opts);
",1,unused,1933,unused,"		fprintf(stderr, ""%s"",
			_(""Couldn't allocate memory to parse options!\n""));
		return 1;
	}
	strcpy(buf, opts);
",unused,e2fsprogdebstretche-misc2Ftune2fs.c
"	if (!tdb_file) {
		free(tmp_name);
		goto errout;
	}
	sprintf(tdb_file, ""%s/tune2fs-%s.e2undo"", tdb_dir, dev_name);
",1,unused,2638,unused,"	if (!tdb_file) {
		free(tmp_name);
		goto errout;
	}
	sprintf(tdb_file, ""%s/tune2fs-%s.e2undo"", tdb_dir, dev_name);
",unused,e2fsprogdebstretche-misc2Ftune2fs.c
"		fputs(_(""Couldn't allocate memory to parse journal ""
			""options!\n""), stderr);
		exit(1);
	}
	strcpy(buf, opts);
",1,unused,165,unused,"		fputs(_(""Couldn't allocate memory to parse journal ""
			""options!\n""), stderr);
		exit(1);
	}
	strcpy(buf, opts);
",unused,e2fsprogdebstretche-misc2Futil.c
"	signal(SIGTERM, terminate_intr);
	signal(SIGALRM, terminate_intr);
	signal(SIGPIPE, SIG_IGN);

	sprintf(reply_buf, ""%8d\n"", getpid());
",1,unused,331,unused,"	signal(SIGTERM, terminate_intr);
	signal(SIGALRM, terminate_intr);
	signal(SIGPIPE, SIG_IGN);

	sprintf(reply_buf, ""%8d\n"", getpid());
",unused,e2fsprogdebstretche-misc2Fuuidd.c
"			printf(""operation %d\n"", op);

		switch(op) {
		case UUIDD_OP_GETPID:
			sprintf(reply_buf, ""%d"", getpid());
",1,unused,369,unused,"			printf(""operation %d\n"", op);

		switch(op) {
		case UUIDD_OP_GETPID:
			sprintf(reply_buf, ""%d"", getpid());
",unused,e2fsprogdebstretche-misc2Fuuidd.c
"			sprintf(reply_buf, ""%d"", getpid());
			reply_len = strlen(reply_buf)+1;
			break;
		case UUIDD_OP_GET_MAXOP:
			sprintf(reply_buf, ""%d"", UUIDD_MAX_OP);
",1,unused,373,unused,"			sprintf(reply_buf, ""%d"", getpid());
			reply_len = strlen(reply_buf)+1;
			break;
		case UUIDD_OP_GET_MAXOP:
			sprintf(reply_buf, ""%d"", UUIDD_MAX_OP);
",unused,e2fsprogdebstretche-misc2Fuuidd.c
"	if (!tdb_file) {
		free(tmp_name);
		goto errout;
	}
	sprintf(tdb_file, ""%s/resize2fs-%s.e2undo"", tdb_dir, dev_name);
",1,unused,215,unused,"	if (!tdb_file) {
		free(tmp_name);
		goto errout;
	}
	sprintf(tdb_file, ""%s/resize2fs-%s.e2undo"", tdb_dir, dev_name);
",unused,e2fsprogdebstretche-resize2Fmain.c
"	if (retval) {
		free(prog);
		return retval;
	}
	strcpy(prog->label, label);
",1,unused,96,unused,"	if (retval) {
		free(prog);
		return retval;
	}
	strcpy(prog->label, label);
",unused,e2fsprogdebstretche-resize2Fsim_progress.c
"		goto fail;
	ent->value = (char *) malloc(strlen(value)+1);
	if (!ent->value)
		goto fail;
	strcpy(ent->name, name);
",1,unused,64,unused,"		goto fail;
	ent->value = (char *) malloc(strlen(value)+1);
	if (!ent->value)
		goto fail;
	strcpy(ent->name, name);
",unused,e2fsprogdebstretche-util2Fsubst.c
"	ent->value = (char *) malloc(strlen(value)+1);
	if (!ent->value)
		goto fail;
	strcpy(ent->name, name);
	strcpy(ent->value, value);
",1,unused,65,unused,"	ent->value = (char *) malloc(strlen(value)+1);
	if (!ent->value)
		goto fail;
	strcpy(ent->name, name);
	strcpy(ent->value, value);
",unused,e2fsprogdebstretche-util2Fsubst.c
"		if (!newfn) {
			fprintf(stderr, ""Memory error!  Exiting.\n"");
			exit(1);
		}
		strcpy(newfn, outfn);
",1,unused,375,unused,"		if (!newfn) {
			fprintf(stderr, ""Memory error!  Exiting.\n"");
			exit(1);
		}
		strcpy(newfn, outfn);
",unused,e2fsprogdebstretche-util2Fsubst.c
"			fprintf(stderr, ""Memory error!  Exiting.\n"");
			exit(1);
		}
		strcpy(newfn, outfn);
		strcat(newfn, "".new"");
",1,unused,376,unused,"			fprintf(stderr, ""Memory error!  Exiting.\n"");
			exit(1);
		}
		strcpy(newfn, outfn);
		strcat(newfn, "".new"");
",unused,e2fsprogdebstretche-util2Fsubst.c
"	if (!tdb_file) {
		free(tmp_name);
		goto errout;
	}
	sprintf(tdb_file, ""%s/debugfs-%s.e2undo"", tdb_dir, dev_name);
",1,unused,103,unused,"	if (!tdb_file) {
		free(tmp_name);
		goto errout;
	}
	sprintf(tdb_file, ""%s/debugfs-%s.e2undo"", tdb_dir, dev_name);
",unused,e2fsprogsources-debugfs2Fdebugfs.c
"	char buf[200];
	unsigned long v;
	char *tmp;

	sprintf(buf, format, *val);
",1,unused,1258,unused,"	char buf[200];
	unsigned long v;
	char *tmp;

	sprintf(buf, format, *val);
",unused,e2fsprogsources-debugfs2Fdebugfs.c
"	char buf[200];
	unsigned long v;
	char *tmp;

	sprintf(buf, format, *val);
",1,unused,1280,unused,"	char buf[200];
	unsigned long v;
	char *tmp;

	sprintf(buf, format, *val);
",unused,e2fsprogsources-debugfs2Fdebugfs.c
"	char buf[200];
	unsigned long v;
	char *tmp;

	sprintf(buf, format, *val);
",1,unused,1302,unused,"	char buf[200];
	unsigned long v;
	char *tmp;

	sprintf(buf, format, *val);
",unused,e2fsprogsources-debugfs2Fdebugfs.c
"	if (fsize)
		modify_u8(argv[0], ""Fragment size"", decimal_format, fsize);

	for (i=0;  i < EXT2_NDIR_BLOCKS; i++) {
		sprintf(buf, ""Direct Block #%d"", i);
",1,unused,1381,unused,"	if (fsize)
		modify_u8(argv[0], ""Fragment size"", decimal_format, fsize);

	for (i=0;  i < EXT2_NDIR_BLOCKS; i++) {
		sprintf(buf, ""Direct Block #%d"", i);
",unused,e2fsprogsources-debugfs2Fdebugfs.c
"		com_err(argv[1], retval, ""out of memory"");
		return;
	}

	strcpy(extent_prompt, orig_prompt);
",1,unused,105,unused,"		com_err(argv[1], retval, ""out of memory"");
		return;
	}

	strcpy(extent_prompt, orig_prompt);
",unused,e2fsprogsources-debugfs2Fextent_inode.c
"	strcpy(extent_prompt, orig_prompt);
	cp = strchr(extent_prompt, ':');
	if (cp)
		*cp = 0;
	sprintf(extent_prompt + strlen(extent_prompt), "" (extent ino %d): "",
",1,unused,109,unused,"	strcpy(extent_prompt, orig_prompt);
	cp = strchr(extent_prompt, ':');
	if (cp)
		*cp = 0;
	sprintf(extent_prompt + strlen(extent_prompt), "" (extent ino %d): "",
",unused,e2fsprogsources-debugfs2Fextent_inode.c
"			fs->dir_name, name);
		return 0;
	}

	sprintf(cp, ""%s/%s"", fs->dir_name, name);
",1,unused,202,unused,"			fs->dir_name, name);
		return 0;
	}

	sprintf(cp, ""%s/%s"", fs->dir_name, name);
",unused,e2fsprogsources-debugfs2Ffilefrag.c
"			if (debugfs_read_inode(ino, &inode, ""ls""))
				return 0;
			modtime = inode.i_mtime;
			tm_p = localtime(&modtime);
			sprintf(datestr, ""%2d-%s-%4d %02d:%02d"",
",1,unused,138,unused,"			if (debugfs_read_inode(ino, &inode, ""ls""))
				return 0;
			modtime = inode.i_mtime;
			tm_p = localtime(&modtime);
			sprintf(datestr, ""%2d-%s-%4d %02d:%02d"",
",unused,e2fsprogsources-debugfs2Fls.c
"				tm_p->tm_mday, monstr[tm_p->tm_mon],
				1900 + tm_p->tm_year, tm_p->tm_hour,
				tm_p->tm_min);
		} else {
			strcpy(datestr, ""                 "");
",1,unused,143,unused,"				tm_p->tm_mday, monstr[tm_p->tm_mon],
				1900 + tm_p->tm_year, tm_p->tm_hour,
				tm_p->tm_min);
		} else {
			strcpy(datestr, ""                 "");
",unused,e2fsprogsources-debugfs2Fls.c
"		print_filename(ls->f, dirent, options);
		fputc('\n', ls->f);
	} else {
		if (entry == DIRENT_CHECKSUM) {
			sprintf(tmp, ""%c%u%c (dirblock checksum: 0x%08x)   "",
",1,unused,164,unused,"		print_filename(ls->f, dirent, options);
		fputc('\n', ls->f);
	} else {
		if (entry == DIRENT_CHECKSUM) {
			sprintf(tmp, ""%c%u%c (dirblock checksum: 0x%08x)   "",
",unused,e2fsprogsources-debugfs2Fls.c
"			fprintf(ls->f, ""%s"", tmp);
			ls->col += thislen;
			return 0;
		}
		sprintf(tmp, ""%c%u%c (%d) "", lbr, dirent->inode, rbr,
",1,unused,175,unused,"			fprintf(ls->f, ""%s"", tmp);
			ls->col += thislen;
			return 0;
		}
		sprintf(tmp, ""%c%u%c (%d) "", lbr, dirent->inode, rbr,
",unused,e2fsprogsources-debugfs2Fls.c
"
	arg = malloc(strlen(field)+1);
	if (!arg)
		return NULL;
	strcpy(arg, field);
",1,unused,381,unused,"
	arg = malloc(strlen(field)+1);
	if (!arg)
		return NULL;
	strcpy(arg, field);
",unused,e2fsprogsources-debugfs2Fset_fields.c
"		fprintf(stderr, ""Error maximum size for %s is %d.\n"",
			info->name, info->size);
		return EINVAL;
	}
	strcpy(cp, arg);
",1,unused,561,unused,"		fprintf(stderr, ""Error maximum size for %s is %d.\n"",
			info->name, info->size);
		return EINVAL;
	}
	strcpy(cp, arg);
",unused,e2fsprogsources-debugfs2Fset_fields.c
"		else if (ss->func == parse_bmap)
			type = ""set physical->logical block map"";
		else if (ss->func == parse_gd_csum)
			type = ""unsigned integer OR \""calc\"""";
		strcpy(name, ss->name);
",1,unused,706,unused,"		else if (ss->func == parse_bmap)
			type = ""set physical->logical block map"";
		else if (ss->func == parse_gd_csum)
			type = ""unsigned integer OR \""calc\"""";
		strcpy(name, ss->name);
",unused,e2fsprogsources-debugfs2Fset_fields.c
"			type = ""unsigned integer OR \""calc\"""";
		strcpy(name, ss->name);
		if (ss->flags & FLAG_ARRAY) {
			if (ss->max_idx > 0)
				sprintf(idx, ""[%d]"", ss->max_idx);
",1,unused,709,unused,"			type = ""unsigned integer OR \""calc\"""";
		strcpy(name, ss->name);
		if (ss->flags & FLAG_ARRAY) {
			if (ss->max_idx > 0)
				sprintf(idx, ""[%d]"", ss->max_idx);
",unused,e2fsprogsources-debugfs2Fset_fields.c
"		if (ss->flags & FLAG_ARRAY) {
			if (ss->max_idx > 0)
				sprintf(idx, ""[%d]"", ss->max_idx);
			else
				strcpy(idx, ""[]"");
",1,unused,711,unused,"		if (ss->flags & FLAG_ARRAY) {
			if (ss->max_idx > 0)
				sprintf(idx, ""[%d]"", ss->max_idx);
			else
				strcpy(idx, ""[]"");
",unused,e2fsprogsources-debugfs2Fset_fields.c
"			if (ss->max_idx > 0)
				sprintf(idx, ""[%d]"", ss->max_idx);
			else
				strcpy(idx, ""[]"");
			strcat(name, idx);
",1,unused,712,unused,"			if (ss->max_idx > 0)
				sprintf(idx, ""[%d]"", ss->max_idx);
			else
				strcpy(idx, ""[]"");
			strcat(name, idx);
",unused,e2fsprogsources-debugfs2Fset_fields.c
"				strcpy(idx, ""[]"");
			strcat(name, idx);
		}
		if (ss->ptr2)
			strcat(name, ""[_hi|_lo]"");
",1,unused,715,unused,"				strcpy(idx, ""[]"");
			strcat(name, idx);
		}
		if (ss->ptr2)
			strcat(name, ""[_hi|_lo]"");
",unused,e2fsprogsources-debugfs2Fset_fields.c
"	const char **i, **j;

	for (i = pager_search_list; *i; i++) {
		for (j = pager_dir_list; *j; j++) {
			sprintf(buf, ""%s/%s"", *j, *i);
",1,unused,72,unused,"	const char **i, **j;

	for (i = pager_search_list; *i; i++) {
		for (j = pager_dir_list; *j; j++) {
			sprintf(buf, ""%s/%s"", *j, *i);
",unused,e2fsprogsources-debugfs2Futil.c
"				_(""while trying to open %s""), bad_blocks_file);
			goto fatal;
		}
	} else {
		sprintf(buf, ""badblocks -b %d -X %s%s%s %llu"", fs->blocksize,
",1,unused,76,unused,"				_(""while trying to open %s""), bad_blocks_file);
			goto fatal;
		}
	} else {
		sprintf(buf, ""badblocks -b %d -X %s%s%s %llu"", fs->blocksize,
",unused,e2fsprogsources-e2fsck2Fbadblocks.c
"	if (retval)
		return;

	uuid_unparse(ctx->fs->super->s_uuid, uuid);
	sprintf(db->tdb_fn, ""%s/%s-dirinfo-XXXXXX"", tdb_dir, uuid);
",1,unused,71,unused,"	if (retval)
		return;

	uuid_unparse(ctx->fs->super->s_uuid, uuid);
	sprintf(db->tdb_fn, ""%s/%s-dirinfo-XXXXXX"", tdb_dir, uuid);
",unused,e2fsprogsources-e2fsck2Fdirinfo.c
"	case '%':
		append_string(s, ""%"", 1);
		return;
	case 'd':
		sprintf(buf, ""%02d"", tm->tm_mday);
",1,unused,90,unused,"	case '%':
		append_string(s, ""%"", 1);
		return;
	case 'd':
		sprintf(buf, ""%02d"", tm->tm_mday);
",unused,e2fsprogsources-e2fsck2Flogfile.c
"	case 'd':
		sprintf(buf, ""%02d"", tm->tm_mday);
		break;
	case 'D':
		sprintf(buf, ""%d%02d%02d"", tm->tm_year + 1900, tm->tm_mon + 1,
",1,unused,93,unused,"	case 'd':
		sprintf(buf, ""%02d"", tm->tm_mday);
		break;
	case 'D':
		sprintf(buf, ""%d%02d%02d"", tm->tm_year + 1900, tm->tm_mon + 1,
",unused,e2fsprogsources-e2fsck2Flogfile.c
"		buf[sizeof(buf)-1] = 0;
#endif
		break;
	case 'H':
		sprintf(buf, ""%02d"", tm->tm_hour);
",1,unused,106,unused,"		buf[sizeof(buf)-1] = 0;
#endif
		break;
	case 'H':
		sprintf(buf, ""%02d"", tm->tm_hour);
",unused,e2fsprogsources-e2fsck2Flogfile.c
"	case 'H':
		sprintf(buf, ""%02d"", tm->tm_hour);
		break;
	case 'm':
		sprintf(buf, ""%02d"", tm->tm_mon + 1);
",1,unused,109,unused,"	case 'H':
		sprintf(buf, ""%02d"", tm->tm_hour);
		break;
	case 'm':
		sprintf(buf, ""%02d"", tm->tm_mon + 1);
",unused,e2fsprogsources-e2fsck2Flogfile.c
"	case 'm':
		sprintf(buf, ""%02d"", tm->tm_mon + 1);
		break;
	case 'M':
		sprintf(buf, ""%02d"", tm->tm_min);
",1,unused,112,unused,"	case 'm':
		sprintf(buf, ""%02d"", tm->tm_mon + 1);
		break;
	case 'M':
		sprintf(buf, ""%02d"", tm->tm_min);
",unused,e2fsprogsources-e2fsck2Flogfile.c
"			cp = ctx->filesystem_name;
		append_string(s, cp, 0);
		return;
	case 'p':
		sprintf(buf, ""%lu"", (unsigned long) getpid());
",1,unused,123,unused,"			cp = ctx->filesystem_name;
		append_string(s, cp, 0);
		return;
	case 'p':
		sprintf(buf, ""%lu"", (unsigned long) getpid());
",unused,e2fsprogsources-e2fsck2Flogfile.c
"	case 'p':
		sprintf(buf, ""%lu"", (unsigned long) getpid());
		break;
	case 's':
		sprintf(buf, ""%lu"", (unsigned long) ctx->now);
",1,unused,126,unused,"	case 'p':
		sprintf(buf, ""%lu"", (unsigned long) getpid());
		break;
	case 's':
		sprintf(buf, ""%lu"", (unsigned long) ctx->now);
",unused,e2fsprogsources-e2fsck2Flogfile.c
"	case 's':
		sprintf(buf, ""%lu"", (unsigned long) ctx->now);
		break;
	case 'S':
		sprintf(buf, ""%02d"", tm->tm_sec);
",1,unused,129,unused,"	case 's':
		sprintf(buf, ""%lu"", (unsigned long) ctx->now);
		break;
	case 'S':
		sprintf(buf, ""%02d"", tm->tm_sec);
",unused,e2fsprogsources-e2fsck2Flogfile.c
"	case 'S':
		sprintf(buf, ""%02d"", tm->tm_sec);
		break;
	case 'T':
		sprintf(buf, ""%02d%02d%02d"", tm->tm_hour, tm->tm_min,
",1,unused,132,unused,"	case 'S':
		sprintf(buf, ""%02d"", tm->tm_sec);
		break;
	case 'T':
		sprintf(buf, ""%02d%02d%02d"", tm->tm_hour, tm->tm_min,
",unused,e2fsprogsources-e2fsck2Flogfile.c
"	case 'U':
		*flags |= FLAG_UTC;
		return;
	case 'y':
		sprintf(buf, ""%02d"", tm->tm_year % 100);
",1,unused,153,unused,"	case 'U':
		*flags |= FLAG_UTC;
		return;
	case 'y':
		sprintf(buf, ""%02d"", tm->tm_year % 100);
",unused,e2fsprogsources-e2fsck2Flogfile.c
"	case 'y':
		sprintf(buf, ""%02d"", tm->tm_year % 100);
		break;
	case 'Y':
		sprintf(buf, ""%d"", tm->tm_year + 1900);
",1,unused,156,unused,"	case 'y':
		sprintf(buf, ""%02d"", tm->tm_year % 100);
		break;
	case 'Y':
		sprintf(buf, ""%d"", tm->tm_year + 1900);
",unused,e2fsprogsources-e2fsck2Flogfile.c
"
#if 0
		printf(""%u "", pctx.ino);
#endif
		sprintf(buf, _(""reading indirect blocks of inode %u""),
",1,unused,2128,unused,"
#if 0
		printf(""%u "", pctx.ino);
#endif
		sprintf(buf, _(""reading indirect blocks of inode %u""),
",unused,e2fsprogsources-e2fsck2Fpass1.c
"		fix_problem(ctx, PR_3_NO_LPF, &pctx);
		return 1;
	}

	sprintf(name, ""#%u"", ino);
",1,unused,613,unused,"		fix_problem(ctx, PR_3_NO_LPF, &pctx);
		return 1;
	}

	sprintf(name, ""#%u"", ino);
",unused,e2fsprogsources-e2fsck2Fpass3.c
"	}
	if (!(ptr->flags & PR_CONFIG)) {
		char	key[9], *new_desc = NULL;

		sprintf(key, ""0x%06x"", code);
",1,unused,2180,unused,"	}
	if (!(ptr->flags & PR_CONFIG)) {
		char	key[9], *new_desc = NULL;

		sprintf(key, ""0x%06x"", code);
",unused,e2fsprogsources-e2fsck2Fproblem.c
"
		newpath = malloc(len);
		if (!newpath)
			fatal_error(ctx, ""Couldn't malloc() newpath"");
		strcpy(newpath, PATH_SET);
",1,unused,1113,unused,"
		newpath = malloc(len);
		if (!newpath)
			fatal_error(ctx, ""Couldn't malloc() newpath"");
		strcpy(newpath, PATH_SET);
",unused,e2fsprogsources-e2fsck2Funix.c
"			fatal_error(ctx, ""Couldn't malloc() newpath"");
		strcpy(newpath, PATH_SET);

		if (oldpath) {
			strcat(newpath, "":"");
",1,unused,1116,unused,"			fatal_error(ctx, ""Couldn't malloc() newpath"");
		strcpy(newpath, PATH_SET);

		if (oldpath) {
			strcat(newpath, "":"");
",unused,e2fsprogsources-e2fsck2Funix.c
"		strcpy(newpath, PATH_SET);

		if (oldpath) {
			strcat(newpath, "":"");
			strcat(newpath, oldpath);
",1,unused,1117,unused,"		strcpy(newpath, PATH_SET);

		if (oldpath) {
			strcat(newpath, "":"");
			strcat(newpath, oldpath);
",unused,e2fsprogsources-e2fsck2Funix.c
"	if (!tdb_file) {
		free(tmp_name);
		goto errout;
	}
	sprintf(tdb_file, ""%s/e2fsck-%s.e2undo"", tdb_dir, dev_name);
",1,unused,1321,unused,"	if (!tdb_file) {
		free(tmp_name);
		goto errout;
	}
	sprintf(tdb_file, ""%s/e2fsck-%s.e2undo"", tdb_dir, dev_name);
",unused,e2fsprogsources-e2fsck2Funix.c
"	printf(""Allocating %u bytes for %s...\n"", size, description);
#endif
	ret = malloc(size);
	if (!ret) {
		sprintf(buf, ""Can't allocate %u bytes for %s\n"",
",1,unused,130,unused,"	printf(""Allocating %u bytes for %s...\n"", size, description);
#endif
	ret = malloc(size);
	if (!ret) {
		sprintf(buf, ""Can't allocate %u bytes for %s\n"",
",unused,e2fsprogsources-e2fsck2Futil.c
"		free(new_type);
		free(new_value);
		return -1;
	}
	strcpy(new_type, search_type);
",1,unused,144,unused,"		free(new_type);
		free(new_value);
		return -1;
	}
	strcpy(new_type, search_type);
",unused,e2fsprogsources-lib2Fblkid2Fdev.c
"		free(new_value);
		return -1;
	}
	strcpy(new_type, search_type);
	strcpy(new_value, search_value);
",1,unused,145,unused,"		free(new_value);
		return -1;
	}
	strcpy(new_type, search_type);
	strcpy(new_value, search_value);
",unused,e2fsprogsources-lib2Fblkid2Fdev.c
"		    !strcmp(de->d_name, devname) ||
		    strncmp(de->d_name, ""dm-"", 3) ||
		    strlen(de->d_name) > sizeof(path)-32)
			continue;
		sprintf(path, ""/sys/block/%s/slaves"", de->d_name);
",1,unused,140,unused,"		    !strcmp(de->d_name, devname) ||
		    strncmp(de->d_name, ""dm-"", 3) ||
		    strlen(de->d_name) > sizeof(path)-32)
			continue;
		sprintf(path, ""/sys/block/%s/slaves"", de->d_name);
",unused,e2fsprogsources-lib2Fblkid2Fdevname.c
"	for (dir = dirlist; *dir; dir++) {
		struct stat st;
		char device[256];

		sprintf(device, ""%s/%s"", *dir, ptname);
",1,unused,229,unused,"	for (dir = dirlist; *dir; dir++) {
		struct stat st;
		char device[256];

		sprintf(device, ""%s/%s"", *dir, ptname);
",unused,e2fsprogsources-lib2Fblkid2Fdevname.c
"			continue;
		vdirname = malloc(vg_len + strlen(vg_name) + 8);
		if (!vdirname)
			goto exit;
		sprintf(vdirname, ""%s/%s/LVs"", VG_DIR, vg_name);
",1,unused,327,unused,"			continue;
		vdirname = malloc(vg_len + strlen(vg_name) + 8);
		if (!vdirname)
			goto exit;
		sprintf(vdirname, ""%s/%s/LVs"", VG_DIR, vg_name);
",unused,e2fsprogsources-lib2Fblkid2Fdevname.c
"			if (!lvm_device) {
				closedir(lv_list);
				goto exit;
			}
			sprintf(lvm_device, ""%s/%s/LVs/%s"", VG_DIR, vg_name,
",1,unused,347,unused,"			if (!lvm_device) {
				closedir(lv_list);
				goto exit;
			}
			sprintf(lvm_device, ""%s/%s/LVs/%s"", VG_DIR, vg_name,
",unused,e2fsprogsources-lib2Fblkid2Fdevname.c
"			}
			sprintf(lvm_device, ""%s/%s/LVs/%s"", VG_DIR, vg_name,
				lv_name);
			dev = lvm_get_devno(lvm_device);
			sprintf(lvm_device, ""%s/%s"", vg_name, lv_name);
",1,unused,350,unused,"			}
			sprintf(lvm_device, ""%s/%s/LVs/%s"", VG_DIR, vg_name,
				lv_name);
			dev = lvm_get_devno(lvm_device);
			sprintf(lvm_device, ""%s/%s"", vg_name, lv_name);
",unused,e2fsprogsources-lib2Fblkid2Fdevname.c
"		    ((dp->d_name[1] == 0) ||
		     ((dp->d_name[1] == '.') && (dp->d_name[2] == 0))))
			continue;

		sprintf(path, ""%s/%s"", dirname, dp->d_name);
",1,unused,118,unused,"		    ((dp->d_name[1] == 0) ||
		     ((dp->d_name[1] == '.') && (dp->d_name[2] == 0))))
			continue;

		sprintf(path, ""%s/%s"", dirname, dp->d_name);
",unused,e2fsprogsources-lib2Fblkid2Fdevno.c
"			label = vol_label;
	}

	/* We can't just print them as %04X, because they are unaligned */
	sprintf(serno, ""%02X%02X-%02X%02X"", vol_serno[3], vol_serno[2],
",1,unused,626,unused,"			label = vol_label;
	}

	/* We can't just print them as %04X, because they are unaligned */
	sprintf(serno, ""%02X%02X-%02X%02X"", vol_serno[3], vol_serno[2],
",unused,e2fsprogsources-lib2Fblkid2Fprobe.c
"			*cp = 0;
		}
	}

	sprintf(uuid_str, ""%016llX"", blkid_le64(ns->volume_serial));
",1,unused,782,unused,"			*cp = 0;
		}
	}

	sprintf(uuid_str, ""%016llX"", blkid_le64(ns->volume_serial));
",unused,e2fsprogsources-lib2Fblkid2Fprobe.c
"
	uuid_ptr = (unsigned long long *)hfs->finder_info.id;
	uuid = blkid_le64(*uuid_ptr);
	if (uuid) {
		sprintf(uuid_str, ""%016llX"", uuid);
",1,unused,1179,unused,"
	uuid_ptr = (unsigned long long *)hfs->finder_info.id;
	uuid = blkid_le64(*uuid_ptr);
	if (uuid) {
		sprintf(uuid_str, ""%016llX"", uuid);
",unused,e2fsprogsources-lib2Fblkid2Fprobe.c
"
	uuid_ptr = (unsigned long long *)hfsplus->finder_info.id;
	uuid = blkid_le64(*uuid_ptr);
	if (uuid) {
		sprintf(uuid_str, ""%016llX"", uuid);
",1,unused,1245,unused,"
	uuid_ptr = (unsigned long long *)hfsplus->finder_info.id;
	uuid = blkid_le64(*uuid_ptr);
	if (uuid) {
		sprintf(uuid_str, ""%016llX"", uuid);
",unused,e2fsprogsources-lib2Fblkid2Fprobe.c
"	if (ret == 0 && S_ISREG(st.st_mode)) {
		tmp = malloc(strlen(filename) + 8);
		if (tmp) {
			mode_t save_umask = umask(022);
			sprintf(tmp, ""%s-XXXXXX"", filename);
",1,unused,102,unused,"	if (ret == 0 && S_ISREG(st.st_mode)) {
		tmp = malloc(strlen(filename) + 8);
		if (tmp) {
			mode_t save_umask = umask(022);
			sprintf(tmp, ""%s-XXXXXX"", filename);
",unused,e2fsprogsources-lib2Fblkid2Fsave.c
"			char *backup;

			backup = malloc(strlen(filename) + 5);
			if (backup) {
				sprintf(backup, ""%s.old"", filename);
",1,unused,155,unused,"			char *backup;

			backup = malloc(strlen(filename) + 5);
			if (backup) {
				sprintf(backup, ""%s.old"", filename);
",unused,e2fsprogsources-lib2Fblkid2Fsave.c
"	for (p = mode_list; p->string; p++) {
		if (num == p->num)
			return p->string;
	}
	sprintf(buf, ""ENC_MODE_%d"", num);
",1,unused,44,unused,"	for (p = mode_list; p->string; p++) {
		if (num == p->num)
			return p->string;
	}
	sprintf(buf, ""ENC_MODE_%d"", num);
",unused,e2fsprogsources-lib2Fe2p2Fcrypto_mode.c
"		fchar = '?';
		break;
	}
	for (fnum = 0; mask >>= 1; fnum++);
	sprintf(buf, ""FEATURE_%c%d"", fchar, fnum);
",1,unused,155,unused,"		fchar = '?';
		break;
	}
	for (fnum = 0; mask >>= 1; fnum++);
	sprintf(buf, ""FEATURE_%c%d"", fchar, fnum);
",unused,e2fsprogsources-lib2Fe2p2Ffeature.c
"		fchar = '?';
		break;
	}
	for (fnum = 0; mask >>= 1; fnum++);
	sprintf(buf, ""FEATURE_%c%d"", fchar, fnum);
",1,unused,229,unused,"		fchar = '?';
		break;
	}
	for (fnum = 0; mask >>= 1; fnum++);
	sprintf(buf, ""FEATURE_%c%d"", fchar, fnum);
",unused,e2fsprogsources-lib2Fe2p2Ffeature.c
"
	buf = malloc(strlen(str)+1);
	if (!buf)
		return 1;
	strcpy(buf, str);
",1,unused,316,unused,"
	buf = malloc(strlen(str)+1);
	if (!buf)
		return 1;
	strcpy(buf, str);
",unused,e2fsprogsources-lib2Fe2p2Ffeature.c
"	for (p = hash_list; p->string; p++) {
		if (num == p->num)
			return p->string;
	}
	sprintf(buf, ""HASHALG_%d"", num);
",1,unused,42,unused,"	for (p = hash_list; p->string; p++) {
		if (num == p->num)
			return p->string;
	}
	sprintf(buf, ""HASHALG_%d"", num);
",unused,e2fsprogsources-lib2Fe2p2Fhashstr.c
"
	if (secs >= MONTH_INT) {
		num = secs / MONTH_INT;
		secs -= num*MONTH_INT;
		sprintf(buf, ""%d month%s"", num, (num>1) ? ""s"" : """");
",1,unused,71,unused,"
	if (secs >= MONTH_INT) {
		num = secs / MONTH_INT;
		secs -= num*MONTH_INT;
		sprintf(buf, ""%d month%s"", num, (num>1) ? ""s"" : """");
",unused,e2fsprogsources-lib2Fe2p2Fls.c
"	}
	if (secs >= WEEK_INT) {
		num = secs / WEEK_INT;
		secs -= num*WEEK_INT;
		sprintf(tmp, ""%s%d week%s"", buf[0] ? "", "" : """",
",1,unused,76,unused,"	}
	if (secs >= WEEK_INT) {
		num = secs / WEEK_INT;
		secs -= num*WEEK_INT;
		sprintf(tmp, ""%s%d week%s"", buf[0] ? "", "" : """",
",unused,e2fsprogsources-lib2Fe2p2Fls.c
"		num = secs / WEEK_INT;
		secs -= num*WEEK_INT;
		sprintf(tmp, ""%s%d week%s"", buf[0] ? "", "" : """",
			num, (num>1) ? ""s"" : """");
		strcat(buf, tmp);
",1,unused,78,unused,"		num = secs / WEEK_INT;
		secs -= num*WEEK_INT;
		sprintf(tmp, ""%s%d week%s"", buf[0] ? "", "" : """",
			num, (num>1) ? ""s"" : """");
		strcat(buf, tmp);
",unused,e2fsprogsources-lib2Fe2p2Fls.c
"	}
	if (secs >= DAY_INT) {
		num = secs / DAY_INT;
		secs -= num*DAY_INT;
		sprintf(tmp, ""%s%d day%s"", buf[0] ? "", "" : """",
",1,unused,83,unused,"	}
	if (secs >= DAY_INT) {
		num = secs / DAY_INT;
		secs -= num*DAY_INT;
		sprintf(tmp, ""%s%d day%s"", buf[0] ? "", "" : """",
",unused,e2fsprogsources-lib2Fe2p2Fls.c
"		num = secs / DAY_INT;
		secs -= num*DAY_INT;
		sprintf(tmp, ""%s%d day%s"", buf[0] ? "", "" : """",
			num, (num>1) ? ""s"" : """");
		strcat(buf, tmp);
",1,unused,85,unused,"		num = secs / DAY_INT;
		secs -= num*DAY_INT;
		sprintf(tmp, ""%s%d day%s"", buf[0] ? "", "" : """",
			num, (num>1) ? ""s"" : """");
		strcat(buf, tmp);
",unused,e2fsprogsources-lib2Fe2p2Fls.c
"		hr = secs / HOUR_INT;
		secs -= hr*HOUR_INT;
		min = secs / MINUTE_INT;
		secs -= min*MINUTE_INT;
		sprintf(tmp, ""%s%d:%02d:%02d"", buf[0] ? "", "" : """",
",1,unused,92,unused,"		hr = secs / HOUR_INT;
		secs -= hr*HOUR_INT;
		min = secs / MINUTE_INT;
		secs -= min*MINUTE_INT;
		sprintf(tmp, ""%s%d:%02d:%02d"", buf[0] ? "", "" : """",
",unused,e2fsprogsources-lib2Fe2p2Fls.c
"		min = secs / MINUTE_INT;
		secs -= min*MINUTE_INT;
		sprintf(tmp, ""%s%d:%02d:%02d"", buf[0] ? "", "" : """",
			hr, min, secs);
		strcat(buf, tmp);
",1,unused,94,unused,"		min = secs / MINUTE_INT;
		secs -= min*MINUTE_INT;
		sprintf(tmp, ""%s%d:%02d:%02d"", buf[0] ? "", "" : """",
			hr, min, secs);
		strcat(buf, tmp);
",unused,e2fsprogsources-lib2Fe2p2Fls.c
"	if (sb->s_volume_name[0]) {
		memset(buf, 0, sizeof(buf));
		strncpy(buf, sb->s_volume_name, sizeof(sb->s_volume_name));
	} else
		strcpy(buf, ""<none>"");
",1,unused,239,unused,"	if (sb->s_volume_name[0]) {
		memset(buf, 0, sizeof(buf));
		strncpy(buf, sb->s_volume_name, sizeof(sb->s_volume_name));
	} else
		strcpy(buf, ""<none>"");
",unused,e2fsprogsources-lib2Fe2p2Fls.c
"	if (sb->s_last_mounted[0]) {
		memset(buf, 0, sizeof(buf));
		strncpy(buf, sb->s_last_mounted, sizeof(sb->s_last_mounted));
	} else
		strcpy(buf, ""<not available>"");
",1,unused,245,unused,"	if (sb->s_last_mounted[0]) {
		memset(buf, 0, sizeof(buf));
		strncpy(buf, sb->s_last_mounted, sizeof(sb->s_last_mounted));
	} else
		strcpy(buf, ""<not available>"");
",unused,e2fsprogsources-lib2Fe2p2Fls.c
"		if (mask == f->mask)
			return f->string;
	}
	for (fnum = 0; mask >>= 1; fnum++);
	sprintf(buf, ""MNTOPT_%d"", fnum);
",1,unused,54,unused,"		if (mask == f->mask)
			return f->string;
	}
	for (fnum = 0; mask >>= 1; fnum++);
	sprintf(buf, ""MNTOPT_%d"", fnum);
",unused,e2fsprogsources-lib2Fe2p2Fmntopts.c
"
	buf = malloc(strlen(str)+1);
	if (!buf)
		return 1;
	strcpy(buf, str);
",1,unused,113,unused,"
	buf = malloc(strlen(str)+1);
	if (!buf)
		return 1;
	strcpy(buf, str);
",unused,e2fsprogsources-lib2Fe2p2Fmntopts.c
"		os = ""(unknown os)"";

        ret = malloc(strlen(os)+1);
	if (ret)
		strcpy(ret, os);
",1,unused,40,unused,"		os = ""(unknown os)"";

        ret = malloc(strlen(os)+1);
	if (ret)
		strcpy(ret, os);
",unused,e2fsprogsources-lib2Fe2p2Fostype.c
"{
	struct uuid uuid;

	e2p_unpack_uuid(uu, &uuid);
	sprintf(out,
",1,unused,68,unused,"{
	struct uuid uuid;

	e2p_unpack_uuid(uu, &uuid);
	sprintf(out,
",unused,e2fsprogsources-lib2Fe2p2Fuuid.c
"	}
    }
    et_list_unlock();
oops:
    strcpy (buffer, ""Unknown code "");
",1,unused,174,unused,"	}
    }
    et_list_unlock();
oops:
    strcpy (buffer, ""Unknown code "");
",unused,e2fsprogsources-lib2Fet2Ferror_message.c
"    et_list_unlock();
oops:
    strcpy (buffer, ""Unknown code "");
    if (table_num) {
	strcat (buffer, error_table_name (table_num));
",1,unused,176,unused,"    et_list_unlock();
oops:
    strcpy (buffer, ""Unknown code "");
    if (table_num) {
	strcat (buffer, error_table_name (table_num));
",unused,e2fsprogsources-lib2Fet2Ferror_message.c
"oops:
    strcpy (buffer, ""Unknown code "");
    if (table_num) {
	strcat (buffer, error_table_name (table_num));
	strcat (buffer, "" "");
",1,unused,177,unused,"oops:
    strcpy (buffer, ""Unknown code "");
    if (table_num) {
	strcat (buffer, error_table_name (table_num));
	strcat (buffer, "" "");
",unused,e2fsprogsources-lib2Fet2Ferror_message.c
"
	retval = ext2fs_get_mem(strlen(src->device_name)+1, &fs->device_name);
	if (retval)
		goto errout;
	strcpy(fs->device_name, src->device_name);
",1,unused,54,unused,"
	retval = ext2fs_get_mem(strlen(src->device_name)+1, &fs->device_name);
	if (retval)
		goto errout;
	strcpy(fs->device_name, src->device_name);
",unused,e2fsprogsources-lib2Fext2fs2Fdupfs.c
"	if (!dp->name) {
		free(dp);
		return;
	}
	strcpy(dp->name, name);
",1,unused,62,unused,"	if (!dp->name) {
		free(dp);
		return;
	}
	strcpy(dp->name, name);
",unused,e2fsprogsources-lib2Fext2fs2Ffinddev.c
"		if (dp->d_name[0] == '.' &&
		    ((dp->d_name[1] == 0) ||
		     ((dp->d_name[1] == '.') && (dp->d_name[2] == 0))))
			goto skip_to_next;
		sprintf(path, ""%s/%s"", dirname, dp->d_name);
",1,unused,102,unused,"		if (dp->d_name[0] == '.' &&
		    ((dp->d_name[1] == 0) ||
		     ((dp->d_name[1] == '.') && (dp->d_name[2] == 0))))
			goto skip_to_next;
		sprintf(path, ""%s/%s"", dirname, dp->d_name);
",unused,e2fsprogsources-lib2Fext2fs2Ffinddev.c
"			if (!cp) {
				closedir(dir);
				return ENOMEM;
			}
			strcpy(cp, path);
",1,unused,114,unused,"			if (!cp) {
				closedir(dir);
				return ENOMEM;
			}
			strcpy(cp, path);
",unused,e2fsprogsources-lib2Fext2fs2Ffinddev.c
"		if (retval) {
			ext2fs_free_mem(&bitmap);
			return retval;
		}
		strcpy(bitmap->description, descr);
",1,unused,112,unused,"		if (retval) {
			ext2fs_free_mem(&bitmap);
			return retval;
		}
		strcpy(bitmap->description, descr);
",unused,e2fsprogsources-lib2Fext2fs2Fgen_bitmap.c
"		if (retval) {
			ext2fs_free_mem(&bitmap);
			return retval;
		}
		strcpy(bitmap->description, descr);
",1,unused,162,unused,"		if (retval) {
			ext2fs_free_mem(&bitmap);
			return retval;
		}
		strcpy(bitmap->description, descr);
",unused,e2fsprogsources-lib2Fext2fs2Fgen_bitmap64.c
"		if (retval) {
			ext2fs_free_mem(&new_bmap);
			return retval;
		}
		strcpy(new_descr, ""copy of "");
",1,unused,327,unused,"		if (retval) {
			ext2fs_free_mem(&new_bmap);
			return retval;
		}
		strcpy(new_descr, ""copy of "");
",unused,e2fsprogsources-lib2Fext2fs2Fgen_bitmap64.c
"			ext2fs_free_mem(&new_bmap);
			return retval;
		}
		strcpy(new_descr, ""copy of "");
		strcat(new_descr, descr);
",1,unused,328,unused,"			ext2fs_free_mem(&new_bmap);
			return retval;
		}
		strcpy(new_descr, ""copy of "");
		strcat(new_descr, descr);
",unused,e2fsprogsources-lib2Fext2fs2Fgen_bitmap64.c
"	if (dir == ino) {
		retval = ext2fs_get_mem(2, name);
		if (retval)
			return retval;
		strcpy(*name, (dir == EXT2_ROOT_INO) ? ""/"" : ""."");
",1,unused,83,unused,"	if (dir == ino) {
		retval = ext2fs_get_mem(2, name);
		if (retval)
			return retval;
		strcpy(*name, (dir == EXT2_ROOT_INO) ? ""/"" : ""."");
",unused,e2fsprogsources-lib2Fext2fs2Fget_pathname.c
"	if (!dir || (maxdepth < 0)) {
		retval = ext2fs_get_mem(4, name);
		if (retval)
			return retval;
		strcpy(*name, ""..."");
",1,unused,91,unused,"	if (!dir || (maxdepth < 0)) {
		retval = ext2fs_get_mem(4, name);
		if (retval)
			return retval;
		strcpy(*name, ""..."");
",unused,e2fsprogsources-lib2Fext2fs2Fget_pathname.c
"			snprintf(tmp, sizeof(tmp), ""<%u>"", dir);
		retval = ext2fs_get_mem(strlen(tmp)+1, name);
		if (retval)
			goto cleanup;
		strcpy(*name, tmp);
",1,unused,111,unused,"			snprintf(tmp, sizeof(tmp), ""<%u>"", dir);
		retval = ext2fs_get_mem(strlen(tmp)+1, name);
		if (retval)
			goto cleanup;
		strcpy(*name, tmp);
",unused,e2fsprogsources-lib2Fext2fs2Fget_pathname.c
"		goto cleanup;

	ret[0] = 0;
	if (parent_name[1])
		strcat(ret, parent_name);
",1,unused,139,unused,"		goto cleanup;

	ret[0] = 0;
	if (parent_name[1])
		strcat(ret, parent_name);
",unused,e2fsprogsources-lib2Fext2fs2Fget_pathname.c
"
	ret[0] = 0;
	if (parent_name[1])
		strcat(ret, parent_name);
	strcat(ret, ""/"");
",1,unused,140,unused,"
	ret[0] = 0;
	if (parent_name[1])
		strcat(ret, parent_name);
	strcat(ret, ""/"");
",unused,e2fsprogsources-lib2Fext2fs2Fget_pathname.c
"	if (parent_name[1])
		strcat(ret, parent_name);
	strcat(ret, ""/"");
	if (gp.name)
		strcat(ret, gp.name);
",1,unused,142,unused,"	if (parent_name[1])
		strcat(ret, parent_name);
	strcat(ret, ""/"");
	if (gp.name)
		strcat(ret, gp.name);
",unused,e2fsprogsources-lib2Fext2fs2Fget_pathname.c
"	strcat(ret, ""/"");
	if (gp.name)
		strcat(ret, gp.name);
	else
		strcat(ret, ""???"");
",1,unused,144,unused,"	strcat(ret, ""/"");
	if (gp.name)
		strcat(ret, gp.name);
	else
		strcat(ret, ""???"");
",unused,e2fsprogsources-lib2Fext2fs2Fget_pathname.c
"{
	struct uuid uuid;

	unpack_uuid(uu, &uuid);
	sprintf(out,
",1,unused,190,unused,"{
	struct uuid uuid;

	unpack_uuid(uu, &uuid);
	sprintf(out,
",unused,e2fsprogsources-lib2Fext2fs2Ficount.c
"	retval = ext2fs_get_mem(strlen(tdb_dir) + 64, &fn);
	if (retval)
		goto errout;
	uuid_unparse(fs->super->s_uuid, uuid);
	sprintf(fn, ""%s/%s-icount-XXXXXX"", tdb_dir, uuid);
",1,unused,220,unused,"	retval = ext2fs_get_mem(strlen(tdb_dir) + 64, &fn);
	if (retval)
		goto errout;
	uuid_unparse(fs->super->s_uuid, uuid);
	sprintf(fn, ""%s/%s-icount-XXXXXX"", tdb_dir, uuid);
",unused,e2fsprogsources-lib2Fext2fs2Ficount.c
"	retval = ext2fs_get_mem(strlen(name)+1, &fs->device_name);
	if (retval)
		goto cleanup;

	strcpy(fs->device_name, name);
",1,unused,147,unused,"	retval = ext2fs_get_mem(strlen(name)+1, &fs->device_name);
	if (retval)
		goto cleanup;

	strcpy(fs->device_name, name);
",unused,e2fsprogsources-lib2Fext2fs2Finitialize.c
"	retval = ext2fs_get_mem(strlen(fs->device_name) + 80, &buf);
	if (retval)
		goto cleanup;

	strcpy(buf, ""block bitmap for "");
",1,unused,479,unused,"	retval = ext2fs_get_mem(strlen(fs->device_name) + 80, &buf);
	if (retval)
		goto cleanup;

	strcpy(buf, ""block bitmap for "");
",unused,e2fsprogsources-lib2Fext2fs2Finitialize.c
"	if (retval)
		goto cleanup;

	strcpy(buf, ""block bitmap for "");
	strcat(buf, fs->device_name);
",1,unused,480,unused,"	if (retval)
		goto cleanup;

	strcpy(buf, ""block bitmap for "");
	strcat(buf, fs->device_name);
",unused,e2fsprogsources-lib2Fext2fs2Finitialize.c
"	retval = ext2fs_allocate_subcluster_bitmap(fs, buf, &fs->block_map);
	if (retval)
		goto cleanup;

	strcpy(buf, ""inode bitmap for "");
",1,unused,485,unused,"	retval = ext2fs_allocate_subcluster_bitmap(fs, buf, &fs->block_map);
	if (retval)
		goto cleanup;

	strcpy(buf, ""inode bitmap for "");
",unused,e2fsprogsources-lib2Fext2fs2Finitialize.c
"	if (retval)
		goto cleanup;

	strcpy(buf, ""inode bitmap for "");
	strcat(buf, fs->device_name);
",1,unused,486,unused,"	if (retval)
		goto cleanup;

	strcpy(buf, ""inode bitmap for "");
	strcat(buf, fs->device_name);
",unused,e2fsprogsources-lib2Fext2fs2Finitialize.c
"	if ((retval = ext2fs_get_mem(sizeof(struct inode_private_data),
				     &data)))
		return retval;
	data->magic = EXT2_ET_MAGIC_INODE_IO_CHANNEL;
	sprintf(data->name, ""%u:%d"", ino, ino_unique++);
",1,unused,92,unused,"	if ((retval = ext2fs_get_mem(sizeof(struct inode_private_data),
				     &data)))
		return retval;
	data->magic = EXT2_ET_MAGIC_INODE_IO_CHANNEL;
	sprintf(data->name, ""%u:%d"", ino, ino_unique++);
",unused,e2fsprogsources-lib2Fext2fs2Finode_io.c
"	retval = ext2fs_get_mem(strlen(name)+1, &io->name);
	if (retval)
		goto cleanup;

	strcpy(io->name, name);
",1,unused,146,unused,"	retval = ext2fs_get_mem(strlen(name)+1, &io->name);
	if (retval)
		goto cleanup;

	strcpy(io->name, name);
",unused,e2fsprogsources-lib2Fext2fs2Finode_io.c
"
	options = malloc(strlen(opts)+1);
	if (!options)
		return EXT2_ET_NO_MEMORY;
	strcpy(options, opts);
",1,unused,39,unused,"
	options = malloc(strlen(opts)+1);
	if (!options)
		return EXT2_ET_NO_MEMORY;
	strcpy(options, opts);
",unused,e2fsprogsources-lib2Fext2fs2Fio_manager.c
"	if (mount_flags & EXT2_MF_MOUNTED) {
#if HAVE_EXT2_IOCTLS
		int f = 0;
#endif
		strcat(jfile, ""/.journal"");
",1,unused,456,unused,"	if (mount_flags & EXT2_MF_MOUNTED) {
#if HAVE_EXT2_IOCTLS
		int f = 0;
#endif
		strcat(jfile, ""/.journal"");
",unused,e2fsprogsources-lib2Fext2fs2Fmkjournal.c
"
	retval = ext2fs_get_mem(strlen(name)+1, &fs->device_name);
	if (retval)
		goto cleanup;
	strcpy(fs->device_name, name);
",1,unused,153,unused,"
	retval = ext2fs_get_mem(strlen(name)+1, &fs->device_name);
	if (retval)
		goto cleanup;
	strcpy(fs->device_name, name);
",unused,e2fsprogsources-lib2Fext2fs2Fopenfs.c
"		return retval;
	if (do_block) {
		if (fs->block_map)
			ext2fs_free_block_bitmap(fs->block_map);
		strcpy(buf, ""block bitmap for "");
",1,unused,230,unused,"		return retval;
	if (do_block) {
		if (fs->block_map)
			ext2fs_free_block_bitmap(fs->block_map);
		strcpy(buf, ""block bitmap for "");
",unused,e2fsprogsources-lib2Fext2fs2Frw_bitmaps.c
"	if (do_block) {
		if (fs->block_map)
			ext2fs_free_block_bitmap(fs->block_map);
		strcpy(buf, ""block bitmap for "");
		strcat(buf, fs->device_name);
",1,unused,231,unused,"	if (do_block) {
		if (fs->block_map)
			ext2fs_free_block_bitmap(fs->block_map);
		strcpy(buf, ""block bitmap for "");
		strcat(buf, fs->device_name);
",unused,e2fsprogsources-lib2Fext2fs2Frw_bitmaps.c
"		block_nbytes = 0;
	if (do_inode) {
		if (fs->inode_map)
			ext2fs_free_inode_bitmap(fs->inode_map);
		strcpy(buf, ""inode bitmap for "");
",1,unused,243,unused,"		block_nbytes = 0;
	if (do_inode) {
		if (fs->inode_map)
			ext2fs_free_inode_bitmap(fs->inode_map);
		strcpy(buf, ""inode bitmap for "");
",unused,e2fsprogsources-lib2Fext2fs2Frw_bitmaps.c
"	if (do_inode) {
		if (fs->inode_map)
			ext2fs_free_inode_bitmap(fs->inode_map);
		strcpy(buf, ""inode bitmap for "");
		strcat(buf, fs->device_name);
",1,unused,244,unused,"	if (do_inode) {
		if (fs->inode_map)
			ext2fs_free_inode_bitmap(fs->inode_map);
		strcpy(buf, ""inode bitmap for "");
		strcat(buf, fs->device_name);
",unused,e2fsprogsources-lib2Fext2fs2Frw_bitmaps.c
"
	inlinelink = !fastlink && ext2fs_has_feature_inline_data(fs->super);
	if (fastlink) {
		/* Fast symlinks, target stored in inode */
		strcpy((char *)&inode.i_block, target);
",1,unused,112,unused,"
	inlinelink = !fastlink && ext2fs_has_feature_inline_data(fs->super);
	if (fastlink) {
		/* Fast symlinks, target stored in inode */
		strcpy((char *)&inode.i_block, target);
",unused,e2fsprogsources-lib2Fext2fs2Fsymlink.c
"	retval = ext2fs_get_mem(strlen(name)+1, &io->name);
	if (retval)
		goto cleanup;

	strcpy(io->name, name);
",1,unused,194,unused,"	retval = ext2fs_get_mem(strlen(name)+1, &io->name);
	if (retval)
		goto cleanup;

	strcpy(io->name, name);
",unused,e2fsprogsources-lib2Fext2fs2Ftest_io.c
"	retval = ext2fs_get_mem(strlen(name)+1, &io->name);
	if (retval)
		goto cleanup;

	strcpy(io->name, name);
",1,unused,717,unused,"	retval = ext2fs_get_mem(strlen(name)+1, &io->name);
	if (retval)
		goto cleanup;

	strcpy(io->name, name);
",unused,e2fsprogsources-lib2Fext2fs2Fundo_io.c
"	retval = ext2fs_get_mem(strlen(name)+1, &io->name);
	if (retval)
		goto cleanup;

	strcpy(io->name, name);
",1,unused,586,unused,"	retval = ext2fs_get_mem(strlen(name)+1, &io->name);
	if (retval)
		goto cleanup;

	strcpy(io->name, name);
",unused,e2fsprogsources-lib2Fext2fs2Funix_io.c
"			 (strlen(infop->subsystem_name)+1)
			 * sizeof(char));
	if (ret_val == (char *)NULL)
	    return((char *)NULL);
	strcpy(ret_val, infop->subsystem_name);
",1,unused,35,unused,"			 (strlen(infop->subsystem_name)+1)
			 * sizeof(char));
	if (ret_val == (char *)NULL)
	    return((char *)NULL);
	strcpy(ret_val, infop->subsystem_name);
",unused,e2fsprogsources-lib2Fss2Ferror.c
"		ss_perror(sci_idx, 0,
			  ""couldn't allocate memory to print usage message"");
		return;
	}
	sprintf(buffer, ""usage:\n\t%s [topic|command]\nor\t%s\n"",
",1,unused,65,unused,"		ss_perror(sci_idx, 0,
			  ""couldn't allocate memory to print usage message"");
		return;
	}
	sprintf(buffer, ""usage:\n\t%s [topic|command]\nor\t%s\n"",
",unused,e2fsprogsources-lib2Fss2Fhelp.c
"	    ss_perror(sci_idx, 0,
		      ""couldn't allocate memory for help filename"");
	    return;
	}
	(void) strcpy(buffer, info->info_dirs[idx]);
",1,unused,88,unused,"	    ss_perror(sci_idx, 0,
		      ""couldn't allocate memory for help filename"");
	    return;
	}
	(void) strcpy(buffer, info->info_dirs[idx]);
",unused,e2fsprogsources-lib2Fss2Fhelp.c
"		      ""couldn't allocate memory for help filename"");
	    return;
	}
	(void) strcpy(buffer, info->info_dirs[idx]);
	(void) strcat(buffer, ""/"");
",1,unused,89,unused,"		      ""couldn't allocate memory for help filename"");
	    return;
	}
	(void) strcpy(buffer, info->info_dirs[idx]);
	(void) strcat(buffer, ""/"");
",unused,e2fsprogsources-lib2Fss2Fhelp.c
"	    return;
	}
	(void) strcpy(buffer, info->info_dirs[idx]);
	(void) strcat(buffer, ""/"");
	(void) strcat(buffer, argv[1]);
",1,unused,90,unused,"	    return;
	}
	(void) strcpy(buffer, info->info_dirs[idx]);
	(void) strcat(buffer, ""/"");
	(void) strcat(buffer, argv[1]);
",unused,e2fsprogsources-lib2Fss2Fhelp.c
"	}
	(void) strcpy(buffer, info->info_dirs[idx]);
	(void) strcat(buffer, ""/"");
	(void) strcat(buffer, argv[1]);
	(void) strcat(buffer, "".info"");
",1,unused,91,unused,"	}
	(void) strcpy(buffer, info->info_dirs[idx]);
	(void) strcat(buffer, ""/"");
	(void) strcat(buffer, argv[1]);
	(void) strcat(buffer, "".info"");
",unused,e2fsprogsources-lib2Fss2Fhelp.c
"    }
    if (fd < 0) {
#define MSG ""No info found for ""
        char *buf = malloc(strlen (MSG) + strlen (argv[1]) + 1);
	strcpy(buf, MSG);
",1,unused,100,unused,"    }
    if (fd < 0) {
#define MSG ""No info found for ""
        char *buf = malloc(strlen (MSG) + strlen (argv[1]) + 1);
	strcpy(buf, MSG);
",unused,e2fsprogsources-lib2Fss2Fhelp.c
"    if (fd < 0) {
#define MSG ""No info found for ""
        char *buf = malloc(strlen (MSG) + strlen (argv[1]) + 1);
	strcpy(buf, MSG);
	strcat(buf, argv[1]);
",1,unused,101,unused,"    if (fd < 0) {
#define MSG ""No info found for ""
        char *buf = malloc(strlen (MSG) + strlen (argv[1]) + 1);
	strcpy(buf, MSG);
	strcat(buf, argv[1]);
",unused,e2fsprogsources-lib2Fss2Fhelp.c
"    }
    info->info_dirs = dirs;
    dirs[n_dirs + 1] = (char *)NULL;
    dirs[n_dirs] = malloc((unsigned)strlen(info_dir)+1);
    strcpy(dirs[n_dirs], info_dir);
",1,unused,158,unused,"    }
    info->info_dirs = dirs;
    dirs[n_dirs + 1] = (char *)NULL;
    dirs[n_dirs] = malloc((unsigned)strlen(info_dir)+1);
    strcpy(dirs[n_dirs], info_dir);
",unused,e2fsprogsources-lib2Fss2Fhelp.c
"	new_table->info_dirs = (char **)malloc(sizeof(char *));
	*new_table->info_dirs = (char *)NULL;
	new_table->info_ptr = info_ptr;
	new_table->prompt = malloc((unsigned)strlen(subsystem_name)+4);
	strcpy(new_table->prompt, subsystem_name);
",1,unused,63,unused,"	new_table->info_dirs = (char **)malloc(sizeof(char *));
	*new_table->info_dirs = (char *)NULL;
	new_table->info_ptr = info_ptr;
	new_table->prompt = malloc((unsigned)strlen(subsystem_name)+4);
	strcpy(new_table->prompt, subsystem_name);
",unused,e2fsprogsources-lib2Fss2Finvocation.c
"	*new_table->info_dirs = (char *)NULL;
	new_table->info_ptr = info_ptr;
	new_table->prompt = malloc((unsigned)strlen(subsystem_name)+4);
	strcpy(new_table->prompt, subsystem_name);
	strcat(new_table->prompt, "":  "");
",1,unused,64,unused,"	*new_table->info_dirs = (char *)NULL;
	new_table->info_ptr = info_ptr;
	new_table->prompt = malloc((unsigned)strlen(subsystem_name)+4);
	strcpy(new_table->prompt, subsystem_name);
	strcat(new_table->prompt, "":  "");
",unused,e2fsprogsources-lib2Fss2Finvocation.c
"		}
		if (strncmp(*name, text, len) == 0) {
			ret = malloc(strlen(*name)+1);
			if (ret)
				strcpy(ret, *name);
",1,unused,181,unused,"		}
		if (strncmp(*name, text, len) == 0) {
			ret = malloc(strlen(*name)+1);
			if (ret)
				strcpy(ret, *name);
",unused,e2fsprogsources-lib2Fss2Flisten.c
"		fprintf(stderr,
			""Couldn't allocate memory to parse quota options!\n"");
		return -ENOMEM;
	}
	strcpy(buf, opts);
",1,unused,709,unused,"		fprintf(stderr,
			""Couldn't allocate memory to parse quota options!\n"");
		return -ENOMEM;
	}
	strcpy(buf, opts);
",unused,e2fsprogsources-lib2Fsupport2Fmkquota.c
"	len = strlen(in_str);
	buf = malloc(len + 1);
	if (!buf)
		return ENOMEM;
	strcpy(buf, in_str);
",1,unused,31,unused,"	len = strlen(in_str);
	buf = malloc(len + 1);
	if (!buf)
		return ENOMEM;
	strcpy(buf, in_str);
",unused,e2fsprogsources-lib2Fsupport2Fparse_qtype.c
"		} else {
			if (err_token) {
				*err_token = malloc(strlen(token) + 1);
				if (*err_token)
					strcpy(*err_token, token);
",1,unused,61,unused,"		} else {
			if (err_token) {
				*err_token = malloc(strlen(token) + 1);
				if (*err_token)
					strcpy(*err_token, token);
",unused,e2fsprogsources-lib2Fsupport2Fparse_qtype.c
"	if ((s = socket(AF_UNIX, SOCK_STREAM, 0)) < 0)
		return -1;

	srv_addr.sun_family = AF_UNIX;
	strcpy(srv_addr.sun_path, UUIDD_SOCKET_PATH);
",1,unused,515,unused,"	if ((s = socket(AF_UNIX, SOCK_STREAM, 0)) < 0)
		return -1;

	srv_addr.sun_family = AF_UNIX;
	strcpy(srv_addr.sun_path, UUIDD_SOCKET_PATH);
",unused,e2fsprogsources-lib2Fuuid2Fgen_uuid.c
"{
	struct uuid uuid;

	uuid_unpack(uu, &uuid);
	sprintf(out, fmt,
",1,unused,57,unused,"{
	struct uuid uuid;

	uuid_unpack(uu, &uuid);
	sprintf(out, fmt,
",unused,e2fsprogsources-lib2Fuuid2Funparse.c
"	min = diff % 60;
	hr = diff / 60;

	if (hr)
		sprintf(buf, ""%d:%02d:%02d"", hr, min, sec);
",1,unused,200,unused,"	min = diff % 60;
	hr = diff / 60;

	if (hr)
		sprintf(buf, ""%d:%02d:%02d"", hr, min, sec);
",unused,e2fsprogsources-misc2Fbadblocks.c
"
	if (hr)
		sprintf(buf, ""%d:%02d:%02d"", hr, min, sec);
	else
		sprintf(buf, ""%d:%02d"", min, sec);
",1,unused,202,unused,"
	if (hr)
		sprintf(buf, ""%d:%02d:%02d"", hr, min, sec);
	else
		sprintf(buf, ""%d:%02d"", min, sec);
",unused,e2fsprogsources-misc2Fbadblocks.c
"
	str = malloc(strlen(device)+1);
	if (!str)
		return NULL;
	strcpy(str, device);
",1,unused,51,unused,"
	str = malloc(strlen(device)+1);
	if (!str)
		return NULL;
	strcpy(str, device);
",unused,e2fsprogsources-misc2Fbase_device.c
"					  mtpt, sizeof(mtpt));
	if (retval == 0) {
		if (mount_flags & EXT2_MF_MOUNTED) {
			if (!mtpt[0])
				strcpy(mtpt, ""(mounted, mtpt unknown)"");
",1,unused,219,unused,"					  mtpt, sizeof(mtpt));
	if (retval == 0) {
		if (mount_flags & EXT2_MF_MOUNTED) {
			if (!mtpt[0])
				strcpy(mtpt, ""(mounted, mtpt unknown)"");
",unused,e2fsprogsources-misc2Fblkid.c
"		if (mount_flags & EXT2_MF_MOUNTED) {
			if (!mtpt[0])
				strcpy(mtpt, ""(mounted, mtpt unknown)"");
		} else if (mount_flags & EXT2_MF_BUSY)
			strcpy(mtpt, ""(in use)"");
",1,unused,221,unused,"		if (mount_flags & EXT2_MF_MOUNTED) {
			if (!mtpt[0])
				strcpy(mtpt, ""(mounted, mtpt unknown)"");
		} else if (mount_flags & EXT2_MF_BUSY)
			strcpy(mtpt, ""(in use)"");
",unused,e2fsprogsources-misc2Fblkid.c
"				strcpy(mtpt, ""(mounted, mtpt unknown)"");
		} else if (mount_flags & EXT2_MF_BUSY)
			strcpy(mtpt, ""(in use)"");
		else
			strcpy(mtpt, ""(not mounted)"");
",1,unused,223,unused,"				strcpy(mtpt, ""(mounted, mtpt unknown)"");
		} else if (mount_flags & EXT2_MF_BUSY)
			strcpy(mtpt, ""(in use)"");
		else
			strcpy(mtpt, ""(not mounted)"");
",unused,e2fsprogsources-misc2Fblkid.c
"				_(""Couldn't allocate path variable ""
				  ""in chattr_dir_proc""));
			return -1;
		}
		sprintf(path, ""%s/%s"", dir_name, de->d_name);
",1,unused,301,unused,"				_(""Couldn't allocate path variable ""
				  ""in chattr_dir_proc""));
			return -1;
		}
		sprintf(path, ""%s/%s"", dir_name, de->d_name);
",unused,e2fsprogsources-misc2Fchattr.c
"		target->path = realloc(target->path, target->path_max_len);
		if (!target->path)
			return EXT2_ET_NO_MEMORY;
	}
	target->path_len += sprintf(target->path + target->path_len, ""/%s"",
",1,unused,709,unused,"		target->path = realloc(target->path, target->path_max_len);
		if (!target->path)
			return EXT2_ET_NO_MEMORY;
	}
	target->path_len += sprintf(target->path + target->path_len, ""/%s"",
",unused,e2fsprogsources-misc2Fcreate_inode.c
"		fprintf(stderr, ""%s"",
			_(""Couldn't allocate memory to parse options!\n""));
		exit(1);
	}
	strcpy(buf, opts);
",1,unused,437,unused,"		fprintf(stderr, ""%s"",
			_(""Couldn't allocate memory to parse options!\n""));
		exit(1);
	}
	strcpy(buf, opts);
",unused,e2fsprogsources-misc2Fdumpe2fs.c
"		end = 1 << (i + info->blocksize_bits - units);
		if (info->histogram.fc_chunks[i] != 0) {
			char end_str[32];

			sprintf(end_str, ""%5lu%c-"", end, *unitp);
",1,unused,301,unused,"		end = 1 << (i + info->blocksize_bits - units);
		if (info->histogram.fc_chunks[i] != 0) {
			char end_str[32];

			sprintf(end_str, ""%5lu%c-"", end, *unitp);
",unused,e2fsprogsources-misc2Fe2freefrag.c
"			char end_str[32];

			sprintf(end_str, ""%5lu%c-"", end, *unitp);
			if (i == MAX_HIST-1)
				strcpy(end_str, ""max "");
",1,unused,303,unused,"			char end_str[32];

			sprintf(end_str, ""%5lu%c-"", end, *unitp);
			if (i == MAX_HIST-1)
				strcpy(end_str, ""max "");
",unused,e2fsprogsources-misc2Fe2freefrag.c
"		exit(1);
	}

	hdr.magic_number = ext2fs_cpu_to_le32(EXT2_ET_MAGIC_E2IMAGE);
	strcpy(hdr.magic_descriptor, ""Ext2 Image 1.0"");
",1,unused,277,unused,"		exit(1);
	}

	hdr.magic_number = ext2fs_cpu_to_le32(EXT2_ET_MAGIC_E2IMAGE);
	strcpy(hdr.magic_descriptor, ""Ext2 Image 1.0"");
",unused,e2fsprogsources-misc2Fe2image.c
"			flags |= E2IMAGE_IS_QCOW2_FLAG;
			goto skip_device;
		}
	}
	sprintf(offset_opt, ""offset=%llu"", source_offset);
",1,unused,1581,unused,"			flags |= E2IMAGE_IS_QCOW2_FLAG;
			goto skip_device;
		}
	}
	sprintf(offset_opt, ""offset=%llu"", source_offset);
",unused,e2fsprogsources-misc2Fe2image.c
"	if (!s)
		return 0;
	ret = malloc(strlen(s)+1);
	if (ret)
		strcpy(ret, s);
",1,unused,165,unused,"	if (!s)
		return 0;
	ret = malloc(strlen(s)+1);
	if (ret)
		strcpy(ret, s);
",unused,e2fsprogsources-misc2Fe2initrd_helper.c
"	ext2fs_sha512(salt->key, EXT4_MAX_KEY_SIZE, key_ref1);
	ext2fs_sha512(key_ref1, SHA512_LENGTH, key_ref2);
	memcpy(salt->key_desc, key_ref2, EXT4_KEY_DESCRIPTOR_SIZE);
	for (x = 0; x < EXT4_KEY_DESCRIPTOR_SIZE; ++x) {
		sprintf(&salt->key_ref_str[x * 2], ""%02x"",
",1,unused,540,unused,"	ext2fs_sha512(salt->key, EXT4_MAX_KEY_SIZE, key_ref1);
	ext2fs_sha512(key_ref1, SHA512_LENGTH, key_ref2);
	memcpy(salt->key_desc, key_ref2, EXT4_KEY_DESCRIPTOR_SIZE);
	for (x = 0; x < EXT4_KEY_DESCRIPTOR_SIZE; ++x) {
		sprintf(&salt->key_ref_str[x * 2], ""%02x"",
",unused,e2fsprogsources-misc2Fe4crypt.c
"	if (keyring_id == 0) {
		printf(""Invalid keyring [%s].\n"", keyring);
		exit(1);
	}
	sprintf(key_ref_full, ""%s%s"", EXT2FS_KEY_DESC_PREFIX,
",1,unused,558,unused,"	if (keyring_id == 0) {
		printf(""Invalid keyring [%s].\n"", keyring);
		exit(1);
	}
	sprintf(key_ref_full, ""%s%s"", EXT2FS_KEY_DESC_PREFIX,
",unused,e2fsprogsources-misc2Fe4crypt.c
"		       argv[optind], (EXT4_KEY_DESCRIPTOR_SIZE * 2));
			exit(1);
	}
	validate_paths(argc, argv, optind+1);
	strcpy(saltbuf.key_ref_str, argv[optind]);
",1,unused,748,unused,"		       argv[optind], (EXT4_KEY_DESCRIPTOR_SIZE * 2));
			exit(1);
	}
	validate_paths(argc, argv, optind+1);
	strcpy(saltbuf.key_ref_str, argv[optind]);
",unused,e2fsprogsources-misc2Fe4crypt.c
"	}

	if (mode_flag & DETAIL) {
		/* Print statistic info */
		sprintf(msg_buffer, ""[%u/%u]%s"",
",1,unused,1213,unused,"	}

	if (mode_flag & DETAIL) {
		/* Print statistic info */
		sprintf(msg_buffer, ""[%u/%u]%s"",
",unused,e2fsprogsources-misc2Fe4defrag.c
"	}

	/* Create donor inode */
	memset(tmp_inode_name, 0, PATH_MAX + 8);
	sprintf(tmp_inode_name, ""%.*s.defrag"",
",1,unused,1531,unused,"	}

	/* Create donor inode */
	memset(tmp_inode_name, 0, PATH_MAX + 8);
	sprintf(tmp_inode_name, ""%.*s.defrag"",
",unused,e2fsprogsources-misc2Fe4defrag.c
"{
	if ((*flags & mask) == 0)
		return;

	strcat(buf, name);
",1,unused,134,unused,"{
	if ((*flags & mask) == 0)
		return;

	strcat(buf, name);
",unused,e2fsprogsources-misc2Ffilefrag.c
"		physical_blk = fm_extent->fe_physical >> blk_shift;
	}

	if (expected)
		sprintf(flags, ext_fmt == hex_fmt ? ""%*llx: "" : ""%*llu: "",
",1,unused,163,unused,"		physical_blk = fm_extent->fe_physical >> blk_shift;
	}

	if (expected)
		sprintf(flags, ext_fmt == hex_fmt ? ""%*llx: "" : ""%*llu: "",
",unused,e2fsprogsources-misc2Ffilefrag.c
"	if (expected)
		sprintf(flags, ext_fmt == hex_fmt ? ""%*llx: "" : ""%*llu: "",
			physical_width, expected >> blk_shift);
	else
		sprintf(flags, ""%.*s  "", physical_width, ""                   "");
",1,unused,166,unused,"	if (expected)
		sprintf(flags, ext_fmt == hex_fmt ? ""%*llx: "" : ""%*llu: "",
			physical_width, expected >> blk_shift);
	else
		sprintf(flags, ""%.*s  "", physical_width, ""                   "");
",unused,e2fsprogsources-misc2Ffilefrag.c
"		char hex[sizeof(mask) * 2 + 4]; /* 2 chars/byte + 0x, + NUL */

		if ((fe_flags & mask) == 0)
			continue;
		sprintf(hex, ""%#04x,"", mask);
",1,unused,186,unused,"		char hex[sizeof(mask) * 2 + 4]; /* 2 chars/byte + 0x, + NUL */

		if ((fe_flags & mask) == 0)
			continue;
		sprintf(hex, ""%#04x,"", mask);
",unused,e2fsprogsources-misc2Ffilefrag.c
"	}

	if (fm_extent->fe_logical + fm_extent->fe_length >=
	    (unsigned long long) st->st_size)
		strcat(flags, ""eof,"");
",1,unused,192,unused,"	}

	if (fm_extent->fe_logical + fm_extent->fe_length >=
	    (unsigned long long) st->st_size)
		strcat(flags, ""eof,"");
",unused,e2fsprogsources-misc2Ffilefrag.c
"	if (!s)
		return 0;
	ret = malloc(strlen(s)+1);
	if (ret)
		strcpy(ret, s);
",1,unused,135,unused,"	if (!s)
		return 0;
	ret = malloc(strlen(s)+1);
	if (ret)
		strcpy(ret, s);
",unused,e2fsprogsources-misc2Ffsck.c
"		if (!fsck_path) {
			fprintf(stderr, ""%s: Unable to allocate memory for fsck_path\n"", progname);
			exit(EXIT_ERROR);
		}
		strcpy (fsck_path, fsck_prefix_path);
",1,unused,1292,unused,"		if (!fsck_path) {
			fprintf(stderr, ""%s: Unable to allocate memory for fsck_path\n"", progname);
			exit(EXIT_ERROR);
		}
		strcpy (fsck_path, fsck_prefix_path);
",unused,e2fsprogsources-misc2Ffsck.c
"			fprintf(stderr, ""%s: Unable to allocate memory for fsck_path\n"", progname);
			exit(EXIT_ERROR);
		}
		strcpy (fsck_path, fsck_prefix_path);
		strcat (fsck_path, "":"");
",1,unused,1293,unused,"			fprintf(stderr, ""%s: Unable to allocate memory for fsck_path\n"", progname);
			exit(EXIT_ERROR);
		}
		strcpy (fsck_path, fsck_prefix_path);
		strcat (fsck_path, "":"");
",unused,e2fsprogsources-misc2Ffsck.c
"			exit(EXIT_ERROR);
		}
		strcpy (fsck_path, fsck_prefix_path);
		strcat (fsck_path, "":"");
		strcat (fsck_path, oldpath);
",1,unused,1294,unused,"			exit(EXIT_ERROR);
		}
		strcpy (fsck_path, fsck_prefix_path);
		strcat (fsck_path, "":"");
		strcat (fsck_path, oldpath);
",unused,e2fsprogsources-misc2Ffsck.c
"	if ( WIFEXITED(status) ) {
		rc = WEXITSTATUS(status);
		if (rc) {
			send_output(argv[0], 0, SEND_BOTH);
			sprintf(buffer, "" exited with status code %d\n"", rc);
",1,unused,213,unused,"	if ( WIFEXITED(status) ) {
		rc = WEXITSTATUS(status);
		if (rc) {
			send_output(argv[0], 0, SEND_BOTH);
			sprintf(buffer, "" exited with status code %d\n"", rc);
",unused,e2fsprogsources-misc2Flogsave.c
"		}
	} else {
		if (WIFSIGNALED(status)) {
			send_output(argv[0], 0, SEND_BOTH);
			sprintf(buffer, ""died with signal %d\n"",
",1,unused,219,unused,"		}
	} else {
		if (WIFSIGNALED(status)) {
			send_output(argv[0], 0, SEND_BOTH);
			sprintf(buffer, ""died with signal %d\n"",
",unused,e2fsprogsources-misc2Flogsave.c
"
	path = malloc(dir_len + strlen (de->d_name) + 2);

	if (dir_len && dir_name[dir_len-1] == '/')
		sprintf (path, ""%s%s"", dir_name, de->d_name);
",1,unused,149,unused,"
	path = malloc(dir_len + strlen (de->d_name) + 2);

	if (dir_len && dir_name[dir_len-1] == '/')
		sprintf (path, ""%s%s"", dir_name, de->d_name);
",unused,e2fsprogsources-misc2Flsattr.c
"
	if (dir_len && dir_name[dir_len-1] == '/')
		sprintf (path, ""%s%s"", dir_name, de->d_name);
	else
		sprintf (path, ""%s/%s"", dir_name, de->d_name);
",1,unused,151,unused,"
	if (dir_len && dir_name[dir_len-1] == '/')
		sprintf (path, ""%s%s"", dir_name, de->d_name);
	else
		sprintf (path, ""%s/%s"", dir_name, de->d_name);
",unused,e2fsprogsources-misc2Flsattr.c
"	if (!cp)
		return 0;
	if (strlen(path) > SYSFS_PATH_LEN - sizeof(""/start""))
		return 0;
	strcat(path, ""/start"");
",1,unused,199,unused,"	if (!cp)
		return 0;
	if (strlen(path) > SYSFS_PATH_LEN - sizeof(""/start""))
		return 0;
	strcat(path, ""/start"");
",unused,e2fsprogsources-misc2Fmk_hugefiles.c
"	fn = malloc(strlen(dir) + 1);
	if (fn == NULL)
		return ENOMEM;

	strcpy(fn, dir);
",1,unused,222,unused,"	fn = malloc(strlen(dir) + 1);
	if (fn == NULL)
		return ENOMEM;

	strcpy(fn, dir);
",unused,e2fsprogsources-misc2Fmk_hugefiles.c
"	if (retval)
		goto errout;

	if (idx_digits)
		sprintf(fn_numbuf, ""%0*lu"", idx_digits, idx);
",1,unused,383,unused,"	if (retval)
		goto errout;

	if (idx_digits)
		sprintf(fn_numbuf, ""%0*lu"", idx_digits, idx);
",unused,e2fsprogsources-misc2Fmk_hugefiles.c
"
	if (idx_digits)
		sprintf(fn_numbuf, ""%0*lu"", idx_digits, idx);
	else if (num_files > 1)
		sprintf(fn_numbuf, ""%lu"", idx);
",1,unused,385,unused,"
	if (idx_digits)
		sprintf(fn_numbuf, ""%0*lu"", idx_digits, idx);
	else if (num_files > 1)
		sprintf(fn_numbuf, ""%lu"", idx);
",unused,e2fsprogsources-misc2Fmk_hugefiles.c
"	if (!fn_buf) {
		free(fn_prefix);
		return ENOMEM;
	}
	strcpy(fn_buf, fn_prefix);
",1,unused,543,unused,"	if (!fn_buf) {
		free(fn_prefix);
		return ENOMEM;
	}
	strcpy(fn_buf, fn_prefix);
",unused,e2fsprogsources-misc2Fmk_hugefiles.c
"	FILE		*f;
	errcode_t	retval;
	char		buf[1024];

	sprintf(buf, ""badblocks -b %d -X %s%s%s %llu"", fs->blocksize,
",1,unused,256,unused,"	FILE		*f;
	errcode_t	retval;
	char		buf[1024];

	sprintf(buf, ""badblocks -b %d -X %s%s%s %llu"", fs->blocksize,
",unused,e2fsprogsources-misc2Fmke2fs.c
"		fprintf(stderr, ""%s"",
			_(""Couldn't allocate memory to parse options!\n""));
		exit(1);
	}
	strcpy(buf, opts);
",1,unused,794,unused,"		fprintf(stderr, ""%s"",
			_(""Couldn't allocate memory to parse options!\n""));
		exit(1);
	}
	strcpy(buf, opts);
",unused,e2fsprogsources-misc2Fmke2fs.c
"	}
	sl->list[sl->num] = malloc(strlen(str)+1);
	if (sl->list[sl->num] == 0)
		return ENOMEM;
	strcpy(sl->list[sl->num], str);
",1,unused,1186,unused,"	}
	sl->list[sl->num] = malloc(strlen(str)+1);
	if (sl->list[sl->num] == 0)
		return ENOMEM;
	strcpy(sl->list[sl->num], str);
",unused,e2fsprogsources-misc2Fmke2fs.c
"		free(profile_type);
		free(list.list);
		return 0;
	}
	strcpy(parse_str, usage_types);
",1,unused,1319,unused,"		free(profile_type);
		free(list.list);
		return 0;
	}
	strcpy(parse_str, usage_types);
",unused,e2fsprogsources-misc2Fmke2fs.c
"		fprintf(stderr, ""%s"",
			_(""Couldn't allocate memory for new PATH.\n""));
		exit(1);
	}
	strcpy(newpath, PATH_SET);
",1,unused,1519,unused,"		fprintf(stderr, ""%s"",
			_(""Couldn't allocate memory for new PATH.\n""));
		exit(1);
	}
	strcpy(newpath, PATH_SET);
",unused,e2fsprogsources-misc2Fmke2fs.c
"	strcpy(newpath, PATH_SET);

	/* Update our PATH to include /sbin  */
	if (oldpath) {
		strcat (newpath, "":"");
",1,unused,1523,unused,"	strcpy(newpath, PATH_SET);

	/* Update our PATH to include /sbin  */
	if (oldpath) {
		strcat (newpath, "":"");
",unused,e2fsprogsources-misc2Fmke2fs.c
"
	/* Update our PATH to include /sbin  */
	if (oldpath) {
		strcat (newpath, "":"");
		strcat (newpath, oldpath);
",1,unused,1524,unused,"
	/* Update our PATH to include /sbin  */
	if (oldpath) {
		strcat (newpath, "":"");
		strcat (newpath, oldpath);
",unused,e2fsprogsources-misc2Fmke2fs.c
"				com_err(program_name, ENOMEM, ""%s"",
					_(""in malloc for bad_blocks_filename""));
				exit(1);
			}
			strcpy(bad_blocks_filename, optarg);
",1,unused,1716,unused,"				com_err(program_name, ENOMEM, ""%s"",
					_(""in malloc for bad_blocks_filename""));
				exit(1);
			}
			strcpy(bad_blocks_filename, optarg);
",unused,e2fsprogsources-misc2Fmke2fs.c
"				     _(""while allocating fs_feature string""));
				exit(1);
			}
			if (fs_features_size)
				strcat(fs_features, "","");
",1,unused,1763,unused,"				     _(""while allocating fs_feature string""));
				exit(1);
			}
			if (fs_features_size)
				strcat(fs_features, "","");
",unused,e2fsprogsources-misc2Fmke2fs.c
"			if (fs_features_size)
				strcat(fs_features, "","");
			else
				fs_features[0] = 0;
			strcat(fs_features, optarg);
",1,unused,1766,unused,"			if (fs_features_size)
				strcat(fs_features, "","");
			else
				fs_features[0] = 0;
			strcat(fs_features, optarg);
",unused,e2fsprogsources-misc2Fmke2fs.c
"	if (!tdb_file) {
		free(tmp_name);
		goto errout;
	}
	sprintf(tdb_file, ""%s/mke2fs-%s.e2undo"", tdb_dir, dev_name);
",1,unused,2636,unused,"	if (!tdb_file) {
		free(tmp_name);
		goto errout;
	}
	sprintf(tdb_file, ""%s/mke2fs-%s.e2undo"", tdb_dir, dev_name);
",unused,e2fsprogsources-misc2Fmke2fs.c
"			com_err(program_name, ENOMEM, ""%s"",
				_(""in malloc for android_sparse_params""));
			exit(1);
		}
		sprintf(android_sparse_params, ""(%s):%u:%u"",
",1,unused,2880,unused,"			com_err(program_name, ENOMEM, ""%s"",
				_(""in malloc for android_sparse_params""));
			exit(1);
		}
		sprintf(android_sparse_params, ""(%s):%u:%u"",
",unused,e2fsprogsources-misc2Fmke2fs.c
"	if (!journal_device && ((journal_size) ||
	    ext2fs_has_feature_journal(&fs_param)))
		journal_blocks = figure_journal_size(journal_size, fs);

	sprintf(opt_string, ""tdb_data_size=%d"", fs->blocksize <= 4096 ?
",1,unused,2932,unused,"	if (!journal_device && ((journal_size) ||
	    ext2fs_has_feature_journal(&fs_param)))
		journal_blocks = figure_journal_size(journal_size, fs);

	sprintf(opt_string, ""tdb_data_size=%d"", fs->blocksize <= 4096 ?
",unused,e2fsprogsources-misc2Fmke2fs.c
"	sprintf(opt_string, ""tdb_data_size=%d"", fs->blocksize <= 4096 ?
		32768 : fs->blocksize * 8);
	io_channel_set_options(fs->io, opt_string);
	if (offset) {
		sprintf(opt_string, ""offset=%llu"", offset);
",1,unused,2936,unused,"	sprintf(opt_string, ""tdb_data_size=%d"", fs->blocksize <= 4096 ?
		32768 : fs->blocksize * 8);
	io_channel_set_options(fs->io, opt_string);
	if (offset) {
		sprintf(opt_string, ""offset=%llu"", offset);
",unused,e2fsprogsources-misc2Fmke2fs.c
"
	i = 0;
	memset (name, 'x', 246);
	do {
		sprintf (name + 246, ""%08d"", i);
",1,unused,61,unused,"
	i = 0;
	memset (name, 'x', 246);
	do {
		sprintf (name + 246, ""%08d"", i);
",unused,e2fsprogsources-misc2Fmklost+found.c
"	i = 0;
	memset (name, 'x', 246);
	do {
		sprintf (name + 246, ""%08d"", i);
		strcpy (path, LPF);
",1,unused,62,unused,"	i = 0;
	memset (name, 'x', 246);
	do {
		sprintf (name + 246, ""%08d"", i);
		strcpy (path, LPF);
",unused,e2fsprogsources-misc2Fmklost+found.c
"	memset (name, 'x', 246);
	do {
		sprintf (name + 246, ""%08d"", i);
		strcpy (path, LPF);
		strcat (path, ""/"");
",1,unused,63,unused,"	memset (name, 'x', 246);
	do {
		sprintf (name + 246, ""%08d"", i);
		strcpy (path, LPF);
		strcat (path, ""/"");
",unused,e2fsprogsources-misc2Fmklost+found.c
"	do {
		sprintf (name + 246, ""%08d"", i);
		strcpy (path, LPF);
		strcat (path, ""/"");
		strcat (path, name);
",1,unused,64,unused,"	do {
		sprintf (name + 246, ""%08d"", i);
		strcpy (path, LPF);
		strcat (path, ""/"");
		strcat (path, name);
",unused,e2fsprogsources-misc2Fmklost+found.c
"			exit (1);
		}
	} while (st.st_size <= (EXT2_NDIR_BLOCKS - 1) * st.st_blksize);
	for (j = 0; j < i; j++) {
		sprintf (name + 246, ""%08d"", j);
",1,unused,77,unused,"			exit (1);
		}
	} while (st.st_size <= (EXT2_NDIR_BLOCKS - 1) * st.st_blksize);
	for (j = 0; j < i; j++) {
		sprintf (name + 246, ""%08d"", j);
",unused,e2fsprogsources-misc2Fmklost+found.c
"		}
	} while (st.st_size <= (EXT2_NDIR_BLOCKS - 1) * st.st_blksize);
	for (j = 0; j < i; j++) {
		sprintf (name + 246, ""%08d"", j);
		strcpy (path, LPF);
",1,unused,78,unused,"		}
	} while (st.st_size <= (EXT2_NDIR_BLOCKS - 1) * st.st_blksize);
	for (j = 0; j < i; j++) {
		sprintf (name + 246, ""%08d"", j);
		strcpy (path, LPF);
",unused,e2fsprogsources-misc2Fmklost+found.c
"	} while (st.st_size <= (EXT2_NDIR_BLOCKS - 1) * st.st_blksize);
	for (j = 0; j < i; j++) {
		sprintf (name + 246, ""%08d"", j);
		strcpy (path, LPF);
		strcat (path, ""/"");
",1,unused,79,unused,"	} while (st.st_size <= (EXT2_NDIR_BLOCKS - 1) * st.st_blksize);
	for (j = 0; j < i; j++) {
		sprintf (name + 246, ""%08d"", j);
		strcpy (path, LPF);
		strcat (path, ""/"");
",unused,e2fsprogsources-misc2Fmklost+found.c
"	for (j = 0; j < i; j++) {
		sprintf (name + 246, ""%08d"", j);
		strcpy (path, LPF);
		strcat (path, ""/"");
		strcat (path, name);
",1,unused,80,unused,"	for (j = 0; j < i; j++) {
		sprintf (name + 246, ""%08d"", j);
		strcpy (path, LPF);
		strcat (path, ""/"");
		strcat (path, name);
",unused,e2fsprogsources-misc2Fmklost+found.c
"		fprintf(stderr, ""%s"",
			_(""Couldn't allocate memory to parse options!\n""));
		return 1;
	}
	strcpy(buf, opts);
",1,unused,2074,unused,"		fprintf(stderr, ""%s"",
			_(""Couldn't allocate memory to parse options!\n""));
		return 1;
	}
	strcpy(buf, opts);
",unused,e2fsprogsources-misc2Ftune2fs.c
"	if (!tdb_file) {
		free(tmp_name);
		goto errout;
	}
	sprintf(tdb_file, ""%s/tune2fs-%s.e2undo"", tdb_dir, dev_name);
",1,unused,2780,unused,"	if (!tdb_file) {
		free(tmp_name);
		goto errout;
	}
	sprintf(tdb_file, ""%s/tune2fs-%s.e2undo"", tdb_dir, dev_name);
",unused,e2fsprogsources-misc2Ftune2fs.c
"		fputs(_(""Couldn't allocate memory to parse journal ""
			""options!\n""), stderr);
		exit(1);
	}
	strcpy(buf, opts);
",1,unused,165,unused,"		fputs(_(""Couldn't allocate memory to parse journal ""
			""options!\n""), stderr);
		exit(1);
	}
	strcpy(buf, opts);
",unused,e2fsprogsources-misc2Futil.c
"	signal(SIGTERM, terminate_intr);
	signal(SIGALRM, terminate_intr);
	signal(SIGPIPE, SIG_IGN);

	sprintf(reply_buf, ""%8d\n"", getpid());
",1,unused,331,unused,"	signal(SIGTERM, terminate_intr);
	signal(SIGALRM, terminate_intr);
	signal(SIGPIPE, SIG_IGN);

	sprintf(reply_buf, ""%8d\n"", getpid());
",unused,e2fsprogsources-misc2Fuuidd.c
"			printf(""operation %d\n"", op);

		switch(op) {
		case UUIDD_OP_GETPID:
			sprintf(reply_buf, ""%d"", getpid());
",1,unused,369,unused,"			printf(""operation %d\n"", op);

		switch(op) {
		case UUIDD_OP_GETPID:
			sprintf(reply_buf, ""%d"", getpid());
",unused,e2fsprogsources-misc2Fuuidd.c
"			sprintf(reply_buf, ""%d"", getpid());
			reply_len = strlen(reply_buf)+1;
			break;
		case UUIDD_OP_GET_MAXOP:
			sprintf(reply_buf, ""%d"", UUIDD_MAX_OP);
",1,unused,373,unused,"			sprintf(reply_buf, ""%d"", getpid());
			reply_len = strlen(reply_buf)+1;
			break;
		case UUIDD_OP_GET_MAXOP:
			sprintf(reply_buf, ""%d"", UUIDD_MAX_OP);
",unused,e2fsprogsources-misc2Fuuidd.c
"	if (!tdb_file) {
		free(tmp_name);
		goto errout;
	}
	sprintf(tdb_file, ""%s/resize2fs-%s.e2undo"", tdb_dir, dev_name);
",1,unused,216,unused,"	if (!tdb_file) {
		free(tmp_name);
		goto errout;
	}
	sprintf(tdb_file, ""%s/resize2fs-%s.e2undo"", tdb_dir, dev_name);
",unused,e2fsprogsources-resize2Fmain.c
"	if (retval) {
		free(prog);
		return retval;
	}
	strcpy(prog->label, label);
",1,unused,96,unused,"	if (retval) {
		free(prog);
		return retval;
	}
	strcpy(prog->label, label);
",unused,e2fsprogsources-resize2Fsim_progress.c
"		goto fail;
	ent->value = (char *) malloc(strlen(value)+1);
	if (!ent->value)
		goto fail;
	strcpy(ent->name, name);
",1,unused,65,unused,"		goto fail;
	ent->value = (char *) malloc(strlen(value)+1);
	if (!ent->value)
		goto fail;
	strcpy(ent->name, name);
",unused,e2fsprogsources-util2Fsubst.c
"	ent->value = (char *) malloc(strlen(value)+1);
	if (!ent->value)
		goto fail;
	strcpy(ent->name, name);
	strcpy(ent->value, value);
",1,unused,66,unused,"	ent->value = (char *) malloc(strlen(value)+1);
	if (!ent->value)
		goto fail;
	strcpy(ent->name, name);
	strcpy(ent->value, value);
",unused,e2fsprogsources-util2Fsubst.c
"		if (!newfn) {
			fprintf(stderr, ""Memory error!  Exiting.\n"");
			exit(1);
		}
		strcpy(newfn, outfn);
",1,unused,376,unused,"		if (!newfn) {
			fprintf(stderr, ""Memory error!  Exiting.\n"");
			exit(1);
		}
		strcpy(newfn, outfn);
",unused,e2fsprogsources-util2Fsubst.c
"			fprintf(stderr, ""Memory error!  Exiting.\n"");
			exit(1);
		}
		strcpy(newfn, outfn);
		strcat(newfn, "".new"");
",1,unused,377,unused,"			fprintf(stderr, ""Memory error!  Exiting.\n"");
			exit(1);
		}
		strcpy(newfn, outfn);
		strcat(newfn, "".new"");
",unused,e2fsprogsources-util2Fsubst.c
"	char buf[200];
	unsigned long v;
	char *tmp;

	sprintf(buf, format, *val);
",1,unused,1146,unused,"	char buf[200];
	unsigned long v;
	char *tmp;

	sprintf(buf, format, *val);
",unused,e2fsprogsxenpatch-debugfs2Fdebugfs.c
"	char buf[200];
	unsigned long v;
	char *tmp;

	sprintf(buf, format, *val);
",1,unused,1168,unused,"	char buf[200];
	unsigned long v;
	char *tmp;

	sprintf(buf, format, *val);
",unused,e2fsprogsxenpatch-debugfs2Fdebugfs.c
"	char buf[200];
	unsigned long v;
	char *tmp;

	sprintf(buf, format, *val);
",1,unused,1190,unused,"	char buf[200];
	unsigned long v;
	char *tmp;

	sprintf(buf, format, *val);
",unused,e2fsprogsxenpatch-debugfs2Fdebugfs.c
"	if (fsize)
		modify_u8(argv[0], ""Fragment size"", decimal_format, fsize);

	for (i=0;  i < EXT2_NDIR_BLOCKS; i++) {
		sprintf(buf, ""Direct Block #%d"", i);
",1,unused,1270,unused,"	if (fsize)
		modify_u8(argv[0], ""Fragment size"", decimal_format, fsize);

	for (i=0;  i < EXT2_NDIR_BLOCKS; i++) {
		sprintf(buf, ""Direct Block #%d"", i);
",unused,e2fsprogsxenpatch-debugfs2Fdebugfs.c
"
	/* Apparently, this is the right way to detect and handle fast
	 * symlinks; see do_stat() in debugfs.c. */
	if (inode->i_blocks == 0)
		strcpy(buf, (char *) inode->i_block);
",1,unused,214,unused,"
	/* Apparently, this is the right way to detect and handle fast
	 * symlinks; see do_stat() in debugfs.c. */
	if (inode->i_blocks == 0)
		strcpy(buf, (char *) inode->i_block);
",unused,e2fsprogsxenpatch-debugfs2Fdump.c
"	if (!fullname) {
		com_err(""rdump"", errno, ""while allocating memory"");
		return;
	}
	sprintf(fullname, ""%s/%s"", dumproot, name);
",1,unused,264,unused,"	if (!fullname) {
		com_err(""rdump"", errno, ""while allocating memory"");
		return;
	}
	sprintf(fullname, ""%s/%s"", dumproot, name);
",unused,e2fsprogsxenpatch-debugfs2Fdump.c
"	current_ino = inode;

	orig_prompt = ss_get_prompt(sci_idx);
	extent_prompt = malloc(strlen(orig_prompt) + 32);
	strcpy(extent_prompt, orig_prompt);
",1,unused,100,unused,"	current_ino = inode;

	orig_prompt = ss_get_prompt(sci_idx);
	extent_prompt = malloc(strlen(orig_prompt) + 32);
	strcpy(extent_prompt, orig_prompt);
",unused,e2fsprogsxenpatch-debugfs2Fextent_inode.c
"	strcpy(extent_prompt, orig_prompt);
	cp = strchr(extent_prompt, ':');
	if (cp)
		*cp = 0;
	sprintf(extent_prompt + strlen(extent_prompt), "" (extent ino %d): "",
",1,unused,104,unused,"	strcpy(extent_prompt, orig_prompt);
	cp = strchr(extent_prompt, ':');
	if (cp)
		*cp = 0;
	sprintf(extent_prompt + strlen(extent_prompt), "" (extent ino %d): "",
",unused,e2fsprogsxenpatch-debugfs2Fextent_inode.c
"			fs->dir_name, name);
		return 0;
	}

	sprintf(cp, ""%s/%s"", fs->dir_name, name);
",1,unused,201,unused,"			fs->dir_name, name);
		return 0;
	}

	sprintf(cp, ""%s/%s"", fs->dir_name, name);
",unused,e2fsprogsxenpatch-debugfs2Ffilefrag.c
"
	arg = malloc(strlen(field)+1);
	if (!arg)
		return NULL;
	strcpy(arg, field);
",1,unused,308,unused,"
	arg = malloc(strlen(field)+1);
	if (!arg)
		return NULL;
	strcpy(arg, field);
",unused,e2fsprogsxenpatch-debugfs2Fset_fields.c
"		fprintf(stderr, ""Error maximum size for %s is %d.\n"",
			info->name, info->size);
		return EINVAL;
	}
	strcpy(cp, arg);
",1,unused,488,unused,"		fprintf(stderr, ""Error maximum size for %s is %d.\n"",
			info->name, info->size);
		return EINVAL;
	}
	strcpy(cp, arg);
",unused,e2fsprogsxenpatch-debugfs2Fset_fields.c
"		else if (ss->func == parse_bmap)
			type = ""set physical->logical block map"";
		else if (ss->func == parse_gd_csum)
			type = ""unsigned integer OR \""calc\"""";
		strcpy(name, ss->name);
",1,unused,629,unused,"		else if (ss->func == parse_bmap)
			type = ""set physical->logical block map"";
		else if (ss->func == parse_gd_csum)
			type = ""unsigned integer OR \""calc\"""";
		strcpy(name, ss->name);
",unused,e2fsprogsxenpatch-debugfs2Fset_fields.c
"			type = ""unsigned integer OR \""calc\"""";
		strcpy(name, ss->name);
		if (ss->flags & FLAG_ARRAY) {
			if (ss->max_idx > 0)
				sprintf(idx, ""[%d]"", ss->max_idx);
",1,unused,632,unused,"			type = ""unsigned integer OR \""calc\"""";
		strcpy(name, ss->name);
		if (ss->flags & FLAG_ARRAY) {
			if (ss->max_idx > 0)
				sprintf(idx, ""[%d]"", ss->max_idx);
",unused,e2fsprogsxenpatch-debugfs2Fset_fields.c
"		if (ss->flags & FLAG_ARRAY) {
			if (ss->max_idx > 0)
				sprintf(idx, ""[%d]"", ss->max_idx);
			else
				strcpy(idx, ""[]"");
",1,unused,634,unused,"		if (ss->flags & FLAG_ARRAY) {
			if (ss->max_idx > 0)
				sprintf(idx, ""[%d]"", ss->max_idx);
			else
				strcpy(idx, ""[]"");
",unused,e2fsprogsxenpatch-debugfs2Fset_fields.c
"			if (ss->max_idx > 0)
				sprintf(idx, ""[%d]"", ss->max_idx);
			else
				strcpy(idx, ""[]"");
			strcat(name, idx);
",1,unused,635,unused,"			if (ss->max_idx > 0)
				sprintf(idx, ""[%d]"", ss->max_idx);
			else
				strcpy(idx, ""[]"");
			strcat(name, idx);
",unused,e2fsprogsxenpatch-debugfs2Fset_fields.c
"				strcpy(idx, ""[]"");
			strcat(name, idx);
		}
		if (ss->ptr2)
			strcat(name, ""[_hi|_lo]"");
",1,unused,638,unused,"				strcpy(idx, ""[]"");
			strcat(name, idx);
		}
		if (ss->ptr2)
			strcat(name, ""[_hi|_lo]"");
",unused,e2fsprogsxenpatch-debugfs2Fset_fields.c
"	const char **i, **j;

	for (i = pager_search_list; *i; i++) {
		for (j = pager_dir_list; *j; j++) {
			sprintf(buf, ""%s/%s"", *j, *i);
",1,unused,72,unused,"	const char **i, **j;

	for (i = pager_search_list; *i; i++) {
		for (j = pager_dir_list; *j; j++) {
			sprintf(buf, ""%s/%s"", *j, *i);
",unused,e2fsprogsxenpatch-debugfs2Futil.c
"				_(""while trying to open %s""), bad_blocks_file);
			goto fatal;
		}
	} else {
		sprintf(buf, ""badblocks -b %d -X %s%s%s %llu"", fs->blocksize,
",1,unused,76,unused,"				_(""while trying to open %s""), bad_blocks_file);
			goto fatal;
		}
	} else {
		sprintf(buf, ""badblocks -b %d -X %s%s%s %llu"", fs->blocksize,
",unused,e2fsprogsxenpatch-e2fsck2Fbadblocks.c
"	if (retval)
		return;

	uuid_unparse(ctx->fs->super->s_uuid, uuid);
	sprintf(db->tdb_fn, ""%s/%s-dirinfo-XXXXXX"", tdb_dir, uuid);
",1,unused,65,unused,"	if (retval)
		return;

	uuid_unparse(ctx->fs->super->s_uuid, uuid);
	sprintf(db->tdb_fn, ""%s/%s-dirinfo-XXXXXX"", tdb_dir, uuid);
",unused,e2fsprogsxenpatch-e2fsck2Fdirinfo.c
"	case '%':
		append_string(s, ""%"", 1);
		return;
	case 'd':
		sprintf(buf, ""%02d"", tm->tm_mday);
",1,unused,90,unused,"	case '%':
		append_string(s, ""%"", 1);
		return;
	case 'd':
		sprintf(buf, ""%02d"", tm->tm_mday);
",unused,e2fsprogsxenpatch-e2fsck2Flogfile.c
"	case 'd':
		sprintf(buf, ""%02d"", tm->tm_mday);
		break;
	case 'D':
		sprintf(buf, ""%d%02d%02d"", tm->tm_year + 1900, tm->tm_mon + 1,
",1,unused,93,unused,"	case 'd':
		sprintf(buf, ""%02d"", tm->tm_mday);
		break;
	case 'D':
		sprintf(buf, ""%d%02d%02d"", tm->tm_year + 1900, tm->tm_mon + 1,
",unused,e2fsprogsxenpatch-e2fsck2Flogfile.c
"		buf[sizeof(buf)-1] = 0;
#endif
		break;
	case 'H':
		sprintf(buf, ""%02d"", tm->tm_hour);
",1,unused,106,unused,"		buf[sizeof(buf)-1] = 0;
#endif
		break;
	case 'H':
		sprintf(buf, ""%02d"", tm->tm_hour);
",unused,e2fsprogsxenpatch-e2fsck2Flogfile.c
"	case 'H':
		sprintf(buf, ""%02d"", tm->tm_hour);
		break;
	case 'm':
		sprintf(buf, ""%02d"", tm->tm_mon + 1);
",1,unused,109,unused,"	case 'H':
		sprintf(buf, ""%02d"", tm->tm_hour);
		break;
	case 'm':
		sprintf(buf, ""%02d"", tm->tm_mon + 1);
",unused,e2fsprogsxenpatch-e2fsck2Flogfile.c
"	case 'm':
		sprintf(buf, ""%02d"", tm->tm_mon + 1);
		break;
	case 'M':
		sprintf(buf, ""%02d"", tm->tm_min);
",1,unused,112,unused,"	case 'm':
		sprintf(buf, ""%02d"", tm->tm_mon + 1);
		break;
	case 'M':
		sprintf(buf, ""%02d"", tm->tm_min);
",unused,e2fsprogsxenpatch-e2fsck2Flogfile.c
"			cp = ctx->filesystem_name;
		append_string(s, cp, 0);
		return;
	case 'p':
		sprintf(buf, ""%lu"", (unsigned long) getpid());
",1,unused,123,unused,"			cp = ctx->filesystem_name;
		append_string(s, cp, 0);
		return;
	case 'p':
		sprintf(buf, ""%lu"", (unsigned long) getpid());
",unused,e2fsprogsxenpatch-e2fsck2Flogfile.c
"	case 'p':
		sprintf(buf, ""%lu"", (unsigned long) getpid());
		break;
	case 's':
		sprintf(buf, ""%lu"", (unsigned long) ctx->now);
",1,unused,126,unused,"	case 'p':
		sprintf(buf, ""%lu"", (unsigned long) getpid());
		break;
	case 's':
		sprintf(buf, ""%lu"", (unsigned long) ctx->now);
",unused,e2fsprogsxenpatch-e2fsck2Flogfile.c
"	case 's':
		sprintf(buf, ""%lu"", (unsigned long) ctx->now);
		break;
	case 'S':
		sprintf(buf, ""%02d"", tm->tm_sec);
",1,unused,129,unused,"	case 's':
		sprintf(buf, ""%lu"", (unsigned long) ctx->now);
		break;
	case 'S':
		sprintf(buf, ""%02d"", tm->tm_sec);
",unused,e2fsprogsxenpatch-e2fsck2Flogfile.c
"	case 'S':
		sprintf(buf, ""%02d"", tm->tm_sec);
		break;
	case 'T':
		sprintf(buf, ""%02d%02d%02d"", tm->tm_hour, tm->tm_min,
",1,unused,132,unused,"	case 'S':
		sprintf(buf, ""%02d"", tm->tm_sec);
		break;
	case 'T':
		sprintf(buf, ""%02d%02d%02d"", tm->tm_hour, tm->tm_min,
",unused,e2fsprogsxenpatch-e2fsck2Flogfile.c
"	case 'U':
		*flags |= FLAG_UTC;
		return;
	case 'y':
		sprintf(buf, ""%02d"", tm->tm_year % 100);
",1,unused,153,unused,"	case 'U':
		*flags |= FLAG_UTC;
		return;
	case 'y':
		sprintf(buf, ""%02d"", tm->tm_year % 100);
",unused,e2fsprogsxenpatch-e2fsck2Flogfile.c
"	case 'y':
		sprintf(buf, ""%02d"", tm->tm_year % 100);
		break;
	case 'Y':
		sprintf(buf, ""%d"", tm->tm_year + 1900);
",1,unused,156,unused,"	case 'y':
		sprintf(buf, ""%02d"", tm->tm_year % 100);
		break;
	case 'Y':
		sprintf(buf, ""%d"", tm->tm_year + 1900);
",unused,e2fsprogsxenpatch-e2fsck2Flogfile.c
"
#if 0
		printf(""%u "", pctx.ino);
#endif
		sprintf(buf, _(""reading indirect blocks of inode %u""),
",1,unused,1336,unused,"
#if 0
		printf(""%u "", pctx.ino);
#endif
		sprintf(buf, _(""reading indirect blocks of inode %u""),
",unused,e2fsprogsxenpatch-e2fsck2Fpass1.c
"		fix_problem(ctx, PR_3_NO_LPF, &pctx);
		return 1;
	}

	sprintf(name, ""#%u"", ino);
",1,unused,549,unused,"		fix_problem(ctx, PR_3_NO_LPF, &pctx);
		return 1;
	}

	sprintf(name, ""#%u"", ino);
",unused,e2fsprogsxenpatch-e2fsck2Fpass3.c
"	}
	if (!(ptr->flags & PR_CONFIG)) {
		char	key[9], *new_desc = NULL;

		sprintf(key, ""0x%06x"", code);
",1,unused,1877,unused,"	}
	if (!(ptr->flags & PR_CONFIG)) {
		char	key[9], *new_desc = NULL;

		sprintf(key, ""0x%06x"", code);
",unused,e2fsprogsxenpatch-e2fsck2Fproblem.c
"
		newpath = malloc(len);
		if (!newpath)
			fatal_error(ctx, ""Couldn't malloc() newpath"");
		strcpy(newpath, PATH_SET);
",1,unused,1018,unused,"
		newpath = malloc(len);
		if (!newpath)
			fatal_error(ctx, ""Couldn't malloc() newpath"");
		strcpy(newpath, PATH_SET);
",unused,e2fsprogsxenpatch-e2fsck2Funix.c
"			fatal_error(ctx, ""Couldn't malloc() newpath"");
		strcpy(newpath, PATH_SET);

		if (oldpath) {
			strcat(newpath, "":"");
",1,unused,1021,unused,"			fatal_error(ctx, ""Couldn't malloc() newpath"");
		strcpy(newpath, PATH_SET);

		if (oldpath) {
			strcat(newpath, "":"");
",unused,e2fsprogsxenpatch-e2fsck2Funix.c
"		strcpy(newpath, PATH_SET);

		if (oldpath) {
			strcat(newpath, "":"");
			strcat(newpath, oldpath);
",1,unused,1022,unused,"		strcpy(newpath, PATH_SET);

		if (oldpath) {
			strcat(newpath, "":"");
			strcat(newpath, oldpath);
",unused,e2fsprogsxenpatch-e2fsck2Funix.c
"	printf(""Allocating %u bytes for %s...\n"", size, description);
#endif
	ret = malloc(size);
	if (!ret) {
		sprintf(buf, ""Can't allocate %u bytes for %s\n"",
",1,unused,124,unused,"	printf(""Allocating %u bytes for %s...\n"", size, description);
#endif
	ret = malloc(size);
	if (!ret) {
		sprintf(buf, ""Can't allocate %u bytes for %s\n"",
",unused,e2fsprogsxenpatch-e2fsck2Futil.c
"		free(new_type);
		free(new_value);
		return -1;
	}
	strcpy(new_type, search_type);
",1,unused,144,unused,"		free(new_type);
		free(new_value);
		return -1;
	}
	strcpy(new_type, search_type);
",unused,e2fsprogsxenpatch-lib2Fblkid2Fdev.c
"		free(new_value);
		return -1;
	}
	strcpy(new_type, search_type);
	strcpy(new_value, search_value);
",1,unused,145,unused,"		free(new_value);
		return -1;
	}
	strcpy(new_type, search_type);
	strcpy(new_value, search_value);
",unused,e2fsprogsxenpatch-lib2Fblkid2Fdev.c
"		    !strcmp(de->d_name, devname) ||
		    strncmp(de->d_name, ""dm-"", 3) ||
		    strlen(de->d_name) > sizeof(path)-32)
			continue;
		sprintf(path, ""/sys/block/%s/slaves"", de->d_name);
",1,unused,137,unused,"		    !strcmp(de->d_name, devname) ||
		    strncmp(de->d_name, ""dm-"", 3) ||
		    strlen(de->d_name) > sizeof(path)-32)
			continue;
		sprintf(path, ""/sys/block/%s/slaves"", de->d_name);
",unused,e2fsprogsxenpatch-lib2Fblkid2Fdevname.c
"	for (dir = dirlist; *dir; dir++) {
		struct stat st;
		char device[256];

		sprintf(device, ""%s/%s"", *dir, ptname);
",1,unused,226,unused,"	for (dir = dirlist; *dir; dir++) {
		struct stat st;
		char device[256];

		sprintf(device, ""%s/%s"", *dir, ptname);
",unused,e2fsprogsxenpatch-lib2Fblkid2Fdevname.c
"			continue;
		vdirname = malloc(vg_len + strlen(vg_name) + 8);
		if (!vdirname)
			goto exit;
		sprintf(vdirname, ""%s/%s/LVs"", VG_DIR, vg_name);
",1,unused,323,unused,"			continue;
		vdirname = malloc(vg_len + strlen(vg_name) + 8);
		if (!vdirname)
			goto exit;
		sprintf(vdirname, ""%s/%s/LVs"", VG_DIR, vg_name);
",unused,e2fsprogsxenpatch-lib2Fblkid2Fdevname.c
"			if (!lvm_device) {
				closedir(lv_list);
				goto exit;
			}
			sprintf(lvm_device, ""%s/%s/LVs/%s"", VG_DIR, vg_name,
",1,unused,343,unused,"			if (!lvm_device) {
				closedir(lv_list);
				goto exit;
			}
			sprintf(lvm_device, ""%s/%s/LVs/%s"", VG_DIR, vg_name,
",unused,e2fsprogsxenpatch-lib2Fblkid2Fdevname.c
"			}
			sprintf(lvm_device, ""%s/%s/LVs/%s"", VG_DIR, vg_name,
				lv_name);
			dev = lvm_get_devno(lvm_device);
			sprintf(lvm_device, ""%s/%s"", vg_name, lv_name);
",1,unused,346,unused,"			}
			sprintf(lvm_device, ""%s/%s/LVs/%s"", VG_DIR, vg_name,
				lv_name);
			dev = lvm_get_devno(lvm_device);
			sprintf(lvm_device, ""%s/%s"", vg_name, lv_name);
",unused,e2fsprogsxenpatch-lib2Fblkid2Fdevname.c
"		    ((dp->d_name[1] == 0) ||
		     ((dp->d_name[1] == '.') && (dp->d_name[2] == 0))))
			continue;

		sprintf(path, ""%s/%s"", dirname, dp->d_name);
",1,unused,115,unused,"		    ((dp->d_name[1] == 0) ||
		     ((dp->d_name[1] == '.') && (dp->d_name[2] == 0))))
			continue;

		sprintf(path, ""%s/%s"", dirname, dp->d_name);
",unused,e2fsprogsxenpatch-lib2Fblkid2Fdevno.c
"			label = vol_label;
	}

	/* We can't just print them as %04X, because they are unaligned */
	sprintf(serno, ""%02X%02X-%02X%02X"", vol_serno[3], vol_serno[2],
",1,unused,627,unused,"			label = vol_label;
	}

	/* We can't just print them as %04X, because they are unaligned */
	sprintf(serno, ""%02X%02X-%02X%02X"", vol_serno[3], vol_serno[2],
",unused,e2fsprogsxenpatch-lib2Fblkid2Fprobe.c
"			*cp = 0;
		}
	}

	sprintf(uuid_str, ""%016llX"", blkid_le64(ns->volume_serial));
",1,unused,783,unused,"			*cp = 0;
		}
	}

	sprintf(uuid_str, ""%016llX"", blkid_le64(ns->volume_serial));
",unused,e2fsprogsxenpatch-lib2Fblkid2Fprobe.c
"
	uuid_ptr = (unsigned long long *)hfs->finder_info.id;
	uuid = blkid_le64(*uuid_ptr);
	if (uuid) {
		sprintf(uuid_str, ""%016llX"", uuid);
",1,unused,1179,unused,"
	uuid_ptr = (unsigned long long *)hfs->finder_info.id;
	uuid = blkid_le64(*uuid_ptr);
	if (uuid) {
		sprintf(uuid_str, ""%016llX"", uuid);
",unused,e2fsprogsxenpatch-lib2Fblkid2Fprobe.c
"
	uuid_ptr = (unsigned long long *)hfsplus->finder_info.id;
	uuid = blkid_le64(*uuid_ptr);
	if (uuid) {
		sprintf(uuid_str, ""%016llX"", uuid);
",1,unused,1245,unused,"
	uuid_ptr = (unsigned long long *)hfsplus->finder_info.id;
	uuid = blkid_le64(*uuid_ptr);
	if (uuid) {
		sprintf(uuid_str, ""%016llX"", uuid);
",unused,e2fsprogsxenpatch-lib2Fblkid2Fprobe.c
"	if (ret == 0 && S_ISREG(st.st_mode)) {
		tmp = malloc(strlen(filename) + 8);
		if (tmp) {
			mode_t save_umask = umask(022);
			sprintf(tmp, ""%s-XXXXXX"", filename);
",1,unused,98,unused,"	if (ret == 0 && S_ISREG(st.st_mode)) {
		tmp = malloc(strlen(filename) + 8);
		if (tmp) {
			mode_t save_umask = umask(022);
			sprintf(tmp, ""%s-XXXXXX"", filename);
",unused,e2fsprogsxenpatch-lib2Fblkid2Fsave.c
"			char *backup;

			backup = malloc(strlen(filename) + 5);
			if (backup) {
				sprintf(backup, ""%s.old"", filename);
",1,unused,147,unused,"			char *backup;

			backup = malloc(strlen(filename) + 5);
			if (backup) {
				sprintf(backup, ""%s.old"", filename);
",unused,e2fsprogsxenpatch-lib2Fblkid2Fsave.c
"		fchar = '?';
		break;
	}
	for (fnum = 0; mask >>= 1; fnum++);
	sprintf(buf, ""FEATURE_%c%d"", fchar, fnum);
",1,unused,143,unused,"		fchar = '?';
		break;
	}
	for (fnum = 0; mask >>= 1; fnum++);
	sprintf(buf, ""FEATURE_%c%d"", fchar, fnum);
",unused,e2fsprogsxenpatch-lib2Fe2p2Ffeature.c
"		fchar = '?';
		break;
	}
	for (fnum = 0; mask >>= 1; fnum++);
	sprintf(buf, ""FEATURE_%c%d"", fchar, fnum);
",1,unused,217,unused,"		fchar = '?';
		break;
	}
	for (fnum = 0; mask >>= 1; fnum++);
	sprintf(buf, ""FEATURE_%c%d"", fchar, fnum);
",unused,e2fsprogsxenpatch-lib2Fe2p2Ffeature.c
"
	buf = malloc(strlen(str)+1);
	if (!buf)
		return 1;
	strcpy(buf, str);
",1,unused,304,unused,"
	buf = malloc(strlen(str)+1);
	if (!buf)
		return 1;
	strcpy(buf, str);
",unused,e2fsprogsxenpatch-lib2Fe2p2Ffeature.c
"	for (p = hash_list; p->string; p++) {
		if (num == p->num)
			return p->string;
	}
	sprintf(buf, ""HASHALG_%d"", num);
",1,unused,42,unused,"	for (p = hash_list; p->string; p++) {
		if (num == p->num)
			return p->string;
	}
	sprintf(buf, ""HASHALG_%d"", num);
",unused,e2fsprogsxenpatch-lib2Fe2p2Fhashstr.c
"
	if (secs >= MONTH_INT) {
		num = secs / MONTH_INT;
		secs -= num*MONTH_INT;
		sprintf(buf, ""%d month%s"", num, (num>1) ? ""s"" : """");
",1,unused,70,unused,"
	if (secs >= MONTH_INT) {
		num = secs / MONTH_INT;
		secs -= num*MONTH_INT;
		sprintf(buf, ""%d month%s"", num, (num>1) ? ""s"" : """");
",unused,e2fsprogsxenpatch-lib2Fe2p2Fls.c
"	}
	if (secs >= WEEK_INT) {
		num = secs / WEEK_INT;
		secs -= num*WEEK_INT;
		sprintf(tmp, ""%s%d week%s"", buf[0] ? "", "" : """",
",1,unused,75,unused,"	}
	if (secs >= WEEK_INT) {
		num = secs / WEEK_INT;
		secs -= num*WEEK_INT;
		sprintf(tmp, ""%s%d week%s"", buf[0] ? "", "" : """",
",unused,e2fsprogsxenpatch-lib2Fe2p2Fls.c
"		num = secs / WEEK_INT;
		secs -= num*WEEK_INT;
		sprintf(tmp, ""%s%d week%s"", buf[0] ? "", "" : """",
			num, (num>1) ? ""s"" : """");
		strcat(buf, tmp);
",1,unused,77,unused,"		num = secs / WEEK_INT;
		secs -= num*WEEK_INT;
		sprintf(tmp, ""%s%d week%s"", buf[0] ? "", "" : """",
			num, (num>1) ? ""s"" : """");
		strcat(buf, tmp);
",unused,e2fsprogsxenpatch-lib2Fe2p2Fls.c
"	}
	if (secs >= DAY_INT) {
		num = secs / DAY_INT;
		secs -= num*DAY_INT;
		sprintf(tmp, ""%s%d day%s"", buf[0] ? "", "" : """",
",1,unused,82,unused,"	}
	if (secs >= DAY_INT) {
		num = secs / DAY_INT;
		secs -= num*DAY_INT;
		sprintf(tmp, ""%s%d day%s"", buf[0] ? "", "" : """",
",unused,e2fsprogsxenpatch-lib2Fe2p2Fls.c
"		num = secs / DAY_INT;
		secs -= num*DAY_INT;
		sprintf(tmp, ""%s%d day%s"", buf[0] ? "", "" : """",
			num, (num>1) ? ""s"" : """");
		strcat(buf, tmp);
",1,unused,84,unused,"		num = secs / DAY_INT;
		secs -= num*DAY_INT;
		sprintf(tmp, ""%s%d day%s"", buf[0] ? "", "" : """",
			num, (num>1) ? ""s"" : """");
		strcat(buf, tmp);
",unused,e2fsprogsxenpatch-lib2Fe2p2Fls.c
"		hr = secs / HOUR_INT;
		secs -= hr*HOUR_INT;
		min = secs / MINUTE_INT;
		secs -= min*MINUTE_INT;
		sprintf(tmp, ""%s%d:%02d:%02d"", buf[0] ? "", "" : """",
",1,unused,91,unused,"		hr = secs / HOUR_INT;
		secs -= hr*HOUR_INT;
		min = secs / MINUTE_INT;
		secs -= min*MINUTE_INT;
		sprintf(tmp, ""%s%d:%02d:%02d"", buf[0] ? "", "" : """",
",unused,e2fsprogsxenpatch-lib2Fe2p2Fls.c
"		min = secs / MINUTE_INT;
		secs -= min*MINUTE_INT;
		sprintf(tmp, ""%s%d:%02d:%02d"", buf[0] ? "", "" : """",
			hr, min, secs);
		strcat(buf, tmp);
",1,unused,93,unused,"		min = secs / MINUTE_INT;
		secs -= min*MINUTE_INT;
		sprintf(tmp, ""%s%d:%02d:%02d"", buf[0] ? "", "" : """",
			hr, min, secs);
		strcat(buf, tmp);
",unused,e2fsprogsxenpatch-lib2Fe2p2Fls.c
"	if (sb->s_volume_name[0]) {
		memset(buf, 0, sizeof(buf));
		strncpy(buf, sb->s_volume_name, sizeof(sb->s_volume_name));
	} else
		strcpy(buf, ""<none>"");
",1,unused,213,unused,"	if (sb->s_volume_name[0]) {
		memset(buf, 0, sizeof(buf));
		strncpy(buf, sb->s_volume_name, sizeof(sb->s_volume_name));
	} else
		strcpy(buf, ""<none>"");
",unused,e2fsprogsxenpatch-lib2Fe2p2Fls.c
"	if (sb->s_last_mounted[0]) {
		memset(buf, 0, sizeof(buf));
		strncpy(buf, sb->s_last_mounted, sizeof(sb->s_last_mounted));
	} else
		strcpy(buf, ""<not available>"");
",1,unused,219,unused,"	if (sb->s_last_mounted[0]) {
		memset(buf, 0, sizeof(buf));
		strncpy(buf, sb->s_last_mounted, sizeof(sb->s_last_mounted));
	} else
		strcpy(buf, ""<not available>"");
",unused,e2fsprogsxenpatch-lib2Fe2p2Fls.c
"		if (mask == f->mask)
			return f->string;
	}
	for (fnum = 0; mask >>= 1; fnum++);
	sprintf(buf, ""MNTOPT_%d"", fnum);
",1,unused,53,unused,"		if (mask == f->mask)
			return f->string;
	}
	for (fnum = 0; mask >>= 1; fnum++);
	sprintf(buf, ""MNTOPT_%d"", fnum);
",unused,e2fsprogsxenpatch-lib2Fe2p2Fmntopts.c
"
	buf = malloc(strlen(str)+1);
	if (!buf)
		return 1;
	strcpy(buf, str);
",1,unused,112,unused,"
	buf = malloc(strlen(str)+1);
	if (!buf)
		return 1;
	strcpy(buf, str);
",unused,e2fsprogsxenpatch-lib2Fe2p2Fmntopts.c
"		os = ""(unknown os)"";

        ret = malloc(strlen(os)+1);
	if (ret)
		strcpy(ret, os);
",1,unused,40,unused,"		os = ""(unknown os)"";

        ret = malloc(strlen(os)+1);
	if (ret)
		strcpy(ret, os);
",unused,e2fsprogsxenpatch-lib2Fe2p2Fostype.c
"{
	struct uuid uuid;

	e2p_unpack_uuid(uu, &uuid);
	sprintf(out,
",1,unused,68,unused,"{
	struct uuid uuid;

	e2p_unpack_uuid(uu, &uuid);
	sprintf(out,
",unused,e2fsprogsxenpatch-lib2Fe2p2Fuuid.c
"	}
    }
    et_list_unlock();
oops:
    strcpy (buffer, ""Unknown code "");
",1,unused,172,unused,"	}
    }
    et_list_unlock();
oops:
    strcpy (buffer, ""Unknown code "");
",unused,e2fsprogsxenpatch-lib2Fet2Ferror_message.c
"    et_list_unlock();
oops:
    strcpy (buffer, ""Unknown code "");
    if (table_num) {
	strcat (buffer, error_table_name (table_num));
",1,unused,174,unused,"    et_list_unlock();
oops:
    strcpy (buffer, ""Unknown code "");
    if (table_num) {
	strcat (buffer, error_table_name (table_num));
",unused,e2fsprogsxenpatch-lib2Fet2Ferror_message.c
"oops:
    strcpy (buffer, ""Unknown code "");
    if (table_num) {
	strcat (buffer, error_table_name (table_num));
	strcat (buffer, "" "");
",1,unused,175,unused,"oops:
    strcpy (buffer, ""Unknown code "");
    if (table_num) {
	strcat (buffer, error_table_name (table_num));
	strcat (buffer, "" "");
",unused,e2fsprogsxenpatch-lib2Fet2Ferror_message.c
"
	retval = ext2fs_get_mem(strlen(src->device_name)+1, &fs->device_name);
	if (retval)
		goto errout;
	strcpy(fs->device_name, src->device_name);
",1,unused,54,unused,"
	retval = ext2fs_get_mem(strlen(src->device_name)+1, &fs->device_name);
	if (retval)
		goto errout;
	strcpy(fs->device_name, src->device_name);
",unused,e2fsprogsxenpatch-lib2Fext2fs2Fdupfs.c
"	if (!dp->name) {
		free(dp);
		return;
	}
	strcpy(dp->name, name);
",1,unused,59,unused,"	if (!dp->name) {
		free(dp);
		return;
	}
	strcpy(dp->name, name);
",unused,e2fsprogsxenpatch-lib2Fext2fs2Ffinddev.c
"		if (dp->d_name[0] == '.' &&
		    ((dp->d_name[1] == 0) ||
		     ((dp->d_name[1] == '.') && (dp->d_name[2] == 0))))
			goto skip_to_next;
		sprintf(path, ""%s/%s"", dirname, dp->d_name);
",1,unused,99,unused,"		if (dp->d_name[0] == '.' &&
		    ((dp->d_name[1] == 0) ||
		     ((dp->d_name[1] == '.') && (dp->d_name[2] == 0))))
			goto skip_to_next;
		sprintf(path, ""%s/%s"", dirname, dp->d_name);
",unused,e2fsprogsxenpatch-lib2Fext2fs2Ffinddev.c
"			if (!cp) {
				closedir(dir);
				return ENOMEM;
			}
			strcpy(cp, path);
",1,unused,110,unused,"			if (!cp) {
				closedir(dir);
				return ENOMEM;
			}
			strcpy(cp, path);
",unused,e2fsprogsxenpatch-lib2Fext2fs2Ffinddev.c
"		if (retval) {
			ext2fs_free_mem(&bitmap);
			return retval;
		}
		strcpy(bitmap->description, descr);
",1,unused,162,unused,"		if (retval) {
			ext2fs_free_mem(&bitmap);
			return retval;
		}
		strcpy(bitmap->description, descr);
",unused,e2fsprogsxenpatch-lib2Fext2fs2Fgen_bitmap64.c
"		if (retval) {
			ext2fs_free_mem(&new_bmap);
			return retval;
		}
		sprintf(new_descr, ""copy of %s"", descr);
",1,unused,327,unused,"		if (retval) {
			ext2fs_free_mem(&new_bmap);
			return retval;
		}
		sprintf(new_descr, ""copy of %s"", descr);
",unused,e2fsprogsxenpatch-lib2Fext2fs2Fgen_bitmap64.c
"	if (dir == ino) {
		retval = ext2fs_get_mem(2, name);
		if (retval)
			return retval;
		strcpy(*name, (dir == EXT2_ROOT_INO) ? ""/"" : ""."");
",1,unused,84,unused,"	if (dir == ino) {
		retval = ext2fs_get_mem(2, name);
		if (retval)
			return retval;
		strcpy(*name, (dir == EXT2_ROOT_INO) ? ""/"" : ""."");
",unused,e2fsprogsxenpatch-lib2Fext2fs2Fget_pathname.c
"	if (!dir || (maxdepth < 0)) {
		retval = ext2fs_get_mem(4, name);
		if (retval)
			return retval;
		strcpy(*name, ""..."");
",1,unused,92,unused,"	if (!dir || (maxdepth < 0)) {
		retval = ext2fs_get_mem(4, name);
		if (retval)
			return retval;
		strcpy(*name, ""..."");
",unused,e2fsprogsxenpatch-lib2Fext2fs2Fget_pathname.c
"			snprintf(tmp, sizeof(tmp), ""<%u>"", dir);
		retval = ext2fs_get_mem(strlen(tmp)+1, name);
		if (retval)
			goto cleanup;
		strcpy(*name, tmp);
",1,unused,112,unused,"			snprintf(tmp, sizeof(tmp), ""<%u>"", dir);
		retval = ext2fs_get_mem(strlen(tmp)+1, name);
		if (retval)
			goto cleanup;
		strcpy(*name, tmp);
",unused,e2fsprogsxenpatch-lib2Fext2fs2Fget_pathname.c
"		goto cleanup;

	ret[0] = 0;
	if (parent_name[1])
		strcat(ret, parent_name);
",1,unused,140,unused,"		goto cleanup;

	ret[0] = 0;
	if (parent_name[1])
		strcat(ret, parent_name);
",unused,e2fsprogsxenpatch-lib2Fext2fs2Fget_pathname.c
"
	ret[0] = 0;
	if (parent_name[1])
		strcat(ret, parent_name);
	strcat(ret, ""/"");
",1,unused,141,unused,"
	ret[0] = 0;
	if (parent_name[1])
		strcat(ret, parent_name);
	strcat(ret, ""/"");
",unused,e2fsprogsxenpatch-lib2Fext2fs2Fget_pathname.c
"	if (parent_name[1])
		strcat(ret, parent_name);
	strcat(ret, ""/"");
	if (gp.name)
		strcat(ret, gp.name);
",1,unused,143,unused,"	if (parent_name[1])
		strcat(ret, parent_name);
	strcat(ret, ""/"");
	if (gp.name)
		strcat(ret, gp.name);
",unused,e2fsprogsxenpatch-lib2Fext2fs2Fget_pathname.c
"	strcat(ret, ""/"");
	if (gp.name)
		strcat(ret, gp.name);
	else
		strcat(ret, ""???"");
",1,unused,145,unused,"	strcat(ret, ""/"");
	if (gp.name)
		strcat(ret, gp.name);
	else
		strcat(ret, ""???"");
",unused,e2fsprogsxenpatch-lib2Fext2fs2Fget_pathname.c
"{
	struct uuid uuid;

	unpack_uuid(uu, &uuid);
	sprintf(out,
",1,unused,169,unused,"{
	struct uuid uuid;

	unpack_uuid(uu, &uuid);
	sprintf(out,
",unused,e2fsprogsxenpatch-lib2Fext2fs2Ficount.c
"	retval = ext2fs_get_mem(strlen(tdb_dir) + 64, &fn);
	if (retval)
		goto errout;
	uuid_unparse(fs->super->s_uuid, uuid);
	sprintf(fn, ""%s/%s-icount-XXXXXX"", tdb_dir, uuid);
",1,unused,195,unused,"	retval = ext2fs_get_mem(strlen(tdb_dir) + 64, &fn);
	if (retval)
		goto errout;
	uuid_unparse(fs->super->s_uuid, uuid);
	sprintf(fn, ""%s/%s-icount-XXXXXX"", tdb_dir, uuid);
",unused,e2fsprogsxenpatch-lib2Fext2fs2Ficount.c
"	retval = ext2fs_get_mem(strlen(name)+1, &fs->device_name);
	if (retval)
		goto cleanup;

	strcpy(fs->device_name, name);
",1,unused,135,unused,"	retval = ext2fs_get_mem(strlen(name)+1, &fs->device_name);
	if (retval)
		goto cleanup;

	strcpy(fs->device_name, name);
",unused,e2fsprogsxenpatch-lib2Fext2fs2Finitialize.c
"	retval = ext2fs_get_mem(strlen(fs->device_name) + 80, &buf);
	if (retval)
		goto cleanup;

	strcpy(buf, ""block bitmap for "");
",1,unused,446,unused,"	retval = ext2fs_get_mem(strlen(fs->device_name) + 80, &buf);
	if (retval)
		goto cleanup;

	strcpy(buf, ""block bitmap for "");
",unused,e2fsprogsxenpatch-lib2Fext2fs2Finitialize.c
"	if (retval)
		goto cleanup;

	strcpy(buf, ""block bitmap for "");
	strcat(buf, fs->device_name);
",1,unused,447,unused,"	if (retval)
		goto cleanup;

	strcpy(buf, ""block bitmap for "");
	strcat(buf, fs->device_name);
",unused,e2fsprogsxenpatch-lib2Fext2fs2Finitialize.c
"	retval = ext2fs_allocate_subcluster_bitmap(fs, buf, &fs->block_map);
	if (retval)
		goto cleanup;

	strcpy(buf, ""inode bitmap for "");
",1,unused,452,unused,"	retval = ext2fs_allocate_subcluster_bitmap(fs, buf, &fs->block_map);
	if (retval)
		goto cleanup;

	strcpy(buf, ""inode bitmap for "");
",unused,e2fsprogsxenpatch-lib2Fext2fs2Finitialize.c
"	if (retval)
		goto cleanup;

	strcpy(buf, ""inode bitmap for "");
	strcat(buf, fs->device_name);
",1,unused,453,unused,"	if (retval)
		goto cleanup;

	strcpy(buf, ""inode bitmap for "");
	strcat(buf, fs->device_name);
",unused,e2fsprogsxenpatch-lib2Fext2fs2Finitialize.c
"	if ((retval = ext2fs_get_mem(sizeof(struct inode_private_data),
				     &data)))
		return retval;
	data->magic = EXT2_ET_MAGIC_INODE_IO_CHANNEL;
	sprintf(data->name, ""%u:%d"", ino, ino_unique++);
",1,unused,92,unused,"	if ((retval = ext2fs_get_mem(sizeof(struct inode_private_data),
				     &data)))
		return retval;
	data->magic = EXT2_ET_MAGIC_INODE_IO_CHANNEL;
	sprintf(data->name, ""%u:%d"", ino, ino_unique++);
",unused,e2fsprogsxenpatch-lib2Fext2fs2Finode_io.c
"	retval = ext2fs_get_mem(strlen(name)+1, &io->name);
	if (retval)
		goto cleanup;

	strcpy(io->name, name);
",1,unused,146,unused,"	retval = ext2fs_get_mem(strlen(name)+1, &io->name);
	if (retval)
		goto cleanup;

	strcpy(io->name, name);
",unused,e2fsprogsxenpatch-lib2Fext2fs2Finode_io.c
"
	options = malloc(strlen(opts)+1);
	if (!options)
		return EXT2_ET_NO_MEMORY;
	strcpy(options, opts);
",1,unused,39,unused,"
	options = malloc(strlen(opts)+1);
	if (!options)
		return EXT2_ET_NO_MEMORY;
	strcpy(options, opts);
",unused,e2fsprogsxenpatch-lib2Fext2fs2Fio_manager.c
"	fs->umask = 022;
	retval = ext2fs_get_mem(strlen(name)+1, &fs->device_name);
	if (retval)
		goto cleanup;
	strcpy(fs->device_name, name);
",1,unused,145,unused,"	fs->umask = 022;
	retval = ext2fs_get_mem(strlen(name)+1, &fs->device_name);
	if (retval)
		goto cleanup;
	strcpy(fs->device_name, name);
",unused,e2fsprogsxenpatch-lib2Fext2fs2Fopenfs.c
"		return retval;
	if (do_block) {
		if (fs->block_map)
			ext2fs_free_block_bitmap(fs->block_map);
		strcpy(buf, ""block bitmap for "");
",1,unused,219,unused,"		return retval;
	if (do_block) {
		if (fs->block_map)
			ext2fs_free_block_bitmap(fs->block_map);
		strcpy(buf, ""block bitmap for "");
",unused,e2fsprogsxenpatch-lib2Fext2fs2Frw_bitmaps.c
"	if (do_block) {
		if (fs->block_map)
			ext2fs_free_block_bitmap(fs->block_map);
		strcpy(buf, ""block bitmap for "");
		strcat(buf, fs->device_name);
",1,unused,220,unused,"	if (do_block) {
		if (fs->block_map)
			ext2fs_free_block_bitmap(fs->block_map);
		strcpy(buf, ""block bitmap for "");
		strcat(buf, fs->device_name);
",unused,e2fsprogsxenpatch-lib2Fext2fs2Frw_bitmaps.c
"		block_nbytes = 0;
	if (do_inode) {
		if (fs->inode_map)
			ext2fs_free_inode_bitmap(fs->inode_map);
		strcpy(buf, ""inode bitmap for "");
",1,unused,232,unused,"		block_nbytes = 0;
	if (do_inode) {
		if (fs->inode_map)
			ext2fs_free_inode_bitmap(fs->inode_map);
		strcpy(buf, ""inode bitmap for "");
",unused,e2fsprogsxenpatch-lib2Fext2fs2Frw_bitmaps.c
"	if (do_inode) {
		if (fs->inode_map)
			ext2fs_free_inode_bitmap(fs->inode_map);
		strcpy(buf, ""inode bitmap for "");
		strcat(buf, fs->device_name);
",1,unused,233,unused,"	if (do_inode) {
		if (fs->inode_map)
			ext2fs_free_inode_bitmap(fs->inode_map);
		strcpy(buf, ""inode bitmap for "");
		strcat(buf, fs->device_name);
",unused,e2fsprogsxenpatch-lib2Fext2fs2Frw_bitmaps.c
"	retval = ext2fs_get_mem(strlen(name)+1, &io->name);
	if (retval)
		goto cleanup;

	strcpy(io->name, name);
",1,unused,190,unused,"	retval = ext2fs_get_mem(strlen(name)+1, &io->name);
	if (retval)
		goto cleanup;

	strcpy(io->name, name);
",unused,e2fsprogsxenpatch-lib2Fext2fs2Ftest_io.c
"	retval = ext2fs_get_mem(strlen(name)+1, &io->name);
	if (retval)
		goto cleanup;

	strcpy(io->name, name);
",1,unused,338,unused,"	retval = ext2fs_get_mem(strlen(name)+1, &io->name);
	if (retval)
		goto cleanup;

	strcpy(io->name, name);
",unused,e2fsprogsxenpatch-lib2Fext2fs2Fundo_io.c
"	retval = ext2fs_get_mem(strlen(name)+1, &io->name);
	if (retval)
		goto cleanup;

	strcpy(io->name, name);
",1,unused,500,unused,"	retval = ext2fs_get_mem(strlen(name)+1, &io->name);
	if (retval)
		goto cleanup;

	strcpy(io->name, name);
",unused,e2fsprogsxenpatch-lib2Fext2fs2Funix_io.c
"			 (strlen(infop->subsystem_name)+1)
			 * sizeof(char));
	if (ret_val == (char *)NULL)
	    return((char *)NULL);
	strcpy(ret_val, infop->subsystem_name);
",1,unused,35,unused,"			 (strlen(infop->subsystem_name)+1)
			 * sizeof(char));
	if (ret_val == (char *)NULL)
	    return((char *)NULL);
	strcpy(ret_val, infop->subsystem_name);
",unused,e2fsprogsxenpatch-lib2Fss2Ferror.c
"
	tmp = malloc(strlen(libpath)+1);
	if (!tmp)
		return;
	strcpy(tmp, libpath);
",1,unused,63,unused,"
	tmp = malloc(strlen(libpath)+1);
	if (!tmp)
		return;
	strcpy(tmp, libpath);
",unused,e2fsprogsxenpatch-lib2Fss2Fget_readline.c
"		ss_perror(sci_idx, 0,
			  ""couldn't allocate memory to print usage message"");
		return;
	}
	sprintf(buffer, ""usage:\n\t%s [topic|command]\nor\t%s\n"",
",1,unused,65,unused,"		ss_perror(sci_idx, 0,
			  ""couldn't allocate memory to print usage message"");
		return;
	}
	sprintf(buffer, ""usage:\n\t%s [topic|command]\nor\t%s\n"",
",unused,e2fsprogsxenpatch-lib2Fss2Fhelp.c
"	    ss_perror(sci_idx, 0,
		      ""couldn't allocate memory for help filename"");
	    return;
	}
	(void) strcpy(buffer, info->info_dirs[idx]);
",1,unused,88,unused,"	    ss_perror(sci_idx, 0,
		      ""couldn't allocate memory for help filename"");
	    return;
	}
	(void) strcpy(buffer, info->info_dirs[idx]);
",unused,e2fsprogsxenpatch-lib2Fss2Fhelp.c
"		      ""couldn't allocate memory for help filename"");
	    return;
	}
	(void) strcpy(buffer, info->info_dirs[idx]);
	(void) strcat(buffer, ""/"");
",1,unused,89,unused,"		      ""couldn't allocate memory for help filename"");
	    return;
	}
	(void) strcpy(buffer, info->info_dirs[idx]);
	(void) strcat(buffer, ""/"");
",unused,e2fsprogsxenpatch-lib2Fss2Fhelp.c
"	    return;
	}
	(void) strcpy(buffer, info->info_dirs[idx]);
	(void) strcat(buffer, ""/"");
	(void) strcat(buffer, argv[1]);
",1,unused,90,unused,"	    return;
	}
	(void) strcpy(buffer, info->info_dirs[idx]);
	(void) strcat(buffer, ""/"");
	(void) strcat(buffer, argv[1]);
",unused,e2fsprogsxenpatch-lib2Fss2Fhelp.c
"	}
	(void) strcpy(buffer, info->info_dirs[idx]);
	(void) strcat(buffer, ""/"");
	(void) strcat(buffer, argv[1]);
	(void) strcat(buffer, "".info"");
",1,unused,91,unused,"	}
	(void) strcpy(buffer, info->info_dirs[idx]);
	(void) strcat(buffer, ""/"");
	(void) strcat(buffer, argv[1]);
	(void) strcat(buffer, "".info"");
",unused,e2fsprogsxenpatch-lib2Fss2Fhelp.c
"    }
    if (fd < 0) {
#define MSG ""No info found for ""
        char *buf = malloc(strlen (MSG) + strlen (argv[1]) + 1);
	strcpy(buf, MSG);
",1,unused,100,unused,"    }
    if (fd < 0) {
#define MSG ""No info found for ""
        char *buf = malloc(strlen (MSG) + strlen (argv[1]) + 1);
	strcpy(buf, MSG);
",unused,e2fsprogsxenpatch-lib2Fss2Fhelp.c
"    if (fd < 0) {
#define MSG ""No info found for ""
        char *buf = malloc(strlen (MSG) + strlen (argv[1]) + 1);
	strcpy(buf, MSG);
	strcat(buf, argv[1]);
",1,unused,101,unused,"    if (fd < 0) {
#define MSG ""No info found for ""
        char *buf = malloc(strlen (MSG) + strlen (argv[1]) + 1);
	strcpy(buf, MSG);
	strcat(buf, argv[1]);
",unused,e2fsprogsxenpatch-lib2Fss2Fhelp.c
"    }
    info->info_dirs = dirs;
    dirs[n_dirs + 1] = (char *)NULL;
    dirs[n_dirs] = malloc((unsigned)strlen(info_dir)+1);
    strcpy(dirs[n_dirs], info_dir);
",1,unused,158,unused,"    }
    info->info_dirs = dirs;
    dirs[n_dirs + 1] = (char *)NULL;
    dirs[n_dirs] = malloc((unsigned)strlen(info_dir)+1);
    strcpy(dirs[n_dirs], info_dir);
",unused,e2fsprogsxenpatch-lib2Fss2Fhelp.c
"	new_table->info_dirs = (char **)malloc(sizeof(char *));
	*new_table->info_dirs = (char *)NULL;
	new_table->info_ptr = info_ptr;
	new_table->prompt = malloc((unsigned)strlen(subsystem_name)+4);
	strcpy(new_table->prompt, subsystem_name);
",1,unused,63,unused,"	new_table->info_dirs = (char **)malloc(sizeof(char *));
	*new_table->info_dirs = (char *)NULL;
	new_table->info_ptr = info_ptr;
	new_table->prompt = malloc((unsigned)strlen(subsystem_name)+4);
	strcpy(new_table->prompt, subsystem_name);
",unused,e2fsprogsxenpatch-lib2Fss2Finvocation.c
"	*new_table->info_dirs = (char *)NULL;
	new_table->info_ptr = info_ptr;
	new_table->prompt = malloc((unsigned)strlen(subsystem_name)+4);
	strcpy(new_table->prompt, subsystem_name);
	strcat(new_table->prompt, "":  "");
",1,unused,64,unused,"	*new_table->info_dirs = (char *)NULL;
	new_table->info_ptr = info_ptr;
	new_table->prompt = malloc((unsigned)strlen(subsystem_name)+4);
	strcpy(new_table->prompt, subsystem_name);
	strcat(new_table->prompt, "":  "");
",unused,e2fsprogsxenpatch-lib2Fss2Finvocation.c
"		}
		if (strncmp(*name, text, len) == 0) {
			ret = malloc(strlen(*name)+1);
			if (ret)
				strcpy(ret, *name);
",1,unused,181,unused,"		}
		if (strncmp(*name, text, len) == 0) {
			ret = malloc(strlen(*name)+1);
			if (ret)
				strcpy(ret, *name);
",unused,e2fsprogsxenpatch-lib2Fss2Flisten.c
"	if ((s = socket(AF_UNIX, SOCK_STREAM, 0)) < 0)
		return -1;

	srv_addr.sun_family = AF_UNIX;
	strcpy(srv_addr.sun_path, UUIDD_SOCKET_PATH);
",1,unused,504,unused,"	if ((s = socket(AF_UNIX, SOCK_STREAM, 0)) < 0)
		return -1;

	srv_addr.sun_family = AF_UNIX;
	strcpy(srv_addr.sun_path, UUIDD_SOCKET_PATH);
",unused,e2fsprogsxenpatch-lib2Fuuid2Fgen_uuid.c
"{
	struct uuid uuid;

	uuid_unpack(uu, &uuid);
	sprintf(out, fmt,
",1,unused,57,unused,"{
	struct uuid uuid;

	uuid_unpack(uu, &uuid);
	sprintf(out, fmt,
",unused,e2fsprogsxenpatch-lib2Fuuid2Funparse.c
"	min = diff % 60;
	hr = diff / 60;

	if (hr)
		sprintf(buf, ""%d:%02d:%02d"", hr, min, sec);
",1,unused,197,unused,"	min = diff % 60;
	hr = diff / 60;

	if (hr)
		sprintf(buf, ""%d:%02d:%02d"", hr, min, sec);
",unused,e2fsprogsxenpatch-misc2Fbadblocks.c
"
	if (hr)
		sprintf(buf, ""%d:%02d:%02d"", hr, min, sec);
	else
		sprintf(buf, ""%d:%02d"", min, sec);
",1,unused,199,unused,"
	if (hr)
		sprintf(buf, ""%d:%02d:%02d"", hr, min, sec);
	else
		sprintf(buf, ""%d:%02d"", min, sec);
",unused,e2fsprogsxenpatch-misc2Fbadblocks.c
"
	str = malloc(strlen(device)+1);
	if (!str)
		return NULL;
	strcpy(str, device);
",1,unused,51,unused,"
	str = malloc(strlen(device)+1);
	if (!str)
		return NULL;
	strcpy(str, device);
",unused,e2fsprogsxenpatch-misc2Fbase_device.c
"					  mtpt, sizeof(mtpt));
	if (retval == 0) {
		if (mount_flags & EXT2_MF_MOUNTED) {
			if (!mtpt[0])
				strcpy(mtpt, ""(mounted, mtpt unknown)"");
",1,unused,219,unused,"					  mtpt, sizeof(mtpt));
	if (retval == 0) {
		if (mount_flags & EXT2_MF_MOUNTED) {
			if (!mtpt[0])
				strcpy(mtpt, ""(mounted, mtpt unknown)"");
",unused,e2fsprogsxenpatch-misc2Fblkid.c
"		if (mount_flags & EXT2_MF_MOUNTED) {
			if (!mtpt[0])
				strcpy(mtpt, ""(mounted, mtpt unknown)"");
		} else if (mount_flags & EXT2_MF_BUSY)
			strcpy(mtpt, ""(in use)"");
",1,unused,221,unused,"		if (mount_flags & EXT2_MF_MOUNTED) {
			if (!mtpt[0])
				strcpy(mtpt, ""(mounted, mtpt unknown)"");
		} else if (mount_flags & EXT2_MF_BUSY)
			strcpy(mtpt, ""(in use)"");
",unused,e2fsprogsxenpatch-misc2Fblkid.c
"				strcpy(mtpt, ""(mounted, mtpt unknown)"");
		} else if (mount_flags & EXT2_MF_BUSY)
			strcpy(mtpt, ""(in use)"");
		else
			strcpy(mtpt, ""(not mounted)"");
",1,unused,223,unused,"				strcpy(mtpt, ""(mounted, mtpt unknown)"");
		} else if (mount_flags & EXT2_MF_BUSY)
			strcpy(mtpt, ""(in use)"");
		else
			strcpy(mtpt, ""(not mounted)"");
",unused,e2fsprogsxenpatch-misc2Fblkid.c
"				_(""Couldn't allocate path variable ""
				  ""in chattr_dir_proc""));
			return -1;
		}
		sprintf(path, ""%s/%s"", dir_name, de->d_name);
",1,unused,271,unused,"				_(""Couldn't allocate path variable ""
				  ""in chattr_dir_proc""));
			return -1;
		}
		sprintf(path, ""%s/%s"", dir_name, de->d_name);
",unused,e2fsprogsxenpatch-misc2Fchattr.c
"		fprintf(stderr, ""%s"",
			_(""Couldn't allocate memory to parse options!\n""));
		exit(1);
	}
	strcpy(buf, opts);
",1,unused,459,unused,"		fprintf(stderr, ""%s"",
			_(""Couldn't allocate memory to parse options!\n""));
		exit(1);
	}
	strcpy(buf, opts);
",unused,e2fsprogsxenpatch-misc2Fdumpe2fs.c
"		end = 1 << (i + info->blocksize_bits - units);
		if (info->histogram.fc_chunks[i] != 0) {
			char end_str[32];

			sprintf(end_str, ""%5lu%c-"", end, *unitp);
",1,unused,195,unused,"		end = 1 << (i + info->blocksize_bits - units);
		if (info->histogram.fc_chunks[i] != 0) {
			char end_str[32];

			sprintf(end_str, ""%5lu%c-"", end, *unitp);
",unused,e2fsprogsxenpatch-misc2Fe2freefrag.c
"			char end_str[32];

			sprintf(end_str, ""%5lu%c-"", end, *unitp);
			if (i == MAX_HIST-1)
				strcpy(end_str, ""max "");
",1,unused,197,unused,"			char end_str[32];

			sprintf(end_str, ""%5lu%c-"", end, *unitp);
			if (i == MAX_HIST-1)
				strcpy(end_str, ""max "");
",unused,e2fsprogsxenpatch-misc2Fe2freefrag.c
"		exit(1);
	}

	hdr.magic_number = EXT2_ET_MAGIC_E2IMAGE;
	strcpy(hdr.magic_descriptor, ""Ext2 Image 1.0"");
",1,unused,271,unused,"		exit(1);
	}

	hdr.magic_number = EXT2_ET_MAGIC_E2IMAGE;
	strcpy(hdr.magic_descriptor, ""Ext2 Image 1.0"");
",unused,e2fsprogsxenpatch-misc2Fe2image.c
"			flags |= E2IMAGE_IS_QCOW2_FLAG;
			goto skip_device;
		}
	}
	sprintf(offset_opt, ""offset=%llu"", source_offset);
",1,unused,1576,unused,"			flags |= E2IMAGE_IS_QCOW2_FLAG;
			goto skip_device;
		}
	}
	sprintf(offset_opt, ""offset=%llu"", source_offset);
",unused,e2fsprogsxenpatch-misc2Fe2image.c
"	if (!s)
		return 0;
	ret = malloc(strlen(s)+1);
	if (ret)
		strcpy(ret, s);
",1,unused,165,unused,"	if (!s)
		return 0;
	ret = malloc(strlen(s)+1);
	if (ret)
		strcpy(ret, s);
",unused,e2fsprogsxenpatch-misc2Fe2initrd_helper.c
"	}

	if (mode_flag & DETAIL) {
		/* Print statistic info */
		sprintf(msg_buffer, ""[%u/%u]%s"",
",1,unused,1211,unused,"	}

	if (mode_flag & DETAIL) {
		/* Print statistic info */
		sprintf(msg_buffer, ""[%u/%u]%s"",
",unused,e2fsprogsxenpatch-misc2Fe4defrag.c
"	}

	/* Create donor inode */
	memset(tmp_inode_name, 0, PATH_MAX + 8);
	sprintf(tmp_inode_name, ""%.*s.defrag"",
",1,unused,1529,unused,"	}

	/* Create donor inode */
	memset(tmp_inode_name, 0, PATH_MAX + 8);
	sprintf(tmp_inode_name, ""%.*s.defrag"",
",unused,e2fsprogsxenpatch-misc2Fe4defrag.c
"{
	if ((*flags & mask) == 0)
		return;

	strcat(buf, name);
",1,unused,128,unused,"{
	if ((*flags & mask) == 0)
		return;

	strcat(buf, name);
",unused,e2fsprogsxenpatch-misc2Ffilefrag.c
"		physical_blk = fm_extent->fe_physical >> blk_shift;
	}

	if (expected)
		sprintf(flags, ext_fmt == hex_fmt ? ""%*llx: "" : ""%*llu: "",
",1,unused,157,unused,"		physical_blk = fm_extent->fe_physical >> blk_shift;
	}

	if (expected)
		sprintf(flags, ext_fmt == hex_fmt ? ""%*llx: "" : ""%*llu: "",
",unused,e2fsprogsxenpatch-misc2Ffilefrag.c
"	if (expected)
		sprintf(flags, ext_fmt == hex_fmt ? ""%*llx: "" : ""%*llu: "",
			physical_width, expected >> blk_shift);
	else
		sprintf(flags, ""%.*s  "", physical_width, ""                   "");
",1,unused,160,unused,"	if (expected)
		sprintf(flags, ext_fmt == hex_fmt ? ""%*llx: "" : ""%*llu: "",
			physical_width, expected >> blk_shift);
	else
		sprintf(flags, ""%.*s  "", physical_width, ""                   "");
",unused,e2fsprogsxenpatch-misc2Ffilefrag.c
"		char hex[6];

		if ((fe_flags & mask) == 0)
			continue;
		sprintf(hex, ""%#04x,"", mask);
",1,unused,180,unused,"		char hex[6];

		if ((fe_flags & mask) == 0)
			continue;
		sprintf(hex, ""%#04x,"", mask);
",unused,e2fsprogsxenpatch-misc2Ffilefrag.c
"		print_flag(&fe_flags, mask, flags, hex);
	}

	if (fm_extent->fe_logical + fm_extent->fe_length >= st->st_size)
		strcat(flags, ""eof,"");
",1,unused,185,unused,"		print_flag(&fe_flags, mask, flags, hex);
	}

	if (fm_extent->fe_logical + fm_extent->fe_length >= st->st_size)
		strcat(flags, ""eof,"");
",unused,e2fsprogsxenpatch-misc2Ffilefrag.c
"	if (!s)
		return 0;
	ret = malloc(strlen(s)+1);
	if (ret)
		strcpy(ret, s);
",1,unused,135,unused,"	if (!s)
		return 0;
	ret = malloc(strlen(s)+1);
	if (ret)
		strcpy(ret, s);
",unused,e2fsprogsxenpatch-misc2Ffsck.c
"  /* Are we looking for a program or just a type? */
  tpl = (strncmp(type, ""fsck."", 5) ? ""%s/fsck.%s"" : ""%s/%s"");

  for(s = strtok(p, "":""); s; s = strtok(NULL, "":"")) {
	sprintf(prog, tpl, s, type);
",1,unused,411,unused,"  /* Are we looking for a program or just a type? */
  tpl = (strncmp(type, ""fsck."", 5) ? ""%s/fsck.%s"" : ""%s/%s"");

  for(s = strtok(p, "":""); s; s = strtok(NULL, "":"")) {
	sprintf(prog, tpl, s, type);
",unused,e2fsprogsxenpatch-misc2Ffsck.c
"	if (!inst)
		return ENOMEM;
	memset(inst, 0, sizeof(struct fsck_instance));

	sprintf(prog, ""fsck.%s"", type);
",1,unused,448,unused,"	if (!inst)
		return ENOMEM;
	memset(inst, 0, sizeof(struct fsck_instance));

	sprintf(prog, ""fsck.%s"", type);
",unused,e2fsprogsxenpatch-misc2Ffsck.c
"		if (!fsck_path) {
			fprintf(stderr, ""%s: Unable to allocate memory for fsck_path\n"", progname);
			exit(EXIT_ERROR);
		}
		strcpy (fsck_path, fsck_prefix_path);
",1,unused,1289,unused,"		if (!fsck_path) {
			fprintf(stderr, ""%s: Unable to allocate memory for fsck_path\n"", progname);
			exit(EXIT_ERROR);
		}
		strcpy (fsck_path, fsck_prefix_path);
",unused,e2fsprogsxenpatch-misc2Ffsck.c
"			fprintf(stderr, ""%s: Unable to allocate memory for fsck_path\n"", progname);
			exit(EXIT_ERROR);
		}
		strcpy (fsck_path, fsck_prefix_path);
		strcat (fsck_path, "":"");
",1,unused,1290,unused,"			fprintf(stderr, ""%s: Unable to allocate memory for fsck_path\n"", progname);
			exit(EXIT_ERROR);
		}
		strcpy (fsck_path, fsck_prefix_path);
		strcat (fsck_path, "":"");
",unused,e2fsprogsxenpatch-misc2Ffsck.c
"			exit(EXIT_ERROR);
		}
		strcpy (fsck_path, fsck_prefix_path);
		strcat (fsck_path, "":"");
		strcat (fsck_path, oldpath);
",1,unused,1291,unused,"			exit(EXIT_ERROR);
		}
		strcpy (fsck_path, fsck_prefix_path);
		strcat (fsck_path, "":"");
		strcat (fsck_path, oldpath);
",unused,e2fsprogsxenpatch-misc2Ffsck.c
"	if ( WIFEXITED(status) ) {
		rc = WEXITSTATUS(status);
		if (rc) {
			send_output(argv[0], 0, SEND_BOTH);
			sprintf(buffer, "" exited with status code %d\n"", rc);
",1,unused,213,unused,"	if ( WIFEXITED(status) ) {
		rc = WEXITSTATUS(status);
		if (rc) {
			send_output(argv[0], 0, SEND_BOTH);
			sprintf(buffer, "" exited with status code %d\n"", rc);
",unused,e2fsprogsxenpatch-misc2Flogsave.c
"		}
	} else {
		if (WIFSIGNALED(status)) {
			send_output(argv[0], 0, SEND_BOTH);
			sprintf(buffer, ""died with signal %d\n"",
",1,unused,219,unused,"		}
	} else {
		if (WIFSIGNALED(status)) {
			send_output(argv[0], 0, SEND_BOTH);
			sprintf(buffer, ""died with signal %d\n"",
",unused,e2fsprogsxenpatch-misc2Flogsave.c
"
	path = malloc(dir_len + strlen (de->d_name) + 2);

	if (dir_len && dir_name[dir_len-1] == '/')
		sprintf (path, ""%s%s"", dir_name, de->d_name);
",1,unused,138,unused,"
	path = malloc(dir_len + strlen (de->d_name) + 2);

	if (dir_len && dir_name[dir_len-1] == '/')
		sprintf (path, ""%s%s"", dir_name, de->d_name);
",unused,e2fsprogsxenpatch-misc2Flsattr.c
"
	if (dir_len && dir_name[dir_len-1] == '/')
		sprintf (path, ""%s%s"", dir_name, de->d_name);
	else
		sprintf (path, ""%s/%s"", dir_name, de->d_name);
",1,unused,140,unused,"
	if (dir_len && dir_name[dir_len-1] == '/')
		sprintf (path, ""%s%s"", dir_name, de->d_name);
	else
		sprintf (path, ""%s/%s"", dir_name, de->d_name);
",unused,e2fsprogsxenpatch-misc2Flsattr.c
"	if (!cp)
		return 0;
	if (strlen(path) > SYSFS_PATH_LEN - sizeof(""/start""))
		return 0;
	strcat(path, ""/start"");
",1,unused,193,unused,"	if (!cp)
		return 0;
	if (strlen(path) > SYSFS_PATH_LEN - sizeof(""/start""))
		return 0;
	strcat(path, ""/start"");
",unused,e2fsprogsxenpatch-misc2Fmk_hugefiles.c
"	fn = malloc(strlen(dir) + 1);
	if (fn == NULL)
		return ENOMEM;

	strcpy(fn, dir);
",1,unused,216,unused,"	fn = malloc(strlen(dir) + 1);
	if (fn == NULL)
		return ENOMEM;

	strcpy(fn, dir);
",unused,e2fsprogsxenpatch-misc2Fmk_hugefiles.c
"	if (retval)
		goto errout;

	if (idx_digits)
		sprintf(fn_numbuf, ""%0*lu"", idx_digits, idx);
",1,unused,369,unused,"	if (retval)
		goto errout;

	if (idx_digits)
		sprintf(fn_numbuf, ""%0*lu"", idx_digits, idx);
",unused,e2fsprogsxenpatch-misc2Fmk_hugefiles.c
"
	if (idx_digits)
		sprintf(fn_numbuf, ""%0*lu"", idx_digits, idx);
	else if (num_files > 1)
		sprintf(fn_numbuf, ""%lu"", idx);
",1,unused,371,unused,"
	if (idx_digits)
		sprintf(fn_numbuf, ""%0*lu"", idx_digits, idx);
	else if (num_files > 1)
		sprintf(fn_numbuf, ""%lu"", idx);
",unused,e2fsprogsxenpatch-misc2Fmk_hugefiles.c
"	if (!fn_buf) {
		free(fn_prefix);
		return ENOMEM;
	}
	strcpy(fn_buf, fn_prefix);
",1,unused,526,unused,"	if (!fn_buf) {
		free(fn_prefix);
		return ENOMEM;
	}
	strcpy(fn_buf, fn_prefix);
",unused,e2fsprogsxenpatch-misc2Fmk_hugefiles.c
"	FILE		*f;
	errcode_t	retval;
	char		buf[1024];

	sprintf(buf, ""badblocks -b %d -X %s%s%s %llu"", fs->blocksize,
",1,unused,248,unused,"	FILE		*f;
	errcode_t	retval;
	char		buf[1024];

	sprintf(buf, ""badblocks -b %d -X %s%s%s %llu"", fs->blocksize,
",unused,e2fsprogsxenpatch-misc2Fmke2fs.c
"		fprintf(stderr, ""%s"",
			_(""Couldn't allocate memory to parse options!\n""));
		exit(1);
	}
	strcpy(buf, opts);
",1,unused,746,unused,"		fprintf(stderr, ""%s"",
			_(""Couldn't allocate memory to parse options!\n""));
		exit(1);
	}
	strcpy(buf, opts);
",unused,e2fsprogsxenpatch-misc2Fmke2fs.c
"	}
	sl->list[sl->num] = malloc(strlen(str)+1);
	if (sl->list[sl->num] == 0)
		return ENOMEM;
	strcpy(sl->list[sl->num], str);
",1,unused,1117,unused,"	}
	sl->list[sl->num] = malloc(strlen(str)+1);
	if (sl->list[sl->num] == 0)
		return ENOMEM;
	strcpy(sl->list[sl->num], str);
",unused,e2fsprogsxenpatch-misc2Fmke2fs.c
"		free(profile_type);
		free(list.list);
		return 0;
	}
	strcpy(parse_str, usage_types);
",1,unused,1254,unused,"		free(profile_type);
		free(list.list);
		return 0;
	}
	strcpy(parse_str, usage_types);
",unused,e2fsprogsxenpatch-misc2Fmke2fs.c
"		fprintf(stderr, ""%s"",
			_(""Couldn't allocate memory for new PATH.\n""));
		exit(1);
	}
	strcpy(newpath, PATH_SET);
",1,unused,1452,unused,"		fprintf(stderr, ""%s"",
			_(""Couldn't allocate memory for new PATH.\n""));
		exit(1);
	}
	strcpy(newpath, PATH_SET);
",unused,e2fsprogsxenpatch-misc2Fmke2fs.c
"	strcpy(newpath, PATH_SET);

	/* Update our PATH to include /sbin  */
	if (oldpath) {
		strcat (newpath, "":"");
",1,unused,1456,unused,"	strcpy(newpath, PATH_SET);

	/* Update our PATH to include /sbin  */
	if (oldpath) {
		strcat (newpath, "":"");
",unused,e2fsprogsxenpatch-misc2Fmke2fs.c
"
	/* Update our PATH to include /sbin  */
	if (oldpath) {
		strcat (newpath, "":"");
		strcat (newpath, oldpath);
",1,unused,1457,unused,"
	/* Update our PATH to include /sbin  */
	if (oldpath) {
		strcat (newpath, "":"");
		strcat (newpath, oldpath);
",unused,e2fsprogsxenpatch-misc2Fmke2fs.c
"				com_err(program_name, ENOMEM, ""%s"",
					_(""in malloc for bad_blocks_filename""));
				exit(1);
			}
			strcpy(bad_blocks_filename, optarg);
",1,unused,1637,unused,"				com_err(program_name, ENOMEM, ""%s"",
					_(""in malloc for bad_blocks_filename""));
				exit(1);
			}
			strcpy(bad_blocks_filename, optarg);
",unused,e2fsprogsxenpatch-misc2Fmke2fs.c
"	if (!tdb_file) {
		free(tmp_name);
		goto errout;
	}
	sprintf(tdb_file, ""%s/mke2fs-%s.e2undo"", tdb_dir, dev_name);
",1,unused,2405,unused,"	if (!tdb_file) {
		free(tmp_name);
		goto errout;
	}
	sprintf(tdb_file, ""%s/mke2fs-%s.e2undo"", tdb_dir, dev_name);
",unused,e2fsprogsxenpatch-misc2Fmke2fs.c
"			zero_hugefile = 0;
		}
	}

	sprintf(opt_string, ""tdb_data_size=%d"", fs->blocksize <= 4096 ?
",1,unused,2620,unused,"			zero_hugefile = 0;
		}
	}

	sprintf(opt_string, ""tdb_data_size=%d"", fs->blocksize <= 4096 ?
",unused,e2fsprogsxenpatch-misc2Fmke2fs.c
"	sprintf(opt_string, ""tdb_data_size=%d"", fs->blocksize <= 4096 ?
		32768 : fs->blocksize * 8);
	io_channel_set_options(fs->io, opt_string);
	if (offset) {
		sprintf(opt_string, ""offset=%llu"", offset);
",1,unused,2624,unused,"	sprintf(opt_string, ""tdb_data_size=%d"", fs->blocksize <= 4096 ?
		32768 : fs->blocksize * 8);
	io_channel_set_options(fs->io, opt_string);
	if (offset) {
		sprintf(opt_string, ""offset=%llu"", offset);
",unused,e2fsprogsxenpatch-misc2Fmke2fs.c
"
	i = 0;
	memset (name, 'x', 246);
	do {
		sprintf (name + 246, ""%08d"", i);
",1,unused,61,unused,"
	i = 0;
	memset (name, 'x', 246);
	do {
		sprintf (name + 246, ""%08d"", i);
",unused,e2fsprogsxenpatch-misc2Fmklost+found.c
"	i = 0;
	memset (name, 'x', 246);
	do {
		sprintf (name + 246, ""%08d"", i);
		strcpy (path, LPF);
",1,unused,62,unused,"	i = 0;
	memset (name, 'x', 246);
	do {
		sprintf (name + 246, ""%08d"", i);
		strcpy (path, LPF);
",unused,e2fsprogsxenpatch-misc2Fmklost+found.c
"	memset (name, 'x', 246);
	do {
		sprintf (name + 246, ""%08d"", i);
		strcpy (path, LPF);
		strcat (path, ""/"");
",1,unused,63,unused,"	memset (name, 'x', 246);
	do {
		sprintf (name + 246, ""%08d"", i);
		strcpy (path, LPF);
		strcat (path, ""/"");
",unused,e2fsprogsxenpatch-misc2Fmklost+found.c
"	do {
		sprintf (name + 246, ""%08d"", i);
		strcpy (path, LPF);
		strcat (path, ""/"");
		strcat (path, name);
",1,unused,64,unused,"	do {
		sprintf (name + 246, ""%08d"", i);
		strcpy (path, LPF);
		strcat (path, ""/"");
		strcat (path, name);
",unused,e2fsprogsxenpatch-misc2Fmklost+found.c
"			exit (1);
		}
	} while (st.st_size <= (EXT2_NDIR_BLOCKS - 1) * st.st_blksize);
	for (j = 0; j < i; j++) {
		sprintf (name + 246, ""%08d"", j);
",1,unused,77,unused,"			exit (1);
		}
	} while (st.st_size <= (EXT2_NDIR_BLOCKS - 1) * st.st_blksize);
	for (j = 0; j < i; j++) {
		sprintf (name + 246, ""%08d"", j);
",unused,e2fsprogsxenpatch-misc2Fmklost+found.c
"		}
	} while (st.st_size <= (EXT2_NDIR_BLOCKS - 1) * st.st_blksize);
	for (j = 0; j < i; j++) {
		sprintf (name + 246, ""%08d"", j);
		strcpy (path, LPF);
",1,unused,78,unused,"		}
	} while (st.st_size <= (EXT2_NDIR_BLOCKS - 1) * st.st_blksize);
	for (j = 0; j < i; j++) {
		sprintf (name + 246, ""%08d"", j);
		strcpy (path, LPF);
",unused,e2fsprogsxenpatch-misc2Fmklost+found.c
"	} while (st.st_size <= (EXT2_NDIR_BLOCKS - 1) * st.st_blksize);
	for (j = 0; j < i; j++) {
		sprintf (name + 246, ""%08d"", j);
		strcpy (path, LPF);
		strcat (path, ""/"");
",1,unused,79,unused,"	} while (st.st_size <= (EXT2_NDIR_BLOCKS - 1) * st.st_blksize);
	for (j = 0; j < i; j++) {
		sprintf (name + 246, ""%08d"", j);
		strcpy (path, LPF);
		strcat (path, ""/"");
",unused,e2fsprogsxenpatch-misc2Fmklost+found.c
"	for (j = 0; j < i; j++) {
		sprintf (name + 246, ""%08d"", j);
		strcpy (path, LPF);
		strcat (path, ""/"");
		strcat (path, name);
",1,unused,80,unused,"	for (j = 0; j < i; j++) {
		sprintf (name + 246, ""%08d"", j);
		strcpy (path, LPF);
		strcat (path, ""/"");
		strcat (path, name);
",unused,e2fsprogsxenpatch-misc2Fmklost+found.c
"		fprintf(stderr, ""%s"",
			_(""Couldn't allocate memory to parse options!\n""));
		return 1;
	}
	strcpy(buf, opts);
",1,unused,1214,unused,"		fprintf(stderr, ""%s"",
			_(""Couldn't allocate memory to parse options!\n""));
		return 1;
	}
	strcpy(buf, opts);
",unused,e2fsprogsxenpatch-misc2Ftune2fs.c
"
	tdb_file = malloc(strlen(tdb_dir) + 9 + strlen(dev_name) + 7 + 1);
	if (!tdb_file)
		goto alloc_fn_fail;
	sprintf(tdb_file, ""%s/tune2fs-%s.e2undo"", tdb_dir, dev_name);
",1,unused,1909,unused,"
	tdb_file = malloc(strlen(tdb_dir) + 9 + strlen(dev_name) + 7 + 1);
	if (!tdb_file)
		goto alloc_fn_fail;
	sprintf(tdb_file, ""%s/tune2fs-%s.e2undo"", tdb_dir, dev_name);
",unused,e2fsprogsxenpatch-misc2Ftune2fs.c
"		fputs(_(""Couldn't allocate memory to parse journal ""
			""options!\n""), stderr);
		exit(1);
	}
	strcpy(buf, opts);
",1,unused,355,unused,"		fputs(_(""Couldn't allocate memory to parse journal ""
			""options!\n""), stderr);
		exit(1);
	}
	strcpy(buf, opts);
",unused,e2fsprogsxenpatch-misc2Futil.c
"	if (retval) {
		free(prog);
		return retval;
	}
	strcpy(prog->label, label);
",1,unused,96,unused,"	if (retval) {
		free(prog);
		return retval;
	}
	strcpy(prog->label, label);
",unused,e2fsprogsxenpatch-resize2Fsim_progress.c
"		goto fail;
	ent->value = (char *) malloc(strlen(value)+1);
	if (!ent->value)
		goto fail;
	strcpy(ent->name, name);
",1,unused,57,unused,"		goto fail;
	ent->value = (char *) malloc(strlen(value)+1);
	if (!ent->value)
		goto fail;
	strcpy(ent->name, name);
",unused,e2fsprogsxenpatch-util2Fsubst.c
"	ent->value = (char *) malloc(strlen(value)+1);
	if (!ent->value)
		goto fail;
	strcpy(ent->name, name);
	strcpy(ent->value, value);
",1,unused,58,unused,"	ent->value = (char *) malloc(strlen(value)+1);
	if (!ent->value)
		goto fail;
	strcpy(ent->name, name);
	strcpy(ent->value, value);
",unused,e2fsprogsxenpatch-util2Fsubst.c
"		if (!newfn) {
			fprintf(stderr, ""Memory error!  Exiting.\n"");
			exit(1);
		}
		strcpy(newfn, outfn);
",1,unused,368,unused,"		if (!newfn) {
			fprintf(stderr, ""Memory error!  Exiting.\n"");
			exit(1);
		}
		strcpy(newfn, outfn);
",unused,e2fsprogsxenpatch-util2Fsubst.c
"			fprintf(stderr, ""Memory error!  Exiting.\n"");
			exit(1);
		}
		strcpy(newfn, outfn);
		strcat(newfn, "".new"");
",1,unused,369,unused,"			fprintf(stderr, ""Memory error!  Exiting.\n"");
			exit(1);
		}
		strcpy(newfn, outfn);
		strcat(newfn, "".new"");
",unused,e2fsprogsxenpatch-util2Fsubst.c
"	char buf[200];
	unsigned long v;
	char *tmp;

	sprintf(buf, format, *val);
",1,unused,1148,unused,"	char buf[200];
	unsigned long v;
	char *tmp;

	sprintf(buf, format, *val);
",unused,e2fsprogtrusty-debugfs2Fdebugfs.c
"	char buf[200];
	unsigned long v;
	char *tmp;

	sprintf(buf, format, *val);
",1,unused,1170,unused,"	char buf[200];
	unsigned long v;
	char *tmp;

	sprintf(buf, format, *val);
",unused,e2fsprogtrusty-debugfs2Fdebugfs.c
"	char buf[200];
	unsigned long v;
	char *tmp;

	sprintf(buf, format, *val);
",1,unused,1192,unused,"	char buf[200];
	unsigned long v;
	char *tmp;

	sprintf(buf, format, *val);
",unused,e2fsprogtrusty-debugfs2Fdebugfs.c
"	if (fsize)
		modify_u8(argv[0], ""Fragment size"", decimal_format, fsize);

	for (i=0;  i < EXT2_NDIR_BLOCKS; i++) {
		sprintf(buf, ""Direct Block #%d"", i);
",1,unused,1272,unused,"	if (fsize)
		modify_u8(argv[0], ""Fragment size"", decimal_format, fsize);

	for (i=0;  i < EXT2_NDIR_BLOCKS; i++) {
		sprintf(buf, ""Direct Block #%d"", i);
",unused,e2fsprogtrusty-debugfs2Fdebugfs.c
"
	/* Apparently, this is the right way to detect and handle fast
	 * symlinks; see do_stat() in debugfs.c. */
	if (inode->i_blocks == 0)
		strcpy(buf, (char *) inode->i_block);
",1,unused,217,unused,"
	/* Apparently, this is the right way to detect and handle fast
	 * symlinks; see do_stat() in debugfs.c. */
	if (inode->i_blocks == 0)
		strcpy(buf, (char *) inode->i_block);
",unused,e2fsprogtrusty-debugfs2Fdump.c
"	if (!fullname) {
		com_err(""rdump"", errno, ""while allocating memory"");
		return;
	}
	sprintf(fullname, ""%s/%s"", dumproot, name);
",1,unused,267,unused,"	if (!fullname) {
		com_err(""rdump"", errno, ""while allocating memory"");
		return;
	}
	sprintf(fullname, ""%s/%s"", dumproot, name);
",unused,e2fsprogtrusty-debugfs2Fdump.c
"	current_ino = inode;

	orig_prompt = ss_get_prompt(sci_idx);
	extent_prompt = malloc(strlen(orig_prompt) + 32);
	strcpy(extent_prompt, orig_prompt);
",1,unused,100,unused,"	current_ino = inode;

	orig_prompt = ss_get_prompt(sci_idx);
	extent_prompt = malloc(strlen(orig_prompt) + 32);
	strcpy(extent_prompt, orig_prompt);
",unused,e2fsprogtrusty-debugfs2Fextent_inode.c
"	strcpy(extent_prompt, orig_prompt);
	cp = strchr(extent_prompt, ':');
	if (cp)
		*cp = 0;
	sprintf(extent_prompt + strlen(extent_prompt), "" (extent ino %d): "",
",1,unused,104,unused,"	strcpy(extent_prompt, orig_prompt);
	cp = strchr(extent_prompt, ':');
	if (cp)
		*cp = 0;
	sprintf(extent_prompt + strlen(extent_prompt), "" (extent ino %d): "",
",unused,e2fsprogtrusty-debugfs2Fextent_inode.c
"			fs->dir_name, name);
		return 0;
	}

	sprintf(cp, ""%s/%s"", fs->dir_name, name);
",1,unused,201,unused,"			fs->dir_name, name);
		return 0;
	}

	sprintf(cp, ""%s/%s"", fs->dir_name, name);
",unused,e2fsprogtrusty-debugfs2Ffilefrag.c
"			if (debugfs_read_inode(ino, &inode, name))
				return 0;
			modtime = inode.i_mtime;
			tm_p = localtime(&modtime);
			sprintf(datestr, ""%2d-%s-%4d %02d:%02d"",
",1,unused,94,unused,"			if (debugfs_read_inode(ino, &inode, name))
				return 0;
			modtime = inode.i_mtime;
			tm_p = localtime(&modtime);
			sprintf(datestr, ""%2d-%s-%4d %02d:%02d"",
",unused,e2fsprogtrusty-debugfs2Fls.c
"				tm_p->tm_mday, monstr[tm_p->tm_mon],
				1900 + tm_p->tm_year, tm_p->tm_hour,
				tm_p->tm_min);
		} else {
			strcpy(datestr, ""                 "");
",1,unused,99,unused,"				tm_p->tm_mday, monstr[tm_p->tm_mon],
				1900 + tm_p->tm_year, tm_p->tm_hour,
				tm_p->tm_min);
		} else {
			strcpy(datestr, ""                 "");
",unused,e2fsprogtrusty-debugfs2Fls.c
"		else
			fprintf(ls->f, ""%5llu"", EXT2_I_SIZE(&inode));
		fprintf (ls->f, "" %s %s\n"", datestr, name);
	} else {
		sprintf(tmp, ""%c%u%c (%d) %s   "", lbr, dirent->inode, rbr,
",1,unused,111,unused,"		else
			fprintf(ls->f, ""%5llu"", EXT2_I_SIZE(&inode));
		fprintf (ls->f, "" %s %s\n"", datestr, name);
	} else {
		sprintf(tmp, ""%c%u%c (%d) %s   "", lbr, dirent->inode, rbr,
",unused,e2fsprogtrusty-debugfs2Fls.c
"
	arg = malloc(strlen(field)+1);
	if (!arg)
		return NULL;
	strcpy(arg, field);
",1,unused,295,unused,"
	arg = malloc(strlen(field)+1);
	if (!arg)
		return NULL;
	strcpy(arg, field);
",unused,e2fsprogtrusty-debugfs2Fset_fields.c
"		fprintf(stderr, ""Error maximum size for %s is %d.\n"",
			info->name, info->size);
		return EINVAL;
	}
	strcpy(cp, arg);
",1,unused,472,unused,"		fprintf(stderr, ""Error maximum size for %s is %d.\n"",
			info->name, info->size);
		return EINVAL;
	}
	strcpy(cp, arg);
",unused,e2fsprogtrusty-debugfs2Fset_fields.c
"		else if (ss->func == parse_bmap)
			type = ""set physical->logical block map"";
		else if (ss->func == parse_gd_csum)
			type = ""unsigned integer OR \""calc\"""";
		strcpy(name, ss->name);
",1,unused,612,unused,"		else if (ss->func == parse_bmap)
			type = ""set physical->logical block map"";
		else if (ss->func == parse_gd_csum)
			type = ""unsigned integer OR \""calc\"""";
		strcpy(name, ss->name);
",unused,e2fsprogtrusty-debugfs2Fset_fields.c
"			type = ""unsigned integer OR \""calc\"""";
		strcpy(name, ss->name);
		if (ss->flags & FLAG_ARRAY) {
			if (ss->max_idx > 0)
				sprintf(idx, ""[%d]"", ss->max_idx);
",1,unused,615,unused,"			type = ""unsigned integer OR \""calc\"""";
		strcpy(name, ss->name);
		if (ss->flags & FLAG_ARRAY) {
			if (ss->max_idx > 0)
				sprintf(idx, ""[%d]"", ss->max_idx);
",unused,e2fsprogtrusty-debugfs2Fset_fields.c
"		if (ss->flags & FLAG_ARRAY) {
			if (ss->max_idx > 0)
				sprintf(idx, ""[%d]"", ss->max_idx);
			else
				strcpy(idx, ""[]"");
",1,unused,617,unused,"		if (ss->flags & FLAG_ARRAY) {
			if (ss->max_idx > 0)
				sprintf(idx, ""[%d]"", ss->max_idx);
			else
				strcpy(idx, ""[]"");
",unused,e2fsprogtrusty-debugfs2Fset_fields.c
"			if (ss->max_idx > 0)
				sprintf(idx, ""[%d]"", ss->max_idx);
			else
				strcpy(idx, ""[]"");
			strcat(name, idx);
",1,unused,618,unused,"			if (ss->max_idx > 0)
				sprintf(idx, ""[%d]"", ss->max_idx);
			else
				strcpy(idx, ""[]"");
			strcat(name, idx);
",unused,e2fsprogtrusty-debugfs2Fset_fields.c
"				strcpy(idx, ""[]"");
			strcat(name, idx);
		}
		if (ss->ptr2)
			strcat(name, ""[_hi|_lo]"");
",1,unused,621,unused,"				strcpy(idx, ""[]"");
			strcat(name, idx);
		}
		if (ss->ptr2)
			strcat(name, ""[_hi|_lo]"");
",unused,e2fsprogtrusty-debugfs2Fset_fields.c
"	const char **i, **j;

	for (i = pager_search_list; *i; i++) {
		for (j = pager_dir_list; *j; j++) {
			sprintf(buf, ""%s/%s"", *j, *i);
",1,unused,72,unused,"	const char **i, **j;

	for (i = pager_search_list; *i; i++) {
		for (j = pager_dir_list; *j; j++) {
			sprintf(buf, ""%s/%s"", *j, *i);
",unused,e2fsprogtrusty-debugfs2Futil.c
"				_(""while trying to open %s""), bad_blocks_file);
			goto fatal;
		}
	} else {
		sprintf(buf, ""badblocks -b %d -X %s%s%s %llu"", fs->blocksize,
",1,unused,76,unused,"				_(""while trying to open %s""), bad_blocks_file);
			goto fatal;
		}
	} else {
		sprintf(buf, ""badblocks -b %d -X %s%s%s %llu"", fs->blocksize,
",unused,e2fsprogtrusty-e2fsck2Fbadblocks.c
"	if (retval)
		return;

	uuid_unparse(ctx->fs->super->s_uuid, uuid);
	sprintf(db->tdb_fn, ""%s/%s-dirinfo-XXXXXX"", tdb_dir, uuid);
",1,unused,64,unused,"	if (retval)
		return;

	uuid_unparse(ctx->fs->super->s_uuid, uuid);
	sprintf(db->tdb_fn, ""%s/%s-dirinfo-XXXXXX"", tdb_dir, uuid);
",unused,e2fsprogtrusty-e2fsck2Fdirinfo.c
"	case '%':
		append_string(s, ""%"", 1);
		return;
	case 'd':
		sprintf(buf, ""%02d"", tm->tm_mday);
",1,unused,88,unused,"	case '%':
		append_string(s, ""%"", 1);
		return;
	case 'd':
		sprintf(buf, ""%02d"", tm->tm_mday);
",unused,e2fsprogtrusty-e2fsck2Flogfile.c
"	case 'd':
		sprintf(buf, ""%02d"", tm->tm_mday);
		break;
	case 'D':
		sprintf(buf, ""%d%02d%02d"", tm->tm_year + 1900, tm->tm_mon + 1,
",1,unused,91,unused,"	case 'd':
		sprintf(buf, ""%02d"", tm->tm_mday);
		break;
	case 'D':
		sprintf(buf, ""%d%02d%02d"", tm->tm_year + 1900, tm->tm_mon + 1,
",unused,e2fsprogtrusty-e2fsck2Flogfile.c
"		buf[sizeof(buf)-1] = 0;
#endif
		break;
	case 'H':
		sprintf(buf, ""%02d"", tm->tm_hour);
",1,unused,104,unused,"		buf[sizeof(buf)-1] = 0;
#endif
		break;
	case 'H':
		sprintf(buf, ""%02d"", tm->tm_hour);
",unused,e2fsprogtrusty-e2fsck2Flogfile.c
"	case 'H':
		sprintf(buf, ""%02d"", tm->tm_hour);
		break;
	case 'm':
		sprintf(buf, ""%02d"", tm->tm_mon + 1);
",1,unused,107,unused,"	case 'H':
		sprintf(buf, ""%02d"", tm->tm_hour);
		break;
	case 'm':
		sprintf(buf, ""%02d"", tm->tm_mon + 1);
",unused,e2fsprogtrusty-e2fsck2Flogfile.c
"	case 'm':
		sprintf(buf, ""%02d"", tm->tm_mon + 1);
		break;
	case 'M':
		sprintf(buf, ""%02d"", tm->tm_min);
",1,unused,110,unused,"	case 'm':
		sprintf(buf, ""%02d"", tm->tm_mon + 1);
		break;
	case 'M':
		sprintf(buf, ""%02d"", tm->tm_min);
",unused,e2fsprogtrusty-e2fsck2Flogfile.c
"			cp = ctx->filesystem_name;
		append_string(s, cp, 0);
		return;
	case 'p':
		sprintf(buf, ""%lu"", (unsigned long) getpid());
",1,unused,121,unused,"			cp = ctx->filesystem_name;
		append_string(s, cp, 0);
		return;
	case 'p':
		sprintf(buf, ""%lu"", (unsigned long) getpid());
",unused,e2fsprogtrusty-e2fsck2Flogfile.c
"	case 'p':
		sprintf(buf, ""%lu"", (unsigned long) getpid());
		break;
	case 's':
		sprintf(buf, ""%lu"", (unsigned long) ctx->now);
",1,unused,124,unused,"	case 'p':
		sprintf(buf, ""%lu"", (unsigned long) getpid());
		break;
	case 's':
		sprintf(buf, ""%lu"", (unsigned long) ctx->now);
",unused,e2fsprogtrusty-e2fsck2Flogfile.c
"	case 's':
		sprintf(buf, ""%lu"", (unsigned long) ctx->now);
		break;
	case 'S':
		sprintf(buf, ""%02d"", tm->tm_sec);
",1,unused,127,unused,"	case 's':
		sprintf(buf, ""%lu"", (unsigned long) ctx->now);
		break;
	case 'S':
		sprintf(buf, ""%02d"", tm->tm_sec);
",unused,e2fsprogtrusty-e2fsck2Flogfile.c
"	case 'S':
		sprintf(buf, ""%02d"", tm->tm_sec);
		break;
	case 'T':
		sprintf(buf, ""%02d%02d%02d"", tm->tm_hour, tm->tm_min,
",1,unused,130,unused,"	case 'S':
		sprintf(buf, ""%02d"", tm->tm_sec);
		break;
	case 'T':
		sprintf(buf, ""%02d%02d%02d"", tm->tm_hour, tm->tm_min,
",unused,e2fsprogtrusty-e2fsck2Flogfile.c
"	case 'U':
		*flags |= FLAG_UTC;
		return;
	case 'y':
		sprintf(buf, ""%02d"", tm->tm_year % 100);
",1,unused,151,unused,"	case 'U':
		*flags |= FLAG_UTC;
		return;
	case 'y':
		sprintf(buf, ""%02d"", tm->tm_year % 100);
",unused,e2fsprogtrusty-e2fsck2Flogfile.c
"	case 'y':
		sprintf(buf, ""%02d"", tm->tm_year % 100);
		break;
	case 'Y':
		sprintf(buf, ""%d"", tm->tm_year + 1900);
",1,unused,154,unused,"	case 'y':
		sprintf(buf, ""%02d"", tm->tm_year % 100);
		break;
	case 'Y':
		sprintf(buf, ""%d"", tm->tm_year + 1900);
",unused,e2fsprogtrusty-e2fsck2Flogfile.c
"
#if 0
		printf(""%u "", pctx.ino);
#endif
		sprintf(buf, _(""reading indirect blocks of inode %u""),
",1,unused,1296,unused,"
#if 0
		printf(""%u "", pctx.ino);
#endif
		sprintf(buf, _(""reading indirect blocks of inode %u""),
",unused,e2fsprogtrusty-e2fsck2Fpass1.c
"		fix_problem(ctx, PR_3_NO_LPF, &pctx);
		return 1;
	}

	sprintf(name, ""#%u"", ino);
",1,unused,526,unused,"		fix_problem(ctx, PR_3_NO_LPF, &pctx);
		return 1;
	}

	sprintf(name, ""#%u"", ino);
",unused,e2fsprogtrusty-e2fsck2Fpass3.c
"	}
	if (!(ptr->flags & PR_CONFIG)) {
		char	key[9], *new_desc = NULL;

		sprintf(key, ""0x%06x"", code);
",1,unused,1840,unused,"	}
	if (!(ptr->flags & PR_CONFIG)) {
		char	key[9], *new_desc = NULL;

		sprintf(key, ""0x%06x"", code);
",unused,e2fsprogtrusty-e2fsck2Fproblem.c
"	printf(""Allocating %u bytes for %s...\n"", size, description);
#endif
	ret = malloc(size);
	if (!ret) {
		sprintf(buf, ""Can't allocate %u bytes for %s\n"",
",1,unused,124,unused,"	printf(""Allocating %u bytes for %s...\n"", size, description);
#endif
	ret = malloc(size);
	if (!ret) {
		sprintf(buf, ""Can't allocate %u bytes for %s\n"",
",unused,e2fsprogtrusty-e2fsck2Futil.c
"		free(new_type);
		free(new_value);
		return -1;
	}
	strcpy(new_type, search_type);
",1,unused,144,unused,"		free(new_type);
		free(new_value);
		return -1;
	}
	strcpy(new_type, search_type);
",unused,e2fsprogtrusty-lib2Fblkid2Fdev.c
"		free(new_value);
		return -1;
	}
	strcpy(new_type, search_type);
	strcpy(new_value, search_value);
",1,unused,145,unused,"		free(new_value);
		return -1;
	}
	strcpy(new_type, search_type);
	strcpy(new_value, search_value);
",unused,e2fsprogtrusty-lib2Fblkid2Fdev.c
"		    !strcmp(de->d_name, devname) ||
		    strncmp(de->d_name, ""dm-"", 3) ||
		    strlen(de->d_name) > sizeof(path)-32)
			continue;
		sprintf(path, ""/sys/block/%s/slaves"", de->d_name);
",1,unused,139,unused,"		    !strcmp(de->d_name, devname) ||
		    strncmp(de->d_name, ""dm-"", 3) ||
		    strlen(de->d_name) > sizeof(path)-32)
			continue;
		sprintf(path, ""/sys/block/%s/slaves"", de->d_name);
",unused,e2fsprogtrusty-lib2Fblkid2Fdevname.c
"	for (dir = dirlist; *dir; dir++) {
		struct stat st;
		char device[256];

		sprintf(device, ""%s/%s"", *dir, ptname);
",1,unused,228,unused,"	for (dir = dirlist; *dir; dir++) {
		struct stat st;
		char device[256];

		sprintf(device, ""%s/%s"", *dir, ptname);
",unused,e2fsprogtrusty-lib2Fblkid2Fdevname.c
"			continue;
		vdirname = malloc(vg_len + strlen(vg_name) + 8);
		if (!vdirname)
			goto exit;
		sprintf(vdirname, ""%s/%s/LVs"", VG_DIR, vg_name);
",1,unused,325,unused,"			continue;
		vdirname = malloc(vg_len + strlen(vg_name) + 8);
		if (!vdirname)
			goto exit;
		sprintf(vdirname, ""%s/%s/LVs"", VG_DIR, vg_name);
",unused,e2fsprogtrusty-lib2Fblkid2Fdevname.c
"			if (!lvm_device) {
				closedir(lv_list);
				goto exit;
			}
			sprintf(lvm_device, ""%s/%s/LVs/%s"", VG_DIR, vg_name,
",1,unused,345,unused,"			if (!lvm_device) {
				closedir(lv_list);
				goto exit;
			}
			sprintf(lvm_device, ""%s/%s/LVs/%s"", VG_DIR, vg_name,
",unused,e2fsprogtrusty-lib2Fblkid2Fdevname.c
"			}
			sprintf(lvm_device, ""%s/%s/LVs/%s"", VG_DIR, vg_name,
				lv_name);
			dev = lvm_get_devno(lvm_device);
			sprintf(lvm_device, ""%s/%s"", vg_name, lv_name);
",1,unused,348,unused,"			}
			sprintf(lvm_device, ""%s/%s/LVs/%s"", VG_DIR, vg_name,
				lv_name);
			dev = lvm_get_devno(lvm_device);
			sprintf(lvm_device, ""%s/%s"", vg_name, lv_name);
",unused,e2fsprogtrusty-lib2Fblkid2Fdevname.c
"		    ((dp->d_name[1] == 0) ||
		     ((dp->d_name[1] == '.') && (dp->d_name[2] == 0))))
			continue;

		sprintf(path, ""%s/%s"", dirname, dp->d_name);
",1,unused,115,unused,"		    ((dp->d_name[1] == 0) ||
		     ((dp->d_name[1] == '.') && (dp->d_name[2] == 0))))
			continue;

		sprintf(path, ""%s/%s"", dirname, dp->d_name);
",unused,e2fsprogtrusty-lib2Fblkid2Fdevno.c
"			label = vol_label;
	}

	/* We can't just print them as %04X, because they are unaligned */
	sprintf(serno, ""%02X%02X-%02X%02X"", vol_serno[3], vol_serno[2],
",1,unused,625,unused,"			label = vol_label;
	}

	/* We can't just print them as %04X, because they are unaligned */
	sprintf(serno, ""%02X%02X-%02X%02X"", vol_serno[3], vol_serno[2],
",unused,e2fsprogtrusty-lib2Fblkid2Fprobe.c
"			*cp = 0;
		}
	}

	sprintf(uuid_str, ""%016llX"", blkid_le64(ns->volume_serial));
",1,unused,781,unused,"			*cp = 0;
		}
	}

	sprintf(uuid_str, ""%016llX"", blkid_le64(ns->volume_serial));
",unused,e2fsprogtrusty-lib2Fblkid2Fprobe.c
"
	uuid_ptr = (unsigned long long *)hfs->finder_info.id;
	uuid = blkid_le64(*uuid_ptr);
	if (uuid) {
		sprintf(uuid_str, ""%016llX"", uuid);
",1,unused,1176,unused,"
	uuid_ptr = (unsigned long long *)hfs->finder_info.id;
	uuid = blkid_le64(*uuid_ptr);
	if (uuid) {
		sprintf(uuid_str, ""%016llX"", uuid);
",unused,e2fsprogtrusty-lib2Fblkid2Fprobe.c
"
	uuid_ptr = (unsigned long long *)hfsplus->finder_info.id;
	uuid = blkid_le64(*uuid_ptr);
	if (uuid) {
		sprintf(uuid_str, ""%016llX"", uuid);
",1,unused,1242,unused,"
	uuid_ptr = (unsigned long long *)hfsplus->finder_info.id;
	uuid = blkid_le64(*uuid_ptr);
	if (uuid) {
		sprintf(uuid_str, ""%016llX"", uuid);
",unused,e2fsprogtrusty-lib2Fblkid2Fprobe.c
"	 */
	if (ret == 0 && S_ISREG(st.st_mode)) {
		tmp = malloc(strlen(filename) + 8);
		if (tmp) {
			sprintf(tmp, ""%s-XXXXXX"", filename);
",1,unused,97,unused,"	 */
	if (ret == 0 && S_ISREG(st.st_mode)) {
		tmp = malloc(strlen(filename) + 8);
		if (tmp) {
			sprintf(tmp, ""%s-XXXXXX"", filename);
",unused,e2fsprogtrusty-lib2Fblkid2Fsave.c
"			char *backup;

			backup = malloc(strlen(filename) + 5);
			if (backup) {
				sprintf(backup, ""%s.old"", filename);
",1,unused,145,unused,"			char *backup;

			backup = malloc(strlen(filename) + 5);
			if (backup) {
				sprintf(backup, ""%s.old"", filename);
",unused,e2fsprogtrusty-lib2Fblkid2Fsave.c
"		fchar = '?';
		break;
	}
	for (fnum = 0; mask >>= 1; fnum++);
	sprintf(buf, ""FEATURE_%c%d"", fchar, fnum);
",1,unused,141,unused,"		fchar = '?';
		break;
	}
	for (fnum = 0; mask >>= 1; fnum++);
	sprintf(buf, ""FEATURE_%c%d"", fchar, fnum);
",unused,e2fsprogtrusty-lib2Fe2p2Ffeature.c
"		fchar = '?';
		break;
	}
	for (fnum = 0; mask >>= 1; fnum++);
	sprintf(buf, ""FEATURE_%c%d"", fchar, fnum);
",1,unused,215,unused,"		fchar = '?';
		break;
	}
	for (fnum = 0; mask >>= 1; fnum++);
	sprintf(buf, ""FEATURE_%c%d"", fchar, fnum);
",unused,e2fsprogtrusty-lib2Fe2p2Ffeature.c
"
	buf = malloc(strlen(str)+1);
	if (!buf)
		return 1;
	strcpy(buf, str);
",1,unused,302,unused,"
	buf = malloc(strlen(str)+1);
	if (!buf)
		return 1;
	strcpy(buf, str);
",unused,e2fsprogtrusty-lib2Fe2p2Ffeature.c
"	for (p = hash_list; p->string; p++) {
		if (num == p->num)
			return p->string;
	}
	sprintf(buf, ""HASHALG_%d"", num);
",1,unused,42,unused,"	for (p = hash_list; p->string; p++) {
		if (num == p->num)
			return p->string;
	}
	sprintf(buf, ""HASHALG_%d"", num);
",unused,e2fsprogtrusty-lib2Fe2p2Fhashstr.c
"
	if (secs >= MONTH_INT) {
		num = secs / MONTH_INT;
		secs -= num*MONTH_INT;
		sprintf(buf, ""%d month%s"", num, (num>1) ? ""s"" : """");
",1,unused,70,unused,"
	if (secs >= MONTH_INT) {
		num = secs / MONTH_INT;
		secs -= num*MONTH_INT;
		sprintf(buf, ""%d month%s"", num, (num>1) ? ""s"" : """");
",unused,e2fsprogtrusty-lib2Fe2p2Fls.c
"	}
	if (secs >= WEEK_INT) {
		num = secs / WEEK_INT;
		secs -= num*WEEK_INT;
		sprintf(tmp, ""%s%d week%s"", buf[0] ? "", "" : """",
",1,unused,75,unused,"	}
	if (secs >= WEEK_INT) {
		num = secs / WEEK_INT;
		secs -= num*WEEK_INT;
		sprintf(tmp, ""%s%d week%s"", buf[0] ? "", "" : """",
",unused,e2fsprogtrusty-lib2Fe2p2Fls.c
"		num = secs / WEEK_INT;
		secs -= num*WEEK_INT;
		sprintf(tmp, ""%s%d week%s"", buf[0] ? "", "" : """",
			num, (num>1) ? ""s"" : """");
		strcat(buf, tmp);
",1,unused,77,unused,"		num = secs / WEEK_INT;
		secs -= num*WEEK_INT;
		sprintf(tmp, ""%s%d week%s"", buf[0] ? "", "" : """",
			num, (num>1) ? ""s"" : """");
		strcat(buf, tmp);
",unused,e2fsprogtrusty-lib2Fe2p2Fls.c
"	}
	if (secs >= DAY_INT) {
		num = secs / DAY_INT;
		secs -= num*DAY_INT;
		sprintf(tmp, ""%s%d day%s"", buf[0] ? "", "" : """",
",1,unused,82,unused,"	}
	if (secs >= DAY_INT) {
		num = secs / DAY_INT;
		secs -= num*DAY_INT;
		sprintf(tmp, ""%s%d day%s"", buf[0] ? "", "" : """",
",unused,e2fsprogtrusty-lib2Fe2p2Fls.c
"		num = secs / DAY_INT;
		secs -= num*DAY_INT;
		sprintf(tmp, ""%s%d day%s"", buf[0] ? "", "" : """",
			num, (num>1) ? ""s"" : """");
		strcat(buf, tmp);
",1,unused,84,unused,"		num = secs / DAY_INT;
		secs -= num*DAY_INT;
		sprintf(tmp, ""%s%d day%s"", buf[0] ? "", "" : """",
			num, (num>1) ? ""s"" : """");
		strcat(buf, tmp);
",unused,e2fsprogtrusty-lib2Fe2p2Fls.c
"		hr = secs / HOUR_INT;
		secs -= hr*HOUR_INT;
		min = secs / MINUTE_INT;
		secs -= min*MINUTE_INT;
		sprintf(tmp, ""%s%d:%02d:%02d"", buf[0] ? "", "" : """",
",1,unused,91,unused,"		hr = secs / HOUR_INT;
		secs -= hr*HOUR_INT;
		min = secs / MINUTE_INT;
		secs -= min*MINUTE_INT;
		sprintf(tmp, ""%s%d:%02d:%02d"", buf[0] ? "", "" : """",
",unused,e2fsprogtrusty-lib2Fe2p2Fls.c
"		min = secs / MINUTE_INT;
		secs -= min*MINUTE_INT;
		sprintf(tmp, ""%s%d:%02d:%02d"", buf[0] ? "", "" : """",
			hr, min, secs);
		strcat(buf, tmp);
",1,unused,93,unused,"		min = secs / MINUTE_INT;
		secs -= min*MINUTE_INT;
		sprintf(tmp, ""%s%d:%02d:%02d"", buf[0] ? "", "" : """",
			hr, min, secs);
		strcat(buf, tmp);
",unused,e2fsprogtrusty-lib2Fe2p2Fls.c
"	if (sb->s_volume_name[0]) {
		memset(buf, 0, sizeof(buf));
		strncpy(buf, sb->s_volume_name, sizeof(sb->s_volume_name));
	} else
		strcpy(buf, ""<none>"");
",1,unused,213,unused,"	if (sb->s_volume_name[0]) {
		memset(buf, 0, sizeof(buf));
		strncpy(buf, sb->s_volume_name, sizeof(sb->s_volume_name));
	} else
		strcpy(buf, ""<none>"");
",unused,e2fsprogtrusty-lib2Fe2p2Fls.c
"	if (sb->s_last_mounted[0]) {
		memset(buf, 0, sizeof(buf));
		strncpy(buf, sb->s_last_mounted, sizeof(sb->s_last_mounted));
	} else
		strcpy(buf, ""<not available>"");
",1,unused,219,unused,"	if (sb->s_last_mounted[0]) {
		memset(buf, 0, sizeof(buf));
		strncpy(buf, sb->s_last_mounted, sizeof(sb->s_last_mounted));
	} else
		strcpy(buf, ""<not available>"");
",unused,e2fsprogtrusty-lib2Fe2p2Fls.c
"		if (mask == f->mask)
			return f->string;
	}
	for (fnum = 0; mask >>= 1; fnum++);
	sprintf(buf, ""MNTOPT_%d"", fnum);
",1,unused,53,unused,"		if (mask == f->mask)
			return f->string;
	}
	for (fnum = 0; mask >>= 1; fnum++);
	sprintf(buf, ""MNTOPT_%d"", fnum);
",unused,e2fsprogtrusty-lib2Fe2p2Fmntopts.c
"
	buf = malloc(strlen(str)+1);
	if (!buf)
		return 1;
	strcpy(buf, str);
",1,unused,112,unused,"
	buf = malloc(strlen(str)+1);
	if (!buf)
		return 1;
	strcpy(buf, str);
",unused,e2fsprogtrusty-lib2Fe2p2Fmntopts.c
"		os = ""(unknown os)"";

        ret = malloc(strlen(os)+1);
	if (ret)
		strcpy(ret, os);
",1,unused,40,unused,"		os = ""(unknown os)"";

        ret = malloc(strlen(os)+1);
	if (ret)
		strcpy(ret, os);
",unused,e2fsprogtrusty-lib2Fe2p2Fostype.c
"{
	struct uuid uuid;

	e2p_unpack_uuid(uu, &uuid);
	sprintf(out,
",1,unused,68,unused,"{
	struct uuid uuid;

	e2p_unpack_uuid(uu, &uuid);
	sprintf(out,
",unused,e2fsprogtrusty-lib2Fe2p2Fuuid.c
"	}
    }
    et_list_unlock();
oops:
    strcpy (buffer, ""Unknown code "");
",1,unused,175,unused,"	}
    }
    et_list_unlock();
oops:
    strcpy (buffer, ""Unknown code "");
",unused,e2fsprogtrusty-lib2Fet2Ferror_message.c
"    et_list_unlock();
oops:
    strcpy (buffer, ""Unknown code "");
    if (table_num) {
	strcat (buffer, error_table_name (table_num));
",1,unused,177,unused,"    et_list_unlock();
oops:
    strcpy (buffer, ""Unknown code "");
    if (table_num) {
	strcat (buffer, error_table_name (table_num));
",unused,e2fsprogtrusty-lib2Fet2Ferror_message.c
"oops:
    strcpy (buffer, ""Unknown code "");
    if (table_num) {
	strcat (buffer, error_table_name (table_num));
	strcat (buffer, "" "");
",1,unused,178,unused,"oops:
    strcpy (buffer, ""Unknown code "");
    if (table_num) {
	strcat (buffer, error_table_name (table_num));
	strcat (buffer, "" "");
",unused,e2fsprogtrusty-lib2Fet2Ferror_message.c
"
	retval = ext2fs_get_mem(strlen(src->device_name)+1, &fs->device_name);
	if (retval)
		goto errout;
	strcpy(fs->device_name, src->device_name);
",1,unused,54,unused,"
	retval = ext2fs_get_mem(strlen(src->device_name)+1, &fs->device_name);
	if (retval)
		goto errout;
	strcpy(fs->device_name, src->device_name);
",unused,e2fsprogtrusty-lib2Fext2fs2Fdupfs.c
"	if (!dp->name) {
		free(dp);
		return;
	}
	strcpy(dp->name, name);
",1,unused,59,unused,"	if (!dp->name) {
		free(dp);
		return;
	}
	strcpy(dp->name, name);
",unused,e2fsprogtrusty-lib2Fext2fs2Ffinddev.c
"		if (dp->d_name[0] == '.' &&
		    ((dp->d_name[1] == 0) ||
		     ((dp->d_name[1] == '.') && (dp->d_name[2] == 0))))
			goto skip_to_next;
		sprintf(path, ""%s/%s"", dirname, dp->d_name);
",1,unused,99,unused,"		if (dp->d_name[0] == '.' &&
		    ((dp->d_name[1] == 0) ||
		     ((dp->d_name[1] == '.') && (dp->d_name[2] == 0))))
			goto skip_to_next;
		sprintf(path, ""%s/%s"", dirname, dp->d_name);
",unused,e2fsprogtrusty-lib2Fext2fs2Ffinddev.c
"			if (!cp) {
				closedir(dir);
				return ENOMEM;
			}
			strcpy(cp, path);
",1,unused,110,unused,"			if (!cp) {
				closedir(dir);
				return ENOMEM;
			}
			strcpy(cp, path);
",unused,e2fsprogtrusty-lib2Fext2fs2Ffinddev.c
"		if (retval) {
			ext2fs_free_mem(&bitmap);
			return retval;
		}
		strcpy(bitmap->description, descr);
",1,unused,112,unused,"		if (retval) {
			ext2fs_free_mem(&bitmap);
			return retval;
		}
		strcpy(bitmap->description, descr);
",unused,e2fsprogtrusty-lib2Fext2fs2Fgen_bitmap.c
"		if (retval) {
			ext2fs_free_mem(&bitmap);
			return retval;
		}
		strcpy(bitmap->description, descr);
",1,unused,162,unused,"		if (retval) {
			ext2fs_free_mem(&bitmap);
			return retval;
		}
		strcpy(bitmap->description, descr);
",unused,e2fsprogtrusty-lib2Fext2fs2Fgen_bitmap64.c
"		if (retval) {
			ext2fs_free_mem(&new_bmap);
			return retval;
		}
		sprintf(new_descr, ""copy of %s"", descr);
",1,unused,327,unused,"		if (retval) {
			ext2fs_free_mem(&new_bmap);
			return retval;
		}
		sprintf(new_descr, ""copy of %s"", descr);
",unused,e2fsprogtrusty-lib2Fext2fs2Fgen_bitmap64.c
"	if (dir == ino) {
		retval = ext2fs_get_mem(2, name);
		if (retval)
			return retval;
		strcpy(*name, (dir == EXT2_ROOT_INO) ? ""/"" : ""."");
",1,unused,84,unused,"	if (dir == ino) {
		retval = ext2fs_get_mem(2, name);
		if (retval)
			return retval;
		strcpy(*name, (dir == EXT2_ROOT_INO) ? ""/"" : ""."");
",unused,e2fsprogtrusty-lib2Fext2fs2Fget_pathname.c
"	if (!dir || (maxdepth < 0)) {
		retval = ext2fs_get_mem(4, name);
		if (retval)
			return retval;
		strcpy(*name, ""..."");
",1,unused,92,unused,"	if (!dir || (maxdepth < 0)) {
		retval = ext2fs_get_mem(4, name);
		if (retval)
			return retval;
		strcpy(*name, ""..."");
",unused,e2fsprogtrusty-lib2Fext2fs2Fget_pathname.c
"			snprintf(tmp, sizeof(tmp), ""<%u>"", dir);
		retval = ext2fs_get_mem(strlen(tmp)+1, name);
		if (retval)
			goto cleanup;
		strcpy(*name, tmp);
",1,unused,112,unused,"			snprintf(tmp, sizeof(tmp), ""<%u>"", dir);
		retval = ext2fs_get_mem(strlen(tmp)+1, name);
		if (retval)
			goto cleanup;
		strcpy(*name, tmp);
",unused,e2fsprogtrusty-lib2Fext2fs2Fget_pathname.c
"		goto cleanup;

	ret[0] = 0;
	if (parent_name[1])
		strcat(ret, parent_name);
",1,unused,140,unused,"		goto cleanup;

	ret[0] = 0;
	if (parent_name[1])
		strcat(ret, parent_name);
",unused,e2fsprogtrusty-lib2Fext2fs2Fget_pathname.c
"
	ret[0] = 0;
	if (parent_name[1])
		strcat(ret, parent_name);
	strcat(ret, ""/"");
",1,unused,141,unused,"
	ret[0] = 0;
	if (parent_name[1])
		strcat(ret, parent_name);
	strcat(ret, ""/"");
",unused,e2fsprogtrusty-lib2Fext2fs2Fget_pathname.c
"	if (parent_name[1])
		strcat(ret, parent_name);
	strcat(ret, ""/"");
	if (gp.name)
		strcat(ret, gp.name);
",1,unused,143,unused,"	if (parent_name[1])
		strcat(ret, parent_name);
	strcat(ret, ""/"");
	if (gp.name)
		strcat(ret, gp.name);
",unused,e2fsprogtrusty-lib2Fext2fs2Fget_pathname.c
"	strcat(ret, ""/"");
	if (gp.name)
		strcat(ret, gp.name);
	else
		strcat(ret, ""???"");
",1,unused,145,unused,"	strcat(ret, ""/"");
	if (gp.name)
		strcat(ret, gp.name);
	else
		strcat(ret, ""???"");
",unused,e2fsprogtrusty-lib2Fext2fs2Fget_pathname.c
"{
	struct uuid uuid;

	unpack_uuid(uu, &uuid);
	sprintf(out,
",1,unused,169,unused,"{
	struct uuid uuid;

	unpack_uuid(uu, &uuid);
	sprintf(out,
",unused,e2fsprogtrusty-lib2Fext2fs2Ficount.c
"	retval = ext2fs_get_mem(strlen(tdb_dir) + 64, &fn);
	if (retval)
		goto errout;
	uuid_unparse(fs->super->s_uuid, uuid);
	sprintf(fn, ""%s/%s-icount-XXXXXX"", tdb_dir, uuid);
",1,unused,194,unused,"	retval = ext2fs_get_mem(strlen(tdb_dir) + 64, &fn);
	if (retval)
		goto errout;
	uuid_unparse(fs->super->s_uuid, uuid);
	sprintf(fn, ""%s/%s-icount-XXXXXX"", tdb_dir, uuid);
",unused,e2fsprogtrusty-lib2Fext2fs2Ficount.c
"	retval = ext2fs_get_mem(strlen(name)+1, &fs->device_name);
	if (retval)
		goto cleanup;

	strcpy(fs->device_name, name);
",1,unused,135,unused,"	retval = ext2fs_get_mem(strlen(name)+1, &fs->device_name);
	if (retval)
		goto cleanup;

	strcpy(fs->device_name, name);
",unused,e2fsprogtrusty-lib2Fext2fs2Finitialize.c
"	retval = ext2fs_get_mem(strlen(fs->device_name) + 80, &buf);
	if (retval)
		goto cleanup;

	strcpy(buf, ""block bitmap for "");
",1,unused,429,unused,"	retval = ext2fs_get_mem(strlen(fs->device_name) + 80, &buf);
	if (retval)
		goto cleanup;

	strcpy(buf, ""block bitmap for "");
",unused,e2fsprogtrusty-lib2Fext2fs2Finitialize.c
"	if (retval)
		goto cleanup;

	strcpy(buf, ""block bitmap for "");
	strcat(buf, fs->device_name);
",1,unused,430,unused,"	if (retval)
		goto cleanup;

	strcpy(buf, ""block bitmap for "");
	strcat(buf, fs->device_name);
",unused,e2fsprogtrusty-lib2Fext2fs2Finitialize.c
"	retval = ext2fs_allocate_subcluster_bitmap(fs, buf, &fs->block_map);
	if (retval)
		goto cleanup;

	strcpy(buf, ""inode bitmap for "");
",1,unused,435,unused,"	retval = ext2fs_allocate_subcluster_bitmap(fs, buf, &fs->block_map);
	if (retval)
		goto cleanup;

	strcpy(buf, ""inode bitmap for "");
",unused,e2fsprogtrusty-lib2Fext2fs2Finitialize.c
"	if (retval)
		goto cleanup;

	strcpy(buf, ""inode bitmap for "");
	strcat(buf, fs->device_name);
",1,unused,436,unused,"	if (retval)
		goto cleanup;

	strcpy(buf, ""inode bitmap for "");
	strcat(buf, fs->device_name);
",unused,e2fsprogtrusty-lib2Fext2fs2Finitialize.c
"	if ((retval = ext2fs_get_mem(sizeof(struct inode_private_data),
				     &data)))
		return retval;
	data->magic = EXT2_ET_MAGIC_INODE_IO_CHANNEL;
	sprintf(data->name, ""%u:%d"", ino, ino_unique++);
",1,unused,94,unused,"	if ((retval = ext2fs_get_mem(sizeof(struct inode_private_data),
				     &data)))
		return retval;
	data->magic = EXT2_ET_MAGIC_INODE_IO_CHANNEL;
	sprintf(data->name, ""%u:%d"", ino, ino_unique++);
",unused,e2fsprogtrusty-lib2Fext2fs2Finode_io.c
"	retval = ext2fs_get_mem(strlen(name)+1, &io->name);
	if (retval)
		goto cleanup;

	strcpy(io->name, name);
",1,unused,148,unused,"	retval = ext2fs_get_mem(strlen(name)+1, &io->name);
	if (retval)
		goto cleanup;

	strcpy(io->name, name);
",unused,e2fsprogtrusty-lib2Fext2fs2Finode_io.c
"
	options = malloc(strlen(opts)+1);
	if (!options)
		return EXT2_ET_NO_MEMORY;
	strcpy(options, opts);
",1,unused,39,unused,"
	options = malloc(strlen(opts)+1);
	if (!options)
		return EXT2_ET_NO_MEMORY;
	strcpy(options, opts);
",unused,e2fsprogtrusty-lib2Fext2fs2Fio_manager.c
"	if (mount_flags & EXT2_MF_MOUNTED) {
#if HAVE_EXT2_IOCTLS
		int f = 0;
#endif
		strcat(jfile, ""/.journal"");
",1,unused,514,unused,"	if (mount_flags & EXT2_MF_MOUNTED) {
#if HAVE_EXT2_IOCTLS
		int f = 0;
#endif
		strcat(jfile, ""/.journal"");
",unused,e2fsprogtrusty-lib2Fext2fs2Fmkjournal.c
"	fs->umask = 022;
	retval = ext2fs_get_mem(strlen(name)+1, &fs->device_name);
	if (retval)
		goto cleanup;
	strcpy(fs->device_name, name);
",1,unused,126,unused,"	fs->umask = 022;
	retval = ext2fs_get_mem(strlen(name)+1, &fs->device_name);
	if (retval)
		goto cleanup;
	strcpy(fs->device_name, name);
",unused,e2fsprogtrusty-lib2Fext2fs2Fopenfs.c
"		return retval;
	if (do_block) {
		if (fs->block_map)
			ext2fs_free_block_bitmap(fs->block_map);
		strcpy(buf, ""block bitmap for "");
",1,unused,182,unused,"		return retval;
	if (do_block) {
		if (fs->block_map)
			ext2fs_free_block_bitmap(fs->block_map);
		strcpy(buf, ""block bitmap for "");
",unused,e2fsprogtrusty-lib2Fext2fs2Frw_bitmaps.c
"	if (do_block) {
		if (fs->block_map)
			ext2fs_free_block_bitmap(fs->block_map);
		strcpy(buf, ""block bitmap for "");
		strcat(buf, fs->device_name);
",1,unused,183,unused,"	if (do_block) {
		if (fs->block_map)
			ext2fs_free_block_bitmap(fs->block_map);
		strcpy(buf, ""block bitmap for "");
		strcat(buf, fs->device_name);
",unused,e2fsprogtrusty-lib2Fext2fs2Frw_bitmaps.c
"		block_nbytes = 0;
	if (do_inode) {
		if (fs->inode_map)
			ext2fs_free_inode_bitmap(fs->inode_map);
		strcpy(buf, ""inode bitmap for "");
",1,unused,195,unused,"		block_nbytes = 0;
	if (do_inode) {
		if (fs->inode_map)
			ext2fs_free_inode_bitmap(fs->inode_map);
		strcpy(buf, ""inode bitmap for "");
",unused,e2fsprogtrusty-lib2Fext2fs2Frw_bitmaps.c
"	if (do_inode) {
		if (fs->inode_map)
			ext2fs_free_inode_bitmap(fs->inode_map);
		strcpy(buf, ""inode bitmap for "");
		strcat(buf, fs->device_name);
",1,unused,196,unused,"	if (do_inode) {
		if (fs->inode_map)
			ext2fs_free_inode_bitmap(fs->inode_map);
		strcpy(buf, ""inode bitmap for "");
		strcat(buf, fs->device_name);
",unused,e2fsprogtrusty-lib2Fext2fs2Frw_bitmaps.c
"	/* The time fields are set by ext2fs_write_new_inode() */

	if (fastlink) {
		/* Fast symlinks, target stored in inode */
		strcpy((char *)&inode.i_block, target);
",1,unused,88,unused,"	/* The time fields are set by ext2fs_write_new_inode() */

	if (fastlink) {
		/* Fast symlinks, target stored in inode */
		strcpy((char *)&inode.i_block, target);
",unused,e2fsprogtrusty-lib2Fext2fs2Fsymlink.c
"		strcpy((char *)&inode.i_block, target);
	} else {
		/* Slow symlinks, target stored in the first block */
		memset(block_buf, 0, fs->blocksize);
		strcpy(block_buf, target);
",1,unused,92,unused,"		strcpy((char *)&inode.i_block, target);
	} else {
		/* Slow symlinks, target stored in the first block */
		memset(block_buf, 0, fs->blocksize);
		strcpy(block_buf, target);
",unused,e2fsprogtrusty-lib2Fext2fs2Fsymlink.c
"	retval = ext2fs_get_mem(strlen(name)+1, &io->name);
	if (retval)
		goto cleanup;

	strcpy(io->name, name);
",1,unused,213,unused,"	retval = ext2fs_get_mem(strlen(name)+1, &io->name);
	if (retval)
		goto cleanup;

	strcpy(io->name, name);
",unused,e2fsprogtrusty-lib2Fext2fs2Ftest_io.c
"	retval = ext2fs_get_mem(strlen(name)+1, &io->name);
	if (retval)
		goto cleanup;

	strcpy(io->name, name);
",1,unused,373,unused,"	retval = ext2fs_get_mem(strlen(name)+1, &io->name);
	if (retval)
		goto cleanup;

	strcpy(io->name, name);
",unused,e2fsprogtrusty-lib2Fext2fs2Fundo_io.c
"	retval = ext2fs_get_mem(strlen(name)+1, &io->name);
	if (retval)
		goto cleanup;

	strcpy(io->name, name);
",1,unused,498,unused,"	retval = ext2fs_get_mem(strlen(name)+1, &io->name);
	if (retval)
		goto cleanup;

	strcpy(io->name, name);
",unused,e2fsprogtrusty-lib2Fext2fs2Funix_io.c
"			 (strlen(infop->subsystem_name)+1)
			 * sizeof(char));
	if (ret_val == (char *)NULL)
	    return((char *)NULL);
	strcpy(ret_val, infop->subsystem_name);
",1,unused,35,unused,"			 (strlen(infop->subsystem_name)+1)
			 * sizeof(char));
	if (ret_val == (char *)NULL)
	    return((char *)NULL);
	strcpy(ret_val, infop->subsystem_name);
",unused,e2fsprogtrusty-lib2Fss2Ferror.c
"
	tmp = malloc(strlen(libpath)+1);
	if (!tmp)
		return;
	strcpy(tmp, libpath);
",1,unused,63,unused,"
	tmp = malloc(strlen(libpath)+1);
	if (!tmp)
		return;
	strcpy(tmp, libpath);
",unused,e2fsprogtrusty-lib2Fss2Fget_readline.c
"		ss_perror(sci_idx, 0,
			  ""couldn't allocate memory to print usage message"");
		return;
	}
	sprintf(buffer, ""usage:\n\t%s [topic|command]\nor\t%s\n"",
",1,unused,65,unused,"		ss_perror(sci_idx, 0,
			  ""couldn't allocate memory to print usage message"");
		return;
	}
	sprintf(buffer, ""usage:\n\t%s [topic|command]\nor\t%s\n"",
",unused,e2fsprogtrusty-lib2Fss2Fhelp.c
"	    ss_perror(sci_idx, 0,
		      ""couldn't allocate memory for help filename"");
	    return;
	}
	(void) strcpy(buffer, info->info_dirs[idx]);
",1,unused,88,unused,"	    ss_perror(sci_idx, 0,
		      ""couldn't allocate memory for help filename"");
	    return;
	}
	(void) strcpy(buffer, info->info_dirs[idx]);
",unused,e2fsprogtrusty-lib2Fss2Fhelp.c
"		      ""couldn't allocate memory for help filename"");
	    return;
	}
	(void) strcpy(buffer, info->info_dirs[idx]);
	(void) strcat(buffer, ""/"");
",1,unused,89,unused,"		      ""couldn't allocate memory for help filename"");
	    return;
	}
	(void) strcpy(buffer, info->info_dirs[idx]);
	(void) strcat(buffer, ""/"");
",unused,e2fsprogtrusty-lib2Fss2Fhelp.c
"	    return;
	}
	(void) strcpy(buffer, info->info_dirs[idx]);
	(void) strcat(buffer, ""/"");
	(void) strcat(buffer, argv[1]);
",1,unused,90,unused,"	    return;
	}
	(void) strcpy(buffer, info->info_dirs[idx]);
	(void) strcat(buffer, ""/"");
	(void) strcat(buffer, argv[1]);
",unused,e2fsprogtrusty-lib2Fss2Fhelp.c
"	}
	(void) strcpy(buffer, info->info_dirs[idx]);
	(void) strcat(buffer, ""/"");
	(void) strcat(buffer, argv[1]);
	(void) strcat(buffer, "".info"");
",1,unused,91,unused,"	}
	(void) strcpy(buffer, info->info_dirs[idx]);
	(void) strcat(buffer, ""/"");
	(void) strcat(buffer, argv[1]);
	(void) strcat(buffer, "".info"");
",unused,e2fsprogtrusty-lib2Fss2Fhelp.c
"    }
    if (fd < 0) {
#define MSG ""No info found for ""
        char *buf = malloc(strlen (MSG) + strlen (argv[1]) + 1);
	strcpy(buf, MSG);
",1,unused,100,unused,"    }
    if (fd < 0) {
#define MSG ""No info found for ""
        char *buf = malloc(strlen (MSG) + strlen (argv[1]) + 1);
	strcpy(buf, MSG);
",unused,e2fsprogtrusty-lib2Fss2Fhelp.c
"    if (fd < 0) {
#define MSG ""No info found for ""
        char *buf = malloc(strlen (MSG) + strlen (argv[1]) + 1);
	strcpy(buf, MSG);
	strcat(buf, argv[1]);
",1,unused,101,unused,"    if (fd < 0) {
#define MSG ""No info found for ""
        char *buf = malloc(strlen (MSG) + strlen (argv[1]) + 1);
	strcpy(buf, MSG);
	strcat(buf, argv[1]);
",unused,e2fsprogtrusty-lib2Fss2Fhelp.c
"    }
    info->info_dirs = dirs;
    dirs[n_dirs + 1] = (char *)NULL;
    dirs[n_dirs] = malloc((unsigned)strlen(info_dir)+1);
    strcpy(dirs[n_dirs], info_dir);
",1,unused,158,unused,"    }
    info->info_dirs = dirs;
    dirs[n_dirs + 1] = (char *)NULL;
    dirs[n_dirs] = malloc((unsigned)strlen(info_dir)+1);
    strcpy(dirs[n_dirs], info_dir);
",unused,e2fsprogtrusty-lib2Fss2Fhelp.c
"	new_table->info_dirs = (char **)malloc(sizeof(char *));
	*new_table->info_dirs = (char *)NULL;
	new_table->info_ptr = info_ptr;
	new_table->prompt = malloc((unsigned)strlen(subsystem_name)+4);
	strcpy(new_table->prompt, subsystem_name);
",1,unused,62,unused,"	new_table->info_dirs = (char **)malloc(sizeof(char *));
	*new_table->info_dirs = (char *)NULL;
	new_table->info_ptr = info_ptr;
	new_table->prompt = malloc((unsigned)strlen(subsystem_name)+4);
	strcpy(new_table->prompt, subsystem_name);
",unused,e2fsprogtrusty-lib2Fss2Finvocation.c
"	*new_table->info_dirs = (char *)NULL;
	new_table->info_ptr = info_ptr;
	new_table->prompt = malloc((unsigned)strlen(subsystem_name)+4);
	strcpy(new_table->prompt, subsystem_name);
	strcat(new_table->prompt, "":  "");
",1,unused,63,unused,"	*new_table->info_dirs = (char *)NULL;
	new_table->info_ptr = info_ptr;
	new_table->prompt = malloc((unsigned)strlen(subsystem_name)+4);
	strcpy(new_table->prompt, subsystem_name);
	strcat(new_table->prompt, "":  "");
",unused,e2fsprogtrusty-lib2Fss2Finvocation.c
"                int len = strlen(*name);
                strncat(buffer, *name, len);
                spacing += len + 2;
                if (name[1]) {
                    strcat(buffer, "", "");
",1,unused,71,unused,"                int len = strlen(*name);
                strncat(buffer, *name, len);
                spacing += len + 2;
                if (name[1]) {
                    strcat(buffer, "", "");
",unused,e2fsprogtrusty-lib2Fss2Flist_rqs.c
"                    strcat(buffer, "", "");
                }
            }
            if (spacing > 23) {
                strcat(buffer, NL);
",1,unused,75,unused,"                    strcat(buffer, "", "");
                }
            }
            if (spacing > 23) {
                strcat(buffer, NL);
",unused,e2fsprogtrusty-lib2Fss2Flist_rqs.c
"                spacing = 0;
                buffer[0] = '\0';
            }
            strncat(buffer, twentyfive_spaces, 25-spacing);
            strcat(buffer, entry->info_string);
",1,unused,81,unused,"                spacing = 0;
                buffer[0] = '\0';
            }
            strncat(buffer, twentyfive_spaces, 25-spacing);
            strcat(buffer, entry->info_string);
",unused,e2fsprogtrusty-lib2Fss2Flist_rqs.c
"                buffer[0] = '\0';
            }
            strncat(buffer, twentyfive_spaces, 25-spacing);
            strcat(buffer, entry->info_string);
            strcat(buffer, NL);
",1,unused,82,unused,"                buffer[0] = '\0';
            }
            strncat(buffer, twentyfive_spaces, 25-spacing);
            strcat(buffer, entry->info_string);
            strcat(buffer, NL);
",unused,e2fsprogtrusty-lib2Fss2Flist_rqs.c
"		}
		if (strncmp(*name, text, len) == 0) {
			ret = malloc(strlen(*name)+1);
			if (ret)
				strcpy(ret, *name);
",1,unused,181,unused,"		}
		if (strncmp(*name, text, len) == 0) {
			ret = malloc(strlen(*name)+1);
			if (ret)
				strcpy(ret, *name);
",unused,e2fsprogtrusty-lib2Fss2Flisten.c
"	if ((s = socket(AF_UNIX, SOCK_STREAM, 0)) < 0)
		return -1;

	srv_addr.sun_family = AF_UNIX;
	strcpy(srv_addr.sun_path, UUIDD_SOCKET_PATH);
",1,unused,500,unused,"	if ((s = socket(AF_UNIX, SOCK_STREAM, 0)) < 0)
		return -1;

	srv_addr.sun_family = AF_UNIX;
	strcpy(srv_addr.sun_path, UUIDD_SOCKET_PATH);
",unused,e2fsprogtrusty-lib2Fuuid2Fgen_uuid.c
"{
	struct uuid uuid;

	uuid_unpack(uu, &uuid);
	sprintf(out, fmt,
",1,unused,57,unused,"{
	struct uuid uuid;

	uuid_unpack(uu, &uuid);
	sprintf(out, fmt,
",unused,e2fsprogtrusty-lib2Fuuid2Funparse.c
"
	str = malloc(strlen(device)+1);
	if (!str)
		return NULL;
	strcpy(str, device);
",1,unused,51,unused,"
	str = malloc(strlen(device)+1);
	if (!str)
		return NULL;
	strcpy(str, device);
",unused,e2fsprogtrusty-misc2Fbase_device.c
"					  mtpt, sizeof(mtpt));
	if (retval == 0) {
		if (mount_flags & EXT2_MF_MOUNTED) {
			if (!mtpt[0])
				strcpy(mtpt, ""(mounted, mtpt unknown)"");
",1,unused,210,unused,"					  mtpt, sizeof(mtpt));
	if (retval == 0) {
		if (mount_flags & EXT2_MF_MOUNTED) {
			if (!mtpt[0])
				strcpy(mtpt, ""(mounted, mtpt unknown)"");
",unused,e2fsprogtrusty-misc2Fblkid.c
"		if (mount_flags & EXT2_MF_MOUNTED) {
			if (!mtpt[0])
				strcpy(mtpt, ""(mounted, mtpt unknown)"");
		} else if (mount_flags & EXT2_MF_BUSY)
			strcpy(mtpt, ""(in use)"");
",1,unused,212,unused,"		if (mount_flags & EXT2_MF_MOUNTED) {
			if (!mtpt[0])
				strcpy(mtpt, ""(mounted, mtpt unknown)"");
		} else if (mount_flags & EXT2_MF_BUSY)
			strcpy(mtpt, ""(in use)"");
",unused,e2fsprogtrusty-misc2Fblkid.c
"				strcpy(mtpt, ""(mounted, mtpt unknown)"");
		} else if (mount_flags & EXT2_MF_BUSY)
			strcpy(mtpt, ""(in use)"");
		else
			strcpy(mtpt, ""(not mounted)"");
",1,unused,214,unused,"				strcpy(mtpt, ""(mounted, mtpt unknown)"");
		} else if (mount_flags & EXT2_MF_BUSY)
			strcpy(mtpt, ""(in use)"");
		else
			strcpy(mtpt, ""(not mounted)"");
",unused,e2fsprogtrusty-misc2Fblkid.c
"				_(""Couldn't allocate path variable ""
				  ""in chattr_dir_proc""));
			return -1;
		}
		sprintf(path, ""%s/%s"", dir_name, de->d_name);
",1,unused,271,unused,"				_(""Couldn't allocate path variable ""
				  ""in chattr_dir_proc""));
			return -1;
		}
		sprintf(path, ""%s/%s"", dir_name, de->d_name);
",unused,e2fsprogtrusty-misc2Fchattr.c
"		fprintf(stderr, ""%s"",
			_(""Couldn't allocate memory to parse options!\n""));
		exit(1);
	}
	strcpy(buf, opts);
",1,unused,459,unused,"		fprintf(stderr, ""%s"",
			_(""Couldn't allocate memory to parse options!\n""));
		exit(1);
	}
	strcpy(buf, opts);
",unused,e2fsprogtrusty-misc2Fdumpe2fs.c
"		exit(1);
	}

	hdr.magic_number = EXT2_ET_MAGIC_E2IMAGE;
	strcpy(hdr.magic_descriptor, ""Ext2 Image 1.0"");
",1,unused,269,unused,"		exit(1);
	}

	hdr.magic_number = EXT2_ET_MAGIC_E2IMAGE;
	strcpy(hdr.magic_descriptor, ""Ext2 Image 1.0"");
",unused,e2fsprogtrusty-misc2Fe2image.c
"			flags |= E2IMAGE_IS_QCOW2_FLAG;
			goto skip_device;
		}
	}
	sprintf(offset_opt, ""offset=%llu"", source_offset);
",1,unused,1563,unused,"			flags |= E2IMAGE_IS_QCOW2_FLAG;
			goto skip_device;
		}
	}
	sprintf(offset_opt, ""offset=%llu"", source_offset);
",unused,e2fsprogtrusty-misc2Fe2image.c
"	if (!s)
		return 0;
	ret = malloc(strlen(s)+1);
	if (ret)
		strcpy(ret, s);
",1,unused,165,unused,"	if (!s)
		return 0;
	ret = malloc(strlen(s)+1);
	if (ret)
		strcpy(ret, s);
",unused,e2fsprogtrusty-misc2Fe2initrd_helper.c
"	}

	if (mode_flag & DETAIL) {
		/* Print statistic info */
		sprintf(msg_buffer, ""[%u/%u]%s"",
",1,unused,1262,unused,"	}

	if (mode_flag & DETAIL) {
		/* Print statistic info */
		sprintf(msg_buffer, ""[%u/%u]%s"",
",unused,e2fsprogtrusty-misc2Fe4defrag.c
"	}

	/* Create donor inode */
	memset(tmp_inode_name, 0, PATH_MAX + 8);
	sprintf(tmp_inode_name, ""%.*s.defrag"",
",1,unused,1580,unused,"	}

	/* Create donor inode */
	memset(tmp_inode_name, 0, PATH_MAX + 8);
	sprintf(tmp_inode_name, ""%.*s.defrag"",
",unused,e2fsprogtrusty-misc2Fe4defrag.c
"	logical_blk = fm_extent->fe_logical >> blk_shift;
	physical_blk = fm_extent->fe_physical >> blk_shift;

	if (expected)
		sprintf(flags, ext_fmt == hex_fmt ? ""%*llx: "" : ""%*llu: "",
",1,unused,147,unused,"	logical_blk = fm_extent->fe_logical >> blk_shift;
	physical_blk = fm_extent->fe_physical >> blk_shift;

	if (expected)
		sprintf(flags, ext_fmt == hex_fmt ? ""%*llx: "" : ""%*llu: "",
",unused,e2fsprogtrusty-misc2Ffilefrag.c
"	if (expected)
		sprintf(flags, ext_fmt == hex_fmt ? ""%*llx: "" : ""%*llu: "",
			physical_width, expected >> blk_shift);
	else
		sprintf(flags, ""%.*s  "", physical_width, ""                   "");
",1,unused,150,unused,"	if (expected)
		sprintf(flags, ext_fmt == hex_fmt ? ""%*llx: "" : ""%*llu: "",
			physical_width, expected >> blk_shift);
	else
		sprintf(flags, ""%.*s  "", physical_width, ""                   "");
",unused,e2fsprogtrusty-misc2Ffilefrag.c
"	else
		sprintf(flags, ""%.*s  "", physical_width, ""                   "");

	if (fm_extent->fe_flags & FIEMAP_EXTENT_UNKNOWN)
		strcat(flags, ""unknown,"");
",1,unused,153,unused,"	else
		sprintf(flags, ""%.*s  "", physical_width, ""                   "");

	if (fm_extent->fe_flags & FIEMAP_EXTENT_UNKNOWN)
		strcat(flags, ""unknown,"");
",unused,e2fsprogtrusty-misc2Ffilefrag.c
"
	if (fm_extent->fe_flags & FIEMAP_EXTENT_UNKNOWN)
		strcat(flags, ""unknown,"");
	if (fm_extent->fe_flags & FIEMAP_EXTENT_DELALLOC)
		strcat(flags, ""delalloc,"");
",1,unused,155,unused,"
	if (fm_extent->fe_flags & FIEMAP_EXTENT_UNKNOWN)
		strcat(flags, ""unknown,"");
	if (fm_extent->fe_flags & FIEMAP_EXTENT_DELALLOC)
		strcat(flags, ""delalloc,"");
",unused,e2fsprogtrusty-misc2Ffilefrag.c
"		strcat(flags, ""unknown,"");
	if (fm_extent->fe_flags & FIEMAP_EXTENT_DELALLOC)
		strcat(flags, ""delalloc,"");
	if (fm_extent->fe_flags & FIEMAP_EXTENT_DATA_ENCRYPTED)
		strcat(flags, ""encrypted,"");
",1,unused,157,unused,"		strcat(flags, ""unknown,"");
	if (fm_extent->fe_flags & FIEMAP_EXTENT_DELALLOC)
		strcat(flags, ""delalloc,"");
	if (fm_extent->fe_flags & FIEMAP_EXTENT_DATA_ENCRYPTED)
		strcat(flags, ""encrypted,"");
",unused,e2fsprogtrusty-misc2Ffilefrag.c
"		strcat(flags, ""delalloc,"");
	if (fm_extent->fe_flags & FIEMAP_EXTENT_DATA_ENCRYPTED)
		strcat(flags, ""encrypted,"");
	if (fm_extent->fe_flags & FIEMAP_EXTENT_NOT_ALIGNED)
		strcat(flags, ""not_aligned,"");
",1,unused,159,unused,"		strcat(flags, ""delalloc,"");
	if (fm_extent->fe_flags & FIEMAP_EXTENT_DATA_ENCRYPTED)
		strcat(flags, ""encrypted,"");
	if (fm_extent->fe_flags & FIEMAP_EXTENT_NOT_ALIGNED)
		strcat(flags, ""not_aligned,"");
",unused,e2fsprogtrusty-misc2Ffilefrag.c
"		strcat(flags, ""encrypted,"");
	if (fm_extent->fe_flags & FIEMAP_EXTENT_NOT_ALIGNED)
		strcat(flags, ""not_aligned,"");
	if (fm_extent->fe_flags & FIEMAP_EXTENT_DATA_INLINE)
		strcat(flags, ""inline,"");
",1,unused,161,unused,"		strcat(flags, ""encrypted,"");
	if (fm_extent->fe_flags & FIEMAP_EXTENT_NOT_ALIGNED)
		strcat(flags, ""not_aligned,"");
	if (fm_extent->fe_flags & FIEMAP_EXTENT_DATA_INLINE)
		strcat(flags, ""inline,"");
",unused,e2fsprogtrusty-misc2Ffilefrag.c
"		strcat(flags, ""not_aligned,"");
	if (fm_extent->fe_flags & FIEMAP_EXTENT_DATA_INLINE)
		strcat(flags, ""inline,"");
	if (fm_extent->fe_flags & FIEMAP_EXTENT_DATA_TAIL)
		strcat(flags, ""tail_packed,"");
",1,unused,163,unused,"		strcat(flags, ""not_aligned,"");
	if (fm_extent->fe_flags & FIEMAP_EXTENT_DATA_INLINE)
		strcat(flags, ""inline,"");
	if (fm_extent->fe_flags & FIEMAP_EXTENT_DATA_TAIL)
		strcat(flags, ""tail_packed,"");
",unused,e2fsprogtrusty-misc2Ffilefrag.c
"		strcat(flags, ""inline,"");
	if (fm_extent->fe_flags & FIEMAP_EXTENT_DATA_TAIL)
		strcat(flags, ""tail_packed,"");
	if (fm_extent->fe_flags & FIEMAP_EXTENT_UNWRITTEN)
		strcat(flags, ""unwritten,"");
",1,unused,165,unused,"		strcat(flags, ""inline,"");
	if (fm_extent->fe_flags & FIEMAP_EXTENT_DATA_TAIL)
		strcat(flags, ""tail_packed,"");
	if (fm_extent->fe_flags & FIEMAP_EXTENT_UNWRITTEN)
		strcat(flags, ""unwritten,"");
",unused,e2fsprogtrusty-misc2Ffilefrag.c
"		strcat(flags, ""tail_packed,"");
	if (fm_extent->fe_flags & FIEMAP_EXTENT_UNWRITTEN)
		strcat(flags, ""unwritten,"");
	if (fm_extent->fe_flags & FIEMAP_EXTENT_MERGED)
		strcat(flags, ""merged,"");
",1,unused,167,unused,"		strcat(flags, ""tail_packed,"");
	if (fm_extent->fe_flags & FIEMAP_EXTENT_UNWRITTEN)
		strcat(flags, ""unwritten,"");
	if (fm_extent->fe_flags & FIEMAP_EXTENT_MERGED)
		strcat(flags, ""merged,"");
",unused,e2fsprogtrusty-misc2Ffilefrag.c
"	if (fm_extent->fe_flags & FIEMAP_EXTENT_MERGED)
		strcat(flags, ""merged,"");

	if (fm_extent->fe_logical + fm_extent->fe_length >= (__u64) st->st_size)
		strcat(flags, ""eof,"");
",1,unused,170,unused,"	if (fm_extent->fe_flags & FIEMAP_EXTENT_MERGED)
		strcat(flags, ""merged,"");

	if (fm_extent->fe_logical + fm_extent->fe_length >= (__u64) st->st_size)
		strcat(flags, ""eof,"");
",unused,e2fsprogtrusty-misc2Ffilefrag.c
"	if (!s)
		return 0;
	ret = malloc(strlen(s)+1);
	if (ret)
		strcpy(ret, s);
",1,unused,135,unused,"	if (!s)
		return 0;
	ret = malloc(strlen(s)+1);
	if (ret)
		strcpy(ret, s);
",unused,e2fsprogtrusty-misc2Ffsck.c
"  /* Are we looking for a program or just a type? */
  tpl = (strncmp(type, ""fsck."", 5) ? ""%s/fsck.%s"" : ""%s/%s"");

  for(s = strtok(p, "":""); s; s = strtok(NULL, "":"")) {
	sprintf(prog, tpl, s, type);
",1,unused,411,unused,"  /* Are we looking for a program or just a type? */
  tpl = (strncmp(type, ""fsck."", 5) ? ""%s/fsck.%s"" : ""%s/%s"");

  for(s = strtok(p, "":""); s; s = strtok(NULL, "":"")) {
	sprintf(prog, tpl, s, type);
",unused,e2fsprogtrusty-misc2Ffsck.c
"	if (!inst)
		return ENOMEM;
	memset(inst, 0, sizeof(struct fsck_instance));

	sprintf(prog, ""fsck.%s"", type);
",1,unused,448,unused,"	if (!inst)
		return ENOMEM;
	memset(inst, 0, sizeof(struct fsck_instance));

	sprintf(prog, ""fsck.%s"", type);
",unused,e2fsprogtrusty-misc2Ffsck.c
"		if (!fsck_path) {
			fprintf(stderr, ""%s: Unable to allocate memory for fsck_path\n"", progname);
			exit(EXIT_ERROR);
		}
		strcpy (fsck_path, fsck_prefix_path);
",1,unused,1289,unused,"		if (!fsck_path) {
			fprintf(stderr, ""%s: Unable to allocate memory for fsck_path\n"", progname);
			exit(EXIT_ERROR);
		}
		strcpy (fsck_path, fsck_prefix_path);
",unused,e2fsprogtrusty-misc2Ffsck.c
"			fprintf(stderr, ""%s: Unable to allocate memory for fsck_path\n"", progname);
			exit(EXIT_ERROR);
		}
		strcpy (fsck_path, fsck_prefix_path);
		strcat (fsck_path, "":"");
",1,unused,1290,unused,"			fprintf(stderr, ""%s: Unable to allocate memory for fsck_path\n"", progname);
			exit(EXIT_ERROR);
		}
		strcpy (fsck_path, fsck_prefix_path);
		strcat (fsck_path, "":"");
",unused,e2fsprogtrusty-misc2Ffsck.c
"			exit(EXIT_ERROR);
		}
		strcpy (fsck_path, fsck_prefix_path);
		strcat (fsck_path, "":"");
		strcat (fsck_path, oldpath);
",1,unused,1291,unused,"			exit(EXIT_ERROR);
		}
		strcpy (fsck_path, fsck_prefix_path);
		strcat (fsck_path, "":"");
		strcat (fsck_path, oldpath);
",unused,e2fsprogtrusty-misc2Ffsck.c
"	if ( WIFEXITED(status) ) {
		rc = WEXITSTATUS(status);
		if (rc) {
			send_output(argv[0], 0, SEND_BOTH);
			sprintf(buffer, "" died with exit status %d\n"", rc);
",1,unused,213,unused,"	if ( WIFEXITED(status) ) {
		rc = WEXITSTATUS(status);
		if (rc) {
			send_output(argv[0], 0, SEND_BOTH);
			sprintf(buffer, "" died with exit status %d\n"", rc);
",unused,e2fsprogtrusty-misc2Flogsave.c
"		}
	} else {
		if (WIFSIGNALED(status)) {
			send_output(argv[0], 0, SEND_BOTH);
			sprintf(buffer, ""died with signal %d\n"",
",1,unused,219,unused,"		}
	} else {
		if (WIFSIGNALED(status)) {
			send_output(argv[0], 0, SEND_BOTH);
			sprintf(buffer, ""died with signal %d\n"",
",unused,e2fsprogtrusty-misc2Flogsave.c
"
	path = malloc(dir_len + strlen (de->d_name) + 2);

	if (dir_len && dir_name[dir_len-1] == '/')
		sprintf (path, ""%s%s"", dir_name, de->d_name);
",1,unused,138,unused,"
	path = malloc(dir_len + strlen (de->d_name) + 2);

	if (dir_len && dir_name[dir_len-1] == '/')
		sprintf (path, ""%s%s"", dir_name, de->d_name);
",unused,e2fsprogtrusty-misc2Flsattr.c
"
	if (dir_len && dir_name[dir_len-1] == '/')
		sprintf (path, ""%s%s"", dir_name, de->d_name);
	else
		sprintf (path, ""%s/%s"", dir_name, de->d_name);
",1,unused,140,unused,"
	if (dir_len && dir_name[dir_len-1] == '/')
		sprintf (path, ""%s%s"", dir_name, de->d_name);
	else
		sprintf (path, ""%s/%s"", dir_name, de->d_name);
",unused,e2fsprogtrusty-misc2Flsattr.c
"	FILE		*f;
	errcode_t	retval;
	char		buf[1024];

	sprintf(buf, ""badblocks -b %d -X %s%s%s %llu"", fs->blocksize,
",1,unused,217,unused,"	FILE		*f;
	errcode_t	retval;
	char		buf[1024];

	sprintf(buf, ""badblocks -b %d -X %s%s%s %llu"", fs->blocksize,
",unused,e2fsprogtrusty-misc2Fmke2fs.c
"		fprintf(stderr, ""%s"",
			_(""Couldn't allocate memory to parse options!\n""));
		exit(1);
	}
	strcpy(buf, opts);
",1,unused,669,unused,"		fprintf(stderr, ""%s"",
			_(""Couldn't allocate memory to parse options!\n""));
		exit(1);
	}
	strcpy(buf, opts);
",unused,e2fsprogtrusty-misc2Fmke2fs.c
"	}
	sl->list[sl->num] = malloc(strlen(str)+1);
	if (sl->list[sl->num] == 0)
		return ENOMEM;
	strcpy(sl->list[sl->num], str);
",1,unused,1000,unused,"	}
	sl->list[sl->num] = malloc(strlen(str)+1);
	if (sl->list[sl->num] == 0)
		return ENOMEM;
	strcpy(sl->list[sl->num], str);
",unused,e2fsprogtrusty-misc2Fmke2fs.c
"		free(profile_type);
		free(list.list);
		return 0;
	}
	strcpy(parse_str, usage_types);
",1,unused,1137,unused,"		free(profile_type);
		free(list.list);
		return 0;
	}
	strcpy(parse_str, usage_types);
",unused,e2fsprogtrusty-misc2Fmke2fs.c
"		fprintf(stderr, ""%s"",
			_(""Couldn't allocate memory for new PATH.\n""));
		exit(1);
	}
	strcpy(newpath, PATH_SET);
",1,unused,1327,unused,"		fprintf(stderr, ""%s"",
			_(""Couldn't allocate memory for new PATH.\n""));
		exit(1);
	}
	strcpy(newpath, PATH_SET);
",unused,e2fsprogtrusty-misc2Fmke2fs.c
"	strcpy(newpath, PATH_SET);

	/* Update our PATH to include /sbin  */
	if (oldpath) {
		strcat (newpath, "":"");
",1,unused,1331,unused,"	strcpy(newpath, PATH_SET);

	/* Update our PATH to include /sbin  */
	if (oldpath) {
		strcat (newpath, "":"");
",unused,e2fsprogtrusty-misc2Fmke2fs.c
"
	/* Update our PATH to include /sbin  */
	if (oldpath) {
		strcat (newpath, "":"");
		strcat (newpath, oldpath);
",1,unused,1332,unused,"
	/* Update our PATH to include /sbin  */
	if (oldpath) {
		strcat (newpath, "":"");
		strcat (newpath, oldpath);
",unused,e2fsprogtrusty-misc2Fmke2fs.c
"				com_err(program_name, ENOMEM, ""%s"",
					_(""in malloc for bad_blocks_filename""));
				exit(1);
			}
			strcpy(bad_blocks_filename, optarg);
",1,unused,1513,unused,"				com_err(program_name, ENOMEM, ""%s"",
					_(""in malloc for bad_blocks_filename""));
				exit(1);
			}
			strcpy(bad_blocks_filename, optarg);
",unused,e2fsprogtrusty-misc2Fmke2fs.c
"	if (!tdb_file) {
		free(tmp_name);
		goto errout;
	}
	sprintf(tdb_file, ""%s/mke2fs-%s.e2undo"", tdb_dir, dev_name);
",1,unused,2238,unused,"	if (!tdb_file) {
		free(tmp_name);
		goto errout;
	}
	sprintf(tdb_file, ""%s/mke2fs-%s.e2undo"", tdb_dir, dev_name);
",unused,e2fsprogtrusty-misc2Fmke2fs.c
"			itable_zeroed = 1;
		}
	}

	sprintf(tdb_string, ""tdb_data_size=%d"", fs->blocksize <= 4096 ?
",1,unused,2441,unused,"			itable_zeroed = 1;
		}
	}

	sprintf(tdb_string, ""tdb_data_size=%d"", fs->blocksize <= 4096 ?
",unused,e2fsprogtrusty-misc2Fmke2fs.c
"
	i = 0;
	memset (name, 'x', 246);
	do {
		sprintf (name + 246, ""%08d"", i);
",1,unused,61,unused,"
	i = 0;
	memset (name, 'x', 246);
	do {
		sprintf (name + 246, ""%08d"", i);
",unused,e2fsprogtrusty-misc2Fmklost+found.c
"	i = 0;
	memset (name, 'x', 246);
	do {
		sprintf (name + 246, ""%08d"", i);
		strcpy (path, LPF);
",1,unused,62,unused,"	i = 0;
	memset (name, 'x', 246);
	do {
		sprintf (name + 246, ""%08d"", i);
		strcpy (path, LPF);
",unused,e2fsprogtrusty-misc2Fmklost+found.c
"	memset (name, 'x', 246);
	do {
		sprintf (name + 246, ""%08d"", i);
		strcpy (path, LPF);
		strcat (path, ""/"");
",1,unused,63,unused,"	memset (name, 'x', 246);
	do {
		sprintf (name + 246, ""%08d"", i);
		strcpy (path, LPF);
		strcat (path, ""/"");
",unused,e2fsprogtrusty-misc2Fmklost+found.c
"	do {
		sprintf (name + 246, ""%08d"", i);
		strcpy (path, LPF);
		strcat (path, ""/"");
		strcat (path, name);
",1,unused,64,unused,"	do {
		sprintf (name + 246, ""%08d"", i);
		strcpy (path, LPF);
		strcat (path, ""/"");
		strcat (path, name);
",unused,e2fsprogtrusty-misc2Fmklost+found.c
"			exit (1);
		}
	} while (st.st_size <= (EXT2_NDIR_BLOCKS - 1) * st.st_blksize);
	for (j = 0; j < i; j++) {
		sprintf (name + 246, ""%08d"", j);
",1,unused,77,unused,"			exit (1);
		}
	} while (st.st_size <= (EXT2_NDIR_BLOCKS - 1) * st.st_blksize);
	for (j = 0; j < i; j++) {
		sprintf (name + 246, ""%08d"", j);
",unused,e2fsprogtrusty-misc2Fmklost+found.c
"		}
	} while (st.st_size <= (EXT2_NDIR_BLOCKS - 1) * st.st_blksize);
	for (j = 0; j < i; j++) {
		sprintf (name + 246, ""%08d"", j);
		strcpy (path, LPF);
",1,unused,78,unused,"		}
	} while (st.st_size <= (EXT2_NDIR_BLOCKS - 1) * st.st_blksize);
	for (j = 0; j < i; j++) {
		sprintf (name + 246, ""%08d"", j);
		strcpy (path, LPF);
",unused,e2fsprogtrusty-misc2Fmklost+found.c
"	} while (st.st_size <= (EXT2_NDIR_BLOCKS - 1) * st.st_blksize);
	for (j = 0; j < i; j++) {
		sprintf (name + 246, ""%08d"", j);
		strcpy (path, LPF);
		strcat (path, ""/"");
",1,unused,79,unused,"	} while (st.st_size <= (EXT2_NDIR_BLOCKS - 1) * st.st_blksize);
	for (j = 0; j < i; j++) {
		sprintf (name + 246, ""%08d"", j);
		strcpy (path, LPF);
		strcat (path, ""/"");
",unused,e2fsprogtrusty-misc2Fmklost+found.c
"	for (j = 0; j < i; j++) {
		sprintf (name + 246, ""%08d"", j);
		strcpy (path, LPF);
		strcat (path, ""/"");
		strcat (path, name);
",1,unused,80,unused,"	for (j = 0; j < i; j++) {
		sprintf (name + 246, ""%08d"", j);
		strcpy (path, LPF);
		strcat (path, ""/"");
		strcat (path, name);
",unused,e2fsprogtrusty-misc2Fmklost+found.c
"		fprintf(stderr, ""%s"",
			_(""Couldn't allocate memory to parse options!\n""));
		return 1;
	}
	strcpy(buf, opts);
",1,unused,1163,unused,"		fprintf(stderr, ""%s"",
			_(""Couldn't allocate memory to parse options!\n""));
		return 1;
	}
	strcpy(buf, opts);
",unused,e2fsprogtrusty-misc2Ftune2fs.c
"
	tdb_file = malloc(strlen(tdb_dir) + 9 + strlen(dev_name) + 7 + 1);
	if (!tdb_file)
		goto alloc_fn_fail;
	sprintf(tdb_file, ""%s/tune2fs-%s.e2undo"", tdb_dir, dev_name);
",1,unused,1857,unused,"
	tdb_file = malloc(strlen(tdb_dir) + 9 + strlen(dev_name) + 7 + 1);
	if (!tdb_file)
		goto alloc_fn_fail;
	sprintf(tdb_file, ""%s/tune2fs-%s.e2undo"", tdb_dir, dev_name);
",unused,e2fsprogtrusty-misc2Ftune2fs.c
"	signal(SIGTERM, terminate_intr);
	signal(SIGALRM, terminate_intr);
	signal(SIGPIPE, SIG_IGN);

	sprintf(reply_buf, ""%8d\n"", getpid());
",1,unused,330,unused,"	signal(SIGTERM, terminate_intr);
	signal(SIGALRM, terminate_intr);
	signal(SIGPIPE, SIG_IGN);

	sprintf(reply_buf, ""%8d\n"", getpid());
",unused,e2fsprogtrusty-misc2Fuuidd.c
"			printf(""operation %d\n"", op);

		switch(op) {
		case UUIDD_OP_GETPID:
			sprintf(reply_buf, ""%d"", getpid());
",1,unused,368,unused,"			printf(""operation %d\n"", op);

		switch(op) {
		case UUIDD_OP_GETPID:
			sprintf(reply_buf, ""%d"", getpid());
",unused,e2fsprogtrusty-misc2Fuuidd.c
"			sprintf(reply_buf, ""%d"", getpid());
			reply_len = strlen(reply_buf)+1;
			break;
		case UUIDD_OP_GET_MAXOP:
			sprintf(reply_buf, ""%d"", UUIDD_MAX_OP);
",1,unused,372,unused,"			sprintf(reply_buf, ""%d"", getpid());
			reply_len = strlen(reply_buf)+1;
			break;
		case UUIDD_OP_GET_MAXOP:
			sprintf(reply_buf, ""%d"", UUIDD_MAX_OP);
",unused,e2fsprogtrusty-misc2Fuuidd.c
"	if (retval) {
		free(prog);
		return retval;
	}
	strcpy(prog->label, label);
",1,unused,96,unused,"	if (retval) {
		free(prog);
		return retval;
	}
	strcpy(prog->label, label);
",unused,e2fsprogtrusty-resize2Fsim_progress.c
"		goto fail;
	ent->value = (char *) malloc(strlen(value)+1);
	if (!ent->value)
		goto fail;
	strcpy(ent->name, name);
",1,unused,48,unused,"		goto fail;
	ent->value = (char *) malloc(strlen(value)+1);
	if (!ent->value)
		goto fail;
	strcpy(ent->name, name);
",unused,e2fsprogtrusty-util2Fsubst.c
"	ent->value = (char *) malloc(strlen(value)+1);
	if (!ent->value)
		goto fail;
	strcpy(ent->name, name);
	strcpy(ent->value, value);
",1,unused,49,unused,"	ent->value = (char *) malloc(strlen(value)+1);
	if (!ent->value)
		goto fail;
	strcpy(ent->name, name);
	strcpy(ent->value, value);
",unused,e2fsprogtrusty-util2Fsubst.c
"		if (!newfn) {
			fprintf(stderr, ""Memory error!  Exiting.\n"");
			exit(1);
		}
		strcpy(newfn, outfn);
",1,unused,352,unused,"		if (!newfn) {
			fprintf(stderr, ""Memory error!  Exiting.\n"");
			exit(1);
		}
		strcpy(newfn, outfn);
",unused,e2fsprogtrusty-util2Fsubst.c
"			fprintf(stderr, ""Memory error!  Exiting.\n"");
			exit(1);
		}
		strcpy(newfn, outfn);
		strcat(newfn, "".new"");
",1,unused,353,unused,"			fprintf(stderr, ""Memory error!  Exiting.\n"");
			exit(1);
		}
		strcpy(newfn, outfn);
		strcat(newfn, "".new"");
",unused,e2fsprogtrusty-util2Fsubst.c
"//parses the object type from csv
void parse_type(FILE *fh, Object *obj) {
  char *str = (char *) malloc(sizeof(sizeof(double)));
  char *character = malloc(sizeof(char));
  sprintf(character, ""%c"", fgetc(fh));
",1,unused,17,unused,"//parses the object type from csv
void parse_type(FILE *fh, Object *obj) {
  char *str = (char *) malloc(sizeof(sizeof(double)));
  char *character = malloc(sizeof(char));
  sprintf(character, ""%c"", fgetc(fh));
",unused,ffg-raycast.c
"  char *str = (char *) malloc(sizeof(sizeof(double)));
  char *character = malloc(sizeof(char));
  sprintf(character, ""%c"", fgetc(fh));
  while (*character != ',') {
    strcat(str, character);
",1,unused,19,unused,"  char *str = (char *) malloc(sizeof(sizeof(double)));
  char *character = malloc(sizeof(char));
  sprintf(character, ""%c"", fgetc(fh));
  while (*character != ',') {
    strcat(str, character);
",unused,ffg-raycast.c
"  char *character = malloc(sizeof(char));
  sprintf(character, ""%c"", fgetc(fh));
  while (*character != ',') {
    strcat(str, character);
    sprintf(character, ""%c"", fgetc(fh));
",1,unused,20,unused,"  char *character = malloc(sizeof(char));
  sprintf(character, ""%c"", fgetc(fh));
  while (*character != ',') {
    strcat(str, character);
    sprintf(character, ""%c"", fgetc(fh));
",unused,ffg-raycast.c
"  char *str = (char *) malloc(sizeof(char) * 9);
  char *character = malloc(sizeof(char));
  char *tmp = malloc(100);
  int check = 0;
  sprintf(character, ""%c"", fgetc(fh));
",1,unused,61,unused,"  char *str = (char *) malloc(sizeof(char) * 9);
  char *character = malloc(sizeof(char));
  char *tmp = malloc(100);
  int check = 0;
  sprintf(character, ""%c"", fgetc(fh));
",unused,ffg-raycast.c
"  char *tmp = malloc(100);
  int check = 0;
  sprintf(character, ""%c"", fgetc(fh));
  while (*character != 58) {
    strcat(str, character);
",1,unused,63,unused,"  char *tmp = malloc(100);
  int check = 0;
  sprintf(character, ""%c"", fgetc(fh));
  while (*character != 58) {
    strcat(str, character);
",unused,ffg-raycast.c
"  int check = 0;
  sprintf(character, ""%c"", fgetc(fh));
  while (*character != 58) {
    strcat(str, character);
    sprintf(character, ""%c"", fgetc(fh));
",1,unused,64,unused,"  int check = 0;
  sprintf(character, ""%c"", fgetc(fh));
  while (*character != 58) {
    strcat(str, character);
    sprintf(character, ""%c"", fgetc(fh));
",unused,ffg-raycast.c
"  char *str = (char *) malloc(sizeof(char) * 6);
  char *character = malloc(sizeof(char));
  char *tmp = malloc(100);
  int check = 0;
  sprintf(character, ""%c"", fgetc(fh));
",1,unused,103,unused,"  char *str = (char *) malloc(sizeof(char) * 6);
  char *character = malloc(sizeof(char));
  char *tmp = malloc(100);
  int check = 0;
  sprintf(character, ""%c"", fgetc(fh));
",unused,ffg-raycast.c
"  char *tmp = malloc(100);
  int check = 0;
  sprintf(character, ""%c"", fgetc(fh));
  while (*character != 58) {
    strcat(str, character);
",1,unused,105,unused,"  char *tmp = malloc(100);
  int check = 0;
  sprintf(character, ""%c"", fgetc(fh));
  while (*character != 58) {
    strcat(str, character);
",unused,ffg-raycast.c
"  int check = 0;
  sprintf(character, ""%c"", fgetc(fh));
  while (*character != 58) {
    strcat(str, character);
    sprintf(character, ""%c"", fgetc(fh));
",1,unused,106,unused,"  int check = 0;
  sprintf(character, ""%c"", fgetc(fh));
  while (*character != 58) {
    strcat(str, character);
    sprintf(character, ""%c"", fgetc(fh));
",unused,ffg-raycast.c
"  char *str = (char *) malloc(sizeof(char) * 8);
  char *character = malloc(sizeof(char));
  char *tmp = malloc(100);
  int check = 0;
  sprintf(character, ""%c"", fgetc(fh));
",1,unused,134,unused,"  char *str = (char *) malloc(sizeof(char) * 8);
  char *character = malloc(sizeof(char));
  char *tmp = malloc(100);
  int check = 0;
  sprintf(character, ""%c"", fgetc(fh));
",unused,ffg-raycast.c
"  char *tmp = malloc(100);
  int check = 0;
  sprintf(character, ""%c"", fgetc(fh));
  while (*character != 58) {
    strcat(str, character);
",1,unused,136,unused,"  char *tmp = malloc(100);
  int check = 0;
  sprintf(character, ""%c"", fgetc(fh));
  while (*character != 58) {
    strcat(str, character);
",unused,ffg-raycast.c
"  int check = 0;
  sprintf(character, ""%c"", fgetc(fh));
  while (*character != 58) {
    strcat(str, character);
    sprintf(character, ""%c"", fgetc(fh));
",1,unused,137,unused,"  int check = 0;
  sprintf(character, ""%c"", fgetc(fh));
  while (*character != 58) {
    strcat(str, character);
    sprintf(character, ""%c"", fgetc(fh));
",unused,ffg-raycast.c
"  char *character = malloc(sizeof(char));
  char *tmp = malloc(100);
  int check = 0;
  while (*character != 58) {
    sprintf(character, ""%c"", fgetc(fh));
",1,unused,181,unused,"  char *character = malloc(sizeof(char));
  char *tmp = malloc(100);
  int check = 0;
  while (*character != 58) {
    sprintf(character, ""%c"", fgetc(fh));
",unused,ffg-raycast.c
"  char *tmp = malloc(100);
  int check = 0;
  while (*character != 58) {
    sprintf(character, ""%c"", fgetc(fh));
    strcat(str, character);
",1,unused,182,unused,"  char *tmp = malloc(100);
  int check = 0;
  while (*character != 58) {
    sprintf(character, ""%c"", fgetc(fh));
    strcat(str, character);
",unused,ffg-raycast.c
"  char *str = malloc(sizeof(char) * 6);
  char *character = malloc(sizeof(char));
  char *tmp = malloc(100);
  int check = 0;
  sprintf(character, ""%c"", fgetc(fh));
",1,unused,338,unused,"  char *str = malloc(sizeof(char) * 6);
  char *character = malloc(sizeof(char));
  char *tmp = malloc(100);
  int check = 0;
  sprintf(character, ""%c"", fgetc(fh));
",unused,ffg-raycast.c
"  char *tmp = malloc(100);
  int check = 0;
  sprintf(character, ""%c"", fgetc(fh));
  while (*character != ':') {
    strcat(str, character);
",1,unused,340,unused,"  char *tmp = malloc(100);
  int check = 0;
  sprintf(character, ""%c"", fgetc(fh));
  while (*character != ':') {
    strcat(str, character);
",unused,ffg-raycast.c
"  int check = 0;
  sprintf(character, ""%c"", fgetc(fh));
  while (*character != ':') {
    strcat(str, character);
    sprintf(character, ""%c"", fgetc(fh));
",1,unused,341,unused,"  int check = 0;
  sprintf(character, ""%c"", fgetc(fh));
  while (*character != ':') {
    strcat(str, character);
    sprintf(character, ""%c"", fgetc(fh));
",unused,ffg-raycast.c
"  char *str = malloc(sizeof(char) * 10);
  char *character = malloc(sizeof(char));
  char *tmp = malloc(100);
  int check = 0;
  sprintf(character, ""%c"", fgetc(fh));
",1,unused,370,unused,"  char *str = malloc(sizeof(char) * 10);
  char *character = malloc(sizeof(char));
  char *tmp = malloc(100);
  int check = 0;
  sprintf(character, ""%c"", fgetc(fh));
",unused,ffg-raycast.c
"  char *tmp = malloc(100);
  int check = 0;
  sprintf(character, ""%c"", fgetc(fh));
  while (*character != ':') {
    strcat(str, character);
",1,unused,372,unused,"  char *tmp = malloc(100);
  int check = 0;
  sprintf(character, ""%c"", fgetc(fh));
  while (*character != ':') {
    strcat(str, character);
",unused,ffg-raycast.c
"  int check = 0;
  sprintf(character, ""%c"", fgetc(fh));
  while (*character != ':') {
    strcat(str, character);
    sprintf(character, ""%c"", fgetc(fh));
",1,unused,373,unused,"  int check = 0;
  sprintf(character, ""%c"", fgetc(fh));
  while (*character != ':') {
    strcat(str, character);
    sprintf(character, ""%c"", fgetc(fh));
",unused,ffg-raycast.c
"  char *str = (char *) malloc(sizeof(char) * 6);
  char *character = malloc(sizeof(char));
  int check = 0;
  char *tmp = malloc(100);
  sprintf(character, ""%c"", fgetc(fh));
",1,unused,416,unused,"  char *str = (char *) malloc(sizeof(char) * 6);
  char *character = malloc(sizeof(char));
  int check = 0;
  char *tmp = malloc(100);
  sprintf(character, ""%c"", fgetc(fh));
",unused,ffg-raycast.c
"  int check = 0;
  char *tmp = malloc(100);
  sprintf(character, ""%c"", fgetc(fh));
  while (*character != 58) {
    strcat(str, character);
",1,unused,418,unused,"  int check = 0;
  char *tmp = malloc(100);
  sprintf(character, ""%c"", fgetc(fh));
  while (*character != 58) {
    strcat(str, character);
",unused,ffg-raycast.c
"  char *tmp = malloc(100);
  sprintf(character, ""%c"", fgetc(fh));
  while (*character != 58) {
    strcat(str, character);
    sprintf(character, ""%c"", fgetc(fh));
",1,unused,419,unused,"  char *tmp = malloc(100);
  sprintf(character, ""%c"", fgetc(fh));
  while (*character != 58) {
    strcat(str, character);
    sprintf(character, ""%c"", fgetc(fh));
",unused,ffg-raycast.c
"  char *str = (char *) malloc(sizeof(char) * 6);
  char *character = malloc(sizeof(char));
  int check = 0;
  char *tmp = malloc(100);
  sprintf(character, ""%c"", fgetc(fh));
",1,unused,463,unused,"  char *str = (char *) malloc(sizeof(char) * 6);
  char *character = malloc(sizeof(char));
  int check = 0;
  char *tmp = malloc(100);
  sprintf(character, ""%c"", fgetc(fh));
",unused,ffg-raycast.c
"  int check = 0;
  char *tmp = malloc(100);
  sprintf(character, ""%c"", fgetc(fh));
  while (*character != 58) {
    strcat(str, character);
",1,unused,465,unused,"  int check = 0;
  char *tmp = malloc(100);
  sprintf(character, ""%c"", fgetc(fh));
  while (*character != 58) {
    strcat(str, character);
",unused,ffg-raycast.c
"  char *tmp = malloc(100);
  sprintf(character, ""%c"", fgetc(fh));
  while (*character != 58) {
    strcat(str, character);
    sprintf(character, ""%c"", fgetc(fh));
",1,unused,466,unused,"  char *tmp = malloc(100);
  sprintf(character, ""%c"", fgetc(fh));
  while (*character != 58) {
    strcat(str, character);
    sprintf(character, ""%c"", fgetc(fh));
",unused,ffg-raycast.c
"  char *str = (char *) malloc(sizeof(char) * 6);
  char *character = malloc(sizeof(char));
  int check = 0;
  char *tmp = malloc(100);
  sprintf(character, ""%c"", fgetc(fh));
",1,unused,509,unused,"  char *str = (char *) malloc(sizeof(char) * 6);
  char *character = malloc(sizeof(char));
  int check = 0;
  char *tmp = malloc(100);
  sprintf(character, ""%c"", fgetc(fh));
",unused,ffg-raycast.c
"  int check = 0;
  char *tmp = malloc(100);
  sprintf(character, ""%c"", fgetc(fh));
  while (*character != 58) {
    strcat(str, character);
",1,unused,511,unused,"  int check = 0;
  char *tmp = malloc(100);
  sprintf(character, ""%c"", fgetc(fh));
  while (*character != 58) {
    strcat(str, character);
",unused,ffg-raycast.c
"  char *tmp = malloc(100);
  sprintf(character, ""%c"", fgetc(fh));
  while (*character != 58) {
    strcat(str, character);
    sprintf(character, ""%c"", fgetc(fh));
",1,unused,512,unused,"  char *tmp = malloc(100);
  sprintf(character, ""%c"", fgetc(fh));
  while (*character != 58) {
    strcat(str, character);
    sprintf(character, ""%c"", fgetc(fh));
",unused,ffg-raycast.c
"  char *str = (char *) malloc(sizeof(char) * 12);
  char *character = malloc(sizeof(char));
  int check = 0;
  char *tmp = malloc(100);
  sprintf(character, ""%c"", fgetc(fh));
",1,unused,535,unused,"  char *str = (char *) malloc(sizeof(char) * 12);
  char *character = malloc(sizeof(char));
  int check = 0;
  char *tmp = malloc(100);
  sprintf(character, ""%c"", fgetc(fh));
",unused,ffg-raycast.c
"  int check = 0;
  char *tmp = malloc(100);
  sprintf(character, ""%c"", fgetc(fh));
  while (*character != 58) {
    strcat(str, character);
",1,unused,537,unused,"  int check = 0;
  char *tmp = malloc(100);
  sprintf(character, ""%c"", fgetc(fh));
  while (*character != 58) {
    strcat(str, character);
",unused,ffg-raycast.c
"  char *tmp = malloc(100);
  sprintf(character, ""%c"", fgetc(fh));
  while (*character != 58) {
    strcat(str, character);
    sprintf(character, ""%c"", fgetc(fh));
",1,unused,538,unused,"  char *tmp = malloc(100);
  sprintf(character, ""%c"", fgetc(fh));
  while (*character != 58) {
    strcat(str, character);
    sprintf(character, ""%c"", fgetc(fh));
",unused,ffg-raycast.c
"  char *str = (char *) malloc(sizeof(char) * 12);
  char *character = malloc(sizeof(char));
  int check = 0;
  char *tmp = malloc(100);
  sprintf(character, ""%c"", fgetc(fh));
",1,unused,563,unused,"  char *str = (char *) malloc(sizeof(char) * 12);
  char *character = malloc(sizeof(char));
  int check = 0;
  char *tmp = malloc(100);
  sprintf(character, ""%c"", fgetc(fh));
",unused,ffg-raycast.c
"  int check = 0;
  char *tmp = malloc(100);
  sprintf(character, ""%c"", fgetc(fh));
  while (*character != 58) {
    strcat(str, character);
",1,unused,565,unused,"  int check = 0;
  char *tmp = malloc(100);
  sprintf(character, ""%c"", fgetc(fh));
  while (*character != 58) {
    strcat(str, character);
",unused,ffg-raycast.c
"  char *tmp = malloc(100);
  sprintf(character, ""%c"", fgetc(fh));
  while (*character != 58) {
    strcat(str, character);
    sprintf(character, ""%c"", fgetc(fh));
",1,unused,566,unused,"  char *tmp = malloc(100);
  sprintf(character, ""%c"", fgetc(fh));
  while (*character != 58) {
    strcat(str, character);
    sprintf(character, ""%c"", fgetc(fh));
",unused,ffg-raycast.c
"  char *str = (char *) malloc(sizeof(char) * 3);
  char *character = malloc(sizeof(char));
  int check = 0;
  char *tmp = malloc(100);
  sprintf(character, ""%c"", fgetc(fh));
",1,unused,591,unused,"  char *str = (char *) malloc(sizeof(char) * 3);
  char *character = malloc(sizeof(char));
  int check = 0;
  char *tmp = malloc(100);
  sprintf(character, ""%c"", fgetc(fh));
",unused,ffg-raycast.c
"  int check = 0;
  char *tmp = malloc(100);
  sprintf(character, ""%c"", fgetc(fh));
  while (*character != 58) {
    strcat(str, character);
",1,unused,593,unused,"  int check = 0;
  char *tmp = malloc(100);
  sprintf(character, ""%c"", fgetc(fh));
  while (*character != 58) {
    strcat(str, character);
",unused,ffg-raycast.c
"  char *tmp = malloc(100);
  sprintf(character, ""%c"", fgetc(fh));
  while (*character != 58) {
    strcat(str, character);
    sprintf(character, ""%c"", fgetc(fh));
",1,unused,594,unused,"  char *tmp = malloc(100);
  sprintf(character, ""%c"", fgetc(fh));
  while (*character != 58) {
    strcat(str, character);
    sprintf(character, ""%c"", fgetc(fh));
",unused,ffg-raycast.c
"      parse_field(fh, new_obj);
      skip_non_alphanum(fh);
    } else if (strcmp(new_obj->kind, ""SPHERE"") == 0) {
      while (strcmp(str, ""light"") != 0 && strcmp(str, ""plane"") != 0 && strcmp(str, ""camera"") != 0 && *character != EOF) {
        sprintf(character, ""%c"", fgetc(fh));
",1,unused,628,unused,"      parse_field(fh, new_obj);
      skip_non_alphanum(fh);
    } else if (strcmp(new_obj->kind, ""SPHERE"") == 0) {
      while (strcmp(str, ""light"") != 0 && strcmp(str, ""plane"") != 0 && strcmp(str, ""camera"") != 0 && *character != EOF) {
        sprintf(character, ""%c"", fgetc(fh));
",unused,ffg-raycast.c
"      skip_non_alphanum(fh);
    } else if (strcmp(new_obj->kind, ""SPHERE"") == 0) {
      while (strcmp(str, ""light"") != 0 && strcmp(str, ""plane"") != 0 && strcmp(str, ""camera"") != 0 && *character != EOF) {
        sprintf(character, ""%c"", fgetc(fh));
        strcat(str, character);
",1,unused,629,unused,"      skip_non_alphanum(fh);
    } else if (strcmp(new_obj->kind, ""SPHERE"") == 0) {
      while (strcmp(str, ""light"") != 0 && strcmp(str, ""plane"") != 0 && strcmp(str, ""camera"") != 0 && *character != EOF) {
        sprintf(character, ""%c"", fgetc(fh));
        strcat(str, character);
",unused,ffg-raycast.c
"        sprintf(character, ""%c"", fgetc(fh));
        strcat(str, character);
        if (strcmp(str, ""radius"") == 0) {
          rewind_file(fh, str);
          strcpy(str, """");
",1,unused,632,unused,"        sprintf(character, ""%c"", fgetc(fh));
        strcat(str, character);
        if (strcmp(str, ""radius"") == 0) {
          rewind_file(fh, str);
          strcpy(str, """");
",unused,ffg-raycast.c
"          strcpy(str, """");
          parse_radius(fh, new_obj);
        } else if (strcmp(str, ""color"") == 0) {
          rewind_file(fh, str);
          strcpy(str, """");
",1,unused,636,unused,"          strcpy(str, """");
          parse_radius(fh, new_obj);
        } else if (strcmp(str, ""color"") == 0) {
          rewind_file(fh, str);
          strcpy(str, """");
",unused,ffg-raycast.c
"          strcpy(str, """");
          parse_color(fh, new_obj);
        } else if (strcmp(str, ""diffuse_color"") == 0) {
          rewind_file(fh, str);
          strcpy(str, """");
",1,unused,640,unused,"          strcpy(str, """");
          parse_color(fh, new_obj);
        } else if (strcmp(str, ""diffuse_color"") == 0) {
          rewind_file(fh, str);
          strcpy(str, """");
",unused,ffg-raycast.c
"          strcpy(str, """");
          parse_color(fh, new_obj);
        } else if (strcmp(str, ""specular_color"") == 0) {
          rewind_file(fh, str);
          strcpy(str, """");
",1,unused,644,unused,"          strcpy(str, """");
          parse_color(fh, new_obj);
        } else if (strcmp(str, ""specular_color"") == 0) {
          rewind_file(fh, str);
          strcpy(str, """");
",unused,ffg-raycast.c
"          strcpy(str, """");
          parse_color(fh, new_obj);
        } else if (strcmp(str, ""position"") == 0) {
          rewind_file(fh, str);
          strcpy(str, """");
",1,unused,648,unused,"          strcpy(str, """");
          parse_color(fh, new_obj);
        } else if (strcmp(str, ""position"") == 0) {
          rewind_file(fh, str);
          strcpy(str, """");
",unused,ffg-raycast.c
"          strcpy(str, """");
          parse_position(fh, new_obj);
        } else if (strcmp(str, ""reflectivity"") == 0) {
          rewind_file(fh, str);
          strcpy(str, """");
",1,unused,652,unused,"          strcpy(str, """");
          parse_position(fh, new_obj);
        } else if (strcmp(str, ""reflectivity"") == 0) {
          rewind_file(fh, str);
          strcpy(str, """");
",unused,ffg-raycast.c
"          strcpy(str, """");
          parse_reflect(fh, new_obj);
        } else if (strcmp(str, ""refractivity"") == 0) {
          rewind_file(fh, str);
          strcpy(str, """");
",1,unused,656,unused,"          strcpy(str, """");
          parse_reflect(fh, new_obj);
        } else if (strcmp(str, ""refractivity"") == 0) {
          rewind_file(fh, str);
          strcpy(str, """");
",unused,ffg-raycast.c
"          strcpy(str, """");
          parse_refract(fh, new_obj);
        } else if (strcmp(str, ""ior"") == 0) {
          rewind_file(fh, str);
          strcpy(str, """");
",1,unused,660,unused,"          strcpy(str, """");
          parse_refract(fh, new_obj);
        } else if (strcmp(str, ""ior"") == 0) {
          rewind_file(fh, str);
          strcpy(str, """");
",unused,ffg-raycast.c
"        }
      }
      if (*character != EOF && strcmp(new_obj->kind, ""SPHERE"") == 0) {
        rewind_file(fh, str);
        strcpy(str, """");
",1,unused,666,unused,"        }
      }
      if (*character != EOF && strcmp(new_obj->kind, ""SPHERE"") == 0) {
        rewind_file(fh, str);
        strcpy(str, """");
",unused,ffg-raycast.c
"        strcpy(str, """");
      }
    } else if (strcmp(new_obj->kind, ""PLANE"") == 0) {
      while (strcmp(str, ""light"") != 0 && strcmp(str, ""sphere"") != 0 && strcmp(str, ""camera"") != 0 && *character != EOF) {
        sprintf(character, ""%c"", fgetc(fh));
",1,unused,670,unused,"        strcpy(str, """");
      }
    } else if (strcmp(new_obj->kind, ""PLANE"") == 0) {
      while (strcmp(str, ""light"") != 0 && strcmp(str, ""sphere"") != 0 && strcmp(str, ""camera"") != 0 && *character != EOF) {
        sprintf(character, ""%c"", fgetc(fh));
",unused,ffg-raycast.c
"      }
    } else if (strcmp(new_obj->kind, ""PLANE"") == 0) {
      while (strcmp(str, ""light"") != 0 && strcmp(str, ""sphere"") != 0 && strcmp(str, ""camera"") != 0 && *character != EOF) {
        sprintf(character, ""%c"", fgetc(fh));
        strcat(str, character);
",1,unused,671,unused,"      }
    } else if (strcmp(new_obj->kind, ""PLANE"") == 0) {
      while (strcmp(str, ""light"") != 0 && strcmp(str, ""sphere"") != 0 && strcmp(str, ""camera"") != 0 && *character != EOF) {
        sprintf(character, ""%c"", fgetc(fh));
        strcat(str, character);
",unused,ffg-raycast.c
"        sprintf(character, ""%c"", fgetc(fh));
        strcat(str, character);
        if (strcmp(str, ""normal"") == 0) {
          rewind_file(fh, str);
          strcpy(str, """");
",1,unused,674,unused,"        sprintf(character, ""%c"", fgetc(fh));
        strcat(str, character);
        if (strcmp(str, ""normal"") == 0) {
          rewind_file(fh, str);
          strcpy(str, """");
",unused,ffg-raycast.c
"          strcpy(str, """");
          parse_normal(fh, new_obj);
        } else if (strcmp(str, ""color"") == 0) {
          rewind_file(fh, str);
          strcpy(str, """");
",1,unused,678,unused,"          strcpy(str, """");
          parse_normal(fh, new_obj);
        } else if (strcmp(str, ""color"") == 0) {
          rewind_file(fh, str);
          strcpy(str, """");
",unused,ffg-raycast.c
"          strcpy(str, """");
          parse_color(fh, new_obj);
        } else if (strcmp(str, ""diffuse_color"") == 0) {
          rewind_file(fh, str);
          strcpy(str, """");
",1,unused,682,unused,"          strcpy(str, """");
          parse_color(fh, new_obj);
        } else if (strcmp(str, ""diffuse_color"") == 0) {
          rewind_file(fh, str);
          strcpy(str, """");
",unused,ffg-raycast.c
"          strcpy(str, """");
          parse_color(fh, new_obj);
        } else if (strcmp(str, ""specular_color"") == 0) {
          rewind_file(fh, str);
          strcpy(str, """");
",1,unused,686,unused,"          strcpy(str, """");
          parse_color(fh, new_obj);
        } else if (strcmp(str, ""specular_color"") == 0) {
          rewind_file(fh, str);
          strcpy(str, """");
",unused,ffg-raycast.c
"          strcpy(str, """");
          parse_color(fh, new_obj);
        } else if (strcmp(str, ""position"") == 0) {
          rewind_file(fh, str);
          strcpy(str, """");
",1,unused,690,unused,"          strcpy(str, """");
          parse_color(fh, new_obj);
        } else if (strcmp(str, ""position"") == 0) {
          rewind_file(fh, str);
          strcpy(str, """");
",unused,ffg-raycast.c
"          strcpy(str, """");
          parse_position(fh, new_obj);
        } else if (strcmp(str, ""reflectivity"") == 0) {
          rewind_file(fh, str);
          strcpy(str, """");
",1,unused,694,unused,"          strcpy(str, """");
          parse_position(fh, new_obj);
        } else if (strcmp(str, ""reflectivity"") == 0) {
          rewind_file(fh, str);
          strcpy(str, """");
",unused,ffg-raycast.c
"          strcpy(str, """");
          parse_reflect(fh, new_obj);
        } else if (strcmp(str, ""refractivity"") == 0) {
          rewind_file(fh, str);
          strcpy(str, """");
",1,unused,698,unused,"          strcpy(str, """");
          parse_reflect(fh, new_obj);
        } else if (strcmp(str, ""refractivity"") == 0) {
          rewind_file(fh, str);
          strcpy(str, """");
",unused,ffg-raycast.c
"          strcpy(str, """");
          parse_refract(fh, new_obj);
        } else if (strcmp(str, ""ior"") == 0) {
          rewind_file(fh, str);
          strcpy(str, """");
",1,unused,702,unused,"          strcpy(str, """");
          parse_refract(fh, new_obj);
        } else if (strcmp(str, ""ior"") == 0) {
          rewind_file(fh, str);
          strcpy(str, """");
",unused,ffg-raycast.c
"        }
      }
      if (*character != EOF && strcmp(new_obj->kind, ""PLANE"") == 0) {
        rewind_file(fh, str);
        strcpy(str, """");
",1,unused,708,unused,"        }
      }
      if (*character != EOF && strcmp(new_obj->kind, ""PLANE"") == 0) {
        rewind_file(fh, str);
        strcpy(str, """");
",unused,ffg-raycast.c
"      }
    } else if (strcmp(new_obj->kind, ""LIGHT"") == 0) {
      Light *new_light = malloc(sizeof(Light));
      while (strcmp(str, ""camera"") != 0 && strcmp(str, ""plane"") != 0 && strcmp(str, ""sphere"") != 0 && *character != EOF) {
        sprintf(character, ""%c"", fgetc(fh));
",1,unused,713,unused,"      }
    } else if (strcmp(new_obj->kind, ""LIGHT"") == 0) {
      Light *new_light = malloc(sizeof(Light));
      while (strcmp(str, ""camera"") != 0 && strcmp(str, ""plane"") != 0 && strcmp(str, ""sphere"") != 0 && *character != EOF) {
        sprintf(character, ""%c"", fgetc(fh));
",unused,ffg-raycast.c
"    } else if (strcmp(new_obj->kind, ""LIGHT"") == 0) {
      Light *new_light = malloc(sizeof(Light));
      while (strcmp(str, ""camera"") != 0 && strcmp(str, ""plane"") != 0 && strcmp(str, ""sphere"") != 0 && *character != EOF) {
        sprintf(character, ""%c"", fgetc(fh));
        strcat(str, character);
",1,unused,714,unused,"    } else if (strcmp(new_obj->kind, ""LIGHT"") == 0) {
      Light *new_light = malloc(sizeof(Light));
      while (strcmp(str, ""camera"") != 0 && strcmp(str, ""plane"") != 0 && strcmp(str, ""sphere"") != 0 && *character != EOF) {
        sprintf(character, ""%c"", fgetc(fh));
        strcat(str, character);
",unused,ffg-raycast.c
"        sprintf(character, ""%c"", fgetc(fh));
        strcat(str, character);
        if (strcmp(str, ""theta"") == 0) {
          rewind_file(fh, str);
          strcpy(str, """");
",1,unused,717,unused,"        sprintf(character, ""%c"", fgetc(fh));
        strcat(str, character);
        if (strcmp(str, ""theta"") == 0) {
          rewind_file(fh, str);
          strcpy(str, """");
",unused,ffg-raycast.c
"          strcpy(str, """");
          parse_theta(fh, new_obj);;
        } else if (strcmp(str, ""color"") == 0) {
          rewind_file(fh, str);
          strcpy(str, """");
",1,unused,721,unused,"          strcpy(str, """");
          parse_theta(fh, new_obj);;
        } else if (strcmp(str, ""color"") == 0) {
          rewind_file(fh, str);
          strcpy(str, """");
",unused,ffg-raycast.c
"          strcpy(str, """");
          parse_color(fh, new_obj);
        } else if (strcmp(str, ""radial-a2"") == 0) {
          rewind_file(fh, str);
          strcpy(str, """");
",1,unused,725,unused,"          strcpy(str, """");
          parse_color(fh, new_obj);
        } else if (strcmp(str, ""radial-a2"") == 0) {
          rewind_file(fh, str);
          strcpy(str, """");
",unused,ffg-raycast.c
"          strcpy(str, """");
          parse_radial(fh, new_obj);
        } else if (strcmp(str, ""radial-a1"") == 0) {
          rewind_file(fh, str);
          strcpy(str, """");
",1,unused,729,unused,"          strcpy(str, """");
          parse_radial(fh, new_obj);
        } else if (strcmp(str, ""radial-a1"") == 0) {
          rewind_file(fh, str);
          strcpy(str, """");
",unused,ffg-raycast.c
"          strcpy(str, """");
          parse_radial(fh, new_obj);
        } else if (strcmp(str, ""radial-a0"") == 0) {
          rewind_file(fh, str);
          strcpy(str, """");
",1,unused,733,unused,"          strcpy(str, """");
          parse_radial(fh, new_obj);
        } else if (strcmp(str, ""radial-a0"") == 0) {
          rewind_file(fh, str);
          strcpy(str, """");
",unused,ffg-raycast.c
"          strcpy(str, """");
          parse_radial(fh, new_obj);
        } else if (strcmp(str, ""position"") == 0) {
          rewind_file(fh, str);
          strcpy(str, """");
",1,unused,737,unused,"          strcpy(str, """");
          parse_radial(fh, new_obj);
        } else if (strcmp(str, ""position"") == 0) {
          rewind_file(fh, str);
          strcpy(str, """");
",unused,ffg-raycast.c
"          strcpy(str, """");
          parse_position(fh, new_obj);
        } else if (strcmp(str, ""direction"") == 0) {
          rewind_file(fh, str);
          strcpy(str, """");
",1,unused,741,unused,"          strcpy(str, """");
          parse_position(fh, new_obj);
        } else if (strcmp(str, ""direction"") == 0) {
          rewind_file(fh, str);
          strcpy(str, """");
",unused,ffg-raycast.c
"          strcpy(str, """");
          parse_direction(fh, new_obj);
        } else if (strcmp(str, ""angular-a0"") == 0) {
          rewind_file(fh, str);
          strcpy(str, """");
",1,unused,745,unused,"          strcpy(str, """");
          parse_direction(fh, new_obj);
        } else if (strcmp(str, ""angular-a0"") == 0) {
          rewind_file(fh, str);
          strcpy(str, """");
",unused,ffg-raycast.c
"        }
      }
      if (*character != EOF && strcmp(new_obj->kind, ""LIGHT"") == 0) {
        rewind_file(fh, str);
        strcpy(str, """");
",1,unused,751,unused,"        }
      }
      if (*character != EOF && strcmp(new_obj->kind, ""LIGHT"") == 0) {
        rewind_file(fh, str);
        strcpy(str, """");
",unused,ffg-raycast.c
"        rewind_file(fh, str);
        strcpy(str, """");
      } else if (*character == EOF) {
        rewind_file(fh, character);
        strcpy(str, """");
",1,unused,754,unused,"        rewind_file(fh, str);
        strcpy(str, """");
      } else if (*character == EOF) {
        rewind_file(fh, character);
        strcpy(str, """");
",unused,ffg-raycast.c
"  Scene *scene = malloc(sizeof(Scene));
  Light *light = malloc(sizeof(Scene));
  Object *result_object = malloc(sizeof(Object));
  input_file = fopen(argv[3], ""r"");
  sprintf(character, ""%c"", fgetc(input_file));
",1,unused,1303,unused,"  Scene *scene = malloc(sizeof(Scene));
  Light *light = malloc(sizeof(Scene));
  Object *result_object = malloc(sizeof(Object));
  input_file = fopen(argv[3], ""r"");
  sprintf(character, ""%c"", fgetc(input_file));
",unused,ffg-raycast.c
"    if (!slash)
        slash = pathname;
    else
        slash++;
    strcpy(slash, ""ffmpeg"");
",1,unused,506,unused,"    if (!slash)
        slash = pathname;
    else
        slash++;
    strcpy(slash, ""ffmpeg"");
",unused,ffmpeg-3.1.3-ffserver.c
"        /* if this isn't WMP or lookalike, return the redirector file */
        redir_type = REDIR_ASF;
    } else if (av_match_ext(filename, ""rpm,ram"")) {
        redir_type = REDIR_RAM;
        strcpy(filename + strlen(filename)-2, ""m"");
",1,unused,1494,unused,"        /* if this isn't WMP or lookalike, return the redirector file */
        redir_type = REDIR_ASF;
    } else if (av_match_ext(filename, ""rpm,ram"")) {
        redir_type = REDIR_RAM;
        strcpy(filename + strlen(filename)-2, ""m"");
",unused,ffmpeg-3.1.3-ffserver.c
"        av_strlcpy(sfilename, stream->filename, sizeof(sfilename) - 10);
        eosf = sfilename + strlen(sfilename);
        if (eosf - sfilename >= 4) {
            if (strcmp(eosf - 4, "".asf"") == 0)
                strcpy(eosf - 4, "".asx"");
",1,unused,1962,unused,"        av_strlcpy(sfilename, stream->filename, sizeof(sfilename) - 10);
        eosf = sfilename + strlen(sfilename);
        if (eosf - sfilename >= 4) {
            if (strcmp(eosf - 4, "".asf"") == 0)
                strcpy(eosf - 4, "".asx"");
",unused,ffmpeg-3.1.3-ffserver.c
"        if (eosf - sfilename >= 4) {
            if (strcmp(eosf - 4, "".asf"") == 0)
                strcpy(eosf - 4, "".asx"");
            else if (strcmp(eosf - 3, "".rm"") == 0)
                strcpy(eosf - 3, "".ram"");
",1,unused,1964,unused,"        if (eosf - sfilename >= 4) {
            if (strcmp(eosf - 4, "".asf"") == 0)
                strcpy(eosf - 4, "".asx"");
            else if (strcmp(eosf - 3, "".rm"") == 0)
                strcpy(eosf - 3, "".ram"");
",unused,ffmpeg-3.1.3-ffserver.c
"                eosf = strrchr(sfilename, '.');
                if (!eosf)
                    eosf = sfilename + strlen(sfilename);
                if (stream->is_multicast)
                    strcpy(eosf, "".sdp"");
",1,unused,1973,unused,"                eosf = strrchr(sfilename, '.');
                if (!eosf)
                    eosf = sfilename + strlen(sfilename);
                if (stream->is_multicast)
                    strcpy(eosf, "".sdp"");
",unused,ffmpeg-3.1.3-ffserver.c
"                    eosf = sfilename + strlen(sfilename);
                if (stream->is_multicast)
                    strcpy(eosf, "".sdp"");
                else
                    strcpy(eosf, "".rtsp"");
",1,unused,1975,unused,"                    eosf = sfilename + strlen(sfilename);
                if (stream->is_multicast)
                    strcpy(eosf, "".sdp"");
                else
                    strcpy(eosf, "".rtsp"");
",unused,ffmpeg-3.1.3-ffserver.c
"    int64_t stream_pos;

    /* find file name */
    if (c->stream->feed) {
        strcpy(input_filename, c->stream->feed->feed_filename);
",1,unused,2157,unused,"    int64_t stream_pos;

    /* find file name */
    if (c->stream->feed) {
        strcpy(input_filename, c->stream->feed->feed_filename);
",unused,ffmpeg-3.1.3-ffserver.c
"            stream_pos = av_gettime() - prebuffer * (int64_t)1000000;
        } else
            stream_pos = av_gettime() - c->stream->prebuffer * (int64_t)1000;
    } else {
        strcpy(input_filename, c->stream->feed_filename);
",1,unused,2171,unused,"            stream_pos = av_gettime() - prebuffer * (int64_t)1000000;
        } else
            stream_pos = av_gettime() - c->stream->prebuffer * (int64_t)1000;
    } else {
        strcpy(input_filename, c->stream->feed_filename);
",unused,ffmpeg-3.1.3-ffserver.c
"        } else {
            stream->stream_type = STREAM_TYPE_LIVE;
            /* JPEG cannot be used here, so use single frame MJPEG */
            if (!strcmp(arg, ""jpeg"")) {
                strcpy(arg, ""singlejpeg"");
",1,unused,869,unused,"        } else {
            stream->stream_type = STREAM_TYPE_LIVE;
            /* JPEG cannot be used here, so use single frame MJPEG */
            if (!strcmp(arg, ""jpeg"")) {
                strcpy(arg, ""singlejpeg"");
",unused,ffmpeg-3.1.3-ffserver_config.c
"    int len, tag_close, sptr = 1, line_start = 1, an = 0, end = 0;
    SrtStack stack[16];

    stack[0].tag[0] = 0;
    strcpy(stack[0].param[PARAM_SIZE],  ""{\\fs}"");
",1,unused,60,unused,"    int len, tag_close, sptr = 1, line_start = 1, an = 0, end = 0;
    SrtStack stack[16];

    stack[0].tag[0] = 0;
    strcpy(stack[0].param[PARAM_SIZE],  ""{\\fs}"");
",unused,ffmpeg-3.1.3-libavcodec2Fhtmlsubtitles.c
"    SrtStack stack[16];

    stack[0].tag[0] = 0;
    strcpy(stack[0].param[PARAM_SIZE],  ""{\\fs}"");
    strcpy(stack[0].param[PARAM_COLOR], ""{\\c}"");
",1,unused,61,unused,"    SrtStack stack[16];

    stack[0].tag[0] = 0;
    strcpy(stack[0].param[PARAM_SIZE],  ""{\\fs}"");
    strcpy(stack[0].param[PARAM_COLOR], ""{\\c}"");
",unused,ffmpeg-3.1.3-libavcodec2Fhtmlsubtitles.c
"
    stack[0].tag[0] = 0;
    strcpy(stack[0].param[PARAM_SIZE],  ""{\\fs}"");
    strcpy(stack[0].param[PARAM_COLOR], ""{\\c}"");
    strcpy(stack[0].param[PARAM_FACE],  ""{\\fn}"");
",1,unused,62,unused,"
    stack[0].tag[0] = 0;
    strcpy(stack[0].param[PARAM_SIZE],  ""{\\fs}"");
    strcpy(stack[0].param[PARAM_COLOR], ""{\\c}"");
    strcpy(stack[0].param[PARAM_FACE],  ""{\\fn}"");
",unused,ffmpeg-3.1.3-libavcodec2Fhtmlsubtitles.c
"        goto fail;
    }
    uc->av_class = &ffurl_context_class;
    uc->filename = (char *)&uc[1];
    strcpy(uc->filename, filename);
",1,unused,101,unused,"        goto fail;
    }
    uc->av_class = &ffurl_context_class;
    uc->filename = (char *)&uc[1];
    strcpy(uc->filename, filename);
",unused,ffmpeg-3.1.3-libavformat2Favio.c
"
    if (filename[proto_len] != ':' &&
        (strncmp(filename, ""subfile,"", 8) || !strchr(filename + proto_len + 1, ':')) ||
        is_dos_path(filename))
        strcpy(proto_str, ""file"");
",1,unused,261,unused,"
    if (filename[proto_len] != ':' &&
        (strncmp(filename, ""subfile,"", 8) || !strchr(filename + proto_len + 1, ':')) ||
        is_dos_path(filename))
        strcpy(proto_str, ""file"");
",unused,ffmpeg-3.1.3-libavformat2Favio.c
"        return NULL;

    if (info) {
        var->bandwidth = atoi(info->bandwidth);
        strcpy(var->audio_group, info->audio);
",1,unused,342,unused,"        return NULL;

    if (info) {
        var->bandwidth = atoi(info->bandwidth);
        strcpy(var->audio_group, info->audio);
",unused,ffmpeg-3.1.3-libavformat2Fhls.c
"
    if (info) {
        var->bandwidth = atoi(info->bandwidth);
        strcpy(var->audio_group, info->audio);
        strcpy(var->video_group, info->video);
",1,unused,343,unused,"
    if (info) {
        var->bandwidth = atoi(info->bandwidth);
        strcpy(var->audio_group, info->audio);
        strcpy(var->video_group, info->video);
",unused,ffmpeg-3.1.3-libavformat2Fhls.c
"    if (info) {
        var->bandwidth = atoi(info->bandwidth);
        strcpy(var->audio_group, info->audio);
        strcpy(var->video_group, info->video);
        strcpy(var->subtitles_group, info->subtitles);
",1,unused,344,unused,"    if (info) {
        var->bandwidth = atoi(info->bandwidth);
        strcpy(var->audio_group, info->audio);
        strcpy(var->video_group, info->video);
        strcpy(var->subtitles_group, info->subtitles);
",unused,ffmpeg-3.1.3-libavformat2Fhls.c
"
    dynarray_add(&c->renditions, &c->n_renditions, rend);

    rend->type = type;
    strcpy(rend->group_id, info->group_id);
",1,unused,496,unused,"
    dynarray_add(&c->renditions, &c->n_renditions, rend);

    rend->type = type;
    strcpy(rend->group_id, info->group_id);
",unused,ffmpeg-3.1.3-libavformat2Fhls.c
"    dynarray_add(&c->renditions, &c->n_renditions, rend);

    rend->type = type;
    strcpy(rend->group_id, info->group_id);
    strcpy(rend->language, info->language);
",1,unused,497,unused,"    dynarray_add(&c->renditions, &c->n_renditions, rend);

    rend->type = type;
    strcpy(rend->group_id, info->group_id);
    strcpy(rend->language, info->language);
",unused,ffmpeg-3.1.3-libavformat2Fhls.c
"
    rend->type = type;
    strcpy(rend->group_id, info->group_id);
    strcpy(rend->language, info->language);
    strcpy(rend->name, info->name);
",1,unused,498,unused,"
    rend->type = type;
    strcpy(rend->group_id, info->group_id);
    strcpy(rend->language, info->language);
    strcpy(rend->name, info->name);
",unused,ffmpeg-3.1.3-libavformat2Fhls.c
"        if (p)
            *p = '\0';

        if( hls->subtitle_filename ) {
            strcpy(hls->vtt_m3u8_name, hls->subtitle_filename);
",1,unused,741,unused,"        if (p)
            *p = '\0';

        if( hls->subtitle_filename ) {
            strcpy(hls->vtt_m3u8_name, hls->subtitle_filename);
",unused,ffmpeg-3.1.3-libavformat2Fhlsenc.c
"
        if( hls->subtitle_filename ) {
            strcpy(hls->vtt_m3u8_name, hls->subtitle_filename);
        } else {
            strcpy(hls->vtt_m3u8_name, hls->vtt_basename);
",1,unused,743,unused,"
        if( hls->subtitle_filename ) {
            strcpy(hls->vtt_m3u8_name, hls->subtitle_filename);
        } else {
            strcpy(hls->vtt_m3u8_name, hls->vtt_basename);
",unused,ffmpeg-3.1.3-libavformat2Fhlsenc.c
"    // store cue point timestamps as a comma separated list for checking subsegment alignment in
    // the muxer. assumes that each timestamp cannot be more than 20 characters long.
    buf = av_malloc_array(s->streams[0]->nb_index_entries, 20 * sizeof(char));
    if (!buf) return -1;
    strcpy(buf, """");
",1,unused,3729,unused,"    // store cue point timestamps as a comma separated list for checking subsegment alignment in
    // the muxer. assumes that each timestamp cannot be more than 20 characters long.
    buf = av_malloc_array(s->streams[0]->nb_index_entries, 20 * sizeof(char));
    if (!buf) return -1;
    strcpy(buf, """");
",unused,ffmpeg-3.1.3-libavformat2Fmatroskadec.c
"        if (!strncmp(line, ""id:"", 3)) {
            if (sscanf(line, ""id: %63[^,], index: %u"", id, &stream_id) != 2) {
                av_log(s, AV_LOG_WARNING, ""Unable to parse index line '%s', ""
                       ""assuming 'id: und, index: 0'\n"", line);
                strcpy(id, ""und"");
",1,unused,758,unused,"        if (!strncmp(line, ""id:"", 3)) {
            if (sscanf(line, ""id: %63[^,], index: %u"", id, &stream_id) != 2) {
                av_log(s, AV_LOG_WARNING, ""Unable to parse index line '%s', ""
                       ""assuming 'id: und, index: 0'\n"", line);
                strcpy(id, ""und"");
",unused,ffmpeg-3.1.3-libavformat2Fmpeg.c
"    av_md5_sum(zres, buf, 64);
    ff_data_to_hex(response, zres, 16, 1);

    /* add tail */
    strcpy (response + 32, ""01d0a8e3"");
",1,unused,123,unused,"    av_md5_sum(zres, buf, 64);
    ff_data_to_hex(response, zres, 16, 1);

    /* add tail */
    strcpy (response + 32, ""01d0a8e3"");
",unused,ffmpeg-3.1.3-libavformat2Frdt.c
"            continue;
        } else if (!av_strncasecmp(reply->server, ""WMServer/"", 9)) {
            rt->server_type = RTSP_SERVER_WMS;
        } else if (rt->server_type == RTSP_SERVER_REAL)
            strcpy(real_challenge, reply->real_challenge);
",1,unused,1861,unused,"            continue;
        } else if (!av_strncasecmp(reply->server, ""WMServer/"", 9)) {
            rt->server_type = RTSP_SERVER_WMS;
        } else if (rt->server_type == RTSP_SERVER_REAL)
            strcpy(real_challenge, reply->real_challenge);
",unused,ffmpeg-3.1.3-libavformat2Frtsp.c
"             * cache it */
            if (strtol(line, &pline, 10) < 0 || line == pline)
                av_bprintf(&buf, ""%s\n"", line);
            else
                strcpy(line_cache, line);
",1,unused,179,unused,"             * cache it */
            if (strtol(line, &pline, 10) < 0 || line == pline)
                av_bprintf(&buf, ""%s\n"", line);
            else
                strcpy(line_cache, line);
",unused,ffmpeg-3.1.3-libavformat2Fsrtdec.c
"           av_free(buf);
           return;
        }
    } else if (type == 3 && length == 4) {
        strcpy(buf, avio_rl32(pb) ? ""true"" : ""false"");
",1,unused,487,unused,"           av_free(buf);
           return;
        }
    } else if (type == 3 && length == 4) {
        strcpy(buf, avio_rl32(pb) ? ""true"" : ""false"");
",unused,ffmpeg-3.1.3-libavformat2Fwtvdec.c
"    if (count > 0) {
        fprintf(stderr, ""    Last message repeated %d times\n"", count);
        count = 0;
    }
    strcpy(prev, line);
",1,unused,343,unused,"    if (count > 0) {
        fprintf(stderr, ""    Last message repeated %d times\n"", count);
        count = 0;
    }
    strcpy(prev, line);
",unused,ffmpeg-3.1.3-libavutil2Flog.c
"    size_t nonintegerlen;

    if (! (opts & human_autoscale))
      {
        sprintf (buf, ""%.0Lf"", adjust_value (inexact_style, damt));
",1,unused,232,unused,"    size_t nonintegerlen;

    if (! (opts & human_autoscale))
      {
        sprintf (buf, ""%.0Lf"", adjust_value (inexact_style, damt));
",unused,findoldversion-gl2Flib2Fhuman.c
"        while (e * base <= damt && exponent < exponent_max);

        damt /= e;

        sprintf (buf, ""%.1Lf"", adjust_value (inexact_style, damt));
",1,unused,250,unused,"        while (e * base <= damt && exponent < exponent_max);

        damt /= e;

        sprintf (buf, ""%.1Lf"", adjust_value (inexact_style, damt));
",unused,findoldversion-gl2Flib2Fhuman.c
"        if (1 + nonintegerlen + ! (opts & human_base_1024) < buflen
            || ((opts & human_suppress_point_zero)
                && buf[buflen - 1] == '0'))
          {
            sprintf (buf, ""%.0Lf"",
",1,unused,258,unused,"        if (1 + nonintegerlen + ! (opts & human_base_1024) < buflen
            || ((opts & human_suppress_point_zero)
                && buf[buflen - 1] == '0'))
          {
            sprintf (buf, ""%.0Lf"",
",unused,findoldversion-gl2Flib2Fhuman.c
"      struct passwd *pwent = getpwuid (uid);
      char const *name = pwent ? pwent->pw_name : """";
      match = xmalloc (offsetof (struct userid, name) + strlen (name) + 1);
      match->id.u = uid;
      strcpy (match->name, name);
",1,unused,88,unused,"      struct passwd *pwent = getpwuid (uid);
      char const *name = pwent ? pwent->pw_name : """";
      match = xmalloc (offsetof (struct userid, name) + strlen (name) + 1);
      match->id.u = uid;
      strcpy (match->name, name);
",unused,findoldversion-gl2Flib2Fidcache.c
"    }
#endif

  tail = xmalloc (offsetof (struct userid, name) + strlen (user) + 1);
  strcpy (tail->name, user);
",1,unused,131,unused,"    }
#endif

  tail = xmalloc (offsetof (struct userid, name) + strlen (user) + 1);
  strcpy (tail->name, user);
",unused,findoldversion-gl2Flib2Fidcache.c
"      struct group *grent = getgrgid (gid);
      char const *name = grent ? grent->gr_name : """";
      match = xmalloc (offsetof (struct userid, name) + strlen (name) + 1);
      match->id.g = gid;
      strcpy (match->name, name);
",1,unused,170,unused,"      struct group *grent = getgrgid (gid);
      char const *name = grent ? grent->gr_name : """";
      match = xmalloc (offsetof (struct userid, name) + strlen (name) + 1);
      match->id.g = gid;
      strcpy (match->name, name);
",unused,findoldversion-gl2Flib2Fidcache.c
"    }
#endif

  tail = xmalloc (offsetof (struct userid, name) + strlen (group) + 1);
  strcpy (tail->name, group);
",1,unused,213,unused,"    }
#endif

  tail = xmalloc (offsetof (struct userid, name) + strlen (group) + 1);
  strcpy (tail->name, group);
",unused,findoldversion-gl2Flib2Fidcache.c
"                          res_size = 0;
                          free (old_res_ptr);
                          break;
                        }
                      strcpy (res_ptr + res_size - (l2 + 1) - (l1 + 1), buf1);
",1,unused,239,unused,"                          res_size = 0;
                          free (old_res_ptr);
                          break;
                        }
                      strcpy (res_ptr + res_size - (l2 + 1) - (l1 + 1), buf1);
",unused,findoldversion-gl2Flib2Flocalcharset.c
"                          free (old_res_ptr);
                          break;
                        }
                      strcpy (res_ptr + res_size - (l2 + 1) - (l1 + 1), buf1);
                      strcpy (res_ptr + res_size - (l2 + 1), buf2);
",1,unused,240,unused,"                          free (old_res_ptr);
                          break;
                        }
                      strcpy (res_ptr + res_size - (l2 + 1) - (l1 + 1), buf1);
                      strcpy (res_ptr + res_size - (l2 + 1), buf2);
",unused,findoldversion-gl2Flib2Flocalcharset.c
"               that name resolves to /proc/self/fd, which was opened above.
               However, on Solaris, it may resolve to /proc/self/fd/fd, which
               cannot exist, since all names in /proc/self/fd are numeric.  */
            char dotdot_buf[PROC_SELF_FD_DIR_SIZE_BOUND + sizeof ""../fd"" - 1];
            sprintf (dotdot_buf, PROC_SELF_FD_FORMAT ""../fd"", proc_self_fd);
",1,unused,88,unused,"               that name resolves to /proc/self/fd, which was opened above.
               However, on Solaris, it may resolve to /proc/self/fd/fd, which
               cannot exist, since all names in /proc/self/fd are numeric.  */
            char dotdot_buf[PROC_SELF_FD_DIR_SIZE_BOUND + sizeof ""../fd"" - 1];
            sprintf (dotdot_buf, PROC_SELF_FD_FORMAT ""../fd"", proc_self_fd);
",unused,findoldversion-gl2Flib2Fopenat-proc.c
"            if (! result)
              return NULL;
          }

        dirlen = sprintf (result, PROC_SELF_FD_FORMAT, fd);
",1,unused,106,unused,"            if (! result)
              return NULL;
          }

        dirlen = sprintf (result, PROC_SELF_FD_FORMAT, fd);
",unused,findoldversion-gl2Flib2Fopenat-proc.c
"    result[dirlen++] = '/';
  }
#endif

  strcpy (result + dirlen, file);
",1,unused,132,unused,"    result[dirlen++] = '/';
  }
#endif

  strcpy (result + dirlen, file);
",unused,findoldversion-gl2Flib2Fopenat-proc.c
"              char tz1buf[sizeof ""XXX+0:00""
                          + sizeof pc.time_zone * CHAR_BIT / 3];
              if (!tz_was_altered)
                tz0 = get_tz (tz0buf);
              sprintf (tz1buf, ""XXX%s%ld:%02d"", &""-""[time_zone < 0],
",1,unused,3202,unused,"              char tz1buf[sizeof ""XXX+0:00""
                          + sizeof pc.time_zone * CHAR_BIT / 3];
              if (!tz_was_altered)
                tz0 = get_tz (tz0buf);
              sprintf (tz1buf, ""XXX%s%ld:%02d"", &""-""[time_zone < 0],
",unused,findoldversion-gl2Flib2Fparse-datetime.c
"	      char tz1buf[sizeof ""XXX+0:00""
			  + sizeof pc.time_zone * CHAR_BIT / 3];
	      if (!tz_was_altered)
		tz0 = get_tz (tz0buf);
	      sprintf (tz1buf, ""XXX%s%ld:%02d"", ""-"" + (time_zone < 0),
",1,unused,3189,unused,"	      char tz1buf[sizeof ""XXX+0:00""
			  + sizeof pc.time_zone * CHAR_BIT / 3];
	      if (!tz_was_altered)
		tz0 = get_tz (tz0buf);
	      sprintf (tz1buf, ""XXX%s%ld:%02d"", ""-"" + (time_zone < 0),
",unused,findutilstrusty-gnulib2Flib2Fgetdate.c
"    size_t nonintegerlen;

    if (! (opts & human_autoscale))
      {
	sprintf (buf, ""%.0Lf"", adjust_value (inexact_style, damt));
",1,unused,232,unused,"    size_t nonintegerlen;

    if (! (opts & human_autoscale))
      {
	sprintf (buf, ""%.0Lf"", adjust_value (inexact_style, damt));
",unused,findutilstrusty-gnulib2Flib2Fhuman.c
"	while (e * base <= damt && exponent < exponent_max);

	damt /= e;

	sprintf (buf, ""%.1Lf"", adjust_value (inexact_style, damt));
",1,unused,250,unused,"	while (e * base <= damt && exponent < exponent_max);

	damt /= e;

	sprintf (buf, ""%.1Lf"", adjust_value (inexact_style, damt));
",unused,findutilstrusty-gnulib2Flib2Fhuman.c
"	if (1 + nonintegerlen + ! (opts & human_base_1024) < buflen
	    || ((opts & human_suppress_point_zero)
		&& buf[buflen - 1] == '0'))
	  {
	    sprintf (buf, ""%.0Lf"",
",1,unused,258,unused,"	if (1 + nonintegerlen + ! (opts & human_base_1024) < buflen
	    || ((opts & human_suppress_point_zero)
		&& buf[buflen - 1] == '0'))
	  {
	    sprintf (buf, ""%.0Lf"",
",unused,findutilstrusty-gnulib2Flib2Fhuman.c
"      struct passwd *pwent = getpwuid (uid);
      char const *name = pwent ? pwent->pw_name : """";
      match = xmalloc (offsetof (struct userid, name) + strlen (name) + 1);
      match->id.u = uid;
      strcpy (match->name, name);
",1,unused,88,unused,"      struct passwd *pwent = getpwuid (uid);
      char const *name = pwent ? pwent->pw_name : """";
      match = xmalloc (offsetof (struct userid, name) + strlen (name) + 1);
      match->id.u = uid;
      strcpy (match->name, name);
",unused,findutilstrusty-gnulib2Flib2Fidcache.c
"    }
#endif

  tail = xmalloc (offsetof (struct userid, name) + strlen (user) + 1);
  strcpy (tail->name, user);
",1,unused,131,unused,"    }
#endif

  tail = xmalloc (offsetof (struct userid, name) + strlen (user) + 1);
  strcpy (tail->name, user);
",unused,findutilstrusty-gnulib2Flib2Fidcache.c
"      struct group *grent = getgrgid (gid);
      char const *name = grent ? grent->gr_name : """";
      match = xmalloc (offsetof (struct userid, name) + strlen (name) + 1);
      match->id.g = gid;
      strcpy (match->name, name);
",1,unused,170,unused,"      struct group *grent = getgrgid (gid);
      char const *name = grent ? grent->gr_name : """";
      match = xmalloc (offsetof (struct userid, name) + strlen (name) + 1);
      match->id.g = gid;
      strcpy (match->name, name);
",unused,findutilstrusty-gnulib2Flib2Fidcache.c
"    }
#endif

  tail = xmalloc (offsetof (struct userid, name) + strlen (group) + 1);
  strcpy (tail->name, group);
",1,unused,213,unused,"    }
#endif

  tail = xmalloc (offsetof (struct userid, name) + strlen (group) + 1);
  strcpy (tail->name, group);
",unused,findutilstrusty-gnulib2Flib2Fidcache.c
"		  if (old_res_ptr != NULL)
		    free (old_res_ptr);
		  break;
		}
	      strcpy (res_ptr + res_size - (l2 + 1) - (l1 + 1), buf1);
",1,unused,196,unused,"		  if (old_res_ptr != NULL)
		    free (old_res_ptr);
		  break;
		}
	      strcpy (res_ptr + res_size - (l2 + 1) - (l1 + 1), buf1);
",unused,findutilstrusty-gnulib2Flib2Flocalcharset.c
"		    free (old_res_ptr);
		  break;
		}
	      strcpy (res_ptr + res_size - (l2 + 1) - (l1 + 1), buf1);
	      strcpy (res_ptr + res_size - (l2 + 1), buf2);
",1,unused,197,unused,"		    free (old_res_ptr);
		  break;
		}
	      strcpy (res_ptr + res_size - (l2 + 1) - (l1 + 1), buf1);
	      strcpy (res_ptr + res_size - (l2 + 1), buf2);
",unused,findutilstrusty-gnulib2Flib2Flocalcharset.c
"	{
	  struct stat proc_self_fd_dotdot_st;
	  struct stat proc_self_st;
	  char dotdot_buf[PROC_SELF_FD_NAME_SIZE_BOUND (sizeof "".."" - 1)];
	  sprintf (dotdot_buf, PROC_SELF_FD_FORMAT, proc_self_fd, "".."");
",1,unused,75,unused,"	{
	  struct stat proc_self_fd_dotdot_st;
	  struct stat proc_self_st;
	  char dotdot_buf[PROC_SELF_FD_NAME_SIZE_BOUND (sizeof "".."" - 1)];
	  sprintf (dotdot_buf, PROC_SELF_FD_FORMAT, proc_self_fd, "".."");
",unused,findutilstrusty-gnulib2Flib2Fopenat-proc.c
"  else
    {
      size_t bufsize = PROC_SELF_FD_NAME_SIZE_BOUND (strlen (file));
      char *result = (bufsize < OPENAT_BUFFER_SIZE ? buf : xmalloc (bufsize));
      sprintf (result, PROC_SELF_FD_FORMAT, fd, file);
",1,unused,91,unused,"  else
    {
      size_t bufsize = PROC_SELF_FD_NAME_SIZE_BOUND (strlen (file));
      char *result = (bufsize < OPENAT_BUFFER_SIZE ? buf : xmalloc (bufsize));
      sprintf (result, PROC_SELF_FD_FORMAT, fd, file);
",unused,findutilstrusty-gnulib2Flib2Fopenat-proc.c
"		    first = FALSE;
		} else {
		    *target++ = '|';
		}
		strcpy(target, scr_attrs[n].name);
",1,unused,666,unused,"		    first = FALSE;
		} else {
		    *target++ = '|';
		}
		strcpy(target, scr_attrs[n].name);
",unused,findutilsxenial-ncurses2Fbase2Flib_screen.c
"	}
	if ((source & A_COLOR) != (prior & A_COLOR)) {
	    if (!first)
		*target++ = '|';
	    sprintf(target, ""C%d"", PAIR_NUMBER((int) source));
",1,unused,673,unused,"	}
	if ((source & A_COLOR) != (prior & A_COLOR)) {
	    if (!first)
		*target++ = '|';
	    sprintf(target, ""C%d"", PAIR_NUMBER((int) source));
",unused,findutilsxenial-ncurses2Fbase2Flib_screen.c
"    }
    target += strlen(target);
    *target++ = MARKER;
    if (ch < 32 || ch >= 127) {
	sprintf(target, ""%03o"", UChar(ch));
",1,unused,739,unused,"    }
    target += strlen(target);
    *target++ = MARKER;
    if (ch < 32 || ch >= 127) {
	sprintf(target, ""%03o"", UChar(ch));
",unused,findutilsxenial-ncurses2Fbase2Flib_screen.c
"	sprintf(target, ""%03o"", UChar(ch));
    } else {
	switch (ch) {
	case ' ':
	    strcpy(target, ""s"");
",1,unused,743,unused,"	sprintf(target, ""%03o"", UChar(ch));
    } else {
	switch (ch) {
	case ' ':
	    strcpy(target, ""s"");
",unused,findutilsxenial-ncurses2Fbase2Flib_screen.c
"	    *target++ = MARKER;
	    *target = '\0';
	    break;
	default:
	    sprintf(--target, ""%c"", UChar(ch));
",1,unused,750,unused,"	    *target++ = MARKER;
	    *target = '\0';
	    break;
	default:
	    sprintf(--target, ""%c"", UChar(ch));
",unused,findutilsxenial-ncurses2Fbase2Flib_screen.c
"	    case pBOOL:
		if (!(*(const bool *) data)) {
		    continue;
		}
		strcpy(buffer, name);
",1,unused,801,unused,"	    case pBOOL:
		if (!(*(const bool *) data)) {
		    continue;
		}
		strcpy(buffer, name);
",unused,findutilsxenial-ncurses2Fbase2Flib_screen.c
"		break;
	    case pINT:
		if (!(*(const int *) dp))
		    continue;
		sprintf(buffer, ""%d"", *(const int *) dp);
",1,unused,810,unused,"		break;
	    case pINT:
		if (!(*(const int *) dp))
		    continue;
		sprintf(buffer, ""%d"", *(const int *) dp);
",unused,findutilsxenial-ncurses2Fbase2Flib_screen.c
"		break;
	    case pSHORT:
		if (!(*(const short *) dp))
		    continue;
		sprintf(buffer, ""%d"", *(const short *) dp);
",1,unused,815,unused,"		break;
	    case pSHORT:
		if (!(*(const short *) dp))
		    continue;
		sprintf(buffer, ""%d"", *(const short *) dp);
",unused,findutilsxenial-ncurses2Fbase2Flib_screen.c
"		break;
	    case pSIZE:
		if (!(*(const NCURSES_SIZE_T *) dp))
		    continue;
		sprintf(buffer, ""%d"", *(const NCURSES_SIZE_T *) dp);
",1,unused,820,unused,"		break;
	    case pSIZE:
		if (!(*(const NCURSES_SIZE_T *) dp))
		    continue;
		sprintf(buffer, ""%d"", *(const NCURSES_SIZE_T *) dp);
",unused,findutilsxenial-ncurses2Fbase2Flib_screen.c
"		if (outbuf.used)
		    wrap_concat(""\n"");
		wrap_concat(""hex:"");
		for (n = 0; n < offset; ++n) {
		    sprintf(numbuf, ""%02X"", UChar(bigbuf[n]));
",1,unused,1180,unused,"		if (outbuf.used)
		    wrap_concat(""\n"");
		wrap_concat(""hex:"");
		for (n = 0; n < offset; ++n) {
		    sprintf(numbuf, ""%02X"", UChar(bigbuf[n]));
",unused,findutilsxenial-progs2Fdump_entry.c
"
    *next++ = '\0';
    for (k = 1; k <= NUM_PARM; k++) {
	numbers[k] = count;
	sprintf(next, ""XYZ%d"", count);
",1,unused,1779,unused,"
    *next++ = '\0';
    for (k = 1; k <= NUM_PARM; k++) {
	numbers[k] = count;
	sprintf(next, ""XYZ%d"", count);
",unused,findutilsxenial-progs2Ftic.c
"		c = live[0];
	    } else {
		char buf[BUFSIZ];

		(void) sprintf(buf,
",1,unused,318,unused,"		c = live[0];
	    } else {
		char buf[BUFSIZ];

		(void) sprintf(buf,
",unused,findutilsxenial-test2Fblue.c
"	if (card->content != 0 && (offset = strlen(card->content)) != 0) {
	    total += 1 + offset;
	    card->content = typeRealloc(char, total + 1, card->content);
	    if (card->content)
		strcpy(card->content + offset++, "" "");
",1,unused,136,unused,"	if (card->content != 0 && (offset = strlen(card->content)) != 0) {
	    total += 1 + offset;
	    card->content = typeRealloc(char, total + 1, card->content);
	    if (card->content)
		strcpy(card->content + offset++, "" "");
",unused,findutilsxenial-test2Fcardfile.c
"		free(card->content);
	    card->content = typeMalloc(char, total + 1);
	}
	if (card->content)
	    strcpy(card->content + offset, content);
",1,unused,144,unused,"		free(card->content);
	    card->content = typeMalloc(char, total + 1);
	}
	if (card->content)
	    strcpy(card->content + offset, content);
",unused,findutilsxenial-test2Fcardfile.c
"	case '.':		/* change from current position */
	    (void) wattrset(win, AttrArg(COLOR_PAIR(st.pair), st.attr));
	    if (st.count > 0) {
		need = (unsigned) st.count + 1;
		sprintf(fmt, ""%%c%%%ds%%c"", st.count);
",1,unused,337,unused,"	case '.':		/* change from current position */
	    (void) wattrset(win, AttrArg(COLOR_PAIR(st.pair), st.attr));
	    if (st.count > 0) {
		need = (unsigned) st.count + 1;
		sprintf(fmt, ""%%c%%%ds%%c"", st.count);
",unused,findutilsxenial-test2Fclip_printw.c
"		need = (unsigned) st.count + 1;
		sprintf(fmt, ""%%c%%%ds%%c"", st.count);
	    } else {
		need = (unsigned) getmaxx(win) - 1;
		strcpy(fmt, ""%c%s%c"");
",1,unused,340,unused,"		need = (unsigned) st.count + 1;
		sprintf(fmt, ""%%c%%%ds%%c"", st.count);
	    } else {
		need = (unsigned) getmaxx(win) - 1;
		strcpy(fmt, ""%c%s%c"");
",unused,findutilsxenial-test2Fclip_printw.c
"     * keypad() initializes the corresponding data.
     */
    for (n = 0; n < 255; ++n) {
	char temp[10];
	sprintf(temp, ""\033%c"", n);
",1,unused,107,unused,"     * keypad() initializes the corresponding data.
     */
    for (n = 0; n < 255; ++n) {
	char temp[10];
	sprintf(temp, ""\033%c"", n);
",unused,findutilsxenial-test2Fdemo_altkeys.c
"    for (n = KEY_MIN; n < KEY_MAX; ++n) {
	char *value;
	if ((value = keybound(n, 0)) != 0) {
	    char *temp = typeMalloc(char, strlen(value) + 2);
	    sprintf(temp, ""\033%s"", value);
",1,unused,114,unused,"    for (n = KEY_MIN; n < KEY_MAX; ++n) {
	char *value;
	if ((value = keybound(n, 0)) != 0) {
	    char *temp = typeMalloc(char, strlen(value) + 2);
	    sprintf(temp, ""\033%s"", value);
",unused,findutilsxenial-test2Fdemo_altkeys.c
"		    size_t need = strlen(buffer) + 2 + strlen(prior);
		    char *value = typeRealloc(char, need, prior);
		    if (value == 0)
			failed(""realloc"");
		    strcat(value, ""\n"");
",1,unused,152,unused,"		    size_t need = strlen(buffer) + 2 + strlen(prior);
		    char *value = typeRealloc(char, need, prior);
		    if (value == 0)
			failed(""realloc"");
		    strcat(value, ""\n"");
",unused,findutilsxenial-test2Fdemo_forms.c
"		    char *value = typeRealloc(char, need, prior);
		    if (value == 0)
			failed(""realloc"");
		    strcat(value, ""\n"");
		    strcat(value, buffer);
",1,unused,153,unused,"		    char *value = typeRealloc(char, need, prior);
		    if (value == 0)
			failed(""realloc"");
		    strcat(value, ""\n"");
		    strcat(value, buffer);
",unused,findutilsxenial-test2Fdemo_forms.c
"    /* describe the form */
    memset(f, 0, sizeof(f));
    for (pg = 0; pg < 4; ++pg) {
	char label[80];
	sprintf(label, ""Sample Form Page %d"", pg + 1);
",1,unused,459,unused,"    /* describe the form */
    memset(f, 0, sizeof(f));
    for (pg = 0; pg < 4; ++pg) {
	char label[80];
	sprintf(label, ""Sample Form Page %d"", pg + 1);
",unused,findutilsxenial-test2Fdemo_forms.c
"	} else if (!unboxed) {
	    wbkgdset(win, A_BOLD | ' ');
	}
    }
    sprintf(userdata, ""p%d"", color % 8);
",1,unused,225,unused,"	} else if (!unboxed) {
	    wbkgdset(win, A_BOLD | ' ');
	}
    }
    sprintf(userdata, ""p%d"", color % 8);
",unused,findutilsxenial-test2Fdemo_panels.c
"    }

    if (code > 0) {
	char also[80];
	sprintf(also, "" (first %d,%d)"", y0, x0);
",1,unused,274,unused,"    }

    if (code > 0) {
	char also[80];
	sprintf(also, "" (first %d,%d)"", y0, x0);
",unused,findutilsxenial-test2Fdemo_panels.c
"	WINDOW *win = panel_window(pans[which]);
	char also[80];

	getbegyx(win, y0, x0);
	sprintf(also, "" (start %d,%d)"", y0, x0);
",1,unused,305,unused,"	WINDOW *win = panel_window(pans[which]);
	char also[80];

	getbegyx(win, y0, x0);
	sprintf(also, "" (start %d,%d)"", y0, x0);
",unused,findutilsxenial-test2Fdemo_panels.c
"	WINDOW *win = panel_window(pans[which]);
	char also[80];

	getbegyx(win, y0, x0);
	sprintf(also, "" (start %d,%d)"", y0, x0);
",1,unused,330,unused,"	WINDOW *win = panel_window(pans[which]);
	char also[80];

	getbegyx(win, y0, x0);
	sprintf(also, "" (start %d,%d)"", y0, x0);
",unused,findutilsxenial-test2Fdemo_panels.c
"static char *
make_dbitem(char *p, char *q)
{
    char *result = malloc(strlen(e_opt) + 2 + (size_t) (p - q));
    sprintf(result, ""%s=%.*s"", e_opt, (int) (p - q), q);
",1,unused,104,unused,"static char *
make_dbitem(char *p, char *q)
{
    char *result = malloc(strlen(e_opt) + 2 + (size_t) (p - q));
    sprintf(result, ""%s=%.*s"", e_opt, (int) (p - q), q);
",unused,findutilsxenial-test2Fdemo_termcap.c
"	    if (pass == 0) {
		length += chunk;
	    } else {
		result[count] = unused;
		strcpy(unused, list[count]);
",1,unused,702,unused,"	    if (pass == 0) {
		length += chunk;
	    } else {
		result[count] = unused;
		strcpy(unused, list[count]);
",unused,findutilsxenial-test2Fdemo_termcap.c
"static char *
make_dbitem(char *p, char *q)
{
    char *result = malloc(strlen(e_opt) + 2 + (size_t) (p - q));
    sprintf(result, ""%s=%.*s"", e_opt, (int) (p - q), q);
",1,unused,99,unused,"static char *
make_dbitem(char *p, char *q)
{
    char *result = malloc(strlen(e_opt) + 2 + (size_t) (p - q));
    sprintf(result, ""%s=%.*s"", e_opt, (int) (p - q), q);
",unused,findutilsxenial-test2Fdemo_terminfo.c
"			    !strcmp(xterm_keys[n], ""kLFT"") ||
			    !strcmp(xterm_keys[n], ""kRIT"")) {
			    continue;
			}
			sprintf(temp, ""%.*s"", 8, xterm_keys[n]);
",1,unused,399,unused,"			    !strcmp(xterm_keys[n], ""kLFT"") ||
			    !strcmp(xterm_keys[n], ""kRIT"")) {
			    continue;
			}
			sprintf(temp, ""%.*s"", 8, xterm_keys[n]);
",unused,findutilsxenial-test2Fdemo_terminfo.c
"			    continue;
			}
			sprintf(temp, ""%.*s"", 8, xterm_keys[n]);
		    } else {
			sprintf(temp, ""%.*s%d"", 8, xterm_keys[n], mod);
",1,unused,401,unused,"			    continue;
			}
			sprintf(temp, ""%.*s"", 8, xterm_keys[n]);
		    } else {
			sprintf(temp, ""%.*s%d"", 8, xterm_keys[n], mod);
",unused,findutilsxenial-test2Fdemo_terminfo.c
"	    if (pass == 0) {
		length += chunk;
	    } else {
		result[count] = unused;
		strcpy(unused, list[count]);
",1,unused,736,unused,"	    if (pass == 0) {
		length += chunk;
	    } else {
		result[count] = unused;
		strcpy(unused, list[count]);
",unused,findutilsxenial-test2Fdemo_terminfo.c
"     * will execute as a comment.
     */
#ifdef KEY_EVENT
    if (code == KEY_EVENT)
	strcpy(buffer, ""# event!"");
",1,unused,66,unused,"     * will execute as a comment.
     */
#ifdef KEY_EVENT
    if (code == KEY_EVENT)
	strcpy(buffer, ""# event!"");
",unused,findutilsxenial-test2Ffilter.c
"	strcpy(buffer, ""# event!"");
#endif
#ifdef KEY_RESIZE
    if (code == KEY_RESIZE) {
	strcpy(buffer, ""# resize!"");
",1,unused,70,unused,"	strcpy(buffer, ""# event!"");
#endif
#ifdef KEY_RESIZE
    if (code == KEY_RESIZE) {
	strcpy(buffer, ""# resize!"");
",unused,findutilsxenial-test2Ffilter.c
"		      &second,
		      final) == 3
	    && *final != ';'
	    && (value = strdup(info[j].value)) != 0) {
	    sprintf(value, ""\033[%d%c"", first, *final);
",1,unused,166,unused,"		      &second,
		      final) == 3
	    && *final != ';'
	    && (value = strdup(info[j].value)) != 0) {
	    sprintf(value, ""\033[%d%c"", first, *final);
",unused,findutilsxenial-test2Ffoldkeys.c
"		    break;
		}
	    }
	    if (info[j].state == 0) {
		sprintf(value, ""\033O%c"", *final);
",1,unused,175,unused,"		    break;
		}
	    }
	    if (info[j].state == 0) {
		sprintf(value, ""\033O%c"", *final);
",unused,findutilsxenial-test2Ffoldkeys.c
"    if (first) {
	static char cmd[80];
	setlocale(LC_ALL, """");

	putenv(strcpy(cmd, ""TABSIZE=8""));
",1,unused,164,unused,"    if (first) {
	static char cmd[80];
	setlocale(LC_ALL, """");

	putenv(strcpy(cmd, ""TABSIZE=8""));
",unused,findutilsxenial-test2Finserts.c
"mouse_decode(MEVENT const *ep)
{
    static char buf[80 + (5 * 10) + (32 * 15)];

    (void) sprintf(buf, ""id %2d at (%2d, %2d, %d) state %4lx = {"",
",1,unused,518,unused,"mouse_decode(MEVENT const *ep)
{
    static char buf[80 + (5 * 10) + (32 * 15)];

    (void) sprintf(buf, ""id %2d at (%2d, %2d, %d) state %4lx = {"",
",unused,findutilsxenial-test2Fncurses.c
"#undef SHOW

    if (buf[strlen(buf) - 1] == ' ')
	buf[strlen(buf) - 2] = '\0';
    (void) strcat(buf, ""}"");
",1,unused,577,unused,"#undef SHOW

    if (buf[strlen(buf) - 1] == ' ')
	buf[strlen(buf) - 2] = '\0';
    (void) strcat(buf, ""}"");
",unused,findutilsxenial-test2Fncurses.c
"	char temp[80];
	int width = 8;

	if (wide) {
	    sprintf(temp, ""%02d"", color);
",1,unused,2087,unused,"	char temp[80];
	int width = 8;

	if (wide) {
	    sprintf(temp, ""%02d"", color);
",unused,findutilsxenial-test2Fncurses.c
"	if (wide) {
	    sprintf(temp, ""%02d"", color);
	    width = 4;
	} else if (color >= 8) {
	    sprintf(temp, ""[%02d]"", color);
",1,unused,2090,unused,"	if (wide) {
	    sprintf(temp, ""%02d"", color);
	    width = 4;
	} else if (color >= 8) {
	    sprintf(temp, ""[%02d]"", color);
",unused,findutilsxenial-test2Fncurses.c
"	    width = 4;
	} else if (color >= 8) {
	    sprintf(temp, ""[%02d]"", color);
	} else if (color < 0) {
	    strcpy(temp, ""default"");
",1,unused,2092,unused,"	    width = 4;
	} else if (color >= 8) {
	    sprintf(temp, ""[%02d]"", color);
	} else if (color < 0) {
	    strcpy(temp, ""default"");
",unused,findutilsxenial-test2Fncurses.c
"	    sprintf(temp, ""[%02d]"", color);
	} else if (color < 0) {
	    strcpy(temp, ""default"");
	} else {
	    sprintf(temp, ""%.*s"", 16, the_color_names[color]);
",1,unused,2094,unused,"	    sprintf(temp, ""[%02d]"", color);
	} else if (color < 0) {
	    strcpy(temp, ""default"");
	} else {
	    sprintf(temp, ""%.*s"", 16, the_color_names[color]);
",unused,findutilsxenial-test2Fncurses.c
"		if (opt_revs)
		    attron(A_REVERSE);

		if (opt_nums) {
		    sprintf(numbered, ""{%02X}"", (int) i);
",1,unused,2281,unused,"		if (opt_revs)
		    attron(A_REVERSE);

		if (opt_nums) {
		    sprintf(numbered, ""{%02X}"", (int) i);
",unused,findutilsxenial-test2Fncurses.c
"	     (i - top_color < page_size)
	     && (i < max_colors); i++) {
	    char numeric[80];

	    sprintf(numeric, ""[%d]"", i);
",1,unused,2701,unused,"	     (i - top_color < page_size)
	     && (i < max_colors); i++) {
	    char numeric[80];

	    sprintf(numeric, ""[%d]"", i);
",unused,findutilsxenial-test2Fncurses.c
"	case '6':
	case '7':
	case '8':
	    MvAddStr(SLK_WORK, 0, ""Please enter the label value: "");
	    strcpy(buf, """");
",1,unused,3078,unused,"	case '6':
	case '7':
	case '8':
	    MvAddStr(SLK_WORK, 0, ""Please enter the label value: "");
	    strcpy(buf, """");
",unused,findutilsxenial-test2Fncurses.c
"	int count = repeat;
	int row = 2 + ((int) (code - first) % (pagesize / 2));
	int col = ((int) (code - first) / (pagesize / 2)) * COLS / 2;
	char tmp[80];
	sprintf(tmp, ""%3u (0x%x)"", code, code);
",1,unused,3336,unused,"	int count = repeat;
	int row = 2 + ((int) (code - first) % (pagesize / 2));
	int col = ((int) (code - first) / (pagesize / 2)) * COLS / 2;
	char tmp[80];
	sprintf(tmp, ""%3u (0x%x)"", code, code);
",unused,findutilsxenial-test2Fncurses.c
"    move(LINES - 4, 0);
    for (n = 0; n < SIZEOF(legend); n++) {
	switch (legend[n].code) {
	default:
	    strcpy(buf, legend[n].msg);
",1,unused,4349,unused,"    move(LINES - 4, 0);
    for (n = 0; n < SIZEOF(legend); n++) {
	switch (legend[n].code) {
	default:
	    strcpy(buf, legend[n].msg);
",unused,findutilsxenial-test2Fncurses.c
"	default:
	    strcpy(buf, legend[n].msg);
	    break;
	case 1:
	    sprintf(buf, legend[n].msg, do_keypad ? ""yes"" : ""no"");
",1,unused,4352,unused,"	default:
	    strcpy(buf, legend[n].msg);
	    break;
	case 1:
	    sprintf(buf, legend[n].msg, do_keypad ? ""yes"" : ""no"");
",unused,findutilsxenial-test2Fncurses.c
"	case 1:
	    sprintf(buf, legend[n].msg, do_keypad ? ""yes"" : ""no"");
	    break;
	case 2:
	    sprintf(buf, legend[n].msg, do_scroll ? ""yes"" : ""no"");
",1,unused,4355,unused,"	case 1:
	    sprintf(buf, legend[n].msg, do_keypad ? ""yes"" : ""no"");
	    break;
	case 2:
	    sprintf(buf, legend[n].msg, do_scroll ? ""yes"" : ""no"");
",unused,findutilsxenial-test2Fncurses.c
"	case 2:
	    sprintf(buf, legend[n].msg, do_scroll ? ""yes"" : ""no"");
	    break;
	case 3:
	    sprintf(buf, legend[n].msg, do_keypad ? ""/ESC"" : """");
",1,unused,4358,unused,"	case 2:
	    sprintf(buf, legend[n].msg, do_scroll ? ""yes"" : ""no"");
	    break;
	case 3:
	    sprintf(buf, legend[n].msg, do_keypad ? ""/ESC"" : """");
",unused,findutilsxenial-test2Fncurses.c
"
	switch (row) {
	case 0:
	    flavors[row] = 0;
	    sprintf(msg, ""refresh %s, then %s, then doupdate."", ths, tht);
",1,unused,6528,unused,"
	switch (row) {
	case 0:
	    flavors[row] = 0;
	    sprintf(msg, ""refresh %s, then %s, then doupdate."", ths, tht);
",unused,findutilsxenial-test2Fncurses.c
"	    } else {
		flavors[row] %= 2;
	    }
	    overlap_test_1_attr(stdscr, flavors[row], col);
	    sprintf(msg, ""fill window %s with letter %s."", ths, ths);
",1,unused,6537,unused,"	    } else {
		flavors[row] %= 2;
	    }
	    overlap_test_1_attr(stdscr, flavors[row], col);
	    sprintf(msg, ""fill window %s with letter %s."", ths, ths);
",unused,findutilsxenial-test2Fncurses.c
"		flavors[row] %= 2;
	    }
	    switch (flavors[row]) {
	    case 0:
		sprintf(msg, ""cross pattern in window %s."", ths);
",1,unused,6547,unused,"		flavors[row] %= 2;
	    }
	    switch (flavors[row]) {
	    case 0:
		sprintf(msg, ""cross pattern in window %s."", ths);
",unused,findutilsxenial-test2Fncurses.c
"	    case 0:
		sprintf(msg, ""cross pattern in window %s."", ths);
		break;
	    case 1:
		sprintf(msg, ""draw box in window %s."", ths);
",1,unused,6550,unused,"	    case 0:
		sprintf(msg, ""cross pattern in window %s."", ths);
		break;
	    case 1:
		sprintf(msg, ""draw box in window %s."", ths);
",unused,findutilsxenial-test2Fncurses.c
"	    case 1:
		sprintf(msg, ""draw box in window %s."", ths);
		break;
	    case 2:
		sprintf(msg, ""set background of window %s."", ths);
",1,unused,6553,unused,"	    case 1:
		sprintf(msg, ""draw box in window %s."", ths);
		break;
	    case 2:
		sprintf(msg, ""set background of window %s."", ths);
",unused,findutilsxenial-test2Fncurses.c
"	    case 2:
		sprintf(msg, ""set background of window %s."", ths);
		break;
	    case 3:
		sprintf(msg, ""reset background of window %s."", ths);
",1,unused,6556,unused,"	    case 2:
		sprintf(msg, ""set background of window %s."", ths);
		break;
	    case 3:
		sprintf(msg, ""reset background of window %s."", ths);
",unused,findutilsxenial-test2Fncurses.c
"	    }
	    break;
	case 3:
	    flavors[row] = 0;
	    sprintf(msg, ""clear window %s."", ths);
",1,unused,6562,unused,"	    }
	    break;
	case 3:
	    flavors[row] = 0;
	    sprintf(msg, ""clear window %s."", ths);
",unused,findutilsxenial-test2Fncurses.c
"	case 4:
	    flavors[row] %= 4;
	    switch (flavors[row]) {
	    case 0:
		sprintf(msg, ""overwrite %s onto %s."", ths, tht);
",1,unused,6568,unused,"	case 4:
	    flavors[row] %= 4;
	    switch (flavors[row]) {
	    case 0:
		sprintf(msg, ""overwrite %s onto %s."", ths, tht);
",unused,findutilsxenial-test2Fncurses.c
"	    case 0:
		sprintf(msg, ""overwrite %s onto %s."", ths, tht);
		break;
	    case 1:
		sprintf(msg, ""copywin(FALSE) %s onto %s."", ths, tht);
",1,unused,6571,unused,"	    case 0:
		sprintf(msg, ""overwrite %s onto %s."", ths, tht);
		break;
	    case 1:
		sprintf(msg, ""copywin(FALSE) %s onto %s."", ths, tht);
",unused,findutilsxenial-test2Fncurses.c
"	    case 1:
		sprintf(msg, ""copywin(FALSE) %s onto %s."", ths, tht);
		break;
	    case 2:
		sprintf(msg, ""copywin(TRUE) %s onto %s."", ths, tht);
",1,unused,6574,unused,"	    case 1:
		sprintf(msg, ""copywin(FALSE) %s onto %s."", ths, tht);
		break;
	    case 2:
		sprintf(msg, ""copywin(TRUE) %s onto %s."", ths, tht);
",unused,findutilsxenial-test2Fncurses.c
"	    case 2:
		sprintf(msg, ""copywin(TRUE) %s onto %s."", ths, tht);
		break;
	    case 3:
		sprintf(msg, ""overlay %s onto %s."", ths, tht);
",1,unused,6577,unused,"	    case 2:
		sprintf(msg, ""copywin(TRUE) %s onto %s."", ths, tht);
		break;
	    case 3:
		sprintf(msg, ""overlay %s onto %s."", ths, tht);
",unused,findutilsxenial-test2Fncurses.c
"	set_colors(win, 6, COLOR_YELLOW, COLOR_WHITE);
	message = messages[j = 0];
	i = 1;
	w = width - 2;
	strcpy(buffer, message);
",1,unused,302,unused,"	set_colors(win, 6, COLOR_YELLOW, COLOR_WHITE);
	message = messages[j = 0];
	i = 1;
	w = width - 2;
	strcpy(buffer, message);
",unused,findutilsxenial-test2Fnewdemo.c
"	w = width - 2;
	strcpy(buffer, message);
	while (j < NMESSAGES) {
	    while ((int) strlen(buffer) < w) {
		strcat(buffer, "" ... "");
",1,unused,305,unused,"	w = width - 2;
	strcpy(buffer, message);
	while (j < NMESSAGES) {
	    while ((int) strlen(buffer) < w) {
		strcat(buffer, "" ... "");
",unused,findutilsxenial-test2Fnewdemo.c
"	strcpy(buffer, message);
	while (j < NMESSAGES) {
	    while ((int) strlen(buffer) < w) {
		strcat(buffer, "" ... "");
		strcat(buffer, messages[++j % NMESSAGES]);
",1,unused,306,unused,"	strcpy(buffer, message);
	while (j < NMESSAGES) {
	    while ((int) strlen(buffer) < w) {
		strcat(buffer, "" ... "");
		strcat(buffer, messages[++j % NMESSAGES]);
",unused,findutilsxenial-test2Fnewdemo.c
"    for (i = 0; i < 12; i++) {
	sangle = (i + 1) * (2.0 * PI) / 12.0;
	sdx = A2X(sangle, sradius);
	sdy = A2Y(sangle, sradius);
	sprintf(szChar, ""%d"", i + 1);
",1,unused,178,unused,"    for (i = 0; i < 12; i++) {
	sangle = (i + 1) * (2.0 * PI) / 12.0;
	sdx = A2X(sangle, sradius);
	sdy = A2Y(sangle, sradius);
	sprintf(szChar, ""%d"", i + 1);
",unused,findutilsxenial-test2Ftclock.c
"    if (first) {
	static char cmd[80];
	setlocale(LC_ALL, """");

	putenv(strcpy(cmd, ""TABSIZE=8""));
",1,unused,236,unused,"    if (first) {
	static char cmd[80];
	setlocale(LC_ALL, """");

	putenv(strcpy(cmd, ""TABSIZE=8""));
",unused,findutilsxenial-test2Ftest_addchstr.c
"static char *
make_dbitem(char *p, char *q)
{
    char *result = malloc(strlen(e_opt) + 2 + (size_t) (p - q));
    sprintf(result, ""%s=%.*s"", e_opt, (int) (p - q), q);
",1,unused,65,unused,"static char *
make_dbitem(char *p, char *q)
{
    char *result = malloc(strlen(e_opt) + 2 + (size_t) (p - q));
    sprintf(result, ""%s=%.*s"", e_opt, (int) (p - q), q);
",unused,findutilsxenial-test2Ftest_sgr.c
"	    if (isprint(UChar(*d))) {
		col++;
		d++;
	    } else {
		sprintf(d, ""\\%03o"", UChar(*s));
",1,unused,356,unused,"	    if (isprint(UChar(*d))) {
		col++;
		d++;
	    } else {
		sprintf(d, ""\\%03o"", UChar(*s));
",unused,findutilsxenial-test2Fview.c
"    NCURSES_CH_T *s;
    time_t this_time;

#if CAN_RESIZE
    sprintf(temp, ""%.20s (%3dx%3d) col %d "", tag, LINES, COLS, shift);
",1,unused,569,unused,"    NCURSES_CH_T *s;
    time_t this_time;

#if CAN_RESIZE
    sprintf(temp, ""%.20s (%3dx%3d) col %d "", tag, LINES, COLS, shift);
",unused,findutilsxenial-test2Fview.c
"#if CAN_RESIZE
    sprintf(temp, ""%.20s (%3dx%3d) col %d "", tag, LINES, COLS, shift);
    i = (int) strlen(temp);
    if ((i + 7) < (int) sizeof(temp)) {
	sprintf(temp + i, ""view %.*s"",
",1,unused,572,unused,"#if CAN_RESIZE
    sprintf(temp, ""%.20s (%3dx%3d) col %d "", tag, LINES, COLS, shift);
    i = (int) strlen(temp);
    if ((i + 7) < (int) sizeof(temp)) {
	sprintf(temp + i, ""view %.*s"",
",unused,findutilsxenial-test2Fview.c
"					NUL_ec);
	}

	else
		strcpy (char_map, useecs ?
",1,unused,891,unused,"					NUL_ec);
	}

	else
		strcpy (char_map, useecs ?
",unused,flexdebianstretche2.6-src2Fgen.c
"			reallocate_character_array (action_array,
						    action_size);
	}

	strcpy (&action_array[action_index], new_text);
",1,unused,159,unused,"			reallocate_character_array (action_array,
						    action_size);
	}

	strcpy (&action_array[action_index], new_text);
",unused,flexdebianstretche2.6-src2Fmisc.c
"#line 185 ""stage1scan.l""
{
			if(yyleng < MAXLINE)
        		 {
			strcpy( nmstr, yytext );
",1,unused,2276,unused,"#line 185 ""stage1scan.l""
{
			if(yyleng < MAXLINE)
        		 {
			strcpy( nmstr, yytext );
",unused,flexdebianstretche2.6-src2Fstage1scan.c
"#line 293 ""stage1scan.l""
{
 		        if(yyleng < MAXLINE)
 		         {
			strcpy( nmdef, yytext );
",1,unused,2509,unused,"#line 293 ""stage1scan.l""
{
 		        if(yyleng < MAXLINE)
 		         {
			strcpy( nmdef, yytext );
",unused,flexdebianstretche2.6-src2Fstage1scan.c
"#line 437 ""stage1scan.l""
{
			if(yyleng-1 < MAXLINE)
        		 {
			strcpy( nmstr, yytext + 1 );
",1,unused,2961,unused,"#line 437 ""stage1scan.l""
{
			if(yyleng-1 < MAXLINE)
        		 {
			strcpy( nmstr, yytext + 1 );
",unused,flexdebianstretche2.6-src2Fstage1scan.c
"			int cclval;

			if(yyleng < MAXLINE)
        		 {
			strcpy( nmstr, yytext );
",1,unused,3229,unused,"			int cclval;

			if(yyleng < MAXLINE)
        		 {
			strcpy( nmstr, yytext );
",unused,flexdebianstretche2.6-src2Fstage1scan.c
"            end_is_ws = end_ch != '}' ? 1 : 0;

 			if(yyleng-1 < MAXLINE)
         		 {
			strcpy( nmstr, yytext + 1 );
",1,unused,3298,unused,"            end_is_ws = end_ch != '}' ? 1 : 0;

 			if(yyleng-1 < MAXLINE)
         		 {
			strcpy( nmstr, yytext + 1 );
",unused,flexdebianstretche2.6-src2Fstage1scan.c
"					NUL_ec);
	}

	else
		strcpy (char_map, useecs ?
",1,unused,881,unused,"					NUL_ec);
	}

	else
		strcpy (char_map, useecs ?
",unused,flexnewver-src2Fgen.c
"			reallocate_character_array (action_array,
						    action_size);
	}

	strcpy (&action_array[action_index], new_text);
",1,unused,134,unused,"			reallocate_character_array (action_array,
						    action_size);
	}

	strcpy (&action_array[action_index], new_text);
",unused,flexnewver-src2Fmisc.c
"					NUL_ec);
	}

	else
		strcpy (char_map, useecs ?
",1,unused,891,unused,"					NUL_ec);
	}

	else
		strcpy (char_map, useecs ?
",unused,flexold-src2Fgen.c
"			reallocate_character_array (action_array,
						    action_size);
	}

	strcpy (&action_array[action_index], new_text);
",1,unused,159,unused,"			reallocate_character_array (action_array,
						    action_size);
	}

	strcpy (&action_array[action_index], new_text);
",unused,flexold-src2Fmisc.c
"#line 185 ""scan.l""
{
			if(yyleng < MAXLINE)
        		 {
			strcpy( nmstr, yytext );
",1,unused,2290,unused,"#line 185 ""scan.l""
{
			if(yyleng < MAXLINE)
        		 {
			strcpy( nmstr, yytext );
",unused,flexold-src2Fscan.c
"#line 293 ""scan.l""
{
 		        if(yyleng < MAXLINE)
 		         {
			strcpy( nmdef, yytext );
",1,unused,2523,unused,"#line 293 ""scan.l""
{
 		        if(yyleng < MAXLINE)
 		         {
			strcpy( nmdef, yytext );
",unused,flexold-src2Fscan.c
"#line 437 ""scan.l""
{
			if(yyleng-1 < MAXLINE)
        		 {
			strcpy( nmstr, yytext + 1 );
",1,unused,2975,unused,"#line 437 ""scan.l""
{
			if(yyleng-1 < MAXLINE)
        		 {
			strcpy( nmstr, yytext + 1 );
",unused,flexold-src2Fscan.c
"			int cclval;

			if(yyleng < MAXLINE)
        		 {
			strcpy( nmstr, yytext );
",1,unused,3243,unused,"			int cclval;

			if(yyleng < MAXLINE)
        		 {
			strcpy( nmstr, yytext );
",unused,flexold-src2Fscan.c
"            end_is_ws = end_ch != '}' ? 1 : 0;

 			if(yyleng-1 < MAXLINE)
         		 {
			strcpy( nmstr, yytext + 1 );
",1,unused,3312,unused,"            end_is_ws = end_ch != '}' ? 1 : 0;

 			if(yyleng-1 < MAXLINE)
         		 {
			strcpy( nmstr, yytext + 1 );
",unused,flexold-src2Fscan.c
"					NUL_ec);
	}

	else
		strcpy (char_map, useecs ?
",1,unused,891,unused,"					NUL_ec);
	}

	else
		strcpy (char_map, useecs ?
",unused,flexsources2.6.1-src2Fgen.c
"			reallocate_character_array (action_array,
						    action_size);
	}

	strcpy (&action_array[action_index], new_text);
",1,unused,159,unused,"			reallocate_character_array (action_array,
						    action_size);
	}

	strcpy (&action_array[action_index], new_text);
",unused,flexsources2.6.1-src2Fmisc.c
"#line 185 ""scan.l""
{
			if(yyleng < MAXLINE)
        		 {
			strcpy( nmstr, yytext );
",1,unused,2290,unused,"#line 185 ""scan.l""
{
			if(yyleng < MAXLINE)
        		 {
			strcpy( nmstr, yytext );
",unused,flexsources2.6.1-src2Fscan.c
"#line 293 ""scan.l""
{
 		        if(yyleng < MAXLINE)
 		         {
			strcpy( nmdef, yytext );
",1,unused,2523,unused,"#line 293 ""scan.l""
{
 		        if(yyleng < MAXLINE)
 		         {
			strcpy( nmdef, yytext );
",unused,flexsources2.6.1-src2Fscan.c
"#line 437 ""scan.l""
{
			if(yyleng-1 < MAXLINE)
        		 {
			strcpy( nmstr, yytext + 1 );
",1,unused,2975,unused,"#line 437 ""scan.l""
{
			if(yyleng-1 < MAXLINE)
        		 {
			strcpy( nmstr, yytext + 1 );
",unused,flexsources2.6.1-src2Fscan.c
"			int cclval;

			if(yyleng < MAXLINE)
        		 {
			strcpy( nmstr, yytext );
",1,unused,3243,unused,"			int cclval;

			if(yyleng < MAXLINE)
        		 {
			strcpy( nmstr, yytext );
",unused,flexsources2.6.1-src2Fscan.c
"            end_is_ws = end_ch != '}' ? 1 : 0;

 			if(yyleng-1 < MAXLINE)
         		 {
			strcpy( nmstr, yytext + 1 );
",1,unused,3312,unused,"            end_is_ws = end_ch != '}' ? 1 : 0;

 			if(yyleng-1 < MAXLINE)
         		 {
			strcpy( nmstr, yytext + 1 );
",unused,flexsources2.6.1-src2Fscan.c
"#line 185 ""stage1scan.l""
{
			if(yyleng < MAXLINE)
        		 {
			strcpy( nmstr, yytext );
",1,unused,2276,unused,"#line 185 ""stage1scan.l""
{
			if(yyleng < MAXLINE)
        		 {
			strcpy( nmstr, yytext );
",unused,flexsources2.6.1-src2Fstage1scan.c
"#line 293 ""stage1scan.l""
{
 		        if(yyleng < MAXLINE)
 		         {
			strcpy( nmdef, yytext );
",1,unused,2509,unused,"#line 293 ""stage1scan.l""
{
 		        if(yyleng < MAXLINE)
 		         {
			strcpy( nmdef, yytext );
",unused,flexsources2.6.1-src2Fstage1scan.c
"#line 437 ""stage1scan.l""
{
			if(yyleng-1 < MAXLINE)
        		 {
			strcpy( nmstr, yytext + 1 );
",1,unused,2961,unused,"#line 437 ""stage1scan.l""
{
			if(yyleng-1 < MAXLINE)
        		 {
			strcpy( nmstr, yytext + 1 );
",unused,flexsources2.6.1-src2Fstage1scan.c
"			int cclval;

			if(yyleng < MAXLINE)
        		 {
			strcpy( nmstr, yytext );
",1,unused,3229,unused,"			int cclval;

			if(yyleng < MAXLINE)
        		 {
			strcpy( nmstr, yytext );
",unused,flexsources2.6.1-src2Fstage1scan.c
"            end_is_ws = end_ch != '}' ? 1 : 0;

 			if(yyleng-1 < MAXLINE)
         		 {
			strcpy( nmstr, yytext + 1 );
",1,unused,3298,unused,"            end_is_ws = end_ch != '}' ? 1 : 0;

 			if(yyleng-1 < MAXLINE)
         		 {
			strcpy( nmstr, yytext + 1 );
",unused,flexsources2.6.1-src2Fstage1scan.c
"               1;                                   /* NUL */
    t = malloc(tsz);
    if (!t)
      flexfatal (_(""Allocation of buffer for line directive failed""));
    for (dst = t + sprintf (t, ""#line %d \"""", lineno), src = filename; *src; *dst++ = *src++)
",1,unused,107,unused,"               1;                                   /* NUL */
    t = malloc(tsz);
    if (!t)
      flexfatal (_(""Allocation of buffer for line directive failed""));
    for (dst = t + sprintf (t, ""#line %d \"""", lineno), src = filename; *src; *dst++ = *src++)
",unused,flexxenpatch-src2Fbuf.c
"			reallocate_character_array (action_array,
						    action_size);
	}

	strcpy (&action_array[action_index], new_text);
",1,unused,161,unused,"			reallocate_character_array (action_array,
						    action_size);
	}

	strcpy (&action_array[action_index], new_text);
",unused,flexxenpatch-src2Fmisc.c
"#line 185 ""scan.l""
{
			if(yyleng < MAXLINE)
        		 {
			strcpy( nmstr, yytext );
",1,unused,2288,unused,"#line 185 ""scan.l""
{
			if(yyleng < MAXLINE)
        		 {
			strcpy( nmstr, yytext );
",unused,flexxenpatch-src2Fscan.c
"#line 293 ""scan.l""
{
 		        if(yyleng < MAXLINE)
 		         {
			strcpy( (char *) nmdef, yytext );
",1,unused,2521,unused,"#line 293 ""scan.l""
{
 		        if(yyleng < MAXLINE)
 		         {
			strcpy( (char *) nmdef, yytext );
",unused,flexxenpatch-src2Fscan.c
"#line 436 ""scan.l""
{
			if(yyleng-1 < MAXLINE)
        		 {
			strcpy( nmstr, yytext + 1 );
",1,unused,2968,unused,"#line 436 ""scan.l""
{
			if(yyleng-1 < MAXLINE)
        		 {
			strcpy( nmstr, yytext + 1 );
",unused,flexxenpatch-src2Fscan.c
"			int cclval;

			if(yyleng < MAXLINE)
        		 {
			strcpy( nmstr, yytext );
",1,unused,3237,unused,"			int cclval;

			if(yyleng < MAXLINE)
        		 {
			strcpy( nmstr, yytext );
",unused,flexxenpatch-src2Fscan.c
"            end_is_ws = end_ch != '}' ? 1 : 0;

 			if(yyleng-1 < MAXLINE)
         		 {
			strcpy( nmstr, yytext + 1 );
",1,unused,3306,unused,"            end_is_ws = end_ch != '}' ? 1 : 0;

 			if(yyleng-1 < MAXLINE)
         		 {
			strcpy( nmstr, yytext + 1 );
",unused,flexxenpatch-src2Fscan.c
"	    char_u	*s;

	    if (opt.jo_set & JO_IN_BUF)
	    {
		sprintf((char *)numbuf, ""%d"", opt.jo_io_buf[PART_IN]);
",1,unused,4102,unused,"	    char_u	*s;

	    if (opt.jo_set & JO_IN_BUF)
	    {
		sprintf((char *)numbuf, ""%d"", opt.jo_io_buf[PART_IN]);
",unused,gawkxenpatch-src2Fchannel.c
"
    list_hashtable_vars(&curbuf->b_vars->dv_hashtab, (char_u *)""b:"",
								 TRUE, first);

    sprintf((char *)numbuf, ""%ld"", (long)curbuf->b_changedtick);
",1,unused,2195,unused,"
    list_hashtable_vars(&curbuf->b_vars->dv_hashtab, (char_u *)""b:"",
								 TRUE, first);

    sprintf((char *)numbuf, ""%ld"", (long)curbuf->b_changedtick);
",unused,gawkxenpatch-src2Feval.c
"	    if (current_SID <= 0)
		*error = ERROR_SCRIPT;
	    else
	    {
		sprintf((char *)fname_buf + 3, ""%ld_"", (long)current_SID);
",1,unused,8808,unused,"	    if (current_SID <= 0)
		*error = ERROR_SCRIPT;
	    else
	    {
		sprintf((char *)fname_buf + 3, ""%ld_"", (long)current_SID);
",unused,gawkxenpatch-src2Feval.c
"	    ga_concat(gap, (char_u *)"" "");
    }
    if (sourcing_lnum > 0)
    {
	sprintf(buf, ""line %ld"", (long)sourcing_lnum);
",1,unused,9348,unused,"	    ga_concat(gap, (char_u *)"" "");
    }
    if (sourcing_lnum > 0)
    {
	sprintf(buf, ""line %ld"", (long)sourcing_lnum);
",unused,gawkxenpatch-src2Feval.c
"		    + 20				    /* for %3ld */
		    + STRLEN(s)));			    /* concatenated */
	if (r != NULL)
	{
	    sprintf((char *)r, txt, vimvars[VV_FOLDDASHES].vv_str,
",1,unused,11883,unused,"		    + 20				    /* for %3ld */
		    + STRLEN(s)));			    /* concatenated */
	if (r != NULL)
	{
	    sprintf((char *)r, txt, vimvars[VV_FOLDDASHES].vv_str,
",unused,gawkxenpatch-src2Feval.c
"	    /* Expand s: and <SID> into <SNR>nr_, so that the function can
	     * also be called from another script. Using trans_function_name()
	     * would also work, but some plugins depend on the name being
	     * printable text. */
	    sprintf(sid_buf, ""<SNR>%ld_"", (long)current_SID);
",1,unused,11996,unused,"	    /* Expand s: and <SID> into <SNR>nr_, so that the function can
	     * also be called from another script. Using trans_function_name()
	     * would also work, but some plugins depend on the name being
	     * printable text. */
	    sprintf(sid_buf, ""<SNR>%ld_"", (long)current_SID);
",unused,gawkxenpatch-src2Feval.c
"		    {
			list_append_number(l, (varnumber_T)llpos->col);
			list_append_number(l, (varnumber_T)llpos->len);
		    }
		    sprintf(buf, ""pos%d"", i + 1);
",1,unused,12778,unused,"		    {
			list_append_number(l, (varnumber_T)llpos->col);
			list_append_number(l, (varnumber_T)llpos->len);
		    }
		    sprintf(buf, ""pos%d"", i + 1);
",unused,gawkxenpatch-src2Feval.c
"	case MLINE: buf[0] = 'V'; break;
	case MCHAR: buf[0] = 'v'; break;
	case MBLOCK:
		buf[0] = Ctrl_V;
		sprintf((char *)buf + 1, ""%ld"", reglen + 1);
",1,unused,12988,unused,"	case MLINE: buf[0] = 'V'; break;
	case MCHAR: buf[0] = 'v'; break;
	case MBLOCK:
		buf[0] = Ctrl_V;
		sprintf((char *)buf + 1, ""%ld"", reglen + 1);
",unused,gawkxenpatch-src2Feval.c
"	dictitem_T	v;
	char_u		str[30];
	char_u		*idvar;

	sprintf((char *)str, PRINTF_HEX_LONG_U, (long_u)w);
",1,unused,16625,unused,"	dictitem_T	v;
	char_u		str[30];
	char_u		*idvar;

	sprintf((char *)str, PRINTF_HEX_LONG_U, (long_u)w);
",unused,gawkxenpatch-src2Feval.c
"    pat2 = alloc((unsigned)(STRLEN(spat) + STRLEN(epat) + 15));
    pat3 = alloc((unsigned)(STRLEN(spat) + STRLEN(mpat) + STRLEN(epat) + 23));
    if (pat2 == NULL || pat3 == NULL)
	goto theend;
    sprintf((char *)pat2, ""\\(%s\\m\\)\\|\\(%s\\m\\)"", spat, epat);
",1,unused,17624,unused,"    pat2 = alloc((unsigned)(STRLEN(spat) + STRLEN(epat) + 15));
    pat3 = alloc((unsigned)(STRLEN(spat) + STRLEN(mpat) + STRLEN(epat) + 23));
    if (pat2 == NULL || pat3 == NULL)
	goto theend;
    sprintf((char *)pat2, ""\\(%s\\m\\)\\|\\(%s\\m\\)"", spat, epat);
",unused,gawkxenpatch-src2Feval.c
"    sprintf((char *)pat2, ""\\(%s\\m\\)\\|\\(%s\\m\\)"", spat, epat);
    if (*mpat == NUL)
	STRCPY(pat3, pat2);
    else
	sprintf((char *)pat3, ""\\(%s\\m\\)\\|\\(%s\\m\\)\\|\\(%s\\m\\)"",
",1,unused,17628,unused,"    sprintf((char *)pat2, ""\\(%s\\m\\)\\|\\(%s\\m\\)"", spat, epat);
    if (*mpat == NUL)
	STRCPY(pat3, pat2);
    else
	sprintf((char *)pat3, ""\\(%s\\m\\)\\|\\(%s\\m\\)\\|\\(%s\\m\\)"",
",unused,gawkxenpatch-src2Feval.c
"
		/* match from matchaddpos() */
		for (i = 1; i < 9; i++)
		{
		    sprintf((char *)buf, (char *)""pos%d"", i);
",1,unused,18154,unused,"
		/* match from matchaddpos() */
		for (i = 1; i < 9; i++)
		{
		    sprintf((char *)buf, (char *)""pos%d"", i);
",unused,gawkxenpatch-src2Feval.c
"
    ga_init2(&ga, (int)sizeof(char), 70);
    for (wp = firstwin; wp != NULL; wp = wp->w_next)
    {
	sprintf((char *)buf, ""%dresize %d|"", winnr, wp->w_height);
",1,unused,20786,unused,"
    ga_init2(&ga, (int)sizeof(char), 70);
    for (wp = firstwin; wp != NULL; wp = wp->w_next)
    {
	sprintf((char *)buf, ""%dresize %d|"", winnr, wp->w_height);
",unused,gawkxenpatch-src2Feval.c
"    for (wp = firstwin; wp != NULL; wp = wp->w_next)
    {
	sprintf((char *)buf, ""%dresize %d|"", winnr, wp->w_height);
	ga_concat(&ga, buf);
	sprintf((char *)buf, ""vert %dresize %d|"", winnr, wp->w_width);
",1,unused,20788,unused,"    for (wp = firstwin; wp != NULL; wp = wp->w_next)
    {
	sprintf((char *)buf, ""%dresize %d|"", winnr, wp->w_height);
	ga_concat(&ga, buf);
	sprintf((char *)buf, ""vert %dresize %d|"", winnr, wp->w_width);
",unused,gawkxenpatch-src2Feval.c
"    if (newval == NULL)
	return NULL;

    if (eap->force_bin == FORCE_BIN)
	sprintf((char *)newval, "" ++bin"");
",1,unused,21723,unused,"    if (newval == NULL)
	return NULL;

    if (eap->force_bin == FORCE_BIN)
	sprintf((char *)newval, "" ++bin"");
",unused,gawkxenpatch-src2Feval.c
"
    if (eap->force_bin == FORCE_BIN)
	sprintf((char *)newval, "" ++bin"");
    else if (eap->force_bin == FORCE_NOBIN)
	sprintf((char *)newval, "" ++nobin"");
",1,unused,21725,unused,"
    if (eap->force_bin == FORCE_BIN)
	sprintf((char *)newval, "" ++bin"");
    else if (eap->force_bin == FORCE_NOBIN)
	sprintf((char *)newval, "" ++nobin"");
",unused,gawkxenpatch-src2Feval.c
"    if (eap->read_edit)
	STRCAT(newval, "" ++edit"");

    if (eap->force_ff != 0)
	sprintf((char *)newval + STRLEN(newval), "" ++ff=%s"",
",1,unused,21733,unused,"    if (eap->read_edit)
	STRCAT(newval, "" ++edit"");

    if (eap->force_ff != 0)
	sprintf((char *)newval + STRLEN(newval), "" ++ff=%s"",
",unused,gawkxenpatch-src2Feval.c
"	sprintf((char *)newval + STRLEN(newval), "" ++ff=%s"",
						eap->cmd + eap->force_ff);
# ifdef FEAT_MBYTE
    if (eap->force_enc != 0)
	sprintf((char *)newval + STRLEN(newval), "" ++enc=%s"",
",1,unused,21737,unused,"	sprintf((char *)newval + STRLEN(newval), "" ++ff=%s"",
						eap->cmd + eap->force_ff);
# ifdef FEAT_MBYTE
    if (eap->force_enc != 0)
	sprintf((char *)newval + STRLEN(newval), "" ++enc=%s"",
",unused,gawkxenpatch-src2Feval.c
"	STRCPY(newval + STRLEN(newval), "" ++bad=keep"");
    else if (eap->bad_char == BAD_DROP)
	STRCPY(newval + STRLEN(newval), "" ++bad=drop"");
    else if (eap->bad_char != 0)
	sprintf((char *)newval + STRLEN(newval), "" ++bad=%c"", eap->bad_char);
",1,unused,21744,unused,"	STRCPY(newval + STRLEN(newval), "" ++bad=keep"");
    else if (eap->bad_char == BAD_DROP)
	STRCPY(newval + STRLEN(newval), "" ++bad=drop"");
    else if (eap->bad_char != 0)
	sprintf((char *)newval + STRLEN(newval), "" ++bad=%c"", eap->bad_char);
",unused,gawkxenpatch-src2Feval.c
"{
    switch (varp->v_type)
    {
	case VAR_NUMBER:
	    sprintf((char *)buf, ""%ld"", (long)varp->vval.v_number);
",1,unused,22301,unused,"{
    switch (varp->v_type)
    {
	case VAR_NUMBER:
	    sprintf((char *)buf, ""%ld"", (long)varp->vval.v_number);
",unused,gawkxenpatch-src2Feval.c
"
	/* Give the function a sequential number.  Can only be used with a
	 * Funcref! */
	vim_free(name);
	sprintf(numbuf, ""%d"", ++func_nr);
",1,unused,23915,unused,"
	/* Give the function a sequential number.  Can only be used with a
	 * Funcref! */
	vim_free(name);
	sprintf(numbuf, ""%d"", ++func_nr);
",unused,gawkxenpatch-src2Feval.c
"	    {
		EMSG(_(e_usingsid));
		goto theend;
	    }
	    sprintf((char *)sid_buf, ""%ld_"", (long)current_SID);
",1,unused,24204,unused,"	    {
		EMSG(_(e_usingsid));
		goto theend;
	    }
	    sprintf((char *)sid_buf, ""%ld_"", (long)current_SID);
",unused,gawkxenpatch-src2Feval.c
"	    name = FUNCARG(fp, i);
	else
	{
	    /* ""..."" argument a:1, a:2, etc. */
	    sprintf((char *)numbuf, ""%d"", ai + 1);
",1,unused,24978,unused,"	    name = FUNCARG(fp, i);
	else
	{
	    /* ""..."" argument a:1, a:2, etc. */
	    sprintf((char *)numbuf, ""%d"", ai + 1);
",unused,gawkxenpatch-src2Feval.c
"    if (sourcing_name != NULL)
    {
	if (save_sourcing_name != NULL
			  && STRNCMP(save_sourcing_name, ""function "", 9) == 0)
	    sprintf((char *)sourcing_name, ""%s[%d].."",
",1,unused,25023,unused,"    if (sourcing_name != NULL)
    {
	if (save_sourcing_name != NULL
			  && STRNCMP(save_sourcing_name, ""function "", 9) == 0)
	    sprintf((char *)sourcing_name, ""%s[%d].."",
",unused,gawkxenpatch-src2Feval.c
"	    if (s == NULL)
		got_int = TRUE;
	    else
	    {
		sprintf((char *)s, ""help-tags\t%s\t1\n"", tagfname);
",1,unused,6663,unused,"	    if (s == NULL)
		got_int = TRUE;
	    else
	    {
		sprintf((char *)s, ""help-tags\t%s\t1\n"", tagfname);
",unused,gawkxenpatch-src2Fex_cmds.c
"			    break;
			}
			((char_u **)ga.ga_data)[ga.ga_len] = s;
			++ga.ga_len;
			sprintf((char *)s, ""%s\t%s"", p1, fname);
",1,unused,6759,unused,"			    break;
			}
			((char_u **)ga.ga_data)[ga.ga_len] = s;
			++ga.ga_len;
			sprintf((char *)s, ""%s\t%s"", p1, fname);
",unused,gawkxenpatch-src2Fex_cmds.c
"
		    cmd = alloc((unsigned)STRLEN(buf->b_fname) + 25);
		    if (cmd == NULL)
			return;
		    sprintf((char *)cmd, ""e +%ld %s"", (long)lnum, buf->b_fname);
",1,unused,7403,unused,"
		    cmd = alloc((unsigned)STRLEN(buf->b_fname) + 25);
		    if (cmd == NULL)
			return;
		    sprintf((char *)cmd, ""e +%ld %s"", (long)lnum, buf->b_fname);
",unused,gawkxenpatch-src2Fex_cmds.c
"
    QueryPerformanceFrequency(&fr);
    sprintf(buf, ""%10.6lf"", (double)tm->QuadPart / (double)fr.QuadPart);
# else
    sprintf(buf, ""%3ld.%06ld"", (long)tm->tv_sec, (long)tm->tv_usec);
",1,unused,1003,unused,"
    QueryPerformanceFrequency(&fr);
    sprintf(buf, ""%10.6lf"", (double)tm->QuadPart / (double)fr.QuadPart);
# else
    sprintf(buf, ""%3ld.%06ld"", (long)tm->tv_sec, (long)tm->tv_usec);
",unused,gawkxenpatch-src2Fex_cmds2.c
"	    }
	    do_unlet((char_u *)""g:current_compiler"", TRUE);
	    do_unlet((char_u *)""b:current_compiler"", TRUE);

	    sprintf((char *)buf, ""compiler/%s.vim"", eap->arg);
",1,unused,3042,unused,"	    }
	    do_unlet((char_u *)""g:current_compiler"", TRUE);
	    do_unlet((char_u *)""b:current_compiler"", TRUE);

	    sprintf((char *)buf, ""compiler/%s.vim"", eap->arg);
",unused,gawkxenpatch-src2Fex_cmds2.c
"	    {
		if (a & COUNT)
		{
		    /* -count=N */
		    sprintf((char *)IObuff + len, ""%ldc"", cmd->uc_def);
",1,unused,5934,unused,"	    {
		if (a & COUNT)
		{
		    /* -count=N */
		    sprintf((char *)IObuff + len, ""%ldc"", cmd->uc_def);
",unused,gawkxenpatch-src2Fex_docmd.c
"		    IObuff[len++] = '%';
		else if (cmd->uc_def >= 0)
		{
		    /* -range=N */
		    sprintf((char *)IObuff + len, ""%ld"", cmd->uc_def);
",1,unused,5942,unused,"		    IObuff[len++] = '%';
		else if (cmd->uc_def >= 0)
		{
		    /* -range=N */
		    sprintf((char *)IObuff + len, ""%ld"", cmd->uc_def);
",unused,gawkxenpatch-src2Fex_docmd.c
"		   (type == ct_LINE2) ? eap->line2 :
		   (eap->addr_count > 0) ? eap->line2 : cmd->uc_def;
	size_t num_len;

	sprintf(num_buf, ""%ld"", num);
",1,unused,6568,unused,"		   (type == ct_LINE2) ? eap->line2 :
		   (eap->addr_count > 0) ? eap->line2 : cmd->uc_def;
	size_t num_len;

	sprintf(num_buf, ""%ld"", num);
",unused,gawkxenpatch-src2Fex_docmd.c
"#  else
	if (mch_get_winpos(&x, &y) != FAIL)
#  endif
	{
	    sprintf((char *)IObuff, _(""Window position: X %d, Y %d""), x, y);
",1,unused,9005,unused,"#  else
	if (mch_get_winpos(&x, &y) != FAIL)
#  endif
	{
	    sprintf((char *)IObuff, _(""Window position: X %d, Y %d""), x, y);
",unused,gawkxenpatch-src2Fex_docmd.c
"		{
		    *errormsg = (char_u *)_(""E496: no autocommand buffer number to substitute for \""<abuf>\"""");
		    return NULL;
		}
		sprintf((char *)strbuf, ""%d"", autocmd_bufnr);
",1,unused,10522,unused,"		{
		    *errormsg = (char_u *)_(""E496: no autocommand buffer number to substitute for \""<abuf>\"""");
		    return NULL;
		}
		sprintf((char *)strbuf, ""%d"", autocmd_bufnr);
",unused,gawkxenpatch-src2Fex_docmd.c
"		{
		    *errormsg = (char_u *)_(""E842: no line number to use for \""<slnum>\"""");
		    return NULL;
		}
		sprintf((char *)strbuf, ""%ld"", (long)sourcing_lnum);
",1,unused,10550,unused,"		{
		    *errormsg = (char_u *)_(""E842: no line number to use for \""<slnum>\"""");
		    return NULL;
		}
		sprintf((char *)strbuf, ""%ld"", (long)sourcing_lnum);
",unused,gawkxenpatch-src2Fex_docmd.c
"		result = strbuf;
		break;
#if defined(FEAT_CLIENTSERVER)
	case SPEC_CLIENT:	/* Source of last submitted input */
		sprintf((char *)strbuf, PRINTF_HEX_LONG_U,
",1,unused,10555,unused,"		result = strbuf;
		break;
#if defined(FEAT_CLIENTSERVER)
	case SPEC_CLIENT:	/* Source of last submitted input */
		sprintf((char *)strbuf, PRINTF_HEX_LONG_U,
",unused,gawkxenpatch-src2Fex_docmd.c
"			continue;

		    STRCAT(val, p);
		    p[-2] = NUL;
		    sprintf((char *)(val + STRLEN(p)), "" (%s)"", &mesg[1]);
",1,unused,482,unused,"			continue;

		    STRCAT(val, p);
		    p[-2] = NUL;
		    sprintf((char *)(val + STRLEN(p)), "" (%s)"", &mesg[1]);
",unused,gawkxenpatch-src2Fex_eval.c
"    }

    args[0] = vim_strnsave(xp->xp_pattern, xp->xp_pattern_len);
    args[1] = xp->xp_line;
    sprintf((char *)num, ""%d"", xp->xp_col);
",1,unused,5031,unused,"    }

    args[0] = vim_strnsave(xp->xp_pattern, xp->xp_pattern_len);
    args[1] = xp->xp_line;
    sprintf((char *)num, ""%d"", xp->xp_col);
",unused,gawkxenpatch-src2Fex_getln.c
"	{
	    ga_clear_strings(&ga);
	    return FAIL;
	}
	sprintf((char *)s, ""%s/%s*.vim"", dirnames[i], pat);
",1,unused,5181,unused,"	{
	    ga_clear_strings(&ga);
	    return FAIL;
	}
	sprintf((char *)s, ""%s/%s*.vim"", dirnames[i], pat);
",unused,gawkxenpatch-src2Fex_getln.c
"	    {
		ga_clear_strings(&ga);
		return FAIL;
	    }
	    sprintf((char *)s, ""pack/*/start/*/%s/%s*.vim"", dirnames[i], pat);
",1,unused,5195,unused,"	    {
		ga_clear_strings(&ga);
		return FAIL;
	    }
	    sprintf((char *)s, ""pack/*/start/*/%s/%s*.vim"", dirnames[i], pat);
",unused,gawkxenpatch-src2Fex_getln.c
"	    {
		ga_clear_strings(&ga);
		return FAIL;
	    }
	    sprintf((char *)s, ""pack/*/opt/*/%s/%s*.vim"", dirnames[i], pat);
",1,unused,5210,unused,"	    {
		ga_clear_strings(&ga);
		return FAIL;
	    }
	    sprintf((char *)s, ""pack/*/opt/*/%s/%s*.vim"", dirnames[i], pat);
",unused,gawkxenpatch-src2Fex_getln.c
"    {
	ga_clear_strings(&ga);
	return FAIL;
    }
    sprintf((char *)s, ""pack/*/opt/%s*"", pat);
",1,unused,5273,unused,"    {
	ga_clear_strings(&ga);
	return FAIL;
    }
    sprintf((char *)s, ""pack/*/opt/%s*"", pat);
",unused,gawkxenpatch-src2Fex_getln.c
"		if (hist[i].hisstr != NULL
			&& hist[i].hisnum >= j && hist[i].hisnum <= k)
		{
		    msg_putchar('\n');
		    sprintf((char *)IObuff, ""%c%6d  "", i == idx ? '>' : ' ',
",1,unused,6107,unused,"		if (hist[i].hisstr != NULL
			&& hist[i].hisnum >= j && hist[i].hisnum <= k)
		{
		    msg_putchar('\n');
		    sprintf((char *)IObuff, ""%c%6d  "", i == idx ? '>' : ' ',
",unused,gawkxenpatch-src2Fex_getln.c
"#endif
#ifdef FEAT_MBYTE
	    if (conv_error != 0)
	    {
		sprintf((char *)IObuff + STRLEN(IObuff),
",1,unused,2520,unused,"#endif
#ifdef FEAT_MBYTE
	    if (conv_error != 0)
	    {
		sprintf((char *)IObuff + STRLEN(IObuff),
",unused,gawkxenpatch-src2Ffileio.c
"		c = TRUE;
	    }
	    else if (illegal_byte > 0)
	    {
		sprintf((char *)IObuff + STRLEN(IObuff),
",1,unused,2526,unused,"		c = TRUE;
	    }
	    else if (illegal_byte > 0)
	    {
		sprintf((char *)IObuff + STRLEN(IObuff),
",unused,gawkxenpatch-src2Ffileio.c
"    if (eap->cmd == NULL)
	return FAIL;

#ifdef FEAT_MBYTE
    sprintf((char *)eap->cmd, ""e ++ff=%s ++enc=%s"", buf->b_p_ff, buf->b_p_fenc);
",1,unused,2750,unused,"    if (eap->cmd == NULL)
	return FAIL;

#ifdef FEAT_MBYTE
    sprintf((char *)eap->cmd, ""e ++ff=%s ++enc=%s"", buf->b_p_ff, buf->b_p_fenc);
",unused,gawkxenpatch-src2Ffileio.c
"		 */
		STRCPY(IObuff, fname);
		for (i = 4913; ; i += 123)
		{
		    sprintf((char *)gettail(IObuff), ""%d"", i);
",1,unused,3699,unused,"		 */
		STRCPY(IObuff, fname);
		for (i = 4913; ; i += 123)
		{
		    sprintf((char *)gettail(IObuff), ""%d"", i);
",unused,gawkxenpatch-src2Ffileio.c
"
    if (insert_space)
	*p++ = ' ';
    if (shortmess(SHM_LINES))
	sprintf((char *)p,
",1,unused,5208,unused,"
    if (insert_space)
	*p++ = ' ';
    if (shortmess(SHM_LINES))
	sprintf((char *)p,
",unused,gawkxenpatch-src2Ffileio.c
"    {
	if (lnum == 1)
	    STRCPY(p, _(""1 line, ""));
	else
	    sprintf((char *)p, _(""%ld lines, ""), lnum);
",1,unused,5221,unused,"    {
	if (lnum == 1)
	    STRCPY(p, _(""1 line, ""));
	else
	    sprintf((char *)p, _(""%ld lines, ""), lnum);
",unused,gawkxenpatch-src2Ffileio.c
"	p += STRLEN(p);
	if (nchars == 1)
	    STRCPY(p, _(""1 character""));
	else
	    sprintf((char *)p,
",1,unused,5226,unused,"	p += STRLEN(p);
	if (nchars == 1)
	    STRCPY(p, _(""1 character""));
	else
	    sprintf((char *)p,
",unused,gawkxenpatch-src2Ffileio.c
"	    return -1;
	STRCPY(tempname, from);
	for (n = 123; n < 99999; ++n)
	{
	    sprintf((char *)gettail((char_u *)tempname), ""%d"", n);
",1,unused,6487,unused,"	    return -1;
	STRCPY(tempname, from);
	for (n = 123; n < 99999; ++n)
	{
	    sprintf((char *)gettail((char_u *)tempname), ""%d"", n);
",unused,gawkxenpatch-src2Ffileio.c
"	    if (!helpmesg)
		mesg2 = """";
	    tbuf = alloc((unsigned)(STRLEN(path) + STRLEN(mesg)
							+ STRLEN(mesg2) + 2));
	    sprintf((char *)tbuf, mesg, path);
",1,unused,6930,unused,"	    if (!helpmesg)
		mesg2 = """";
	    tbuf = alloc((unsigned)(STRLEN(path) + STRLEN(mesg)
							+ STRLEN(mesg2) + 2));
	    sprintf((char *)tbuf, mesg, path);
",unused,gawkxenpatch-src2Ffileio.c
"    if (vim_tempdir != NULL)
    {
	/* There is no need to check if the file exists, because we own the
	 * directory and nobody else creates a file in it. */
	sprintf((char *)itmp, ""%s%ld"", vim_tempdir, temp_count++);
",1,unused,7429,unused,"    if (vim_tempdir != NULL)
    {
	/* There is no need to check if the file exists, because we own the
	 * directory and nobody else creates a file in it. */
	sprintf((char *)itmp, ""%s%ld"", vim_tempdir, temp_count++);
",unused,gawkxenpatch-src2Ffileio.c
"
	if (is_buflocal)
	{
	    /* normalize pat into standard ""<buffer>#N"" form */
	    sprintf((char *)buflocal_pat, ""<buffer=%d>"", buflocal_nr);
",1,unused,8500,unused,"
	if (is_buflocal)
	{
	    /* normalize pat into standard ""<buffer>#N"" form */
	    sprintf((char *)buflocal_pat, ""<buffer=%d>"", buflocal_nr);
",unused,gawkxenpatch-src2Ffileio.c
"		sourcing_name = alloc((unsigned)(STRLEN(s)
					    + STRLEN(name) + ap->patlen + 1));
		if (sourcing_name != NULL)
		{
		    sprintf((char *)sourcing_name, s,
",1,unused,9621,unused,"		sourcing_name = alloc((unsigned)(STRLEN(s)
					    + STRLEN(name) + ap->patlen + 1));
		if (sourcing_name != NULL)
		{
		    sprintf((char *)sourcing_name, s,
",unused,gawkxenpatch-src2Ffileio.c
"    }
    if (text == NULL)
#endif
    {
	sprintf((char *)buf, _(""+--%3ld lines folded ""),
",1,unused,1960,unused,"    }
    if (text == NULL)
#endif
    {
	sprintf((char *)buf, _(""+--%3ld lines folded ""),
",unused,gawkxenpatch-src2Ffold.c
"add_num_buff(buffheader_T *buf, long n)
{
    char_u	number[32];

    sprintf((char *)number, ""%ld"", n);
",1,unused,295,unused,"add_num_buff(buffheader_T *buf, long n)
{
    char_u	number[32];

    sprintf((char *)number, ""%ld"", n);
",unused,gawkxenpatch-src2Fgetchar.c
"		i = getdigits(&p);
		if (i != 0)
		{
		    /* Double the width specification. */
		    sprintf((char *)wp, ""%d%s"", i * 2, p);
",1,unused,951,unused,"		i = getdigits(&p);
		if (i != 0)
		{
		    /* Double the width specification. */
		    sprintf((char *)wp, ""%d%s"", i * 2, p);
",unused,gawkxenpatch-src2Fgui.c
"    if (strcmp(path, SFcurrentDir))
    {
	result = mch_chdir(path);
	if (!result)
	    (void) strcpy(SFcurrentDir, path);
",1,unused,253,unused,"    if (strcmp(path, SFcurrentDir))
    {
	result = mch_chdir(path);
	if (!result)
	    (void) strcpy(SFcurrentDir, path);
",unused,gawkxenpatch-src2Fgui_at_fs.c
"
    static void
SFstrdup(char **s1, char *s2)
{
    *s1 = strcpy(XtMalloc((unsigned)(strlen(s2) + 1)), s2);
",1,unused,287,unused,"
    static void
SFstrdup(char **s1, char *s2)
{
    *s1 = strcpy(XtMalloc((unsigned)(strlen(s2) + 1)), s2);
",unused,gawkxenpatch-src2Fgui_at_fs.c
"
    *(dir->path) = 0;
    len = strlen(str);
    if (str[len - 1] == '/')
	(void) strcat(SFcurrentPath, str);
",1,unused,315,unused,"
    *(dir->path) = 0;
    len = strlen(str);
    if (str[len - 1] == '/')
	(void) strcat(SFcurrentPath, str);
",unused,gawkxenpatch-src2Fgui_at_fs.c
"    i = 1;
    entries = (SFEntry *)XtMalloc(sizeof(SFEntry));
    SFlogins = (SFLogin *)XtMalloc(sizeof(SFLogin));
    entries[0].real = XtMalloc(3);
    (void) strcpy(entries[0].real, ""~"");
",1,unused,520,unused,"    i = 1;
    entries = (SFEntry *)XtMalloc(sizeof(SFEntry));
    SFlogins = (SFLogin *)XtMalloc(sizeof(SFLogin));
    entries[0].real = XtMalloc(3);
    (void) strcpy(entries[0].real, ""~"");
",unused,gawkxenpatch-src2Fgui_at_fs.c
"					 (unsigned)(Alloc * sizeof(SFLogin)));
	}
	len = strlen(pw->pw_name);
	entries[i].real = XtMalloc((unsigned) (len + 3));
	(void) strcat(strcpy(entries[i].real, ""~""), pw->pw_name);
",1,unused,542,unused,"					 (unsigned)(Alloc * sizeof(SFLogin)));
	}
	len = strlen(pw->pw_name);
	entries[i].real = XtMalloc((unsigned) (len + 3));
	(void) strcat(strcpy(entries[i].real, ""~""), pw->pw_name);
",unused,gawkxenpatch-src2Fgui_at_fs.c
"					 (unsigned)(Alloc * sizeof(SFLogin)));
	}
	len = strlen(pw->pw_name);
	entries[i].real = XtMalloc((unsigned) (len + 3));
	(void) strcat(strcpy(entries[i].real, ""~""), pw->pw_name);
",1,unused,542,unused,"					 (unsigned)(Alloc * sizeof(SFLogin)));
	}
	len = strlen(pw->pw_name);
	entries[i].real = XtMalloc((unsigned) (len + 3));
	(void) strcat(strcpy(entries[i].real, ""~""), pw->pw_name);
",unused,gawkxenpatch-src2Fgui_at_fs.c
"    qsort((char *)entries, (size_t)i, sizeof(SFEntry), SFcompareEntries);
    qsort((char *)SFlogins, (size_t)i, sizeof(SFLogin), SFcompareLogins);

    for (i--; i >= 0; i--)
	(void)strcat(entries[i].real, ""/"");
",1,unused,568,unused,"    qsort((char *)entries, (size_t)i, sizeof(SFEntry), SFcompareEntries);
    qsort((char *)SFlogins, (size_t)i, sizeof(SFLogin), SFcompareLogins);

    for (i--; i >= 0; i--)
	(void)strcat(entries[i].real, ""/"");
",unused,gawkxenpatch-src2Fgui_at_fs.c
"	if (!strcmp(SFhomeDir.entries[i].real, begin))
	{
	    *end = save;
	    SFstrdup(&theRest, end);
	    (void) strcat(strcat(strcpy(SFcurrentPath,
",1,unused,589,unused,"	if (!strcmp(SFhomeDir.entries[i].real, begin))
	{
	    *end = save;
	    SFstrdup(&theRest, end);
	    (void) strcat(strcat(strcpy(SFcurrentPath,
",unused,gawkxenpatch-src2Fgui_at_fs.c
"	if (!strcmp(SFhomeDir.entries[i].real, begin))
	{
	    *end = save;
	    SFstrdup(&theRest, end);
	    (void) strcat(strcat(strcpy(SFcurrentPath,
",1,unused,589,unused,"	if (!strcmp(SFhomeDir.entries[i].real, begin))
	{
	    *end = save;
	    SFstrdup(&theRest, end);
	    (void) strcat(strcat(strcpy(SFcurrentPath,
",unused,gawkxenpatch-src2Fgui_at_fs.c
"	if (!strcmp(SFhomeDir.entries[i].real, begin))
	{
	    *end = save;
	    SFstrdup(&theRest, end);
	    (void) strcat(strcat(strcpy(SFcurrentPath,
",1,unused,589,unused,"	if (!strcmp(SFhomeDir.entries[i].real, begin))
	{
	    *end = save;
	    SFstrdup(&theRest, end);
	    (void) strcat(strcat(strcpy(SFcurrentPath,
",unused,gawkxenpatch-src2Fgui_at_fs.c
"			int len;

			len = strlen(shown);
			entry->shown = XtMalloc((unsigned) (len + 2));
			(void) strcpy(entry->shown, shown);
",1,unused,1366,unused,"			int len;

			len = strlen(shown);
			entry->shown = XtMalloc((unsigned) (len + 2));
			(void) strcpy(entry->shown, shown);
",unused,gawkxenpatch-src2Fgui_at_fs.c
"	result[i].statDone = 0;
	str = dp->d_name;
	len = strlen(str);
	result[i].real = XtMalloc((unsigned) (len + 2));
	(void) strcat(strcpy(result[i].real, str), "" "");
",1,unused,2095,unused,"	result[i].statDone = 0;
	str = dp->d_name;
	len = strlen(str);
	result[i].real = XtMalloc((unsigned) (len + 2));
	(void) strcat(strcpy(result[i].real, str), "" "");
",unused,gawkxenpatch-src2Fgui_at_fs.c
"	result[i].statDone = 0;
	str = dp->d_name;
	len = strlen(str);
	result[i].real = XtMalloc((unsigned) (len + 2));
	(void) strcat(strcpy(result[i].real, str), "" "");
",1,unused,2095,unused,"	result[i].statDone = 0;
	str = dp->d_name;
	len = strlen(str);
	result[i].real = XtMalloc((unsigned) (len + 2));
	(void) strcat(strcpy(result[i].real, str), "" "");
",unused,gawkxenpatch-src2Fgui_at_fs.c
"	    SFtextPos = XawTextGetInsertionPoint(selFileField);
	}
	else
	{
	    strcpy(SFcurrentPath, SFstartDir);
",1,unused,2637,unused,"	    SFtextPos = XawTextGetInsertionPoint(selFileField);
	}
	else
	{
	    strcpy(SFcurrentPath, SFstartDir);
",unused,gawkxenpatch-src2Fgui_at_fs.c
"    else
#endif
    if ((SFtextBuffer[0] == '/') || (SFtextBuffer[0] == '~'))
    {
	(void) strcpy(SFcurrentPath, SFtextBuffer);
",1,unused,2647,unused,"    else
#endif
    if ((SFtextBuffer[0] == '/') || (SFtextBuffer[0] == '~'))
    {
	(void) strcpy(SFcurrentPath, SFtextBuffer);
",unused,gawkxenpatch-src2Fgui_at_fs.c
"	SFtextPos = XawTextGetInsertionPoint(selFileField);
    }
    else
    {
	(void) strcat(strcpy(SFcurrentPath, SFstartDir), SFtextBuffer);
",1,unused,2652,unused,"	SFtextPos = XawTextGetInsertionPoint(selFileField);
    }
    else
    {
	(void) strcat(strcpy(SFcurrentPath, SFstartDir), SFtextBuffer);
",unused,gawkxenpatch-src2Fgui_at_fs.c
"	SFtextPos = XawTextGetInsertionPoint(selFileField);
    }
    else
    {
	(void) strcat(strcpy(SFcurrentPath, SFstartDir), SFtextBuffer);
",1,unused,2652,unused,"	SFtextPos = XawTextGetInsertionPoint(selFileField);
    }
    else
    {
	(void) strcat(strcpy(SFcurrentPath, SFstartDir), SFtextBuffer);
",unused,gawkxenpatch-src2Fgui_at_fs.c
"
    XtVaSetValues(selFile, XtNx, x, XtNy, y, NULL);
    XtMapWidget(selFile);

    (void)strcat(SFstartDir, ""/"");
",1,unused,2750,unused,"
    XtVaSetValues(selFile, XtNx, x, XtNy, y, NULL);
    XtMapWidget(selFile);

    (void)strcat(SFstartDir, ""/"");
",unused,gawkxenpatch-src2Fgui_at_fs.c
"    XtVaSetValues(selFile, XtNx, x, XtNy, y, NULL);
    XtMapWidget(selFile);

    (void)strcat(SFstartDir, ""/"");
    (void)strcpy(SFcurrentDir, SFstartDir);
",1,unused,2751,unused,"    XtVaSetValues(selFile, XtNx, x, XtNy, y, NULL);
    XtMapWidget(selFile);

    (void)strcat(SFstartDir, ""/"");
    (void)strcpy(SFcurrentDir, SFstartDir);
",unused,gawkxenpatch-src2Fgui_at_fs.c
"    if (init_path)
    {
	if (init_path[0] == '/')
	{
	    (void)strcpy(SFcurrentPath, init_path);
",1,unused,2757,unused,"    if (init_path)
    {
	if (init_path[0] == '/')
	{
	    (void)strcpy(SFcurrentPath, init_path);
",unused,gawkxenpatch-src2Fgui_at_fs.c
"		SFsetText(&(SFcurrentPath[strlen(SFstartDir)]));
	}
	else
	{
	    (void)strcat(strcpy(SFcurrentPath, SFstartDir), init_path);
",1,unused,2765,unused,"		SFsetText(&(SFcurrentPath[strlen(SFstartDir)]));
	}
	else
	{
	    (void)strcat(strcpy(SFcurrentPath, SFstartDir), init_path);
",unused,gawkxenpatch-src2Fgui_at_fs.c
"		SFsetText(&(SFcurrentPath[strlen(SFstartDir)]));
	}
	else
	{
	    (void)strcat(strcpy(SFcurrentPath, SFstartDir), init_path);
",1,unused,2765,unused,"		SFsetText(&(SFcurrentPath[strlen(SFstartDir)]));
	}
	else
	{
	    (void)strcat(strcpy(SFcurrentPath, SFstartDir), init_path);
",unused,gawkxenpatch-src2Fgui_at_fs.c
"	    SFsetText(&(SFcurrentPath[strlen(SFstartDir)]));
	}
    }
    else
	(void)strcpy(SFcurrentPath, SFstartDir);
",1,unused,2770,unused,"	    SFsetText(&(SFcurrentPath[strlen(SFstartDir)]));
	}
    }
    else
	(void)strcpy(SFcurrentPath, SFstartDir);
",unused,gawkxenpatch-src2Fgui_at_fs.c
"
    pname = vim_strnsave(name, STRLEN(name) + strlen(""-pullright""));
    if (pname != NULL)
    {
	strcat((char *)pname, ""-pullright"");
",1,unused,1141,unused,"
    pname = vim_strnsave(name, STRLEN(name) + strlen(""-pullright""));
    if (pname != NULL)
    {
	strcat((char *)pname, ""-pullright"");
",unused,gawkxenpatch-src2Fgui_athena.c
"    mch_print_start_line(TRUE, page_line);

    /* Leave two spaces between the number and the text; depends on
     * PRINT_NUMBER_WIDTH. */
    sprintf((char *)tbuf, ""%6ld"", (long)lnum);
",1,unused,374,unused,"    mch_print_start_line(TRUE, page_line);

    /* Leave two spaces between the number and the text; depends on
     * PRINT_NUMBER_WIDTH. */
    sprintf((char *)tbuf, ""%6ld"", (long)lnum);
",unused,gawkxenpatch-src2Fhardcopy.c
"	curwin->w_botline = tmp_botline;
    }
    else
#endif
	sprintf((char *)tbuf, _(""Page %d""), pagenum);
",1,unused,493,unused,"	curwin->w_botline = tmp_botline;
    }
    else
#endif
	sprintf((char *)tbuf, _(""Page %d""), pagenum);
",unused,gawkxenpatch-src2Fhardcopy.c
"		    ui_breakcheck();
		    if (got_int || settings.user_abort)
			goto print_fail;

		    sprintf((char *)IObuff, _(""Printing page %d (%d%%)""),
",1,unused,726,unused,"		    ui_breakcheck();
		    if (got_int || settings.user_abort)
			goto print_fail;

		    sprintf((char *)IObuff, _(""Printing page %d (%d%%)""),
",unused,gawkxenpatch-src2Fhardcopy.c
"		    if (!mch_print_begin_page(IObuff))
			goto print_fail;

		    if (settings.n_collated_copies > 1)
			sprintf((char *)IObuff + STRLEN(IObuff),
",1,unused,737,unused,"		    if (!mch_print_begin_page(IObuff))
			goto print_fail;

		    if (settings.n_collated_copies > 1)
			sprintf((char *)IObuff + STRLEN(IObuff),
",unused,gawkxenpatch-src2Fhardcopy.c
"
print_fail:
    if (got_int || settings.user_abort)
    {
	sprintf((char *)IObuff, ""%s"", _(""Printing aborted""));
",1,unused,804,unused,"
print_fail:
    if (got_int || settings.user_abort)
    {
	sprintf((char *)IObuff, ""%s"", _(""Printing aborted""));
",unused,gawkxenpatch-src2Fhardcopy.c
" */
    static void
prt_write_int(int i)
{
    sprintf((char *)prt_line_buffer, ""%d "", i);
",1,unused,1493,unused," */
    static void
prt_write_int(int i)
{
    sprintf((char *)prt_line_buffer, ""%d "", i);
",unused,gawkxenpatch-src2Fhardcopy.c
" */
    static void
prt_write_boolean(int b)
{
    sprintf((char *)prt_line_buffer, ""%s "", (b ? ""T"" : ""F""));
",1,unused,1503,unused," */
    static void
prt_write_boolean(int b)
{
    sprintf((char *)prt_line_buffer, ""%s "", (b ? ""T"" : ""F""));
",unused,gawkxenpatch-src2Fhardcopy.c
"			  ""/_%s /VIM-%s /%s ref\n"", new_name, encoding, font);
    prt_write_file(prt_line_buffer);
#ifdef FEAT_MBYTE
    if (prt_out_mbyte)
	sprintf((char *)prt_line_buffer, ""/%s %d %f /_%s sffs\n"",
",1,unused,1522,unused,"			  ""/_%s /VIM-%s /%s ref\n"", new_name, encoding, font);
    prt_write_file(prt_line_buffer);
#ifdef FEAT_MBYTE
    if (prt_out_mbyte)
	sprintf((char *)prt_line_buffer, ""/%s %d %f /_%s sffs\n"",
",unused,gawkxenpatch-src2Fhardcopy.c
"    int     fraction;

    prt_real_bits(val, prec, &integer, &fraction);
    /* Emit integer part */
    sprintf((char *)prt_line_buffer, ""%d"", integer);
",1,unused,1598,unused,"    int     fraction;

    prt_real_bits(val, prec, &integer, &fraction);
    /* Emit integer part */
    sprintf((char *)prt_line_buffer, ""%d"", integer);
",unused,gawkxenpatch-src2Fhardcopy.c
"	    prec--;
	    fraction /= 10;
	}
	/* Emit fraction left padded with zeros */
	sprintf((char *)prt_line_buffer, "".%0*d"", prec, fraction);
",1,unused,1610,unused,"	    prec--;
	    fraction /= 10;
	}
	/* Emit fraction left padded with zeros */
	sprintf((char *)prt_line_buffer, "".%0*d"", prec, fraction);
",unused,gawkxenpatch-src2Fhardcopy.c
"	/* Emit fraction left padded with zeros */
	sprintf((char *)prt_line_buffer, "".%0*d"", prec, fraction);
	prt_write_file(prt_line_buffer);
    }
    sprintf((char *)prt_line_buffer, "" "");
",1,unused,1613,unused,"	/* Emit fraction left padded with zeros */
	sprintf((char *)prt_line_buffer, "".%0*d"", prec, fraction);
	prt_write_file(prt_line_buffer);
    }
    sprintf((char *)prt_line_buffer, "" "");
",unused,gawkxenpatch-src2Fhardcopy.c
"    vim_snprintf((char *)prt_line_buffer, sizeof(prt_line_buffer),
								""/%s "", name);
    prt_write_file(prt_line_buffer);
    prt_write_real(value, prec);
    sprintf((char *)prt_line_buffer, ""d\n"");
",1,unused,1627,unused,"    vim_snprintf((char *)prt_line_buffer, sizeof(prt_line_buffer),
								""/%s "", name);
    prt_write_file(prt_line_buffer);
    prt_write_real(value, prec);
    sprintf((char *)prt_line_buffer, ""d\n"");
",unused,gawkxenpatch-src2Fhardcopy.c
"    prt_write_file(prt_line_buffer);

    for (i = 0; i < count; i++)
    {
	sprintf((char *)prt_line_buffer, "" %d"", ints[i]);
",1,unused,2070,unused,"    prt_write_file(prt_line_buffer);

    for (i = 0; i < count; i++)
    {
	sprintf((char *)prt_line_buffer, "" %d"", ints[i]);
",unused,gawkxenpatch-src2Fhardcopy.c
"     */
    if (!(duplex || collate || color || (num_copies > 1)))
	return;

    sprintf((char *)prt_line_buffer, ""%%%%Requirements:"");
",1,unused,2122,unused,"     */
    if (!(duplex || collate || color || (num_copies > 1)))
	return;

    sprintf((char *)prt_line_buffer, ""%%%%Requirements:"");
",unused,gawkxenpatch-src2Fhardcopy.c
"    if (num_copies > 1)
    {
	prt_write_string("" numcopies("");
	/* Note: no space wanted so don't use prt_write_int() */
	sprintf((char *)prt_line_buffer, ""%d"", num_copies);
",1,unused,2139,unused,"    if (num_copies > 1)
    {
	prt_write_string("" numcopies("");
	/* Note: no space wanted so don't use prt_write_int() */
	sprintf((char *)prt_line_buffer, ""%d"", num_copies);
",unused,gawkxenpatch-src2Fhardcopy.c
"		case ')':  ga_append(&prt_ps_buffer, IF_EB(')', 0051)); break;
		case '\\': ga_append(&prt_ps_buffer, IF_EB('\\', 0134)); break;

		default:
			   sprintf((char *)ch_buff, ""%03o"", (unsigned int)ch);
",1,unused,3540,unused,"		case ')':  ga_append(&prt_ps_buffer, IF_EB(')', 0051)); break;
		case '\\': ga_append(&prt_ps_buffer, IF_EB('\\', 0134)); break;

		default:
			   sprintf((char *)ch_buff, ""%03o"", (unsigned int)ch);
",unused,gawkxenpatch-src2Fhardcopy.c
"    char *buf = (char *)alloc((unsigned)strlen(stat_emsg) + MAXPATHL + 10);

    if (buf != NULL)
    {
	(void)sprintf(buf, stat_emsg, fname, errno);
",1,unused,501,unused,"    char *buf = (char *)alloc((unsigned)strlen(stat_emsg) + MAXPATHL + 10);

    if (buf != NULL)
    {
	(void)sprintf(buf, stat_emsg, fname, errno);
",unused,gawkxenpatch-src2Fif_cscope.c
"	    if (fname[0] == '\0')
		break;
	}
	if (fname[0] == '\0')
	    (void)sprintf(fname2, ""/%s"", CSCOPE_DBFILE);
",1,unused,591,unused,"	    if (fname[0] == '\0')
		break;
	}
	if (fname[0] == '\0')
	    (void)sprintf(fname2, ""/%s"", CSCOPE_DBFILE);
",unused,gawkxenpatch-src2Fif_cscope.c
"	}
	if (fname[0] == '\0')
	    (void)sprintf(fname2, ""/%s"", CSCOPE_DBFILE);
	else
	    (void)sprintf(fname2, ""%s/%s"", fname, CSCOPE_DBFILE);
",1,unused,593,unused,"	}
	if (fname[0] == '\0')
	    (void)sprintf(fname2, ""/%s"", CSCOPE_DBFILE);
	else
	    (void)sprintf(fname2, ""%s/%s"", fname, CSCOPE_DBFILE);
",unused,gawkxenpatch-src2Fif_cscope.c
"
    if ((cmd = (char *)alloc((unsigned)(strlen(pat) + 2))) == NULL)
	return NULL;

    (void)sprintf(cmd, ""%d%s"", search, pat);
",1,unused,810,unused,"
    if ((cmd = (char *)alloc((unsigned)(strlen(pat) + 2))) == NULL)
	return NULL;

    (void)sprintf(cmd, ""%d%s"", search, pat);
",unused,gawkxenpatch-src2Fif_cscope.c
"	}

	/* run the cscope command; is there execl for non-unix systems? */
#if defined(UNIX)
	(void)sprintf(cmd, ""exec %s -dl -f %s"", prog, csinfo[i].fname);
",1,unused,961,unused,"	}

	/* run the cscope command; is there execl for non-unix systems? */
#if defined(UNIX)
	(void)sprintf(cmd, ""exec %s -dl -f %s"", prog, csinfo[i].fname);
",unused,gawkxenpatch-src2Fif_cscope.c
"	(void)sprintf(cmd, ""%s -dl -f %s"", prog, csinfo[i].fname);
#endif
	if (csinfo[i].ppath != NULL)
	{
	    (void)strcat(cmd, "" -P"");
",1,unused,968,unused,"	(void)sprintf(cmd, ""%s -dl -f %s"", prog, csinfo[i].fname);
#endif
	if (csinfo[i].ppath != NULL)
	{
	    (void)strcat(cmd, "" -P"");
",unused,gawkxenpatch-src2Fif_cscope.c
"#endif
	if (csinfo[i].ppath != NULL)
	{
	    (void)strcat(cmd, "" -P"");
	    (void)strcat(cmd, csinfo[i].ppath);
",1,unused,969,unused,"#endif
	if (csinfo[i].ppath != NULL)
	{
	    (void)strcat(cmd, "" -P"");
	    (void)strcat(cmd, csinfo[i].ppath);
",unused,gawkxenpatch-src2Fif_cscope.c
"	    (void)strcat(cmd, csinfo[i].ppath);
	}
	if (csinfo[i].flags != NULL)
	{
	    (void)strcat(cmd, "" "");
",1,unused,973,unused,"	    (void)strcat(cmd, csinfo[i].ppath);
	}
	if (csinfo[i].flags != NULL)
	{
	    (void)strcat(cmd, "" "");
",unused,gawkxenpatch-src2Fif_cscope.c
"	}
	if (csinfo[i].flags != NULL)
	{
	    (void)strcat(cmd, "" "");
	    (void)strcat(cmd, csinfo[i].flags);
",1,unused,974,unused,"	}
	if (csinfo[i].flags != NULL)
	{
	    (void)strcat(cmd, "" "");
	    (void)strcat(cmd, csinfo[i].flags);
",unused,gawkxenpatch-src2Fif_cscope.c
"
	    /* strlen will be enough because we use chars */
	    if (buf != NULL)
	    {
		sprintf(buf, nf, *qfpos, *(qfpos-1));
",1,unused,1171,unused,"
	    /* strlen will be enough because we use chars */
	    if (buf != NULL)
	    {
		sprintf(buf, nf, *qfpos, *(qfpos-1));
",unused,gawkxenpatch-src2Fif_cscope.c
"	if (buf == NULL)
	    (void)EMSG(nf);
	else
	{
	    sprintf(buf, nf, opt, pat);
",1,unused,1244,unused,"	if (buf == NULL)
	    (void)EMSG(nf);
	else
	{
	    sprintf(buf, nf, opt, pat);
",unused,gawkxenpatch-src2Fif_cscope.c
"
    if ((csinfo[i].fname = (char *)alloc((unsigned)strlen(fname)+1)) == NULL)
	return -1;

    (void)strcpy(csinfo[i].fname, (const char *)fname);
",1,unused,1514,unused,"
    if ((csinfo[i].fname = (char *)alloc((unsigned)strlen(fname)+1)) == NULL)
	return -1;

    (void)strcpy(csinfo[i].fname, (const char *)fname);
",unused,gawkxenpatch-src2Fif_cscope.c
"	    vim_free(csinfo[i].fname);
	    csinfo[i].fname = NULL;
	    return -1;
	}
	(void)strcpy(csinfo[i].ppath, (const char *)ppath);
",1,unused,1524,unused,"	    vim_free(csinfo[i].fname);
	    csinfo[i].fname = NULL;
	    return -1;
	}
	(void)strcpy(csinfo[i].ppath, (const char *)ppath);
",unused,gawkxenpatch-src2Fif_cscope.c
"	    csinfo[i].fname = NULL;
	    csinfo[i].ppath = NULL;
	    return -1;
	}
	(void)strcpy(csinfo[i].flags, (const char *)flags);
",1,unused,1538,unused,"	    csinfo[i].fname = NULL;
	    csinfo[i].ppath = NULL;
	    return -1;
	}
	(void)strcpy(csinfo[i].flags, (const char *)flags);
",unused,gawkxenpatch-src2Fif_cscope.c
"	amt = (int)(strlen(fname) + strlen(slno) + strlen(tagstr) + strlen(search)+6);
	if ((buf = (char *)alloc(amt)) == NULL)
	    return NULL;

	(void)sprintf(buf, ""%s\t%s\t%s;\""\t%s"", tagstr, fname, slno, search);
",1,unused,1710,unused,"	amt = (int)(strlen(fname) + strlen(slno) + strlen(tagstr) + strlen(search)+6);
	if ((buf = (char *)alloc(amt)) == NULL)
	    return NULL;

	(void)sprintf(buf, ""%s\t%s\t%s;\""\t%s"", tagstr, fname, slno, search);
",unused,gawkxenpatch-src2Fif_cscope.c
"	amt = (int)(strlen(fname) + strlen(slno) + strlen(tagstr) + 5);
	if ((buf = (char *)alloc(amt)) == NULL)
	    return NULL;

	(void)sprintf(buf, ""%s\t%s\t%s;\"""", tagstr, fname, slno);
",1,unused,1718,unused,"	amt = (int)(strlen(fname) + strlen(slno) + strlen(tagstr) + 5);
	if ((buf = (char *)alloc(amt)) == NULL)
	    return NULL;

	(void)sprintf(buf, ""%s\t%s\t%s;\"""", tagstr, fname, slno);
",unused,gawkxenpatch-src2Fif_cscope.c
"	   if (context == NULL)
	       continue;

	   if (strcmp(cntx, ""<global>"")==0)
	       strcpy(context, ""<<global>>"");
",1,unused,1903,unused,"	   if (context == NULL)
	       continue;

	   if (strcmp(cntx, ""<global>"")==0)
	       strcpy(context, ""<<global>>"");
",unused,gawkxenpatch-src2Fif_cscope.c
"
	   if (strcmp(cntx, ""<global>"")==0)
	       strcpy(context, ""<<global>>"");
	   else
	       sprintf(context, ""<<%s>>"", cntx);
",1,unused,1905,unused,"
	   if (strcmp(cntx, ""<global>"")==0)
	       strcpy(context, ""<<global>>"");
	   else
	       sprintf(context, ""<<%s>>"", cntx);
",unused,gawkxenpatch-src2Fif_cscope.c
"
    if ((tbuf = (char *)alloc((unsigned)strlen(matches[0]) + 1)) == NULL)
	return;

    strcpy(tbuf, matches[0]);
",1,unused,2062,unused,"
    if ((tbuf = (char *)alloc((unsigned)strlen(matches[0]) + 1)) == NULL)
	return;

    strcpy(tbuf, matches[0]);
",unused,gawkxenpatch-src2Fif_cscope.c
"    buf = (char *)alloc(newsize);
    if (buf != NULL)
    {
	bufsize = newsize;
	(void)sprintf(buf, cstag_msg, ptag);
",1,unused,2075,unused,"    buf = (char *)alloc(newsize);
    if (buf != NULL)
    {
	bufsize = newsize;
	(void)sprintf(buf, cstag_msg, ptag);
",unused,gawkxenpatch-src2Fif_cscope.c
"	 * directly, but that's too much of a hassle
	 */
	if ((tbuf = (char *)alloc((unsigned)strlen(matches[idx]) + 1)) == NULL)
	    continue;
	(void)strcpy(tbuf, matches[idx]);
",1,unused,2096,unused,"	 * directly, but that's too much of a hassle
	 */
	if ((tbuf = (char *)alloc((unsigned)strlen(matches[idx]) + 1)) == NULL)
	    continue;
	(void)strcpy(tbuf, matches[idx]);
",unused,gawkxenpatch-src2Fif_cscope.c
"	}
	if (buf != NULL)
	{
	    /* csfmt_str = ""%4d %6s  ""; */
	    (void)sprintf(buf, csfmt_str, num, lno);
",1,unused,2126,unused,"	}
	if (buf != NULL)
	{
	    /* csfmt_str = ""%4d %6s  ""; */
	    (void)sprintf(buf, csfmt_str, num, lno);
",unused,gawkxenpatch-src2Fif_cscope.c
"		bufsize = newsize;
	}
	if (buf != NULL)
	{
	    (void)sprintf(buf, cntxformat, context);
",1,unused,2152,unused,"		bufsize = newsize;
	}
	if (buf != NULL)
	{
	    (void)sprintf(buf, cntxformat, context);
",unused,gawkxenpatch-src2Fif_cscope.c
"		/* don't use smsg_attr() because we want to display the
		 * connection number in the same line as
		 * ""Added cscope database...""
		 */
		sprintf(buf, "" (#%d)"", i);
",1,unused,2460,unused,"		/* don't use smsg_attr() because we want to display the
		 * connection number in the same line as
		 * ""Added cscope database...""
		 */
		sprintf(buf, "" (#%d)"", i);
",unused,gawkxenpatch-src2Fif_cscope.c
"#endif
       )
    {
	if ((fullname = (char *)alloc(len)) != NULL)
	    (void)sprintf(fullname, ""%s/%s"", csinfo[i].ppath, name);
",1,unused,2530,unused,"#endif
       )
    {
	if ((fullname = (char *)alloc(len)) != NULL)
	    (void)sprintf(fullname, ""%s/%s"", csinfo[i].ppath, name);
",unused,gawkxenpatch-src2Fif_cscope.c
"	    {
		res = -10;
		continue;
	    }
	    sprintf((char *)p, ""%s%d"", name, i++);
",1,unused,244,unused,"	    {
		res = -10;
		continue;
	    }
	    sprintf((char *)p, ""%s%d"", name, i++);
",unused,gawkxenpatch-src2Fif_xcmdsrv.c
"	    return -1;
	}
	(void)LookupName(dpy, name, /*delete=*/TRUE, NULL);
    }
    sprintf((char *)propInfo, ""%x %.*s"", (int_u)commWindow,
",1,unused,303,unused,"	    return -1;
	}
	(void)LookupName(dpy, name, /*delete=*/TRUE, NULL);
    }
    sprintf((char *)propInfo, ""%x %.*s"", (int_u)commWindow,
",unused,gawkxenpatch-src2Fif_xcmdsrv.c
"    if (serverName != NULL)
    {
	/* Reinsert name if we was already registered */
	(void)LookupName(dpy, serverName, /*delete=*/TRUE, NULL);
	sprintf((char *)propInfo, ""%x %.*s"",
",1,unused,354,unused,"    if (serverName != NULL)
    {
	/* Reinsert name if we was already registered */
	(void)LookupName(dpy, serverName, /*delete=*/TRUE, NULL);
	sprintf((char *)propInfo, ""%x %.*s"",
",unused,gawkxenpatch-src2Fif_xcmdsrv.c
"#endif
    property = (char_u *)alloc((unsigned)length + 30);

#ifdef FEAT_MBYTE
    sprintf((char *)property, ""%c%c%c-n %s%c-E %s%c-s %s"",
",1,unused,471,unused,"#endif
    property = (char_u *)alloc((unsigned)length + 30);

#ifdef FEAT_MBYTE
    sprintf((char *)property, ""%c%c%c-n %s%c-E %s%c-s %s"",
",unused,gawkxenpatch-src2Fif_xcmdsrv.c
"    if (name == loosename)
	vim_free(loosename);
    /* Add a back reference to our comm window */
    serial++;
    sprintf((char *)property + length, ""%c-r %x %d"",
",1,unused,481,unused,"    if (name == loosename)
	vim_free(loosename);
    /* Add a back reference to our comm window */
    serial++;
    sprintf((char *)property + length, ""%c-r %x %d"",
",unused,gawkxenpatch-src2Fif_xcmdsrv.c
"#endif
    if ((property = (char_u *)alloc((unsigned)length + 30)) != NULL)
    {
#ifdef FEAT_MBYTE
	sprintf((char *)property, ""%cn%c-E %s%c-n %s%c-w %x"",
",1,unused,784,unused,"#endif
    if ((property = (char_u *)alloc((unsigned)length + 30)) != NULL)
    {
#ifdef FEAT_MBYTE
	sprintf((char *)property, ""%cn%c-E %s%c-n %s%c-w %x"",
",unused,gawkxenpatch-src2Fif_xcmdsrv.c
"			/* Initialize the result property. */
			ga_init2(&reply, 1, 100);
#ifdef FEAT_MBYTE
			(void)ga_grow(&reply, 50 + STRLEN(p_enc));
			sprintf(reply.ga_data, ""%cr%c-E %s%c-s %s%c-r "",
",1,unused,1350,unused,"			/* Initialize the result property. */
			ga_init2(&reply, 1, 100);
#ifdef FEAT_MBYTE
			(void)ga_grow(&reply, 50 + STRLEN(p_enc));
			sprintf(reply.ga_data, ""%cr%c-E %s%c-s %s%c-r "",
",unused,gawkxenpatch-src2Fif_xcmdsrv.c
"#ifdef FEAT_AUTOCMD
	    {
		char_u	winstr[30];

		sprintf((char *)winstr, ""0x%x"", (unsigned int)win);
",1,unused,1496,unused,"#ifdef FEAT_AUTOCMD
	    {
		char_u	winstr[30];

		sprintf((char *)winstr, ""0x%x"", (unsigned int)win);
",unused,gawkxenpatch-src2Fif_xcmdsrv.c
"			    a = argv[0];
			p = alloc((unsigned)(STRLEN(a) + 4));
			if (p == NULL)
			    mch_exit(2);
			sprintf((char *)p, ""so %s"", a);
",1,unused,2291,unused,"			    a = argv[0];
			p = alloc((unsigned)(STRLEN(a) + 4));
			if (p == NULL)
			    mch_exit(2);
			sprintf((char *)p, ""so %s"", a);
",unused,gawkxenpatch-src2Fmain.c
"    {
	p = alloc((unsigned)STRLEN(parmp->commands[0]) + 3);
	if (p != NULL)
	{
	    sprintf((char *)p, "":%s\r"", parmp->commands[0]);
",1,unused,2517,unused,"    {
	p = alloc((unsigned)STRLEN(parmp->commands[0]) + 3);
	if (p != NULL)
	{
	    sprintf((char *)p, "":%s\r"", parmp->commands[0]);
",unused,gawkxenpatch-src2Fmain.c
"	}
	msg_putchar('\n');
	if (!got_int)
	{
	    sprintf((char *)IObuff, "" %c %6ld %4d "", c, p->lnum, p->col);
",1,unused,773,unused,"	}
	msg_putchar('\n');
	if (!got_int)
	{
	    sprintf((char *)IObuff, "" %c %6ld %4d "", c, p->lnum, p->col);
",unused,gawkxenpatch-src2Fmark.c
"	    {
		vim_free(name);
		break;
	    }
	    sprintf((char *)IObuff, ""%c %2d %5ld %4d "",
",1,unused,902,unused,"	    {
		vim_free(name);
		break;
	    }
	    sprintf((char *)IObuff, ""%c %2d %5ld %4d "",
",unused,gawkxenpatch-src2Fmark.c
"	{
	    msg_putchar('\n');
	    if (got_int)
		break;
	    sprintf((char *)IObuff, ""%c %3d %5ld %4d "",
",1,unused,940,unused,"	{
	    msg_putchar('\n');
	    if (got_int)
		break;
	    sprintf((char *)IObuff, ""%c %3d %5ld %4d "",
",unused,gawkxenpatch-src2Fmark.c
"		rlen += 2;
	    }
	    clen = utf_ptr2len(line + i);
	}
	sprintf((char *)IObuff + rlen, ""%02x "",
",1,unused,3528,unused,"		rlen += 2;
	    }
	    clen = utf_ptr2len(line + i);
	}
	sprintf((char *)IObuff + rlen, ""%02x "",
",unused,gawkxenpatch-src2Fmbyte.c
"	return FALSE;

    if (gui.rsrc_input_method != NULL && *gui.rsrc_input_method != NUL)
    {
	strcpy(tmp, gui.rsrc_input_method);
",1,unused,5722,unused,"	return FALSE;

    if (gui.rsrc_input_method != NULL && *gui.rsrc_input_method != NUL)
    {
	strcpy(tmp, gui.rsrc_input_method);
",unused,gawkxenpatch-src2Fmbyte.c
"	    *end = NUL;

	    if (strlen(s) <= IMLEN_MAX)
	    {
		strcpy(buf, ""@im="");
",1,unused,5736,unused,"	    *end = NUL;

	    if (strlen(s) <= IMLEN_MAX)
	    {
		strcpy(buf, ""@im="");
",unused,gawkxenpatch-src2Fmbyte.c
"
	    if (strlen(s) <= IMLEN_MAX)
	    {
		strcpy(buf, ""@im="");
		strcat(buf, s);
",1,unused,5737,unused,"
	    if (strlen(s) <= IMLEN_MAX)
	    {
		strcpy(buf, ""@im="");
		strcat(buf, s);
",unused,gawkxenpatch-src2Fmbyte.c
"	return FALSE;
    }

    found = False;
    strcpy(tmp, gui.rsrc_preedit_type_name);
",1,unused,5789,unused,"	return FALSE;
    }

    found = False;
    strcpy(tmp, gui.rsrc_preedit_type_name);
",unused,gawkxenpatch-src2Fmbyte.c
"    {
	p = (char_u *)_(""Error detected while processing %s:"");
	Buf = alloc((unsigned)(STRLEN(sourcing_name) + STRLEN(p)));
	if (Buf != NULL)
	    sprintf((char *)Buf, (char *)p, sourcing_name);
",1,unused,420,unused,"    {
	p = (char_u *)_(""Error detected while processing %s:"");
	Buf = alloc((unsigned)(STRLEN(sourcing_name) + STRLEN(p)));
	if (Buf != NULL)
	    sprintf((char *)Buf, (char *)p, sourcing_name);
",unused,gawkxenpatch-src2Fmessage.c
"    {
	p = (char_u *)_(""line %4ld:"");
	Buf = alloc((unsigned)(STRLEN(p) + 20));
	if (Buf != NULL)
	    sprintf((char *)Buf, (char *)p, (long)sourcing_lnum);
",1,unused,445,unused,"    {
	p = (char_u *)_(""line %4ld:"");
	Buf = alloc((unsigned)(STRLEN(p) + 20));
	if (Buf != NULL)
	    sprintf((char *)Buf, (char *)p, (long)sourcing_lnum);
",unused,gawkxenpatch-src2Fmessage.c
"msg_outnum(long n)
{
    char_u	buf[20];

    sprintf((char *)buf, ""%ld"", n);
",1,unused,1210,unused,"msg_outnum(long n)
{
    char_u	buf[20];

    sprintf((char *)buf, ""%ld"", n);
",unused,gawkxenpatch-src2Fmessage.c
"			f[f_l++] = fmt_spec;
			f[f_l++] = '\0';

			if (fmt_spec == 'p')
			    str_arg_l += sprintf(tmp + str_arg_l, f, ptr_arg);
",1,unused,4402,unused,"			f[f_l++] = fmt_spec;
			f[f_l++] = '\0';

			if (fmt_spec == 'p')
			    str_arg_l += sprintf(tmp + str_arg_l, f, ptr_arg);
",unused,gawkxenpatch-src2Fmessage.c
"			    /* signed */
			    switch (length_modifier)
			    {
			    case '\0':
			    case 'h': str_arg_l += sprintf(
",1,unused,4409,unused,"			    /* signed */
			    switch (length_modifier)
			    {
			    case '\0':
			    case 'h': str_arg_l += sprintf(
",unused,gawkxenpatch-src2Fmessage.c
"			    case '\0':
			    case 'h': str_arg_l += sprintf(
						 tmp + str_arg_l, f, int_arg);
				      break;
			    case 'l': str_arg_l += sprintf(
",1,unused,4412,unused,"			    case '\0':
			    case 'h': str_arg_l += sprintf(
						 tmp + str_arg_l, f, int_arg);
				      break;
			    case 'l': str_arg_l += sprintf(
",unused,gawkxenpatch-src2Fmessage.c
"			    /* unsigned */
			    switch (length_modifier)
			    {
			    case '\0':
			    case 'h': str_arg_l += sprintf(
",1,unused,4423,unused,"			    /* unsigned */
			    switch (length_modifier)
			    {
			    case '\0':
			    case 'h': str_arg_l += sprintf(
",unused,gawkxenpatch-src2Fmessage.c
"			    case '\0':
			    case 'h': str_arg_l += sprintf(
						tmp + str_arg_l, f, uint_arg);
				      break;
			    case 'l': str_arg_l += sprintf(
",1,unused,4426,unused,"			    case '\0':
			    case 'h': str_arg_l += sprintf(
						tmp + str_arg_l, f, uint_arg);
				      break;
			    case 'l': str_arg_l += sprintf(
",unused,gawkxenpatch-src2Fmessage.c
"#  endif
			    )
		    {
			/* Avoid a buffer overflow */
			strcpy(tmp, ""inf"");
",1,unused,4525,unused,"#  endif
			    )
		    {
			/* Avoid a buffer overflow */
			strcpy(tmp, ""inf"");
",unused,gawkxenpatch-src2Fmessage.c
"			    if (fmt_spec == 'f' && abs_f > 1.0)
				max_prec -= (size_t)log10(abs_f);
			    if (precision > max_prec)
				precision = max_prec;
			    l += sprintf(format + 1, "".%d"", (int)precision);
",1,unused,4542,unused,"			    if (fmt_spec == 'f' && abs_f > 1.0)
				max_prec -= (size_t)log10(abs_f);
			    if (precision > max_prec)
				precision = max_prec;
			    l += sprintf(format + 1, "".%d"", (int)precision);
",unused,gawkxenpatch-src2Fmessage.c
"			    l += sprintf(format + 1, "".%d"", (int)precision);
			}
			format[l] = fmt_spec;
			format[l + 1] = NUL;
			str_arg_l = sprintf(tmp, format, f);
",1,unused,4546,unused,"			    l += sprintf(format + 1, "".%d"", (int)precision);
			}
			format[l] = fmt_spec;
			format[l + 1] = NUL;
			str_arg_l = sprintf(tmp, format, f);
",unused,gawkxenpatch-src2Fmessage.c
"	    /* success, login */
	    vim_snprintf(buf, sizeof(buf), ""AUTH %s\n"", password);
	    nb_send(buf, ""netbeans_connect"");

	    sprintf(buf, ""0:version=0 \""%s\""\n"", ExtEdProtocolVersion);
",1,unused,231,unused,"	    /* success, login */
	    vim_snprintf(buf, sizeof(buf), ""AUTH %s\n"", password);
	    nb_send(buf, ""netbeans_connect"");

	    sprintf(buf, ""0:version=0 \""%s\""\n"", ExtEdProtocolVersion);
",unused,gawkxenpatch-src2Fnetbeans.c
"	    continue;
	if (netbeansForcedQuit)
	{
	    /* mark as unmodified so NetBeans won't put up dialog on ""killed"" */
	    sprintf(buf, ""%d:unmodified=%d\n"", i, r_cmdno);
",1,unused,744,unused,"	    continue;
	if (netbeansForcedQuit)
	{
	    /* mark as unmodified so NetBeans won't put up dialog on ""killed"" */
	    sprintf(buf, ""%d:unmodified=%d\n"", i, r_cmdno);
",unused,gawkxenpatch-src2Fnetbeans.c
"	    sprintf(buf, ""%d:unmodified=%d\n"", i, r_cmdno);
	    nbdebug((""EVT: %s"", buf));
	    nb_send(buf, ""netbeans_end"");
	}
	sprintf(buf, ""%d:killed=%d\n"", i, r_cmdno);
",1,unused,748,unused,"	    sprintf(buf, ""%d:unmodified=%d\n"", i, r_cmdno);
	    nbdebug((""EVT: %s"", buf));
	    nb_send(buf, ""netbeans_end"");
	}
	sprintf(buf, ""%d:killed=%d\n"", i, r_cmdno);
",unused,gawkxenpatch-src2Fnetbeans.c
"    /* Avoid printing an annoying error message. */
    if (!NETBEANS_OPEN)
	return;

    sprintf(reply, ""%d\n"", cmdno);
",1,unused,781,unused,"    /* Avoid printing an annoying error message. */
    if (!NETBEANS_OPEN)
	return;

    sprintf(reply, ""%d\n"", cmdno);
",unused,gawkxenpatch-src2Fnetbeans.c
"
    nbdebug((""REP %d: %s\n"", cmdno, (char *)result));

    reply = alloc((unsigned)STRLEN(result) + 32);
    sprintf((char *)reply, ""%d %s\n"", cmdno, (char *)result);
",1,unused,798,unused,"
    nbdebug((""REP %d: %s\n"", cmdno, (char *)result));

    reply = alloc((unsigned)STRLEN(result) + 32);
    sprintf((char *)reply, ""%d %s\n"", cmdno, (char *)result);
",unused,gawkxenpatch-src2Fnetbeans.c
"    char reply[32];

    nbdebug((""REP %d: %ld\n"", cmdno, result));

    sprintf(reply, ""%d %ld\n"", cmdno, result);
",1,unused,815,unused,"    char reply[32];

    nbdebug((""REP %d: %ld\n"", cmdno, result));

    sprintf(reply, ""%d %ld\n"", cmdno, result);
",unused,gawkxenpatch-src2Fnetbeans.c
"
	    /* Note: nb_getbufno() may return -1.  This indicates the IDE
	     * didn't assign a number to the current buffer in response to a
	     * fileOpened event. */
	    sprintf((char *)text, ""%d %ld %d %ld"",
",1,unused,1024,unused,"
	    /* Note: nb_getbufno() may return -1.  This indicates the IDE
	     * didn't assign a number to the current buffer in response to a
	     * fileOpened event. */
	    sprintf((char *)text, ""%d %ld %d %ld"",
",unused,gawkxenpatch-src2Fnetbeans.c
"	    }
	    tok++;
	}

	strcpy(&keybuf[i], tok);
",1,unused,2351,unused,"	    }
	    tok++;
	}

	strcpy(&keybuf[i], tok);
",unused,gawkxenpatch-src2Fnetbeans.c
"    }

    buf[0] = '\0';
    if (ctrl)
	strcat(buf, ""C"");
",1,unused,2468,unused,"    }

    buf[0] = '\0';
    if (ctrl)
	strcat(buf, ""C"");
",unused,gawkxenpatch-src2Fnetbeans.c
"    buf[0] = '\0';
    if (ctrl)
	strcat(buf, ""C"");
    if (shift)
	strcat(buf, ""S"");
",1,unused,2470,unused,"    buf[0] = '\0';
    if (ctrl)
	strcat(buf, ""C"");
    if (shift)
	strcat(buf, ""S"");
",unused,gawkxenpatch-src2Fnetbeans.c
"	strcat(buf, ""C"");
    if (shift)
	strcat(buf, ""S"");
    if (alt)
	strcat(buf, ""M""); /* META */
",1,unused,2472,unused,"	strcat(buf, ""C"");
    if (shift)
	strcat(buf, ""S"");
    if (alt)
	strcat(buf, ""M""); /* META */
",unused,gawkxenpatch-src2Fnetbeans.c
"	strcat(buf, ""S"");
    if (alt)
	strcat(buf, ""M""); /* META */
    if (ctrl || shift || alt)
	strcat(buf, ""-"");
",1,unused,2474,unused,"	strcat(buf, ""S"");
    if (alt)
	strcat(buf, ""M""); /* META */
    if (ctrl || shift || alt)
	strcat(buf, ""-"");
",unused,gawkxenpatch-src2Fnetbeans.c
"    if (alt)
	strcat(buf, ""M""); /* META */
    if (ctrl || shift || alt)
	strcat(buf, ""-"");
    strcat(buf, name);
",1,unused,2475,unused,"    if (alt)
	strcat(buf, ""M""); /* META */
    if (ctrl || shift || alt)
	strcat(buf, ""-"");
    strcat(buf, name);
",unused,gawkxenpatch-src2Fnetbeans.c
"    char buf[128];

    if (NETBEANS_OPEN)
    {
	sprintf(buf, ""0:disconnect=%d\n"", r_cmdno);
",1,unused,2582,unused,"    char buf[128];

    if (NETBEANS_OPEN)
    {
	sprintf(buf, ""0:disconnect=%d\n"", r_cmdno);
",unused,gawkxenpatch-src2Fnetbeans.c
"
    if (!NETBEANS_OPEN)
	return;

    sprintf(buf, ""0:geometry=%d %d %d %d %d\n"",
",1,unused,2600,unused,"
    if (!NETBEANS_OPEN)
	return;

    sprintf(buf, ""0:geometry=%d %d %d %d %d\n"",
",unused,gawkxenpatch-src2Fnetbeans.c
"
    nbdebug((""netbeans_file_killed:\n""));
    nbdebug((""    Killing bufno: %d"", bufno));

    sprintf(buffer, ""%d:killed=%d\n"", bufno, r_cmdno);
",1,unused,2692,unused,"
    nbdebug((""netbeans_file_killed:\n""));
    nbdebug((""    Killing bufno: %d"", bufno));

    sprintf(buffer, ""%d:killed=%d\n"", bufno, r_cmdno);
",unused,gawkxenpatch-src2Fnetbeans.c
"    p = nb_quote(newtxt);
    if (p != NULL)
    {
	buf = alloc(128 + 2*newlen);
	sprintf((char *)buf, ""%d:insert=%d %ld \""%s\""\n"",
",1,unused,2769,unused,"    p = nb_quote(newtxt);
    if (p != NULL)
    {
	buf = alloc(128 + 2*newlen);
	sprintf((char *)buf, ""%d:insert=%d %ld \""%s\""\n"",
",unused,gawkxenpatch-src2Fnetbeans.c
"    pos.col = col;

    off = pos2off(bufp, &pos);

    sprintf((char *)buf, ""%d:remove=%d %ld %ld\n"", bufno, r_cmdno, off, len);
",1,unused,2815,unused,"    pos.col = col;

    off = pos2off(bufp, &pos);

    sprintf((char *)buf, ""%d:remove=%d %ld %ld\n"", bufno, r_cmdno, off, len);
",unused,gawkxenpatch-src2Fnetbeans.c
"			      - ((curwin->w_p_nu || curwin->w_p_rnu) ? 9 : 1);
	long off = pos2off(curbuf, &curwin->w_cursor);

	/* sync the cursor position */
	sprintf(buf, ""%d:newDotAndMark=%d %ld %ld\n"", bufno, r_cmdno, off, off);
",1,unused,2852,unused,"			      - ((curwin->w_p_nu || curwin->w_p_rnu) ? 9 : 1);
	long off = pos2off(curbuf, &curwin->w_cursor);

	/* sync the cursor position */
	sprintf(buf, ""%d:newDotAndMark=%d %ld %ld\n"", bufno, r_cmdno, off, off);
",unused,gawkxenpatch-src2Fnetbeans.c
"	sprintf(buf, ""%d:newDotAndMark=%d %ld %ld\n"", bufno, r_cmdno, off, off);
	nbdebug((""EVT: %s"", buf));
	nb_send(buf, ""netbeans_button_release[newDotAndMark]"");

	sprintf(buf, ""%d:buttonRelease=%d %d %ld %d\n"", bufno, r_cmdno,
",1,unused,2856,unused,"	sprintf(buf, ""%d:newDotAndMark=%d %ld %ld\n"", bufno, r_cmdno, off, off);
	nbdebug((""EVT: %s"", buf));
	nb_send(buf, ""netbeans_button_release[newDotAndMark]"");

	sprintf(buf, ""%d:buttonRelease=%d %d %ld %d\n"", bufno, r_cmdno,
",unused,gawkxenpatch-src2Fnetbeans.c
"    }

    /* sync the cursor position */
    off = pos2off(curbuf, &curwin->w_cursor);
    sprintf(buf, ""%d:newDotAndMark=%d %ld %ld\n"", bufno, r_cmdno, off, off);
",1,unused,2919,unused,"    }

    /* sync the cursor position */
    off = pos2off(curbuf, &curwin->w_cursor);
    sprintf(buf, ""%d:newDotAndMark=%d %ld %ld\n"", bufno, r_cmdno, off, off);
",unused,gawkxenpatch-src2Fnetbeans.c
"	return;

    nbbuf->modified = 0;

    sprintf((char *)buf, ""%d:save=%d\n"", bufno, r_cmdno);
",1,unused,2963,unused,"	return;

    nbbuf->modified = 0;

    sprintf((char *)buf, ""%d:save=%d\n"", bufno, r_cmdno);
",unused,gawkxenpatch-src2Fnetbeans.c
"    /* Don't mark as modified for initial read */
    if (nbbuf->insertDone)
	nbbuf->modified = 1;

    sprintf((char *)buf, ""%d:remove=%d 0 -1\n"", bufno, r_cmdno);
",1,unused,2990,unused,"    /* Don't mark as modified for initial read */
    if (nbbuf->insertDone)
	nbbuf->modified = 1;

    sprintf((char *)buf, ""%d:remove=%d 0 -1\n"", bufno, r_cmdno);
",unused,gawkxenpatch-src2Fnetbeans.c
"	    int value;

	    value = strtol((char *)fg, &ptr, 10);
	    if (ptr != (char *)fg)
		sprintf(fgbuf, ""guifg=#%06x"", value & 0xFFFFFF);
",1,unused,3215,unused,"	    int value;

	    value = strtol((char *)fg, &ptr, 10);
	    if (ptr != (char *)fg)
		sprintf(fgbuf, ""guifg=#%06x"", value & 0xFFFFFF);
",unused,gawkxenpatch-src2Fnetbeans.c
"	    value = strtol((char *)fg, &ptr, 10);
	    if (ptr != (char *)fg)
		sprintf(fgbuf, ""guifg=#%06x"", value & 0xFFFFFF);
	    else
		sprintf(fgbuf, ""guifg=%s ctermfg=%s"", fg, fg);
",1,unused,3217,unused,"	    value = strtol((char *)fg, &ptr, 10);
	    if (ptr != (char *)fg)
		sprintf(fgbuf, ""guifg=#%06x"", value & 0xFFFFFF);
	    else
		sprintf(fgbuf, ""guifg=%s ctermfg=%s"", fg, fg);
",unused,gawkxenpatch-src2Fnetbeans.c
"		sprintf(fgbuf, ""guifg=%s ctermfg=%s"", fg, fg);

	    value = strtol((char *)bg, &ptr, 10);
	    if (ptr != (char *)bg)
		sprintf(bgbuf, ""guibg=#%06x"", value & 0xFFFFFF);
",1,unused,3221,unused,"		sprintf(fgbuf, ""guifg=%s ctermfg=%s"", fg, fg);

	    value = strtol((char *)bg, &ptr, 10);
	    if (ptr != (char *)bg)
		sprintf(bgbuf, ""guibg=#%06x"", value & 0xFFFFFF);
",unused,gawkxenpatch-src2Fnetbeans.c
"	    value = strtol((char *)bg, &ptr, 10);
	    if (ptr != (char *)bg)
		sprintf(bgbuf, ""guibg=#%06x"", value & 0xFFFFFF);
	    else
		sprintf(bgbuf, ""guibg=%s ctermbg=%s"", bg, bg);
",1,unused,3223,unused,"	    value = strtol((char *)bg, &ptr, 10);
	    if (ptr != (char *)bg)
		sprintf(bgbuf, ""guibg=#%06x"", value & 0xFFFFFF);
	    else
		sprintf(bgbuf, ""guibg=%s ctermbg=%s"", bg, bg);
",unused,gawkxenpatch-src2Fnetbeans.c
"	    getvcols(curwin, &curwin->w_cursor, &VIsual, &leftcol, &rightcol);
# ifdef FEAT_LINEBREAK
	    p_sbr = saved_sbr;
# endif
	    sprintf((char *)showcmd_buf, ""%ldx%ld"", lines,
",1,unused,3773,unused,"	    getvcols(curwin, &curwin->w_cursor, &VIsual, &leftcol, &rightcol);
# ifdef FEAT_LINEBREAK
	    p_sbr = saved_sbr;
# endif
	    sprintf((char *)showcmd_buf, ""%ldx%ld"", lines,
",unused,gawkxenpatch-src2Fnormal.c
"	    sprintf((char *)showcmd_buf, ""%ldx%ld"", lines,
					      (long)(rightcol - leftcol + 1));
	}
	else if (VIsual_mode == 'V' || VIsual.lnum != curwin->w_cursor.lnum)
	    sprintf((char *)showcmd_buf, ""%ld"", lines);
",1,unused,3777,unused,"	    sprintf((char *)showcmd_buf, ""%ldx%ld"", lines,
					      (long)(rightcol - leftcol + 1));
	}
	else if (VIsual_mode == 'V' || VIsual.lnum != curwin->w_cursor.lnum)
	    sprintf((char *)showcmd_buf, ""%ld"", lines);
",unused,gawkxenpatch-src2Fnormal.c
"		++chars;
		s += l;
	    }
	    if (bytes == chars)
		sprintf((char *)showcmd_buf, ""%d"", chars);
",1,unused,3813,unused,"		++chars;
		s += l;
	    }
	    if (bytes == chars)
		sprintf((char *)showcmd_buf, ""%d"", chars);
",unused,gawkxenpatch-src2Fnormal.c
"	    }
	    if (bytes == chars)
		sprintf((char *)showcmd_buf, ""%d"", chars);
	    else
		sprintf((char *)showcmd_buf, ""%d-%d"", chars, bytes);
",1,unused,3815,unused,"	    }
	    if (bytes == chars)
		sprintf((char *)showcmd_buf, ""%d"", chars);
	    else
		sprintf((char *)showcmd_buf, ""%d-%d"", chars, bytes);
",unused,gawkxenpatch-src2Fnormal.c
"	return FAIL;

    /* Put ""\V"" before the pattern to avoid that the special meaning of "".""
     * and ""~"" causes trouble. */
    sprintf((char *)pat, vim_iswordp(ptr) ? ""\\V\\<%.*s\\>"" : ""\\V%.*s"",
",1,unused,4269,unused,"	return FAIL;

    /* Put ""\V"" before the pattern to avoid that the special meaning of "".""
     * and ""~"" causes trouble. */
    sprintf((char *)pat, vim_iswordp(ptr) ? ""\\V\\<%.*s\\>"" : ""\\V%.*s"",
",unused,gawkxenpatch-src2Fnormal.c
"		 * really what we want? */
		isman = (STRCMP(kp, ""man"") == 0);
		isman_s = (STRCMP(kp, ""man -s"") == 0);
		if (cap->count0 != 0 && !(isman || isman_s))
		    sprintf((char *)buf, "".,.+%ld"", cap->count0 - 1);
",1,unused,5585,unused,"		 * really what we want? */
		isman = (STRCMP(kp, ""man"") == 0);
		isman_s = (STRCMP(kp, ""man -s"") == 0);
		if (cap->count0 != 0 && !(isman || isman_s))
		    sprintf((char *)buf, "".,.+%ld"", cap->count0 - 1);
",unused,gawkxenpatch-src2Fnormal.c
"		    STRCAT(buf, kp);
		STRCAT(buf, "" "");
		if (cap->count0 != 0 && (isman || isman_s))
		{
		    sprintf((char *)buf + STRLEN(buf), ""%ld"", cap->count0);
",1,unused,5595,unused,"		    STRCAT(buf, kp);
		STRCAT(buf, "" "");
		if (cap->count0 != 0 && (isman || isman_s))
		{
		    sprintf((char *)buf + STRLEN(buf), ""%ld"", cap->count0);
",unused,gawkxenpatch-src2Fnormal.c
"	    {
		if (g_cmd)
		    STRCPY(buf, ""tj "");
		else
		    sprintf((char *)buf, ""%ldta "", cap->count0);
",1,unused,5620,unused,"	    {
		if (g_cmd)
		    STRCPY(buf, ""tj "");
		else
		    sprintf((char *)buf, ""%ldta "", cap->count0);
",unused,gawkxenpatch-src2Fnormal.c
"	    s = (char_u *)""<"";
	if (oap->line_count == 1)
	{
	    if (amount == 1)
		sprintf((char *)IObuff, _(""1 line %sed 1 time""), s);
",1,unused,284,unused,"	    s = (char_u *)""<"";
	if (oap->line_count == 1)
	{
	    if (amount == 1)
		sprintf((char *)IObuff, _(""1 line %sed 1 time""), s);
",unused,gawkxenpatch-src2Fops.c
"	{
	    if (amount == 1)
		sprintf((char *)IObuff, _(""1 line %sed 1 time""), s);
	    else
		sprintf((char *)IObuff, _(""1 line %sed %d times""), s, amount);
",1,unused,286,unused,"	{
	    if (amount == 1)
		sprintf((char *)IObuff, _(""1 line %sed 1 time""), s);
	    else
		sprintf((char *)IObuff, _(""1 line %sed %d times""), s, amount);
",unused,gawkxenpatch-src2Fops.c
"	}
	else
	{
	    if (amount == 1)
		sprintf((char *)IObuff, _(""%ld lines %sed 1 time""),
",1,unused,291,unused,"	}
	else
	{
	    if (amount == 1)
		sprintf((char *)IObuff, _(""%ld lines %sed 1 time""),
",unused,gawkxenpatch-src2Fops.c
"	    if (amount == 1)
		sprintf((char *)IObuff, _(""%ld lines %sed 1 time""),
							  oap->line_count, s);
	    else
		sprintf((char *)IObuff, _(""%ld lines %sed %d times""),
",1,unused,294,unused,"	    if (amount == 1)
		sprintf((char *)IObuff, _(""%ld lines %sed 1 time""),
							  oap->line_count, s);
	    else
		sprintf((char *)IObuff, _(""%ld lines %sed %d times""),
",unused,gawkxenpatch-src2Fops.c
"
	    buf2[i] = '\0';
	}
	else if (pre == 0)
	    sprintf((char *)buf2, ""%lu"", n);
",1,unused,5747,unused,"
	    buf2[i] = '\0';
	}
	else if (pre == 0)
	    sprintf((char *)buf2, ""%lu"", n);
",unused,gawkxenpatch-src2Fops.c
"	}
	else if (pre == 0)
	    sprintf((char *)buf2, ""%lu"", n);
	else if (pre == '0')
	    sprintf((char *)buf2, ""%lo"", n);
",1,unused,5749,unused,"	}
	else if (pre == 0)
	    sprintf((char *)buf2, ""%lu"", n);
	else if (pre == '0')
	    sprintf((char *)buf2, ""%lo"", n);
",unused,gawkxenpatch-src2Fops.c
"	    sprintf((char *)buf2, ""%lu"", n);
	else if (pre == '0')
	    sprintf((char *)buf2, ""%lo"", n);
	else if (pre && hexupper)
	    sprintf((char *)buf2, ""%lX"", n);
",1,unused,5751,unused,"	    sprintf((char *)buf2, ""%lu"", n);
	else if (pre == '0')
	    sprintf((char *)buf2, ""%lo"", n);
	else if (pre && hexupper)
	    sprintf((char *)buf2, ""%lX"", n);
",unused,gawkxenpatch-src2Fops.c
"	    sprintf((char *)buf2, ""%lo"", n);
	else if (pre && hexupper)
	    sprintf((char *)buf2, ""%lX"", n);
	else
	    sprintf((char *)buf2, ""%lx"", n);
",1,unused,5753,unused,"	    sprintf((char *)buf2, ""%lo"", n);
	else if (pre && hexupper)
	    sprintf((char *)buf2, ""%lX"", n);
	else
	    sprintf((char *)buf2, ""%lx"", n);
",unused,gawkxenpatch-src2Fops.c
"	    case MBLOCK:
		type = (char_u *)""BLOCK"";
		break;
	    default:
		sprintf((char *)IObuff, _(""E574: Unknown register type %d""),
",1,unused,5994,unused,"	    case MBLOCK:
		type = (char_u *)""BLOCK"";
		break;
	    default:
		sprintf((char *)IObuff, _(""E574: Unknown register type %d""),
",unused,gawkxenpatch-src2Fops.c
"			if (saved_origval != NULL)
			{
			    char_u buf_type[7];

			    sprintf((char *)buf_type, ""%s"",
",1,unused,4963,unused,"			if (saved_origval != NULL)
			{
			    char_u buf_type[7];

			    sprintf((char *)buf_type, ""%s"",
",unused,gawkxenpatch-src2Foption.c
"illegal_char(char_u *errbuf, int c)
{
    if (errbuf == NULL)
	return (char_u *)"""";
    sprintf((char *)errbuf, _(""E539: Illegal character <%s>""),
",1,unused,5100,unused,"illegal_char(char_u *errbuf, int c)
{
    if (errbuf == NULL)
	return (char_u *)"""";
    sprintf((char *)errbuf, _(""E539: Illegal character <%s>""),
",unused,gawkxenpatch-src2Foption.c
"#if defined(FEAT_AUTOCMD) && defined(FEAT_EVAL)
	if (saved_oldval != NULL)
	{
	    char_u buf_type[7];
	    sprintf((char *)buf_type, ""%s"",
",1,unused,5792,unused,"#if defined(FEAT_AUTOCMD) && defined(FEAT_EVAL)
	if (saved_oldval != NULL)
	{
	    char_u buf_type[7];
	    sprintf((char *)buf_type, ""%s"",
",unused,gawkxenpatch-src2Foption.c
"		if (!VIM_ISDIGIT(*(s - 1)))
		{
		    if (errbuf != NULL)
		    {
			sprintf((char *)errbuf,
",1,unused,6514,unused,"		if (!VIM_ISDIGIT(*(s - 1)))
		{
		    if (errbuf != NULL)
		    {
			sprintf((char *)errbuf,
",unused,gawkxenpatch-src2Foption.c
"		else
		{
		    if (errbuf != NULL)
		    {
			sprintf((char *)errbuf,
",1,unused,6954,unused,"		else
		{
		    if (errbuf != NULL)
		    {
			sprintf((char *)errbuf,
",unused,gawkxenpatch-src2Foption.c
"	    STRCPY(NameBuff, get_special_key_name((int)wc, 0));
	else if (wc != 0)
	    STRCPY(NameBuff, transchar((int)wc));
	else
	    sprintf((char *)NameBuff, ""%ld"", *(long *)varp);
",1,unused,11371,unused,"	    STRCPY(NameBuff, get_special_key_name((int)wc, 0));
	else if (wc != 0)
	    STRCPY(NameBuff, transchar((int)wc));
	else
	    sprintf((char *)NameBuff, ""%ld"", *(long *)varp);
",unused,gawkxenpatch-src2Foption.c
"    }

    /* No translation, it may call malloc(). */
#ifdef SIGHASARG
    sprintf((char *)IObuff, ""Vim: Caught deadly signal %s\n"",
",1,unused,1102,unused,"    }

    /* No translation, it may call malloc(). */
#ifdef SIGHASARG
    sprintf((char *)IObuff, ""Vim: Caught deadly signal %s\n"",
",unused,gawkxenpatch-src2Fos_unix.c
"	vim_strncpy(s, (char_u *)pw->pw_name, len - 1);
	return OK;
    }
#endif
    sprintf((char *)s, ""%d"", (int)uid);	    /* assumes s is long enough */
",1,unused,2309,unused,"	vim_strncpy(s, (char_u *)pw->pw_name, len - 1);
	return OK;
    }
#endif
    sprintf((char *)s, ""%d"", (int)uid);	    /* assumes s is long enough */
",unused,gawkxenpatch-src2Fos_unix.c
"
    /* Simulate to have a dumb terminal (for now) */
# ifdef HAVE_SETENV
    setenv(""TERM"", ""dumb"", 1);
    sprintf((char *)envbuf, ""%ld"", Rows);
",1,unused,4002,unused,"
    /* Simulate to have a dumb terminal (for now) */
# ifdef HAVE_SETENV
    setenv(""TERM"", ""dumb"", 1);
    sprintf((char *)envbuf, ""%ld"", Rows);
",unused,gawkxenpatch-src2Fos_unix.c
"# ifdef HAVE_SETENV
    setenv(""TERM"", ""dumb"", 1);
    sprintf((char *)envbuf, ""%ld"", Rows);
    setenv(""ROWS"", (char *)envbuf, 1);
    sprintf((char *)envbuf, ""%ld"", Rows);
",1,unused,4004,unused,"# ifdef HAVE_SETENV
    setenv(""TERM"", ""dumb"", 1);
    sprintf((char *)envbuf, ""%ld"", Rows);
    setenv(""ROWS"", (char *)envbuf, 1);
    sprintf((char *)envbuf, ""%ld"", Rows);
",unused,gawkxenpatch-src2Fos_unix.c
"    sprintf((char *)envbuf, ""%ld"", Rows);
    setenv(""ROWS"", (char *)envbuf, 1);
    sprintf((char *)envbuf, ""%ld"", Rows);
    setenv(""LINES"", (char *)envbuf, 1);
    sprintf((char *)envbuf, ""%ld"", Columns);
",1,unused,4006,unused,"    sprintf((char *)envbuf, ""%ld"", Rows);
    setenv(""ROWS"", (char *)envbuf, 1);
    sprintf((char *)envbuf, ""%ld"", Rows);
    setenv(""LINES"", (char *)envbuf, 1);
    sprintf((char *)envbuf, ""%ld"", Columns);
",unused,gawkxenpatch-src2Fos_unix.c
"		if (idx < FMT_PATTERNS)
		{
		    if (fmt_ptr->addr[idx])
		    {
			sprintf((char *)errmsg,
",1,unused,335,unused,"		if (idx < FMT_PATTERNS)
		{
		    if (fmt_ptr->addr[idx])
		    {
			sprintf((char *)errmsg,
",unused,gawkxenpatch-src2Fquickfix.c
"			    || (idx == 6
				&& vim_strchr((char_u *)""OPQ"",
						    fmt_ptr->prefix) == NULL))
		    {
			sprintf((char *)errmsg,
",1,unused,348,unused,"			    || (idx == 6
				&& vim_strchr((char_u *)""OPQ"",
						    fmt_ptr->prefix) == NULL))
		    {
			sprintf((char *)errmsg,
",unused,gawkxenpatch-src2Fquickfix.c
"		    }
		    else
		    {
			/* TODO: scanf()-like: %*ud, %*3c, %*f, ... ? */
			sprintf((char *)errmsg,
",1,unused,424,unused,"		    }
		    else
		    {
			/* TODO: scanf()-like: %*ud, %*3c, %*f, ... ? */
			sprintf((char *)errmsg,
",unused,gawkxenpatch-src2Fquickfix.c
"		    if (vim_strchr((char_u *)""DXAEWICZGOPQ"", *efmp) != NULL)
			fmt_ptr->prefix = *efmp;
		    else
		    {
			sprintf((char *)errmsg,
",1,unused,444,unused,"		    if (vim_strchr((char_u *)""DXAEWICZGOPQ"", *efmp) != NULL)
			fmt_ptr->prefix = *efmp;
		    else
		    {
			sprintf((char *)errmsg,
",unused,gawkxenpatch-src2Fquickfix.c
"		    }
		}
		else
		{
		    sprintf((char *)errmsg,
",1,unused,452,unused,"		    }
		}
		else
		{
		    sprintf((char *)errmsg,
",unused,gawkxenpatch-src2Fquickfix.c
"	char_u *p = alloc((int)STRLEN(title) + 2);

	qi->qf_lists[qi->qf_curlist].qf_title = p;
	if (p != NULL)
	    sprintf((char *)p, "":%s"", (char *)title);
",1,unused,898,unused,"	char_u *p = alloc((int)STRLEN(title) + 2);

	qi->qf_lists[qi->qf_curlist].qf_title = p;
	if (p != NULL)
	    sprintf((char *)p, "":%s"", (char *)title);
",unused,gawkxenpatch-src2Fquickfix.c
"	    /* Update the screen before showing the message, unless the screen
	     * scrolled up. */
	    if (!msg_scrolled)
		update_topline_redraw();
	    sprintf((char *)IObuff, _(""(%d of %d)%s%s: ""), qf_index,
",1,unused,1931,unused,"	    /* Update the screen before showing the message, unless the screen
	     * scrolled up. */
	    if (!msg_scrolled)
		update_topline_redraw();
	    sprintf((char *)IObuff, _(""(%d of %d)%s%s: ""), qf_index,
",unused,gawkxenpatch-src2Fquickfix.c
"		if (qfp->qf_type == 1)	/* :helpgrep */
		    fname = gettail(fname);
	    }
	    if (fname == NULL)
		sprintf((char *)IObuff, ""%2d"", i);
",1,unused,2057,unused,"		if (qfp->qf_type == 1)	/* :helpgrep */
		    fname = gettail(fname);
	    }
	    if (fname == NULL)
		sprintf((char *)IObuff, ""%2d"", i);
",unused,gawkxenpatch-src2Fquickfix.c
"					   ? hl_attr(HLF_L) : hl_attr(HLF_D));
	    if (qfp->qf_lnum == 0)
		IObuff[0] = NUL;
	    else if (qfp->qf_col == 0)
		sprintf((char *)IObuff, "":%ld"", qfp->qf_lnum);
",1,unused,2066,unused,"					   ? hl_attr(HLF_L) : hl_attr(HLF_D));
	    if (qfp->qf_lnum == 0)
		IObuff[0] = NUL;
	    else if (qfp->qf_col == 0)
		sprintf((char *)IObuff, "":%ld"", qfp->qf_lnum);
",unused,gawkxenpatch-src2Fquickfix.c
"		IObuff[0] = NUL;
	    else if (qfp->qf_col == 0)
		sprintf((char *)IObuff, "":%ld"", qfp->qf_lnum);
	    else
		sprintf((char *)IObuff, "":%ld col %d"",
",1,unused,2068,unused,"		IObuff[0] = NUL;
	    else if (qfp->qf_col == 0)
		sprintf((char *)IObuff, "":%ld"", qfp->qf_lnum);
	    else
		sprintf((char *)IObuff, "":%ld col %d"",
",unused,gawkxenpatch-src2Fquickfix.c
"		sprintf((char *)IObuff, "":%ld"", qfp->qf_lnum);
	    else
		sprintf((char *)IObuff, "":%ld col %d"",
						   qfp->qf_lnum, qfp->qf_col);
	    sprintf((char *)IObuff + STRLEN(IObuff), ""%s:"",
",1,unused,2070,unused,"		sprintf((char *)IObuff, "":%ld"", qfp->qf_lnum);
	    else
		sprintf((char *)IObuff, "":%ld col %d"",
						   qfp->qf_lnum, qfp->qf_col);
	    sprintf((char *)IObuff + STRLEN(IObuff), ""%s:"",
",unused,gawkxenpatch-src2Fquickfix.c
"
    if (nr <= 0)
	return p;

    sprintf((char *)buf, ""%s %3d"", (char *)p, nr);
",1,unused,2297,unused,"
    if (nr <= 0)
	return p;

    sprintf((char *)buf, ""%s %3d"", (char *)p, nr);
",unused,gawkxenpatch-src2Fquickfix.c
"	    IObuff[len++] = '|';

	    if (qfp->qf_lnum > 0)
	    {
		sprintf((char *)IObuff + len, ""%ld"", qfp->qf_lnum);
",1,unused,2691,unused,"	    IObuff[len++] = '|';

	    if (qfp->qf_lnum > 0)
	    {
		sprintf((char *)IObuff + len, ""%ld"", qfp->qf_lnum);
",unused,gawkxenpatch-src2Fquickfix.c
"		len += (int)STRLEN(IObuff + len);

		if (qfp->qf_col > 0)
		{
		    sprintf((char *)IObuff + len, "" col %d"", qfp->qf_col);
",1,unused,2696,unused,"		len += (int)STRLEN(IObuff + len);

		if (qfp->qf_col > 0)
		{
		    sprintf((char *)IObuff + len, "" col %d"", qfp->qf_col);
",unused,gawkxenpatch-src2Fquickfix.c
"		    sprintf((char *)IObuff + len, "" col %d"", qfp->qf_col);
		    len += (int)STRLEN(IObuff + len);
		}

		sprintf((char *)IObuff + len, ""%s"",
",1,unused,2700,unused,"		    sprintf((char *)IObuff + len, "" col %d"", qfp->qf_col);
		    len += (int)STRLEN(IObuff + len);
		}

		sprintf((char *)IObuff + len, ""%s"",
",unused,gawkxenpatch-src2Fquickfix.c
"	len += (unsigned)STRLEN(p_sp) + (unsigned)STRLEN(fname) + 3;
    cmd = alloc(len);
    if (cmd == NULL)
	return;
    sprintf((char *)cmd, ""%s%s%s"", (char *)p_shq, (char *)eap->arg,
",1,unused,2888,unused,"	len += (unsigned)STRLEN(p_sp) + (unsigned)STRLEN(fname) + 3;
    cmd = alloc(len);
    if (cmd == NULL)
	return;
    sprintf((char *)cmd, ""%s%s%s"", (char *)p_shq, (char *)eap->arg,
",unused,gawkxenpatch-src2Fquickfix.c
"	name = alloc((unsigned)STRLEN(p_mef) + 30);
	if (name == NULL)
	    break;
	STRCPY(name, p_mef);
	sprintf((char *)name + (p - p_mef), ""%d%d"", start, off);
",1,unused,2980,unused,"	name = alloc((unsigned)STRLEN(p_mef) + 30);
	if (name == NULL)
	    break;
	STRCPY(name, p_mef);
	sprintf((char *)name + (p - p_mef), ""%d%d"", start, off);
",unused,gawkxenpatch-src2Fquickfix.c
"		    fmt = ""%-*ld "";
		}
	    }

	    sprintf((char *)buf, fmt, w, num);
",1,unused,2523,unused,"		    fmt = ""%-*ld "";
		}
	    }

	    sprintf((char *)buf, fmt, w, num);
",unused,gawkxenpatch-src2Fscreen.c
"				fmt = ""%-*ld "";
			    }
			}

			sprintf((char *)extra, fmt,
",1,unused,3729,unused,"				fmt = ""%-*ld "";
			    }
			}

			sprintf((char *)extra, fmt,
",unused,gawkxenpatch-src2Fscreen.c
"#endif
		p = (char_u *)""lang"";
	}
	if ((int)(STRLEN(p) + 3) < len)
	    sprintf((char *)buf, ""<%s>"", p);
",1,unused,6876,unused,"#endif
		p = (char_u *)""lang"";
	}
	if ((int)(STRLEN(p) + 3) < len)
	    sprintf((char *)buf, ""<%s>"", p);
",unused,gawkxenpatch-src2Fscreen.c
"	{
	    char	buf[20];

	    /* The GUI handles this internally. */
	    sprintf(buf, IF_EB(""\033|%dh"", ESC_STR ""|%dh""), attr);
",1,unused,7822,unused,"	{
	    char	buf[20];

	    /* The GUI handles this internally. */
	    sprintf(buf, IF_EB(""\033|%dh"", ESC_STR ""|%dh""), attr);
",unused,gawkxenpatch-src2Fscreen.c
"	{
	    char	buf[20];

	    /* use internal GUI code */
	    sprintf(buf, IF_EB(""\033|%dH"", ESC_STR ""|%dH""), screen_attr);
",1,unused,7896,unused,"	{
	    char	buf[20];

	    /* use internal GUI code */
	    sprintf(buf, IF_EB(""\033|%dH"", ESC_STR ""|%dH""), screen_attr);
",unused,gawkxenpatch-src2Fscreen.c
"    MSG_PUTS_ATTR(_(""recording""), attr);
    if (!shortmess(SHM_RECORDING))
    {
	char_u s[4];
	sprintf((char *)s, "" @%c"", Recording);
",1,unused,10202,unused,"    MSG_PUTS_ATTR(_(""recording""), attr);
    if (!shortmess(SHM_RECORDING))
    {
	char_u s[4];
	sprintf((char *)s, "" @%c"", Recording);
",unused,gawkxenpatch-src2Fscreen.c
"			*p++ = 's';
		    if (spats[0].off.off > 0 || spats[0].off.line)
			*p++ = '+';
		    if (spats[0].off.off != 0 || spats[0].off.line)
			sprintf((char *)p, ""%ld"", spats[0].off.off);
",1,unused,1343,unused,"			*p++ = 's';
		    if (spats[0].off.off > 0 || spats[0].off.line)
			*p++ = '+';
		    if (spats[0].off.off != 0 || spats[0].off.line)
			sprintf((char *)p, ""%ld"", spats[0].off.off);
",unused,gawkxenpatch-src2Fsearch.c
"	vim_free(epat);
	curwin->w_cursor = old_pos;
	goto theend;
    }
    sprintf((char *)spat, ""<%.*s\\>\\%%(\\s\\_[^>]\\{-}[^/]>\\|>\\)\\c"", len, p);
",1,unused,3982,unused,"	vim_free(epat);
	curwin->w_cursor = old_pos;
	goto theend;
    }
    sprintf((char *)spat, ""<%.*s\\>\\%%(\\s\\_[^>]\\{-}[^/]>\\|>\\)\\c"", len, p);
",unused,gawkxenpatch-src2Fsearch.c
"	curwin->w_cursor = old_pos;
	goto theend;
    }
    sprintf((char *)spat, ""<%.*s\\>\\%%(\\s\\_[^>]\\{-}[^/]>\\|>\\)\\c"", len, p);
    sprintf((char *)epat, ""</%.*s>\\c"", len, p);
",1,unused,3983,unused,"	curwin->w_cursor = old_pos;
	goto theend;
    }
    sprintf((char *)spat, ""<%.*s\\>\\%%(\\s\\_[^>]\\{-}[^/]>\\|>\\)\\c"", len, p);
    sprintf((char *)epat, ""</%.*s>\\c"", len, p);
",unused,gawkxenpatch-src2Fsearch.c
"    {
	pat = alloc(len + 5);
	if (pat == NULL)
	    goto fpip_end;
	sprintf((char *)pat, whole ? ""\\<%.*s\\>"" : ""%.*s"", len, ptr);
",1,unused,4861,unused,"    {
	pat = alloc(len + 5);
	if (pat == NULL)
	    goto fpip_end;
	sprintf((char *)pat, whole ? ""\\<%.*s\\>"" : ""%.*s"", len, ptr);
",unused,gawkxenpatch-src2Fsearch.c
"	    *(p + 1) = NUL;
	}
	if (action == ACTION_SHOW_ALL)
	{
	    sprintf((char *)IObuff, ""%3ld: "", count);	/* show match nr */
",1,unused,5535,unused,"	    *(p + 1) = NUL;
	}
	if (action == ACTION_SHOW_ALL)
	{
	    sprintf((char *)IObuff, ""%3ld: "", count);	/* show match nr */
",unused,gawkxenpatch-src2Fsearch.c
"	if (action == ACTION_SHOW_ALL)
	{
	    sprintf((char *)IObuff, ""%3ld: "", count);	/* show match nr */
	    msg_puts(IObuff);
	    sprintf((char *)IObuff, ""%4ld"", *lnum);	/* show line nr */
",1,unused,5537,unused,"	if (action == ACTION_SHOW_ALL)
	{
	    sprintf((char *)IObuff, ""%3ld: "", count);	/* show match nr */
	    msg_puts(IObuff);
	    sprintf((char *)IObuff, ""%4ld"", *lnum);	/* show line nr */
",unused,gawkxenpatch-src2Fsearch.c
"    if (salt != NULL)
	sha256_update(&ctx, salt, salt_len);
    sha256_finish(&ctx, sha256sum);
    for (j = 0; j < 32; j++)
	sprintf((char *)hexit + j * 2, ""%02x"", sha256sum[j]);
",1,unused,294,unused,"    if (salt != NULL)
	sha256_update(&ctx, salt, salt_len);
    sha256_finish(&ctx, sha256sum);
    for (j = 0; j < 32; j++)
	sprintf((char *)hexit + j * 2, ""%02x"", sha256sum[j]);
",unused,gawkxenpatch-src2Fsha256.c
"	    for (j = 0; j < 1000; j++)
		sha256_update(&ctx, (char_u *)buf, 1000);
	    sha256_finish(&ctx, sha256sum);
	    for (j = 0; j < 32; j++)
		sprintf(output + j * 2, ""%02x"", sha256sum[j]);
",1,unused,371,unused,"	    for (j = 0; j < 1000; j++)
		sha256_update(&ctx, (char_u *)buf, 1000);
	    sha256_finish(&ctx, sha256sum);
	    for (j = 0; j < 32; j++)
		sprintf(output + j * 2, ""%02x"", sha256sum[j]);
",unused,gawkxenpatch-src2Fsha256.c
"			char_u	buf[MAXLINELEN];

			aff_entry->ae_cond = getroom_save(spin, items[4]);
			if (*items[0] == 'P')
			    sprintf((char *)buf, ""^%s"", items[4]);
",1,unused,5720,unused,"			char_u	buf[MAXLINELEN];

			aff_entry->ae_cond = getroom_save(spin, items[4]);
			if (*items[0] == 'P')
			    sprintf((char *)buf, ""^%s"", items[4]);
",unused,gawkxenpatch-src2Fspell.c
"			aff_entry->ae_cond = getroom_save(spin, items[4]);
			if (*items[0] == 'P')
			    sprintf((char *)buf, ""^%s"", items[4]);
			else
			    sprintf((char *)buf, ""%s$"", items[4]);
",1,unused,5722,unused,"			aff_entry->ae_cond = getroom_save(spin, items[4]);
			if (*items[0] == 'P')
			    sprintf((char *)buf, ""^%s"", items[4]);
			else
			    sprintf((char *)buf, ""%s$"", items[4]);
",unused,gawkxenpatch-src2Fspell.c
"#endif
					    *aff_entry->ae_cond = c_up;
					if (aff_entry->ae_cond != NULL)
					{
					    sprintf((char *)buf, ""^%s"",
",1,unused,5787,unused,"#endif
					    *aff_entry->ae_cond = c_up;
					if (aff_entry->ae_cond != NULL)
					{
					    sprintf((char *)buf, ""^%s"",
",unused,gawkxenpatch-src2Fspell.c
"
    frompat = alloc((unsigned)STRLEN(repl_from) + 7);
    if (frompat == NULL)
	return;
    sprintf((char *)frompat, ""\\V\\<%s\\>"", repl_from);
",1,unused,10401,unused,"
    frompat = alloc((unsigned)STRLEN(repl_from) + 7);
    if (frompat == NULL)
	return;
    sprintf((char *)frompat, ""\\V\\<%s\\>"", repl_from);
",unused,gawkxenpatch-src2Fspell.c
"		STRCAT(badword, ""?"");
	    if (flags & WF_REGION)
		for (i = 0; i < 7; ++i)
		    if (flags & (0x10000 << i))
			sprintf((char *)badword + STRLEN(badword), ""%d"", i + 1);
",1,unused,15836,unused,"		STRCAT(badword, ""?"");
	    if (flags & WF_REGION)
		for (i = 0; i < 7; ++i)
		    if (flags & (0x10000 << i))
			sprintf((char *)badword + STRLEN(badword), ""%d"", i + 1);
",unused,gawkxenpatch-src2Fspell.c
"    recursive = TRUE;
    buf = alloc((unsigned)(STRLEN(name) + 12));
    if (buf != NULL)
    {
	sprintf((char *)buf, ""colors/%s.vim"", name);
",1,unused,7106,unused,"    recursive = TRUE;
    buf = alloc((unsigned)(STRLEN(name) + 12));
    if (buf != NULL)
    {
	sprintf((char *)buf, ""colors/%s.vim"", name);
",unused,gawkxenpatch-src2Fsyntax.c
"    if (type == LIST_STRING ? (sarg != NULL) : (iarg != 0))
    {
	ts = buf;
	if (type == LIST_INT)
	    sprintf((char *)buf, ""%d"", iarg - 1);
",1,unused,8864,unused,"    if (type == LIST_STRING ? (sarg != NULL) : (iarg != 0))
    {
	ts = buf;
	if (type == LIST_INT)
	    sprintf((char *)buf, ""%d"", iarg - 1);
",unused,gawkxenpatch-src2Fsyntax.c
"		color = HL_TABLE()[id - 1].sg_gui_bg;
	    if (color == INVALCOLOR)
		return NULL;
	    rgb = gui_mch_get_rgb(color);
	    sprintf((char *)buf, ""#%02x%02x%02x"",
",1,unused,8981,unused,"		color = HL_TABLE()[id - 1].sg_gui_bg;
	    if (color == INVALCOLOR)
		return NULL;
	    rgb = gui_mch_get_rgb(color);
	    sprintf((char *)buf, ""#%02x%02x%02x"",
",unused,gawkxenpatch-src2Fsyntax.c
"	else
	    n = HL_TABLE()[id - 1].sg_cterm_bg - 1;
	if (n < 0)
	    return NULL;
	sprintf((char *)name, ""%d"", n);
",1,unused,9004,unused,"	else
	    n = HL_TABLE()[id - 1].sg_cterm_bg - 1;
	if (n < 0)
	    return NULL;
	sprintf((char *)name, ""%d"", n);
",unused,gawkxenpatch-src2Fsyntax.c
"    }
# endif
    for (i = 0; i < 9; i++)
    {
	sprintf((char *)userhl, ""User%d"", i + 1);
",1,unused,9594,unused,"    }
# endif
    for (i = 0; i < 9; i++)
    {
	sprintf((char *)userhl, ""User%d"", i + 1);
",unused,gawkxenpatch-src2Fsyntax.c
"		&& (num_matches > 1 || ic)
		&& !skip_msg)
	    {
		/* Give an indication of the number of matching tags */
		sprintf((char *)IObuff, _(""tag %d of %d%s""),
",1,unused,1000,unused,"		&& (num_matches > 1 || ic)
		&& !skip_msg)
	    {
		/* Give an indication of the number of matching tags */
		sprintf((char *)IObuff, _(""tag %d of %d%s""),
",unused,gawkxenpatch-src2Ftag.c
"	    if (name == NULL)	    /* file name not available */
		continue;

	    msg_putchar('\n');
	    sprintf((char *)IObuff, ""%c%2d %2d %-15s %5ld  "",
",1,unused,1136,unused,"	    if (name == NULL)	    /* file name not available */
		continue;

	    msg_putchar('\n');
	    sprintf((char *)IObuff, ""%c%2d %2d %-15s %5ld  "",
",unused,gawkxenpatch-src2Ftag.c
"#ifdef FEAT_MULTI_LANG
			    p[len] = '@';
			    STRCPY(p + len + 1, help_lang);
#endif
			    sprintf((char *)p + len + 1 + ML_EXTRA, ""%06d"",
",1,unused,2288,unused,"#ifdef FEAT_MULTI_LANG
			    p[len] = '@';
			    STRCPY(p + len + 1, help_lang);
#endif
			    sprintf((char *)p + len + 1 + ML_EXTRA, ""%06d"",
",unused,gawkxenpatch-src2Ftag.c
"		    found = 2;
		    (void)test_for_static(&tagp);
		    cc = *tagp.tagname_end;
		    *tagp.tagname_end = NUL;
		    sprintf((char *)pbuf, ""^%s\\s\\*("", tagp.tagname);
",1,unused,3271,unused,"		    found = 2;
		    (void)test_for_static(&tagp);
		    cc = *tagp.tagname_end;
		    *tagp.tagname_end = NUL;
		    sprintf((char *)pbuf, ""^%s\\s\\*("", tagp.tagname);
",unused,gawkxenpatch-src2Ftag.c
"		    if (!do_search(NULL, '/', pbuf, (long)1,
							search_options, NULL))
		    {
			/* Guess again: ""^char * \<func  ("" */
			sprintf((char *)pbuf, ""^\\[#a-zA-Z_]\\.\\*\\<%s\\s\\*("",
",1,unused,3276,unused,"		    if (!do_search(NULL, '/', pbuf, (long)1,
							search_options, NULL))
		    {
			/* Guess again: ""^char * \<func  ("" */
			sprintf((char *)pbuf, ""^\\[#a-zA-Z_]\\.\\*\\<%s\\s\\*("",
",unused,gawkxenpatch-src2Ftag.c
"	    /* Check for 9.9x or 9.9xx, alpha/beta version */
	    if (isalpha((int)vers[3]))
	    {
		int len = (isalpha((int)vers[4])) ? 5 : 4;
		sprintf((char *)vers + len, "".%d%s"", highest_patch(),
",1,unused,4754,unused,"	    /* Check for 9.9x or 9.9xx, alpha/beta version */
	    if (isalpha((int)vers[3]))
	    {
		int len = (isalpha((int)vers[4])) ? 5 : 4;
		sprintf((char *)vers + len, "".%d%s"", highest_patch(),
",unused,gawkxenpatch-src2Fversion.c
"		sprintf((char *)vers + len, "".%d%s"", highest_patch(),
							 mediumVersion + len);
	    }
	    else
		sprintf((char *)vers + 3, "".%d"", highest_patch());
",1,unused,4758,unused,"		sprintf((char *)vers + len, "".%d%s"", highest_patch(),
							 mediumVersion + len);
	    }
	    else
		sprintf((char *)vers + 3, "".%d"", highest_patch());
",unused,gawkxenpatch-src2Fversion.c
"		 * cursor in a new window.
		 */
		if (bt_quickfix(curbuf))
		{
		    sprintf((char *)cbuf, ""split +%ld%s"",
",1,unused,528,unused,"		 * cursor in a new window.
		 */
		if (bt_quickfix(curbuf))
		{
		    sprintf((char *)cbuf, ""split +%ld%s"",
",unused,gawkxenpatch-src2Fwindow.c
"  static char z[LLEN+1];
  static int zero_seen = 0;

  if (!nz && zero_seen == 1)
    strcpy(z, l);
",1,unused,420,unused,"  static char z[LLEN+1];
  static int zero_seen = 0;

  if (!nz && zero_seen == 1)
    strcpy(z, l);
",unused,gawkxenpatch-src2Fxxd2Fxxd.c
"  while ((length < 0 || n < length) && (e = getc(fp)) != EOF)
    {
      if (p == 0)
	{
	  sprintf(l, ""%08lx:"",
",1,unused,823,unused,"  while ((length < 0 || n < length) && (e = getc(fp)) != EOF)
    {
      if (p == 0)
	{
	  sprintf(l, ""%08lx:"",
",unused,gawkxenpatch-src2Fxxd2Fxxd.c
"      gdbm_errno = GDBM_MALLOC_ERROR;	/* For the hell of it. */
      return -1;
    }

  strcpy (pag_file, file);
",1,unused,69,unused,"      gdbm_errno = GDBM_MALLOC_ERROR;	/* For the hell of it. */
      return -1;
    }

  strcpy (pag_file, file);
",unused,gdbmdebstretche-dbminit.c
"      return -1;
    }

  strcpy (pag_file, file);
  strcat (pag_file, "".pag"");
",1,unused,70,unused,"      return -1;
    }

  strcpy (pag_file, file);
  strcat (pag_file, "".pag"");
",unused,gdbmdebstretche-dbminit.c
"    }

  strcpy (pag_file, file);
  strcat (pag_file, "".pag"");
  strcpy (dir_file, file);
",1,unused,71,unused,"    }

  strcpy (pag_file, file);
  strcat (pag_file, "".pag"");
  strcpy (dir_file, file);
",unused,gdbmdebstretche-dbminit.c
"
  strcpy (pag_file, file);
  strcat (pag_file, "".pag"");
  strcpy (dir_file, file);
  strcat (dir_file, "".dir"");
",1,unused,72,unused,"
  strcpy (pag_file, file);
  strcat (pag_file, "".pag"");
  strcpy (dir_file, file);
  strcat (dir_file, "".dir"");
",unused,gdbmdebstretche-dbminit.c
"      gdbm_errno = GDBM_MALLOC_ERROR;	/* For the hell of it. */
      return NULL;
    }

  strcpy (pag_file, file);
",1,unused,76,unused,"      gdbm_errno = GDBM_MALLOC_ERROR;	/* For the hell of it. */
      return NULL;
    }

  strcpy (pag_file, file);
",unused,gdbmdebstretche-dbmopen.c
"      return NULL;
    }

  strcpy (pag_file, file);
  strcat (pag_file, "".pag"");
",1,unused,77,unused,"      return NULL;
    }

  strcpy (pag_file, file);
  strcat (pag_file, "".pag"");
",unused,gdbmdebstretche-dbmopen.c
"    }

  strcpy (pag_file, file);
  strcat (pag_file, "".pag"");
  strcpy (dir_file, file);
",1,unused,78,unused,"    }

  strcpy (pag_file, file);
  strcat (pag_file, "".pag"");
  strcpy (dir_file, file);
",unused,gdbmdebstretche-dbmopen.c
"
  strcpy (pag_file, file);
  strcat (pag_file, "".pag"");
  strcpy (dir_file, file);
  strcat (dir_file, "".dir"");
",1,unused,79,unused,"
  strcpy (pag_file, file);
  strcat (pag_file, "".pag"");
  strcpy (dir_file, file);
  strcat (dir_file, "".dir"");
",unused,gdbmdebstretche-dbmopen.c
"      free (dbf);
      gdbm_errno = GDBM_MALLOC_ERROR;
      return NULL;
    }
  strcpy (dbf->name, file);
",1,unused,103,unused,"      free (dbf);
      gdbm_errno = GDBM_MALLOC_ERROR;
      return NULL;
    }
  strcpy (dbf->name, file);
",unused,gdbmdebstretche-gdbmopen.c
"    {
      gdbm_errno = GDBM_MALLOC_ERROR;
      return -1;
    }
  strcpy (&new_name[0], dbf->name);
",1,unused,103,unused,"    {
      gdbm_errno = GDBM_MALLOC_ERROR;
      return -1;
    }
  strcpy (&new_name[0], dbf->name);
",unused,gdbmdebstretche-gdbmreorg.c
"      gdbm_errno = GDBM_MALLOC_ERROR;	/* For the hell of it. */
      return -1;
    }

  strcpy (pag_file, file);
",1,unused,69,unused,"      gdbm_errno = GDBM_MALLOC_ERROR;	/* For the hell of it. */
      return -1;
    }

  strcpy (pag_file, file);
",unused,gdbmdebstretche1.8.3-dbminit.c
"      return -1;
    }

  strcpy (pag_file, file);
  strcat (pag_file, "".pag"");
",1,unused,70,unused,"      return -1;
    }

  strcpy (pag_file, file);
  strcat (pag_file, "".pag"");
",unused,gdbmdebstretche1.8.3-dbminit.c
"    }

  strcpy (pag_file, file);
  strcat (pag_file, "".pag"");
  strcpy (dir_file, file);
",1,unused,71,unused,"    }

  strcpy (pag_file, file);
  strcat (pag_file, "".pag"");
  strcpy (dir_file, file);
",unused,gdbmdebstretche1.8.3-dbminit.c
"
  strcpy (pag_file, file);
  strcat (pag_file, "".pag"");
  strcpy (dir_file, file);
  strcat (dir_file, "".dir"");
",1,unused,72,unused,"
  strcpy (pag_file, file);
  strcat (pag_file, "".pag"");
  strcpy (dir_file, file);
  strcat (dir_file, "".dir"");
",unused,gdbmdebstretche1.8.3-dbminit.c
"      gdbm_errno = GDBM_MALLOC_ERROR;	/* For the hell of it. */
      return NULL;
    }

  strcpy (pag_file, file);
",1,unused,76,unused,"      gdbm_errno = GDBM_MALLOC_ERROR;	/* For the hell of it. */
      return NULL;
    }

  strcpy (pag_file, file);
",unused,gdbmdebstretche1.8.3-dbmopen.c
"      return NULL;
    }

  strcpy (pag_file, file);
  strcat (pag_file, "".pag"");
",1,unused,77,unused,"      return NULL;
    }

  strcpy (pag_file, file);
  strcat (pag_file, "".pag"");
",unused,gdbmdebstretche1.8.3-dbmopen.c
"    }

  strcpy (pag_file, file);
  strcat (pag_file, "".pag"");
  strcpy (dir_file, file);
",1,unused,78,unused,"    }

  strcpy (pag_file, file);
  strcat (pag_file, "".pag"");
  strcpy (dir_file, file);
",unused,gdbmdebstretche1.8.3-dbmopen.c
"
  strcpy (pag_file, file);
  strcat (pag_file, "".pag"");
  strcpy (dir_file, file);
  strcat (dir_file, "".dir"");
",1,unused,79,unused,"
  strcpy (pag_file, file);
  strcat (pag_file, "".pag"");
  strcpy (dir_file, file);
  strcat (dir_file, "".dir"");
",unused,gdbmdebstretche1.8.3-dbmopen.c
"      free (dbf);
      gdbm_errno = GDBM_MALLOC_ERROR;
      return NULL;
    }
  strcpy (dbf->name, file);
",1,unused,103,unused,"      free (dbf);
      gdbm_errno = GDBM_MALLOC_ERROR;
      return NULL;
    }
  strcpy (dbf->name, file);
",unused,gdbmdebstretche1.8.3-gdbmopen.c
"    {
      gdbm_errno = GDBM_MALLOC_ERROR;
      return -1;
    }
  strcpy (&new_name[0], dbf->name);
",1,unused,103,unused,"    {
      gdbm_errno = GDBM_MALLOC_ERROR;
      return -1;
    }
  strcpy (&new_name[0], dbf->name);
",unused,gdbmdebstretche1.8.3-gdbmreorg.c
"      gdbm_errno = GDBM_MALLOC_ERROR;	/* For the hell of it. */
      return -1;
    }

  strcpy (pag_file, file);
",1,unused,69,unused,"      gdbm_errno = GDBM_MALLOC_ERROR;	/* For the hell of it. */
      return -1;
    }

  strcpy (pag_file, file);
",unused,gdbmpatchxen-dbminit.c
"      return -1;
    }

  strcpy (pag_file, file);
  strcat (pag_file, "".pag"");
",1,unused,70,unused,"      return -1;
    }

  strcpy (pag_file, file);
  strcat (pag_file, "".pag"");
",unused,gdbmpatchxen-dbminit.c
"    }

  strcpy (pag_file, file);
  strcat (pag_file, "".pag"");
  strcpy (dir_file, file);
",1,unused,71,unused,"    }

  strcpy (pag_file, file);
  strcat (pag_file, "".pag"");
  strcpy (dir_file, file);
",unused,gdbmpatchxen-dbminit.c
"
  strcpy (pag_file, file);
  strcat (pag_file, "".pag"");
  strcpy (dir_file, file);
  strcat (dir_file, "".dir"");
",1,unused,72,unused,"
  strcpy (pag_file, file);
  strcat (pag_file, "".pag"");
  strcpy (dir_file, file);
  strcat (dir_file, "".dir"");
",unused,gdbmpatchxen-dbminit.c
"      gdbm_errno = GDBM_MALLOC_ERROR;	/* For the hell of it. */
      return NULL;
    }

  strcpy (pag_file, file);
",1,unused,76,unused,"      gdbm_errno = GDBM_MALLOC_ERROR;	/* For the hell of it. */
      return NULL;
    }

  strcpy (pag_file, file);
",unused,gdbmpatchxen-dbmopen.c
"      return NULL;
    }

  strcpy (pag_file, file);
  strcat (pag_file, "".pag"");
",1,unused,77,unused,"      return NULL;
    }

  strcpy (pag_file, file);
  strcat (pag_file, "".pag"");
",unused,gdbmpatchxen-dbmopen.c
"    }

  strcpy (pag_file, file);
  strcat (pag_file, "".pag"");
  strcpy (dir_file, file);
",1,unused,78,unused,"    }

  strcpy (pag_file, file);
  strcat (pag_file, "".pag"");
  strcpy (dir_file, file);
",unused,gdbmpatchxen-dbmopen.c
"
  strcpy (pag_file, file);
  strcat (pag_file, "".pag"");
  strcpy (dir_file, file);
  strcat (dir_file, "".dir"");
",1,unused,79,unused,"
  strcpy (pag_file, file);
  strcat (pag_file, "".pag"");
  strcpy (dir_file, file);
  strcat (dir_file, "".dir"");
",unused,gdbmpatchxen-dbmopen.c
"      free (dbf);
      gdbm_errno = GDBM_MALLOC_ERROR;
      return NULL;
    }
  strcpy (dbf->name, file);
",1,unused,103,unused,"      free (dbf);
      gdbm_errno = GDBM_MALLOC_ERROR;
      return NULL;
    }
  strcpy (dbf->name, file);
",unused,gdbmpatchxen-gdbmopen.c
"    {
      gdbm_errno = GDBM_MALLOC_ERROR;
      return -1;
    }
  strcpy (&new_name[0], dbf->name);
",1,unused,103,unused,"    {
      gdbm_errno = GDBM_MALLOC_ERROR;
      return -1;
    }
  strcpy (&new_name[0], dbf->name);
",unused,gdbmpatchxen-gdbmreorg.c
"      gdbm_errno = GDBM_MALLOC_ERROR;	/* For the hell of it. */
      return -1;
    }

  strcpy (pag_file, file);
",1,unused,69,unused,"      gdbm_errno = GDBM_MALLOC_ERROR;	/* For the hell of it. */
      return -1;
    }

  strcpy (pag_file, file);
",unused,gdbmsources1.8.3-dbminit.c
"      return -1;
    }

  strcpy (pag_file, file);
  strcat (pag_file, "".pag"");
",1,unused,70,unused,"      return -1;
    }

  strcpy (pag_file, file);
  strcat (pag_file, "".pag"");
",unused,gdbmsources1.8.3-dbminit.c
"    }

  strcpy (pag_file, file);
  strcat (pag_file, "".pag"");
  strcpy (dir_file, file);
",1,unused,71,unused,"    }

  strcpy (pag_file, file);
  strcat (pag_file, "".pag"");
  strcpy (dir_file, file);
",unused,gdbmsources1.8.3-dbminit.c
"
  strcpy (pag_file, file);
  strcat (pag_file, "".pag"");
  strcpy (dir_file, file);
  strcat (dir_file, "".dir"");
",1,unused,72,unused,"
  strcpy (pag_file, file);
  strcat (pag_file, "".pag"");
  strcpy (dir_file, file);
  strcat (dir_file, "".dir"");
",unused,gdbmsources1.8.3-dbminit.c
"      gdbm_errno = GDBM_MALLOC_ERROR;	/* For the hell of it. */
      return NULL;
    }

  strcpy (pag_file, file);
",1,unused,76,unused,"      gdbm_errno = GDBM_MALLOC_ERROR;	/* For the hell of it. */
      return NULL;
    }

  strcpy (pag_file, file);
",unused,gdbmsources1.8.3-dbmopen.c
"      return NULL;
    }

  strcpy (pag_file, file);
  strcat (pag_file, "".pag"");
",1,unused,77,unused,"      return NULL;
    }

  strcpy (pag_file, file);
  strcat (pag_file, "".pag"");
",unused,gdbmsources1.8.3-dbmopen.c
"    }

  strcpy (pag_file, file);
  strcat (pag_file, "".pag"");
  strcpy (dir_file, file);
",1,unused,78,unused,"    }

  strcpy (pag_file, file);
  strcat (pag_file, "".pag"");
  strcpy (dir_file, file);
",unused,gdbmsources1.8.3-dbmopen.c
"
  strcpy (pag_file, file);
  strcat (pag_file, "".pag"");
  strcpy (dir_file, file);
  strcat (dir_file, "".dir"");
",1,unused,79,unused,"
  strcpy (pag_file, file);
  strcat (pag_file, "".pag"");
  strcpy (dir_file, file);
  strcat (dir_file, "".dir"");
",unused,gdbmsources1.8.3-dbmopen.c
"      free (dbf);
      gdbm_errno = GDBM_MALLOC_ERROR;
      return NULL;
    }
  strcpy (dbf->name, file);
",1,unused,103,unused,"      free (dbf);
      gdbm_errno = GDBM_MALLOC_ERROR;
      return NULL;
    }
  strcpy (dbf->name, file);
",unused,gdbmsources1.8.3-gdbmopen.c
"    {
      gdbm_errno = GDBM_MALLOC_ERROR;
      return -1;
    }
  strcpy (&new_name[0], dbf->name);
",1,unused,103,unused,"    {
      gdbm_errno = GDBM_MALLOC_ERROR;
      return -1;
    }
  strcpy (&new_name[0], dbf->name);
",unused,gdbmsources1.8.3-gdbmreorg.c
"      gdbm_errno = GDBM_MALLOC_ERROR;	/* For the hell of it. */
      return -1;
    }

  strcpy (pag_file, file);
",1,unused,69,unused,"      gdbm_errno = GDBM_MALLOC_ERROR;	/* For the hell of it. */
      return -1;
    }

  strcpy (pag_file, file);
",unused,gdbmubuntuartful1.8.3-dbminit.c
"      return -1;
    }

  strcpy (pag_file, file);
  strcat (pag_file, "".pag"");
",1,unused,70,unused,"      return -1;
    }

  strcpy (pag_file, file);
  strcat (pag_file, "".pag"");
",unused,gdbmubuntuartful1.8.3-dbminit.c
"    }

  strcpy (pag_file, file);
  strcat (pag_file, "".pag"");
  strcpy (dir_file, file);
",1,unused,71,unused,"    }

  strcpy (pag_file, file);
  strcat (pag_file, "".pag"");
  strcpy (dir_file, file);
",unused,gdbmubuntuartful1.8.3-dbminit.c
"
  strcpy (pag_file, file);
  strcat (pag_file, "".pag"");
  strcpy (dir_file, file);
  strcat (dir_file, "".dir"");
",1,unused,72,unused,"
  strcpy (pag_file, file);
  strcat (pag_file, "".pag"");
  strcpy (dir_file, file);
  strcat (dir_file, "".dir"");
",unused,gdbmubuntuartful1.8.3-dbminit.c
"      gdbm_errno = GDBM_MALLOC_ERROR;	/* For the hell of it. */
      return NULL;
    }

  strcpy (pag_file, file);
",1,unused,76,unused,"      gdbm_errno = GDBM_MALLOC_ERROR;	/* For the hell of it. */
      return NULL;
    }

  strcpy (pag_file, file);
",unused,gdbmubuntuartful1.8.3-dbmopen.c
"      return NULL;
    }

  strcpy (pag_file, file);
  strcat (pag_file, "".pag"");
",1,unused,77,unused,"      return NULL;
    }

  strcpy (pag_file, file);
  strcat (pag_file, "".pag"");
",unused,gdbmubuntuartful1.8.3-dbmopen.c
"    }

  strcpy (pag_file, file);
  strcat (pag_file, "".pag"");
  strcpy (dir_file, file);
",1,unused,78,unused,"    }

  strcpy (pag_file, file);
  strcat (pag_file, "".pag"");
  strcpy (dir_file, file);
",unused,gdbmubuntuartful1.8.3-dbmopen.c
"
  strcpy (pag_file, file);
  strcat (pag_file, "".pag"");
  strcpy (dir_file, file);
  strcat (dir_file, "".dir"");
",1,unused,79,unused,"
  strcpy (pag_file, file);
  strcat (pag_file, "".pag"");
  strcpy (dir_file, file);
  strcat (dir_file, "".dir"");
",unused,gdbmubuntuartful1.8.3-dbmopen.c
"      free (dbf);
      gdbm_errno = GDBM_MALLOC_ERROR;
      return NULL;
    }
  strcpy (dbf->name, file);
",1,unused,103,unused,"      free (dbf);
      gdbm_errno = GDBM_MALLOC_ERROR;
      return NULL;
    }
  strcpy (dbf->name, file);
",unused,gdbmubuntuartful1.8.3-gdbmopen.c
"    {
      gdbm_errno = GDBM_MALLOC_ERROR;
      return -1;
    }
  strcpy (&new_name[0], dbf->name);
",1,unused,103,unused,"    {
      gdbm_errno = GDBM_MALLOC_ERROR;
      return -1;
    }
  strcpy (&new_name[0], dbf->name);
",unused,gdbmubuntuartful1.8.3-gdbmreorg.c
"                      (0x10000 <= l && l <= 0x10FFFF))
                    {
                      gchar buf[8];
                      char_str (l, buf);
                      strcpy (to, buf);
",1,unused,384,unused,"                      (0x10000 <= l && l <= 0x10FFFF))
                    {
                      gchar buf[8];
                      char_str (l, buf);
                      strcpy (to, buf);
",unused,gitlab_gimp_master-gimp2Fapp2Fcore2Fgimp-utils.c
"      g_snprintf (statusbar->cursor_format_str,
                  sizeof (statusbar->cursor_format_str),
                  ""%%s%%.%df%%s%%.%df%%s"",
                  w_digits, h_digits);
      strcpy (statusbar->cursor_format_str_f, statusbar->cursor_format_str);
",1,unused,1371,unused,"      g_snprintf (statusbar->cursor_format_str,
                  sizeof (statusbar->cursor_format_str),
                  ""%%s%%.%df%%s%%.%df%%s"",
                  w_digits, h_digits);
      strcpy (statusbar->cursor_format_str_f, statusbar->cursor_format_str);
",unused,gitlab_gimp_master-gimp2Fapp2Fdisplay2Fgimpstatusbar.c
"    {
      switch (*fields[i])
        {
        case 'i':
          strcpy (buffers[i], ""italic"");
",1,unused,101,unused,"    {
      switch (*fields[i])
        {
        case 'i':
          strcpy (buffers[i], ""italic"");
",unused,gitlab_gimp_master-gimp2Fapp2Ftext2Fgimptext-xlfd.c
"          strcpy (buffers[i], ""italic"");
          i++;
          break;
        case 'o':
          strcpy (buffers[i], ""oblique"");
",1,unused,105,unused,"          strcpy (buffers[i], ""italic"");
          i++;
          break;
        case 'o':
          strcpy (buffers[i], ""oblique"");
",unused,gitlab_gimp_master-gimp2Fapp2Ftext2Fgimptext-xlfd.c
"  len = strlen (extension);

  pattern = g_new (gchar, 4 + 4 * len);

  strcpy (pattern, ""*."");
",1,unused,451,unused,"  len = strlen (extension);

  pattern = g_new (gchar, 4 + 4 * len);

  strcpy (pattern, ""*."");
",unused,gitlab_gimp_master-gimp2Fapp2Fwidgets2Fgimpfileprocview.c
"
  /* write out the tag information for the image */
  if (info->file_version > 0)
    {
      sprintf (version_tag, ""gimp xcf v%03d"", info->file_version);
",1,unused,240,unused,"
  /* write out the tag information for the image */
  if (info->file_version > 0)
    {
      sprintf (version_tag, ""gimp xcf v%03d"", info->file_version);
",unused,gitlab_gimp_master-gimp2Fapp2Fxcf2Fxcf-save.c
"      sprintf (version_tag, ""gimp xcf v%03d"", info->file_version);
    }
  else
    {
      strcpy (version_tag, ""gimp xcf file"");
",1,unused,244,unused,"      sprintf (version_tag, ""gimp xcf v%03d"", info->file_version);
    }
  else
    {
      strcpy (version_tag, ""gimp xcf file"");
",unused,gitlab_gimp_master-gimp2Fapp2Fxcf2Fxcf-save.c
"
  /* Update new Instance ID */
  uuid = gimp_metadata_get_guid ();

  strcpy (iid_data, ""xmp.iid:"");
",1,unused,312,unused,"
  /* Update new Instance ID */
  uuid = gimp_metadata_get_guid ();

  strcpy (iid_data, ""xmp.iid:"");
",unused,gitlab_gimp_master-gimp2Flibgimpbase2Fgimpmetadata.c
"  /* Update new Instance ID */
  uuid = gimp_metadata_get_guid ();

  strcpy (iid_data, ""xmp.iid:"");
  strcat (iid_data, uuid);
",1,unused,313,unused,"  /* Update new Instance ID */
  uuid = gimp_metadata_get_guid ();

  strcpy (iid_data, ""xmp.iid:"");
  strcat (iid_data, uuid);
",unused,gitlab_gimp_master-gimp2Flibgimpbase2Fgimpmetadata.c
"      gchar did_data[256];

      uuid = gimp_metadata_get_guid ();

      strcpy (did_data, ""gimp:docid:gimp:"");
",1,unused,328,unused,"      gchar did_data[256];

      uuid = gimp_metadata_get_guid ();

      strcpy (did_data, ""gimp:docid:gimp:"");
",unused,gitlab_gimp_master-gimp2Flibgimpbase2Fgimpmetadata.c
"
      uuid = gimp_metadata_get_guid ();

      strcpy (did_data, ""gimp:docid:gimp:"");
      strcat (did_data, uuid);
",1,unused,329,unused,"
      uuid = gimp_metadata_get_guid ();

      strcpy (did_data, ""gimp:docid:gimp:"");
      strcat (did_data, uuid);
",unused,gitlab_gimp_master-gimp2Flibgimpbase2Fgimpmetadata.c
"    {
      gchar  did_data[256];
      gchar *uuid = gimp_metadata_get_guid ();

      strcpy (did_data, ""xmp.did:"");
",1,unused,344,unused,"    {
      gchar  did_data[256];
      gchar *uuid = gimp_metadata_get_guid ();

      strcpy (did_data, ""xmp.did:"");
",unused,gitlab_gimp_master-gimp2Flibgimpbase2Fgimpmetadata.c
"      gchar  did_data[256];
      gchar *uuid = gimp_metadata_get_guid ();

      strcpy (did_data, ""xmp.did:"");
      strcat (did_data, uuid);
",1,unused,345,unused,"      gchar  did_data[256];
      gchar *uuid = gimp_metadata_get_guid ();

      strcpy (did_data, ""xmp.did:"");
      strcat (did_data, uuid);
",unused,gitlab_gimp_master-gimp2Flibgimpbase2Fgimpmetadata.c
"
  g_snprintf (tagstr, sizeof (tagstr), ""%s[%d]%s"",
              tags[3], id_count, history_tags[4]);

  strcpy (strdata, ""/"");
",1,unused,457,unused,"
  g_snprintf (tagstr, sizeof (tagstr), ""%s[%d]%s"",
              tags[3], id_count, history_tags[4]);

  strcpy (strdata, ""/"");
",unused,gitlab_gimp_master-gimp2Flibgimpbase2Fgimpmetadata.c
"  g_snprintf (tagstr, sizeof (tagstr), ""%s[%d]%s"",
              tags[3], id_count, history_tags[4]);

  strcpy (strdata, ""/"");
  strcat (strdata, state_status);
",1,unused,458,unused,"  g_snprintf (tagstr, sizeof (tagstr), ""%s[%d]%s"",
              tags[3], id_count, history_tags[4]);

  strcpy (strdata, ""/"");
  strcat (strdata, state_status);
",unused,gitlab_gimp_master-gimp2Flibgimpbase2Fgimpmetadata.c
"
  if (isatty(0) && isatty(1))
    fgets (buf, 8, stdin);
  else
    strcpy (buf, ""E\n"");
",1,unused,1456,unused,"
  if (isatty(0) && isatty(1))
    fgets (buf, 8, stdin);
  else
    strcpy (buf, ""E\n"");
",unused,gitlab_gimp_master-gimp2Flibgimpbase2Fgimputils.c
"    {
      if (*p == '~' && home)
        {
          *n = '\0';
          strcat (n, home);
",1,unused,622,unused,"    {
      if (*p == '~' && home)
        {
          *n = '\0';
          strcat (n, home);
",unused,gitlab_gimp_master-gimp2Flibgimpconfig2Fgimpconfig-path.c
"                {
                  s = substs[2*i+1];

                  *n = '\0';
                  strcat (n, s);
",1,unused,635,unused,"                {
                  s = substs[2*i+1];

                  *n = '\0';
                  strcat (n, s);
",unused,gitlab_gimp_master-gimp2Flibgimpconfig2Fgimpconfig-path.c
"      gchar *p;

      p = strstr (short_format, ""%s"");
      if (p)
        strcpy (p, ""%a"");
",1,unused,418,unused,"      gchar *p;

      p = strstr (short_format, ""%s"");
      if (p)
        strcpy (p, ""%a"");
",unused,gitlab_gimp_master-gimp2Flibgimpwidgets2Fgimpsizeentry.c
"        strcpy (p, ""%a"");

      p = strstr (short_format, ""%p"");
      if (p)
        strcpy (p, ""%a"");
",1,unused,422,unused,"        strcpy (p, ""%a"");

      p = strstr (short_format, ""%p"");
      if (p)
        strcpy (p, ""%a"");
",unused,gitlab_gimp_master-gimp2Flibgimpwidgets2Fgimpsizeentry.c
"  DisposeType dummy;

  length = strlen(src);

  strcpy(dest, src);
",1,unused,1286,unused,"  DisposeType dummy;

  length = strlen(src);

  strcpy(dest, src);
",unused,gitlab_gimp_master-gimp2Fplug-ins2Fcommon2Fanimation-optimize.c
"  gint dummy;

  length = strlen(src);

  strcpy(dest, src);
",1,unused,1314,unused,"  gint dummy;

  length = strlen(src);

  strcpy(dest, src);
",unused,gitlab_gimp_master-gimp2Fplug-ins2Fcommon2Fanimation-optimize.c
"          else
            composevals.inputs[j].comp.val = composeint.selected[j].comp.val;
        }

      strcpy (composevals.compose_type,
",1,unused,1266,unused,"          else
            composevals.inputs[j].comp.val = composeint.selected[j].comp.val;
        }

      strcpy (composevals.compose_type,
",unused,gitlab_gimp_master-gimp2Fplug-ins2Fcommon2Fcompose.c
"    }

  /* Headers */
  memset (header, 0, 32);
  strcpy ((gchar *) header, ""KiSS"");
",1,unused,802,unused,"    }

  /* Headers */
  memset (header, 0, 32);
  strcpy ((gchar *) header, ""KiSS"");
",unused,gitlab_gimp_master-gimp2Fplug-ins2Fcommon2Ffile-cel.c
"          element_length_chars[0] = value_rep[0];
          element_length_chars[1] = value_rep[1];

          /* Unknown value rep. It is not used right now anyhow */
          strcpy (value_rep, ""??"");
",1,unused,423,unused,"          element_length_chars[0] = value_rep[0];
          element_length_chars[1] = value_rep[1];

          /* Unknown value rep. It is not used right now anyhow */
          strcpy (value_rep, ""??"");
",unused,gitlab_gimp_master-gimp2Fplug-ins2Fcommon2Ffile-dicom.c
"    default:
#ifdef GIFDEBUG
      str = (gchar *)buf;
#endif
      sprintf ((gchar *)buf, ""UNKNOWN (0x%02x)"", label);
",1,unused,641,unused,"    default:
#ifdef GIFDEBUG
      str = (gchar *)buf;
#endif
      sprintf ((gchar *)buf, ""UNKNOWN (0x%02x)"", label);
",unused,gitlab_gimp_master-gimp2Fplug-ins2Fcommon2Ffile-gif-load.c
"  for (i = 0; i < ri->xres * ri->np; i++)
    {
      if (ri->bpc == 2)
        {
          sprintf ((gchar *) rbcur,""%d\n"", 0xffff & *(sdata++));
",1,unused,1177,unused,"  for (i = 0; i < ri->xres * ri->np; i++)
    {
      if (ri->bpc == 2)
        {
          sprintf ((gchar *) rbcur,""%d\n"", 0xffff & *(sdata++));
",unused,gitlab_gimp_master-gimp2Fplug-ins2Fcommon2Ffile-pnm.c
"          sprintf ((gchar *) rbcur,""%d\n"", 0xffff & *(sdata++));
        }
      else
        {
          sprintf ((gchar *) rbcur,""%d\n"", 0xff & *(data++));
",1,unused,1181,unused,"          sprintf ((gchar *) rbcur,""%d\n"", 0xffff & *(sdata++));
        }
      else
        {
          sprintf ((gchar *) rbcur,""%d\n"", 0xff & *(data++));
",unused,gitlab_gimp_master-gimp2Fplug-ins2Fcommon2Ffile-pnm.c
"  gchar *rbcur = ri->rowbuf;

  for (i = 0; i < ri->xres; i++)
    {
      sprintf (rbcur, ""%d\n"", 0xff & ri->red[*(data)]);
",1,unused,1201,unused,"  gchar *rbcur = ri->rowbuf;

  for (i = 0; i < ri->xres; i++)
    {
      sprintf (rbcur, ""%d\n"", 0xff & ri->red[*(data)]);
",unused,gitlab_gimp_master-gimp2Fplug-ins2Fcommon2Ffile-pnm.c
"  for (i = 0; i < ri->xres; i++)
    {
      sprintf (rbcur, ""%d\n"", 0xff & ri->red[*(data)]);
      rbcur += strlen (rbcur);
      sprintf (rbcur, ""%d\n"", 0xff & ri->grn[*(data)]);
",1,unused,1203,unused,"  for (i = 0; i < ri->xres; i++)
    {
      sprintf (rbcur, ""%d\n"", 0xff & ri->red[*(data)]);
      rbcur += strlen (rbcur);
      sprintf (rbcur, ""%d\n"", 0xff & ri->grn[*(data)]);
",unused,gitlab_gimp_master-gimp2Fplug-ins2Fcommon2Ffile-pnm.c
"      sprintf (rbcur, ""%d\n"", 0xff & ri->red[*(data)]);
      rbcur += strlen (rbcur);
      sprintf (rbcur, ""%d\n"", 0xff & ri->grn[*(data)]);
      rbcur += strlen (rbcur);
      sprintf (rbcur, ""%d\n"", 0xff & ri->blu[*(data++)]);
",1,unused,1205,unused,"      sprintf (rbcur, ""%d\n"", 0xff & ri->red[*(data)]);
      rbcur += strlen (rbcur);
      sprintf (rbcur, ""%d\n"", 0xff & ri->grn[*(data)]);
      rbcur += strlen (rbcur);
      sprintf (rbcur, ""%d\n"", 0xff & ri->blu[*(data++)]);
",unused,gitlab_gimp_master-gimp2Fplug-ins2Fcommon2Ffile-pnm.c
"  if (filmvals.number_start < 0)
    filmvals.number_start = 0;

  if (filmvals.number_font[0] == '\0')
    strcpy (filmvals.number_font, ""Monospace"");
",1,unused,545,unused,"  if (filmvals.number_start < 0)
    filmvals.number_start = 0;

  if (filmvals.number_font[0] == '\0')
    strcpy (filmvals.number_font, ""Monospace"");
",unused,gitlab_gimp_master-gimp2Fplug-ins2Fcommon2Ffilm.c
"                }
            }
          else
            {
              strcpy (xtimestr, """");
",1,unused,469,unused,"                }
            }
          else
            {
              strcpy (xtimestr, """");
",unused,gitlab_gimp_master-gimp2Fplug-ins2Fcommon2Fplugin-browser.c
"  struct textures_t *l;
  static gchar tmps[100];

  if (t->majtype == 0)
    strcpy (tmps, _(""Texture""));
",1,unused,1749,unused,"  struct textures_t *l;
  static gchar tmps[100];

  if (t->majtype == 0)
    strcpy (tmps, _(""Texture""));
",unused,gitlab_gimp_master-gimp2Fplug-ins2Fcommon2Fsphere-designer.c
"
  if (t->majtype == 0)
    strcpy (tmps, _(""Texture""));
  else if (t->majtype == 1)
    strcpy (tmps, _(""Bumpmap""));
",1,unused,1751,unused,"
  if (t->majtype == 0)
    strcpy (tmps, _(""Texture""));
  else if (t->majtype == 1)
    strcpy (tmps, _(""Bumpmap""));
",unused,gitlab_gimp_master-gimp2Fplug-ins2Fcommon2Fsphere-designer.c
"    strcpy (tmps, _(""Texture""));
  else if (t->majtype == 1)
    strcpy (tmps, _(""Bumpmap""));
  else if (t->majtype == 2)
    strcpy (tmps, _(""Light""));
",1,unused,1753,unused,"    strcpy (tmps, _(""Texture""));
  else if (t->majtype == 1)
    strcpy (tmps, _(""Bumpmap""));
  else if (t->majtype == 2)
    strcpy (tmps, _(""Light""));
",unused,gitlab_gimp_master-gimp2Fplug-ins2Fcommon2Fsphere-designer.c
"    strcpy (tmps, _(""Bumpmap""));
  else if (t->majtype == 2)
    strcpy (tmps, _(""Light""));
  else
    strcpy (tmps, ""<unknown>"");
",1,unused,1755,unused,"    strcpy (tmps, _(""Bumpmap""));
  else if (t->majtype == 2)
    strcpy (tmps, _(""Light""));
  else
    strcpy (tmps, ""<unknown>"");
",unused,gitlab_gimp_master-gimp2Fplug-ins2Fcommon2Fsphere-designer.c
"  else
    strcpy (tmps, ""<unknown>"");
  if ((t->majtype == 0) || (t->majtype == 1))
    {
      strcat (tmps, "" / "");
",1,unused,1758,unused,"  else
    strcpy (tmps, ""<unknown>"");
  if ((t->majtype == 0) || (t->majtype == 1))
    {
      strcat (tmps, "" / "");
",unused,gitlab_gimp_master-gimp2Fplug-ins2Fcommon2Fsphere-designer.c
"      while (l->s)
        {
          if (t->type == l->n)
            {
              strcat (tmps, gettext (l->s));
",1,unused,1764,unused,"      while (l->s)
        {
          if (t->type == l->n)
            {
              strcat (tmps, gettext (l->s));
",unused,gitlab_gimp_master-gimp2Fplug-ins2Fcommon2Fsphere-designer.c
"
  if (fits_n_error <= 0)
    return NULL;

  strcpy (errmsg, fits_error[0]);
",1,unused,481,unused,"
  if (fits_n_error <= 0)
    return NULL;

  strcpy (errmsg, fits_error[0]);
",unused,gitlab_gimp_master-gimp2Fplug-ins2Ffile-fits2Ffits-io.c
"
  strcpy (errmsg, fits_error[0]);

  for (k = 1; k < fits_n_error; k++)
    strcpy (fits_error[k-1], fits_error[k]);
",1,unused,484,unused,"
  strcpy (errmsg, fits_error[0]);

  for (k = 1; k < fits_n_error; k++)
    strcpy (fits_error[k-1], fits_error[k]);
",unused,gitlab_gimp_master-gimp2Fplug-ins2Ffile-fits2Ffits-io.c
"      fdat = fits_decode_card (fits_search_card (hdr, ""XTENSION""),
                               FITS_DATA_TYPE_FSTRING);
      if (fdat != NULL)
        {
          strcpy (hdulist->xtension, fdat->fstring);
",1,unused,1104,unused,"      fdat = fits_decode_card (fits_search_card (hdr, ""XTENSION""),
                               FITS_DATA_TYPE_FSTRING);
      if (fdat != NULL)
        {
          strcpy (hdulist->xtension, fdat->fstring);
",unused,gitlab_gimp_master-gimp2Fplug-ins2Ffile-fits2Ffits-io.c
"          strcpy (hdulist->xtension, fdat->fstring);
        }
      else
        {
          strcpy (errmsg, ""No valid XTENSION header found."");
",1,unused,1108,unused,"          strcpy (hdulist->xtension, fdat->fstring);
        }
      else
        {
          strcpy (errmsg, ""No valid XTENSION header found."");
",unused,gitlab_gimp_master-gimp2Fplug-ins2Ffile-fits2Ffits-io.c
"  bpp = hdulist->bitpix = (gint) fdat->flong;
  if ((bpp != 8)   && (bpp != 16) && (bpp != 32) &&
      (bpp != -32) && (bpp != -64))
    {
      strcpy (errmsg, ""fits_decode_header: Invalid BITPIX-value"");
",1,unused,1121,unused,"  bpp = hdulist->bitpix = (gint) fdat->flong;
  if ((bpp != 8)   && (bpp != 16) && (bpp != 32) &&
      (bpp != -32) && (bpp != -64))
    {
      strcpy (errmsg, ""fits_decode_header: Invalid BITPIX-value"");
",unused,gitlab_gimp_master-gimp2Fplug-ins2Ffile-fits2Ffits-io.c
"  if (hdulist->used.xtension)  /* Extension requires GCOUNT and PCOUNT */
    {
      if (! hdulist->used.gcount || ! hdulist->used.pcount)
        {
          strcpy (errmsg, ""fits_decode_header: Missing GCOUNT/PCOUNT for XTENSION"");
",1,unused,1143,unused,"  if (hdulist->used.xtension)  /* Extension requires GCOUNT and PCOUNT */
    {
      if (! hdulist->used.gcount || ! hdulist->used.pcount)
        {
          strcpy (errmsg, ""fits_decode_header: Missing GCOUNT/PCOUNT for XTENSION"");
",unused,gitlab_gimp_master-gimp2Fplug-ins2Ffile-fits2Ffits-io.c
"      hdulist->naxisn[k-1] = (int)fdat->flong;

      if (hdulist->naxisn[k-1] < 0)
        {
          strcpy (errmsg, ""fits_decode_header: Negative value in NAXISn"");
",1,unused,1168,unused,"      hdulist->naxisn[k-1] = (int)fdat->flong;

      if (hdulist->naxisn[k-1] < 0)
        {
          strcpy (errmsg, ""fits_decode_header: Negative value in NAXISn"");
",unused,gitlab_gimp_master-gimp2Fplug-ins2Ffile-fits2Ffits-io.c
"      if ((k == 1) && random_groups)
        {
          if (hdulist->naxisn[0] != 0)
            {
              strcpy (errmsg, ""fits_decode_header: Random groups with NAXIS1 != 0"");
",1,unused,1176,unused,"      if ((k == 1) && random_groups)
        {
          if (hdulist->naxisn[0] != 0)
            {
              strcpy (errmsg, ""fits_decode_header: Random groups with NAXIS1 != 0"");
",unused,gitlab_gimp_master-gimp2Fplug-ins2Ffile-fits2Ffits-io.c
"    }

  if ((hdulist->naxis > 0) && (k < hdulist->naxis))
    {
      strcpy (errmsg, ""fits_decode_card: Not enough NAXISn-cards"");
",1,unused,1188,unused,"    }

  if ((hdulist->naxis > 0) && (k < hdulist->naxis))
    {
      strcpy (errmsg, ""fits_decode_card: Not enough NAXISn-cards"");
",unused,gitlab_gimp_master-gimp2Fplug-ins2Ffile-fits2Ffits-io.c
"    key_len = 8;
  if (key_len == 0)
    FITS_RETURN (""fits_search_card: Invalid parameter"", NULL);

  strcpy (key, ""        "");
",1,unused,1823,unused,"    key_len = 8;
  if (key_len == 0)
    FITS_RETURN (""fits_search_card: Invalid parameter"", NULL);

  strcpy (key, ""        "");
",unused,gitlab_gimp_master-gimp2Fplug-ins2Ffile-fits2Ffits-io.c
"  image_ID = gimp_image_new_with_precision (width, height, itype, iprecision);

  if ((tmp = g_malloc (strlen (filename) + 64)) != NULL)
    {
      sprintf (tmp, ""%s-img%ld"", filename, (long)pagenum);
",1,unused,521,unused,"  image_ID = gimp_image_new_with_precision (width, height, itype, iprecision);

  if ((tmp = g_malloc (strlen (filename) + 64)) != NULL)
    {
      sprintf (tmp, ""%s-img%ld"", filename, (long)pagenum);
",unused,gitlab_gimp_master-gimp2Fplug-ins2Ffile-fits2Ffits.c
"  while (*src && cnt--)
    {
      if (g_ascii_iscntrl (*src) || g_ascii_isspace (*src) || *src == '\\')
        {
          sprintf (dest, ""\\%03o"", *src++);
",1,unused,269,unused,"  while (*src && cnt--)
    {
      if (g_ascii_iscntrl (*src) || g_ascii_isspace (*src) || *src == '\\')
        {
          sprintf (dest, ""\\%03o"", *src++);
",unused,gitlab_gimp_master-gimp2Fplug-ins2Fgfig2Fgfig.c
"  while (*src && cnt--)
    {
      if (g_ascii_iscntrl (*src) || g_ascii_isspace (*src) || *src == '\\')
        {
          sprintf (dest, ""\\%03o"", *src++);
",1,unused,4653,unused,"  while (*src && cnt--)
    {
      if (g_ascii_iscntrl (*src) || g_ascii_isspace (*src) || *src == '\\')
        {
          sprintf (dest, ""\\%03o"", *src++);
",unused,gitlab_gimp_master-gimp2Fplug-ins2Fgradient-flare2Fgradient-flare.c
"  aff_element_compute_color_trans (elem);

  elem->v.prob = 1.0;

  sprintf (buffer,""%d"", count);
",1,unused,808,unused,"  aff_element_compute_color_trans (elem);

  elem->v.prob = 1.0;

  sprintf (buffer,""%d"", count);
",unused,gitlab_gimp_master-gimp2Fplug-ins2Fifs-compose2Fifs-compose-utils.c
"  GdkPoint *point;
  gchar scratch[16];

  gtk_tree_model_get(tree_model, iter, 0, &point, -1);
  sprintf(scratch, ""%d"", point->x);
",1,unused,424,unused,"  GdkPoint *point;
  gchar scratch[16];

  gtk_tree_model_get(tree_model, iter, 0, &point, -1);
  sprintf(scratch, ""%d"", point->x);
",unused,gitlab_gimp_master-gimp2Fplug-ins2Fimagemap2Fimap_polygon.c
"  GdkPoint *point;
  gchar scratch[16];

  gtk_tree_model_get(tree_model, iter, 0, &point, -1);
  sprintf(scratch, ""%d"", point->y);
",1,unused,436,unused,"  GdkPoint *point;
  gchar scratch[16];

  gtk_tree_model_get(tree_model, iter, 0, &point, -1);
  sprintf(scratch, ""%d"", point->y);
",unused,gitlab_gimp_master-gimp2Fplug-ins2Fimagemap2Fimap_polygon.c
"statusbar_set_xy(StatusBar_t *statusbar, gint x, gint y)
{
   char scratch[16];

   sprintf(scratch, ""%d, %d"", (int) x, (int) y);
",1,unused,121,unused,"statusbar_set_xy(StatusBar_t *statusbar, gint x, gint y)
{
   char scratch[16];

   sprintf(scratch, ""%d, %d"", (int) x, (int) y);
",unused,gitlab_gimp_master-gimp2Fplug-ins2Fimagemap2Fimap_statusbar.c
"statusbar_set_zoom(StatusBar_t *statusbar, gint factor)
{
   char scratch[16];

   sprintf(scratch, ""1:%d"", factor);
",1,unused,150,unused,"statusbar_set_zoom(StatusBar_t *statusbar, gint factor)
{
   char scratch[16];

   sprintf(scratch, ""1:%d"", factor);
",unused,gitlab_gimp_master-gimp2Fplug-ins2Fimagemap2Fimap_statusbar.c
"    {
      gchar *p = strstr (string, substring);
      if (p)
        {
          strcpy (p, p + strlen (substring));
",1,unused,614,unused,"    {
      gchar *p = strstr (string, substring);
      if (p)
        {
          strcpy (p, p + strlen (substring));
",unused,gitlab_gimp_master-gimp2Fplug-ins2Fmetadata2Fmetadata-editor.c
"            {
              gchar *new_value_clean[2];

              new_value_clean[0] = strtok (value_clean, "" "");
              strcpy (value_clean, new_value_clean[0]);
",1,unused,1990,unused,"            {
              gchar *new_value_clean[2];

              new_value_clean[0] = strtok (value_clean, "" "");
              strcpy (value_clean, new_value_clean[0]);
",unused,gitlab_gimp_master-gimp2Fplug-ins2Fmetadata2Fmetadata-editor.c
"                          while (isspace (str[l - 1])) --l;
                          while (* str && isspace (*str)) ++str, --l;

                          /* stuff into array */
                          strcpy (arr[i_ctr], str);
",1,unused,2468,unused,"                          while (isspace (str[l - 1])) --l;
                          while (* str && isspace (*str)) ++str, --l;

                          /* stuff into array */
                          strcpy (arr[i_ctr], str);
",unused,gitlab_gimp_master-gimp2Fplug-ins2Fmetadata2Fmetadata-editor.c
"                          while (isspace (str[l - 1])) --l;
                          while (* str && isspace (*str)) ++str, --l;

                          /* stuff into array */
                          strcpy (arr[i_ctr], str);
",1,unused,2552,unused,"                          while (isspace (str[l - 1])) --l;
                          while (* str && isspace (*str)) ++str, --l;

                          /* stuff into array */
                          strcpy (arr[i_ctr], str);
",unused,gitlab_gimp_master-gimp2Fplug-ins2Fmetadata2Fmetadata-editor.c
"                          while (isspace (str[l - 1])) --l;
                          while (* str && isspace (*str)) ++str, --l;

                          /* stuff into array */
                          strcpy (arr[i_ctr], str);
",1,unused,2636,unused,"                          while (isspace (str[l - 1])) --l;
                          while (* str && isspace (*str)) ++str, --l;

                          /* stuff into array */
                          strcpy (arr[i_ctr], str);
",unused,gitlab_gimp_master-gimp2Fplug-ins2Fmetadata2Fmetadata-editor.c
"                          while (isspace (str[l - 1])) --l;
                          while (*str && isspace (*str)) ++str, --l;

                          /* stuff into array */
                          strcpy (arr[i_ctr], str);
",1,unused,2729,unused,"                          while (isspace (str[l - 1])) --l;
                          while (*str && isspace (*str)) ++str, --l;

                          /* stuff into array */
                          strcpy (arr[i_ctr], str);
",unused,gitlab_gimp_master-gimp2Fplug-ins2Fmetadata2Fmetadata-editor.c
"                          gchar type1[256];
                          gchar type2[256];
                          gint  types;

                          strcpy (type1, gettext (phone_types[0].display));
",1,unused,3283,unused,"                          gchar type1[256];
                          gchar type2[256];
                          gint  types;

                          strcpy (type1, gettext (phone_types[0].display));
",unused,gitlab_gimp_master-gimp2Fplug-ins2Fmetadata2Fmetadata-editor.c
"                          gchar type2[256];
                          gint  types;

                          strcpy (type1, gettext (phone_types[0].display));
                          strcpy (type2, gettext (phone_types[0].display));
",1,unused,3284,unused,"                          gchar type2[256];
                          gint  types;

                          strcpy (type1, gettext (phone_types[0].display));
                          strcpy (type2, gettext (phone_types[0].display));
",unused,gitlab_gimp_master-gimp2Fplug-ins2Fmetadata2Fmetadata-editor.c
"                            {
                              if (! strcmp (tagdata[item][3],
                                            phone_types[types].data))
                                {
                                  strcpy (type1,
",1,unused,3291,unused,"                            {
                              if (! strcmp (tagdata[item][3],
                                            phone_types[types].data))
                                {
                                  strcpy (type1,
",unused,gitlab_gimp_master-gimp2Fplug-ins2Fmetadata2Fmetadata-editor.c
"
                              if (! strcmp (tagdata[item][5],
                                            phone_types[types].data))
                                {
                                  strcpy (type2,
",1,unused,3298,unused,"
                              if (! strcmp (tagdata[item][5],
                                            phone_types[types].data))
                                {
                                  strcpy (type2,
",unused,gitlab_gimp_master-gimp2Fplug-ins2Fmetadata2Fmetadata-editor.c
"                          while (isspace (str[l - 1])) --l;
                          while (*str && isspace (*str)) ++str, --l;

                          /* stuff into array */
                          strcpy (arr[i_ctr], str);
",1,unused,4043,unused,"                          while (isspace (str[l - 1])) --l;
                          while (*str && isspace (*str)) ++str, --l;

                          /* stuff into array */
                          strcpy (arr[i_ctr], str);
",unused,gitlab_gimp_master-gimp2Fplug-ins2Fmetadata2Fmetadata-editor.c
"                          while (isspace (str[l - 1])) --l;
                          while (*str && isspace (*str)) ++str, --l;

                          /* stuff into array */
                          strcpy (arr[i_ctr], str);
",1,unused,4112,unused,"                          while (isspace (str[l - 1])) --l;
                          while (*str && isspace (*str)) ++str, --l;

                          /* stuff into array */
                          strcpy (arr[i_ctr], str);
",unused,gitlab_gimp_master-gimp2Fplug-ins2Fmetadata2Fmetadata-editor.c
"                          while (isspace (str[l - 1])) --l;
                          while (*str && isspace (*str)) ++str, --l;

                          /* stuff into array */
                          strcpy (arr[i_ctr], str);
",1,unused,4181,unused,"                          while (isspace (str[l - 1])) --l;
                          while (*str && isspace (*str)) ++str, --l;

                          /* stuff into array */
                          strcpy (arr[i_ctr], str);
",unused,gitlab_gimp_master-gimp2Fplug-ins2Fmetadata2Fmetadata-editor.c
"                          while (isspace (str[l - 1])) --l;
                          while (*str && isspace (*str)) ++str, --l;

                          /* stuff into array */
                          strcpy (arr[i_ctr], str);
",1,unused,4250,unused,"                          while (isspace (str[l - 1])) --l;
                          while (*str && isspace (*str)) ++str, --l;

                          /* stuff into array */
                          strcpy (arr[i_ctr], str);
",unused,gitlab_gimp_master-gimp2Fplug-ins2Fmetadata2Fmetadata-editor.c
"                              COL_ORG_IMG_NAME, &rc_data,
                              -1);
          if (rc_data && *rc_data)
            {
              strcat (output_data, rc_data);
",1,unused,4388,unused,"                              COL_ORG_IMG_NAME, &rc_data,
                              -1);
          if (rc_data && *rc_data)
            {
              strcat (output_data, rc_data);
",unused,gitlab_gimp_master-gimp2Fplug-ins2Fmetadata2Fmetadata-editor.c
"          if (rc_data && *rc_data)
            {
              strcat (output_data, rc_data);
              if (row + 1 < number_of_rows)
                strcat (output_data, "", "");
",1,unused,4390,unused,"          if (rc_data && *rc_data)
            {
              strcat (output_data, rc_data);
              if (row + 1 < number_of_rows)
                strcat (output_data, "", "");
",unused,gitlab_gimp_master-gimp2Fplug-ins2Fmetadata2Fmetadata-editor.c
"                              COL_ORG_IMG_CODE, &rc_data,
                              -1);
          if (rc_data && *rc_data)
            {
              strcat (output_data, rc_data);
",1,unused,4418,unused,"                              COL_ORG_IMG_CODE, &rc_data,
                              -1);
          if (rc_data && *rc_data)
            {
              strcat (output_data, rc_data);
",unused,gitlab_gimp_master-gimp2Fplug-ins2Fmetadata2Fmetadata-editor.c
"          if (rc_data && *rc_data)
            {
              strcat (output_data, rc_data);
              if (row + 1 < number_of_rows)
                strcat (output_data, "", "");
",1,unused,4420,unused,"          if (rc_data && *rc_data)
            {
              strcat (output_data, rc_data);
              if (row + 1 < number_of_rows)
                strcat (output_data, "", "");
",unused,gitlab_gimp_master-gimp2Fplug-ins2Fmetadata2Fmetadata-editor.c
"                              COL_MOD_REL_ID, &rc_data,
                              -1);
          if (rc_data && *rc_data)
            {
              strcat (output_data, rc_data);
",1,unused,4447,unused,"                              COL_MOD_REL_ID, &rc_data,
                              -1);
          if (rc_data && *rc_data)
            {
              strcat (output_data, rc_data);
",unused,gitlab_gimp_master-gimp2Fplug-ins2Fmetadata2Fmetadata-editor.c
"          if (rc_data && *rc_data)
            {
              strcat (output_data, rc_data);
              if (row + 1 < number_of_rows)
                strcat (output_data, "", "");
",1,unused,4449,unused,"          if (rc_data && *rc_data)
            {
              strcat (output_data, rc_data);
              if (row + 1 < number_of_rows)
                strcat (output_data, "", "");
",unused,gitlab_gimp_master-gimp2Fplug-ins2Fmetadata2Fmetadata-editor.c
"                              COL_PROP_REL_ID, &rc_data,
                              -1);
          if (rc_data && *rc_data)
            {
              strcat (output_data, rc_data);
",1,unused,4476,unused,"                              COL_PROP_REL_ID, &rc_data,
                              -1);
          if (rc_data && *rc_data)
            {
              strcat (output_data, rc_data);
",unused,gitlab_gimp_master-gimp2Fplug-ins2Fmetadata2Fmetadata-editor.c
"          if (rc_data && *rc_data)
            {
              strcat (output_data, rc_data);
              if (row + 1 < number_of_rows)
                strcat (output_data, "", "");
",1,unused,4478,unused,"          if (rc_data && *rc_data)
            {
              strcat (output_data, rc_data);
              if (row + 1 < number_of_rows)
                strcat (output_data, "", "");
",unused,gitlab_gimp_master-gimp2Fplug-ins2Fmetadata2Fmetadata-editor.c
"
          g_snprintf (tag, sizeof (tag), ""%s[%d]%s"",
                      licensor_header, counter, licensor[3]);

          strcpy (type1, phone_types[0].data);
",1,unused,4965,unused,"
          g_snprintf (tag, sizeof (tag), ""%s[%d]%s"",
                      licensor_header, counter, licensor[3]);

          strcpy (type1, phone_types[0].data);
",unused,gitlab_gimp_master-gimp2Fplug-ins2Fmetadata2Fmetadata-editor.c
"              for (types = 0; types < 6; types++)
                {
                  if (! strcmp (tag_data, gettext (phone_types[types].display)))
                    {
                      strcpy (type1, phone_types[types].data);
",1,unused,4973,unused,"              for (types = 0; types < 6; types++)
                {
                  if (! strcmp (tag_data, gettext (phone_types[types].display)))
                    {
                      strcpy (type1, phone_types[types].data);
",unused,gitlab_gimp_master-gimp2Fplug-ins2Fmetadata2Fmetadata-editor.c
"
          g_snprintf (tag, sizeof (tag), ""%s[%d]%s"",
                      licensor_header, counter, licensor[5]);

          strcpy (type2, phone_types[0].data);
",1,unused,4998,unused,"
          g_snprintf (tag, sizeof (tag), ""%s[%d]%s"",
                      licensor_header, counter, licensor[5]);

          strcpy (type2, phone_types[0].data);
",unused,gitlab_gimp_master-gimp2Fplug-ins2Fmetadata2Fmetadata-editor.c
"                           gettext (phone_types[types].display));
                  if (! strcmp (tag_data, gettext (phone_types[types].display)))
                    {
                      g_print (""%d %s \n"", types, phone_types[types].data);
                      strcpy (type2, phone_types[types].data);
",1,unused,5009,unused,"                           gettext (phone_types[types].display));
                  if (! strcmp (tag_data, gettext (phone_types[types].display)))
                    {
                      g_print (""%d %s \n"", types, phone_types[types].data);
                      strcpy (type2, phone_types[types].data);
",unused,gitlab_gimp_master-gimp2Fplug-ins2Fmetadata2Fmetadata-editor.c
"                }

              if (str1)
                {
                  strcpy (lng, str1);
",1,unused,5163,unused,"                }

              if (str1)
                {
                  strcpy (lng, str1);
",unused,gitlab_gimp_master-gimp2Fplug-ins2Fmetadata2Fmetadata-editor.c
"
              if (str1)
                {
                  strcpy (lng, str1);
                  strcat (lng, ""/1"");
",1,unused,5164,unused,"
              if (str1)
                {
                  strcpy (lng, str1);
                  strcat (lng, ""/1"");
",unused,gitlab_gimp_master-gimp2Fplug-ins2Fmetadata2Fmetadata-editor.c
"                  strcat (lng, ""/1"");
                }
              else
                {
                  strcpy (lng, ""0/1"");
",1,unused,5168,unused,"                  strcat (lng, ""/1"");
                }
              else
                {
                  strcpy (lng, ""0/1"");
",unused,gitlab_gimp_master-gimp2Fplug-ins2Fmetadata2Fmetadata-editor.c
"                }

              if (str2)
                {
                  strcat (lng, "" "");
",1,unused,5173,unused,"                }

              if (str2)
                {
                  strcat (lng, "" "");
",unused,gitlab_gimp_master-gimp2Fplug-ins2Fmetadata2Fmetadata-editor.c
"
              if (str2)
                {
                  strcat (lng, "" "");
                  strcat (lng, str2);
",1,unused,5174,unused,"
              if (str2)
                {
                  strcat (lng, "" "");
                  strcat (lng, str2);
",unused,gitlab_gimp_master-gimp2Fplug-ins2Fmetadata2Fmetadata-editor.c
"              if (str2)
                {
                  strcat (lng, "" "");
                  strcat (lng, str2);
                  strcat (lng, ""/1"");
",1,unused,5175,unused,"              if (str2)
                {
                  strcat (lng, "" "");
                  strcat (lng, str2);
                  strcat (lng, ""/1"");
",unused,gitlab_gimp_master-gimp2Fplug-ins2Fmetadata2Fmetadata-editor.c
"                  strcat (lng, ""/1"");
                }
              else
                {
                  strcat (lng, "" "");
",1,unused,5179,unused,"                  strcat (lng, ""/1"");
                }
              else
                {
                  strcat (lng, "" "");
",unused,gitlab_gimp_master-gimp2Fplug-ins2Fmetadata2Fmetadata-editor.c
"                }
              else
                {
                  strcat (lng, "" "");
                  strcat (lng, ""0/1"");
",1,unused,5180,unused,"                }
              else
                {
                  strcat (lng, "" "");
                  strcat (lng, ""0/1"");
",unused,gitlab_gimp_master-gimp2Fplug-ins2Fmetadata2Fmetadata-editor.c
"                }

              if (str3)
                {
                  strcat (lng, "" "");
",1,unused,5185,unused,"                }

              if (str3)
                {
                  strcat (lng, "" "");
",unused,gitlab_gimp_master-gimp2Fplug-ins2Fmetadata2Fmetadata-editor.c
"
              if (str3)
                {
                  strcat (lng, "" "");
                  strcat (lng, str3);
",1,unused,5186,unused,"
              if (str3)
                {
                  strcat (lng, "" "");
                  strcat (lng, str3);
",unused,gitlab_gimp_master-gimp2Fplug-ins2Fmetadata2Fmetadata-editor.c
"              if (str3)
                {
                  strcat (lng, "" "");
                  strcat (lng, str3);
                  strcat (lng, ""/1"");
",1,unused,5187,unused,"              if (str3)
                {
                  strcat (lng, "" "");
                  strcat (lng, str3);
                  strcat (lng, ""/1"");
",unused,gitlab_gimp_master-gimp2Fplug-ins2Fmetadata2Fmetadata-editor.c
"                  strcat (lng, ""/1"");
                }
              else
                {
                  strcat (lng, "" "");
",1,unused,5191,unused,"                  strcat (lng, ""/1"");
                }
              else
                {
                  strcat (lng, "" "");
",unused,gitlab_gimp_master-gimp2Fplug-ins2Fmetadata2Fmetadata-editor.c
"                }
              else
                {
                  strcat (lng, "" "");
                  strcat (lng, ""0/1"");
",1,unused,5192,unused,"                }
              else
                {
                  strcat (lng, "" "");
                  strcat (lng, ""0/1"");
",unused,gitlab_gimp_master-gimp2Fplug-ins2Fmetadata2Fmetadata-editor.c
"                }

              if (str1)
                {
                  strcpy (lat, str1);
",1,unused,5251,unused,"                }

              if (str1)
                {
                  strcpy (lat, str1);
",unused,gitlab_gimp_master-gimp2Fplug-ins2Fmetadata2Fmetadata-editor.c
"
              if (str1)
                {
                  strcpy (lat, str1);
                  strcat (lat, ""/1"");
",1,unused,5252,unused,"
              if (str1)
                {
                  strcpy (lat, str1);
                  strcat (lat, ""/1"");
",unused,gitlab_gimp_master-gimp2Fplug-ins2Fmetadata2Fmetadata-editor.c
"                  strcat (lat, ""/1"");
                }
              else
                {
                  strcpy (lat, ""0/1"");
",1,unused,5256,unused,"                  strcat (lat, ""/1"");
                }
              else
                {
                  strcpy (lat, ""0/1"");
",unused,gitlab_gimp_master-gimp2Fplug-ins2Fmetadata2Fmetadata-editor.c
"                }

              if (str2)
                {
                  strcat (lat, "" "");
",1,unused,5261,unused,"                }

              if (str2)
                {
                  strcat (lat, "" "");
",unused,gitlab_gimp_master-gimp2Fplug-ins2Fmetadata2Fmetadata-editor.c
"
              if (str2)
                {
                  strcat (lat, "" "");
                  strcat (lat, str2);
",1,unused,5262,unused,"
              if (str2)
                {
                  strcat (lat, "" "");
                  strcat (lat, str2);
",unused,gitlab_gimp_master-gimp2Fplug-ins2Fmetadata2Fmetadata-editor.c
"              if (str2)
                {
                  strcat (lat, "" "");
                  strcat (lat, str2);
                  strcat (lat, ""/1"");
",1,unused,5263,unused,"              if (str2)
                {
                  strcat (lat, "" "");
                  strcat (lat, str2);
                  strcat (lat, ""/1"");
",unused,gitlab_gimp_master-gimp2Fplug-ins2Fmetadata2Fmetadata-editor.c
"                  strcat (lat, ""/1"");
                }
              else
                {
                  strcat (lat, "" "");
",1,unused,5267,unused,"                  strcat (lat, ""/1"");
                }
              else
                {
                  strcat (lat, "" "");
",unused,gitlab_gimp_master-gimp2Fplug-ins2Fmetadata2Fmetadata-editor.c
"                }
              else
                {
                  strcat (lat, "" "");
                  strcat (lat, ""0/1"");
",1,unused,5268,unused,"                }
              else
                {
                  strcat (lat, "" "");
                  strcat (lat, ""0/1"");
",unused,gitlab_gimp_master-gimp2Fplug-ins2Fmetadata2Fmetadata-editor.c
"                }

              if (str3)
                {
                  strcat (lat, "" "");
",1,unused,5273,unused,"                }

              if (str3)
                {
                  strcat (lat, "" "");
",unused,gitlab_gimp_master-gimp2Fplug-ins2Fmetadata2Fmetadata-editor.c
"
              if (str3)
                {
                  strcat (lat, "" "");
                  strcat (lat, str3);
",1,unused,5274,unused,"
              if (str3)
                {
                  strcat (lat, "" "");
                  strcat (lat, str3);
",unused,gitlab_gimp_master-gimp2Fplug-ins2Fmetadata2Fmetadata-editor.c
"              if (str3)
                {
                  strcat (lat, "" "");
                  strcat (lat, str3);
                  strcat (lat, ""/1"");
",1,unused,5275,unused,"              if (str3)
                {
                  strcat (lat, "" "");
                  strcat (lat, str3);
                  strcat (lat, ""/1"");
",unused,gitlab_gimp_master-gimp2Fplug-ins2Fmetadata2Fmetadata-editor.c
"                  strcat (lat, ""/1"");
                }
              else
                {
                  strcat (lat, "" "");
",1,unused,5279,unused,"                  strcat (lat, ""/1"");
                }
              else
                {
                  strcat (lat, "" "");
",unused,gitlab_gimp_master-gimp2Fplug-ins2Fmetadata2Fmetadata-editor.c
"                }
              else
                {
                  strcat (lat, "" "");
                  strcat (lat, ""0/1"");
",1,unused,5280,unused,"                }
              else
                {
                  strcat (lat, "" "");
                  strcat (lat, ""0/1"");
",unused,gitlab_gimp_master-gimp2Fplug-ins2Fmetadata2Fmetadata-editor.c
"  char *str=sc->malloc(new_size);
  if(str) {
    memset(str,' ',new_size-1);
    str[new_size-1]='\0';
    strcpy(str,start);
",1,unused,1726,unused,"  char *str=sc->malloc(new_size);
  if(str) {
    memset(str,' ',new_size-1);
    str[new_size-1]='\0';
    strcpy(str,start);
",unused,gitlab_gimp_master-gimp2Fplug-ins2Fscript-fu2Ftinyscheme2Fscheme.c
"     case OP_CURR_ENV: /* current-environment */
          s_return(sc,sc->envir);

     default:
          sprintf(sc->strbuff, ""%d: illegal operator"", sc->op);
",1,unused,4259,unused,"     case OP_CURR_ENV: /* current-environment */
          s_return(sc,sc->envir);

     default:
          sprintf(sc->strbuff, ""%d: illegal operator"", sc->op);
",unused,gitlab_gimp_master-gimp2Fplug-ins2Fscript-fu2Ftinyscheme2Fscheme.c
"  rawfactor = (struct rawfactor_t *) xmalloc (factor_alloc * sizeof (*rawfactor));

  if (numb_bits % 4 != 0)
    {
      strcpy (mod34_excuse, ""GMP_NUMB_BITS % 4 != 0"");
",1,unused,251,unused,"  rawfactor = (struct rawfactor_t *) xmalloc (factor_alloc * sizeof (*rawfactor));

  if (numb_bits % 4 != 0)
    {
      strcpy (mod34_excuse, ""GMP_NUMB_BITS % 4 != 0"");
",unused,gmpdebstretche-gen-psqr.c
"      max_divisor_bits = log2_ceil (max_divisor);

      if (numb_bits / 4 < max_divisor_bits)
        {
          strcpy (mod34_excuse, ""GMP_NUMB_BITS / 4 too small"");
",1,unused,267,unused,"      max_divisor_bits = log2_ceil (max_divisor);

      if (numb_bits / 4 < max_divisor_bits)
        {
          strcpy (mod34_excuse, ""GMP_NUMB_BITS / 4 too small"");
",unused,gmpdebstretche-gen-psqr.c
"  if (nrawfactor <= 2)
    {
      mpz_t  new_pp;

      sprintf (mod34_excuse, ""only %d small factor%s"",
",1,unused,328,unused,"  if (nrawfactor <= 2)
    {
      mpz_t  new_pp;

      sprintf (mod34_excuse, ""only %d small factor%s"",
",unused,gmpdebstretche-gen-psqr.c
"  rawfactor = (struct rawfactor_t *) xmalloc (factor_alloc * sizeof (*rawfactor));

  if (numb_bits % 4 != 0)
    {
      strcpy (mod34_excuse, ""GMP_NUMB_BITS % 4 != 0"");
",1,unused,251,unused,"  rawfactor = (struct rawfactor_t *) xmalloc (factor_alloc * sizeof (*rawfactor));

  if (numb_bits % 4 != 0)
    {
      strcpy (mod34_excuse, ""GMP_NUMB_BITS % 4 != 0"");
",unused,gmpxenpatch-gen-psqr.c
"      max_divisor_bits = log2_ceil (max_divisor);

      if (numb_bits / 4 < max_divisor_bits)
        {
          strcpy (mod34_excuse, ""GMP_NUMB_BITS / 4 too small"");
",1,unused,267,unused,"      max_divisor_bits = log2_ceil (max_divisor);

      if (numb_bits / 4 < max_divisor_bits)
        {
          strcpy (mod34_excuse, ""GMP_NUMB_BITS / 4 too small"");
",unused,gmpxenpatch-gen-psqr.c
"  if (nrawfactor <= 2)
    {
      mpz_t  new_pp;

      sprintf (mod34_excuse, ""only %d small factor%s"",
",1,unused,328,unused,"  if (nrawfactor <= 2)
    {
      mpz_t  new_pp;

      sprintf (mod34_excuse, ""only %d small factor%s"",
",unused,gmpxenpatch-gen-psqr.c
"        _pPublishTopic = pPublishTopic;
        _pAcceptTopic = pAcceptTopic;
        _pRejectTopic = pRejectTopic;

        strcpy( _pPublishTopic, TOPIC_PREFIX );
",1,unused,81,unused,"        _pPublishTopic = pPublishTopic;
        _pAcceptTopic = pAcceptTopic;
        _pRejectTopic = pRejectTopic;

        strcpy( _pPublishTopic, TOPIC_PREFIX );
",unused,gordonwang0_aws-iot-device-sdk-embedded-C-lib2Fsource2Fdefender2Faws_iot_defender_mqtt.c
"        _pRejectTopic = pRejectTopic;

        strcpy( _pPublishTopic, TOPIC_PREFIX );
        strncat( _pPublishTopic, pThingName, thingNameLength );
        strcat( _pPublishTopic, TOPIC_SUFFIX_PUBLISH );
",1,unused,83,unused,"        _pRejectTopic = pRejectTopic;

        strcpy( _pPublishTopic, TOPIC_PREFIX );
        strncat( _pPublishTopic, pThingName, thingNameLength );
        strcat( _pPublishTopic, TOPIC_SUFFIX_PUBLISH );
",unused,gordonwang0_aws-iot-device-sdk-embedded-C-lib2Fsource2Fdefender2Faws_iot_defender_mqtt.c
"        strcpy( _pPublishTopic, TOPIC_PREFIX );
        strncat( _pPublishTopic, pThingName, thingNameLength );
        strcat( _pPublishTopic, TOPIC_SUFFIX_PUBLISH );

        strcpy( _pAcceptTopic, TOPIC_PREFIX );
",1,unused,85,unused,"        strcpy( _pPublishTopic, TOPIC_PREFIX );
        strncat( _pPublishTopic, pThingName, thingNameLength );
        strcat( _pPublishTopic, TOPIC_SUFFIX_PUBLISH );

        strcpy( _pAcceptTopic, TOPIC_PREFIX );
",unused,gordonwang0_aws-iot-device-sdk-embedded-C-lib2Fsource2Fdefender2Faws_iot_defender_mqtt.c
"        strcat( _pPublishTopic, TOPIC_SUFFIX_PUBLISH );

        strcpy( _pAcceptTopic, TOPIC_PREFIX );
        strncat( _pAcceptTopic, pThingName, thingNameLength );
        strcat( _pAcceptTopic, TOPIC_SUFFIX_ACCEPTED );
",1,unused,87,unused,"        strcat( _pPublishTopic, TOPIC_SUFFIX_PUBLISH );

        strcpy( _pAcceptTopic, TOPIC_PREFIX );
        strncat( _pAcceptTopic, pThingName, thingNameLength );
        strcat( _pAcceptTopic, TOPIC_SUFFIX_ACCEPTED );
",unused,gordonwang0_aws-iot-device-sdk-embedded-C-lib2Fsource2Fdefender2Faws_iot_defender_mqtt.c
"        strcpy( _pAcceptTopic, TOPIC_PREFIX );
        strncat( _pAcceptTopic, pThingName, thingNameLength );
        strcat( _pAcceptTopic, TOPIC_SUFFIX_ACCEPTED );

        strcpy( _pRejectTopic, TOPIC_PREFIX );
",1,unused,89,unused,"        strcpy( _pAcceptTopic, TOPIC_PREFIX );
        strncat( _pAcceptTopic, pThingName, thingNameLength );
        strcat( _pAcceptTopic, TOPIC_SUFFIX_ACCEPTED );

        strcpy( _pRejectTopic, TOPIC_PREFIX );
",unused,gordonwang0_aws-iot-device-sdk-embedded-C-lib2Fsource2Fdefender2Faws_iot_defender_mqtt.c
"        strcat( _pAcceptTopic, TOPIC_SUFFIX_ACCEPTED );

        strcpy( _pRejectTopic, TOPIC_PREFIX );
        strncat( _pRejectTopic, pThingName, thingNameLength );
        strcat( _pRejectTopic, TOPIC_SUFFIX_REJECTED );
",1,unused,91,unused,"        strcat( _pAcceptTopic, TOPIC_SUFFIX_ACCEPTED );

        strcpy( _pRejectTopic, TOPIC_PREFIX );
        strncat( _pRejectTopic, pThingName, thingNameLength );
        strcat( _pRejectTopic, TOPIC_SUFFIX_REJECTED );
",unused,gordonwang0_aws-iot-device-sdk-embedded-C-lib2Fsource2Fdefender2Faws_iot_defender_mqtt.c
"             that name resolves to /proc/self/fd, which was opened above.
             However, on Solaris, it may resolve to /proc/self/fd/fd, which
             cannot exist, since all names in /proc/self/fd are numeric.  */
          char dotdot_buf[PROC_SELF_FD_NAME_SIZE_BOUND (sizeof ""../fd"" - 1)];
          sprintf (dotdot_buf, PROC_SELF_FD_FORMAT, proc_self_fd, ""../fd"");
",1,unused,89,unused,"             that name resolves to /proc/self/fd, which was opened above.
             However, on Solaris, it may resolve to /proc/self/fd/fd, which
             cannot exist, since all names in /proc/self/fd are numeric.  */
          char dotdot_buf[PROC_SELF_FD_NAME_SIZE_BOUND (sizeof ""../fd"" - 1)];
          sprintf (dotdot_buf, PROC_SELF_FD_FORMAT, proc_self_fd, ""../fd"");
",unused,gzipdebian-lib2Fopenat-proc.c
"          result = malloc (bufsize);
          if (! result)
            return NULL;
        }
      sprintf (result, PROC_SELF_FD_FORMAT, fd, file);
",1,unused,107,unused,"          result = malloc (bufsize);
          if (! result)
            return NULL;
        }
      sprintf (result, PROC_SELF_FD_FORMAT, fd, file);
",unused,gzipdebian-lib2Fopenat-proc.c
"#  if HAVE_NL_LANGINFO && (__GLIBC__ || defined __UCLIBC__ || (defined __APPLE__ && defined __MACH__))
  point = nl_langinfo (RADIXCHAR);
#  elif 1
  char pointbuf[5];
  sprintf (pointbuf, ""%#.0f"", 1.0);
",1,unused,285,unused,"#  if HAVE_NL_LANGINFO && (__GLIBC__ || defined __UCLIBC__ || (defined __APPLE__ && defined __MACH__))
  point = nl_langinfo (RADIXCHAR);
#  elif 1
  char pointbuf[5];
  sprintf (pointbuf, ""%#.0f"", 1.0);
",unused,gzipdebian-lib2Fvasnprintf.c
"                          res_size = 0;
                          free (old_res_ptr);
                          break;
                        }
                      strcpy (res_ptr + res_size - (l2 + 1) - (l1 + 1), buf1);
",1,unused,233,unused,"                          res_size = 0;
                          free (old_res_ptr);
                          break;
                        }
                      strcpy (res_ptr + res_size - (l2 + 1) - (l1 + 1), buf1);
",unused,gzipdebianstretche1.6-lib2Flocalcharset.c
"                          free (old_res_ptr);
                          break;
                        }
                      strcpy (res_ptr + res_size - (l2 + 1) - (l1 + 1), buf1);
                      strcpy (res_ptr + res_size - (l2 + 1), buf2);
",1,unused,234,unused,"                          free (old_res_ptr);
                          break;
                        }
                      strcpy (res_ptr + res_size - (l2 + 1) - (l1 + 1), buf1);
                      strcpy (res_ptr + res_size - (l2 + 1), buf2);
",unused,gzipdebianstretche1.6-lib2Flocalcharset.c
"             that name resolves to /proc/self/fd, which was opened above.
             However, on Solaris, it may resolve to /proc/self/fd/fd, which
             cannot exist, since all names in /proc/self/fd are numeric.  */
          char dotdot_buf[PROC_SELF_FD_NAME_SIZE_BOUND (sizeof ""../fd"" - 1)];
          sprintf (dotdot_buf, PROC_SELF_FD_FORMAT, proc_self_fd, ""../fd"");
",1,unused,89,unused,"             that name resolves to /proc/self/fd, which was opened above.
             However, on Solaris, it may resolve to /proc/self/fd/fd, which
             cannot exist, since all names in /proc/self/fd are numeric.  */
          char dotdot_buf[PROC_SELF_FD_NAME_SIZE_BOUND (sizeof ""../fd"" - 1)];
          sprintf (dotdot_buf, PROC_SELF_FD_FORMAT, proc_self_fd, ""../fd"");
",unused,gzipdebianstretche1.6-lib2Fopenat-proc.c
"          result = malloc (bufsize);
          if (! result)
            return NULL;
        }
      sprintf (result, PROC_SELF_FD_FORMAT, fd, file);
",1,unused,107,unused,"          result = malloc (bufsize);
          if (! result)
            return NULL;
        }
      sprintf (result, PROC_SELF_FD_FORMAT, fd, file);
",unused,gzipdebianstretche1.6-lib2Fopenat-proc.c
"#  if HAVE_NL_LANGINFO && (__GLIBC__ || defined __UCLIBC__ || (defined __APPLE__ && defined __MACH__))
  point = nl_langinfo (RADIXCHAR);
#  elif 1
  char pointbuf[5];
  sprintf (pointbuf, ""%#.0f"", 1.0);
",1,unused,285,unused,"#  if HAVE_NL_LANGINFO && (__GLIBC__ || defined __UCLIBC__ || (defined __APPLE__ && defined __MACH__))
  point = nl_langinfo (RADIXCHAR);
#  elif 1
  char pointbuf[5];
  sprintf (pointbuf, ""%#.0f"", 1.0);
",unused,gzipdebianstretche1.6-lib2Fvasnprintf.c
"                          res_size = 0;
                          free (old_res_ptr);
                          break;
                        }
                      strcpy (res_ptr + res_size - (l2 + 1) - (l1 + 1), buf1);
",1,unused,233,unused,"                          res_size = 0;
                          free (old_res_ptr);
                          break;
                        }
                      strcpy (res_ptr + res_size - (l2 + 1) - (l1 + 1), buf1);
",unused,gzipsources1.6-lib2Flocalcharset.c
"                          free (old_res_ptr);
                          break;
                        }
                      strcpy (res_ptr + res_size - (l2 + 1) - (l1 + 1), buf1);
                      strcpy (res_ptr + res_size - (l2 + 1), buf2);
",1,unused,234,unused,"                          free (old_res_ptr);
                          break;
                        }
                      strcpy (res_ptr + res_size - (l2 + 1) - (l1 + 1), buf1);
                      strcpy (res_ptr + res_size - (l2 + 1), buf2);
",unused,gzipsources1.6-lib2Flocalcharset.c
"             that name resolves to /proc/self/fd, which was opened above.
             However, on Solaris, it may resolve to /proc/self/fd/fd, which
             cannot exist, since all names in /proc/self/fd are numeric.  */
          char dotdot_buf[PROC_SELF_FD_NAME_SIZE_BOUND (sizeof ""../fd"" - 1)];
          sprintf (dotdot_buf, PROC_SELF_FD_FORMAT, proc_self_fd, ""../fd"");
",1,unused,89,unused,"             that name resolves to /proc/self/fd, which was opened above.
             However, on Solaris, it may resolve to /proc/self/fd/fd, which
             cannot exist, since all names in /proc/self/fd are numeric.  */
          char dotdot_buf[PROC_SELF_FD_NAME_SIZE_BOUND (sizeof ""../fd"" - 1)];
          sprintf (dotdot_buf, PROC_SELF_FD_FORMAT, proc_self_fd, ""../fd"");
",unused,gzipsources1.6-lib2Fopenat-proc.c
"          result = malloc (bufsize);
          if (! result)
            return NULL;
        }
      sprintf (result, PROC_SELF_FD_FORMAT, fd, file);
",1,unused,107,unused,"          result = malloc (bufsize);
          if (! result)
            return NULL;
        }
      sprintf (result, PROC_SELF_FD_FORMAT, fd, file);
",unused,gzipsources1.6-lib2Fopenat-proc.c
"#  if HAVE_NL_LANGINFO && (__GLIBC__ || defined __UCLIBC__ || (defined __APPLE__ && defined __MACH__))
  point = nl_langinfo (RADIXCHAR);
#  elif 1
  char pointbuf[5];
  sprintf (pointbuf, ""%#.0f"", 1.0);
",1,unused,285,unused,"#  if HAVE_NL_LANGINFO && (__GLIBC__ || defined __UCLIBC__ || (defined __APPLE__ && defined __MACH__))
  point = nl_langinfo (RADIXCHAR);
#  elif 1
  char pointbuf[5];
  sprintf (pointbuf, ""%#.0f"", 1.0);
",unused,gzipsources1.6-lib2Fvasnprintf.c
"                          res_size = 0;
                          free (old_res_ptr);
                          break;
                        }
                      strcpy (res_ptr + res_size - (l2 + 1) - (l1 + 1), buf1);
",1,unused,233,unused,"                          res_size = 0;
                          free (old_res_ptr);
                          break;
                        }
                      strcpy (res_ptr + res_size - (l2 + 1) - (l1 + 1), buf1);
",unused,gzipubuntuxenial-lib2Flocalcharset.c
"                          free (old_res_ptr);
                          break;
                        }
                      strcpy (res_ptr + res_size - (l2 + 1) - (l1 + 1), buf1);
                      strcpy (res_ptr + res_size - (l2 + 1), buf2);
",1,unused,234,unused,"                          free (old_res_ptr);
                          break;
                        }
                      strcpy (res_ptr + res_size - (l2 + 1) - (l1 + 1), buf1);
                      strcpy (res_ptr + res_size - (l2 + 1), buf2);
",unused,gzipubuntuxenial-lib2Flocalcharset.c
"             that name resolves to /proc/self/fd, which was opened above.
             However, on Solaris, it may resolve to /proc/self/fd/fd, which
             cannot exist, since all names in /proc/self/fd are numeric.  */
          char dotdot_buf[PROC_SELF_FD_NAME_SIZE_BOUND (sizeof ""../fd"" - 1)];
          sprintf (dotdot_buf, PROC_SELF_FD_FORMAT, proc_self_fd, ""../fd"");
",1,unused,89,unused,"             that name resolves to /proc/self/fd, which was opened above.
             However, on Solaris, it may resolve to /proc/self/fd/fd, which
             cannot exist, since all names in /proc/self/fd are numeric.  */
          char dotdot_buf[PROC_SELF_FD_NAME_SIZE_BOUND (sizeof ""../fd"" - 1)];
          sprintf (dotdot_buf, PROC_SELF_FD_FORMAT, proc_self_fd, ""../fd"");
",unused,gzipubuntuxenial-lib2Fopenat-proc.c
"          result = malloc (bufsize);
          if (! result)
            return NULL;
        }
      sprintf (result, PROC_SELF_FD_FORMAT, fd, file);
",1,unused,107,unused,"          result = malloc (bufsize);
          if (! result)
            return NULL;
        }
      sprintf (result, PROC_SELF_FD_FORMAT, fd, file);
",unused,gzipubuntuxenial-lib2Fopenat-proc.c
"                          res_size = 0;
                          free (old_res_ptr);
                          break;
                        }
                      strcpy (res_ptr + res_size - (l2 + 1) - (l1 + 1), buf1);
",1,unused,233,unused,"                          res_size = 0;
                          free (old_res_ptr);
                          break;
                        }
                      strcpy (res_ptr + res_size - (l2 + 1) - (l1 + 1), buf1);
",unused,gzipubuntuxenial1.6-lib2Flocalcharset.c
"                          free (old_res_ptr);
                          break;
                        }
                      strcpy (res_ptr + res_size - (l2 + 1) - (l1 + 1), buf1);
                      strcpy (res_ptr + res_size - (l2 + 1), buf2);
",1,unused,234,unused,"                          free (old_res_ptr);
                          break;
                        }
                      strcpy (res_ptr + res_size - (l2 + 1) - (l1 + 1), buf1);
                      strcpy (res_ptr + res_size - (l2 + 1), buf2);
",unused,gzipubuntuxenial1.6-lib2Flocalcharset.c
"             that name resolves to /proc/self/fd, which was opened above.
             However, on Solaris, it may resolve to /proc/self/fd/fd, which
             cannot exist, since all names in /proc/self/fd are numeric.  */
          char dotdot_buf[PROC_SELF_FD_NAME_SIZE_BOUND (sizeof ""../fd"" - 1)];
          sprintf (dotdot_buf, PROC_SELF_FD_FORMAT, proc_self_fd, ""../fd"");
",1,unused,89,unused,"             that name resolves to /proc/self/fd, which was opened above.
             However, on Solaris, it may resolve to /proc/self/fd/fd, which
             cannot exist, since all names in /proc/self/fd are numeric.  */
          char dotdot_buf[PROC_SELF_FD_NAME_SIZE_BOUND (sizeof ""../fd"" - 1)];
          sprintf (dotdot_buf, PROC_SELF_FD_FORMAT, proc_self_fd, ""../fd"");
",unused,gzipubuntuxenial1.6-lib2Fopenat-proc.c
"          result = malloc (bufsize);
          if (! result)
            return NULL;
        }
      sprintf (result, PROC_SELF_FD_FORMAT, fd, file);
",1,unused,107,unused,"          result = malloc (bufsize);
          if (! result)
            return NULL;
        }
      sprintf (result, PROC_SELF_FD_FORMAT, fd, file);
",unused,gzipubuntuxenial1.6-lib2Fopenat-proc.c
"#  if HAVE_NL_LANGINFO && (__GLIBC__ || defined __UCLIBC__ || (defined __APPLE__ && defined __MACH__))
  point = nl_langinfo (RADIXCHAR);
#  elif 1
  char pointbuf[5];
  sprintf (pointbuf, ""%#.0f"", 1.0);
",1,unused,285,unused,"#  if HAVE_NL_LANGINFO && (__GLIBC__ || defined __UCLIBC__ || (defined __APPLE__ && defined __MACH__))
  point = nl_langinfo (RADIXCHAR);
#  elif 1
  char pointbuf[5];
  sprintf (pointbuf, ""%#.0f"", 1.0);
",unused,gzipubuntuxenial1.6-lib2Fvasnprintf.c
"                globfree (pglob);
                pglob->gl_pathc = 0;
                return GLOB_NOSPACE;
              }
            strcpy (&new[len - 2], ""/"");
",1,unused,1073,unused,"                globfree (pglob);
                pglob->gl_pathc = 0;
                return GLOB_NOSPACE;
              }
            strcpy (&new[len - 2], ""/"");
",unused,inetutilspatchxen-lib2Fglob.c
"                          res_size = 0;
                          free (old_res_ptr);
                          break;
                        }
                      strcpy (res_ptr + res_size - (l2 + 1) - (l1 + 1), buf1);
",1,unused,239,unused,"                          res_size = 0;
                          free (old_res_ptr);
                          break;
                        }
                      strcpy (res_ptr + res_size - (l2 + 1) - (l1 + 1), buf1);
",unused,inetutilspatchxen-lib2Flocalcharset.c
"                          free (old_res_ptr);
                          break;
                        }
                      strcpy (res_ptr + res_size - (l2 + 1) - (l1 + 1), buf1);
                      strcpy (res_ptr + res_size - (l2 + 1), buf2);
",1,unused,240,unused,"                          free (old_res_ptr);
                          break;
                        }
                      strcpy (res_ptr + res_size - (l2 + 1) - (l1 + 1), buf1);
                      strcpy (res_ptr + res_size - (l2 + 1), buf2);
",unused,inetutilspatchxen-lib2Flocalcharset.c
"             that name resolves to /proc/self/fd, which was opened above.
             However, on Solaris, it may resolve to /proc/self/fd/fd, which
             cannot exist, since all names in /proc/self/fd are numeric.  */
          char dotdot_buf[PROC_SELF_FD_NAME_SIZE_BOUND (sizeof ""../fd"" - 1)];
          sprintf (dotdot_buf, PROC_SELF_FD_FORMAT, proc_self_fd, ""../fd"");
",1,unused,81,unused,"             that name resolves to /proc/self/fd, which was opened above.
             However, on Solaris, it may resolve to /proc/self/fd/fd, which
             cannot exist, since all names in /proc/self/fd are numeric.  */
          char dotdot_buf[PROC_SELF_FD_NAME_SIZE_BOUND (sizeof ""../fd"" - 1)];
          sprintf (dotdot_buf, PROC_SELF_FD_FORMAT, proc_self_fd, ""../fd"");
",unused,inetutilspatchxen-lib2Fopenat-proc.c
"          result = malloc (bufsize);
          if (! result)
            return NULL;
        }
      sprintf (result, PROC_SELF_FD_FORMAT, fd, file);
",1,unused,99,unused,"          result = malloc (bufsize);
          if (! result)
            return NULL;
        }
      sprintf (result, PROC_SELF_FD_FORMAT, fd, file);
",unused,inetutilspatchxen-lib2Fopenat-proc.c
"        // checking addr is ipv4 or not
        if (endpoint->family & OC_IP_USE_V4)
        {
            // ipv4
            snprintf(buf, MAX_ADDR_STR_SIZE, ""%s://%s:%d"", endpoint->tps,
",1,unused,249,unused,"        // checking addr is ipv4 or not
        if (endpoint->family & OC_IP_USE_V4)
        {
            // ipv4
            snprintf(buf, MAX_ADDR_STR_SIZE, ""%s://%s:%d"", endpoint->tps,
",unused,iotivity_test-resource2Fcsdk2Fstack2Fsrc2Focendpoint.c
"                     endpoint->addr, endpoint->port);
        }
        else
        {
            // ipv6
",1,unused,254,unused,"                     endpoint->addr, endpoint->port);
        }
        else
        {
            // ipv6
",unused,iotivity_test-resource2Fcsdk2Fstack2Fsrc2Focendpoint.c
"#endif
#ifdef HTTP_ADAPTER
    case OC_HTTP: case OC_HTTPS:
#endif
        if (!endpoint->addr || !endpoint->port)
",1,unused,305,unused,"#endif
#ifdef HTTP_ADAPTER
    case OC_HTTP: case OC_HTTPS:
#endif
        if (!endpoint->addr || !endpoint->port)
",unused,iotivity_test-resource2Fcsdk2Fstack2Fsrc2Focendpoint.c
"        {
            goto exit;
        }
        // checking addr is ipv4 or not
        if (endpoint->flags & CA_IPV4)
",1,unused,310,unused,"        {
            goto exit;
        }
        // checking addr is ipv4 or not
        if (endpoint->flags & CA_IPV4)
",unused,iotivity_test-resource2Fcsdk2Fstack2Fsrc2Focendpoint.c
"        // checking addr is ipv4 or not
        if (endpoint->family & OC_IP_USE_V4)
        {
            // ipv4
            snprintf(buf, MAX_ADDR_STR_SIZE, ""%s://%s:%d"", endpoint->tps,
",1,unused,249,unused,"        // checking addr is ipv4 or not
        if (endpoint->family & OC_IP_USE_V4)
        {
            // ipv4
            snprintf(buf, MAX_ADDR_STR_SIZE, ""%s://%s:%d"", endpoint->tps,
",unused,iotivity_test-resource2Fcsdk2Fstack2Fsrc2Focendpoint.c
"                     endpoint->addr, endpoint->port);
        }
        else
        {
            // ipv6
",1,unused,254,unused,"                     endpoint->addr, endpoint->port);
        }
        else
        {
            // ipv6
",unused,iotivity_test-resource2Fcsdk2Fstack2Fsrc2Focendpoint.c
"#endif
#ifdef HTTP_ADAPTER
    case OC_HTTP: case OC_HTTPS:
#endif
        if (!endpoint->addr || !endpoint->port)
",1,unused,305,unused,"#endif
#ifdef HTTP_ADAPTER
    case OC_HTTP: case OC_HTTPS:
#endif
        if (!endpoint->addr || !endpoint->port)
",unused,iotivity_test-resource2Fcsdk2Fstack2Fsrc2Focendpoint.c
"        {
            goto exit;
        }
        // checking addr is ipv4 or not
        if (endpoint->flags & CA_IPV4)
",1,unused,310,unused,"        {
            goto exit;
        }
        // checking addr is ipv4 or not
        if (endpoint->flags & CA_IPV4)
",unused,iotivity_test-resource2Fcsdk2Fstack2Fsrc2Focendpoint.c
"        // checking addr is ipv4 or not
        if (endpoint->family & OC_IP_USE_V4)
        {
            // ipv4
            snprintf(buf, MAX_ADDR_STR_SIZE, ""%s://%s:%d"", endpoint->tps,
",1,unused,249,unused,"        // checking addr is ipv4 or not
        if (endpoint->family & OC_IP_USE_V4)
        {
            // ipv4
            snprintf(buf, MAX_ADDR_STR_SIZE, ""%s://%s:%d"", endpoint->tps,
",unused,iotivity_test-resource2Fcsdk2Fstack2Fsrc2Focendpoint.c
"                     endpoint->addr, endpoint->port);
        }
        else
        {
            // ipv6
",1,unused,254,unused,"                     endpoint->addr, endpoint->port);
        }
        else
        {
            // ipv6
",unused,iotivity_test-resource2Fcsdk2Fstack2Fsrc2Focendpoint.c
"#endif
#ifdef HTTP_ADAPTER
    case OC_HTTP: case OC_HTTPS:
#endif
        if (!endpoint->addr || !endpoint->port)
",1,unused,305,unused,"#endif
#ifdef HTTP_ADAPTER
    case OC_HTTP: case OC_HTTPS:
#endif
        if (!endpoint->addr || !endpoint->port)
",unused,iotivity_test-resource2Fcsdk2Fstack2Fsrc2Focendpoint.c
"        {
            goto exit;
        }
        // checking addr is ipv4 or not
        if (endpoint->flags & CA_IPV4)
",1,unused,310,unused,"        {
            goto exit;
        }
        // checking addr is ipv4 or not
        if (endpoint->flags & CA_IPV4)
",unused,iotivity_test-resource2Fcsdk2Fstack2Fsrc2Focendpoint.c
"        // checking addr is ipv4 or not
        if (endpoint->family & OC_IP_USE_V4)
        {
            // ipv4
            snprintf(buf, MAX_ADDR_STR_SIZE, ""%s://%s:%d"", endpoint->tps,
",1,unused,249,unused,"        // checking addr is ipv4 or not
        if (endpoint->family & OC_IP_USE_V4)
        {
            // ipv4
            snprintf(buf, MAX_ADDR_STR_SIZE, ""%s://%s:%d"", endpoint->tps,
",unused,iotivity_test-resource2Fcsdk2Fstack2Fsrc2Focendpoint.c
"                     endpoint->addr, endpoint->port);
        }
        else
        {
            // ipv6
",1,unused,254,unused,"                     endpoint->addr, endpoint->port);
        }
        else
        {
            // ipv6
",unused,iotivity_test-resource2Fcsdk2Fstack2Fsrc2Focendpoint.c
"#endif
#ifdef HTTP_ADAPTER
    case OC_HTTP: case OC_HTTPS:
#endif
        if (!endpoint->addr || !endpoint->port)
",1,unused,305,unused,"#endif
#ifdef HTTP_ADAPTER
    case OC_HTTP: case OC_HTTPS:
#endif
        if (!endpoint->addr || !endpoint->port)
",unused,iotivity_test-resource2Fcsdk2Fstack2Fsrc2Focendpoint.c
"        {
            goto exit;
        }
        // checking addr is ipv4 or not
        if (endpoint->flags & CA_IPV4)
",1,unused,310,unused,"        {
            goto exit;
        }
        // checking addr is ipv4 or not
        if (endpoint->flags & CA_IPV4)
",unused,iotivity_test-resource2Fcsdk2Fstack2Fsrc2Focendpoint.c
"        // checking addr is ipv4 or not
        if (endpoint->family & OC_IP_USE_V4)
        {
            // ipv4
            snprintf(buf, MAX_ADDR_STR_SIZE, ""%s://%s:%d"", endpoint->tps,
",1,unused,249,unused,"        // checking addr is ipv4 or not
        if (endpoint->family & OC_IP_USE_V4)
        {
            // ipv4
            snprintf(buf, MAX_ADDR_STR_SIZE, ""%s://%s:%d"", endpoint->tps,
",unused,iotivity_test-resource2Fcsdk2Fstack2Fsrc2Focendpoint.c
"                     endpoint->addr, endpoint->port);
        }
        else
        {
            // ipv6
",1,unused,254,unused,"                     endpoint->addr, endpoint->port);
        }
        else
        {
            // ipv6
",unused,iotivity_test-resource2Fcsdk2Fstack2Fsrc2Focendpoint.c
"#endif
#ifdef HTTP_ADAPTER
    case OC_HTTP: case OC_HTTPS:
#endif
        if (!endpoint->addr || !endpoint->port)
",1,unused,305,unused,"#endif
#ifdef HTTP_ADAPTER
    case OC_HTTP: case OC_HTTPS:
#endif
        if (!endpoint->addr || !endpoint->port)
",unused,iotivity_test-resource2Fcsdk2Fstack2Fsrc2Focendpoint.c
"        {
            goto exit;
        }
        // checking addr is ipv4 or not
        if (endpoint->flags & CA_IPV4)
",1,unused,310,unused,"        {
            goto exit;
        }
        // checking addr is ipv4 or not
        if (endpoint->flags & CA_IPV4)
",unused,iotivity_test-resource2Fcsdk2Fstack2Fsrc2Focendpoint.c
"        // checking addr is ipv4 or not
        if (endpoint->family & OC_IP_USE_V4)
        {
            // ipv4
            snprintf(buf, MAX_ADDR_STR_SIZE, ""%s://%s:%d"", endpoint->tps,
",1,unused,249,unused,"        // checking addr is ipv4 or not
        if (endpoint->family & OC_IP_USE_V4)
        {
            // ipv4
            snprintf(buf, MAX_ADDR_STR_SIZE, ""%s://%s:%d"", endpoint->tps,
",unused,iotivity_test-resource2Fcsdk2Fstack2Fsrc2Focendpoint.c
"                     endpoint->addr, endpoint->port);
        }
        else
        {
            // ipv6
",1,unused,254,unused,"                     endpoint->addr, endpoint->port);
        }
        else
        {
            // ipv6
",unused,iotivity_test-resource2Fcsdk2Fstack2Fsrc2Focendpoint.c
"#endif
#ifdef HTTP_ADAPTER
    case OC_HTTP: case OC_HTTPS:
#endif
        if (!endpoint->addr || !endpoint->port)
",1,unused,305,unused,"#endif
#ifdef HTTP_ADAPTER
    case OC_HTTP: case OC_HTTPS:
#endif
        if (!endpoint->addr || !endpoint->port)
",unused,iotivity_test-resource2Fcsdk2Fstack2Fsrc2Focendpoint.c
"        {
            goto exit;
        }
        // checking addr is ipv4 or not
        if (endpoint->flags & CA_IPV4)
",1,unused,310,unused,"        {
            goto exit;
        }
        // checking addr is ipv4 or not
        if (endpoint->flags & CA_IPV4)
",unused,iotivity_test-resource2Fcsdk2Fstack2Fsrc2Focendpoint.c
"    OICStrcat(outputAddress, outputSize, scopeIdPart);

    return OC_STACK_OK;
}

",1,unused,1102,unused,"    OICStrcat(outputAddress, outputSize, scopeIdPart);

    return OC_STACK_OK;
}

",unused,iotivity_test-resource2Fcsdk2Fstack2Fsrc2Focstack.c
"
    return OC_STACK_OK;
}

OCStackResult OCDecodeAddressForRFC6874(char *outputAddress,
",1,unused,1103,unused,"
    return OC_STACK_OK;
}

OCStackResult OCDecodeAddressForRFC6874(char *outputAddress,
",unused,iotivity_test-resource2Fcsdk2Fstack2Fsrc2Focstack.c
"                return OC_STACK_INVALID_URI;
            }
            end = close;
            if (close[1] == ':')
            {
",1,unused,3021,unused,"                return OC_STACK_INVALID_URI;
            }
            end = close;
            if (close[1] == ':')
            {
",unused,iotivity_test-resource2Fcsdk2Fstack2Fsrc2Focstack.c
"    OICStrcat(outputAddress, outputSize, scopeIdPart);

    return OC_STACK_OK;
}

",1,unused,1102,unused,"    OICStrcat(outputAddress, outputSize, scopeIdPart);

    return OC_STACK_OK;
}

",unused,iotivity_test-resource2Fcsdk2Fstack2Fsrc2Focstack.c
"
    return OC_STACK_OK;
}

OCStackResult OCDecodeAddressForRFC6874(char *outputAddress,
",1,unused,1103,unused,"
    return OC_STACK_OK;
}

OCStackResult OCDecodeAddressForRFC6874(char *outputAddress,
",unused,iotivity_test-resource2Fcsdk2Fstack2Fsrc2Focstack.c
"                return OC_STACK_INVALID_URI;
            }
            end = close;
            if (close[1] == ':')
            {
",1,unused,3021,unused,"                return OC_STACK_INVALID_URI;
            }
            end = close;
            if (close[1] == ':')
            {
",unused,iotivity_test-resource2Fcsdk2Fstack2Fsrc2Focstack.c
"    OICStrcat(outputAddress, outputSize, scopeIdPart);

    return OC_STACK_OK;
}

",1,unused,1102,unused,"    OICStrcat(outputAddress, outputSize, scopeIdPart);

    return OC_STACK_OK;
}

",unused,iotivity_test-resource2Fcsdk2Fstack2Fsrc2Focstack.c
"
    return OC_STACK_OK;
}

OCStackResult OCDecodeAddressForRFC6874(char *outputAddress,
",1,unused,1103,unused,"
    return OC_STACK_OK;
}

OCStackResult OCDecodeAddressForRFC6874(char *outputAddress,
",unused,iotivity_test-resource2Fcsdk2Fstack2Fsrc2Focstack.c
"                return OC_STACK_INVALID_URI;
            }
            end = close;
            if (close[1] == ':')
            {
",1,unused,3021,unused,"                return OC_STACK_INVALID_URI;
            }
            end = close;
            if (close[1] == ':')
            {
",unused,iotivity_test-resource2Fcsdk2Fstack2Fsrc2Focstack.c
"    OICStrcat(outputAddress, outputSize, scopeIdPart);

    return OC_STACK_OK;
}

",1,unused,1102,unused,"    OICStrcat(outputAddress, outputSize, scopeIdPart);

    return OC_STACK_OK;
}

",unused,iotivity_test-resource2Fcsdk2Fstack2Fsrc2Focstack.c
"
    return OC_STACK_OK;
}

OCStackResult OCDecodeAddressForRFC6874(char *outputAddress,
",1,unused,1103,unused,"
    return OC_STACK_OK;
}

OCStackResult OCDecodeAddressForRFC6874(char *outputAddress,
",unused,iotivity_test-resource2Fcsdk2Fstack2Fsrc2Focstack.c
"                return OC_STACK_INVALID_URI;
            }
            end = close;
            if (close[1] == ':')
            {
",1,unused,3021,unused,"                return OC_STACK_INVALID_URI;
            }
            end = close;
            if (close[1] == ':')
            {
",unused,iotivity_test-resource2Fcsdk2Fstack2Fsrc2Focstack.c
"    OICStrcat(outputAddress, outputSize, scopeIdPart);

    return OC_STACK_OK;
}

",1,unused,1102,unused,"    OICStrcat(outputAddress, outputSize, scopeIdPart);

    return OC_STACK_OK;
}

",unused,iotivity_test-resource2Fcsdk2Fstack2Fsrc2Focstack.c
"
    return OC_STACK_OK;
}

OCStackResult OCDecodeAddressForRFC6874(char *outputAddress,
",1,unused,1103,unused,"
    return OC_STACK_OK;
}

OCStackResult OCDecodeAddressForRFC6874(char *outputAddress,
",unused,iotivity_test-resource2Fcsdk2Fstack2Fsrc2Focstack.c
"                return OC_STACK_INVALID_URI;
            }
            end = close;
            if (close[1] == ':')
            {
",1,unused,3021,unused,"                return OC_STACK_INVALID_URI;
            }
            end = close;
            if (close[1] == ':')
            {
",unused,iotivity_test-resource2Fcsdk2Fstack2Fsrc2Focstack.c
"    OICStrcat(outputAddress, outputSize, scopeIdPart);

    return OC_STACK_OK;
}

",1,unused,1102,unused,"    OICStrcat(outputAddress, outputSize, scopeIdPart);

    return OC_STACK_OK;
}

",unused,iotivity_test-resource2Fcsdk2Fstack2Fsrc2Focstack.c
"
    return OC_STACK_OK;
}

OCStackResult OCDecodeAddressForRFC6874(char *outputAddress,
",1,unused,1103,unused,"
    return OC_STACK_OK;
}

OCStackResult OCDecodeAddressForRFC6874(char *outputAddress,
",unused,iotivity_test-resource2Fcsdk2Fstack2Fsrc2Focstack.c
"                return OC_STACK_INVALID_URI;
            }
            end = close;
            if (close[1] == ':')
            {
",1,unused,3021,unused,"                return OC_STACK_INVALID_URI;
            }
            end = close;
            if (close[1] == ':')
            {
",unused,iotivity_test-resource2Fcsdk2Fstack2Fsrc2Focstack.c
"        return OC_STACK_ERROR;
    }

    // Restore the null terminator with an escaped '%' character, per RFC 6874
    OICStrcpy(outputAddress, scopeIdPart - addressPart, addressPart);
",1,unused,1096,unused,"        return OC_STACK_ERROR;
    }

    // Restore the null terminator with an escaped '%' character, per RFC 6874
    OICStrcpy(outputAddress, scopeIdPart - addressPart, addressPart);
",unused,iotivity_test-resource2Fcsdk2Fstack2Fsrc2Focstack.c
"        OIC_LOG(ERROR, TAG, ""OCEncodeAddressForRFC6874 failed: encoded output will not fit!"");
        return OC_STACK_ERROR;
    }

    // Restore the null terminator with an escaped '%' character, per RFC 6874
",1,unused,1095,unused,"        OIC_LOG(ERROR, TAG, ""OCEncodeAddressForRFC6874 failed: encoded output will not fit!"");
        return OC_STACK_ERROR;
    }

    // Restore the null terminator with an escaped '%' character, per RFC 6874
",unused,iotivity_test-resource2Fcsdk2Fstack2Fsrc2Focstack.c
"    if (urlLen && devAddr)
    {   // construct OCDevAddr
        if (start[0] == '[')
        {   // ipv6 address
            char *close = strchr(++start, ']');
",1,unused,3014,unused,"    if (urlLen && devAddr)
    {   // construct OCDevAddr
        if (start[0] == '[')
        {   // ipv6 address
            char *close = strchr(++start, ']');
",unused,iotivity_test-resource2Fcsdk2Fstack2Fsrc2Focstack.c
"        OIC_LOG(ERROR, TAG, ""OCEncodeAddressForRFC6874 failed: encoded output will not fit!"");
        return OC_STACK_ERROR;
    }

    // Restore the null terminator with an escaped '%' character, per RFC 6874
",1,unused,1095,unused,"        OIC_LOG(ERROR, TAG, ""OCEncodeAddressForRFC6874 failed: encoded output will not fit!"");
        return OC_STACK_ERROR;
    }

    // Restore the null terminator with an escaped '%' character, per RFC 6874
",unused,iotivity_test-resource2Fcsdk2Fstack2Fsrc2Focstack.c
"        return OC_STACK_ERROR;
    }

    // Restore the null terminator with an escaped '%' character, per RFC 6874
    OICStrcpy(outputAddress, scopeIdPart - addressPart, addressPart);
",1,unused,1096,unused,"        return OC_STACK_ERROR;
    }

    // Restore the null terminator with an escaped '%' character, per RFC 6874
    OICStrcpy(outputAddress, scopeIdPart - addressPart, addressPart);
",unused,iotivity_test-resource2Fcsdk2Fstack2Fsrc2Focstack.c
"    if (urlLen && devAddr)
    {   // construct OCDevAddr
        if (start[0] == '[')
        {   // ipv6 address
            char *close = strchr(++start, ']');
",1,unused,3014,unused,"    if (urlLen && devAddr)
    {   // construct OCDevAddr
        if (start[0] == '[')
        {   // ipv6 address
            char *close = strchr(++start, ']');
",unused,iotivity_test-resource2Fcsdk2Fstack2Fsrc2Focstack.c
"        fprintf(stderr, ""%s\n  Options:\n\n"", CLI_DEFAULT_HELP_STRING);
        for (uint32_t k = 0; k < NUM_OF_OPTIONS; k++) {
          if (opts[k].opt) {
            fprintf(stderr, ""    -%s, --%-21s %s\n"", opts[k].opt,
                    opts[k].longopt, opts[k].help);
",1,unused,156,unused,"        fprintf(stderr, ""%s\n  Options:\n\n"", CLI_DEFAULT_HELP_STRING);
        for (uint32_t k = 0; k < NUM_OF_OPTIONS; k++) {
          if (opts[k].opt) {
            fprintf(stderr, ""    -%s, --%-21s %s\n"", opts[k].opt,
                    opts[k].longopt, opts[k].help);
",unused,iotjs-webeng-2-src2Fiotjs_env.c
"
	if (s & NUD_REACHABLE)
		return """";

	sprintf(buf, ""state=%#x"", s);
",1,unused,58,unused,"
	if (s & NUD_REACHABLE)
		return """";

	sprintf(buf, ""state=%#x"", s);
",unused,iproute2xenpatch-bridge2Ffdb.c
"		memset(&p1, 0, sizeof(p1));
		ip6_tnl_parm_init(&p1, 0);
		if (type == ARPHRD_IP6GRE)
			p1.proto = IPPROTO_GRE;
		strcpy(p1.name, name);
",1,unused,402,unused,"		memset(&p1, 0, sizeof(p1));
		ip6_tnl_parm_init(&p1, 0);
		if (type == ARPHRD_IP6GRE)
			p1.proto = IPPROTO_GRE;
		strcpy(p1.name, name);
",unused,iproute2xenpatch-ip2Fip6tunnel.c
"		perror(""malloc"");
		return -ENOMEM;
	}
	c->nsid = nsid;
	strcpy(c->name, name);
",1,unused,181,unused,"		perror(""malloc"");
		return -ENOMEM;
	}
	c->nsid = nsid;
	strcpy(c->name, name);
",unused,iproute2xenpatch-ip2Fipnetns.c
"			continue;
		id = get_netnsid_from_name(entry->d_name);

		if (nsid == id) {
			strcpy(name, entry->d_name);
",1,unused,250,unused,"			continue;
		id = get_netnsid_from_name(entry->d_name);

		if (nsid == id) {
			strcpy(name, entry->d_name);
",unused,iproute2xenpatch-ip2Fipnetns.c
"	strftime(str, sizeof(str), ""%Y-%m-%d %T"", tp);

	return str;
 error:
	strcpy(str, ""(error)"");
",1,unused,348,unused,"	strftime(str, sizeof(str), ""%Y-%m-%d %T"", tp);

	return str;
 error:
	strcpy(str, ""(error)"");
",unused,iproute2xenpatch-ip2Fipntable.c
"	ssize_t len;
	int fd;
	long result;

	sprintf(fname, ""/sys/class/net/%s/%s"", dev, prop);
",1,unused,227,unused,"	ssize_t len;
	int fd;
	long result;

	sprintf(fname, ""/sys/class/net/%s/%s"", dev, prop);
",unused,iproute2xenpatch-ip2Fiptuntap.c
"		if (t->t_type == proto)
			return t->t_name;
	}

	sprintf(str, ""%u"", proto);
",1,unused,151,unused,"		if (t->t_type == proto)
			return t->t_name;
	}

	sprintf(str, ""%u"", proto);
",unused,iproute2xenpatch-ip2Fipxfrm.c
"		if (t->t_type == type)
			return t->t_name;
	}

	sprintf(str, ""%d"", type);
",1,unused,192,unused,"		if (t->t_type == type)
			return t->t_name;
	}

	sprintf(str, ""%d"", type);
",unused,iproute2xenpatch-ip2Fipxfrm.c
"const char *strxf_mask32(__u32 mask)
{
	static char str[16];

	sprintf(str, ""%.8x"", mask);
",1,unused,214,unused,"const char *strxf_mask32(__u32 mask)
{
	static char str[16];

	sprintf(str, ""%.8x"", mask);
",unused,iproute2xenpatch-ip2Fipxfrm.c
"	static char str[32];

	switch (share) {
	case XFRM_SHARE_ANY:
		strcpy(str, ""any"");
",1,unused,225,unused,"	static char str[32];

	switch (share) {
	case XFRM_SHARE_ANY:
		strcpy(str, ""any"");
",unused,iproute2xenpatch-ip2Fipxfrm.c
"	case XFRM_SHARE_ANY:
		strcpy(str, ""any"");
		break;
	case XFRM_SHARE_SESSION:
		strcpy(str, ""session"");
",1,unused,228,unused,"	case XFRM_SHARE_ANY:
		strcpy(str, ""any"");
		break;
	case XFRM_SHARE_SESSION:
		strcpy(str, ""session"");
",unused,iproute2xenpatch-ip2Fipxfrm.c
"	case XFRM_SHARE_SESSION:
		strcpy(str, ""session"");
		break;
	case XFRM_SHARE_USER:
		strcpy(str, ""user"");
",1,unused,231,unused,"	case XFRM_SHARE_SESSION:
		strcpy(str, ""session"");
		break;
	case XFRM_SHARE_USER:
		strcpy(str, ""user"");
",unused,iproute2xenpatch-ip2Fipxfrm.c
"	case XFRM_SHARE_USER:
		strcpy(str, ""user"");
		break;
	case XFRM_SHARE_UNIQUE:
		strcpy(str, ""unique"");
",1,unused,234,unused,"	case XFRM_SHARE_USER:
		strcpy(str, ""user"");
		break;
	case XFRM_SHARE_UNIQUE:
		strcpy(str, ""unique"");
",unused,iproute2xenpatch-ip2Fipxfrm.c
"	case XFRM_SHARE_UNIQUE:
		strcpy(str, ""unique"");
		break;
	default:
		sprintf(str, ""%u"", share);
",1,unused,237,unused,"	case XFRM_SHARE_UNIQUE:
		strcpy(str, ""unique"");
		break;
	default:
		sprintf(str, ""%u"", share);
",unused,iproute2xenpatch-ip2Fipxfrm.c
"	pp = getprotobynumber(proto);
	if (pp)
		p = pp->p_name;
	else {
		sprintf(buf, ""%u"", proto);
",1,unused,254,unused,"	pp = getprotobynumber(proto);
	if (pp)
		p = pp->p_name;
	else {
		sprintf(buf, ""%u"", proto);
",unused,iproute2xenpatch-ip2Fipxfrm.c
"	static char str[16];

	switch (ptype) {
	case XFRM_POLICY_TYPE_MAIN:
		strcpy(str, ""main"");
",1,unused,267,unused,"	static char str[16];

	switch (ptype) {
	case XFRM_POLICY_TYPE_MAIN:
		strcpy(str, ""main"");
",unused,iproute2xenpatch-ip2Fipxfrm.c
"	case XFRM_POLICY_TYPE_MAIN:
		strcpy(str, ""main"");
		break;
	case XFRM_POLICY_TYPE_SUB:
		strcpy(str, ""sub"");
",1,unused,270,unused,"	case XFRM_POLICY_TYPE_MAIN:
		strcpy(str, ""main"");
		break;
	case XFRM_POLICY_TYPE_SUB:
		strcpy(str, ""sub"");
",unused,iproute2xenpatch-ip2Fipxfrm.c
"	case XFRM_POLICY_TYPE_SUB:
		strcpy(str, ""sub"");
		break;
	default:
		sprintf(str, ""%u"", ptype);
",1,unused,273,unused,"	case XFRM_POLICY_TYPE_SUB:
		strcpy(str, ""sub"");
		break;
	default:
		sprintf(str, ""%u"", ptype);
",unused,iproute2xenpatch-ip2Fipxfrm.c
"static const char *strxf_limit(__u64 limit)
{
	static char str[32];
	if (limit == XFRM_INF)
		strcpy(str, ""(INF)"");
",1,unused,344,unused,"static const char *strxf_limit(__u64 limit)
{
	static char str[32];
	if (limit == XFRM_INF)
		strcpy(str, ""(INF)"");
",unused,iproute2xenpatch-ip2Fipxfrm.c
"	static char str[32];
	if (limit == XFRM_INF)
		strcpy(str, ""(INF)"");
	else
		sprintf(str, ""%llu"", (unsigned long long) limit);
",1,unused,346,unused,"	static char str[32];
	if (limit == XFRM_INF)
		strcpy(str, ""(INF)"");
	else
		sprintf(str, ""%llu"", (unsigned long long) limit);
",unused,iproute2xenpatch-ip2Fipxfrm.c
"{
	static char str[32];

	if (time == 0)
		strcpy(str, ""-"");
",1,unused,368,unused,"{
	static char str[32];

	if (time == 0)
		strcpy(str, ""-"");
",unused,iproute2xenpatch-ip2Fipxfrm.c
"		if (max > 16)
			max = 16;
		cookie[0] = 0;
		for (i = 0; i < max; i++)
			sprintf(cookie + i + i, ""%02x"", ptr[i]);
",1,unused,294,unused,"		if (max > 16)
			max = 16;
		cookie[0] = 0;
		for (i = 0; i < max; i++)
			sprintf(cookie + i + i, ""%02x"", ptr[i]);
",unused,iproute2xenpatch-ip2Ftcp_metrics.c
"	static char buf[16];

	switch (proto) {
	case IPPROTO_IPIP:
		strcpy(buf, ""ip"");
",1,unused,46,unused,"	static char buf[16];

	switch (proto) {
	case IPPROTO_IPIP:
		strcpy(buf, ""ip"");
",unused,iproute2xenpatch-ip2Ftunnel.c
"	case IPPROTO_IPIP:
		strcpy(buf, ""ip"");
		break;
	case IPPROTO_GRE:
		strcpy(buf, ""gre"");
",1,unused,49,unused,"	case IPPROTO_IPIP:
		strcpy(buf, ""ip"");
		break;
	case IPPROTO_GRE:
		strcpy(buf, ""gre"");
",unused,iproute2xenpatch-ip2Ftunnel.c
"	case IPPROTO_GRE:
		strcpy(buf, ""gre"");
		break;
	case IPPROTO_IPV6:
		strcpy(buf, ""ipv6"");
",1,unused,52,unused,"	case IPPROTO_GRE:
		strcpy(buf, ""gre"");
		break;
	case IPPROTO_IPV6:
		strcpy(buf, ""ipv6"");
",unused,iproute2xenpatch-ip2Ftunnel.c
"	case IPPROTO_IPV6:
		strcpy(buf, ""ipv6"");
		break;
	case IPPROTO_ESP:
		strcpy(buf, ""esp"");
",1,unused,55,unused,"	case IPPROTO_IPV6:
		strcpy(buf, ""ipv6"");
		break;
	case IPPROTO_ESP:
		strcpy(buf, ""esp"");
",unused,iproute2xenpatch-ip2Ftunnel.c
"	case IPPROTO_ESP:
		strcpy(buf, ""esp"");
		break;
	case 0:
		strcpy(buf, ""any"");
",1,unused,58,unused,"	case IPPROTO_ESP:
		strcpy(buf, ""esp"");
		break;
	case 0:
		strcpy(buf, ""any"");
",unused,iproute2xenpatch-ip2Ftunnel.c
"	case 0:
		strcpy(buf, ""any"");
		break;
	default:
		strcpy(buf, ""unknown"");
",1,unused,61,unused,"	case 0:
		strcpy(buf, ""any"");
		break;
	default:
		strcpy(buf, ""unknown"");
",unused,iproute2xenpatch-ip2Ftunnel.c
"	im = malloc(sizeof(*im));
	if (im == NULL)
		return 0;
	im->index = ifi->ifi_index;
	strcpy(im->name, ifname);
",1,unused,128,unused,"	im = malloc(sizeof(*im));
	if (im == NULL)
		return 0;
	im->index = ifi->ifi_index;
	strcpy(im->name, ifname);
",unused,iproute2xenpatch-lib2Fll_map.c
"		} else if (sscanf(p, ""0x%x %s\n"", id, name) != 2 &&
				sscanf(p, ""0x%x %s #"", id, name) != 2 &&
				sscanf(p, ""%d %s\n"", id, name) != 2 &&
				sscanf(p, ""%d %s #"", id, name) != 2) {
			strcpy(name, p);
",1,unused,44,unused,"		} else if (sscanf(p, ""0x%x %s\n"", id, name) != 2 &&
				sscanf(p, ""0x%x %s #"", id, name) != 2 &&
				sscanf(p, ""%d %s\n"", id, name) != 2 &&
				sscanf(p, ""%d %s #"", id, name) != 2) {
			strcpy(name, p);
",unused,iproute2xenpatch-lib2Fnames.c
"		if (sscanf(p, ""0x%x %s\n"", id, namebuf) != 2 &&
				sscanf(p, ""0x%x %s #"", id, namebuf) != 2 &&
				sscanf(p, ""%d %s\n"", id, namebuf) != 2 &&
				sscanf(p, ""%d %s #"", id, namebuf) != 2) {
			strcpy(namebuf, p);
",1,unused,55,unused,"		if (sscanf(p, ""0x%x %s\n"", id, namebuf) != 2 &&
				sscanf(p, ""0x%x %s #"", id, namebuf) != 2 &&
				sscanf(p, ""%d %s\n"", id, namebuf) != 2 &&
				sscanf(p, ""%d %s #"", id, namebuf) != 2) {
			strcpy(namebuf, p);
",unused,iproute2xenpatch-lib2Frt_names.c
"		snprintf(name, sizeof(name)-1, ""%s"", getenv(""PROC_NET_PSCHED""));
	} else if (getenv(""PROC_ROOT"")) {
		snprintf(name, sizeof(name)-1, ""%s/net/psched"", getenv(""PROC_ROOT""));
	} else {
		strcpy(name, ""/proc/net/psched"");
",1,unused,647,unused,"		snprintf(name, sizeof(name)-1, ""%s"", getenv(""PROC_NET_PSCHED""));
	} else if (getenv(""PROC_ROOT"")) {
		snprintf(name, sizeof(name)-1, ""%s/net/psched"", getenv(""PROC_ROOT""));
	} else {
		strcpy(name, ""/proc/net/psched"");
",unused,iproute2xenpatch-lib2Futils.c
"
	for (i=0; i<len; i++) {
		if (blen < 3)
			break;
		sprintf(ptr, ""%02x"", str[i]);
",1,unused,812,unused,"
	for (i=0; i<len; i++) {
		if (blen < 3)
			break;
		sprintf(ptr, ""%02x"", str[i]);
",unused,iproute2xenpatch-lib2Futils.c
"			*lenp = 0;
			return -1;
		}
		cc += cc1 - 2;
		strcat(*linep, line1);
",1,unused,906,unused,"			*lenp = 0;
			return -1;
		}
		cc += cc1 - 2;
		strcat(*linep, line1);
",unused,iproute2xenpatch-lib2Futils.c
"}

char *int_to_str(int val, char *buf)
{
	sprintf(buf, ""%d"", val);
",1,unused,997,unused,"}

char *int_to_str(int val, char *buf)
{
	sprintf(buf, ""%d"", val);
",unused,iproute2xenpatch-lib2Futils.c
"		char buf[128];
		FILE *fp;

		if (active_probing) {
			sprintf(buf, ""/proc/sys/net/ipv4/neigh/%s/mcast_solicit"", ifnames[i]);
",1,unused,131,unused,"		char buf[128];
		FILE *fp;

		if (active_probing) {
			sprintf(buf, ""/proc/sys/net/ipv4/neigh/%s/mcast_solicit"", ifnames[i]);
",unused,iproute2xenpatch-misc2Farpd.c
"		if (active_probing) {
			sprintf(buf, ""/proc/sys/net/ipv4/neigh/%s/mcast_solicit"", ifnames[i]);
			if ((fp = fopen(buf, ""w"")) != NULL) {
				if (no_kernel_broadcasts)
					strcpy(buf, ""0\n"");
",1,unused,134,unused,"		if (active_probing) {
			sprintf(buf, ""/proc/sys/net/ipv4/neigh/%s/mcast_solicit"", ifnames[i]);
			if ((fp = fopen(buf, ""w"")) != NULL) {
				if (no_kernel_broadcasts)
					strcpy(buf, ""0\n"");
",unused,iproute2xenpatch-misc2Farpd.c
"			if ((fp = fopen(buf, ""w"")) != NULL) {
				if (no_kernel_broadcasts)
					strcpy(buf, ""0\n"");
				else
					sprintf(buf, ""%d\n"", active_probing>=2 ? 1 : 3-active_probing);
",1,unused,136,unused,"			if ((fp = fopen(buf, ""w"")) != NULL) {
				if (no_kernel_broadcasts)
					strcpy(buf, ""0\n"");
				else
					sprintf(buf, ""%d\n"", active_probing>=2 ? 1 : 3-active_probing);
",unused,iproute2xenpatch-misc2Farpd.c
"				fclose(fp);
			}
		}

		sprintf(buf, ""/proc/sys/net/ipv4/neigh/%s/app_solicit"", ifnames[i]);
",1,unused,142,unused,"				fclose(fp);
			}
		}

		sprintf(buf, ""/proc/sys/net/ipv4/neigh/%s/app_solicit"", ifnames[i]);
",unused,iproute2xenpatch-misc2Farpd.c
"		}

		sprintf(buf, ""/proc/sys/net/ipv4/neigh/%s/app_solicit"", ifnames[i]);
		if ((fp = fopen(buf, ""w"")) != NULL) {
			sprintf(buf, ""%d\n"", active_probing<=1 ? 1 : active_probing);
",1,unused,144,unused,"		}

		sprintf(buf, ""/proc/sys/net/ipv4/neigh/%s/app_solicit"", ifnames[i]);
		if ((fp = fopen(buf, ""w"")) != NULL) {
			sprintf(buf, ""%d\n"", active_probing<=1 ? 1 : active_probing);
",unused,iproute2xenpatch-misc2Farpd.c
"		char buf[128];
		FILE *fp;

		if (active_probing) {
			sprintf(buf, ""/proc/sys/net/ipv4/neigh/%s/mcast_solicit"", ifnames[i]);
",1,unused,164,unused,"		char buf[128];
		FILE *fp;

		if (active_probing) {
			sprintf(buf, ""/proc/sys/net/ipv4/neigh/%s/mcast_solicit"", ifnames[i]);
",unused,iproute2xenpatch-misc2Farpd.c
"
		if (active_probing) {
			sprintf(buf, ""/proc/sys/net/ipv4/neigh/%s/mcast_solicit"", ifnames[i]);
			if ((fp = fopen(buf, ""w"")) != NULL) {
				strcpy(buf, ""3\n"");
",1,unused,166,unused,"
		if (active_probing) {
			sprintf(buf, ""/proc/sys/net/ipv4/neigh/%s/mcast_solicit"", ifnames[i]);
			if ((fp = fopen(buf, ""w"")) != NULL) {
				strcpy(buf, ""3\n"");
",unused,iproute2xenpatch-misc2Farpd.c
"				fputs(buf, fp);
				fclose(fp);
			}
		}
		sprintf(buf, ""/proc/sys/net/ipv4/neigh/%s/app_solicit"", ifnames[i]);
",1,unused,171,unused,"				fputs(buf, fp);
				fclose(fp);
			}
		}
		sprintf(buf, ""/proc/sys/net/ipv4/neigh/%s/app_solicit"", ifnames[i]);
",unused,iproute2xenpatch-misc2Farpd.c
"			}
		}
		sprintf(buf, ""/proc/sys/net/ipv4/neigh/%s/app_solicit"", ifnames[i]);
		if ((fp = fopen(buf, ""w"")) != NULL) {
			strcpy(buf, ""0\n"");
",1,unused,173,unused,"			}
		}
		sprintf(buf, ""/proc/sys/net/ipv4/neigh/%s/app_solicit"", ifnames[i]);
		if ((fp = fopen(buf, ""w"")) != NULL) {
			strcpy(buf, ""0\n"");
",unused,iproute2xenpatch-misc2Farpd.c
"	else
		fprintf(fp, ""%8llu "", vals[i]);

	if (rates[i] > mega) {
		sprintf(temp, ""%uM"", (unsigned)(rates[i]/mega));
",1,unused,311,unused,"	else
		fprintf(fp, ""%8llu "", vals[i]);

	if (rates[i] > mega) {
		sprintf(temp, ""%uM"", (unsigned)(rates[i]/mega));
",unused,iproute2xenpatch-misc2Fifstat.c
"	if (rates[i] > mega) {
		sprintf(temp, ""%uM"", (unsigned)(rates[i]/mega));
		fprintf(fp, ""%-6s "", temp);
	} else if (rates[i] > kilo) {
		sprintf(temp, ""%uK"", (unsigned)(rates[i]/kilo));
",1,unused,314,unused,"	if (rates[i] > mega) {
		sprintf(temp, ""%uM"", (unsigned)(rates[i]/mega));
		fprintf(fp, ""%-6s "", temp);
	} else if (rates[i] > kilo) {
		sprintf(temp, ""%uK"", (unsigned)(rates[i]/kilo));
",unused,iproute2xenpatch-misc2Fifstat.c
"	else
		fprintf(fp, ""%8llu "", vals[i]);

	if (vals[k] > giga) {
		sprintf(temp, ""%uM"", (unsigned)(vals[k]/mega));
",1,unused,331,unused,"	else
		fprintf(fp, ""%8llu "", vals[i]);

	if (vals[k] > giga) {
		sprintf(temp, ""%uM"", (unsigned)(vals[k]/mega));
",unused,iproute2xenpatch-misc2Fifstat.c
"	if (vals[k] > giga) {
		sprintf(temp, ""%uM"", (unsigned)(vals[k]/mega));
		fprintf(fp, ""%-6s "", temp);
	} else if (vals[k] > mega) {
		sprintf(temp, ""%uK"", (unsigned)(vals[k]/kilo));
",1,unused,334,unused,"	if (vals[k] > giga) {
		sprintf(temp, ""%uM"", (unsigned)(vals[k]/mega));
		fprintf(fp, ""%-6s "", temp);
	} else if (vals[k] > mega) {
		sprintf(temp, ""%uK"", (unsigned)(vals[k]/kilo));
",unused,iproute2xenpatch-misc2Fifstat.c
"	struct pollfd p;
	p.fd = fd;
	p.events = p.revents = POLLIN;

	sprintf(info_source, ""%d.%lu sampling_interval=%d time_const=%d"",
",1,unused,585,unused,"	struct pollfd p;
	p.fd = fd;
	p.events = p.revents = POLLIN;

	sprintf(info_source, ""%d.%lu sampling_interval=%d time_const=%d"",
",unused,iproute2xenpatch-misc2Fifstat.c
"	argv += optind;

	sun.sun_family = AF_UNIX;
	sun.sun_path[0] = 0;
	sprintf(sun.sun_path+1, ""ifstat%d"", getuid());
",1,unused,746,unused,"	argv += optind;

	sun.sun_family = AF_UNIX;
	sun.sun_path[0] = 0;
	sprintf(sun.sun_path+1, ""ifstat%d"", getuid());
",unused,iproute2xenpatch-misc2Fifstat.c
"	}

	if ((fd = socket(AF_UNIX, SOCK_STREAM, 0)) >= 0 &&
	    (connect(fd, (struct sockaddr*)&sun, 2+1+strlen(sun.sun_path+1)) == 0
	     || (strcpy(sun.sun_path+1, ""ifstat0""),
",1,unused,834,unused,"	}

	if ((fd = socket(AF_UNIX, SOCK_STREAM, 0)) >= 0 &&
	    (connect(fd, (struct sockaddr*)&sun, 2+1+strlen(sun.sun_path+1)) == 0
	     || (strcpy(sun.sun_path+1, ""ifstat0""),
",unused,iproute2xenpatch-misc2Fifstat.c
"			info_source[0] = 0;
		}
		load_info();
		if (info_source[0] == 0)
			strcpy(info_source, ""kernel"");
",1,unused,854,unused,"			info_source[0] = 0;
		}
		load_info();
		if (info_source[0] == 0)
			strcpy(info_source, ""kernel"");
",unused,iproute2xenpatch-misc2Fifstat.c
"	/* initialize */
	memset(lf, 0, sizeof(*lf));

	/* de->d_name is guaranteed to be <= NAME_MAX */
	strcpy(lf->basename, file);
",1,unused,185,unused,"	/* initialize */
	memset(lf, 0, sizeof(*lf));

	/* de->d_name is guaranteed to be <= NAME_MAX */
	strcpy(lf->basename, file);
",unused,iproute2xenpatch-misc2Flnstat_util.c
"	memset(lf, 0, sizeof(*lf));

	/* de->d_name is guaranteed to be <= NAME_MAX */
	strcpy(lf->basename, file);
	strcpy(lf->path, path);
",1,unused,186,unused,"	memset(lf, 0, sizeof(*lf));

	/* de->d_name is guaranteed to be <= NAME_MAX */
	strcpy(lf->basename, file);
	strcpy(lf->path, path);
",unused,iproute2xenpatch-misc2Flnstat_util.c
"
	/* de->d_name is guaranteed to be <= NAME_MAX */
	strcpy(lf->basename, file);
	strcpy(lf->path, path);
	strcat(lf->path, ""/"");
",1,unused,187,unused,"
	/* de->d_name is guaranteed to be <= NAME_MAX */
	strcpy(lf->basename, file);
	strcpy(lf->path, path);
	strcat(lf->path, ""/"");
",unused,iproute2xenpatch-misc2Flnstat_util.c
"	/* de->d_name is guaranteed to be <= NAME_MAX */
	strcpy(lf->basename, file);
	strcpy(lf->path, path);
	strcat(lf->path, ""/"");
	strcat(lf->path, lf->basename);
",1,unused,188,unused,"	/* de->d_name is guaranteed to be <= NAME_MAX */
	strcpy(lf->basename, file);
	strcpy(lf->path, path);
	strcat(lf->path, ""/"");
	strcat(lf->path, lf->basename);
",unused,iproute2xenpatch-misc2Flnstat_util.c
"	struct pollfd p;
	p.fd = fd;
	p.events = p.revents = POLLIN;

	sprintf(info_source, ""%d.%lu sampling_interval=%d time_const=%d"",
",1,unused,427,unused,"	struct pollfd p;
	p.fd = fd;
	p.events = p.revents = POLLIN;

	sprintf(info_source, ""%d.%lu sampling_interval=%d time_const=%d"",
",unused,iproute2xenpatch-misc2Fnstat.c
"	argv += optind;

	sun.sun_family = AF_UNIX;
	sun.sun_path[0] = 0;
	sprintf(sun.sun_path+1, ""nstat%d"", getuid());
",1,unused,578,unused,"	argv += optind;

	sun.sun_family = AF_UNIX;
	sun.sun_path[0] = 0;
	sprintf(sun.sun_path+1, ""nstat%d"", getuid());
",unused,iproute2xenpatch-misc2Fnstat.c
"	npatterns = argc;

	if ((hist_name = getenv(""NSTAT_HISTORY"")) == NULL) {
		hist_name = malloc(128);
		sprintf(hist_name, ""/tmp/.nstat.u%d"", getuid());
",1,unused,612,unused,"	npatterns = argc;

	if ((hist_name = getenv(""NSTAT_HISTORY"")) == NULL) {
		hist_name = malloc(128);
		sprintf(hist_name, ""/tmp/.nstat.u%d"", getuid());
",unused,iproute2xenpatch-misc2Fnstat.c
"	}

	if ((fd = socket(AF_UNIX, SOCK_STREAM, 0)) >= 0 &&
	    (connect(fd, (struct sockaddr*)&sun, 2+1+strlen(sun.sun_path+1)) == 0
	     || (strcpy(sun.sun_path+1, ""nstat0""),
",1,unused,664,unused,"	}

	if ((fd = socket(AF_UNIX, SOCK_STREAM, 0)) >= 0 &&
	    (connect(fd, (struct sockaddr*)&sun, 2+1+strlen(sun.sun_path+1)) == 0
	     || (strcpy(sun.sun_path+1, ""nstat0""),
",unused,iproute2xenpatch-misc2Fnstat.c
"		load_netstat();
		load_snmp6();
		load_snmp();
		if (info_source[0] == 0)
			strcpy(info_source, ""kernel"");
",1,unused,686,unused,"		load_netstat();
		load_snmp6();
		load_snmp();
		if (info_source[0] == 0)
			strcpy(info_source, ""kernel"");
",unused,iproute2xenpatch-misc2Fnstat.c
"{
	char temp[64];

	if (rate > 1024*1024) {
		sprintf(temp, ""%uM"", (unsigned)rint(rate/(1024*1024)));
",1,unused,137,unused,"{
	char temp[64];

	if (rate > 1024*1024) {
		sprintf(temp, ""%uM"", (unsigned)rint(rate/(1024*1024)));
",unused,iproute2xenpatch-misc2Frtacct.c
"	if (rate > 1024*1024) {
		sprintf(temp, ""%uM"", (unsigned)rint(rate/(1024*1024)));
		fprintf(fp, "" %-10s"", temp);
	} else if (rate > 1024) {
		sprintf(temp, ""%uK"", (unsigned)rint(rate/1024));
",1,unused,140,unused,"	if (rate > 1024*1024) {
		sprintf(temp, ""%uM"", (unsigned)rint(rate/(1024*1024)));
		fprintf(fp, "" %-10s"", temp);
	} else if (rate > 1024) {
		sprintf(temp, ""%uK"", (unsigned)rint(rate/1024));
",unused,iproute2xenpatch-misc2Frtacct.c
"	struct pollfd p;
	p.fd = fd;
	p.events = p.revents = POLLIN;

	sprintf(kern_db->signature,
",1,unused,370,unused,"	struct pollfd p;
	p.fd = fd;
	p.events = p.revents = POLLIN;

	sprintf(kern_db->signature,
",unused,iproute2xenpatch-misc2Frtacct.c
"	}

	sun.sun_family = AF_UNIX;
	sun.sun_path[0] = 0;
	sprintf(sun.sun_path+1, ""rtacct%d"", getuid());
",1,unused,507,unused,"	}

	sun.sun_family = AF_UNIX;
	sun.sun_path[0] = 0;
	sprintf(sun.sun_path+1, ""rtacct%d"", getuid());
",unused,iproute2xenpatch-misc2Frtacct.c
"
	if (getenv(""RTACCT_HISTORY""))
		snprintf(hist_name, sizeof(hist_name), ""%s"", getenv(""RTACCT_HISTORY""));
	else
		sprintf(hist_name, ""/tmp/.rtacct.u%d"", getuid());
",1,unused,539,unused,"
	if (getenv(""RTACCT_HISTORY""))
		snprintf(hist_name, sizeof(hist_name), ""%s"", getenv(""RTACCT_HISTORY""));
	else
		sprintf(hist_name, ""/tmp/.rtacct.u%d"", getuid());
",unused,iproute2xenpatch-misc2Frtacct.c
"	}

	if ((fd = socket(AF_UNIX, SOCK_STREAM, 0)) >= 0 &&
	    (connect(fd, (struct sockaddr*)&sun, 2+1+strlen(sun.sun_path+1)) == 0
	     || (strcpy(sun.sun_path+1, ""rtacct0""),
",1,unused,600,unused,"	}

	if ((fd = socket(AF_UNIX, SOCK_STREAM, 0)) >= 0 &&
	    (connect(fd, (struct sockaddr*)&sun, 2+1+strlen(sun.sun_path+1)) == 0
	     || (strcpy(sun.sun_path+1, ""rtacct0""),
",unused,iproute2xenpatch-misc2Frtacct.c
"			hist_db = NULL;
		}

		pad_kern_table(kern_db, read_kern_table(kern_db->ival));
		strcpy(kern_db->signature, ""kernel"");
",1,unused,621,unused,"			hist_db = NULL;
		}

		pad_kern_table(kern_db, read_kern_table(kern_db->ival));
		strcpy(kern_db->signature, ""kernel"");
",unused,iproute2xenpatch-misc2Frtacct.c
"	strncpy(name, root, sizeof(name)-1);
	name[sizeof(name)-1] = 0;

	if (strlen(name) == 0 || name[strlen(name)-1] != '/')
		strcat(name, ""/"");
",1,unused,464,unused,"	strncpy(name, root, sizeof(name)-1);
	name[sizeof(name)-1] = 0;

	if (strlen(name) == 0 || name[strlen(name)-1] != '/')
		strcat(name, ""/"");
",unused,iproute2xenpatch-misc2Fss.c
"	}
	if (secs) {
		if (secs > 9)
			msecs = 0;
		sprintf(buf+strlen(buf), ""%d%s"", secs, msecs ? ""."" : ""sec"");
",1,unused,853,unused,"	}
	if (secs) {
		if (secs > 9)
			msecs = 0;
		sprintf(buf+strlen(buf), ""%d%s"", secs, msecs ? ""."" : ""sec"");
",unused,iproute2xenpatch-misc2Fss.c
"			msecs = 0;
		sprintf(buf+strlen(buf), ""%d%s"", secs, msecs ? ""."" : ""sec"");
	}
	if (msecs)
		sprintf(buf+strlen(buf), ""%03dms"", msecs);
",1,unused,856,unused,"			msecs = 0;
		sprintf(buf+strlen(buf), ""%d%s"", secs, msecs ? ""."" : ""sec"");
	}
	if (msecs)
		sprintf(buf+strlen(buf), ""%03dms"", msecs);
",unused,iproute2xenpatch-misc2Fss.c
"	if (c->name)
		return c->name;

do_numeric:
	sprintf(buf, ""%u"", port);
",1,unused,995,unused,"	if (c->name)
		return c->name;

do_numeric:
	sprintf(buf, ""%u"", port);
",unused,iproute2xenpatch-misc2Fss.c
"
static char *sprint_bw(char *buf, double bw)
{
	if (bw > 1000000.)
		sprintf(buf,""%.1fM"", bw / 1000000.);
",1,unused,1641,unused,"
static char *sprint_bw(char *buf, double bw)
{
	if (bw > 1000000.)
		sprintf(buf,""%.1fM"", bw / 1000000.);
",unused,iproute2xenpatch-misc2Fss.c
"{
	if (bw > 1000000.)
		sprintf(buf,""%.1fM"", bw / 1000000.);
	else if (bw > 1000.)
		sprintf(buf,""%.1fK"", bw / 1000.);
",1,unused,1643,unused,"{
	if (bw > 1000000.)
		sprintf(buf,""%.1fM"", bw / 1000000.);
	else if (bw > 1000.)
		sprintf(buf,""%.1fK"", bw / 1000.);
",unused,iproute2xenpatch-misc2Fss.c
"		sprintf(buf,""%.1fM"", bw / 1000000.);
	else if (bw > 1000.)
		sprintf(buf,""%.1fK"", bw / 1000.);
	else
		sprintf(buf, ""%g"", bw);
",1,unused,1645,unused,"		sprintf(buf,""%.1fM"", bw / 1000000.);
	else if (bw > 1000.)
		sprintf(buf,""%.1fK"", bw / 1000.);
	else
		sprintf(buf, ""%g"", bw);
",unused,iproute2xenpatch-misc2Fss.c
"
		if (name[0]) {
			if ((u->name = malloc(strlen(name)+1)) == NULL)
				break;
			strcpy(u->name, name);
",1,unused,2784,unused,"
		if (name[0]) {
			if ((u->name = malloc(strlen(name)+1)) == NULL)
				break;
			strcpy(u->name, name);
",unused,iproute2xenpatch-misc2Fss.c
"				int type = map_type(*p);

				switch (type) {
					case TCF_META_TYPE_INT:
						strcat(buf, ""INT"");
",1,unused,209,unused,"				int type = map_type(*p);

				switch (type) {
					case TCF_META_TYPE_INT:
						strcat(buf, ""INT"");
",unused,iproute2xenpatch-tc2Fem_meta.c
"						strcat(buf, ""INT"");
						break;

					case TCF_META_TYPE_VAR:
						strcat(buf, ""VAR"");
",1,unused,213,unused,"						strcat(buf, ""INT"");
						break;

					case TCF_META_TYPE_VAR:
						strcat(buf, ""VAR"");
",unused,iproute2xenpatch-tc2Fem_meta.c
"						break;
				}

				if (*(++p))
					strcat(buf, "","");
",1,unused,218,unused,"						break;
				}

				if (*(++p))
					strcat(buf, "","");
",unused,iproute2xenpatch-tc2Fem_meta.c
"noexist:
#ifdef CONFIG_GACT
	if (!looked4gact) {
		looked4gact = 1;
		strcpy(str,""gact"");
",1,unused,125,unused,"noexist:
#ifdef CONFIG_GACT
	if (!looked4gact) {
		looked4gact = 1;
		strcpy(str,""gact"");
",unused,iproute2xenpatch-tc2Fm_action.c
"	q = malloc(sizeof(*q));
	if (q) {

		memset(q, 0, sizeof(*q));
		q->id = strcpy(malloc(strlen(str)+1), str);
",1,unused,139,unused,"	q = malloc(sizeof(*q));
	if (q) {

		memset(q, 0, sizeof(*q));
		q->id = strcpy(malloc(strlen(str)+1), str);
",unused,iproute2xenpatch-tc2Ftc.c
"		node = node->parent_node;
	}
	while (node && node->right_node) {
		if (node->hlist.next)
			strcat(buf, ""|    "");
",1,unused,198,unused,"		node = node->parent_node;
	}
	while (node && node->right_node) {
		if (node->hlist.next)
			strcat(buf, ""|    "");
",unused,iproute2xenpatch-tc2Ftc_class.c
"	while (node && node->right_node) {
		if (node->hlist.next)
			strcat(buf, ""|    "");
		else
			strcat(buf, ""     "");
",1,unused,200,unused,"	while (node && node->right_node) {
		if (node->hlist.next)
			strcat(buf, ""|    "");
		else
			strcat(buf, ""     "");
",unused,iproute2xenpatch-tc2Ftc_class.c
"	}

	if (is_newline) {
		if (node->hlist.next && node->nodes_count)
			strcat(buf, ""|    |"");
",1,unused,207,unused,"	}

	if (is_newline) {
		if (node->hlist.next && node->nodes_count)
			strcat(buf, ""|    |"");
",unused,iproute2xenpatch-tc2Ftc_class.c
"	if (is_newline) {
		if (node->hlist.next && node->nodes_count)
			strcat(buf, ""|    |"");
		else if (node->hlist.next)
			strcat(buf, ""|     "");
",1,unused,209,unused,"	if (is_newline) {
		if (node->hlist.next && node->nodes_count)
			strcat(buf, ""|    |"");
		else if (node->hlist.next)
			strcat(buf, ""|     "");
",unused,iproute2xenpatch-tc2Ftc_class.c
"			strcat(buf, ""|    |"");
		else if (node->hlist.next)
			strcat(buf, ""|     "");
		else if (node->nodes_count)
			strcat(buf, ""     |"");
",1,unused,211,unused,"			strcat(buf, ""|    |"");
		else if (node->hlist.next)
			strcat(buf, ""|     "");
		else if (node->nodes_count)
			strcat(buf, ""     |"");
",unused,iproute2xenpatch-tc2Ftc_class.c
"			strcat(buf, ""|     "");
		else if (node->nodes_count)
			strcat(buf, ""     |"");
		else if (!node->hlist.next)
			strcat(buf, ""      "");
",1,unused,213,unused,"			strcat(buf, ""|     "");
		else if (node->nodes_count)
			strcat(buf, ""     |"");
		else if (!node->hlist.next)
			strcat(buf, ""      "");
",unused,iproute2xenpatch-tc2Ftc_class.c
"		else if (!node->hlist.next)
			strcat(buf, ""      "");
	}
	if (add_spaces > 0) {
		sprintf(spaces, ""%-*s"", add_spaces, """");
",1,unused,216,unused,"		else if (!node->hlist.next)
			strcat(buf, ""      "");
	}
	if (add_spaces > 0) {
		sprintf(spaces, ""%-*s"", add_spaces, """");
",unused,iproute2xenpatch-tc2Ftc_class.c
"			strcat(buf, ""      "");
	}
	if (add_spaces > 0) {
		sprintf(spaces, ""%-*s"", add_spaces, """");
		strcat(buf, spaces);
",1,unused,217,unused,"			strcat(buf, ""      "");
	}
	if (add_spaces > 0) {
		sprintf(spaces, ""%-*s"", add_spaces, """");
		strcat(buf, spaces);
",unused,iproute2xenpatch-tc2Ftc_class.c
"
		graph_indent(buf, cls, 0, 0);

		print_tc_classid(cls_id_str, sizeof(cls_id_str), cls->id);
		sprintf(str, ""+---(%s)"", cls_id_str);
",1,unused,251,unused,"
		graph_indent(buf, cls, 0, 0);

		print_tc_classid(cls_id_str, sizeof(cls_id_str), cls->id);
		sprintf(str, ""+---(%s)"", cls_id_str);
",unused,iproute2xenpatch-tc2Ftc_class.c
"		graph_indent(buf, cls, 0, 0);

		print_tc_classid(cls_id_str, sizeof(cls_id_str), cls->id);
		sprintf(str, ""+---(%s)"", cls_id_str);
		strcat(buf, str);
",1,unused,252,unused,"		graph_indent(buf, cls, 0, 0);

		print_tc_classid(cls_id_str, sizeof(cls_id_str), cls->id);
		sprintf(str, ""+---(%s)"", cls_id_str);
		strcat(buf, str);
",unused,iproute2xenpatch-tc2Ftc_class.c
"		parse_rtattr(tb, TCA_MAX, (struct rtattr *)cls->data,
				cls->data_len);

		if (tb[TCA_KIND] == NULL) {
			strcat(buf, "" [unknown qdisc kind] "");
",1,unused,258,unused,"		parse_rtattr(tb, TCA_MAX, (struct rtattr *)cls->data,
				cls->data_len);

		if (tb[TCA_KIND] == NULL) {
			strcat(buf, "" [unknown qdisc kind] "");
",unused,iproute2xenpatch-tc2Ftc_class.c
"			strcat(buf, "" [unknown qdisc kind] "");
		} else {
			const char *kind = rta_getattr_str(tb[TCA_KIND]);

			sprintf(str, "" %s "", kind);
",1,unused,262,unused,"			strcat(buf, "" [unknown qdisc kind] "");
		} else {
			const char *kind = rta_getattr_str(tb[TCA_KIND]);

			sprintf(str, "" %s "", kind);
",unused,iproute2xenpatch-tc2Ftc_class.c
"		} else {
			const char *kind = rta_getattr_str(tb[TCA_KIND]);

			sprintf(str, "" %s "", kind);
			strcat(buf, str);
",1,unused,263,unused,"		} else {
			const char *kind = rta_getattr_str(tb[TCA_KIND]);

			sprintf(str, "" %s "", kind);
			strcat(buf, str);
",unused,iproute2xenpatch-tc2Ftc_class.c
"					print_tcstats_attr(fp, tb, buf, &stats);
					buf[0] = '\0';
				}
				if (cls->hlist.next || cls->nodes_count) {
					strcat(buf, ""\n"");
",1,unused,284,unused,"					print_tcstats_attr(fp, tb, buf, &stats);
					buf[0] = '\0';
				}
				if (cls->hlist.next || cls->nodes_count) {
					strcat(buf, ""\n"");
",unused,iproute2xenpatch-tc2Ftc_class.c
"
		graph_cls_show(fp, buf, &children, level + 1);
		if (!cls->hlist.next) {
			graph_indent(buf, cls, 0, 0);
			strcat(buf, ""\n"");
",1,unused,296,unused,"
		graph_cls_show(fp, buf, &children, level + 1);
		if (!cls->hlist.next) {
			graph_indent(buf, cls, 0, 0);
			strcat(buf, ""\n"");
",unused,iproute2xenpatch-tc2Ftc_class.c
"	SPRINT_BUF(handle) = {};
	int hlen = SPRINT_BSIZE - 1;

	if (h == TC_H_ROOT)
		sprintf(handle, ""root"");
",1,unused,137,unused,"	SPRINT_BUF(handle) = {};
	int hlen = SPRINT_BSIZE - 1;

	if (h == TC_H_ROOT)
		sprintf(handle, ""root"");
",unused,iproute2xenpatch-tc2Ftc_util.c
"
char *sprint_tc_classid(__u32 h, char *buf)
{
	if (print_tc_classid(buf, SPRINT_BSIZE-1, h))
		strcpy(buf, ""???"");
",1,unused,164,unused,"
char *sprint_tc_classid(__u32 h, char *buf)
{
	if (print_tc_classid(buf, SPRINT_BSIZE-1, h))
		strcpy(buf, ""???"");
",unused,iproute2xenpatch-tc2Ftc_util.c
"	const char *bus_name = mnl_attr_get_str(tb[DEVLINK_ATTR_BUS_NAME]);
	const char *dev_name = mnl_attr_get_str(tb[DEVLINK_ATTR_DEV_NAME]);
	char buf[32];

	sprintf(buf, ""%s/%s"", bus_name, dev_name);
",1,unused,1190,unused,"	const char *bus_name = mnl_attr_get_str(tb[DEVLINK_ATTR_BUS_NAME]);
	const char *dev_name = mnl_attr_get_str(tb[DEVLINK_ATTR_DEV_NAME]);
	char buf[32];

	sprintf(buf, ""%s/%s"", bus_name, dev_name);
",unused,iproutenewver-devlink2Fdevlink.c
"
	if (dl->no_nice_names || !try_nice ||
	    ifname_map_rev_lookup(dl, bus_name, dev_name,
				  port_index, &ifname) != 0)
		sprintf(buf, ""%s/%s/%d"", bus_name, dev_name, port_index);
",1,unused,1287,unused,"
	if (dl->no_nice_names || !try_nice ||
	    ifname_map_rev_lookup(dl, bus_name, dev_name,
				  port_index, &ifname) != 0)
		sprintf(buf, ""%s/%s/%d"", bus_name, dev_name, port_index);
",unused,iproutenewver-devlink2Fdevlink.c
"	    ifname_map_rev_lookup(dl, bus_name, dev_name,
				  port_index, &ifname) != 0)
		sprintf(buf, ""%s/%s/%d"", bus_name, dev_name, port_index);
	else
		sprintf(buf, ""%s"", ifname);
",1,unused,1289,unused,"	    ifname_map_rev_lookup(dl, bus_name, dev_name,
				  port_index, &ifname) != 0)
		sprintf(buf, ""%s/%s/%d"", bus_name, dev_name, port_index);
	else
		sprintf(buf, ""%s"", ifname);
",unused,iproutenewver-devlink2Fdevlink.c
"
	jsonw_name(dl->jw, label);
	jsonw_start_object(dl->jw);
	list_for_each_entry(occ_item, list, list) {
		sprintf(buf, ""%u"", occ_item->index);
",1,unused,2279,unused,"
	jsonw_name(dl->jw, label);
	jsonw_start_object(dl->jw);
	list_for_each_entry(occ_item, list, list) {
		sprintf(buf, ""%u"", occ_item->index);
",unused,iproutenewver-devlink2Fdevlink.c
"			continue;
		ip6_tnl_parm_init(&p1, 0);
		if (type == ARPHRD_IP6GRE)
			p1.proto = IPPROTO_GRE;
		strcpy(p1.name, name);
",1,unused,384,unused,"			continue;
		ip6_tnl_parm_init(&p1, 0);
		if (type == ARPHRD_IP6GRE)
			p1.proto = IPPROTO_GRE;
		strcpy(p1.name, name);
",unused,iproutenewver-ip2Fip6tunnel.c
"
		if (s < 0)
			return;

		strcpy(ifr.ifr_name, rta_getattr_str(tb[IFLA_IFNAME]));
",1,unused,176,unused,"
		if (s < 0)
			return;

		strcpy(ifr.ifr_name, rta_getattr_str(tb[IFLA_IFNAME]));
",unused,iproutenewver-ip2Fipaddress.c
"				SPRINT_BUF(b1);
				SPRINT_BUF(b2);
				char msg[64 + sizeof(b1) + sizeof(b2)];

				sprintf(msg,
",1,unused,312,unused,"				SPRINT_BUF(b1);
				SPRINT_BUF(b2);
				char msg[64 + sizeof(b1) + sizeof(b2)];

				sprintf(msg,
",unused,iproutenewver-ip2Fiplink.c
"	if (tb[RTA_SRC])
		len = snprintf(obuf, sizeof(obuf),
			       ""(%s, "", rt_addr_n2a_rta(family, tb[RTA_SRC]));
	else
		len = sprintf(obuf, ""(unknown, "");
",1,unused,123,unused,"	if (tb[RTA_SRC])
		len = snprintf(obuf, sizeof(obuf),
			       ""(%s, "", rt_addr_n2a_rta(family, tb[RTA_SRC]));
	else
		len = sprintf(obuf, ""(unknown, "");
",unused,iproutenewver-ip2Fipmroute.c
"		perror(""malloc"");
		return -ENOMEM;
	}
	c->nsid = nsid;
	strcpy(c->name, name);
",1,unused,185,unused,"		perror(""malloc"");
		return -ENOMEM;
	}
	c->nsid = nsid;
	strcpy(c->name, name);
",unused,iproutenewver-ip2Fipnetns.c
"			continue;
		id = get_netnsid_from_name(entry->d_name);

		if (nsid == id) {
			strcpy(name, entry->d_name);
",1,unused,261,unused,"			continue;
		id = get_netnsid_from_name(entry->d_name);

		if (nsid == id) {
			strcpy(name, entry->d_name);
",unused,iproutenewver-ip2Fipnetns.c
"	strftime(str, sizeof(str), ""%Y-%m-%d %T"", tp);

	return str;
 error:
	strcpy(str, ""(error)"");
",1,unused,337,unused,"	strftime(str, sizeof(str), ""%Y-%m-%d %T"", tp);

	return str;
 error:
	strcpy(str, ""(error)"");
",unused,iproutenewver-ip2Fipntable.c
"		if (nl)
			*nl = '\0';

		if (get_command_name(buf, comm, sizeof(comm)))
			strcpy(comm, ""<terminated?>"");
",1,unused,136,unused,"		if (nl)
			*nl = '\0';

		if (get_command_name(buf, comm, sizeof(comm)))
			strcpy(comm, ""<terminated?>"");
",unused,iproutenewver-ip2Fipvrf.c
"		return -1;
	}

	if (*netns != '\0')
		strcat(netns, ""-ns"");
",1,unused,205,unused,"		return -1;
	}

	if (*netns != '\0')
		strcat(netns, ""-ns"");
",unused,iproutenewver-ip2Fipvrf.c
"
		if (strcmp(pdir, netns) == 0)
			*pdir = '\0';

		strcat(netns, ""/"");
",1,unused,394,unused,"
		if (strcmp(pdir, netns) == 0)
			*pdir = '\0';

		strcat(netns, ""/"");
",unused,iproutenewver-ip2Fipvrf.c
"
	/*
	 * write pid to cgroup.procs making process part of cgroup
	 */
	strcat(path, CGRP_PROC_FILE);
",1,unused,419,unused,"
	/*
	 * write pid to cgroup.procs making process part of cgroup
	 */
	strcat(path, CGRP_PROC_FILE);
",unused,iproutenewver-ip2Fipvrf.c
"		if (t->t_type == proto)
			return t->t_name;
	}

	sprintf(str, ""%u"", proto);
",1,unused,142,unused,"		if (t->t_type == proto)
			return t->t_name;
	}

	sprintf(str, ""%u"", proto);
",unused,iproutenewver-ip2Fipxfrm.c
"		if (t->t_type == type)
			return t->t_name;
	}

	sprintf(str, ""%d"", type);
",1,unused,185,unused,"		if (t->t_type == type)
			return t->t_name;
	}

	sprintf(str, ""%d"", type);
",unused,iproutenewver-ip2Fipxfrm.c
"const char *strxf_mask32(__u32 mask)
{
	static char str[16];

	sprintf(str, ""%.8x"", mask);
",1,unused,207,unused,"const char *strxf_mask32(__u32 mask)
{
	static char str[16];

	sprintf(str, ""%.8x"", mask);
",unused,iproutenewver-ip2Fipxfrm.c
"	static char str[32];

	switch (share) {
	case XFRM_SHARE_ANY:
		strcpy(str, ""any"");
",1,unused,218,unused,"	static char str[32];

	switch (share) {
	case XFRM_SHARE_ANY:
		strcpy(str, ""any"");
",unused,iproutenewver-ip2Fipxfrm.c
"	case XFRM_SHARE_ANY:
		strcpy(str, ""any"");
		break;
	case XFRM_SHARE_SESSION:
		strcpy(str, ""session"");
",1,unused,221,unused,"	case XFRM_SHARE_ANY:
		strcpy(str, ""any"");
		break;
	case XFRM_SHARE_SESSION:
		strcpy(str, ""session"");
",unused,iproutenewver-ip2Fipxfrm.c
"	case XFRM_SHARE_SESSION:
		strcpy(str, ""session"");
		break;
	case XFRM_SHARE_USER:
		strcpy(str, ""user"");
",1,unused,224,unused,"	case XFRM_SHARE_SESSION:
		strcpy(str, ""session"");
		break;
	case XFRM_SHARE_USER:
		strcpy(str, ""user"");
",unused,iproutenewver-ip2Fipxfrm.c
"	case XFRM_SHARE_USER:
		strcpy(str, ""user"");
		break;
	case XFRM_SHARE_UNIQUE:
		strcpy(str, ""unique"");
",1,unused,227,unused,"	case XFRM_SHARE_USER:
		strcpy(str, ""user"");
		break;
	case XFRM_SHARE_UNIQUE:
		strcpy(str, ""unique"");
",unused,iproutenewver-ip2Fipxfrm.c
"	case XFRM_SHARE_UNIQUE:
		strcpy(str, ""unique"");
		break;
	default:
		sprintf(str, ""%u"", share);
",1,unused,230,unused,"	case XFRM_SHARE_UNIQUE:
		strcpy(str, ""unique"");
		break;
	default:
		sprintf(str, ""%u"", share);
",unused,iproutenewver-ip2Fipxfrm.c
"	pp = getprotobynumber(proto);
	if (pp)
		p = pp->p_name;
	else {
		sprintf(buf, ""%u"", proto);
",1,unused,247,unused,"	pp = getprotobynumber(proto);
	if (pp)
		p = pp->p_name;
	else {
		sprintf(buf, ""%u"", proto);
",unused,iproutenewver-ip2Fipxfrm.c
"	static char str[16];

	switch (ptype) {
	case XFRM_POLICY_TYPE_MAIN:
		strcpy(str, ""main"");
",1,unused,260,unused,"	static char str[16];

	switch (ptype) {
	case XFRM_POLICY_TYPE_MAIN:
		strcpy(str, ""main"");
",unused,iproutenewver-ip2Fipxfrm.c
"	case XFRM_POLICY_TYPE_MAIN:
		strcpy(str, ""main"");
		break;
	case XFRM_POLICY_TYPE_SUB:
		strcpy(str, ""sub"");
",1,unused,263,unused,"	case XFRM_POLICY_TYPE_MAIN:
		strcpy(str, ""main"");
		break;
	case XFRM_POLICY_TYPE_SUB:
		strcpy(str, ""sub"");
",unused,iproutenewver-ip2Fipxfrm.c
"	case XFRM_POLICY_TYPE_SUB:
		strcpy(str, ""sub"");
		break;
	default:
		sprintf(str, ""%u"", ptype);
",1,unused,266,unused,"	case XFRM_POLICY_TYPE_SUB:
		strcpy(str, ""sub"");
		break;
	default:
		sprintf(str, ""%u"", ptype);
",unused,iproutenewver-ip2Fipxfrm.c
"{
	static char str[32];

	if (limit == XFRM_INF)
		strcpy(str, ""(INF)"");
",1,unused,333,unused,"{
	static char str[32];

	if (limit == XFRM_INF)
		strcpy(str, ""(INF)"");
",unused,iproutenewver-ip2Fipxfrm.c
"
	if (limit == XFRM_INF)
		strcpy(str, ""(INF)"");
	else
		sprintf(str, ""%llu"", (unsigned long long) limit);
",1,unused,335,unused,"
	if (limit == XFRM_INF)
		strcpy(str, ""(INF)"");
	else
		sprintf(str, ""%llu"", (unsigned long long) limit);
",unused,iproutenewver-ip2Fipxfrm.c
"{
	static char str[32];

	if (time == 0)
		strcpy(str, ""-"");
",1,unused,357,unused,"{
	static char str[32];

	if (time == 0)
		strcpy(str, ""-"");
",unused,iproutenewver-ip2Fipxfrm.c
"		if (max > 16)
			max = 16;
		cookie[0] = 0;
		for (i = 0; i < max; i++)
			sprintf(cookie + i + i, ""%02x"", ptr[i]);
",1,unused,291,unused,"		if (max > 16)
			max = 16;
		cookie[0] = 0;
		for (i = 0; i < max; i++)
			sprintf(cookie + i + i, ""%02x"", ptr[i]);
",unused,iproutenewver-ip2Ftcp_metrics.c
"	im = malloc(sizeof(*im) + strlen(ifname) + 1);
	if (im == NULL)
		return 0;
	im->index = ifi->ifi_index;
	strcpy(im->name, ifname);
",1,unused,126,unused,"	im = malloc(sizeof(*im) + strlen(ifname) + 1);
	if (im == NULL)
		return 0;
	im->index = ifi->ifi_index;
	strcpy(im->name, ifname);
",unused,iproutenewver-lib2Fll_map.c
"		} else if (sscanf(p, ""0x%x %s\n"", id, name) != 2 &&
				sscanf(p, ""0x%x %s #"", id, name) != 2 &&
				sscanf(p, ""%d %s\n"", id, name) != 2 &&
				sscanf(p, ""%d %s #"", id, name) != 2) {
			strcpy(name, p);
",1,unused,44,unused,"		} else if (sscanf(p, ""0x%x %s\n"", id, name) != 2 &&
				sscanf(p, ""0x%x %s #"", id, name) != 2 &&
				sscanf(p, ""%d %s\n"", id, name) != 2 &&
				sscanf(p, ""%d %s #"", id, name) != 2) {
			strcpy(name, p);
",unused,iproutenewver-lib2Fnames.c
"		if (sscanf(p, ""0x%x %s\n"", id, namebuf) != 2 &&
				sscanf(p, ""0x%x %s #"", id, namebuf) != 2 &&
				sscanf(p, ""%d %s\n"", id, namebuf) != 2 &&
				sscanf(p, ""%d %s #"", id, namebuf) != 2) {
			strcpy(namebuf, p);
",1,unused,53,unused,"		if (sscanf(p, ""0x%x %s\n"", id, namebuf) != 2 &&
				sscanf(p, ""0x%x %s #"", id, namebuf) != 2 &&
				sscanf(p, ""%d %s\n"", id, namebuf) != 2 &&
				sscanf(p, ""%d %s #"", id, namebuf) != 2) {
			strcpy(namebuf, p);
",unused,iproutenewver-lib2Frt_names.c
"	else if (getenv(""PROC_ROOT""))
		snprintf(name, sizeof(name)-1,
			 ""%s/net/psched"", getenv(""PROC_ROOT""));
	else
		strcpy(name, ""/proc/net/psched"");
",1,unused,855,unused,"	else if (getenv(""PROC_ROOT""))
		snprintf(name, sizeof(name)-1,
			 ""%s/net/psched"", getenv(""PROC_ROOT""));
	else
		strcpy(name, ""/proc/net/psched"");
",unused,iproutenewver-lib2Futils.c
"
	for (i = 0; i < len; i++) {
		if (blen < 3)
			break;
		sprintf(ptr, ""%02x"", str[i]);
",1,unused,1039,unused,"
	for (i = 0; i < len; i++) {
		if (blen < 3)
			break;
		sprintf(ptr, ""%02x"", str[i]);
",unused,iproutenewver-lib2Futils.c
"			*lenp = 0;
			return -1;
		}
		cc += cc1 - 2;
		strcat(*linep, line1);
",1,unused,1200,unused,"			*lenp = 0;
			return -1;
		}
		cc += cc1 - 2;
		strcat(*linep, line1);
",unused,iproutenewver-lib2Futils.c
"}

char *int_to_str(int val, char *buf)
{
	sprintf(buf, ""%d"", val);
",1,unused,1301,unused,"}

char *int_to_str(int val, char *buf)
{
	sprintf(buf, ""%d"", val);
",unused,iproutenewver-lib2Futils.c
"		char buf[128];
		FILE *fp;

		if (active_probing) {
			sprintf(buf, ""/proc/sys/net/ipv4/neigh/%s/mcast_solicit"", ifnames[i]);
",1,unused,127,unused,"		char buf[128];
		FILE *fp;

		if (active_probing) {
			sprintf(buf, ""/proc/sys/net/ipv4/neigh/%s/mcast_solicit"", ifnames[i]);
",unused,iproutenewver-misc2Farpd.c
"		if (active_probing) {
			sprintf(buf, ""/proc/sys/net/ipv4/neigh/%s/mcast_solicit"", ifnames[i]);
			if ((fp = fopen(buf, ""w"")) != NULL) {
				if (no_kernel_broadcasts)
					strcpy(buf, ""0\n"");
",1,unused,130,unused,"		if (active_probing) {
			sprintf(buf, ""/proc/sys/net/ipv4/neigh/%s/mcast_solicit"", ifnames[i]);
			if ((fp = fopen(buf, ""w"")) != NULL) {
				if (no_kernel_broadcasts)
					strcpy(buf, ""0\n"");
",unused,iproutenewver-misc2Farpd.c
"			if ((fp = fopen(buf, ""w"")) != NULL) {
				if (no_kernel_broadcasts)
					strcpy(buf, ""0\n"");
				else
					sprintf(buf, ""%d\n"", active_probing >= 2 ? 1 : 3-active_probing);
",1,unused,132,unused,"			if ((fp = fopen(buf, ""w"")) != NULL) {
				if (no_kernel_broadcasts)
					strcpy(buf, ""0\n"");
				else
					sprintf(buf, ""%d\n"", active_probing >= 2 ? 1 : 3-active_probing);
",unused,iproutenewver-misc2Farpd.c
"				fclose(fp);
			}
		}

		sprintf(buf, ""/proc/sys/net/ipv4/neigh/%s/app_solicit"", ifnames[i]);
",1,unused,138,unused,"				fclose(fp);
			}
		}

		sprintf(buf, ""/proc/sys/net/ipv4/neigh/%s/app_solicit"", ifnames[i]);
",unused,iproutenewver-misc2Farpd.c
"		}

		sprintf(buf, ""/proc/sys/net/ipv4/neigh/%s/app_solicit"", ifnames[i]);
		if ((fp = fopen(buf, ""w"")) != NULL) {
			sprintf(buf, ""%d\n"", active_probing <= 1 ? 1 : active_probing);
",1,unused,140,unused,"		}

		sprintf(buf, ""/proc/sys/net/ipv4/neigh/%s/app_solicit"", ifnames[i]);
		if ((fp = fopen(buf, ""w"")) != NULL) {
			sprintf(buf, ""%d\n"", active_probing <= 1 ? 1 : active_probing);
",unused,iproutenewver-misc2Farpd.c
"		char buf[128];
		FILE *fp;

		if (active_probing) {
			sprintf(buf, ""/proc/sys/net/ipv4/neigh/%s/mcast_solicit"", ifnames[i]);
",1,unused,160,unused,"		char buf[128];
		FILE *fp;

		if (active_probing) {
			sprintf(buf, ""/proc/sys/net/ipv4/neigh/%s/mcast_solicit"", ifnames[i]);
",unused,iproutenewver-misc2Farpd.c
"
		if (active_probing) {
			sprintf(buf, ""/proc/sys/net/ipv4/neigh/%s/mcast_solicit"", ifnames[i]);
			if ((fp = fopen(buf, ""w"")) != NULL) {
				strcpy(buf, ""3\n"");
",1,unused,162,unused,"
		if (active_probing) {
			sprintf(buf, ""/proc/sys/net/ipv4/neigh/%s/mcast_solicit"", ifnames[i]);
			if ((fp = fopen(buf, ""w"")) != NULL) {
				strcpy(buf, ""3\n"");
",unused,iproutenewver-misc2Farpd.c
"				fputs(buf, fp);
				fclose(fp);
			}
		}
		sprintf(buf, ""/proc/sys/net/ipv4/neigh/%s/app_solicit"", ifnames[i]);
",1,unused,167,unused,"				fputs(buf, fp);
				fclose(fp);
			}
		}
		sprintf(buf, ""/proc/sys/net/ipv4/neigh/%s/app_solicit"", ifnames[i]);
",unused,iproutenewver-misc2Farpd.c
"			}
		}
		sprintf(buf, ""/proc/sys/net/ipv4/neigh/%s/app_solicit"", ifnames[i]);
		if ((fp = fopen(buf, ""w"")) != NULL) {
			strcpy(buf, ""0\n"");
",1,unused,169,unused,"			}
		}
		sprintf(buf, ""/proc/sys/net/ipv4/neigh/%s/app_solicit"", ifnames[i]);
		if ((fp = fopen(buf, ""w"")) != NULL) {
			strcpy(buf, ""0\n"");
",unused,iproutenewver-misc2Farpd.c
"	else
		fprintf(fp, ""%8llu "", vals[i]);

	if (rates[i] > mega) {
		sprintf(temp, ""%uM"", (unsigned int)(rates[i]/mega));
",1,unused,381,unused,"	else
		fprintf(fp, ""%8llu "", vals[i]);

	if (rates[i] > mega) {
		sprintf(temp, ""%uM"", (unsigned int)(rates[i]/mega));
",unused,iproutenewver-misc2Fifstat.c
"	if (rates[i] > mega) {
		sprintf(temp, ""%uM"", (unsigned int)(rates[i]/mega));
		fprintf(fp, ""%-6s "", temp);
	} else if (rates[i] > kilo) {
		sprintf(temp, ""%uK"", (unsigned int)(rates[i]/kilo));
",1,unused,384,unused,"	if (rates[i] > mega) {
		sprintf(temp, ""%uM"", (unsigned int)(rates[i]/mega));
		fprintf(fp, ""%-6s "", temp);
	} else if (rates[i] > kilo) {
		sprintf(temp, ""%uK"", (unsigned int)(rates[i]/kilo));
",unused,iproutenewver-misc2Fifstat.c
"	else
		fprintf(fp, ""%8llu "", vals[i]);

	if (vals[k] > giga) {
		sprintf(temp, ""%uM"", (unsigned int)(vals[k]/mega));
",1,unused,402,unused,"	else
		fprintf(fp, ""%8llu "", vals[i]);

	if (vals[k] > giga) {
		sprintf(temp, ""%uM"", (unsigned int)(vals[k]/mega));
",unused,iproutenewver-misc2Fifstat.c
"	if (vals[k] > giga) {
		sprintf(temp, ""%uM"", (unsigned int)(vals[k]/mega));
		fprintf(fp, ""%-6s "", temp);
	} else if (vals[k] > mega) {
		sprintf(temp, ""%uK"", (unsigned int)(vals[k]/kilo));
",1,unused,405,unused,"	if (vals[k] > giga) {
		sprintf(temp, ""%uM"", (unsigned int)(vals[k]/mega));
		fprintf(fp, ""%-6s "", temp);
	} else if (vals[k] > mega) {
		sprintf(temp, ""%uK"", (unsigned int)(vals[k]/kilo));
",unused,iproutenewver-misc2Fifstat.c
"
	p.fd = fd;
	p.events = p.revents = POLLIN;

	sprintf(info_source, ""%d.%lu sampling_interval=%d time_const=%d"",
",1,unused,677,unused,"
	p.fd = fd;
	p.events = p.revents = POLLIN;

	sprintf(info_source, ""%d.%lu sampling_interval=%d time_const=%d"",
",unused,iproutenewver-misc2Fifstat.c
"	}

	sun.sun_family = AF_UNIX;
	sun.sun_path[0] = 0;
	sprintf(sun.sun_path+1, ""ifstat%d"", getuid());
",1,unused,895,unused,"	}

	sun.sun_family = AF_UNIX;
	sun.sun_path[0] = 0;
	sprintf(sun.sun_path+1, ""ifstat%d"", getuid());
",unused,iproutenewver-misc2Fifstat.c
"	}

	if ((fd = socket(AF_UNIX, SOCK_STREAM, 0)) >= 0 &&
	    (connect(fd, (struct sockaddr *)&sun, 2+1+strlen(sun.sun_path+1)) == 0
	     || (strcpy(sun.sun_path+1, ""ifstat0""),
",1,unused,990,unused,"	}

	if ((fd = socket(AF_UNIX, SOCK_STREAM, 0)) >= 0 &&
	    (connect(fd, (struct sockaddr *)&sun, 2+1+strlen(sun.sun_path+1)) == 0
	     || (strcpy(sun.sun_path+1, ""ifstat0""),
",unused,iproutenewver-misc2Fifstat.c
"			info_source[0] = 0;
		}
		load_info();
		if (info_source[0] == 0)
			strcpy(info_source, ""kernel"");
",1,unused,1017,unused,"			info_source[0] = 0;
		}
		load_info();
		if (info_source[0] == 0)
			strcpy(info_source, ""kernel"");
",unused,iproutenewver-misc2Fifstat.c
"
	p.fd = fd;
	p.events = p.revents = POLLIN;

	sprintf(info_source, ""%d.%lu sampling_interval=%d time_const=%d"",
",1,unused,463,unused,"
	p.fd = fd;
	p.events = p.revents = POLLIN;

	sprintf(info_source, ""%d.%lu sampling_interval=%d time_const=%d"",
",unused,iproutenewver-misc2Fnstat.c
"	argv += optind;

	sun.sun_family = AF_UNIX;
	sun.sun_path[0] = 0;
	sprintf(sun.sun_path+1, ""nstat%d"", getuid());
",1,unused,616,unused,"	argv += optind;

	sun.sun_family = AF_UNIX;
	sun.sun_path[0] = 0;
	sprintf(sun.sun_path+1, ""nstat%d"", getuid());
",unused,iproutenewver-misc2Fnstat.c
"	npatterns = argc;

	if ((hist_name = getenv(""NSTAT_HISTORY"")) == NULL) {
		hist_name = malloc(128);
		sprintf(hist_name, ""/tmp/.nstat.u%d"", getuid());
",1,unused,650,unused,"	npatterns = argc;

	if ((hist_name = getenv(""NSTAT_HISTORY"")) == NULL) {
		hist_name = malloc(128);
		sprintf(hist_name, ""/tmp/.nstat.u%d"", getuid());
",unused,iproutenewver-misc2Fnstat.c
"	}

	if ((fd = socket(AF_UNIX, SOCK_STREAM, 0)) >= 0 &&
	    (connect(fd, (struct sockaddr *)&sun, 2+1+strlen(sun.sun_path+1)) == 0
	     || (strcpy(sun.sun_path+1, ""nstat0""),
",1,unused,704,unused,"	}

	if ((fd = socket(AF_UNIX, SOCK_STREAM, 0)) >= 0 &&
	    (connect(fd, (struct sockaddr *)&sun, 2+1+strlen(sun.sun_path+1)) == 0
	     || (strcpy(sun.sun_path+1, ""nstat0""),
",unused,iproutenewver-misc2Fnstat.c
"		load_snmp6();
		load_snmp();
		load_sctp_snmp();
		if (info_source[0] == 0)
			strcpy(info_source, ""kernel"");
",1,unused,734,unused,"		load_snmp6();
		load_snmp();
		load_sctp_snmp();
		if (info_source[0] == 0)
			strcpy(info_source, ""kernel"");
",unused,iproutenewver-misc2Fnstat.c
"{
	char temp[64];

	if (rate > 1024*1024) {
		sprintf(temp, ""%uM"", (unsigned int)rint(rate/(1024*1024)));
",1,unused,138,unused,"{
	char temp[64];

	if (rate > 1024*1024) {
		sprintf(temp, ""%uM"", (unsigned int)rint(rate/(1024*1024)));
",unused,iproutenewver-misc2Frtacct.c
"	if (rate > 1024*1024) {
		sprintf(temp, ""%uM"", (unsigned int)rint(rate/(1024*1024)));
		fprintf(fp, "" %-10s"", temp);
	} else if (rate > 1024) {
		sprintf(temp, ""%uK"", (unsigned int)rint(rate/1024));
",1,unused,141,unused,"	if (rate > 1024*1024) {
		sprintf(temp, ""%uM"", (unsigned int)rint(rate/(1024*1024)));
		fprintf(fp, "" %-10s"", temp);
	} else if (rate > 1024) {
		sprintf(temp, ""%uK"", (unsigned int)rint(rate/1024));
",unused,iproutenewver-misc2Frtacct.c
"
	p.fd = fd;
	p.events = p.revents = POLLIN;

	sprintf(kern_db->signature,
",1,unused,363,unused,"
	p.fd = fd;
	p.events = p.revents = POLLIN;

	sprintf(kern_db->signature,
",unused,iproutenewver-misc2Frtacct.c
"	}

	sun.sun_family = AF_UNIX;
	sun.sun_path[0] = 0;
	sprintf(sun.sun_path+1, ""rtacct%d"", getuid());
",1,unused,504,unused,"	}

	sun.sun_family = AF_UNIX;
	sun.sun_path[0] = 0;
	sprintf(sun.sun_path+1, ""rtacct%d"", getuid());
",unused,iproutenewver-misc2Frtacct.c
"
	if (getenv(""RTACCT_HISTORY""))
		snprintf(hist_name, sizeof(hist_name), ""%s"", getenv(""RTACCT_HISTORY""));
	else
		sprintf(hist_name, ""/tmp/.rtacct.u%d"", getuid());
",1,unused,536,unused,"
	if (getenv(""RTACCT_HISTORY""))
		snprintf(hist_name, sizeof(hist_name), ""%s"", getenv(""RTACCT_HISTORY""));
	else
		sprintf(hist_name, ""/tmp/.rtacct.u%d"", getuid());
",unused,iproutenewver-misc2Frtacct.c
"	}

	if ((fd = socket(AF_UNIX, SOCK_STREAM, 0)) >= 0 &&
	    (connect(fd, (struct sockaddr *)&sun, 2+1+strlen(sun.sun_path+1)) == 0
	     || (strcpy(sun.sun_path+1, ""rtacct0""),
",1,unused,598,unused,"	}

	if ((fd = socket(AF_UNIX, SOCK_STREAM, 0)) >= 0 &&
	    (connect(fd, (struct sockaddr *)&sun, 2+1+strlen(sun.sun_path+1)) == 0
	     || (strcpy(sun.sun_path+1, ""rtacct0""),
",unused,iproutenewver-misc2Frtacct.c
"			hist_db = NULL;
		}

		pad_kern_table(kern_db, read_kern_table(kern_db->ival));
		strcpy(kern_db->signature, ""kernel"");
",1,unused,619,unused,"			hist_db = NULL;
		}

		pad_kern_table(kern_db, read_kern_table(kern_db->ival));
		strcpy(kern_db->signature, ""kernel"");
",unused,iproutenewver-misc2Frtacct.c
"
	strlcpy(name, root, sizeof(name));

	if (strlen(name) == 0 || name[strlen(name)-1] != '/')
		strcat(name, ""/"");
",1,unused,513,unused,"
	strlcpy(name, root, sizeof(name));

	if (strlen(name) == 0 || name[strlen(name)-1] != '/')
		strcat(name, ""/"");
",unused,iproutenewver-misc2Fss.c
"	}
	if (secs) {
		if (secs > 9)
			msecs = 0;
		sprintf(buf+strlen(buf), ""%d%s"", secs, msecs ? ""."" : ""sec"");
",1,unused,1344,unused,"	}
	if (secs) {
		if (secs > 9)
			msecs = 0;
		sprintf(buf+strlen(buf), ""%d%s"", secs, msecs ? ""."" : ""sec"");
",unused,iproutenewver-misc2Fss.c
"			msecs = 0;
		sprintf(buf+strlen(buf), ""%d%s"", secs, msecs ? ""."" : ""sec"");
	}
	if (msecs)
		sprintf(buf+strlen(buf), ""%03dms"", msecs);
",1,unused,1347,unused,"			msecs = 0;
		sprintf(buf+strlen(buf), ""%d%s"", secs, msecs ? ""."" : ""sec"");
	}
	if (msecs)
		sprintf(buf+strlen(buf), ""%03dms"", msecs);
",unused,iproutenewver-misc2Fss.c
"	if (c->name)
		return c->name;

do_numeric:
	sprintf(buf, ""%u"", port);
",1,unused,1494,unused,"	if (c->name)
		return c->name;

do_numeric:
	sprintf(buf, ""%u"", port);
",unused,iproutenewver-misc2Fss.c
"
static char *sprint_bw(char *buf, double bw)
{
	if (bw > 1000000.)
		sprintf(buf, ""%.1fM"", bw / 1000000.);
",1,unused,2274,unused,"
static char *sprint_bw(char *buf, double bw)
{
	if (bw > 1000000.)
		sprintf(buf, ""%.1fM"", bw / 1000000.);
",unused,iproutenewver-misc2Fss.c
"{
	if (bw > 1000000.)
		sprintf(buf, ""%.1fM"", bw / 1000000.);
	else if (bw > 1000.)
		sprintf(buf, ""%.1fK"", bw / 1000.);
",1,unused,2276,unused,"{
	if (bw > 1000000.)
		sprintf(buf, ""%.1fM"", bw / 1000000.);
	else if (bw > 1000.)
		sprintf(buf, ""%.1fK"", bw / 1000.);
",unused,iproutenewver-misc2Fss.c
"		sprintf(buf, ""%.1fM"", bw / 1000000.);
	else if (bw > 1000.)
		sprintf(buf, ""%.1fK"", bw / 1000.);
	else
		sprintf(buf, ""%g"", bw);
",1,unused,2278,unused,"		sprintf(buf, ""%.1fM"", bw / 1000000.);
	else if (bw > 1000.)
		sprintf(buf, ""%.1fK"", bw / 1000.);
	else
		sprintf(buf, ""%g"", bw);
",unused,iproutenewver-misc2Fss.c
"				int type = map_type(*p);

				switch (type) {
					case TCF_META_TYPE_INT:
						strcat(buf, ""INT"");
",1,unused,209,unused,"				int type = map_type(*p);

				switch (type) {
					case TCF_META_TYPE_INT:
						strcat(buf, ""INT"");
",unused,iproutenewver-tc2Fem_meta.c
"						strcat(buf, ""INT"");
						break;

					case TCF_META_TYPE_VAR:
						strcat(buf, ""VAR"");
",1,unused,213,unused,"						strcat(buf, ""INT"");
						break;

					case TCF_META_TYPE_VAR:
						strcat(buf, ""VAR"");
",unused,iproutenewver-tc2Fem_meta.c
"						break;
				}

				if (*(++p))
					strcat(buf, "","");
",1,unused,218,unused,"						break;
				}

				if (*(++p))
					strcat(buf, "","");
",unused,iproutenewver-tc2Fem_meta.c
"	int bits;

	if (!addr_attr || RTA_PAYLOAD(addr_attr) != ETH_ALEN)
		return;
	done = sprintf(out, ""%s"",
",1,unused,1051,unused,"	int bits;

	if (!addr_attr || RTA_PAYLOAD(addr_attr) != ETH_ALEN)
		return;
	done = sprintf(out, ""%s"",
",unused,iproutenewver-tc2Ff_flower.c
"				   0, b1, sizeof(b1)));
	if (mask_attr && RTA_PAYLOAD(mask_attr) == ETH_ALEN) {
		bits = __mask_bits(RTA_DATA(mask_attr), ETH_ALEN);
		if (bits < 0)
			sprintf(out + done, ""/%s"",
",1,unused,1057,unused,"				   0, b1, sizeof(b1)));
	if (mask_attr && RTA_PAYLOAD(mask_attr) == ETH_ALEN) {
		bits = __mask_bits(RTA_DATA(mask_attr), ETH_ALEN);
		if (bits < 0)
			sprintf(out + done, ""/%s"",
",unused,iproutenewver-tc2Ff_flower.c
"			sprintf(out + done, ""/%s"",
				ll_addr_n2a(RTA_DATA(mask_attr), ETH_ALEN,
					    0, b1, sizeof(b1)));
		else if (bits < ETH_ALEN * 8)
			sprintf(out + done, ""/%d"", bits);
",1,unused,1061,unused,"			sprintf(out + done, ""/%s"",
				ll_addr_n2a(RTA_DATA(mask_attr), ETH_ALEN,
					    0, b1, sizeof(b1)));
		else if (bits < ETH_ALEN * 8)
			sprintf(out + done, ""/%d"", bits);
",unused,iproutenewver-tc2Ff_flower.c
"		else if (bits < ETH_ALEN * 8)
			sprintf(out + done, ""/%d"", bits);
	}

	sprintf(namefrm, ""\n  %s %%s"", name);
",1,unused,1064,unused,"		else if (bits < ETH_ALEN * 8)
			sprintf(out + done, ""/%d"", bits);
	}

	sprintf(namefrm, ""\n  %s %%s"", name);
",unused,iproutenewver-tc2Ff_flower.c
"		return;

	eth_type = rta_getattr_u16(eth_type_attr);
	if (eth_type == htons(ETH_P_IP))
		sprintf(out, ""ipv4"");
",1,unused,1079,unused,"		return;

	eth_type = rta_getattr_u16(eth_type_attr);
	if (eth_type == htons(ETH_P_IP))
		sprintf(out, ""ipv4"");
",unused,iproutenewver-tc2Ff_flower.c
"	eth_type = rta_getattr_u16(eth_type_attr);
	if (eth_type == htons(ETH_P_IP))
		sprintf(out, ""ipv4"");
	else if (eth_type == htons(ETH_P_IPV6))
		sprintf(out, ""ipv6"");
",1,unused,1081,unused,"	eth_type = rta_getattr_u16(eth_type_attr);
	if (eth_type == htons(ETH_P_IP))
		sprintf(out, ""ipv4"");
	else if (eth_type == htons(ETH_P_IPV6))
		sprintf(out, ""ipv6"");
",unused,iproutenewver-tc2Ff_flower.c
"		sprintf(out, ""ipv4"");
	else if (eth_type == htons(ETH_P_IPV6))
		sprintf(out, ""ipv6"");
	else if (eth_type == htons(ETH_P_ARP))
		sprintf(out, ""arp"");
",1,unused,1083,unused,"		sprintf(out, ""ipv4"");
	else if (eth_type == htons(ETH_P_IPV6))
		sprintf(out, ""ipv6"");
	else if (eth_type == htons(ETH_P_ARP))
		sprintf(out, ""arp"");
",unused,iproutenewver-tc2Ff_flower.c
"		sprintf(out, ""ipv6"");
	else if (eth_type == htons(ETH_P_ARP))
		sprintf(out, ""arp"");
	else if (eth_type == htons(ETH_P_RARP))
		sprintf(out, ""rarp"");
",1,unused,1085,unused,"		sprintf(out, ""ipv6"");
	else if (eth_type == htons(ETH_P_ARP))
		sprintf(out, ""arp"");
	else if (eth_type == htons(ETH_P_RARP))
		sprintf(out, ""rarp"");
",unused,iproutenewver-tc2Ff_flower.c
"		sprintf(out, ""arp"");
	else if (eth_type == htons(ETH_P_RARP))
		sprintf(out, ""rarp"");
	else
		sprintf(out, ""%04x"", ntohs(eth_type));
",1,unused,1087,unused,"		sprintf(out, ""arp"");
	else if (eth_type == htons(ETH_P_RARP))
		sprintf(out, ""rarp"");
	else
		sprintf(out, ""%04x"", ntohs(eth_type));
",unused,iproutenewver-tc2Ff_flower.c
"		return;

	ip_proto = rta_getattr_u8(ip_proto_attr);
	if (ip_proto == IPPROTO_TCP)
		sprintf(out, ""tcp"");
",1,unused,1104,unused,"		return;

	ip_proto = rta_getattr_u8(ip_proto_attr);
	if (ip_proto == IPPROTO_TCP)
		sprintf(out, ""tcp"");
",unused,iproutenewver-tc2Ff_flower.c
"	ip_proto = rta_getattr_u8(ip_proto_attr);
	if (ip_proto == IPPROTO_TCP)
		sprintf(out, ""tcp"");
	else if (ip_proto == IPPROTO_UDP)
		sprintf(out, ""udp"");
",1,unused,1106,unused,"	ip_proto = rta_getattr_u8(ip_proto_attr);
	if (ip_proto == IPPROTO_TCP)
		sprintf(out, ""tcp"");
	else if (ip_proto == IPPROTO_UDP)
		sprintf(out, ""udp"");
",unused,iproutenewver-tc2Ff_flower.c
"		sprintf(out, ""tcp"");
	else if (ip_proto == IPPROTO_UDP)
		sprintf(out, ""udp"");
	else if (ip_proto == IPPROTO_SCTP)
		sprintf(out, ""sctp"");
",1,unused,1108,unused,"		sprintf(out, ""tcp"");
	else if (ip_proto == IPPROTO_UDP)
		sprintf(out, ""udp"");
	else if (ip_proto == IPPROTO_SCTP)
		sprintf(out, ""sctp"");
",unused,iproutenewver-tc2Ff_flower.c
"		sprintf(out, ""udp"");
	else if (ip_proto == IPPROTO_SCTP)
		sprintf(out, ""sctp"");
	else if (ip_proto == IPPROTO_ICMP)
		sprintf(out, ""icmp"");
",1,unused,1110,unused,"		sprintf(out, ""udp"");
	else if (ip_proto == IPPROTO_SCTP)
		sprintf(out, ""sctp"");
	else if (ip_proto == IPPROTO_ICMP)
		sprintf(out, ""icmp"");
",unused,iproutenewver-tc2Ff_flower.c
"		sprintf(out, ""sctp"");
	else if (ip_proto == IPPROTO_ICMP)
		sprintf(out, ""icmp"");
	else if (ip_proto == IPPROTO_ICMPV6)
		sprintf(out, ""icmpv6"");
",1,unused,1112,unused,"		sprintf(out, ""sctp"");
	else if (ip_proto == IPPROTO_ICMP)
		sprintf(out, ""icmp"");
	else if (ip_proto == IPPROTO_ICMPV6)
		sprintf(out, ""icmpv6"");
",unused,iproutenewver-tc2Ff_flower.c
"		sprintf(out, ""icmp"");
	else if (ip_proto == IPPROTO_ICMPV6)
		sprintf(out, ""icmpv6"");
	else
		sprintf(out, ""%02x"", ip_proto);
",1,unused,1114,unused,"		sprintf(out, ""icmp"");
	else if (ip_proto == IPPROTO_ICMPV6)
		sprintf(out, ""icmpv6"");
	else
		sprintf(out, ""%02x"", ip_proto);
",unused,iproutenewver-tc2Ff_flower.c
"
	if (!key_attr)
		return;

	done = sprintf(out, ""%x"", rta_getattr_u8(key_attr));
",1,unused,1130,unused,"
	if (!key_attr)
		return;

	done = sprintf(out, ""%x"", rta_getattr_u8(key_attr));
",unused,iproutenewver-tc2Ff_flower.c
"		return;

	done = sprintf(out, ""%x"", rta_getattr_u8(key_attr));
	if (mask_attr)
		sprintf(out + done, ""/%x"", rta_getattr_u8(mask_attr));
",1,unused,1132,unused,"		return;

	done = sprintf(out, ""%x"", rta_getattr_u8(key_attr));
	if (mask_attr)
		sprintf(out + done, ""/%x"", rta_getattr_u8(mask_attr));
",unused,iproutenewver-tc2Ff_flower.c
"	done = sprintf(out, ""%x"", rta_getattr_u8(key_attr));
	if (mask_attr)
		sprintf(out + done, ""/%x"", rta_getattr_u8(mask_attr));

	sprintf(namefrm, ""\n  %s %%x"", name);
",1,unused,1134,unused,"	done = sprintf(out, ""%x"", rta_getattr_u8(key_attr));
	if (mask_attr)
		sprintf(out + done, ""/%x"", rta_getattr_u8(mask_attr));

	sprintf(namefrm, ""\n  %s %%x"", name);
",unused,iproutenewver-tc2Ff_flower.c
"	if (!addr_attr || RTA_PAYLOAD(addr_attr) != len)
		return;
	if (!mask_attr || RTA_PAYLOAD(mask_attr) != len)
		return;
	done = sprintf(out, ""%s"", rt_addr_n2a_rta(family, addr_attr));
",1,unused,1211,unused,"	if (!addr_attr || RTA_PAYLOAD(addr_attr) != len)
		return;
	if (!mask_attr || RTA_PAYLOAD(mask_attr) != len)
		return;
	done = sprintf(out, ""%s"", rt_addr_n2a_rta(family, addr_attr));
",unused,iproutenewver-tc2Ff_flower.c
"		return;
	done = sprintf(out, ""%s"", rt_addr_n2a_rta(family, addr_attr));
	bits = __mask_bits(RTA_DATA(mask_attr), len);
	if (bits < 0)
		sprintf(out + done, ""/%s"", rt_addr_n2a_rta(family, mask_attr));
",1,unused,1214,unused,"		return;
	done = sprintf(out, ""%s"", rt_addr_n2a_rta(family, addr_attr));
	bits = __mask_bits(RTA_DATA(mask_attr), len);
	if (bits < 0)
		sprintf(out + done, ""/%s"", rt_addr_n2a_rta(family, mask_attr));
",unused,iproutenewver-tc2Ff_flower.c
"	bits = __mask_bits(RTA_DATA(mask_attr), len);
	if (bits < 0)
		sprintf(out + done, ""/%s"", rt_addr_n2a_rta(family, mask_attr));
	else if (bits < len * 8)
		sprintf(out + done, ""/%d"", bits);
",1,unused,1216,unused,"	bits = __mask_bits(RTA_DATA(mask_attr), len);
	if (bits < 0)
		sprintf(out + done, ""/%s"", rt_addr_n2a_rta(family, mask_attr));
	else if (bits < len * 8)
		sprintf(out + done, ""/%d"", bits);
",unused,iproutenewver-tc2Ff_flower.c
"		sprintf(out + done, ""/%s"", rt_addr_n2a_rta(family, mask_attr));
	else if (bits < len * 8)
		sprintf(out + done, ""/%d"", bits);

	sprintf(namefrm, ""\n  %s %%s"", name);
",1,unused,1218,unused,"		sprintf(out + done, ""/%s"", rt_addr_n2a_rta(family, mask_attr));
	else if (bits < len * 8)
		sprintf(out + done, ""/%d"", bits);

	sprintf(namefrm, ""\n  %s %%s"", name);
",unused,iproutenewver-tc2Ff_flower.c
"
	if (!attr)
		return;

	sprintf(namefrm,""\n  %s %%u"", name);
",1,unused,1235,unused,"
	if (!attr)
		return;

	sprintf(namefrm,""\n  %s %%u"", name);
",unused,iproutenewver-tc2Ff_flower.c
"
	if (!flags_attr)
		return;

	done = sprintf(out, ""%x"", rta_getattr_be16(flags_attr));
",1,unused,1249,unused,"
	if (!flags_attr)
		return;

	done = sprintf(out, ""%x"", rta_getattr_be16(flags_attr));
",unused,iproutenewver-tc2Ff_flower.c
"		return;

	done = sprintf(out, ""%x"", rta_getattr_be16(flags_attr));
	if (mask_attr)
		sprintf(out + done, ""%x"", rta_getattr_be16(flags_attr));
",1,unused,1251,unused,"		return;

	done = sprintf(out, ""%x"", rta_getattr_be16(flags_attr));
	if (mask_attr)
		sprintf(out + done, ""%x"", rta_getattr_be16(flags_attr));
",unused,iproutenewver-tc2Ff_flower.c
"	done = sprintf(out, ""%x"", rta_getattr_be16(flags_attr));
	if (mask_attr)
		sprintf(out + done, ""%x"", rta_getattr_be16(flags_attr));

	sprintf(namefrm, ""\n  %s %%s"", name);
",1,unused,1253,unused,"	done = sprintf(out, ""%x"", rta_getattr_be16(flags_attr));
	if (mask_attr)
		sprintf(out + done, ""%x"", rta_getattr_be16(flags_attr));

	sprintf(namefrm, ""\n  %s %%s"", name);
",unused,iproutenewver-tc2Ff_flower.c
"
	if (!attr)
		return;

	sprintf(namefrm,""\n  %s %%u"", name);
",1,unused,1265,unused,"
	if (!attr)
		return;

	sprintf(namefrm,""\n  %s %%u"", name);
",unused,iproutenewver-tc2Ff_flower.c
"	if (mask == UINT8_MAX && value_to_str)
		value_str = value_to_str(value);

	if (value_str)
		done = sprintf(out, ""%s"", value_str);
",1,unused,1288,unused,"	if (mask == UINT8_MAX && value_to_str)
		value_str = value_to_str(value);

	if (value_str)
		done = sprintf(out, ""%s"", value_str);
",unused,iproutenewver-tc2Ff_flower.c
"
	if (value_str)
		done = sprintf(out, ""%s"", value_str);
	else
		done = sprintf(out, ""%d"", value);
",1,unused,1290,unused,"
	if (value_str)
		done = sprintf(out, ""%s"", value_str);
	else
		done = sprintf(out, ""%d"", value);
",unused,iproutenewver-tc2Ff_flower.c
"	else
		done = sprintf(out, ""%d"", value);

	if (mask != UINT8_MAX)
		sprintf(out + done, ""/%d"", mask);
",1,unused,1293,unused,"	else
		done = sprintf(out, ""%d"", value);

	if (mask != UINT8_MAX)
		sprintf(out + done, ""/%d"", mask);
",unused,iproutenewver-tc2Ff_flower.c
"
	if (mask != UINT8_MAX)
		sprintf(out + done, ""/%d"", mask);

	sprintf(namefrm,""\n  %s %%s"", name);
",1,unused,1295,unused,"
	if (mask != UINT8_MAX)
		sprintf(out + done, ""/%d"", mask);

	sprintf(namefrm,""\n  %s %%s"", name);
",unused,iproutenewver-tc2Ff_flower.c
"
	if (!attr)
		return;

	sprintf(namefrm,""\n  %s %%u"", name);
",1,unused,1311,unused,"
	if (!attr)
		return;

	sprintf(namefrm,""\n  %s %%u"", name);
",unused,iproutenewver-tc2Ff_flower.c
"noexist:
#ifdef CONFIG_GACT
	if (!looked4gact) {
		looked4gact = 1;
		strcpy(str, ""gact"");
",1,unused,128,unused,"noexist:
#ifdef CONFIG_GACT
	if (!looked4gact) {
		looked4gact = 1;
		strcpy(str, ""gact"");
",unused,iproutenewver-tc2Fm_action.c
"		print_uint(PRINT_ANY, ""default"", "" default %u"", gopt->defcls);
		print_uint(PRINT_ANY, ""direct_packets_stat"",
			   "" direct_packets_stat %u"", gopt->direct_pkts);
		if (show_details) {
			sprintf(b1, ""%d.%d"", gopt->version >> 16, gopt->version & 0xffff);
",1,unused,350,unused,"		print_uint(PRINT_ANY, ""default"", "" default %u"", gopt->defcls);
		print_uint(PRINT_ANY, ""direct_packets_stat"",
			   "" direct_packets_stat %u"", gopt->direct_pkts);
		if (show_details) {
			sprintf(b1, ""%d.%d"", gopt->version >> 16, gopt->version & 0xffff);
",unused,iproutenewver-tc2Fq_htb.c
"		print_bool(PRINT_ANY, ""added"", ""added "", true);

	print_string(PRINT_ANY, ""kind"", ""qdisc %s"",
		     rta_getattr_str(tb[TCA_KIND]));
	sprintf(abuf, ""%x:"", t->tcm_handle >> 16);
",1,unused,247,unused,"		print_bool(PRINT_ANY, ""added"", ""added "", true);

	print_string(PRINT_ANY, ""kind"", ""qdisc %s"",
		     rta_getattr_str(tb[TCA_KIND]));
	sprintf(abuf, ""%x:"", t->tcm_handle >> 16);
",unused,iproutenewver-tc2Ftc_qdisc.c
"		     rta_getattr_str(tb[TCA_KIND]));
	sprintf(abuf, ""%x:"", t->tcm_handle >> 16);
	print_string(PRINT_ANY, ""handle"", "" %s"", abuf);
	if (show_raw) {
		sprintf(abuf, ""[%08x]"", t->tcm_handle);
",1,unused,250,unused,"		     rta_getattr_str(tb[TCA_KIND]));
	sprintf(abuf, ""%x:"", t->tcm_handle >> 16);
	print_string(PRINT_ANY, ""handle"", "" %s"", abuf);
	if (show_raw) {
		sprintf(abuf, ""[%08x]"", t->tcm_handle);
",unused,iproutenewver-tc2Ftc_qdisc.c
"	SPRINT_BUF(handle) = {};
	int hlen = SPRINT_BSIZE - 1;

	if (h == TC_H_ROOT)
		sprintf(handle, ""root"");
",1,unused,136,unused,"	SPRINT_BUF(handle) = {};
	int hlen = SPRINT_BSIZE - 1;

	if (h == TC_H_ROOT)
		sprintf(handle, ""root"");
",unused,iproutenewver-tc2Ftc_util.c
"
char *sprint_tc_classid(__u32 h, char *buf)
{
	if (print_tc_classid(buf, SPRINT_BSIZE-1, h))
		strcpy(buf, ""???"");
",1,unused,163,unused,"
char *sprint_tc_classid(__u32 h, char *buf)
{
	if (print_tc_classid(buf, SPRINT_BSIZE-1, h))
		strcpy(buf, ""???"");
",unused,iproutenewver-tc2Ftc_util.c
"		/* print the delimiter for every entry */
		if (i != applied)
			printf("","");

		sprintf(addr_str, ""%u.%u.%u:"", tipc_zone(members[i]),
",1,unused,619,unused,"		/* print the delimiter for every entry */
		if (i != applied)
			printf("","");

		sprintf(addr_str, ""%u.%u.%u:"", tipc_zone(members[i]),
",unused,iproutenewver-tipc2Flink.c
"				      const uint32_t dom_gen)
{
	char addr_str[16];

	sprintf(addr_str, ""%u.%u.%u"", tipc_zone(addr), tipc_cluster(addr),
",1,unused,633,unused,"				      const uint32_t dom_gen)
{
	char addr_str[16];

	sprintf(addr_str, ""%u.%u.%u"", tipc_zone(addr), tipc_cluster(addr),
",unused,iproutenewver-tipc2Flink.c
"
	mnl_attr_parse_nested(info[TIPC_NLA_MON_PEER], parse_attrs, attrs);

	(attrs[TIPC_NLA_MON_PEER_LOCAL] || attrs[TIPC_NLA_MON_PEER_HEAD]) ?
		strcpy(monitored, ""direct"") :
",1,unused,661,unused,"
	mnl_attr_parse_nested(info[TIPC_NLA_MON_PEER], parse_attrs, attrs);

	(attrs[TIPC_NLA_MON_PEER_LOCAL] || attrs[TIPC_NLA_MON_PEER_HEAD]) ?
		strcpy(monitored, ""direct"") :
",unused,iproutenewver-tipc2Flink.c
"	mnl_attr_parse_nested(info[TIPC_NLA_MON_PEER], parse_attrs, attrs);

	(attrs[TIPC_NLA_MON_PEER_LOCAL] || attrs[TIPC_NLA_MON_PEER_HEAD]) ?
		strcpy(monitored, ""direct"") :
		strcpy(monitored, ""indirect"");
",1,unused,662,unused,"	mnl_attr_parse_nested(info[TIPC_NLA_MON_PEER], parse_attrs, attrs);

	(attrs[TIPC_NLA_MON_PEER_LOCAL] || attrs[TIPC_NLA_MON_PEER_HEAD]) ?
		strcpy(monitored, ""direct"") :
		strcpy(monitored, ""indirect"");
",unused,iproutenewver-tipc2Flink.c
"		strcpy(monitored, ""direct"") :
		strcpy(monitored, ""indirect"");

	attrs[TIPC_NLA_MON_PEER_UP] ?
		strcpy(status, ""up"") :
",1,unused,665,unused,"		strcpy(monitored, ""direct"") :
		strcpy(monitored, ""indirect"");

	attrs[TIPC_NLA_MON_PEER_UP] ?
		strcpy(status, ""up"") :
",unused,iproutenewver-tipc2Flink.c
"		strcpy(monitored, ""indirect"");

	attrs[TIPC_NLA_MON_PEER_UP] ?
		strcpy(status, ""up"") :
		strcpy(status, ""down"");
",1,unused,666,unused,"		strcpy(monitored, ""indirect"");

	attrs[TIPC_NLA_MON_PEER_UP] ?
		strcpy(status, ""up"") :
		strcpy(status, ""down"");
",unused,iproutenewver-tipc2Flink.c
"
	if (s & NUD_REACHABLE)
		return """";

	sprintf(buf, ""state=%#x"", s);
",1,unused,62,unused,"
	if (s & NUD_REACHABLE)
		return """";

	sprintf(buf, ""state=%#x"", s);
",unused,iprouteold-bridge2Ffdb.c
"
		if (s < 0)
			return;

		strcpy(ifr.ifr_name, rta_getattr_str(tb[IFLA_IFNAME]));
",1,unused,182,unused,"
		if (s < 0)
			return;

		strcpy(ifr.ifr_name, rta_getattr_str(tb[IFLA_IFNAME]));
",unused,iprouteold-ip2Fipaddress.c
"				SPRINT_BUF(b1);
				SPRINT_BUF(b2);
				char msg[64 + sizeof(b1) + sizeof(b2)];

				sprintf(msg, ""Invalid \""vlan protocol\"" value - supported %s, %s\n"",
",1,unused,296,unused,"				SPRINT_BUF(b1);
				SPRINT_BUF(b2);
				char msg[64 + sizeof(b1) + sizeof(b2)];

				sprintf(msg, ""Invalid \""vlan protocol\"" value - supported %s, %s\n"",
",unused,iprouteold-ip2Fiplink.c
"	if (tb[RTA_SRC])
		len = snprintf(obuf, sizeof(obuf),
			       ""(%s, "", rt_addr_n2a_rta(family, tb[RTA_SRC]));
	else
		len = sprintf(obuf, ""(unknown, "");
",1,unused,124,unused,"	if (tb[RTA_SRC])
		len = snprintf(obuf, sizeof(obuf),
			       ""(%s, "", rt_addr_n2a_rta(family, tb[RTA_SRC]));
	else
		len = sprintf(obuf, ""(unknown, "");
",unused,iprouteold-ip2Fipmroute.c
"		perror(""malloc"");
		return -ENOMEM;
	}
	c->nsid = nsid;
	strcpy(c->name, name);
",1,unused,179,unused,"		perror(""malloc"");
		return -ENOMEM;
	}
	c->nsid = nsid;
	strcpy(c->name, name);
",unused,iprouteold-ip2Fipnetns.c
"			continue;
		id = get_netnsid_from_name(entry->d_name);

		if (nsid == id) {
			strcpy(name, entry->d_name);
",1,unused,255,unused,"			continue;
		id = get_netnsid_from_name(entry->d_name);

		if (nsid == id) {
			strcpy(name, entry->d_name);
",unused,iprouteold-ip2Fipnetns.c
"	strftime(str, sizeof(str), ""%Y-%m-%d %T"", tp);

	return str;
 error:
	strcpy(str, ""(error)"");
",1,unused,339,unused,"	strftime(str, sizeof(str), ""%Y-%m-%d %T"", tp);

	return str;
 error:
	strcpy(str, ""(error)"");
",unused,iprouteold-ip2Fipntable.c
"		if (t->t_type == proto)
			return t->t_name;
	}

	sprintf(str, ""%u"", proto);
",1,unused,153,unused,"		if (t->t_type == proto)
			return t->t_name;
	}

	sprintf(str, ""%u"", proto);
",unused,iprouteold-ip2Fipxfrm.c
"		if (t->t_type == type)
			return t->t_name;
	}

	sprintf(str, ""%d"", type);
",1,unused,196,unused,"		if (t->t_type == type)
			return t->t_name;
	}

	sprintf(str, ""%d"", type);
",unused,iprouteold-ip2Fipxfrm.c
"const char *strxf_mask32(__u32 mask)
{
	static char str[16];

	sprintf(str, ""%.8x"", mask);
",1,unused,218,unused,"const char *strxf_mask32(__u32 mask)
{
	static char str[16];

	sprintf(str, ""%.8x"", mask);
",unused,iprouteold-ip2Fipxfrm.c
"	static char str[32];

	switch (share) {
	case XFRM_SHARE_ANY:
		strcpy(str, ""any"");
",1,unused,229,unused,"	static char str[32];

	switch (share) {
	case XFRM_SHARE_ANY:
		strcpy(str, ""any"");
",unused,iprouteold-ip2Fipxfrm.c
"	case XFRM_SHARE_ANY:
		strcpy(str, ""any"");
		break;
	case XFRM_SHARE_SESSION:
		strcpy(str, ""session"");
",1,unused,232,unused,"	case XFRM_SHARE_ANY:
		strcpy(str, ""any"");
		break;
	case XFRM_SHARE_SESSION:
		strcpy(str, ""session"");
",unused,iprouteold-ip2Fipxfrm.c
"	case XFRM_SHARE_SESSION:
		strcpy(str, ""session"");
		break;
	case XFRM_SHARE_USER:
		strcpy(str, ""user"");
",1,unused,235,unused,"	case XFRM_SHARE_SESSION:
		strcpy(str, ""session"");
		break;
	case XFRM_SHARE_USER:
		strcpy(str, ""user"");
",unused,iprouteold-ip2Fipxfrm.c
"	case XFRM_SHARE_USER:
		strcpy(str, ""user"");
		break;
	case XFRM_SHARE_UNIQUE:
		strcpy(str, ""unique"");
",1,unused,238,unused,"	case XFRM_SHARE_USER:
		strcpy(str, ""user"");
		break;
	case XFRM_SHARE_UNIQUE:
		strcpy(str, ""unique"");
",unused,iprouteold-ip2Fipxfrm.c
"	case XFRM_SHARE_UNIQUE:
		strcpy(str, ""unique"");
		break;
	default:
		sprintf(str, ""%u"", share);
",1,unused,241,unused,"	case XFRM_SHARE_UNIQUE:
		strcpy(str, ""unique"");
		break;
	default:
		sprintf(str, ""%u"", share);
",unused,iprouteold-ip2Fipxfrm.c
"	pp = getprotobynumber(proto);
	if (pp)
		p = pp->p_name;
	else {
		sprintf(buf, ""%u"", proto);
",1,unused,258,unused,"	pp = getprotobynumber(proto);
	if (pp)
		p = pp->p_name;
	else {
		sprintf(buf, ""%u"", proto);
",unused,iprouteold-ip2Fipxfrm.c
"	static char str[16];

	switch (ptype) {
	case XFRM_POLICY_TYPE_MAIN:
		strcpy(str, ""main"");
",1,unused,271,unused,"	static char str[16];

	switch (ptype) {
	case XFRM_POLICY_TYPE_MAIN:
		strcpy(str, ""main"");
",unused,iprouteold-ip2Fipxfrm.c
"	case XFRM_POLICY_TYPE_MAIN:
		strcpy(str, ""main"");
		break;
	case XFRM_POLICY_TYPE_SUB:
		strcpy(str, ""sub"");
",1,unused,274,unused,"	case XFRM_POLICY_TYPE_MAIN:
		strcpy(str, ""main"");
		break;
	case XFRM_POLICY_TYPE_SUB:
		strcpy(str, ""sub"");
",unused,iprouteold-ip2Fipxfrm.c
"	case XFRM_POLICY_TYPE_SUB:
		strcpy(str, ""sub"");
		break;
	default:
		sprintf(str, ""%u"", ptype);
",1,unused,277,unused,"	case XFRM_POLICY_TYPE_SUB:
		strcpy(str, ""sub"");
		break;
	default:
		sprintf(str, ""%u"", ptype);
",unused,iprouteold-ip2Fipxfrm.c
"{
	static char str[32];

	if (limit == XFRM_INF)
		strcpy(str, ""(INF)"");
",1,unused,344,unused,"{
	static char str[32];

	if (limit == XFRM_INF)
		strcpy(str, ""(INF)"");
",unused,iprouteold-ip2Fipxfrm.c
"
	if (limit == XFRM_INF)
		strcpy(str, ""(INF)"");
	else
		sprintf(str, ""%llu"", (unsigned long long) limit);
",1,unused,346,unused,"
	if (limit == XFRM_INF)
		strcpy(str, ""(INF)"");
	else
		sprintf(str, ""%llu"", (unsigned long long) limit);
",unused,iprouteold-ip2Fipxfrm.c
"{
	static char str[32];

	if (time == 0)
		strcpy(str, ""-"");
",1,unused,368,unused,"{
	static char str[32];

	if (time == 0)
		strcpy(str, ""-"");
",unused,iprouteold-ip2Fipxfrm.c
"		if (max > 16)
			max = 16;
		cookie[0] = 0;
		for (i = 0; i < max; i++)
			sprintf(cookie + i + i, ""%02x"", ptr[i]);
",1,unused,291,unused,"		if (max > 16)
			max = 16;
		cookie[0] = 0;
		for (i = 0; i < max; i++)
			sprintf(cookie + i + i, ""%02x"", ptr[i]);
",unused,iprouteold-ip2Ftcp_metrics.c
"	static char buf[16];

	switch (proto) {
	case IPPROTO_IPIP:
		strcpy(buf, ""ip"");
",1,unused,46,unused,"	static char buf[16];

	switch (proto) {
	case IPPROTO_IPIP:
		strcpy(buf, ""ip"");
",unused,iprouteold-ip2Ftunnel.c
"	case IPPROTO_IPIP:
		strcpy(buf, ""ip"");
		break;
	case IPPROTO_GRE:
		strcpy(buf, ""gre"");
",1,unused,49,unused,"	case IPPROTO_IPIP:
		strcpy(buf, ""ip"");
		break;
	case IPPROTO_GRE:
		strcpy(buf, ""gre"");
",unused,iprouteold-ip2Ftunnel.c
"	case IPPROTO_GRE:
		strcpy(buf, ""gre"");
		break;
	case IPPROTO_IPV6:
		strcpy(buf, ""ipv6"");
",1,unused,52,unused,"	case IPPROTO_GRE:
		strcpy(buf, ""gre"");
		break;
	case IPPROTO_IPV6:
		strcpy(buf, ""ipv6"");
",unused,iprouteold-ip2Ftunnel.c
"	case IPPROTO_IPV6:
		strcpy(buf, ""ipv6"");
		break;
	case IPPROTO_ESP:
		strcpy(buf, ""esp"");
",1,unused,55,unused,"	case IPPROTO_IPV6:
		strcpy(buf, ""ipv6"");
		break;
	case IPPROTO_ESP:
		strcpy(buf, ""esp"");
",unused,iprouteold-ip2Ftunnel.c
"	case IPPROTO_ESP:
		strcpy(buf, ""esp"");
		break;
	case 0:
		strcpy(buf, ""any"");
",1,unused,58,unused,"	case IPPROTO_ESP:
		strcpy(buf, ""esp"");
		break;
	case 0:
		strcpy(buf, ""any"");
",unused,iprouteold-ip2Ftunnel.c
"	case 0:
		strcpy(buf, ""any"");
		break;
	default:
		strcpy(buf, ""unknown"");
",1,unused,61,unused,"	case 0:
		strcpy(buf, ""any"");
		break;
	default:
		strcpy(buf, ""unknown"");
",unused,iprouteold-ip2Ftunnel.c
"	im = malloc(sizeof(*im));
	if (im == NULL)
		return 0;
	im->index = ifi->ifi_index;
	strcpy(im->name, ifname);
",1,unused,127,unused,"	im = malloc(sizeof(*im));
	if (im == NULL)
		return 0;
	im->index = ifi->ifi_index;
	strcpy(im->name, ifname);
",unused,iprouteold-lib2Fll_map.c
"		} else if (sscanf(p, ""0x%x %s\n"", id, name) != 2 &&
				sscanf(p, ""0x%x %s #"", id, name) != 2 &&
				sscanf(p, ""%d %s\n"", id, name) != 2 &&
				sscanf(p, ""%d %s #"", id, name) != 2) {
			strcpy(name, p);
",1,unused,44,unused,"		} else if (sscanf(p, ""0x%x %s\n"", id, name) != 2 &&
				sscanf(p, ""0x%x %s #"", id, name) != 2 &&
				sscanf(p, ""%d %s\n"", id, name) != 2 &&
				sscanf(p, ""%d %s #"", id, name) != 2) {
			strcpy(name, p);
",unused,iprouteold-lib2Fnames.c
"		snprintf(name, sizeof(name)-1, ""%s"", getenv(""PROC_NET_PSCHED""));
	} else if (getenv(""PROC_ROOT"")) {
		snprintf(name, sizeof(name)-1, ""%s/net/psched"", getenv(""PROC_ROOT""));
	} else {
		strcpy(name, ""/proc/net/psched"");
",1,unused,728,unused,"		snprintf(name, sizeof(name)-1, ""%s"", getenv(""PROC_NET_PSCHED""));
	} else if (getenv(""PROC_ROOT"")) {
		snprintf(name, sizeof(name)-1, ""%s/net/psched"", getenv(""PROC_ROOT""));
	} else {
		strcpy(name, ""/proc/net/psched"");
",unused,iprouteold-lib2Futils.c
"
	for (i=0; i<len; i++) {
		if (blen < 3)
			break;
		sprintf(ptr, ""%02x"", str[i]);
",1,unused,907,unused,"
	for (i=0; i<len; i++) {
		if (blen < 3)
			break;
		sprintf(ptr, ""%02x"", str[i]);
",unused,iprouteold-lib2Futils.c
"			*lenp = 0;
			return -1;
		}
		cc += cc1 - 2;
		strcat(*linep, line1);
",1,unused,1030,unused,"			*lenp = 0;
			return -1;
		}
		cc += cc1 - 2;
		strcat(*linep, line1);
",unused,iprouteold-lib2Futils.c
"}

char *int_to_str(int val, char *buf)
{
	sprintf(buf, ""%d"", val);
",1,unused,1121,unused,"}

char *int_to_str(int val, char *buf)
{
	sprintf(buf, ""%d"", val);
",unused,iprouteold-lib2Futils.c
"		char buf[128];
		FILE *fp;

		if (active_probing) {
			sprintf(buf, ""/proc/sys/net/ipv4/neigh/%s/mcast_solicit"", ifnames[i]);
",1,unused,129,unused,"		char buf[128];
		FILE *fp;

		if (active_probing) {
			sprintf(buf, ""/proc/sys/net/ipv4/neigh/%s/mcast_solicit"", ifnames[i]);
",unused,iprouteold-misc2Farpd.c
"		if (active_probing) {
			sprintf(buf, ""/proc/sys/net/ipv4/neigh/%s/mcast_solicit"", ifnames[i]);
			if ((fp = fopen(buf, ""w"")) != NULL) {
				if (no_kernel_broadcasts)
					strcpy(buf, ""0\n"");
",1,unused,132,unused,"		if (active_probing) {
			sprintf(buf, ""/proc/sys/net/ipv4/neigh/%s/mcast_solicit"", ifnames[i]);
			if ((fp = fopen(buf, ""w"")) != NULL) {
				if (no_kernel_broadcasts)
					strcpy(buf, ""0\n"");
",unused,iprouteold-misc2Farpd.c
"			if ((fp = fopen(buf, ""w"")) != NULL) {
				if (no_kernel_broadcasts)
					strcpy(buf, ""0\n"");
				else
					sprintf(buf, ""%d\n"", active_probing >= 2 ? 1 : 3-active_probing);
",1,unused,134,unused,"			if ((fp = fopen(buf, ""w"")) != NULL) {
				if (no_kernel_broadcasts)
					strcpy(buf, ""0\n"");
				else
					sprintf(buf, ""%d\n"", active_probing >= 2 ? 1 : 3-active_probing);
",unused,iprouteold-misc2Farpd.c
"				fclose(fp);
			}
		}

		sprintf(buf, ""/proc/sys/net/ipv4/neigh/%s/app_solicit"", ifnames[i]);
",1,unused,140,unused,"				fclose(fp);
			}
		}

		sprintf(buf, ""/proc/sys/net/ipv4/neigh/%s/app_solicit"", ifnames[i]);
",unused,iprouteold-misc2Farpd.c
"		}

		sprintf(buf, ""/proc/sys/net/ipv4/neigh/%s/app_solicit"", ifnames[i]);
		if ((fp = fopen(buf, ""w"")) != NULL) {
			sprintf(buf, ""%d\n"", active_probing <= 1 ? 1 : active_probing);
",1,unused,142,unused,"		}

		sprintf(buf, ""/proc/sys/net/ipv4/neigh/%s/app_solicit"", ifnames[i]);
		if ((fp = fopen(buf, ""w"")) != NULL) {
			sprintf(buf, ""%d\n"", active_probing <= 1 ? 1 : active_probing);
",unused,iprouteold-misc2Farpd.c
"		char buf[128];
		FILE *fp;

		if (active_probing) {
			sprintf(buf, ""/proc/sys/net/ipv4/neigh/%s/mcast_solicit"", ifnames[i]);
",1,unused,162,unused,"		char buf[128];
		FILE *fp;

		if (active_probing) {
			sprintf(buf, ""/proc/sys/net/ipv4/neigh/%s/mcast_solicit"", ifnames[i]);
",unused,iprouteold-misc2Farpd.c
"
		if (active_probing) {
			sprintf(buf, ""/proc/sys/net/ipv4/neigh/%s/mcast_solicit"", ifnames[i]);
			if ((fp = fopen(buf, ""w"")) != NULL) {
				strcpy(buf, ""3\n"");
",1,unused,164,unused,"
		if (active_probing) {
			sprintf(buf, ""/proc/sys/net/ipv4/neigh/%s/mcast_solicit"", ifnames[i]);
			if ((fp = fopen(buf, ""w"")) != NULL) {
				strcpy(buf, ""3\n"");
",unused,iprouteold-misc2Farpd.c
"				fputs(buf, fp);
				fclose(fp);
			}
		}
		sprintf(buf, ""/proc/sys/net/ipv4/neigh/%s/app_solicit"", ifnames[i]);
",1,unused,169,unused,"				fputs(buf, fp);
				fclose(fp);
			}
		}
		sprintf(buf, ""/proc/sys/net/ipv4/neigh/%s/app_solicit"", ifnames[i]);
",unused,iprouteold-misc2Farpd.c
"			}
		}
		sprintf(buf, ""/proc/sys/net/ipv4/neigh/%s/app_solicit"", ifnames[i]);
		if ((fp = fopen(buf, ""w"")) != NULL) {
			strcpy(buf, ""0\n"");
",1,unused,171,unused,"			}
		}
		sprintf(buf, ""/proc/sys/net/ipv4/neigh/%s/app_solicit"", ifnames[i]);
		if ((fp = fopen(buf, ""w"")) != NULL) {
			strcpy(buf, ""0\n"");
",unused,iprouteold-misc2Farpd.c
"	else
		fprintf(fp, ""%8llu "", vals[i]);

	if (rates[i] > mega) {
		sprintf(temp, ""%uM"", (unsigned int)(rates[i]/mega));
",1,unused,316,unused,"	else
		fprintf(fp, ""%8llu "", vals[i]);

	if (rates[i] > mega) {
		sprintf(temp, ""%uM"", (unsigned int)(rates[i]/mega));
",unused,iprouteold-misc2Fifstat.c
"	if (rates[i] > mega) {
		sprintf(temp, ""%uM"", (unsigned int)(rates[i]/mega));
		fprintf(fp, ""%-6s "", temp);
	} else if (rates[i] > kilo) {
		sprintf(temp, ""%uK"", (unsigned int)(rates[i]/kilo));
",1,unused,319,unused,"	if (rates[i] > mega) {
		sprintf(temp, ""%uM"", (unsigned int)(rates[i]/mega));
		fprintf(fp, ""%-6s "", temp);
	} else if (rates[i] > kilo) {
		sprintf(temp, ""%uK"", (unsigned int)(rates[i]/kilo));
",unused,iprouteold-misc2Fifstat.c
"	else
		fprintf(fp, ""%8llu "", vals[i]);

	if (vals[k] > giga) {
		sprintf(temp, ""%uM"", (unsigned int)(vals[k]/mega));
",1,unused,337,unused,"	else
		fprintf(fp, ""%8llu "", vals[i]);

	if (vals[k] > giga) {
		sprintf(temp, ""%uM"", (unsigned int)(vals[k]/mega));
",unused,iprouteold-misc2Fifstat.c
"	if (vals[k] > giga) {
		sprintf(temp, ""%uM"", (unsigned int)(vals[k]/mega));
		fprintf(fp, ""%-6s "", temp);
	} else if (vals[k] > mega) {
		sprintf(temp, ""%uK"", (unsigned int)(vals[k]/kilo));
",1,unused,340,unused,"	if (vals[k] > giga) {
		sprintf(temp, ""%uM"", (unsigned int)(vals[k]/mega));
		fprintf(fp, ""%-6s "", temp);
	} else if (vals[k] > mega) {
		sprintf(temp, ""%uK"", (unsigned int)(vals[k]/kilo));
",unused,iprouteold-misc2Fifstat.c
"
	p.fd = fd;
	p.events = p.revents = POLLIN;

	sprintf(info_source, ""%d.%lu sampling_interval=%d time_const=%d"",
",1,unused,601,unused,"
	p.fd = fd;
	p.events = p.revents = POLLIN;

	sprintf(info_source, ""%d.%lu sampling_interval=%d time_const=%d"",
",unused,iprouteold-misc2Fifstat.c
"	argv += optind;

	sun.sun_family = AF_UNIX;
	sun.sun_path[0] = 0;
	sprintf(sun.sun_path+1, ""ifstat%d"", getuid());
",1,unused,762,unused,"	argv += optind;

	sun.sun_family = AF_UNIX;
	sun.sun_path[0] = 0;
	sprintf(sun.sun_path+1, ""ifstat%d"", getuid());
",unused,iprouteold-misc2Fifstat.c
"	}

	if ((fd = socket(AF_UNIX, SOCK_STREAM, 0)) >= 0 &&
	    (connect(fd, (struct sockaddr *)&sun, 2+1+strlen(sun.sun_path+1)) == 0
	     || (strcpy(sun.sun_path+1, ""ifstat0""),
",1,unused,852,unused,"	}

	if ((fd = socket(AF_UNIX, SOCK_STREAM, 0)) >= 0 &&
	    (connect(fd, (struct sockaddr *)&sun, 2+1+strlen(sun.sun_path+1)) == 0
	     || (strcpy(sun.sun_path+1, ""ifstat0""),
",unused,iprouteold-misc2Fifstat.c
"			info_source[0] = 0;
		}
		load_info();
		if (info_source[0] == 0)
			strcpy(info_source, ""kernel"");
",1,unused,873,unused,"			info_source[0] = 0;
		}
		load_info();
		if (info_source[0] == 0)
			strcpy(info_source, ""kernel"");
",unused,iprouteold-misc2Fifstat.c
"	}

	/* initialize */
	/* de->d_name is guaranteed to be <= NAME_MAX */
	strcpy(lf->basename, file);
",1,unused,184,unused,"	}

	/* initialize */
	/* de->d_name is guaranteed to be <= NAME_MAX */
	strcpy(lf->basename, file);
",unused,iprouteold-misc2Flnstat_util.c
"
	/* initialize */
	/* de->d_name is guaranteed to be <= NAME_MAX */
	strcpy(lf->basename, file);
	strcpy(lf->path, path);
",1,unused,185,unused,"
	/* initialize */
	/* de->d_name is guaranteed to be <= NAME_MAX */
	strcpy(lf->basename, file);
	strcpy(lf->path, path);
",unused,iprouteold-misc2Flnstat_util.c
"	/* initialize */
	/* de->d_name is guaranteed to be <= NAME_MAX */
	strcpy(lf->basename, file);
	strcpy(lf->path, path);
	strcat(lf->path, ""/"");
",1,unused,186,unused,"	/* initialize */
	/* de->d_name is guaranteed to be <= NAME_MAX */
	strcpy(lf->basename, file);
	strcpy(lf->path, path);
	strcat(lf->path, ""/"");
",unused,iprouteold-misc2Flnstat_util.c
"	/* de->d_name is guaranteed to be <= NAME_MAX */
	strcpy(lf->basename, file);
	strcpy(lf->path, path);
	strcat(lf->path, ""/"");
	strcat(lf->path, lf->basename);
",1,unused,187,unused,"	/* de->d_name is guaranteed to be <= NAME_MAX */
	strcpy(lf->basename, file);
	strcpy(lf->path, path);
	strcat(lf->path, ""/"");
	strcat(lf->path, lf->basename);
",unused,iprouteold-misc2Flnstat_util.c
"
	p.fd = fd;
	p.events = p.revents = POLLIN;

	sprintf(info_source, ""%d.%lu sampling_interval=%d time_const=%d"",
",1,unused,463,unused,"
	p.fd = fd;
	p.events = p.revents = POLLIN;

	sprintf(info_source, ""%d.%lu sampling_interval=%d time_const=%d"",
",unused,iprouteold-misc2Fnstat.c
"	argv += optind;

	sun.sun_family = AF_UNIX;
	sun.sun_path[0] = 0;
	sprintf(sun.sun_path+1, ""nstat%d"", getuid());
",1,unused,616,unused,"	argv += optind;

	sun.sun_family = AF_UNIX;
	sun.sun_path[0] = 0;
	sprintf(sun.sun_path+1, ""nstat%d"", getuid());
",unused,iprouteold-misc2Fnstat.c
"	npatterns = argc;

	if ((hist_name = getenv(""NSTAT_HISTORY"")) == NULL) {
		hist_name = malloc(128);
		sprintf(hist_name, ""/tmp/.nstat.u%d"", getuid());
",1,unused,650,unused,"	npatterns = argc;

	if ((hist_name = getenv(""NSTAT_HISTORY"")) == NULL) {
		hist_name = malloc(128);
		sprintf(hist_name, ""/tmp/.nstat.u%d"", getuid());
",unused,iprouteold-misc2Fnstat.c
"	}

	if ((fd = socket(AF_UNIX, SOCK_STREAM, 0)) >= 0 &&
	    (connect(fd, (struct sockaddr *)&sun, 2+1+strlen(sun.sun_path+1)) == 0
	     || (strcpy(sun.sun_path+1, ""nstat0""),
",1,unused,704,unused,"	}

	if ((fd = socket(AF_UNIX, SOCK_STREAM, 0)) >= 0 &&
	    (connect(fd, (struct sockaddr *)&sun, 2+1+strlen(sun.sun_path+1)) == 0
	     || (strcpy(sun.sun_path+1, ""nstat0""),
",unused,iprouteold-misc2Fnstat.c
"		load_snmp6();
		load_snmp();
		load_sctp_snmp();
		if (info_source[0] == 0)
			strcpy(info_source, ""kernel"");
",1,unused,728,unused,"		load_snmp6();
		load_snmp();
		load_sctp_snmp();
		if (info_source[0] == 0)
			strcpy(info_source, ""kernel"");
",unused,iprouteold-misc2Fnstat.c
"{
	char temp[64];

	if (rate > 1024*1024) {
		sprintf(temp, ""%uM"", (unsigned int)rint(rate/(1024*1024)));
",1,unused,138,unused,"{
	char temp[64];

	if (rate > 1024*1024) {
		sprintf(temp, ""%uM"", (unsigned int)rint(rate/(1024*1024)));
",unused,iprouteold-misc2Frtacct.c
"	if (rate > 1024*1024) {
		sprintf(temp, ""%uM"", (unsigned int)rint(rate/(1024*1024)));
		fprintf(fp, "" %-10s"", temp);
	} else if (rate > 1024) {
		sprintf(temp, ""%uK"", (unsigned int)rint(rate/1024));
",1,unused,141,unused,"	if (rate > 1024*1024) {
		sprintf(temp, ""%uM"", (unsigned int)rint(rate/(1024*1024)));
		fprintf(fp, "" %-10s"", temp);
	} else if (rate > 1024) {
		sprintf(temp, ""%uK"", (unsigned int)rint(rate/1024));
",unused,iprouteold-misc2Frtacct.c
"
	p.fd = fd;
	p.events = p.revents = POLLIN;

	sprintf(kern_db->signature,
",1,unused,363,unused,"
	p.fd = fd;
	p.events = p.revents = POLLIN;

	sprintf(kern_db->signature,
",unused,iprouteold-misc2Frtacct.c
"	}

	sun.sun_family = AF_UNIX;
	sun.sun_path[0] = 0;
	sprintf(sun.sun_path+1, ""rtacct%d"", getuid());
",1,unused,504,unused,"	}

	sun.sun_family = AF_UNIX;
	sun.sun_path[0] = 0;
	sprintf(sun.sun_path+1, ""rtacct%d"", getuid());
",unused,iprouteold-misc2Frtacct.c
"
	if (getenv(""RTACCT_HISTORY""))
		snprintf(hist_name, sizeof(hist_name), ""%s"", getenv(""RTACCT_HISTORY""));
	else
		sprintf(hist_name, ""/tmp/.rtacct.u%d"", getuid());
",1,unused,536,unused,"
	if (getenv(""RTACCT_HISTORY""))
		snprintf(hist_name, sizeof(hist_name), ""%s"", getenv(""RTACCT_HISTORY""));
	else
		sprintf(hist_name, ""/tmp/.rtacct.u%d"", getuid());
",unused,iprouteold-misc2Frtacct.c
"	}

	if ((fd = socket(AF_UNIX, SOCK_STREAM, 0)) >= 0 &&
	    (connect(fd, (struct sockaddr *)&sun, 2+1+strlen(sun.sun_path+1)) == 0
	     || (strcpy(sun.sun_path+1, ""rtacct0""),
",1,unused,598,unused,"	}

	if ((fd = socket(AF_UNIX, SOCK_STREAM, 0)) >= 0 &&
	    (connect(fd, (struct sockaddr *)&sun, 2+1+strlen(sun.sun_path+1)) == 0
	     || (strcpy(sun.sun_path+1, ""rtacct0""),
",unused,iprouteold-misc2Frtacct.c
"			hist_db = NULL;
		}

		pad_kern_table(kern_db, read_kern_table(kern_db->ival));
		strcpy(kern_db->signature, ""kernel"");
",1,unused,619,unused,"			hist_db = NULL;
		}

		pad_kern_table(kern_db, read_kern_table(kern_db->ival));
		strcpy(kern_db->signature, ""kernel"");
",unused,iprouteold-misc2Frtacct.c
"	strncpy(name, root, sizeof(name)-1);
	name[sizeof(name)-1] = 0;

	if (strlen(name) == 0 || name[strlen(name)-1] != '/')
		strcat(name, ""/"");
",1,unused,486,unused,"	strncpy(name, root, sizeof(name)-1);
	name[sizeof(name)-1] = 0;

	if (strlen(name) == 0 || name[strlen(name)-1] != '/')
		strcat(name, ""/"");
",unused,iprouteold-misc2Fss.c
"	}
	if (secs) {
		if (secs > 9)
			msecs = 0;
		sprintf(buf+strlen(buf), ""%d%s"", secs, msecs ? ""."" : ""sec"");
",1,unused,915,unused,"	}
	if (secs) {
		if (secs > 9)
			msecs = 0;
		sprintf(buf+strlen(buf), ""%d%s"", secs, msecs ? ""."" : ""sec"");
",unused,iprouteold-misc2Fss.c
"			msecs = 0;
		sprintf(buf+strlen(buf), ""%d%s"", secs, msecs ? ""."" : ""sec"");
	}
	if (msecs)
		sprintf(buf+strlen(buf), ""%03dms"", msecs);
",1,unused,918,unused,"			msecs = 0;
		sprintf(buf+strlen(buf), ""%d%s"", secs, msecs ? ""."" : ""sec"");
	}
	if (msecs)
		sprintf(buf+strlen(buf), ""%03dms"", msecs);
",unused,iprouteold-misc2Fss.c
"	if (c->name)
		return c->name;

do_numeric:
	sprintf(buf, ""%u"", port);
",1,unused,1065,unused,"	if (c->name)
		return c->name;

do_numeric:
	sprintf(buf, ""%u"", port);
",unused,iprouteold-misc2Fss.c
"
static char *sprint_bw(char *buf, double bw)
{
	if (bw > 1000000.)
		sprintf(buf, ""%.1fM"", bw / 1000000.);
",1,unused,1819,unused,"
static char *sprint_bw(char *buf, double bw)
{
	if (bw > 1000000.)
		sprintf(buf, ""%.1fM"", bw / 1000000.);
",unused,iprouteold-misc2Fss.c
"{
	if (bw > 1000000.)
		sprintf(buf, ""%.1fM"", bw / 1000000.);
	else if (bw > 1000.)
		sprintf(buf, ""%.1fK"", bw / 1000.);
",1,unused,1821,unused,"{
	if (bw > 1000000.)
		sprintf(buf, ""%.1fM"", bw / 1000000.);
	else if (bw > 1000.)
		sprintf(buf, ""%.1fK"", bw / 1000.);
",unused,iprouteold-misc2Fss.c
"		sprintf(buf, ""%.1fM"", bw / 1000000.);
	else if (bw > 1000.)
		sprintf(buf, ""%.1fK"", bw / 1000.);
	else
		sprintf(buf, ""%g"", bw);
",1,unused,1823,unused,"		sprintf(buf, ""%.1fM"", bw / 1000000.);
	else if (bw > 1000.)
		sprintf(buf, ""%.1fK"", bw / 1000.);
	else
		sprintf(buf, ""%g"", bw);
",unused,iprouteold-misc2Fss.c
"
		if (name[0]) {
			if ((u->name = malloc(strlen(name)+1)) == NULL)
				break;
			strcpy(u->name, name);
",1,unused,3226,unused,"
		if (name[0]) {
			if ((u->name = malloc(strlen(name)+1)) == NULL)
				break;
			strcpy(u->name, name);
",unused,iprouteold-misc2Fss.c
"				int type = map_type(*p);

				switch (type) {
					case TCF_META_TYPE_INT:
						strcat(buf, ""INT"");
",1,unused,210,unused,"				int type = map_type(*p);

				switch (type) {
					case TCF_META_TYPE_INT:
						strcat(buf, ""INT"");
",unused,iprouteold-tc2Fem_meta.c
"						strcat(buf, ""INT"");
						break;

					case TCF_META_TYPE_VAR:
						strcat(buf, ""VAR"");
",1,unused,214,unused,"						strcat(buf, ""INT"");
						break;

					case TCF_META_TYPE_VAR:
						strcat(buf, ""VAR"");
",unused,iprouteold-tc2Fem_meta.c
"						break;
				}

				if (*(++p))
					strcat(buf, "","");
",1,unused,219,unused,"						break;
				}

				if (*(++p))
					strcat(buf, "","");
",unused,iprouteold-tc2Fem_meta.c
"noexist:
#ifdef CONFIG_GACT
	if (!looked4gact) {
		looked4gact = 1;
		strcpy(str, ""gact"");
",1,unused,125,unused,"noexist:
#ifdef CONFIG_GACT
	if (!looked4gact) {
		looked4gact = 1;
		strcpy(str, ""gact"");
",unused,iprouteold-tc2Fm_action.c
"
	if (t == NULL) {
		target->t = xtables_calloc(1, size);
		target->t->u.target_size = size;
		strcpy(target->t->u.user.name, target->name);
",1,unused,95,unused,"
	if (t == NULL) {
		target->t = xtables_calloc(1, size);
		target->t->u.target_size = size;
		strcpy(target->t->u.user.name, target->name);
",unused,iprouteold-tc2Fm_xt.c
"		node = node->parent_node;
	}
	while (node && node->right_node) {
		if (node->hlist.next)
			strcat(buf, ""|    "");
",1,unused,193,unused,"		node = node->parent_node;
	}
	while (node && node->right_node) {
		if (node->hlist.next)
			strcat(buf, ""|    "");
",unused,iprouteold-tc2Ftc_class.c
"	while (node && node->right_node) {
		if (node->hlist.next)
			strcat(buf, ""|    "");
		else
			strcat(buf, ""     "");
",1,unused,195,unused,"	while (node && node->right_node) {
		if (node->hlist.next)
			strcat(buf, ""|    "");
		else
			strcat(buf, ""     "");
",unused,iprouteold-tc2Ftc_class.c
"	}

	if (is_newline) {
		if (node->hlist.next && node->nodes_count)
			strcat(buf, ""|    |"");
",1,unused,202,unused,"	}

	if (is_newline) {
		if (node->hlist.next && node->nodes_count)
			strcat(buf, ""|    |"");
",unused,iprouteold-tc2Ftc_class.c
"	if (is_newline) {
		if (node->hlist.next && node->nodes_count)
			strcat(buf, ""|    |"");
		else if (node->hlist.next)
			strcat(buf, ""|     "");
",1,unused,204,unused,"	if (is_newline) {
		if (node->hlist.next && node->nodes_count)
			strcat(buf, ""|    |"");
		else if (node->hlist.next)
			strcat(buf, ""|     "");
",unused,iprouteold-tc2Ftc_class.c
"			strcat(buf, ""|    |"");
		else if (node->hlist.next)
			strcat(buf, ""|     "");
		else if (node->nodes_count)
			strcat(buf, ""     |"");
",1,unused,206,unused,"			strcat(buf, ""|    |"");
		else if (node->hlist.next)
			strcat(buf, ""|     "");
		else if (node->nodes_count)
			strcat(buf, ""     |"");
",unused,iprouteold-tc2Ftc_class.c
"			strcat(buf, ""|     "");
		else if (node->nodes_count)
			strcat(buf, ""     |"");
		else if (!node->hlist.next)
			strcat(buf, ""      "");
",1,unused,208,unused,"			strcat(buf, ""|     "");
		else if (node->nodes_count)
			strcat(buf, ""     |"");
		else if (!node->hlist.next)
			strcat(buf, ""      "");
",unused,iprouteold-tc2Ftc_class.c
"		else if (!node->hlist.next)
			strcat(buf, ""      "");
	}
	if (add_spaces > 0) {
		sprintf(spaces, ""%-*s"", add_spaces, """");
",1,unused,211,unused,"		else if (!node->hlist.next)
			strcat(buf, ""      "");
	}
	if (add_spaces > 0) {
		sprintf(spaces, ""%-*s"", add_spaces, """");
",unused,iprouteold-tc2Ftc_class.c
"			strcat(buf, ""      "");
	}
	if (add_spaces > 0) {
		sprintf(spaces, ""%-*s"", add_spaces, """");
		strcat(buf, spaces);
",1,unused,212,unused,"			strcat(buf, ""      "");
	}
	if (add_spaces > 0) {
		sprintf(spaces, ""%-*s"", add_spaces, """");
		strcat(buf, spaces);
",unused,iprouteold-tc2Ftc_class.c
"
		graph_indent(buf, cls, 0, 0);

		print_tc_classid(cls_id_str, sizeof(cls_id_str), cls->id);
		sprintf(str, ""+---(%s)"", cls_id_str);
",1,unused,246,unused,"
		graph_indent(buf, cls, 0, 0);

		print_tc_classid(cls_id_str, sizeof(cls_id_str), cls->id);
		sprintf(str, ""+---(%s)"", cls_id_str);
",unused,iprouteold-tc2Ftc_class.c
"		graph_indent(buf, cls, 0, 0);

		print_tc_classid(cls_id_str, sizeof(cls_id_str), cls->id);
		sprintf(str, ""+---(%s)"", cls_id_str);
		strcat(buf, str);
",1,unused,247,unused,"		graph_indent(buf, cls, 0, 0);

		print_tc_classid(cls_id_str, sizeof(cls_id_str), cls->id);
		sprintf(str, ""+---(%s)"", cls_id_str);
		strcat(buf, str);
",unused,iprouteold-tc2Ftc_class.c
"		parse_rtattr(tb, TCA_MAX, (struct rtattr *)cls->data,
				cls->data_len);

		if (tb[TCA_KIND] == NULL) {
			strcat(buf, "" [unknown qdisc kind] "");
",1,unused,253,unused,"		parse_rtattr(tb, TCA_MAX, (struct rtattr *)cls->data,
				cls->data_len);

		if (tb[TCA_KIND] == NULL) {
			strcat(buf, "" [unknown qdisc kind] "");
",unused,iprouteold-tc2Ftc_class.c
"			strcat(buf, "" [unknown qdisc kind] "");
		} else {
			const char *kind = rta_getattr_str(tb[TCA_KIND]);

			sprintf(str, "" %s "", kind);
",1,unused,257,unused,"			strcat(buf, "" [unknown qdisc kind] "");
		} else {
			const char *kind = rta_getattr_str(tb[TCA_KIND]);

			sprintf(str, "" %s "", kind);
",unused,iprouteold-tc2Ftc_class.c
"		} else {
			const char *kind = rta_getattr_str(tb[TCA_KIND]);

			sprintf(str, "" %s "", kind);
			strcat(buf, str);
",1,unused,258,unused,"		} else {
			const char *kind = rta_getattr_str(tb[TCA_KIND]);

			sprintf(str, "" %s "", kind);
			strcat(buf, str);
",unused,iprouteold-tc2Ftc_class.c
"					print_tcstats_attr(fp, tb, buf, &stats);
					buf[0] = '\0';
				}
				if (cls->hlist.next || cls->nodes_count) {
					strcat(buf, ""\n"");
",1,unused,279,unused,"					print_tcstats_attr(fp, tb, buf, &stats);
					buf[0] = '\0';
				}
				if (cls->hlist.next || cls->nodes_count) {
					strcat(buf, ""\n"");
",unused,iprouteold-tc2Ftc_class.c
"
		graph_cls_show(fp, buf, &children, level + 1);
		if (!cls->hlist.next) {
			graph_indent(buf, cls, 0, 0);
			strcat(buf, ""\n"");
",1,unused,291,unused,"
		graph_cls_show(fp, buf, &children, level + 1);
		if (!cls->hlist.next) {
			graph_indent(buf, cls, 0, 0);
			strcat(buf, ""\n"");
",unused,iprouteold-tc2Ftc_class.c
"	SPRINT_BUF(handle) = {};
	int hlen = SPRINT_BSIZE - 1;

	if (h == TC_H_ROOT)
		sprintf(handle, ""root"");
",1,unused,137,unused,"	SPRINT_BUF(handle) = {};
	int hlen = SPRINT_BSIZE - 1;

	if (h == TC_H_ROOT)
		sprintf(handle, ""root"");
",unused,iprouteold-tc2Ftc_util.c
"
char *sprint_tc_classid(__u32 h, char *buf)
{
	if (print_tc_classid(buf, SPRINT_BSIZE-1, h))
		strcpy(buf, ""???"");
",1,unused,164,unused,"
char *sprint_tc_classid(__u32 h, char *buf)
{
	if (print_tc_classid(buf, SPRINT_BSIZE-1, h))
		strcpy(buf, ""???"");
",unused,iprouteold-tc2Ftc_util.c
"		/* print the delimiter for every entry */
		if (i != applied)
			printf("","");

		sprintf(addr_str, ""%u.%u.%u:"", tipc_zone(members[i]),
",1,unused,619,unused,"		/* print the delimiter for every entry */
		if (i != applied)
			printf("","");

		sprintf(addr_str, ""%u.%u.%u:"", tipc_zone(members[i]),
",unused,iprouteold-tipc2Flink.c
"				      const uint32_t dom_gen)
{
	char addr_str[16];

	sprintf(addr_str, ""%u.%u.%u"", tipc_zone(addr), tipc_cluster(addr),
",1,unused,633,unused,"				      const uint32_t dom_gen)
{
	char addr_str[16];

	sprintf(addr_str, ""%u.%u.%u"", tipc_zone(addr), tipc_cluster(addr),
",unused,iprouteold-tipc2Flink.c
"
	mnl_attr_parse_nested(info[TIPC_NLA_MON_PEER], parse_attrs, attrs);

	(attrs[TIPC_NLA_MON_PEER_LOCAL] || attrs[TIPC_NLA_MON_PEER_HEAD]) ?
		strcpy(monitored, ""direct"") :
",1,unused,661,unused,"
	mnl_attr_parse_nested(info[TIPC_NLA_MON_PEER], parse_attrs, attrs);

	(attrs[TIPC_NLA_MON_PEER_LOCAL] || attrs[TIPC_NLA_MON_PEER_HEAD]) ?
		strcpy(monitored, ""direct"") :
",unused,iprouteold-tipc2Flink.c
"	mnl_attr_parse_nested(info[TIPC_NLA_MON_PEER], parse_attrs, attrs);

	(attrs[TIPC_NLA_MON_PEER_LOCAL] || attrs[TIPC_NLA_MON_PEER_HEAD]) ?
		strcpy(monitored, ""direct"") :
		strcpy(monitored, ""indirect"");
",1,unused,662,unused,"	mnl_attr_parse_nested(info[TIPC_NLA_MON_PEER], parse_attrs, attrs);

	(attrs[TIPC_NLA_MON_PEER_LOCAL] || attrs[TIPC_NLA_MON_PEER_HEAD]) ?
		strcpy(monitored, ""direct"") :
		strcpy(monitored, ""indirect"");
",unused,iprouteold-tipc2Flink.c
"		strcpy(monitored, ""direct"") :
		strcpy(monitored, ""indirect"");

	attrs[TIPC_NLA_MON_PEER_UP] ?
		strcpy(status, ""up"") :
",1,unused,665,unused,"		strcpy(monitored, ""direct"") :
		strcpy(monitored, ""indirect"");

	attrs[TIPC_NLA_MON_PEER_UP] ?
		strcpy(status, ""up"") :
",unused,iprouteold-tipc2Flink.c
"		strcpy(monitored, ""indirect"");

	attrs[TIPC_NLA_MON_PEER_UP] ?
		strcpy(status, ""up"") :
		strcpy(status, ""down"");
",1,unused,666,unused,"		strcpy(monitored, ""indirect"");

	attrs[TIPC_NLA_MON_PEER_UP] ?
		strcpy(status, ""up"") :
		strcpy(status, ""down"");
",unused,iprouteold-tipc2Flink.c
"
	if (s & NUD_REACHABLE)
		return """";

	sprintf(buf, ""state=%#x"", s);
",1,unused,58,unused,"
	if (s & NUD_REACHABLE)
		return """";

	sprintf(buf, ""state=%#x"", s);
",unused,iproutexen-bridge2Ffdb.c
"		memset(&p1, 0, sizeof(p1));
		ip6_tnl_parm_init(&p1, 0);
		if (type == ARPHRD_IP6GRE)
			p1.proto = IPPROTO_GRE;
		strcpy(p1.name, name);
",1,unused,402,unused,"		memset(&p1, 0, sizeof(p1));
		ip6_tnl_parm_init(&p1, 0);
		if (type == ARPHRD_IP6GRE)
			p1.proto = IPPROTO_GRE;
		strcpy(p1.name, name);
",unused,iproutexen-ip2Fip6tunnel.c
"		if (s < 0)
			return;

		memset(&ifr, 0, sizeof(ifr));
		strcpy(ifr.ifr_name, rta_getattr_str(tb[IFLA_IFNAME]));
",1,unused,184,unused,"		if (s < 0)
			return;

		memset(&ifr, 0, sizeof(ifr));
		strcpy(ifr.ifr_name, rta_getattr_str(tb[IFLA_IFNAME]));
",unused,iproutexen-ip2Fipaddress.c
"						    RTA_PAYLOAD(tb[RTA_SRC]),
						    RTA_DATA(tb[RTA_SRC]),
						    abuf, sizeof(abuf)));
	else
		len = sprintf(obuf, ""(unknown, "");
",1,unused,132,unused,"						    RTA_PAYLOAD(tb[RTA_SRC]),
						    RTA_DATA(tb[RTA_SRC]),
						    abuf, sizeof(abuf)));
	else
		len = sprintf(obuf, ""(unknown, "");
",unused,iproutexen-ip2Fipmroute.c
"		perror(""malloc"");
		return -ENOMEM;
	}
	c->nsid = nsid;
	strcpy(c->name, name);
",1,unused,181,unused,"		perror(""malloc"");
		return -ENOMEM;
	}
	c->nsid = nsid;
	strcpy(c->name, name);
",unused,iproutexen-ip2Fipnetns.c
"			continue;
		id = get_netnsid_from_name(entry->d_name);

		if (nsid == id) {
			strcpy(name, entry->d_name);
",1,unused,250,unused,"			continue;
		id = get_netnsid_from_name(entry->d_name);

		if (nsid == id) {
			strcpy(name, entry->d_name);
",unused,iproutexen-ip2Fipnetns.c
"	strftime(str, sizeof(str), ""%Y-%m-%d %T"", tp);

	return str;
 error:
	strcpy(str, ""(error)"");
",1,unused,348,unused,"	strftime(str, sizeof(str), ""%Y-%m-%d %T"", tp);

	return str;
 error:
	strcpy(str, ""(error)"");
",unused,iproutexen-ip2Fipntable.c
"	ssize_t len;
	int fd;
	long result;

	sprintf(fname, ""/sys/class/net/%s/%s"", dev, prop);
",1,unused,227,unused,"	ssize_t len;
	int fd;
	long result;

	sprintf(fname, ""/sys/class/net/%s/%s"", dev, prop);
",unused,iproutexen-ip2Fiptuntap.c
"		if (t->t_type == proto)
			return t->t_name;
	}

	sprintf(str, ""%u"", proto);
",1,unused,151,unused,"		if (t->t_type == proto)
			return t->t_name;
	}

	sprintf(str, ""%u"", proto);
",unused,iproutexen-ip2Fipxfrm.c
"		if (t->t_type == type)
			return t->t_name;
	}

	sprintf(str, ""%d"", type);
",1,unused,192,unused,"		if (t->t_type == type)
			return t->t_name;
	}

	sprintf(str, ""%d"", type);
",unused,iproutexen-ip2Fipxfrm.c
"const char *strxf_mask32(__u32 mask)
{
	static char str[16];

	sprintf(str, ""%.8x"", mask);
",1,unused,214,unused,"const char *strxf_mask32(__u32 mask)
{
	static char str[16];

	sprintf(str, ""%.8x"", mask);
",unused,iproutexen-ip2Fipxfrm.c
"	static char str[32];

	switch (share) {
	case XFRM_SHARE_ANY:
		strcpy(str, ""any"");
",1,unused,225,unused,"	static char str[32];

	switch (share) {
	case XFRM_SHARE_ANY:
		strcpy(str, ""any"");
",unused,iproutexen-ip2Fipxfrm.c
"	case XFRM_SHARE_ANY:
		strcpy(str, ""any"");
		break;
	case XFRM_SHARE_SESSION:
		strcpy(str, ""session"");
",1,unused,228,unused,"	case XFRM_SHARE_ANY:
		strcpy(str, ""any"");
		break;
	case XFRM_SHARE_SESSION:
		strcpy(str, ""session"");
",unused,iproutexen-ip2Fipxfrm.c
"	case XFRM_SHARE_SESSION:
		strcpy(str, ""session"");
		break;
	case XFRM_SHARE_USER:
		strcpy(str, ""user"");
",1,unused,231,unused,"	case XFRM_SHARE_SESSION:
		strcpy(str, ""session"");
		break;
	case XFRM_SHARE_USER:
		strcpy(str, ""user"");
",unused,iproutexen-ip2Fipxfrm.c
"	case XFRM_SHARE_USER:
		strcpy(str, ""user"");
		break;
	case XFRM_SHARE_UNIQUE:
		strcpy(str, ""unique"");
",1,unused,234,unused,"	case XFRM_SHARE_USER:
		strcpy(str, ""user"");
		break;
	case XFRM_SHARE_UNIQUE:
		strcpy(str, ""unique"");
",unused,iproutexen-ip2Fipxfrm.c
"	case XFRM_SHARE_UNIQUE:
		strcpy(str, ""unique"");
		break;
	default:
		sprintf(str, ""%u"", share);
",1,unused,237,unused,"	case XFRM_SHARE_UNIQUE:
		strcpy(str, ""unique"");
		break;
	default:
		sprintf(str, ""%u"", share);
",unused,iproutexen-ip2Fipxfrm.c
"	pp = getprotobynumber(proto);
	if (pp)
		p = pp->p_name;
	else {
		sprintf(buf, ""%u"", proto);
",1,unused,254,unused,"	pp = getprotobynumber(proto);
	if (pp)
		p = pp->p_name;
	else {
		sprintf(buf, ""%u"", proto);
",unused,iproutexen-ip2Fipxfrm.c
"	static char str[16];

	switch (ptype) {
	case XFRM_POLICY_TYPE_MAIN:
		strcpy(str, ""main"");
",1,unused,267,unused,"	static char str[16];

	switch (ptype) {
	case XFRM_POLICY_TYPE_MAIN:
		strcpy(str, ""main"");
",unused,iproutexen-ip2Fipxfrm.c
"	case XFRM_POLICY_TYPE_MAIN:
		strcpy(str, ""main"");
		break;
	case XFRM_POLICY_TYPE_SUB:
		strcpy(str, ""sub"");
",1,unused,270,unused,"	case XFRM_POLICY_TYPE_MAIN:
		strcpy(str, ""main"");
		break;
	case XFRM_POLICY_TYPE_SUB:
		strcpy(str, ""sub"");
",unused,iproutexen-ip2Fipxfrm.c
"	case XFRM_POLICY_TYPE_SUB:
		strcpy(str, ""sub"");
		break;
	default:
		sprintf(str, ""%u"", ptype);
",1,unused,273,unused,"	case XFRM_POLICY_TYPE_SUB:
		strcpy(str, ""sub"");
		break;
	default:
		sprintf(str, ""%u"", ptype);
",unused,iproutexen-ip2Fipxfrm.c
"static const char *strxf_limit(__u64 limit)
{
	static char str[32];
	if (limit == XFRM_INF)
		strcpy(str, ""(INF)"");
",1,unused,344,unused,"static const char *strxf_limit(__u64 limit)
{
	static char str[32];
	if (limit == XFRM_INF)
		strcpy(str, ""(INF)"");
",unused,iproutexen-ip2Fipxfrm.c
"	static char str[32];
	if (limit == XFRM_INF)
		strcpy(str, ""(INF)"");
	else
		sprintf(str, ""%llu"", (unsigned long long) limit);
",1,unused,346,unused,"	static char str[32];
	if (limit == XFRM_INF)
		strcpy(str, ""(INF)"");
	else
		sprintf(str, ""%llu"", (unsigned long long) limit);
",unused,iproutexen-ip2Fipxfrm.c
"{
	static char str[32];

	if (time == 0)
		strcpy(str, ""-"");
",1,unused,368,unused,"{
	static char str[32];

	if (time == 0)
		strcpy(str, ""-"");
",unused,iproutexen-ip2Fipxfrm.c
"		if (max > 16)
			max = 16;
		cookie[0] = 0;
		for (i = 0; i < max; i++)
			sprintf(cookie + i + i, ""%02x"", ptr[i]);
",1,unused,294,unused,"		if (max > 16)
			max = 16;
		cookie[0] = 0;
		for (i = 0; i < max; i++)
			sprintf(cookie + i + i, ""%02x"", ptr[i]);
",unused,iproutexen-ip2Ftcp_metrics.c
"	static char buf[16];

	switch (proto) {
	case IPPROTO_IPIP:
		strcpy(buf, ""ip"");
",1,unused,46,unused,"	static char buf[16];

	switch (proto) {
	case IPPROTO_IPIP:
		strcpy(buf, ""ip"");
",unused,iproutexen-ip2Ftunnel.c
"	case IPPROTO_IPIP:
		strcpy(buf, ""ip"");
		break;
	case IPPROTO_GRE:
		strcpy(buf, ""gre"");
",1,unused,49,unused,"	case IPPROTO_IPIP:
		strcpy(buf, ""ip"");
		break;
	case IPPROTO_GRE:
		strcpy(buf, ""gre"");
",unused,iproutexen-ip2Ftunnel.c
"	case IPPROTO_GRE:
		strcpy(buf, ""gre"");
		break;
	case IPPROTO_IPV6:
		strcpy(buf, ""ipv6"");
",1,unused,52,unused,"	case IPPROTO_GRE:
		strcpy(buf, ""gre"");
		break;
	case IPPROTO_IPV6:
		strcpy(buf, ""ipv6"");
",unused,iproutexen-ip2Ftunnel.c
"	case IPPROTO_IPV6:
		strcpy(buf, ""ipv6"");
		break;
	case IPPROTO_ESP:
		strcpy(buf, ""esp"");
",1,unused,55,unused,"	case IPPROTO_IPV6:
		strcpy(buf, ""ipv6"");
		break;
	case IPPROTO_ESP:
		strcpy(buf, ""esp"");
",unused,iproutexen-ip2Ftunnel.c
"	case IPPROTO_ESP:
		strcpy(buf, ""esp"");
		break;
	case 0:
		strcpy(buf, ""any"");
",1,unused,58,unused,"	case IPPROTO_ESP:
		strcpy(buf, ""esp"");
		break;
	case 0:
		strcpy(buf, ""any"");
",unused,iproutexen-ip2Ftunnel.c
"	case 0:
		strcpy(buf, ""any"");
		break;
	default:
		strcpy(buf, ""unknown"");
",1,unused,61,unused,"	case 0:
		strcpy(buf, ""any"");
		break;
	default:
		strcpy(buf, ""unknown"");
",unused,iproutexen-ip2Ftunnel.c
"		} else if (sscanf(p, ""0x%x %s\n"", id, name) != 2 &&
				sscanf(p, ""0x%x %s #"", id, name) != 2 &&
				sscanf(p, ""%d %s\n"", id, name) != 2 &&
				sscanf(p, ""%d %s #"", id, name) != 2) {
			strcpy(name, p);
",1,unused,44,unused,"		} else if (sscanf(p, ""0x%x %s\n"", id, name) != 2 &&
				sscanf(p, ""0x%x %s #"", id, name) != 2 &&
				sscanf(p, ""%d %s\n"", id, name) != 2 &&
				sscanf(p, ""%d %s #"", id, name) != 2) {
			strcpy(name, p);
",unused,iproutexen-lib2Fnames.c
"		if (sscanf(p, ""0x%x %s\n"", id, namebuf) != 2 &&
				sscanf(p, ""0x%x %s #"", id, namebuf) != 2 &&
				sscanf(p, ""%d %s\n"", id, namebuf) != 2 &&
				sscanf(p, ""%d %s #"", id, namebuf) != 2) {
			strcpy(namebuf, p);
",1,unused,55,unused,"		if (sscanf(p, ""0x%x %s\n"", id, namebuf) != 2 &&
				sscanf(p, ""0x%x %s #"", id, namebuf) != 2 &&
				sscanf(p, ""%d %s\n"", id, namebuf) != 2 &&
				sscanf(p, ""%d %s #"", id, namebuf) != 2) {
			strcpy(namebuf, p);
",unused,iproutexen-lib2Frt_names.c
"		snprintf(name, sizeof(name)-1, ""%s"", getenv(""PROC_NET_PSCHED""));
	} else if (getenv(""PROC_ROOT"")) {
		snprintf(name, sizeof(name)-1, ""%s/net/psched"", getenv(""PROC_ROOT""));
	} else {
		strcpy(name, ""/proc/net/psched"");
",1,unused,647,unused,"		snprintf(name, sizeof(name)-1, ""%s"", getenv(""PROC_NET_PSCHED""));
	} else if (getenv(""PROC_ROOT"")) {
		snprintf(name, sizeof(name)-1, ""%s/net/psched"", getenv(""PROC_ROOT""));
	} else {
		strcpy(name, ""/proc/net/psched"");
",unused,iproutexen-lib2Futils.c
"
	for (i=0; i<len; i++) {
		if (blen < 3)
			break;
		sprintf(ptr, ""%02x"", str[i]);
",1,unused,812,unused,"
	for (i=0; i<len; i++) {
		if (blen < 3)
			break;
		sprintf(ptr, ""%02x"", str[i]);
",unused,iproutexen-lib2Futils.c
"			*lenp = 0;
			return -1;
		}
		cc += cc1 - 2;
		strcat(*linep, line1);
",1,unused,906,unused,"			*lenp = 0;
			return -1;
		}
		cc += cc1 - 2;
		strcat(*linep, line1);
",unused,iproutexen-lib2Futils.c
"}

char *int_to_str(int val, char *buf)
{
	sprintf(buf, ""%d"", val);
",1,unused,997,unused,"}

char *int_to_str(int val, char *buf)
{
	sprintf(buf, ""%d"", val);
",unused,iproutexen-lib2Futils.c
"		char buf[128];
		FILE *fp;

		if (active_probing) {
			sprintf(buf, ""/proc/sys/net/ipv4/neigh/%s/mcast_solicit"", ifnames[i]);
",1,unused,131,unused,"		char buf[128];
		FILE *fp;

		if (active_probing) {
			sprintf(buf, ""/proc/sys/net/ipv4/neigh/%s/mcast_solicit"", ifnames[i]);
",unused,iproutexen-misc2Farpd.c
"		if (active_probing) {
			sprintf(buf, ""/proc/sys/net/ipv4/neigh/%s/mcast_solicit"", ifnames[i]);
			if ((fp = fopen(buf, ""w"")) != NULL) {
				if (no_kernel_broadcasts)
					strcpy(buf, ""0\n"");
",1,unused,134,unused,"		if (active_probing) {
			sprintf(buf, ""/proc/sys/net/ipv4/neigh/%s/mcast_solicit"", ifnames[i]);
			if ((fp = fopen(buf, ""w"")) != NULL) {
				if (no_kernel_broadcasts)
					strcpy(buf, ""0\n"");
",unused,iproutexen-misc2Farpd.c
"			if ((fp = fopen(buf, ""w"")) != NULL) {
				if (no_kernel_broadcasts)
					strcpy(buf, ""0\n"");
				else
					sprintf(buf, ""%d\n"", active_probing>=2 ? 1 : 3-active_probing);
",1,unused,136,unused,"			if ((fp = fopen(buf, ""w"")) != NULL) {
				if (no_kernel_broadcasts)
					strcpy(buf, ""0\n"");
				else
					sprintf(buf, ""%d\n"", active_probing>=2 ? 1 : 3-active_probing);
",unused,iproutexen-misc2Farpd.c
"				fclose(fp);
			}
		}

		sprintf(buf, ""/proc/sys/net/ipv4/neigh/%s/app_solicit"", ifnames[i]);
",1,unused,142,unused,"				fclose(fp);
			}
		}

		sprintf(buf, ""/proc/sys/net/ipv4/neigh/%s/app_solicit"", ifnames[i]);
",unused,iproutexen-misc2Farpd.c
"		}

		sprintf(buf, ""/proc/sys/net/ipv4/neigh/%s/app_solicit"", ifnames[i]);
		if ((fp = fopen(buf, ""w"")) != NULL) {
			sprintf(buf, ""%d\n"", active_probing<=1 ? 1 : active_probing);
",1,unused,144,unused,"		}

		sprintf(buf, ""/proc/sys/net/ipv4/neigh/%s/app_solicit"", ifnames[i]);
		if ((fp = fopen(buf, ""w"")) != NULL) {
			sprintf(buf, ""%d\n"", active_probing<=1 ? 1 : active_probing);
",unused,iproutexen-misc2Farpd.c
"		char buf[128];
		FILE *fp;

		if (active_probing) {
			sprintf(buf, ""/proc/sys/net/ipv4/neigh/%s/mcast_solicit"", ifnames[i]);
",1,unused,164,unused,"		char buf[128];
		FILE *fp;

		if (active_probing) {
			sprintf(buf, ""/proc/sys/net/ipv4/neigh/%s/mcast_solicit"", ifnames[i]);
",unused,iproutexen-misc2Farpd.c
"
		if (active_probing) {
			sprintf(buf, ""/proc/sys/net/ipv4/neigh/%s/mcast_solicit"", ifnames[i]);
			if ((fp = fopen(buf, ""w"")) != NULL) {
				strcpy(buf, ""3\n"");
",1,unused,166,unused,"
		if (active_probing) {
			sprintf(buf, ""/proc/sys/net/ipv4/neigh/%s/mcast_solicit"", ifnames[i]);
			if ((fp = fopen(buf, ""w"")) != NULL) {
				strcpy(buf, ""3\n"");
",unused,iproutexen-misc2Farpd.c
"				fputs(buf, fp);
				fclose(fp);
			}
		}
		sprintf(buf, ""/proc/sys/net/ipv4/neigh/%s/app_solicit"", ifnames[i]);
",1,unused,171,unused,"				fputs(buf, fp);
				fclose(fp);
			}
		}
		sprintf(buf, ""/proc/sys/net/ipv4/neigh/%s/app_solicit"", ifnames[i]);
",unused,iproutexen-misc2Farpd.c
"			}
		}
		sprintf(buf, ""/proc/sys/net/ipv4/neigh/%s/app_solicit"", ifnames[i]);
		if ((fp = fopen(buf, ""w"")) != NULL) {
			strcpy(buf, ""0\n"");
",1,unused,173,unused,"			}
		}
		sprintf(buf, ""/proc/sys/net/ipv4/neigh/%s/app_solicit"", ifnames[i]);
		if ((fp = fopen(buf, ""w"")) != NULL) {
			strcpy(buf, ""0\n"");
",unused,iproutexen-misc2Farpd.c
"	else
		fprintf(fp, ""%8llu "", vals[i]);

	if (rates[i] > mega) {
		sprintf(temp, ""%uM"", (unsigned)(rates[i]/mega));
",1,unused,311,unused,"	else
		fprintf(fp, ""%8llu "", vals[i]);

	if (rates[i] > mega) {
		sprintf(temp, ""%uM"", (unsigned)(rates[i]/mega));
",unused,iproutexen-misc2Fifstat.c
"	if (rates[i] > mega) {
		sprintf(temp, ""%uM"", (unsigned)(rates[i]/mega));
		fprintf(fp, ""%-6s "", temp);
	} else if (rates[i] > kilo) {
		sprintf(temp, ""%uK"", (unsigned)(rates[i]/kilo));
",1,unused,314,unused,"	if (rates[i] > mega) {
		sprintf(temp, ""%uM"", (unsigned)(rates[i]/mega));
		fprintf(fp, ""%-6s "", temp);
	} else if (rates[i] > kilo) {
		sprintf(temp, ""%uK"", (unsigned)(rates[i]/kilo));
",unused,iproutexen-misc2Fifstat.c
"	else
		fprintf(fp, ""%8llu "", vals[i]);

	if (vals[k] > giga) {
		sprintf(temp, ""%uM"", (unsigned)(vals[k]/mega));
",1,unused,331,unused,"	else
		fprintf(fp, ""%8llu "", vals[i]);

	if (vals[k] > giga) {
		sprintf(temp, ""%uM"", (unsigned)(vals[k]/mega));
",unused,iproutexen-misc2Fifstat.c
"	if (vals[k] > giga) {
		sprintf(temp, ""%uM"", (unsigned)(vals[k]/mega));
		fprintf(fp, ""%-6s "", temp);
	} else if (vals[k] > mega) {
		sprintf(temp, ""%uK"", (unsigned)(vals[k]/kilo));
",1,unused,334,unused,"	if (vals[k] > giga) {
		sprintf(temp, ""%uM"", (unsigned)(vals[k]/mega));
		fprintf(fp, ""%-6s "", temp);
	} else if (vals[k] > mega) {
		sprintf(temp, ""%uK"", (unsigned)(vals[k]/kilo));
",unused,iproutexen-misc2Fifstat.c
"	struct pollfd p;
	p.fd = fd;
	p.events = p.revents = POLLIN;

	sprintf(info_source, ""%d.%lu sampling_interval=%d time_const=%d"",
",1,unused,585,unused,"	struct pollfd p;
	p.fd = fd;
	p.events = p.revents = POLLIN;

	sprintf(info_source, ""%d.%lu sampling_interval=%d time_const=%d"",
",unused,iproutexen-misc2Fifstat.c
"	argv += optind;

	sun.sun_family = AF_UNIX;
	sun.sun_path[0] = 0;
	sprintf(sun.sun_path+1, ""ifstat%d"", getuid());
",1,unused,746,unused,"	argv += optind;

	sun.sun_family = AF_UNIX;
	sun.sun_path[0] = 0;
	sprintf(sun.sun_path+1, ""ifstat%d"", getuid());
",unused,iproutexen-misc2Fifstat.c
"	}

	if ((fd = socket(AF_UNIX, SOCK_STREAM, 0)) >= 0 &&
	    (connect(fd, (struct sockaddr*)&sun, 2+1+strlen(sun.sun_path+1)) == 0
	     || (strcpy(sun.sun_path+1, ""ifstat0""),
",1,unused,834,unused,"	}

	if ((fd = socket(AF_UNIX, SOCK_STREAM, 0)) >= 0 &&
	    (connect(fd, (struct sockaddr*)&sun, 2+1+strlen(sun.sun_path+1)) == 0
	     || (strcpy(sun.sun_path+1, ""ifstat0""),
",unused,iproutexen-misc2Fifstat.c
"			info_source[0] = 0;
		}
		load_info();
		if (info_source[0] == 0)
			strcpy(info_source, ""kernel"");
",1,unused,854,unused,"			info_source[0] = 0;
		}
		load_info();
		if (info_source[0] == 0)
			strcpy(info_source, ""kernel"");
",unused,iproutexen-misc2Fifstat.c
"	/* initialize */
	memset(lf, 0, sizeof(*lf));

	/* de->d_name is guaranteed to be <= NAME_MAX */
	strcpy(lf->basename, file);
",1,unused,185,unused,"	/* initialize */
	memset(lf, 0, sizeof(*lf));

	/* de->d_name is guaranteed to be <= NAME_MAX */
	strcpy(lf->basename, file);
",unused,iproutexen-misc2Flnstat_util.c
"	memset(lf, 0, sizeof(*lf));

	/* de->d_name is guaranteed to be <= NAME_MAX */
	strcpy(lf->basename, file);
	strcpy(lf->path, path);
",1,unused,186,unused,"	memset(lf, 0, sizeof(*lf));

	/* de->d_name is guaranteed to be <= NAME_MAX */
	strcpy(lf->basename, file);
	strcpy(lf->path, path);
",unused,iproutexen-misc2Flnstat_util.c
"
	/* de->d_name is guaranteed to be <= NAME_MAX */
	strcpy(lf->basename, file);
	strcpy(lf->path, path);
	strcat(lf->path, ""/"");
",1,unused,187,unused,"
	/* de->d_name is guaranteed to be <= NAME_MAX */
	strcpy(lf->basename, file);
	strcpy(lf->path, path);
	strcat(lf->path, ""/"");
",unused,iproutexen-misc2Flnstat_util.c
"	/* de->d_name is guaranteed to be <= NAME_MAX */
	strcpy(lf->basename, file);
	strcpy(lf->path, path);
	strcat(lf->path, ""/"");
	strcat(lf->path, lf->basename);
",1,unused,188,unused,"	/* de->d_name is guaranteed to be <= NAME_MAX */
	strcpy(lf->basename, file);
	strcpy(lf->path, path);
	strcat(lf->path, ""/"");
	strcat(lf->path, lf->basename);
",unused,iproutexen-misc2Flnstat_util.c
"	struct pollfd p;
	p.fd = fd;
	p.events = p.revents = POLLIN;

	sprintf(info_source, ""%d.%lu sampling_interval=%d time_const=%d"",
",1,unused,427,unused,"	struct pollfd p;
	p.fd = fd;
	p.events = p.revents = POLLIN;

	sprintf(info_source, ""%d.%lu sampling_interval=%d time_const=%d"",
",unused,iproutexen-misc2Fnstat.c
"	argv += optind;

	sun.sun_family = AF_UNIX;
	sun.sun_path[0] = 0;
	sprintf(sun.sun_path+1, ""nstat%d"", getuid());
",1,unused,578,unused,"	argv += optind;

	sun.sun_family = AF_UNIX;
	sun.sun_path[0] = 0;
	sprintf(sun.sun_path+1, ""nstat%d"", getuid());
",unused,iproutexen-misc2Fnstat.c
"	npatterns = argc;

	if ((hist_name = getenv(""NSTAT_HISTORY"")) == NULL) {
		hist_name = malloc(128);
		sprintf(hist_name, ""/tmp/.nstat.u%d"", getuid());
",1,unused,612,unused,"	npatterns = argc;

	if ((hist_name = getenv(""NSTAT_HISTORY"")) == NULL) {
		hist_name = malloc(128);
		sprintf(hist_name, ""/tmp/.nstat.u%d"", getuid());
",unused,iproutexen-misc2Fnstat.c
"	}

	if ((fd = socket(AF_UNIX, SOCK_STREAM, 0)) >= 0 &&
	    (connect(fd, (struct sockaddr*)&sun, 2+1+strlen(sun.sun_path+1)) == 0
	     || (strcpy(sun.sun_path+1, ""nstat0""),
",1,unused,664,unused,"	}

	if ((fd = socket(AF_UNIX, SOCK_STREAM, 0)) >= 0 &&
	    (connect(fd, (struct sockaddr*)&sun, 2+1+strlen(sun.sun_path+1)) == 0
	     || (strcpy(sun.sun_path+1, ""nstat0""),
",unused,iproutexen-misc2Fnstat.c
"		load_netstat();
		load_snmp6();
		load_snmp();
		if (info_source[0] == 0)
			strcpy(info_source, ""kernel"");
",1,unused,686,unused,"		load_netstat();
		load_snmp6();
		load_snmp();
		if (info_source[0] == 0)
			strcpy(info_source, ""kernel"");
",unused,iproutexen-misc2Fnstat.c
"{
	char temp[64];

	if (rate > 1024*1024) {
		sprintf(temp, ""%uM"", (unsigned)rint(rate/(1024*1024)));
",1,unused,137,unused,"{
	char temp[64];

	if (rate > 1024*1024) {
		sprintf(temp, ""%uM"", (unsigned)rint(rate/(1024*1024)));
",unused,iproutexen-misc2Frtacct.c
"	if (rate > 1024*1024) {
		sprintf(temp, ""%uM"", (unsigned)rint(rate/(1024*1024)));
		fprintf(fp, "" %-10s"", temp);
	} else if (rate > 1024) {
		sprintf(temp, ""%uK"", (unsigned)rint(rate/1024));
",1,unused,140,unused,"	if (rate > 1024*1024) {
		sprintf(temp, ""%uM"", (unsigned)rint(rate/(1024*1024)));
		fprintf(fp, "" %-10s"", temp);
	} else if (rate > 1024) {
		sprintf(temp, ""%uK"", (unsigned)rint(rate/1024));
",unused,iproutexen-misc2Frtacct.c
"	struct pollfd p;
	p.fd = fd;
	p.events = p.revents = POLLIN;

	sprintf(kern_db->signature,
",1,unused,370,unused,"	struct pollfd p;
	p.fd = fd;
	p.events = p.revents = POLLIN;

	sprintf(kern_db->signature,
",unused,iproutexen-misc2Frtacct.c
"	}

	sun.sun_family = AF_UNIX;
	sun.sun_path[0] = 0;
	sprintf(sun.sun_path+1, ""rtacct%d"", getuid());
",1,unused,507,unused,"	}

	sun.sun_family = AF_UNIX;
	sun.sun_path[0] = 0;
	sprintf(sun.sun_path+1, ""rtacct%d"", getuid());
",unused,iproutexen-misc2Frtacct.c
"
	if (getenv(""RTACCT_HISTORY""))
		snprintf(hist_name, sizeof(hist_name), ""%s"", getenv(""RTACCT_HISTORY""));
	else
		sprintf(hist_name, ""/tmp/.rtacct.u%d"", getuid());
",1,unused,539,unused,"
	if (getenv(""RTACCT_HISTORY""))
		snprintf(hist_name, sizeof(hist_name), ""%s"", getenv(""RTACCT_HISTORY""));
	else
		sprintf(hist_name, ""/tmp/.rtacct.u%d"", getuid());
",unused,iproutexen-misc2Frtacct.c
"	}

	if ((fd = socket(AF_UNIX, SOCK_STREAM, 0)) >= 0 &&
	    (connect(fd, (struct sockaddr*)&sun, 2+1+strlen(sun.sun_path+1)) == 0
	     || (strcpy(sun.sun_path+1, ""rtacct0""),
",1,unused,600,unused,"	}

	if ((fd = socket(AF_UNIX, SOCK_STREAM, 0)) >= 0 &&
	    (connect(fd, (struct sockaddr*)&sun, 2+1+strlen(sun.sun_path+1)) == 0
	     || (strcpy(sun.sun_path+1, ""rtacct0""),
",unused,iproutexen-misc2Frtacct.c
"			hist_db = NULL;
		}

		pad_kern_table(kern_db, read_kern_table(kern_db->ival));
		strcpy(kern_db->signature, ""kernel"");
",1,unused,621,unused,"			hist_db = NULL;
		}

		pad_kern_table(kern_db, read_kern_table(kern_db->ival));
		strcpy(kern_db->signature, ""kernel"");
",unused,iproutexen-misc2Frtacct.c
"	strncpy(name, root, sizeof(name)-1);
	name[sizeof(name)-1] = 0;

	if (strlen(name) == 0 || name[strlen(name)-1] != '/')
		strcat(name, ""/"");
",1,unused,464,unused,"	strncpy(name, root, sizeof(name)-1);
	name[sizeof(name)-1] = 0;

	if (strlen(name) == 0 || name[strlen(name)-1] != '/')
		strcat(name, ""/"");
",unused,iproutexen-misc2Fss.c
"	}
	if (secs) {
		if (secs > 9)
			msecs = 0;
		sprintf(buf+strlen(buf), ""%d%s"", secs, msecs ? ""."" : ""sec"");
",1,unused,853,unused,"	}
	if (secs) {
		if (secs > 9)
			msecs = 0;
		sprintf(buf+strlen(buf), ""%d%s"", secs, msecs ? ""."" : ""sec"");
",unused,iproutexen-misc2Fss.c
"			msecs = 0;
		sprintf(buf+strlen(buf), ""%d%s"", secs, msecs ? ""."" : ""sec"");
	}
	if (msecs)
		sprintf(buf+strlen(buf), ""%03dms"", msecs);
",1,unused,856,unused,"			msecs = 0;
		sprintf(buf+strlen(buf), ""%d%s"", secs, msecs ? ""."" : ""sec"");
	}
	if (msecs)
		sprintf(buf+strlen(buf), ""%03dms"", msecs);
",unused,iproutexen-misc2Fss.c
"	if (c->name)
		return c->name;

do_numeric:
	sprintf(buf, ""%u"", port);
",1,unused,995,unused,"	if (c->name)
		return c->name;

do_numeric:
	sprintf(buf, ""%u"", port);
",unused,iproutexen-misc2Fss.c
"
static char *sprint_bw(char *buf, double bw)
{
	if (bw > 1000000.)
		sprintf(buf,""%.1fM"", bw / 1000000.);
",1,unused,1641,unused,"
static char *sprint_bw(char *buf, double bw)
{
	if (bw > 1000000.)
		sprintf(buf,""%.1fM"", bw / 1000000.);
",unused,iproutexen-misc2Fss.c
"{
	if (bw > 1000000.)
		sprintf(buf,""%.1fM"", bw / 1000000.);
	else if (bw > 1000.)
		sprintf(buf,""%.1fK"", bw / 1000.);
",1,unused,1643,unused,"{
	if (bw > 1000000.)
		sprintf(buf,""%.1fM"", bw / 1000000.);
	else if (bw > 1000.)
		sprintf(buf,""%.1fK"", bw / 1000.);
",unused,iproutexen-misc2Fss.c
"		sprintf(buf,""%.1fM"", bw / 1000000.);
	else if (bw > 1000.)
		sprintf(buf,""%.1fK"", bw / 1000.);
	else
		sprintf(buf, ""%g"", bw);
",1,unused,1645,unused,"		sprintf(buf,""%.1fM"", bw / 1000000.);
	else if (bw > 1000.)
		sprintf(buf,""%.1fK"", bw / 1000.);
	else
		sprintf(buf, ""%g"", bw);
",unused,iproutexen-misc2Fss.c
"
		if (name[0]) {
			if ((u->name = malloc(strlen(name)+1)) == NULL)
				break;
			strcpy(u->name, name);
",1,unused,2784,unused,"
		if (name[0]) {
			if ((u->name = malloc(strlen(name)+1)) == NULL)
				break;
			strcpy(u->name, name);
",unused,iproutexen-misc2Fss.c
"				int type = map_type(*p);

				switch (type) {
					case TCF_META_TYPE_INT:
						strcat(buf, ""INT"");
",1,unused,209,unused,"				int type = map_type(*p);

				switch (type) {
					case TCF_META_TYPE_INT:
						strcat(buf, ""INT"");
",unused,iproutexen-tc2Fem_meta.c
"						strcat(buf, ""INT"");
						break;

					case TCF_META_TYPE_VAR:
						strcat(buf, ""VAR"");
",1,unused,213,unused,"						strcat(buf, ""INT"");
						break;

					case TCF_META_TYPE_VAR:
						strcat(buf, ""VAR"");
",unused,iproutexen-tc2Fem_meta.c
"						break;
				}

				if (*(++p))
					strcat(buf, "","");
",1,unused,218,unused,"						break;
				}

				if (*(++p))
					strcat(buf, "","");
",unused,iproutexen-tc2Fem_meta.c
"noexist:
#ifdef CONFIG_GACT
	if (!looked4gact) {
		looked4gact = 1;
		strcpy(str,""gact"");
",1,unused,125,unused,"noexist:
#ifdef CONFIG_GACT
	if (!looked4gact) {
		looked4gact = 1;
		strcpy(str,""gact"");
",unused,iproutexen-tc2Fm_action.c
"
	if (NULL == t) {
		target->t = xtables_calloc(1, size);
		target->t->u.target_size = size;
		strcpy(target->t->u.user.name, target->name);
",1,unused,93,unused,"
	if (NULL == t) {
		target->t = xtables_calloc(1, size);
		target->t->u.target_size = size;
		strcpy(target->t->u.user.name, target->name);
",unused,iproutexen-tc2Fm_xt.c
"	q = malloc(sizeof(*q));
	if (q) {

		memset(q, 0, sizeof(*q));
		q->id = strcpy(malloc(strlen(str)+1), str);
",1,unused,139,unused,"	q = malloc(sizeof(*q));
	if (q) {

		memset(q, 0, sizeof(*q));
		q->id = strcpy(malloc(strlen(str)+1), str);
",unused,iproutexen-tc2Ftc.c
"		node = node->parent_node;
	}
	while (node && node->right_node) {
		if (node->hlist.next)
			strcat(buf, ""|    "");
",1,unused,198,unused,"		node = node->parent_node;
	}
	while (node && node->right_node) {
		if (node->hlist.next)
			strcat(buf, ""|    "");
",unused,iproutexen-tc2Ftc_class.c
"	while (node && node->right_node) {
		if (node->hlist.next)
			strcat(buf, ""|    "");
		else
			strcat(buf, ""     "");
",1,unused,200,unused,"	while (node && node->right_node) {
		if (node->hlist.next)
			strcat(buf, ""|    "");
		else
			strcat(buf, ""     "");
",unused,iproutexen-tc2Ftc_class.c
"	}

	if (is_newline) {
		if (node->hlist.next && node->nodes_count)
			strcat(buf, ""|    |"");
",1,unused,207,unused,"	}

	if (is_newline) {
		if (node->hlist.next && node->nodes_count)
			strcat(buf, ""|    |"");
",unused,iproutexen-tc2Ftc_class.c
"	if (is_newline) {
		if (node->hlist.next && node->nodes_count)
			strcat(buf, ""|    |"");
		else if (node->hlist.next)
			strcat(buf, ""|     "");
",1,unused,209,unused,"	if (is_newline) {
		if (node->hlist.next && node->nodes_count)
			strcat(buf, ""|    |"");
		else if (node->hlist.next)
			strcat(buf, ""|     "");
",unused,iproutexen-tc2Ftc_class.c
"			strcat(buf, ""|    |"");
		else if (node->hlist.next)
			strcat(buf, ""|     "");
		else if (node->nodes_count)
			strcat(buf, ""     |"");
",1,unused,211,unused,"			strcat(buf, ""|    |"");
		else if (node->hlist.next)
			strcat(buf, ""|     "");
		else if (node->nodes_count)
			strcat(buf, ""     |"");
",unused,iproutexen-tc2Ftc_class.c
"			strcat(buf, ""|     "");
		else if (node->nodes_count)
			strcat(buf, ""     |"");
		else if (!node->hlist.next)
			strcat(buf, ""      "");
",1,unused,213,unused,"			strcat(buf, ""|     "");
		else if (node->nodes_count)
			strcat(buf, ""     |"");
		else if (!node->hlist.next)
			strcat(buf, ""      "");
",unused,iproutexen-tc2Ftc_class.c
"		else if (!node->hlist.next)
			strcat(buf, ""      "");
	}
	if (add_spaces > 0) {
		sprintf(spaces, ""%-*s"", add_spaces, """");
",1,unused,216,unused,"		else if (!node->hlist.next)
			strcat(buf, ""      "");
	}
	if (add_spaces > 0) {
		sprintf(spaces, ""%-*s"", add_spaces, """");
",unused,iproutexen-tc2Ftc_class.c
"			strcat(buf, ""      "");
	}
	if (add_spaces > 0) {
		sprintf(spaces, ""%-*s"", add_spaces, """");
		strcat(buf, spaces);
",1,unused,217,unused,"			strcat(buf, ""      "");
	}
	if (add_spaces > 0) {
		sprintf(spaces, ""%-*s"", add_spaces, """");
		strcat(buf, spaces);
",unused,iproutexen-tc2Ftc_class.c
"
		graph_indent(buf, cls, 0, 0);

		print_tc_classid(cls_id_str, sizeof(cls_id_str), cls->id);
		sprintf(str, ""+---(%s)"", cls_id_str);
",1,unused,251,unused,"
		graph_indent(buf, cls, 0, 0);

		print_tc_classid(cls_id_str, sizeof(cls_id_str), cls->id);
		sprintf(str, ""+---(%s)"", cls_id_str);
",unused,iproutexen-tc2Ftc_class.c
"		graph_indent(buf, cls, 0, 0);

		print_tc_classid(cls_id_str, sizeof(cls_id_str), cls->id);
		sprintf(str, ""+---(%s)"", cls_id_str);
		strcat(buf, str);
",1,unused,252,unused,"		graph_indent(buf, cls, 0, 0);

		print_tc_classid(cls_id_str, sizeof(cls_id_str), cls->id);
		sprintf(str, ""+---(%s)"", cls_id_str);
		strcat(buf, str);
",unused,iproutexen-tc2Ftc_class.c
"		parse_rtattr(tb, TCA_MAX, (struct rtattr *)cls->data,
				cls->data_len);

		if (tb[TCA_KIND] == NULL) {
			strcat(buf, "" [unknown qdisc kind] "");
",1,unused,258,unused,"		parse_rtattr(tb, TCA_MAX, (struct rtattr *)cls->data,
				cls->data_len);

		if (tb[TCA_KIND] == NULL) {
			strcat(buf, "" [unknown qdisc kind] "");
",unused,iproutexen-tc2Ftc_class.c
"			strcat(buf, "" [unknown qdisc kind] "");
		} else {
			const char *kind = rta_getattr_str(tb[TCA_KIND]);

			sprintf(str, "" %s "", kind);
",1,unused,262,unused,"			strcat(buf, "" [unknown qdisc kind] "");
		} else {
			const char *kind = rta_getattr_str(tb[TCA_KIND]);

			sprintf(str, "" %s "", kind);
",unused,iproutexen-tc2Ftc_class.c
"		} else {
			const char *kind = rta_getattr_str(tb[TCA_KIND]);

			sprintf(str, "" %s "", kind);
			strcat(buf, str);
",1,unused,263,unused,"		} else {
			const char *kind = rta_getattr_str(tb[TCA_KIND]);

			sprintf(str, "" %s "", kind);
			strcat(buf, str);
",unused,iproutexen-tc2Ftc_class.c
"					print_tcstats_attr(fp, tb, buf, &stats);
					buf[0] = '\0';
				}
				if (cls->hlist.next || cls->nodes_count) {
					strcat(buf, ""\n"");
",1,unused,284,unused,"					print_tcstats_attr(fp, tb, buf, &stats);
					buf[0] = '\0';
				}
				if (cls->hlist.next || cls->nodes_count) {
					strcat(buf, ""\n"");
",unused,iproutexen-tc2Ftc_class.c
"
		graph_cls_show(fp, buf, &children, level + 1);
		if (!cls->hlist.next) {
			graph_indent(buf, cls, 0, 0);
			strcat(buf, ""\n"");
",1,unused,296,unused,"
		graph_cls_show(fp, buf, &children, level + 1);
		if (!cls->hlist.next) {
			graph_indent(buf, cls, 0, 0);
			strcat(buf, ""\n"");
",unused,iproutexen-tc2Ftc_class.c
"	SPRINT_BUF(handle) = {};
	int hlen = SPRINT_BSIZE - 1;

	if (h == TC_H_ROOT)
		sprintf(handle, ""root"");
",1,unused,137,unused,"	SPRINT_BUF(handle) = {};
	int hlen = SPRINT_BSIZE - 1;

	if (h == TC_H_ROOT)
		sprintf(handle, ""root"");
",unused,iproutexen-tc2Ftc_util.c
"
char *sprint_tc_classid(__u32 h, char *buf)
{
	if (print_tc_classid(buf, SPRINT_BSIZE-1, h))
		strcpy(buf, ""???"");
",1,unused,164,unused,"
char *sprint_tc_classid(__u32 h, char *buf)
{
	if (print_tc_classid(buf, SPRINT_BSIZE-1, h))
		strcpy(buf, ""???"");
",unused,iproutexen-tc2Ftc_util.c
"						&manager->threads[i],
						&manager->threads[i].thread)
			      == ISC_R_SUCCESS);
		char tname[1024];
		sprintf(tname, ""isc-socket-%d"", i);
",1,unused,3950,unused,"						&manager->threads[i],
						&manager->threads[i].thread)
			      == ISC_R_SUCCESS);
		char tname[1024];
		sprintf(tname, ""isc-socket-%d"", i);
",unused,isc-projects_bind9-lib2Fisc2Funix2Fsocket.c
"		}
		fprintf(fp, ""!%s\t%s\t"", this_var->di_key, s);
		if (this_var->di_tv.v_type == VAR_SPECIAL)
		{
		    sprintf((char *)numbuf, ""%ld"",
",1,unused,9109,unused,"		}
		fprintf(fp, ""!%s\t%s\t"", this_var->di_key, s);
		if (this_var->di_tv.v_type == VAR_SPECIAL)
		{
		    sprintf((char *)numbuf, ""%ld"",
",unused,jonbriem_vim-src2Feval.c
"	    /* Expand s: and <SID> into <SNR>nr_, so that the function can
	     * also be called from another script. Using trans_function_name()
	     * would also work, but some plugins depend on the name being
	     * printable text. */
	    sprintf(sid_buf, ""<SNR>%ld_"", (long)current_sctx.sc_sid);
",1,unused,4208,unused,"	    /* Expand s: and <SID> into <SNR>nr_, so that the function can
	     * also be called from another script. Using trans_function_name()
	     * would also work, but some plugins depend on the name being
	     * printable text. */
	    sprintf(sid_buf, ""<SNR>%ld_"", (long)current_sctx.sc_sid);
",unused,jonbriem_vim-src2Fevalfunc.c
"		{
		    *errormsg = _(""E961: no line number to use for \""<sflnum>\"""");
		    return NULL;
		}
		sprintf((char *)strbuf, ""%ld"",
",1,unused,11017,unused,"		{
		    *errormsg = _(""E961: no line number to use for \""<sflnum>\"""");
		    return NULL;
		}
		sprintf((char *)strbuf, ""%ld"",
",unused,jonbriem_vim-src2Fex_docmd.c
"	    if (!helpmesg)
		mesg2 = """";
	    tbuf = (char *)alloc((unsigned)(STRLEN(path) + STRLEN(mesg)
							+ STRLEN(mesg2) + 2));
	    sprintf(tbuf, mesg, path);
",1,unused,6899,unused,"	    if (!helpmesg)
		mesg2 = """";
	    tbuf = (char *)alloc((unsigned)(STRLEN(path) + STRLEN(mesg)
							+ STRLEN(mesg2) + 2));
	    sprintf(tbuf, mesg, path);
",unused,jonbriem_vim-src2Ffileio.c
"	vim_snprintf((char *)p, IOSIZE - (p - IObuff),
		""%ldL, %lldC"", lnum, (long_long_T)nchars);
    else
    {
	sprintf((char *)p, NGETTEXT(""%ld line, "", ""%ld lines, "", lnum), lnum);
",1,unused,5251,unused,"	vim_snprintf((char *)p, IOSIZE - (p - IObuff),
		""%ldL, %lldC"", lnum, (long_long_T)nchars);
    else
    {
	sprintf((char *)p, NGETTEXT(""%ld line, "", ""%ld lines, "", lnum), lnum);
",unused,jonbriem_vim-src2Ffileio.c
"msg_outnum(long n)
{
    char	buf[20];

    sprintf(buf, ""%ld"", n);
",1,unused,1406,unused,"msg_outnum(long n)
{
    char	buf[20];

    sprintf(buf, ""%ld"", n);
",unused,jonbriem_vim-src2Fmessage.c
"		if (!VIM_ISDIGIT(*(s - 1)))
		{
		    if (errbuf != NULL)
		    {
			sprintf(errbuf, _(""E526: Missing number after <%s>""),
",1,unused,6751,unused,"		if (!VIM_ISDIGIT(*(s - 1)))
		{
		    if (errbuf != NULL)
		    {
			sprintf(errbuf, _(""E526: Missing number after <%s>""),
",unused,jonbriem_vim-src2Foption.c
"	len += (unsigned)STRLEN(p_sp) + (unsigned)STRLEN(fname) + 3;
    cmd = alloc(len);
    if (cmd == NULL)
	return NULL;
    sprintf((char *)cmd, ""%s%s%s"", (char *)p_shq, (char *)makecmd,
",1,unused,4694,unused,"	len += (unsigned)STRLEN(p_sp) + (unsigned)STRLEN(fname) + 3;
    cmd = alloc(len);
    if (cmd == NULL)
	return NULL;
    sprintf((char *)cmd, ""%s%s%s"", (char *)p_shq, (char *)makecmd,
",unused,jonbriem_vim-src2Fquickfix.c
"	    if (qfp->qf_type == 1)	// :helpgrep
		fname = gettail(fname);
	}
	if (fname == NULL)
	    sprintf((char *)IObuff, ""%2d"", qf_idx);
",1,unused,3424,unused,"	    if (qfp->qf_type == 1)	// :helpgrep
		fname = gettail(fname);
	}
	if (fname == NULL)
	    sprintf((char *)IObuff, ""%2d"", qf_idx);
",unused,jonbriem_vim-src2Fquickfix.c
"	msg_puts_attr("":"", qfSepAttr);
    if (qfp->qf_lnum == 0)
	IObuff[0] = NUL;
    else if (qfp->qf_col == 0)
	sprintf((char *)IObuff, ""%ld"", qfp->qf_lnum);
",1,unused,3453,unused,"	msg_puts_attr("":"", qfSepAttr);
    if (qfp->qf_lnum == 0)
	IObuff[0] = NUL;
    else if (qfp->qf_col == 0)
	sprintf((char *)IObuff, ""%ld"", qfp->qf_lnum);
",unused,jonbriem_vim-src2Fquickfix.c
"	IObuff[0] = NUL;
    else if (qfp->qf_col == 0)
	sprintf((char *)IObuff, ""%ld"", qfp->qf_lnum);
    else
	sprintf((char *)IObuff, ""%ld col %d"",
",1,unused,3455,unused,"	IObuff[0] = NUL;
    else if (qfp->qf_col == 0)
	sprintf((char *)IObuff, ""%ld"", qfp->qf_lnum);
    else
	sprintf((char *)IObuff, ""%ld col %d"",
",unused,jonbriem_vim-src2Fquickfix.c
"	sprintf((char *)IObuff, ""%ld"", qfp->qf_lnum);
    else
	sprintf((char *)IObuff, ""%ld col %d"",
		qfp->qf_lnum, qfp->qf_col);
    sprintf((char *)IObuff + STRLEN(IObuff), ""%s"",
",1,unused,3457,unused,"	sprintf((char *)IObuff, ""%ld"", qfp->qf_lnum);
    else
	sprintf((char *)IObuff, ""%ld col %d"",
		qfp->qf_lnum, qfp->qf_col);
    sprintf((char *)IObuff + STRLEN(IObuff), ""%s"",
",unused,jonbriem_vim-src2Fquickfix.c
"    if (!shortmess(SHM_RECORDING))
    {
	char s[4];

	sprintf(s, "" @%c"", reg_recording);
",1,unused,10384,unused,"    if (!shortmess(SHM_RECORDING))
    {
	char s[4];

	sprintf(s, "" @%c"", reg_recording);
",unused,jonbriem_vim-src2Fscreen.c
"		    src += 5;
		    result[dlen++] = K_SPECIAL;
		    result[dlen++] = (int)KS_EXTRA;
		    result[dlen++] = (int)KE_SNR;
		    sprintf((char *)result + dlen, ""%ld"",
",1,unused,6133,unused,"		    src += 5;
		    result[dlen++] = K_SPECIAL;
		    result[dlen++] = (int)KS_EXTRA;
		    result[dlen++] = (int)KE_SNR;
		    sprintf((char *)result + dlen, ""%ld"",
",unused,jonbriem_vim-src2Fterm.c
"		    IF_EB(""\033["", ESC_STR ""["")) : ""\233"";
	char *tail = s[i] == '3' ? (n >= 16 ? ""38;5;"" : ""9"")
				 : (n >= 16 ? ""48;5;"" : ""10"");

	sprintf(buf, format, lead, tail);
",1,unused,2929,unused,"		    IF_EB(""\033["", ESC_STR ""["")) : ""\233"";
	char *tail = s[i] == '3' ? (n >= 16 ? ""38;5;"" : ""9"")
				 : (n >= 16 ? ""48;5;"" : ""10"");

	sprintf(buf, format, lead, tail);
",unused,jonbriem_vim-src2Fterm.c
"    {
	char *key_name = key_names[xt_index_out];

	LOG_TR((""Requesting XT %d: %s"", xt_index_out, key_name));
	sprintf(buf, ""\033P+q%02x%02x\033\\"", key_name[0], key_name[1]);
",1,unused,6489,unused,"    {
	char *key_name = key_names[xt_index_out];

	LOG_TR((""Requesting XT %d: %s"", xt_index_out, key_name));
	sprintf(buf, ""\033P+q%02x%02x\033\\"", key_name[0], key_name[1]);
",unused,jonbriem_vim-src2Fterm.c
"	    if (current_sctx.sc_sid <= 0)
		*error = ERROR_SCRIPT;
	    else
	    {
		sprintf((char *)fname_buf + 3, ""%ld_"", (long)current_sctx.sc_sid);
",1,unused,511,unused,"	    if (current_sctx.sc_sid <= 0)
		*error = ERROR_SCRIPT;
	    else
	    {
		sprintf((char *)fname_buf + 3, ""%ld_"", (long)current_sctx.sc_sid);
",unused,jonbriem_vim-src2Fuserfunc.c
"	    {
		emsg(_(e_usingsid));
		goto theend;
	    }
	    sprintf((char *)sid_buf, ""%ld_"", (long)current_sctx.sc_sid);
",1,unused,1840,unused,"	    {
		emsg(_(e_usingsid));
		goto theend;
	    }
	    sprintf((char *)sid_buf, ""%ld_"", (long)current_sctx.sc_sid);
",unused,jonbriem_vim-src2Fuserfunc.c
"  while ((length < 0 || n < length) && (e = getc(fp)) != EOF)
    {
      if (p == 0)
	{
	  addrlen = sprintf(l, ""%08lx:"",
",1,unused,829,unused,"  while ((length < 0 || n < length) && (e = getc(fp)) != EOF)
    {
      if (p == 0)
	{
	  addrlen = sprintf(l, ""%08lx:"",
",unused,jonbriem_vim-src2Fxxd2Fxxd.c
"    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = (char *)calloc(100, sizeof(char));
    if (data == NULL) {exit(-1);}
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",1,unused,32,unused,"    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = (char *)calloc(100, sizeof(char));
    if (data == NULL) {exit(-1);}
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__char_calloc_01.c
"        /* POTENTIAL FLAW: Allocate memory on the heap */
        data = (char *)calloc(100, sizeof(char));
        if (data == NULL) {exit(-1);}
        /* Initialize and make use of data */
        strcpy(data, ""A String"");
",1,unused,34,unused,"        /* POTENTIAL FLAW: Allocate memory on the heap */
        data = (char *)calloc(100, sizeof(char));
        if (data == NULL) {exit(-1);}
        /* Initialize and make use of data */
        strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__char_calloc_02.c
"        /* POTENTIAL FLAW: Allocate memory on the heap */
        data = (char *)calloc(100, sizeof(char));
        if (data == NULL) {exit(-1);}
        /* Initialize and make use of data */
        strcpy(data, ""A String"");
",1,unused,34,unused,"        /* POTENTIAL FLAW: Allocate memory on the heap */
        data = (char *)calloc(100, sizeof(char));
        if (data == NULL) {exit(-1);}
        /* Initialize and make use of data */
        strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__char_calloc_03.c
"        /* POTENTIAL FLAW: Allocate memory on the heap */
        data = (char *)calloc(100, sizeof(char));
        if (data == NULL) {exit(-1);}
        /* Initialize and make use of data */
        strcpy(data, ""A String"");
",1,unused,40,unused,"        /* POTENTIAL FLAW: Allocate memory on the heap */
        data = (char *)calloc(100, sizeof(char));
        if (data == NULL) {exit(-1);}
        /* Initialize and make use of data */
        strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__char_calloc_04.c
"        /* POTENTIAL FLAW: Allocate memory on the heap */
        data = (char *)calloc(100, sizeof(char));
        if (data == NULL) {exit(-1);}
        /* Initialize and make use of data */
        strcpy(data, ""A String"");
",1,unused,40,unused,"        /* POTENTIAL FLAW: Allocate memory on the heap */
        data = (char *)calloc(100, sizeof(char));
        if (data == NULL) {exit(-1);}
        /* Initialize and make use of data */
        strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__char_calloc_05.c
"        /* POTENTIAL FLAW: Allocate memory on the heap */
        data = (char *)calloc(100, sizeof(char));
        if (data == NULL) {exit(-1);}
        /* Initialize and make use of data */
        strcpy(data, ""A String"");
",1,unused,39,unused,"        /* POTENTIAL FLAW: Allocate memory on the heap */
        data = (char *)calloc(100, sizeof(char));
        if (data == NULL) {exit(-1);}
        /* Initialize and make use of data */
        strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__char_calloc_06.c
"        /* POTENTIAL FLAW: Allocate memory on the heap */
        data = (char *)calloc(100, sizeof(char));
        if (data == NULL) {exit(-1);}
        /* Initialize and make use of data */
        strcpy(data, ""A String"");
",1,unused,39,unused,"        /* POTENTIAL FLAW: Allocate memory on the heap */
        data = (char *)calloc(100, sizeof(char));
        if (data == NULL) {exit(-1);}
        /* Initialize and make use of data */
        strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__char_calloc_07.c
"        /* POTENTIAL FLAW: Allocate memory on the heap */
        data = (char *)calloc(100, sizeof(char));
        if (data == NULL) {exit(-1);}
        /* Initialize and make use of data */
        strcpy(data, ""A String"");
",1,unused,47,unused,"        /* POTENTIAL FLAW: Allocate memory on the heap */
        data = (char *)calloc(100, sizeof(char));
        if (data == NULL) {exit(-1);}
        /* Initialize and make use of data */
        strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__char_calloc_08.c
"        /* POTENTIAL FLAW: Allocate memory on the heap */
        data = (char *)calloc(100, sizeof(char));
        if (data == NULL) {exit(-1);}
        /* Initialize and make use of data */
        strcpy(data, ""A String"");
",1,unused,34,unused,"        /* POTENTIAL FLAW: Allocate memory on the heap */
        data = (char *)calloc(100, sizeof(char));
        if (data == NULL) {exit(-1);}
        /* Initialize and make use of data */
        strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__char_calloc_09.c
"        /* POTENTIAL FLAW: Allocate memory on the heap */
        data = (char *)calloc(100, sizeof(char));
        if (data == NULL) {exit(-1);}
        /* Initialize and make use of data */
        strcpy(data, ""A String"");
",1,unused,34,unused,"        /* POTENTIAL FLAW: Allocate memory on the heap */
        data = (char *)calloc(100, sizeof(char));
        if (data == NULL) {exit(-1);}
        /* Initialize and make use of data */
        strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__char_calloc_10.c
"        /* POTENTIAL FLAW: Allocate memory on the heap */
        data = (char *)calloc(100, sizeof(char));
        if (data == NULL) {exit(-1);}
        /* Initialize and make use of data */
        strcpy(data, ""A String"");
",1,unused,34,unused,"        /* POTENTIAL FLAW: Allocate memory on the heap */
        data = (char *)calloc(100, sizeof(char));
        if (data == NULL) {exit(-1);}
        /* Initialize and make use of data */
        strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__char_calloc_11.c
"        /* POTENTIAL FLAW: Allocate memory on the heap */
        data = (char *)calloc(100, sizeof(char));
        if (data == NULL) {exit(-1);}
        /* Initialize and make use of data */
        strcpy(data, ""A String"");
",1,unused,34,unused,"        /* POTENTIAL FLAW: Allocate memory on the heap */
        data = (char *)calloc(100, sizeof(char));
        if (data == NULL) {exit(-1);}
        /* Initialize and make use of data */
        strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__char_calloc_12.c
"    {
        /* FIX: Use memory allocated on the stack with ALLOCA */
        data = (char *)ALLOCA(100*sizeof(char));
        /* Initialize and make use of data */
        strcpy(data, ""A String"");
",1,unused,42,unused,"    {
        /* FIX: Use memory allocated on the stack with ALLOCA */
        data = (char *)ALLOCA(100*sizeof(char));
        /* Initialize and make use of data */
        strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__char_calloc_12.c
"        /* POTENTIAL FLAW: Allocate memory on the heap */
        data = (char *)calloc(100, sizeof(char));
        if (data == NULL) {exit(-1);}
        /* Initialize and make use of data */
        strcpy(data, ""A String"");
",1,unused,34,unused,"        /* POTENTIAL FLAW: Allocate memory on the heap */
        data = (char *)calloc(100, sizeof(char));
        if (data == NULL) {exit(-1);}
        /* Initialize and make use of data */
        strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__char_calloc_13.c
"        /* POTENTIAL FLAW: Allocate memory on the heap */
        data = (char *)calloc(100, sizeof(char));
        if (data == NULL) {exit(-1);}
        /* Initialize and make use of data */
        strcpy(data, ""A String"");
",1,unused,34,unused,"        /* POTENTIAL FLAW: Allocate memory on the heap */
        data = (char *)calloc(100, sizeof(char));
        if (data == NULL) {exit(-1);}
        /* Initialize and make use of data */
        strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__char_calloc_14.c
"        /* POTENTIAL FLAW: Allocate memory on the heap */
        data = (char *)calloc(100, sizeof(char));
        if (data == NULL) {exit(-1);}
        /* Initialize and make use of data */
        strcpy(data, ""A String"");
",1,unused,35,unused,"        /* POTENTIAL FLAW: Allocate memory on the heap */
        data = (char *)calloc(100, sizeof(char));
        if (data == NULL) {exit(-1);}
        /* Initialize and make use of data */
        strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__char_calloc_15.c
"        /* POTENTIAL FLAW: Allocate memory on the heap */
        data = (char *)calloc(100, sizeof(char));
        if (data == NULL) {exit(-1);}
        /* Initialize and make use of data */
        strcpy(data, ""A String"");
",1,unused,34,unused,"        /* POTENTIAL FLAW: Allocate memory on the heap */
        data = (char *)calloc(100, sizeof(char));
        if (data == NULL) {exit(-1);}
        /* Initialize and make use of data */
        strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__char_calloc_16.c
"        /* POTENTIAL FLAW: Allocate memory on the heap */
        data = (char *)calloc(100, sizeof(char));
        if (data == NULL) {exit(-1);}
        /* Initialize and make use of data */
        strcpy(data, ""A String"");
",1,unused,35,unused,"        /* POTENTIAL FLAW: Allocate memory on the heap */
        data = (char *)calloc(100, sizeof(char));
        if (data == NULL) {exit(-1);}
        /* Initialize and make use of data */
        strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__char_calloc_17.c
"    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = (char *)calloc(100, sizeof(char));
    if (data == NULL) {exit(-1);}
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",1,unused,34,unused,"    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = (char *)calloc(100, sizeof(char));
    if (data == NULL) {exit(-1);}
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__char_calloc_18.c
"    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = (char *)calloc(100, sizeof(char));
    if (data == NULL) {exit(-1);}
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",1,unused,44,unused,"    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = (char *)calloc(100, sizeof(char));
    if (data == NULL) {exit(-1);}
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__char_calloc_21.c
"    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = (char *)calloc(100, sizeof(char));
    if (data == NULL) {exit(-1);}
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",1,unused,37,unused,"    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = (char *)calloc(100, sizeof(char));
    if (data == NULL) {exit(-1);}
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__char_calloc_22a.c
"    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = (char *)calloc(100, sizeof(char));
    if (data == NULL) {exit(-1);}
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",1,unused,32,unused,"    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = (char *)calloc(100, sizeof(char));
    if (data == NULL) {exit(-1);}
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__char_calloc_31.c
"        /* POTENTIAL FLAW: Allocate memory on the heap */
        data = (char *)calloc(100, sizeof(char));
        if (data == NULL) {exit(-1);}
        /* Initialize and make use of data */
        strcpy(data, ""A String"");
",1,unused,36,unused,"        /* POTENTIAL FLAW: Allocate memory on the heap */
        data = (char *)calloc(100, sizeof(char));
        if (data == NULL) {exit(-1);}
        /* Initialize and make use of data */
        strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__char_calloc_32.c
"    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = (char *)calloc(100, sizeof(char));
    if (data == NULL) {exit(-1);}
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",1,unused,39,unused,"    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = (char *)calloc(100, sizeof(char));
    if (data == NULL) {exit(-1);}
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__char_calloc_34.c
"    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = (char *)calloc(100, sizeof(char));
    if (data == NULL) {exit(-1);}
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",1,unused,38,unused,"    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = (char *)calloc(100, sizeof(char));
    if (data == NULL) {exit(-1);}
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__char_calloc_41.c
"    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = (char *)calloc(100, sizeof(char));
    if (data == NULL) {exit(-1);}
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",1,unused,40,unused,"    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = (char *)calloc(100, sizeof(char));
    if (data == NULL) {exit(-1);}
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__char_calloc_44.c
"    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = (char *)calloc(100, sizeof(char));
    if (data == NULL) {exit(-1);}
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",1,unused,43,unused,"    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = (char *)calloc(100, sizeof(char));
    if (data == NULL) {exit(-1);}
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__char_calloc_45.c
"    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = (char *)calloc(100, sizeof(char));
    if (data == NULL) {exit(-1);}
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",1,unused,35,unused,"    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = (char *)calloc(100, sizeof(char));
    if (data == NULL) {exit(-1);}
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__char_calloc_51a.c
"    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = (char *)calloc(100, sizeof(char));
    if (data == NULL) {exit(-1);}
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",1,unused,35,unused,"    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = (char *)calloc(100, sizeof(char));
    if (data == NULL) {exit(-1);}
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__char_calloc_52a.c
"    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = (char *)calloc(100, sizeof(char));
    if (data == NULL) {exit(-1);}
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",1,unused,35,unused,"    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = (char *)calloc(100, sizeof(char));
    if (data == NULL) {exit(-1);}
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__char_calloc_53a.c
"    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = (char *)calloc(100, sizeof(char));
    if (data == NULL) {exit(-1);}
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",1,unused,35,unused,"    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = (char *)calloc(100, sizeof(char));
    if (data == NULL) {exit(-1);}
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__char_calloc_54a.c
"    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = (char *)calloc(100, sizeof(char));
    if (data == NULL) {exit(-1);}
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",1,unused,30,unused,"    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = (char *)calloc(100, sizeof(char));
    if (data == NULL) {exit(-1);}
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__char_calloc_61b.c
"    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = (char *)calloc(100, sizeof(char));
    if (data == NULL) {exit(-1);}
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",1,unused,35,unused,"    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = (char *)calloc(100, sizeof(char));
    if (data == NULL) {exit(-1);}
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__char_calloc_63a.c
"    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = (char *)calloc(100, sizeof(char));
    if (data == NULL) {exit(-1);}
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",1,unused,37,unused,"    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = (char *)calloc(100, sizeof(char));
    if (data == NULL) {exit(-1);}
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__char_calloc_65a.c
"    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = (char *)calloc(100, sizeof(char));
    if (data == NULL) {exit(-1);}
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",1,unused,41,unused,"    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = (char *)calloc(100, sizeof(char));
    if (data == NULL) {exit(-1);}
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__char_calloc_67a.c
"    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = (char *)calloc(100, sizeof(char));
    if (data == NULL) {exit(-1);}
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",1,unused,39,unused,"    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = (char *)calloc(100, sizeof(char));
    if (data == NULL) {exit(-1);}
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__char_calloc_68a.c
"    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",1,unused,32,unused,"    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__char_malloc_01.c
"        /* POTENTIAL FLAW: Allocate memory on the heap */
        data = (char *)malloc(100*sizeof(char));
        if (data == NULL) {exit(-1);}
        /* Initialize and make use of data */
        strcpy(data, ""A String"");
",1,unused,34,unused,"        /* POTENTIAL FLAW: Allocate memory on the heap */
        data = (char *)malloc(100*sizeof(char));
        if (data == NULL) {exit(-1);}
        /* Initialize and make use of data */
        strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__char_malloc_02.c
"        /* POTENTIAL FLAW: Allocate memory on the heap */
        data = (char *)malloc(100*sizeof(char));
        if (data == NULL) {exit(-1);}
        /* Initialize and make use of data */
        strcpy(data, ""A String"");
",1,unused,34,unused,"        /* POTENTIAL FLAW: Allocate memory on the heap */
        data = (char *)malloc(100*sizeof(char));
        if (data == NULL) {exit(-1);}
        /* Initialize and make use of data */
        strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__char_malloc_03.c
"        /* POTENTIAL FLAW: Allocate memory on the heap */
        data = (char *)malloc(100*sizeof(char));
        if (data == NULL) {exit(-1);}
        /* Initialize and make use of data */
        strcpy(data, ""A String"");
",1,unused,40,unused,"        /* POTENTIAL FLAW: Allocate memory on the heap */
        data = (char *)malloc(100*sizeof(char));
        if (data == NULL) {exit(-1);}
        /* Initialize and make use of data */
        strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__char_malloc_04.c
"        /* POTENTIAL FLAW: Allocate memory on the heap */
        data = (char *)malloc(100*sizeof(char));
        if (data == NULL) {exit(-1);}
        /* Initialize and make use of data */
        strcpy(data, ""A String"");
",1,unused,40,unused,"        /* POTENTIAL FLAW: Allocate memory on the heap */
        data = (char *)malloc(100*sizeof(char));
        if (data == NULL) {exit(-1);}
        /* Initialize and make use of data */
        strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__char_malloc_05.c
"        /* POTENTIAL FLAW: Allocate memory on the heap */
        data = (char *)malloc(100*sizeof(char));
        if (data == NULL) {exit(-1);}
        /* Initialize and make use of data */
        strcpy(data, ""A String"");
",1,unused,39,unused,"        /* POTENTIAL FLAW: Allocate memory on the heap */
        data = (char *)malloc(100*sizeof(char));
        if (data == NULL) {exit(-1);}
        /* Initialize and make use of data */
        strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__char_malloc_06.c
"        /* POTENTIAL FLAW: Allocate memory on the heap */
        data = (char *)malloc(100*sizeof(char));
        if (data == NULL) {exit(-1);}
        /* Initialize and make use of data */
        strcpy(data, ""A String"");
",1,unused,47,unused,"        /* POTENTIAL FLAW: Allocate memory on the heap */
        data = (char *)malloc(100*sizeof(char));
        if (data == NULL) {exit(-1);}
        /* Initialize and make use of data */
        strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__char_malloc_08.c
"        /* POTENTIAL FLAW: Allocate memory on the heap */
        data = (char *)malloc(100*sizeof(char));
        if (data == NULL) {exit(-1);}
        /* Initialize and make use of data */
        strcpy(data, ""A String"");
",1,unused,34,unused,"        /* POTENTIAL FLAW: Allocate memory on the heap */
        data = (char *)malloc(100*sizeof(char));
        if (data == NULL) {exit(-1);}
        /* Initialize and make use of data */
        strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__char_malloc_09.c
"        /* POTENTIAL FLAW: Allocate memory on the heap */
        data = (char *)malloc(100*sizeof(char));
        if (data == NULL) {exit(-1);}
        /* Initialize and make use of data */
        strcpy(data, ""A String"");
",1,unused,34,unused,"        /* POTENTIAL FLAW: Allocate memory on the heap */
        data = (char *)malloc(100*sizeof(char));
        if (data == NULL) {exit(-1);}
        /* Initialize and make use of data */
        strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__char_malloc_10.c
"        /* POTENTIAL FLAW: Allocate memory on the heap */
        data = (char *)malloc(100*sizeof(char));
        if (data == NULL) {exit(-1);}
        /* Initialize and make use of data */
        strcpy(data, ""A String"");
",1,unused,34,unused,"        /* POTENTIAL FLAW: Allocate memory on the heap */
        data = (char *)malloc(100*sizeof(char));
        if (data == NULL) {exit(-1);}
        /* Initialize and make use of data */
        strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__char_malloc_11.c
"        /* POTENTIAL FLAW: Allocate memory on the heap */
        data = (char *)malloc(100*sizeof(char));
        if (data == NULL) {exit(-1);}
        /* Initialize and make use of data */
        strcpy(data, ""A String"");
",1,unused,34,unused,"        /* POTENTIAL FLAW: Allocate memory on the heap */
        data = (char *)malloc(100*sizeof(char));
        if (data == NULL) {exit(-1);}
        /* Initialize and make use of data */
        strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__char_malloc_12.c
"    {
        /* FIX: Use memory allocated on the stack with ALLOCA */
        data = (char *)ALLOCA(100*sizeof(char));
        /* Initialize and make use of data */
        strcpy(data, ""A String"");
",1,unused,42,unused,"    {
        /* FIX: Use memory allocated on the stack with ALLOCA */
        data = (char *)ALLOCA(100*sizeof(char));
        /* Initialize and make use of data */
        strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__char_malloc_12.c
"        /* POTENTIAL FLAW: Allocate memory on the heap */
        data = (char *)malloc(100*sizeof(char));
        if (data == NULL) {exit(-1);}
        /* Initialize and make use of data */
        strcpy(data, ""A String"");
",1,unused,34,unused,"        /* POTENTIAL FLAW: Allocate memory on the heap */
        data = (char *)malloc(100*sizeof(char));
        if (data == NULL) {exit(-1);}
        /* Initialize and make use of data */
        strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__char_malloc_13.c
"        /* POTENTIAL FLAW: Allocate memory on the heap */
        data = (char *)malloc(100*sizeof(char));
        if (data == NULL) {exit(-1);}
        /* Initialize and make use of data */
        strcpy(data, ""A String"");
",1,unused,34,unused,"        /* POTENTIAL FLAW: Allocate memory on the heap */
        data = (char *)malloc(100*sizeof(char));
        if (data == NULL) {exit(-1);}
        /* Initialize and make use of data */
        strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__char_malloc_16.c
"        /* POTENTIAL FLAW: Allocate memory on the heap */
        data = (char *)malloc(100*sizeof(char));
        if (data == NULL) {exit(-1);}
        /* Initialize and make use of data */
        strcpy(data, ""A String"");
",1,unused,35,unused,"        /* POTENTIAL FLAW: Allocate memory on the heap */
        data = (char *)malloc(100*sizeof(char));
        if (data == NULL) {exit(-1);}
        /* Initialize and make use of data */
        strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__char_malloc_17.c
"    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",1,unused,34,unused,"    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__char_malloc_18.c
"    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",1,unused,44,unused,"    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__char_malloc_21.c
"    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",1,unused,37,unused,"    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__char_malloc_22a.c
"    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",1,unused,32,unused,"    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__char_malloc_31.c
"        /* POTENTIAL FLAW: Allocate memory on the heap */
        data = (char *)malloc(100*sizeof(char));
        if (data == NULL) {exit(-1);}
        /* Initialize and make use of data */
        strcpy(data, ""A String"");
",1,unused,36,unused,"        /* POTENTIAL FLAW: Allocate memory on the heap */
        data = (char *)malloc(100*sizeof(char));
        if (data == NULL) {exit(-1);}
        /* Initialize and make use of data */
        strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__char_malloc_32.c
"    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",1,unused,39,unused,"    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__char_malloc_34.c
"    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",1,unused,38,unused,"    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__char_malloc_41.c
"    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",1,unused,30,unused,"    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__char_malloc_42.c
"    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",1,unused,43,unused,"    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__char_malloc_45.c
"    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",1,unused,35,unused,"    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__char_malloc_51a.c
"    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",1,unused,35,unused,"    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__char_malloc_52a.c
"    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",1,unused,35,unused,"    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__char_malloc_53a.c
"    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",1,unused,35,unused,"    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__char_malloc_54a.c
"    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",1,unused,30,unused,"    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__char_malloc_61b.c
"    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",1,unused,35,unused,"    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__char_malloc_63a.c
"    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",1,unused,35,unused,"    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__char_malloc_64a.c
"    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",1,unused,37,unused,"    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__char_malloc_65a.c
"    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",1,unused,41,unused,"    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__char_malloc_67a.c
"    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",1,unused,39,unused,"    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = (char *)malloc(100*sizeof(char));
    if (data == NULL) {exit(-1);}
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__char_malloc_68a.c
"    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = (char *)realloc(data, 100*sizeof(char));
    if (data == NULL) {exit(-1);}
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",1,unused,32,unused,"    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = (char *)realloc(data, 100*sizeof(char));
    if (data == NULL) {exit(-1);}
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__char_realloc_01.c
"        /* POTENTIAL FLAW: Allocate memory on the heap */
        data = (char *)realloc(data, 100*sizeof(char));
        if (data == NULL) {exit(-1);}
        /* Initialize and make use of data */
        strcpy(data, ""A String"");
",1,unused,34,unused,"        /* POTENTIAL FLAW: Allocate memory on the heap */
        data = (char *)realloc(data, 100*sizeof(char));
        if (data == NULL) {exit(-1);}
        /* Initialize and make use of data */
        strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__char_realloc_02.c
"        /* POTENTIAL FLAW: Allocate memory on the heap */
        data = (char *)realloc(data, 100*sizeof(char));
        if (data == NULL) {exit(-1);}
        /* Initialize and make use of data */
        strcpy(data, ""A String"");
",1,unused,34,unused,"        /* POTENTIAL FLAW: Allocate memory on the heap */
        data = (char *)realloc(data, 100*sizeof(char));
        if (data == NULL) {exit(-1);}
        /* Initialize and make use of data */
        strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__char_realloc_03.c
"        /* POTENTIAL FLAW: Allocate memory on the heap */
        data = (char *)realloc(data, 100*sizeof(char));
        if (data == NULL) {exit(-1);}
        /* Initialize and make use of data */
        strcpy(data, ""A String"");
",1,unused,40,unused,"        /* POTENTIAL FLAW: Allocate memory on the heap */
        data = (char *)realloc(data, 100*sizeof(char));
        if (data == NULL) {exit(-1);}
        /* Initialize and make use of data */
        strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__char_realloc_04.c
"        /* POTENTIAL FLAW: Allocate memory on the heap */
        data = (char *)realloc(data, 100*sizeof(char));
        if (data == NULL) {exit(-1);}
        /* Initialize and make use of data */
        strcpy(data, ""A String"");
",1,unused,40,unused,"        /* POTENTIAL FLAW: Allocate memory on the heap */
        data = (char *)realloc(data, 100*sizeof(char));
        if (data == NULL) {exit(-1);}
        /* Initialize and make use of data */
        strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__char_realloc_05.c
"        /* POTENTIAL FLAW: Allocate memory on the heap */
        data = (char *)realloc(data, 100*sizeof(char));
        if (data == NULL) {exit(-1);}
        /* Initialize and make use of data */
        strcpy(data, ""A String"");
",1,unused,39,unused,"        /* POTENTIAL FLAW: Allocate memory on the heap */
        data = (char *)realloc(data, 100*sizeof(char));
        if (data == NULL) {exit(-1);}
        /* Initialize and make use of data */
        strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__char_realloc_06.c
"        /* POTENTIAL FLAW: Allocate memory on the heap */
        data = (char *)realloc(data, 100*sizeof(char));
        if (data == NULL) {exit(-1);}
        /* Initialize and make use of data */
        strcpy(data, ""A String"");
",1,unused,47,unused,"        /* POTENTIAL FLAW: Allocate memory on the heap */
        data = (char *)realloc(data, 100*sizeof(char));
        if (data == NULL) {exit(-1);}
        /* Initialize and make use of data */
        strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__char_realloc_08.c
"        /* POTENTIAL FLAW: Allocate memory on the heap */
        data = (char *)realloc(data, 100*sizeof(char));
        if (data == NULL) {exit(-1);}
        /* Initialize and make use of data */
        strcpy(data, ""A String"");
",1,unused,34,unused,"        /* POTENTIAL FLAW: Allocate memory on the heap */
        data = (char *)realloc(data, 100*sizeof(char));
        if (data == NULL) {exit(-1);}
        /* Initialize and make use of data */
        strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__char_realloc_09.c
"        /* POTENTIAL FLAW: Allocate memory on the heap */
        data = (char *)realloc(data, 100*sizeof(char));
        if (data == NULL) {exit(-1);}
        /* Initialize and make use of data */
        strcpy(data, ""A String"");
",1,unused,34,unused,"        /* POTENTIAL FLAW: Allocate memory on the heap */
        data = (char *)realloc(data, 100*sizeof(char));
        if (data == NULL) {exit(-1);}
        /* Initialize and make use of data */
        strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__char_realloc_10.c
"        /* POTENTIAL FLAW: Allocate memory on the heap */
        data = (char *)realloc(data, 100*sizeof(char));
        if (data == NULL) {exit(-1);}
        /* Initialize and make use of data */
        strcpy(data, ""A String"");
",1,unused,34,unused,"        /* POTENTIAL FLAW: Allocate memory on the heap */
        data = (char *)realloc(data, 100*sizeof(char));
        if (data == NULL) {exit(-1);}
        /* Initialize and make use of data */
        strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__char_realloc_11.c
"        /* POTENTIAL FLAW: Allocate memory on the heap */
        data = (char *)realloc(data, 100*sizeof(char));
        if (data == NULL) {exit(-1);}
        /* Initialize and make use of data */
        strcpy(data, ""A String"");
",1,unused,34,unused,"        /* POTENTIAL FLAW: Allocate memory on the heap */
        data = (char *)realloc(data, 100*sizeof(char));
        if (data == NULL) {exit(-1);}
        /* Initialize and make use of data */
        strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__char_realloc_12.c
"    {
        /* FIX: Use memory allocated on the stack with ALLOCA */
        data = (char *)ALLOCA(100*sizeof(char));
        /* Initialize and make use of data */
        strcpy(data, ""A String"");
",1,unused,42,unused,"    {
        /* FIX: Use memory allocated on the stack with ALLOCA */
        data = (char *)ALLOCA(100*sizeof(char));
        /* Initialize and make use of data */
        strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__char_realloc_12.c
"        /* POTENTIAL FLAW: Allocate memory on the heap */
        data = (char *)realloc(data, 100*sizeof(char));
        if (data == NULL) {exit(-1);}
        /* Initialize and make use of data */
        strcpy(data, ""A String"");
",1,unused,34,unused,"        /* POTENTIAL FLAW: Allocate memory on the heap */
        data = (char *)realloc(data, 100*sizeof(char));
        if (data == NULL) {exit(-1);}
        /* Initialize and make use of data */
        strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__char_realloc_13.c
"        /* POTENTIAL FLAW: Allocate memory on the heap */
        data = (char *)realloc(data, 100*sizeof(char));
        if (data == NULL) {exit(-1);}
        /* Initialize and make use of data */
        strcpy(data, ""A String"");
",1,unused,34,unused,"        /* POTENTIAL FLAW: Allocate memory on the heap */
        data = (char *)realloc(data, 100*sizeof(char));
        if (data == NULL) {exit(-1);}
        /* Initialize and make use of data */
        strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__char_realloc_14.c
"        /* POTENTIAL FLAW: Allocate memory on the heap */
        data = (char *)realloc(data, 100*sizeof(char));
        if (data == NULL) {exit(-1);}
        /* Initialize and make use of data */
        strcpy(data, ""A String"");
",1,unused,35,unused,"        /* POTENTIAL FLAW: Allocate memory on the heap */
        data = (char *)realloc(data, 100*sizeof(char));
        if (data == NULL) {exit(-1);}
        /* Initialize and make use of data */
        strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__char_realloc_15.c
"        /* POTENTIAL FLAW: Allocate memory on the heap */
        data = (char *)realloc(data, 100*sizeof(char));
        if (data == NULL) {exit(-1);}
        /* Initialize and make use of data */
        strcpy(data, ""A String"");
",1,unused,34,unused,"        /* POTENTIAL FLAW: Allocate memory on the heap */
        data = (char *)realloc(data, 100*sizeof(char));
        if (data == NULL) {exit(-1);}
        /* Initialize and make use of data */
        strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__char_realloc_16.c
"    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = (char *)realloc(data, 100*sizeof(char));
    if (data == NULL) {exit(-1);}
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",1,unused,34,unused,"    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = (char *)realloc(data, 100*sizeof(char));
    if (data == NULL) {exit(-1);}
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__char_realloc_18.c
"    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = (char *)realloc(data, 100*sizeof(char));
    if (data == NULL) {exit(-1);}
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",1,unused,44,unused,"    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = (char *)realloc(data, 100*sizeof(char));
    if (data == NULL) {exit(-1);}
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__char_realloc_21.c
"    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = (char *)realloc(data, 100*sizeof(char));
    if (data == NULL) {exit(-1);}
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",1,unused,37,unused,"    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = (char *)realloc(data, 100*sizeof(char));
    if (data == NULL) {exit(-1);}
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__char_realloc_22a.c
"    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = (char *)realloc(data, 100*sizeof(char));
    if (data == NULL) {exit(-1);}
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",1,unused,32,unused,"    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = (char *)realloc(data, 100*sizeof(char));
    if (data == NULL) {exit(-1);}
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__char_realloc_31.c
"        /* POTENTIAL FLAW: Allocate memory on the heap */
        data = (char *)realloc(data, 100*sizeof(char));
        if (data == NULL) {exit(-1);}
        /* Initialize and make use of data */
        strcpy(data, ""A String"");
",1,unused,36,unused,"        /* POTENTIAL FLAW: Allocate memory on the heap */
        data = (char *)realloc(data, 100*sizeof(char));
        if (data == NULL) {exit(-1);}
        /* Initialize and make use of data */
        strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__char_realloc_32.c
"    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = (char *)realloc(data, 100*sizeof(char));
    if (data == NULL) {exit(-1);}
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",1,unused,39,unused,"    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = (char *)realloc(data, 100*sizeof(char));
    if (data == NULL) {exit(-1);}
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__char_realloc_34.c
"    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = (char *)realloc(data, 100*sizeof(char));
    if (data == NULL) {exit(-1);}
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",1,unused,38,unused,"    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = (char *)realloc(data, 100*sizeof(char));
    if (data == NULL) {exit(-1);}
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__char_realloc_41.c
"    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = (char *)realloc(data, 100*sizeof(char));
    if (data == NULL) {exit(-1);}
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",1,unused,40,unused,"    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = (char *)realloc(data, 100*sizeof(char));
    if (data == NULL) {exit(-1);}
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__char_realloc_44.c
"    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = (char *)realloc(data, 100*sizeof(char));
    if (data == NULL) {exit(-1);}
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",1,unused,35,unused,"    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = (char *)realloc(data, 100*sizeof(char));
    if (data == NULL) {exit(-1);}
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__char_realloc_51a.c
"    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = (char *)realloc(data, 100*sizeof(char));
    if (data == NULL) {exit(-1);}
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",1,unused,35,unused,"    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = (char *)realloc(data, 100*sizeof(char));
    if (data == NULL) {exit(-1);}
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__char_realloc_53a.c
"    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = (char *)realloc(data, 100*sizeof(char));
    if (data == NULL) {exit(-1);}
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",1,unused,35,unused,"    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = (char *)realloc(data, 100*sizeof(char));
    if (data == NULL) {exit(-1);}
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__char_realloc_54a.c
"    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = (char *)realloc(data, 100*sizeof(char));
    if (data == NULL) {exit(-1);}
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",1,unused,30,unused,"    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = (char *)realloc(data, 100*sizeof(char));
    if (data == NULL) {exit(-1);}
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__char_realloc_61b.c
"    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = (char *)realloc(data, 100*sizeof(char));
    if (data == NULL) {exit(-1);}
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",1,unused,35,unused,"    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = (char *)realloc(data, 100*sizeof(char));
    if (data == NULL) {exit(-1);}
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__char_realloc_64a.c
"    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = (char *)realloc(data, 100*sizeof(char));
    if (data == NULL) {exit(-1);}
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",1,unused,37,unused,"    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = (char *)realloc(data, 100*sizeof(char));
    if (data == NULL) {exit(-1);}
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__char_realloc_65a.c
"    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = (char *)realloc(data, 100*sizeof(char));
    if (data == NULL) {exit(-1);}
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",1,unused,36,unused,"    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = (char *)realloc(data, 100*sizeof(char));
    if (data == NULL) {exit(-1);}
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__char_realloc_66a.c
"    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = (char *)realloc(data, 100*sizeof(char));
    if (data == NULL) {exit(-1);}
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",1,unused,41,unused,"    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = (char *)realloc(data, 100*sizeof(char));
    if (data == NULL) {exit(-1);}
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__char_realloc_67a.c
"    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = (char *)realloc(data, 100*sizeof(char));
    if (data == NULL) {exit(-1);}
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",1,unused,39,unused,"    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = (char *)realloc(data, 100*sizeof(char));
    if (data == NULL) {exit(-1);}
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__char_realloc_68a.c
"    {
        char * data = (char *)malloc(100*sizeof(char));
        if (data == NULL) {exit(-1);}
        /* Initialize and make use of data */
        strcpy(data, ""A String"");
",1,unused,30,unused,"    {
        char * data = (char *)malloc(100*sizeof(char));
        if (data == NULL) {exit(-1);}
        /* Initialize and make use of data */
        strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__malloc_realloc_char_01.c
"        data = (char *)realloc(data, (130000)*sizeof(char));
        if (data != NULL)
        {
            /* Reinitialize and make use of data */
            strcpy(data, ""New String"");
",1,unused,37,unused,"        data = (char *)realloc(data, (130000)*sizeof(char));
        if (data != NULL)
        {
            /* Reinitialize and make use of data */
            strcpy(data, ""New String"");
",unused,juliet-cpp-CWE401_Memory_Leak__malloc_realloc_char_01.c
"        {
            char * data = (char *)malloc(100*sizeof(char));
            if (data == NULL) {exit(-1);}
            /* Initialize and make use of data */
            strcpy(data, ""A String"");
",1,unused,32,unused,"        {
            char * data = (char *)malloc(100*sizeof(char));
            if (data == NULL) {exit(-1);}
            /* Initialize and make use of data */
            strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__malloc_realloc_char_02.c
"            data = (char *)realloc(data, (130000)*sizeof(char));
            if (data != NULL)
            {
                /* Reinitialize and make use of data */
                strcpy(data, ""New String"");
",1,unused,39,unused,"            data = (char *)realloc(data, (130000)*sizeof(char));
            if (data != NULL)
            {
                /* Reinitialize and make use of data */
                strcpy(data, ""New String"");
",unused,juliet-cpp-CWE401_Memory_Leak__malloc_realloc_char_02.c
"        {
            char * data = (char *)malloc(100*sizeof(char));
            if (data == NULL) {exit(-1);}
            /* Initialize and make use of data */
            strcpy(data, ""A String"");
",1,unused,32,unused,"        {
            char * data = (char *)malloc(100*sizeof(char));
            if (data == NULL) {exit(-1);}
            /* Initialize and make use of data */
            strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__malloc_realloc_char_03.c
"            data = (char *)realloc(data, (130000)*sizeof(char));
            if (data != NULL)
            {
                /* Reinitialize and make use of data */
                strcpy(data, ""New String"");
",1,unused,39,unused,"            data = (char *)realloc(data, (130000)*sizeof(char));
            if (data != NULL)
            {
                /* Reinitialize and make use of data */
                strcpy(data, ""New String"");
",unused,juliet-cpp-CWE401_Memory_Leak__malloc_realloc_char_03.c
"        {
            char * data = (char *)malloc(100*sizeof(char));
            if (data == NULL) {exit(-1);}
            /* Initialize and make use of data */
            strcpy(data, ""A String"");
",1,unused,38,unused,"        {
            char * data = (char *)malloc(100*sizeof(char));
            if (data == NULL) {exit(-1);}
            /* Initialize and make use of data */
            strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__malloc_realloc_char_04.c
"            data = (char *)realloc(data, (130000)*sizeof(char));
            if (data != NULL)
            {
                /* Reinitialize and make use of data */
                strcpy(data, ""New String"");
",1,unused,45,unused,"            data = (char *)realloc(data, (130000)*sizeof(char));
            if (data != NULL)
            {
                /* Reinitialize and make use of data */
                strcpy(data, ""New String"");
",unused,juliet-cpp-CWE401_Memory_Leak__malloc_realloc_char_04.c
"        {
            char * data = (char *)malloc(100*sizeof(char));
            if (data == NULL) {exit(-1);}
            /* Initialize and make use of data */
            strcpy(data, ""A String"");
",1,unused,38,unused,"        {
            char * data = (char *)malloc(100*sizeof(char));
            if (data == NULL) {exit(-1);}
            /* Initialize and make use of data */
            strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__malloc_realloc_char_05.c
"            data = (char *)realloc(data, (130000)*sizeof(char));
            if (data != NULL)
            {
                /* Reinitialize and make use of data */
                strcpy(data, ""New String"");
",1,unused,45,unused,"            data = (char *)realloc(data, (130000)*sizeof(char));
            if (data != NULL)
            {
                /* Reinitialize and make use of data */
                strcpy(data, ""New String"");
",unused,juliet-cpp-CWE401_Memory_Leak__malloc_realloc_char_05.c
"        {
            char * data = (char *)malloc(100*sizeof(char));
            if (data == NULL) {exit(-1);}
            /* Initialize and make use of data */
            strcpy(data, ""A String"");
",1,unused,37,unused,"        {
            char * data = (char *)malloc(100*sizeof(char));
            if (data == NULL) {exit(-1);}
            /* Initialize and make use of data */
            strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__malloc_realloc_char_06.c
"            data = (char *)realloc(data, (130000)*sizeof(char));
            if (data != NULL)
            {
                /* Reinitialize and make use of data */
                strcpy(data, ""New String"");
",1,unused,44,unused,"            data = (char *)realloc(data, (130000)*sizeof(char));
            if (data != NULL)
            {
                /* Reinitialize and make use of data */
                strcpy(data, ""New String"");
",unused,juliet-cpp-CWE401_Memory_Leak__malloc_realloc_char_06.c
"        {
            char * data = (char *)malloc(100*sizeof(char));
            if (data == NULL) {exit(-1);}
            /* Initialize and make use of data */
            strcpy(data, ""A String"");
",1,unused,37,unused,"        {
            char * data = (char *)malloc(100*sizeof(char));
            if (data == NULL) {exit(-1);}
            /* Initialize and make use of data */
            strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__malloc_realloc_char_07.c
"            data = (char *)realloc(data, (130000)*sizeof(char));
            if (data != NULL)
            {
                /* Reinitialize and make use of data */
                strcpy(data, ""New String"");
",1,unused,44,unused,"            data = (char *)realloc(data, (130000)*sizeof(char));
            if (data != NULL)
            {
                /* Reinitialize and make use of data */
                strcpy(data, ""New String"");
",unused,juliet-cpp-CWE401_Memory_Leak__malloc_realloc_char_07.c
"        {
            char * data = (char *)malloc(100*sizeof(char));
            if (data == NULL) {exit(-1);}
            /* Initialize and make use of data */
            strcpy(data, ""A String"");
",1,unused,45,unused,"        {
            char * data = (char *)malloc(100*sizeof(char));
            if (data == NULL) {exit(-1);}
            /* Initialize and make use of data */
            strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__malloc_realloc_char_08.c
"            data = (char *)realloc(data, (130000)*sizeof(char));
            if (data != NULL)
            {
                /* Reinitialize and make use of data */
                strcpy(data, ""New String"");
",1,unused,52,unused,"            data = (char *)realloc(data, (130000)*sizeof(char));
            if (data != NULL)
            {
                /* Reinitialize and make use of data */
                strcpy(data, ""New String"");
",unused,juliet-cpp-CWE401_Memory_Leak__malloc_realloc_char_08.c
"        {
            char * data = (char *)malloc(100*sizeof(char));
            if (data == NULL) {exit(-1);}
            /* Initialize and make use of data */
            strcpy(data, ""A String"");
",1,unused,32,unused,"        {
            char * data = (char *)malloc(100*sizeof(char));
            if (data == NULL) {exit(-1);}
            /* Initialize and make use of data */
            strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__malloc_realloc_char_09.c
"            data = (char *)realloc(data, (130000)*sizeof(char));
            if (data != NULL)
            {
                /* Reinitialize and make use of data */
                strcpy(data, ""New String"");
",1,unused,39,unused,"            data = (char *)realloc(data, (130000)*sizeof(char));
            if (data != NULL)
            {
                /* Reinitialize and make use of data */
                strcpy(data, ""New String"");
",unused,juliet-cpp-CWE401_Memory_Leak__malloc_realloc_char_09.c
"        {
            char * data = (char *)malloc(100*sizeof(char));
            if (data == NULL) {exit(-1);}
            /* Initialize and make use of data */
            strcpy(data, ""A String"");
",1,unused,32,unused,"        {
            char * data = (char *)malloc(100*sizeof(char));
            if (data == NULL) {exit(-1);}
            /* Initialize and make use of data */
            strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__malloc_realloc_char_10.c
"            data = (char *)realloc(data, (130000)*sizeof(char));
            if (data != NULL)
            {
                /* Reinitialize and make use of data */
                strcpy(data, ""New String"");
",1,unused,39,unused,"            data = (char *)realloc(data, (130000)*sizeof(char));
            if (data != NULL)
            {
                /* Reinitialize and make use of data */
                strcpy(data, ""New String"");
",unused,juliet-cpp-CWE401_Memory_Leak__malloc_realloc_char_10.c
"        {
            char * data = (char *)malloc(100*sizeof(char));
            if (data == NULL) {exit(-1);}
            /* Initialize and make use of data */
            strcpy(data, ""A String"");
",1,unused,32,unused,"        {
            char * data = (char *)malloc(100*sizeof(char));
            if (data == NULL) {exit(-1);}
            /* Initialize and make use of data */
            strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__malloc_realloc_char_11.c
"            data = (char *)realloc(data, (130000)*sizeof(char));
            if (data != NULL)
            {
                /* Reinitialize and make use of data */
                strcpy(data, ""New String"");
",1,unused,39,unused,"            data = (char *)realloc(data, (130000)*sizeof(char));
            if (data != NULL)
            {
                /* Reinitialize and make use of data */
                strcpy(data, ""New String"");
",unused,juliet-cpp-CWE401_Memory_Leak__malloc_realloc_char_11.c
"        {
            char * data = (char *)malloc(100*sizeof(char));
            if (data == NULL) {exit(-1);}
            /* Initialize and make use of data */
            strcpy(data, ""A String"");
",1,unused,32,unused,"        {
            char * data = (char *)malloc(100*sizeof(char));
            if (data == NULL) {exit(-1);}
            /* Initialize and make use of data */
            strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__malloc_realloc_char_12.c
"            data = (char *)realloc(data, (130000)*sizeof(char));
            if (data != NULL)
            {
                /* Reinitialize and make use of data */
                strcpy(data, ""New String"");
",1,unused,39,unused,"            data = (char *)realloc(data, (130000)*sizeof(char));
            if (data != NULL)
            {
                /* Reinitialize and make use of data */
                strcpy(data, ""New String"");
",unused,juliet-cpp-CWE401_Memory_Leak__malloc_realloc_char_12.c
"            char * data = (char *)malloc(100*sizeof(char));
            if (data == NULL) {exit(-1);}
            char * tmpData;
            /* Initialize and make use of data */
            strcpy(data, ""A String"");
",1,unused,52,unused,"            char * data = (char *)malloc(100*sizeof(char));
            if (data == NULL) {exit(-1);}
            char * tmpData;
            /* Initialize and make use of data */
            strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__malloc_realloc_char_12.c
"            if (tmpData != NULL)
            {
                data = tmpData;
                /* Reinitialize and make use of data */
                strcpy(data, ""New String"");
",1,unused,61,unused,"            if (tmpData != NULL)
            {
                data = tmpData;
                /* Reinitialize and make use of data */
                strcpy(data, ""New String"");
",unused,juliet-cpp-CWE401_Memory_Leak__malloc_realloc_char_12.c
"        {
            char * data = (char *)malloc(100*sizeof(char));
            if (data == NULL) {exit(-1);}
            /* Initialize and make use of data */
            strcpy(data, ""A String"");
",1,unused,32,unused,"        {
            char * data = (char *)malloc(100*sizeof(char));
            if (data == NULL) {exit(-1);}
            /* Initialize and make use of data */
            strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__malloc_realloc_char_13.c
"            data = (char *)realloc(data, (130000)*sizeof(char));
            if (data != NULL)
            {
                /* Reinitialize and make use of data */
                strcpy(data, ""New String"");
",1,unused,39,unused,"            data = (char *)realloc(data, (130000)*sizeof(char));
            if (data != NULL)
            {
                /* Reinitialize and make use of data */
                strcpy(data, ""New String"");
",unused,juliet-cpp-CWE401_Memory_Leak__malloc_realloc_char_13.c
"        {
            char * data = (char *)malloc(100*sizeof(char));
            if (data == NULL) {exit(-1);}
            /* Initialize and make use of data */
            strcpy(data, ""A String"");
",1,unused,32,unused,"        {
            char * data = (char *)malloc(100*sizeof(char));
            if (data == NULL) {exit(-1);}
            /* Initialize and make use of data */
            strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__malloc_realloc_char_14.c
"            data = (char *)realloc(data, (130000)*sizeof(char));
            if (data != NULL)
            {
                /* Reinitialize and make use of data */
                strcpy(data, ""New String"");
",1,unused,39,unused,"            data = (char *)realloc(data, (130000)*sizeof(char));
            if (data != NULL)
            {
                /* Reinitialize and make use of data */
                strcpy(data, ""New String"");
",unused,juliet-cpp-CWE401_Memory_Leak__malloc_realloc_char_14.c
"    {
        char * data = (char *)malloc(100*sizeof(char));
        if (data == NULL) {exit(-1);}
        /* Initialize and make use of data */
        strcpy(data, ""A String"");
",1,unused,33,unused,"    {
        char * data = (char *)malloc(100*sizeof(char));
        if (data == NULL) {exit(-1);}
        /* Initialize and make use of data */
        strcpy(data, ""A String"");
",unused,juliet-cpp-CWE401_Memory_Leak__malloc_realloc_char_15.c
"    {
        /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
        size_t dataLen = strlen((char *)data);
        void * dest = (void *)ALLOCA((dataLen+1) * 1);
        (void)strcpy(dest, data);
",1,unused,57,unused,"    {
        /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
        size_t dataLen = strlen((char *)data);
        void * dest = (void *)ALLOCA((dataLen+1) * 1);
        (void)strcpy(dest, data);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE135_01.c
"        {
            /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
            size_t dataLen = strlen((char *)data);
            void * dest = (void *)ALLOCA((dataLen+1) * 1);
            (void)strcpy(dest, data);
",1,unused,128,unused,"        {
            /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
            size_t dataLen = strlen((char *)data);
            void * dest = (void *)ALLOCA((dataLen+1) * 1);
            (void)strcpy(dest, data);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE135_04.c
"        {
            /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
            size_t dataLen = strlen((char *)data);
            void * dest = (void *)ALLOCA((dataLen+1) * 1);
            (void)strcpy(dest, data);
",1,unused,150,unused,"        {
            /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
            size_t dataLen = strlen((char *)data);
            void * dest = (void *)ALLOCA((dataLen+1) * 1);
            (void)strcpy(dest, data);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE135_04.c
"        {
            /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
            size_t dataLen = strlen((char *)data);
            void * dest = (void *)ALLOCA((dataLen+1) * 1);
            (void)strcpy(dest, data);
",1,unused,128,unused,"        {
            /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
            size_t dataLen = strlen((char *)data);
            void * dest = (void *)ALLOCA((dataLen+1) * 1);
            (void)strcpy(dest, data);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE135_05.c
"        {
            /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
            size_t dataLen = strlen((char *)data);
            void * dest = (void *)ALLOCA((dataLen+1) * 1);
            (void)strcpy(dest, data);
",1,unused,150,unused,"        {
            /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
            size_t dataLen = strlen((char *)data);
            void * dest = (void *)ALLOCA((dataLen+1) * 1);
            (void)strcpy(dest, data);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE135_05.c
"        {
            /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
            size_t dataLen = strlen((char *)data);
            void * dest = (void *)ALLOCA((dataLen+1) * 1);
            (void)strcpy(dest, data);
",1,unused,127,unused,"        {
            /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
            size_t dataLen = strlen((char *)data);
            void * dest = (void *)ALLOCA((dataLen+1) * 1);
            (void)strcpy(dest, data);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE135_06.c
"        {
            /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
            size_t dataLen = strlen((char *)data);
            void * dest = (void *)ALLOCA((dataLen+1) * 1);
            (void)strcpy(dest, data);
",1,unused,149,unused,"        {
            /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
            size_t dataLen = strlen((char *)data);
            void * dest = (void *)ALLOCA((dataLen+1) * 1);
            (void)strcpy(dest, data);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE135_06.c
"        {
            /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
            size_t dataLen = strlen((char *)data);
            void * dest = (void *)ALLOCA((dataLen+1) * 1);
            (void)strcpy(dest, data);
",1,unused,127,unused,"        {
            /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
            size_t dataLen = strlen((char *)data);
            void * dest = (void *)ALLOCA((dataLen+1) * 1);
            (void)strcpy(dest, data);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE135_07.c
"        {
            /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
            size_t dataLen = strlen((char *)data);
            void * dest = (void *)ALLOCA((dataLen+1) * 1);
            (void)strcpy(dest, data);
",1,unused,149,unused,"        {
            /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
            size_t dataLen = strlen((char *)data);
            void * dest = (void *)ALLOCA((dataLen+1) * 1);
            (void)strcpy(dest, data);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE135_07.c
"        {
            /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
            size_t dataLen = strlen((char *)data);
            void * dest = (void *)ALLOCA((dataLen+1) * 1);
            (void)strcpy(dest, data);
",1,unused,135,unused,"        {
            /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
            size_t dataLen = strlen((char *)data);
            void * dest = (void *)ALLOCA((dataLen+1) * 1);
            (void)strcpy(dest, data);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE135_08.c
"        {
            /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
            size_t dataLen = strlen((char *)data);
            void * dest = (void *)ALLOCA((dataLen+1) * 1);
            (void)strcpy(dest, data);
",1,unused,157,unused,"        {
            /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
            size_t dataLen = strlen((char *)data);
            void * dest = (void *)ALLOCA((dataLen+1) * 1);
            (void)strcpy(dest, data);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE135_08.c
"        {
            /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
            size_t dataLen = strlen((char *)data);
            void * dest = (void *)ALLOCA((dataLen+1) * 1);
            (void)strcpy(dest, data);
",1,unused,122,unused,"        {
            /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
            size_t dataLen = strlen((char *)data);
            void * dest = (void *)ALLOCA((dataLen+1) * 1);
            (void)strcpy(dest, data);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE135_09.c
"        {
            /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
            size_t dataLen = strlen((char *)data);
            void * dest = (void *)ALLOCA((dataLen+1) * 1);
            (void)strcpy(dest, data);
",1,unused,144,unused,"        {
            /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
            size_t dataLen = strlen((char *)data);
            void * dest = (void *)ALLOCA((dataLen+1) * 1);
            (void)strcpy(dest, data);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE135_09.c
"        {
            /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
            size_t dataLen = strlen((char *)data);
            void * dest = (void *)ALLOCA((dataLen+1) * 1);
            (void)strcpy(dest, data);
",1,unused,122,unused,"        {
            /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
            size_t dataLen = strlen((char *)data);
            void * dest = (void *)ALLOCA((dataLen+1) * 1);
            (void)strcpy(dest, data);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE135_10.c
"        {
            /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
            size_t dataLen = strlen((char *)data);
            void * dest = (void *)ALLOCA((dataLen+1) * 1);
            (void)strcpy(dest, data);
",1,unused,144,unused,"        {
            /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
            size_t dataLen = strlen((char *)data);
            void * dest = (void *)ALLOCA((dataLen+1) * 1);
            (void)strcpy(dest, data);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE135_10.c
"        {
            /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
            size_t dataLen = strlen((char *)data);
            void * dest = (void *)ALLOCA((dataLen+1) * 1);
            (void)strcpy(dest, data);
",1,unused,122,unused,"        {
            /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
            size_t dataLen = strlen((char *)data);
            void * dest = (void *)ALLOCA((dataLen+1) * 1);
            (void)strcpy(dest, data);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE135_11.c
"        {
            /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
            size_t dataLen = strlen((char *)data);
            void * dest = (void *)ALLOCA((dataLen+1) * 1);
            (void)strcpy(dest, data);
",1,unused,144,unused,"        {
            /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
            size_t dataLen = strlen((char *)data);
            void * dest = (void *)ALLOCA((dataLen+1) * 1);
            (void)strcpy(dest, data);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE135_11.c
"        {
            /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
            size_t dataLen = strlen((char *)data);
            void * dest = (void *)ALLOCA((dataLen+1) * 1);
            (void)strcpy(dest, data);
",1,unused,129,unused,"        {
            /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
            size_t dataLen = strlen((char *)data);
            void * dest = (void *)ALLOCA((dataLen+1) * 1);
            (void)strcpy(dest, data);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE135_12.c
"        {
            /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
            size_t dataLen = strlen((char *)data);
            void * dest = (void *)ALLOCA((dataLen+1) * 1);
            (void)strcpy(dest, data);
",1,unused,139,unused,"        {
            /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
            size_t dataLen = strlen((char *)data);
            void * dest = (void *)ALLOCA((dataLen+1) * 1);
            (void)strcpy(dest, data);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE135_12.c
"        {
            /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
            size_t dataLen = strlen((char *)data);
            void * dest = (void *)ALLOCA((dataLen+1) * 1);
            (void)strcpy(dest, data);
",1,unused,122,unused,"        {
            /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
            size_t dataLen = strlen((char *)data);
            void * dest = (void *)ALLOCA((dataLen+1) * 1);
            (void)strcpy(dest, data);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE135_13.c
"        {
            /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
            size_t dataLen = strlen((char *)data);
            void * dest = (void *)ALLOCA((dataLen+1) * 1);
            (void)strcpy(dest, data);
",1,unused,144,unused,"        {
            /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
            size_t dataLen = strlen((char *)data);
            void * dest = (void *)ALLOCA((dataLen+1) * 1);
            (void)strcpy(dest, data);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE135_13.c
"        {
            /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
            size_t dataLen = strlen((char *)data);
            void * dest = (void *)ALLOCA((dataLen+1) * 1);
            (void)strcpy(dest, data);
",1,unused,122,unused,"        {
            /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
            size_t dataLen = strlen((char *)data);
            void * dest = (void *)ALLOCA((dataLen+1) * 1);
            (void)strcpy(dest, data);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE135_14.c
"        {
            /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
            size_t dataLen = strlen((char *)data);
            void * dest = (void *)ALLOCA((dataLen+1) * 1);
            (void)strcpy(dest, data);
",1,unused,144,unused,"        {
            /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
            size_t dataLen = strlen((char *)data);
            void * dest = (void *)ALLOCA((dataLen+1) * 1);
            (void)strcpy(dest, data);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE135_14.c
"    {
        /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
        size_t dataLen = strlen((char *)data);
        void * dest = (void *)ALLOCA((dataLen+1) * 1);
        (void)strcpy(dest, data);
",1,unused,155,unused,"    {
        /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
        size_t dataLen = strlen((char *)data);
        void * dest = (void *)ALLOCA((dataLen+1) * 1);
        (void)strcpy(dest, data);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE135_15.c
"    {
        /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
        size_t dataLen = strlen((char *)data);
        void * dest = (void *)ALLOCA((dataLen+1) * 1);
        (void)strcpy(dest, data);
",1,unused,189,unused,"    {
        /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
        size_t dataLen = strlen((char *)data);
        void * dest = (void *)ALLOCA((dataLen+1) * 1);
        (void)strcpy(dest, data);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE135_15.c
"        {
            /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
            size_t dataLen = strlen((char *)data);
            void * dest = (void *)ALLOCA((dataLen+1) * 1);
            (void)strcpy(dest, data);
",1,unused,95,unused,"        {
            /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
            size_t dataLen = strlen((char *)data);
            void * dest = (void *)ALLOCA((dataLen+1) * 1);
            (void)strcpy(dest, data);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE135_16.c
"        {
            /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
            size_t dataLen = strlen((char *)data);
            void * dest = (void *)ALLOCA((dataLen+1) * 1);
            (void)strcpy(dest, data);
",1,unused,93,unused,"        {
            /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
            size_t dataLen = strlen((char *)data);
            void * dest = (void *)ALLOCA((dataLen+1) * 1);
            (void)strcpy(dest, data);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE135_17.c
"    {
        /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
        size_t dataLen = strlen((char *)data);
        void * dest = (void *)ALLOCA((dataLen+1) * 1);
        (void)strcpy(dest, data);
",1,unused,85,unused,"    {
        /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
        size_t dataLen = strlen((char *)data);
        void * dest = (void *)ALLOCA((dataLen+1) * 1);
        (void)strcpy(dest, data);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE135_18.c
"        {
            /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
            size_t dataLen = strlen((char *)data);
            void * dest = (void *)ALLOCA((dataLen+1) * 1);
            (void)strcpy(dest, data);
",1,unused,127,unused,"        {
            /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
            size_t dataLen = strlen((char *)data);
            void * dest = (void *)ALLOCA((dataLen+1) * 1);
            (void)strcpy(dest, data);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE135_21.c
"        {
            /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
            size_t dataLen = strlen((char *)data);
            void * dest = (void *)ALLOCA((dataLen+1) * 1);
            (void)strcpy(dest, data);
",1,unused,94,unused,"        {
            /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
            size_t dataLen = strlen((char *)data);
            void * dest = (void *)ALLOCA((dataLen+1) * 1);
            (void)strcpy(dest, data);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE135_22b.c
"        {
            /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
            size_t dataLen = strlen((char *)data);
            void * dest = (void *)ALLOCA((dataLen+1) * 1);
            (void)strcpy(dest, data);
",1,unused,64,unused,"        {
            /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
            size_t dataLen = strlen((char *)data);
            void * dest = (void *)ALLOCA((dataLen+1) * 1);
            (void)strcpy(dest, data);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE135_31.c
"        {
            /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
            size_t dataLen = strlen((char *)data);
            void * dest = (void *)ALLOCA((dataLen+1) * 1);
            (void)strcpy(dest, data);
",1,unused,72,unused,"        {
            /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
            size_t dataLen = strlen((char *)data);
            void * dest = (void *)ALLOCA((dataLen+1) * 1);
            (void)strcpy(dest, data);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE135_34.c
"    {
        /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
        size_t dataLen = strlen((char *)data);
        void * dest = (void *)ALLOCA((dataLen+1) * 1);
        (void)strcpy(dest, data);
",1,unused,58,unused,"    {
        /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
        size_t dataLen = strlen((char *)data);
        void * dest = (void *)ALLOCA((dataLen+1) * 1);
        (void)strcpy(dest, data);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE135_41.c
"    {
        /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
        size_t dataLen = strlen((char *)data);
        void * dest = (void *)ALLOCA((dataLen+1) * 1);
        (void)strcpy(dest, data);
",1,unused,69,unused,"    {
        /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
        size_t dataLen = strlen((char *)data);
        void * dest = (void *)ALLOCA((dataLen+1) * 1);
        (void)strcpy(dest, data);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE135_42.c
"    {
        /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
        size_t dataLen = strlen((char *)data);
        void * dest = (void *)ALLOCA((dataLen+1) * 1);
        (void)strcpy(dest, data);
",1,unused,61,unused,"    {
        /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
        size_t dataLen = strlen((char *)data);
        void * dest = (void *)ALLOCA((dataLen+1) * 1);
        (void)strcpy(dest, data);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE135_44.c
"    {
        /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
        size_t dataLen = strlen((char *)data);
        void * dest = (void *)ALLOCA((dataLen+1) * 1);
        (void)strcpy(dest, data);
",1,unused,49,unused,"    {
        /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
        size_t dataLen = strlen((char *)data);
        void * dest = (void *)ALLOCA((dataLen+1) * 1);
        (void)strcpy(dest, data);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE135_51b.c
"    {
        /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
        size_t dataLen = strlen((char *)data);
        void * dest = (void *)ALLOCA((dataLen+1) * 1);
        (void)strcpy(dest, data);
",1,unused,49,unused,"    {
        /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
        size_t dataLen = strlen((char *)data);
        void * dest = (void *)ALLOCA((dataLen+1) * 1);
        (void)strcpy(dest, data);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE135_52c.c
"    {
        /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
        size_t dataLen = strlen((char *)data);
        void * dest = (void *)ALLOCA((dataLen+1) * 1);
        (void)strcpy(dest, data);
",1,unused,49,unused,"    {
        /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
        size_t dataLen = strlen((char *)data);
        void * dest = (void *)ALLOCA((dataLen+1) * 1);
        (void)strcpy(dest, data);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE135_53d.c
"    {
        /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
        size_t dataLen = strlen((char *)data);
        void * dest = (void *)ALLOCA((dataLen+1) * 1);
        (void)strcpy(dest, data);
",1,unused,49,unused,"    {
        /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
        size_t dataLen = strlen((char *)data);
        void * dest = (void *)ALLOCA((dataLen+1) * 1);
        (void)strcpy(dest, data);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE135_54e.c
"    {
        /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
        size_t dataLen = strlen((char *)data);
        void * dest = (void *)ALLOCA((dataLen+1) * 1);
        (void)strcpy(dest, data);
",1,unused,60,unused,"    {
        /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
        size_t dataLen = strlen((char *)data);
        void * dest = (void *)ALLOCA((dataLen+1) * 1);
        (void)strcpy(dest, data);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE135_61a.c
"    {
        /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
        size_t dataLen = strlen((char *)data);
        void * dest = (void *)ALLOCA((dataLen+1) * 1);
        (void)strcpy(dest, data);
",1,unused,51,unused,"    {
        /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
        size_t dataLen = strlen((char *)data);
        void * dest = (void *)ALLOCA((dataLen+1) * 1);
        (void)strcpy(dest, data);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE135_63b.c
"    {
        /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
        size_t dataLen = strlen((char *)data);
        void * dest = (void *)ALLOCA((dataLen+1) * 1);
        (void)strcpy(dest, data);
",1,unused,57,unused,"    {
        /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
        size_t dataLen = strlen((char *)data);
        void * dest = (void *)ALLOCA((dataLen+1) * 1);
        (void)strcpy(dest, data);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE135_64b.c
"    {
        /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
        size_t dataLen = strlen((char *)data);
        void * dest = (void *)ALLOCA((dataLen+1) * 1);
        (void)strcpy(dest, data);
",1,unused,49,unused,"    {
        /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
        size_t dataLen = strlen((char *)data);
        void * dest = (void *)ALLOCA((dataLen+1) * 1);
        (void)strcpy(dest, data);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE135_65b.c
"    {
        /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
        size_t dataLen = strlen((char *)data);
        void * dest = (void *)ALLOCA((dataLen+1) * 1);
        (void)strcpy(dest, data);
",1,unused,52,unused,"    {
        /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
        size_t dataLen = strlen((char *)data);
        void * dest = (void *)ALLOCA((dataLen+1) * 1);
        (void)strcpy(dest, data);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE135_66b.c
"    {
        /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
        size_t dataLen = strlen((char *)data);
        void * dest = (void *)ALLOCA((dataLen+1) * 1);
        (void)strcpy(dest, data);
",1,unused,56,unused,"    {
        /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
        size_t dataLen = strlen((char *)data);
        void * dest = (void *)ALLOCA((dataLen+1) * 1);
        (void)strcpy(dest, data);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE135_67b.c
"    {
        /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
        size_t dataLen = strlen((char *)data);
        void * dest = (void *)ALLOCA((dataLen+1) * 1);
        (void)strcpy(dest, data);
",1,unused,55,unused,"    {
        /* POTENTIAL FLAW: treating pointer as a char* when it may point to a wide string */
        size_t dataLen = strlen((char *)data);
        void * dest = (void *)ALLOCA((dataLen+1) * 1);
        (void)strcpy(dest, data);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE135_68b.c
"    }
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",1,unused,43,unused,"    }
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_03.c
"    }
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",1,unused,73,unused,"    }
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_03.c
"    }
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",1,unused,94,unused,"    }
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_03.c
"    }
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",1,unused,50,unused,"    }
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_04.c
"    }
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",1,unused,80,unused,"    }
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_04.c
"    }
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",1,unused,101,unused,"    }
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_04.c
"    }
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",1,unused,50,unused,"    }
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_05.c
"    }
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",1,unused,80,unused,"    }
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_05.c
"    }
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",1,unused,101,unused,"    }
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_05.c
"    }
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",1,unused,47,unused,"    }
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_06.c
"    }
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",1,unused,77,unused,"    }
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_06.c
"    }
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",1,unused,98,unused,"    }
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_06.c
"    }
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",1,unused,49,unused,"    }
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_07.c
"    }
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",1,unused,79,unused,"    }
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_07.c
"    }
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",1,unused,100,unused,"    }
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_07.c
"    }
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",1,unused,57,unused,"    }
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_08.c
"    }
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",1,unused,87,unused,"    }
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_08.c
"    }
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",1,unused,108,unused,"    }
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_08.c
"    }
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",1,unused,43,unused,"    }
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_09.c
"    }
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",1,unused,73,unused,"    }
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_09.c
"    }
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",1,unused,94,unused,"    }
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_09.c
"    }
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",1,unused,43,unused,"    }
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_10.c
"    }
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",1,unused,73,unused,"    }
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_10.c
"    }
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",1,unused,94,unused,"    }
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_10.c
"    }
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",1,unused,50,unused,"    }
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_12.c
"    }
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",1,unused,83,unused,"    }
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_12.c
"    }
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",1,unused,43,unused,"    }
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_13.c
"    }
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",1,unused,73,unused,"    }
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_13.c
"    }
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",1,unused,94,unused,"    }
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_13.c
"    }
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",1,unused,43,unused,"    }
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_14.c
"    }
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",1,unused,73,unused,"    }
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_14.c
"    }
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",1,unused,94,unused,"    }
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_14.c
"    }
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",1,unused,49,unused,"    }
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_15.c
"    }
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",1,unused,80,unused,"    }
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_15.c
"    }
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",1,unused,107,unused,"    }
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_15.c
"    }
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",1,unused,44,unused,"    }
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_16.c
"    }
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",1,unused,70,unused,"    }
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_16.c
"    }
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",1,unused,44,unused,"    }
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_17.c
"    }
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",1,unused,70,unused,"    }
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_17.c
"    data[0] = '\0'; /* null terminate */
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",1,unused,42,unused,"    data[0] = '\0'; /* null terminate */
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_18.c
"    data[0] = '\0'; /* null terminate */
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",1,unused,66,unused,"    data[0] = '\0'; /* null terminate */
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_18.c
"        char * data = dataCopy;
        {
            char source[10+1] = SRC_STRING;
            /* POTENTIAL FLAW: data may not have enough space to hold source */
            strcpy(data, source);
",1,unused,43,unused,"        char * data = dataCopy;
        {
            char source[10+1] = SRC_STRING;
            /* POTENTIAL FLAW: data may not have enough space to hold source */
            strcpy(data, source);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_31.c
"        char * data = dataCopy;
        {
            char source[10+1] = SRC_STRING;
            /* POTENTIAL FLAW: data may not have enough space to hold source */
            strcpy(data, source);
",1,unused,69,unused,"        char * data = dataCopy;
        {
            char source[10+1] = SRC_STRING;
            /* POTENTIAL FLAW: data may not have enough space to hold source */
            strcpy(data, source);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_31.c
"        char * data = *dataPtr2;
        {
            char source[10+1] = SRC_STRING;
            /* POTENTIAL FLAW: data may not have enough space to hold source */
            strcpy(data, source);
",1,unused,48,unused,"        char * data = *dataPtr2;
        {
            char source[10+1] = SRC_STRING;
            /* POTENTIAL FLAW: data may not have enough space to hold source */
            strcpy(data, source);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_32.c
"        char * data = *dataPtr2;
        {
            char source[10+1] = SRC_STRING;
            /* POTENTIAL FLAW: data may not have enough space to hold source */
            strcpy(data, source);
",1,unused,79,unused,"        char * data = *dataPtr2;
        {
            char source[10+1] = SRC_STRING;
            /* POTENTIAL FLAW: data may not have enough space to hold source */
            strcpy(data, source);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_32.c
"        char * data = myUnion.unionSecond;
        {
            char source[10+1] = SRC_STRING;
            /* POTENTIAL FLAW: data may not have enough space to hold source */
            strcpy(data, source);
",1,unused,50,unused,"        char * data = myUnion.unionSecond;
        {
            char source[10+1] = SRC_STRING;
            /* POTENTIAL FLAW: data may not have enough space to hold source */
            strcpy(data, source);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_34.c
"        char * data = myUnion.unionSecond;
        {
            char source[10+1] = SRC_STRING;
            /* POTENTIAL FLAW: data may not have enough space to hold source */
            strcpy(data, source);
",1,unused,77,unused,"        char * data = myUnion.unionSecond;
        {
            char source[10+1] = SRC_STRING;
            /* POTENTIAL FLAW: data may not have enough space to hold source */
            strcpy(data, source);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_34.c
"{
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",1,unused,33,unused,"{
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_41.c
"{
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",1,unused,59,unused,"{
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_41.c
"{
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",1,unused,33,unused,"{
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_44.c
"{
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",1,unused,63,unused,"{
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_44.c
"    char * data = CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_45_badData;
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",1,unused,37,unused,"    char * data = CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_45_badData;
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_45.c
"    char * data = CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_45_goodG2BData;
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",1,unused,66,unused,"    char * data = CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_45_goodG2BData;
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_45.c
"{
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",1,unused,35,unused,"{
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_51b.c
"{
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",1,unused,50,unused,"{
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_51b.c
"{
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",1,unused,35,unused,"{
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_52c.c
"{
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",1,unused,50,unused,"{
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_52c.c
"{
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",1,unused,35,unused,"{
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_53d.c
"{
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",1,unused,50,unused,"{
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_53d.c
"{
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",1,unused,35,unused,"{
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_54e.c
"{
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",1,unused,50,unused,"{
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_54e.c
"    char * data = *dataPtr;
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",1,unused,34,unused,"    char * data = *dataPtr;
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_63b.c
"    char * data = *dataPtr;
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",1,unused,50,unused,"    char * data = *dataPtr;
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_63b.c
"    char * data = (*dataPtr);
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",1,unused,37,unused,"    char * data = (*dataPtr);
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_64b.c
"    char * data = (*dataPtr);
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",1,unused,56,unused,"    char * data = (*dataPtr);
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_64b.c
"{
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",1,unused,33,unused,"{
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_65b.c
"{
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",1,unused,48,unused,"{
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_65b.c
"    char * data = dataArray[2];
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",1,unused,35,unused,"    char * data = dataArray[2];
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_66b.c
"    char * data = dataArray[2];
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",1,unused,51,unused,"    char * data = dataArray[2];
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_66b.c
"    char * data = myStruct.structFirst;
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",1,unused,39,unused,"    char * data = myStruct.structFirst;
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_67b.c
"    char * data = myStruct.structFirst;
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",1,unused,55,unused,"    char * data = myStruct.structFirst;
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_67b.c
"    char * data = CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_68_badData;
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",1,unused,39,unused,"    char * data = CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_68_badData;
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_68b.c
"    char * data = CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_68_goodG2BData;
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",1,unused,55,unused,"    char * data = CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_68_goodG2BData;
    {
        char source[10+1] = SRC_STRING;
        /* POTENTIAL FLAW: data may not have enough space to hold source */
        strcpy(data, source);
",unused,juliet_testsuite_CWE121_S01-CWE121_Stack_Based_Buffer_Overflow__CWE193_char_alloca_cpy_68b.c
"	FILE *fp;

	ispipe = 1;
	pipe_cmd = xmalloc(strlen(dc->cmd) + strlen(pathname) + 2);
	sprintf(pipe_cmd, ""%s %s"", dc->cmd, pathname);
",1,unused,48,unused,"	FILE *fp;

	ispipe = 1;
	pipe_cmd = xmalloc(strlen(dc->cmd) + strlen(pathname) + 2);
	sprintf(pipe_cmd, ""%s %s"", dc->cmd, pathname);
",unused,kbdartful-src2Ffindfile.c
"
		if (fnam_len + sp_len + 1 > sizeof(pathname))
			continue;

		sprintf(pathname, ""%s%s"", fnam, *sp);
",1,unused,96,unused,"
		if (fnam_len + sp_len + 1 > sizeof(pathname))
			continue;

		sprintf(pathname, ""%s%s"", fnam, *sp);
",unused,kbdartful-src2Ffindfile.c
"		for (dc = &decompressors[0]; dc->cmd; dc++) {
			if (fnam_len + sp_len + strlen(dc->ext) + 1 > sizeof(pathname))
				continue;

			sprintf(pathname, ""%s%s%s"", fnam, *sp, dc->ext);
",1,unused,107,unused,"		for (dc = &decompressors[0]; dc->cmd; dc++) {
			if (fnam_len + sp_len + strlen(dc->ext) + 1 > sizeof(pathname))
				continue;

			sprintf(pathname, ""%s%s%s"", fnam, *sp, dc->ext);
",unused,kbdartful-src2Ffindfile.c
"	    if ((secondpass && recdepth) || okdir) {
		char *a;

		a = xmalloc(dir_len + d_len + 2);
		sprintf(a, ""%s/%s"", dir, de->d_name);
",1,unused,167,unused,"	    if ((secondpass && recdepth) || okdir) {
		char *a;

		a = xmalloc(dir_len + d_len + 2);
		sprintf(a, ""%s/%s"", dir, de->d_name);
",unused,kbdartful-src2Ffindfile.c
"	    while (*p && *p == *q) p++,q++;
	    if (*q)
		    continue;

	    sprintf(pathname, ""%s/%s"", dir, de->d_name);
",1,unused,198,unused,"	    while (*p && *p == *q) p++,q++;
	    if (*q)
		    continue;

	    sprintf(pathname, ""%s/%s"", dir, de->d_name);
",unused,kbdartful-src2Ffindfile.c
"	if (strlen(fnam) >= sizeof(pathname))
		return NULL;

	/* Try explicitly given name first */
	strcpy(pathname, fnam);
",1,unused,246,unused,"	if (strlen(fnam) >= sizeof(pathname))
		return NULL;

	/* Try explicitly given name first */
	strcpy(pathname, fnam);
",unused,kbdartful-src2Ffindfile.c
"			for (i = charsets[i].start; i < 256; i++,p++) {
				if(p->name[0])
					syms[0].table[i] = p->name;
			}
			strcpy(chosen_charset, charset);
",1,unused,1703,unused,"			for (i = charsets[i].start; i < 256; i++,p++) {
				if(p->name[0])
					syms[0].table[i] = p->name;
			}
			strcpy(chosen_charset, charset);
",unused,kbdartful-src2Fksyms.c
"		len = strlen(t);
		include_dirpath2[0] = t;
		include_dirpath2[1] = t1 = xmalloc(len + 12);
		include_dirpath2[2] = t2 = xmalloc(len + 15);
		strcpy(t1, t);
",1,unused,952,unused,"		len = strlen(t);
		include_dirpath2[0] = t;
		include_dirpath2[1] = t1 = xmalloc(len + 12);
		include_dirpath2[2] = t2 = xmalloc(len + 15);
		strcpy(t1, t);
",unused,kbdartful-src2Floadkeys.analyze.c
"		include_dirpath2[0] = t;
		include_dirpath2[1] = t1 = xmalloc(len + 12);
		include_dirpath2[2] = t2 = xmalloc(len + 15);
		strcpy(t1, t);
		strcat(t1, ""../include/"");
",1,unused,953,unused,"		include_dirpath2[0] = t;
		include_dirpath2[1] = t1 = xmalloc(len + 12);
		include_dirpath2[2] = t2 = xmalloc(len + 15);
		strcpy(t1, t);
		strcat(t1, ""../include/"");
",unused,kbdartful-src2Floadkeys.analyze.c
"		include_dirpath2[1] = t1 = xmalloc(len + 12);
		include_dirpath2[2] = t2 = xmalloc(len + 15);
		strcpy(t1, t);
		strcat(t1, ""../include/"");
		strcpy(t2, t);
",1,unused,954,unused,"		include_dirpath2[1] = t1 = xmalloc(len + 12);
		include_dirpath2[2] = t2 = xmalloc(len + 15);
		strcpy(t1, t);
		strcat(t1, ""../include/"");
		strcpy(t2, t);
",unused,kbdartful-src2Floadkeys.analyze.c
"		include_dirpath2[2] = t2 = xmalloc(len + 15);
		strcpy(t1, t);
		strcat(t1, ""../include/"");
		strcpy(t2, t);
		strcat(t2, ""../../include/"");
",1,unused,955,unused,"		include_dirpath2[2] = t2 = xmalloc(len + 15);
		strcpy(t1, t);
		strcat(t1, ""../include/"");
		strcpy(t2, t);
		strcat(t2, ""../../include/"");
",unused,kbdartful-src2Floadkeys.analyze.c
"			if (buf[0] == '/') {
				f = find_incl_file_near_fn(s, buf);

			} else if (strlen(filename) + n < sizeof(path)) {
				strcpy(path, filename);
",1,unused,984,unused,"			if (buf[0] == '/') {
				f = find_incl_file_near_fn(s, buf);

			} else if (strlen(filename) + n < sizeof(path)) {
				strcpy(path, filename);
",unused,kbdartful-src2Floadkeys.analyze.c
"				path[sizeof(path) - 1] = 0;
				ptr = strrchr(path, '/');
				if (ptr)
					ptr[1] = 0;
				strcat(path, buf);
",1,unused,989,unused,"				path[sizeof(path) - 1] = 0;
				ptr = strrchr(path, '/');
				if (ptr)
					ptr[1] = 0;
				strcat(path, buf);
",unused,kbdartful-src2Floadkeys.analyze.c
"				char *ptmp = p;
				p += strlen(yytext);
				if (p > pmax)
					lkfatal(_(""string too long""));
				strcpy(ptmp, yytext);
",1,unused,1675,unused,"				char *ptmp = p;
				p += strlen(yytext);
				if (p > pmax)
					lkfatal(_(""string too long""));
				strcpy(ptmp, yytext);
",unused,kbdartful-src2Floadkeys.analyze.c
"		openvt_fatal(1, errno, ""opendir(/proc)"");

	/* get the current tty */
	/* try /dev/ttyN, then /dev/vc/N */
	sprintf(filename, VTNAME, curvt);
",1,unused,133,unused,"		openvt_fatal(1, errno, ""opendir(/proc)"");

	/* get the current tty */
	/* try /dev/ttyN, then /dev/vc/N */
	sprintf(filename, VTNAME, curvt);
",unused,kbdartful-src2Fopenvt.c
"	/* try /dev/ttyN, then /dev/vc/N */
	sprintf(filename, VTNAME, curvt);
	if (stat(filename, &buf)) {
		int errsv = errno;
		sprintf(filename, VTNAME2, curvt);
",1,unused,136,unused,"	/* try /dev/ttyN, then /dev/vc/N */
	sprintf(filename, VTNAME, curvt);
	if (stat(filename, &buf)) {
		int errsv = errno;
		sprintf(filename, VTNAME2, curvt);
",unused,kbdartful-src2Fopenvt.c
"		int errsv = errno;
		sprintf(filename, VTNAME2, curvt);
		if (stat(filename, &buf)) {
			/* give error message for first attempt */
			sprintf(filename, VTNAME, curvt);
",1,unused,139,unused,"		int errsv = errno;
		sprintf(filename, VTNAME2, curvt);
		if (stat(filename, &buf)) {
			/* give error message for first attempt */
			sprintf(filename, VTNAME, curvt);
",unused,kbdartful-src2Fopenvt.c
"
	/* check to make sure that user has a process on that tty */
	/* this will fail for example when X is running on the tty */
	while ((dentp = readdir(dp))) {
		sprintf(filename, ""/proc/%s/fd/0"", dentp->d_name);
",1,unused,154,unused,"
	/* check to make sure that user has a process on that tty */
	/* this will fail for example when X is running on the tty */
	while ((dentp = readdir(dp))) {
		sprintf(filename, ""/proc/%s/fd/0"", dentp->d_name);
",unused,kbdartful-src2Fopenvt.c
"			cmd = xmalloc(strlen(argv[optind]) + 2);
		}

		if (login)
			strcpy(cmd, ""-"");
",1,unused,313,unused,"			cmd = xmalloc(strlen(argv[optind]) + 2);
		}

		if (login)
			strcpy(cmd, ""-"");
",unused,kbdartful-src2Fopenvt.c
"		else
			cmd[0] = '\0';

		if (def_cmd)
			strcat(cmd, def_cmd);
",1,unused,318,unused,"		else
			cmd[0] = '\0';

		if (def_cmd)
			strcat(cmd, def_cmd);
",unused,kbdartful-src2Fopenvt.c
"
		if (def_cmd)
			strcat(cmd, def_cmd);
		else
			strcat(cmd, argv[optind]);
",1,unused,320,unused,"
		if (def_cmd)
			strcat(cmd, def_cmd);
		else
			strcat(cmd, argv[optind]);
",unused,kbdartful-src2Fopenvt.c
"#endif				/* ESIX_5_3_2_D */
				openvt_fatal(5, errno, _(""Unable to set new session""));
		}

		sprintf(vtname, VTNAME, vtno);
",1,unused,341,unused,"#endif				/* ESIX_5_3_2_D */
				openvt_fatal(5, errno, _(""Unable to set new session""));
		}

		sprintf(vtname, VTNAME, vtno);
",unused,kbdartful-src2Fopenvt.c
"				   used it and did a chown.  Try a few vt's more
				   before giving up. Note: the 16 is a kernel limitation. */
				for (i = vtno + 1; i < 16; i++) {
					if ((vtstat.v_state & (1 << i)) == 0) {
						sprintf(vtname, VTNAME, i);
",1,unused,353,unused,"				   used it and did a chown.  Try a few vt's more
				   before giving up. Note: the 16 is a kernel limitation. */
				for (i = vtno + 1; i < 16; i++) {
					if ((vtstat.v_state & (1 << i)) == 0) {
						sprintf(vtname, VTNAME, i);
",unused,kbdartful-src2Fopenvt.c
"							goto got_vtno;
						}
					}
				}
				sprintf(vtname, VTNAME, vtno);
",1,unused,360,unused,"							goto got_vtno;
						}
					}
				}
				sprintf(vtname, VTNAME, vtno);
",unused,kbdartful-src2Fopenvt.c
"      usage();

    if (mode == MODE_RESTORETEXTMODE) {
        /* prepare for: restoretextmode -r 80x25 */
        sprintf(infile, ""%dx%d"", cc, rr);
",1,unused,151,unused,"      usage();

    if (mode == MODE_RESTORETEXTMODE) {
        /* prepare for: restoretextmode -r 80x25 */
        sprintf(infile, ""%dx%d"", cc, rr);
",unused,kbdartful-src2Fresizecons.c
"    }

    if (mode == MODE_RESTORETEXTMODE) {
	/* do: restoretextmode -r 25x80 */
	sprintf(cmd, ""restoretextmode -r %s\n"", pathname);
",1,unused,247,unused,"    }

    if (mode == MODE_RESTORETEXTMODE) {
	/* do: restoretextmode -r 25x80 */
	sprintf(cmd, ""restoretextmode -r %s\n"", pathname);
",unused,kbdartful-src2Fresizecons.c
"    winsize.ws_row = rr;
    winsize.ws_col = cc;
    for (i=0; i<16; i++)
      if (vtstat.v_state & (1<<i)) {
	  sprintf(tty, ""/dev/tty%d"", i);
",1,unused,268,unused,"    winsize.ws_row = rr;
    winsize.ws_col = cc;
    for (i=0; i<16; i++)
      if (vtstat.v_state & (1<<i)) {
	  sprintf(tty, ""/dev/tty%d"", i);
",unused,kbdartful-src2Fresizecons.c
"      if (vtstat.v_state & (1<<i)) {
	  sprintf(tty, ""/dev/tty%d"", i);
	  fd = open(tty, O_RDONLY);
	  if (fd < 0 && errno == ENOENT) {
	      sprintf(tty, ""/dev/vc/%d"", i);
",1,unused,271,unused,"      if (vtstat.v_state & (1<<i)) {
	  sprintf(tty, ""/dev/tty%d"", i);
	  fd = open(tty, O_RDONLY);
	  if (fd < 0 && errno == ENOENT) {
	      sprintf(tty, ""/dev/vc/%d"", i);
",unused,kbdartful-src2Fresizecons.c
"    case 16 :
    default : defaultfont = ""default8x16""; break;
    }

    sprintf(cmd, ""setfont %s"", defaultfont);
",1,unused,316,unused,"    case 16 :
    default : defaultfont = ""default8x16""; break;
    }

    sprintf(cmd, ""setfont %s"", defaultfont);
",unused,kbdartful-src2Fresizecons.c
"				fprintf(stderr, _(""Cannot find default font\n""));
				exit(EX_NOINPUT);
			}
		} else {
			sprintf(defname, ""default8x%d"", iunit);
",1,unused,491,unused,"				fprintf(stderr, _(""Cannot find default font\n""));
				exit(EX_NOINPUT);
			}
		} else {
			sprintf(defname, ""default8x%d"", iunit);
",unused,kbdartful-src2Fsetfont.c
"		if ((st.st_rdev >> 8) != 4)
			break;

		i = st.st_rdev & 0xff;
		sprintf(path, ""/dev/vcsa%u"", i);
",1,unused,59,unused,"		if ((st.st_rdev >> 8) != 4)
			break;

		i = st.st_rdev & 0xff;
		sprintf(path, ""/dev/vcsa%u"", i);
",unused,kbdartful-src2Fvlock2Fscreen.c
"			for (i = charsets[i].start; i < 256; i++,p++) {
				if(p->name[0])
					syms[0].table[i] = p->name;
			}
			strcpy(chosen_charset, charset);
",1,unused,1703,unused,"			for (i = charsets[i].start; i < 256; i++,p++) {
				if(p->name[0])
					syms[0].table[i] = p->name;
			}
			strcpy(chosen_charset, charset);
",unused,kbdsource-src2Fksyms.c
"		len = strlen(t);
		include_dirpath2[0] = t;
		include_dirpath2[1] = t1 = xmalloc(len + 12);
		include_dirpath2[2] = t2 = xmalloc(len + 15);
		strcpy(t1, t);
",1,unused,952,unused,"		len = strlen(t);
		include_dirpath2[0] = t;
		include_dirpath2[1] = t1 = xmalloc(len + 12);
		include_dirpath2[2] = t2 = xmalloc(len + 15);
		strcpy(t1, t);
",unused,kbdsource-src2Floadkeys.analyze.c
"		include_dirpath2[0] = t;
		include_dirpath2[1] = t1 = xmalloc(len + 12);
		include_dirpath2[2] = t2 = xmalloc(len + 15);
		strcpy(t1, t);
		strcat(t1, ""../include/"");
",1,unused,953,unused,"		include_dirpath2[0] = t;
		include_dirpath2[1] = t1 = xmalloc(len + 12);
		include_dirpath2[2] = t2 = xmalloc(len + 15);
		strcpy(t1, t);
		strcat(t1, ""../include/"");
",unused,kbdsource-src2Floadkeys.analyze.c
"		include_dirpath2[1] = t1 = xmalloc(len + 12);
		include_dirpath2[2] = t2 = xmalloc(len + 15);
		strcpy(t1, t);
		strcat(t1, ""../include/"");
		strcpy(t2, t);
",1,unused,954,unused,"		include_dirpath2[1] = t1 = xmalloc(len + 12);
		include_dirpath2[2] = t2 = xmalloc(len + 15);
		strcpy(t1, t);
		strcat(t1, ""../include/"");
		strcpy(t2, t);
",unused,kbdsource-src2Floadkeys.analyze.c
"		include_dirpath2[2] = t2 = xmalloc(len + 15);
		strcpy(t1, t);
		strcat(t1, ""../include/"");
		strcpy(t2, t);
		strcat(t2, ""../../include/"");
",1,unused,955,unused,"		include_dirpath2[2] = t2 = xmalloc(len + 15);
		strcpy(t1, t);
		strcat(t1, ""../include/"");
		strcpy(t2, t);
		strcat(t2, ""../../include/"");
",unused,kbdsource-src2Floadkeys.analyze.c
"			if (buf[0] == '/') {
				f = find_incl_file_near_fn(s, buf);

			} else if (strlen(filename) + n < sizeof(path)) {
				strcpy(path, filename);
",1,unused,984,unused,"			if (buf[0] == '/') {
				f = find_incl_file_near_fn(s, buf);

			} else if (strlen(filename) + n < sizeof(path)) {
				strcpy(path, filename);
",unused,kbdsource-src2Floadkeys.analyze.c
"				path[sizeof(path) - 1] = 0;
				ptr = strrchr(path, '/');
				if (ptr)
					ptr[1] = 0;
				strcat(path, buf);
",1,unused,989,unused,"				path[sizeof(path) - 1] = 0;
				ptr = strrchr(path, '/');
				if (ptr)
					ptr[1] = 0;
				strcat(path, buf);
",unused,kbdsource-src2Floadkeys.analyze.c
"				char *ptmp = p;
				p += strlen(yytext);
				if (p > pmax)
					lkfatal(_(""string too long""));
				strcpy(ptmp, yytext);
",1,unused,1675,unused,"				char *ptmp = p;
				p += strlen(yytext);
				if (p > pmax)
					lkfatal(_(""string too long""));
				strcpy(ptmp, yytext);
",unused,kbdsource-src2Floadkeys.analyze.c
"	fp += sh;
	r = fp;
	while (q > ptr)
		*--r = *--q;
	strcpy(ptr, (char *)kbs.kb_string);
",1,unused,334,unused,"	fp += sh;
	r = fp;
	while (q > ptr)
		*--r = *--q;
	strcpy(ptr, (char *)kbs.kb_string);
",unused,kbdsource-src2Floadkeys.c
"	for (i = 0; i < MAX_NR_FUNC; i++) {
		kbs_buf.kb_func = i;

		if ((ptr = func_table[i])) {
			strcpy((char *)kbs_buf.kb_string, ptr);
",1,unused,508,unused,"	for (i = 0; i < MAX_NR_FUNC; i++) {
		kbs_buf.kb_func = i;

		if ((ptr = func_table[i])) {
			strcpy((char *)kbs_buf.kb_string, ptr);
",unused,kbdsource-src2Floadkeys.c
"	buf[0] = 0;
	for (i = 0; i < 8; i++)
		if (modifier & (1 << i)) {
			if (buf[0])
				strcat(buf, ""_"");
",1,unused,774,unused,"	buf[0] = 0;
	for (i = 0; i < 8; i++)
		if (modifier & (1 << i)) {
			if (buf[0])
				strcat(buf, ""_"");
",unused,kbdsource-src2Floadkeys.c
"	for (i = 0; i < 8; i++)
		if (modifier & (1 << i)) {
			if (buf[0])
				strcat(buf, ""_"");
			strcat(buf, modifiers[i]);
",1,unused,775,unused,"	for (i = 0; i < 8; i++)
		if (modifier & (1 << i)) {
			if (buf[0])
				strcat(buf, ""_"");
			strcat(buf, modifiers[i]);
",unused,kbdsource-src2Floadkeys.c
"		}
		parse_keymap(f);

	} else if (optind == argc) {
		strcpy(pathname, ""<stdin>"");
",1,unused,2856,unused,"		}
		parse_keymap(f);

	} else if (optind == argc) {
		strcpy(pathname, ""<stdin>"");
",unused,kbdsource-src2Floadkeys.c
"
	for (i = optind; argv[i]; i++) {
		if (!strcmp(argv[i], ""-"")) {
			f = stdin;
			strcpy(pathname, ""<stdin>"");
",1,unused,2863,unused,"
	for (i = optind; argv[i]; i++) {
		if (!strcmp(argv[i], ""-"")) {
			f = stdin;
			strcpy(pathname, ""<stdin>"");
",unused,kbdsource-src2Floadkeys.c
"		openvt_fatal(1, errno, ""opendir(/proc)"");

	/* get the current tty */
	/* try /dev/ttyN, then /dev/vc/N */
	sprintf(filename, VTNAME, curvt);
",1,unused,133,unused,"		openvt_fatal(1, errno, ""opendir(/proc)"");

	/* get the current tty */
	/* try /dev/ttyN, then /dev/vc/N */
	sprintf(filename, VTNAME, curvt);
",unused,kbdsource-src2Fopenvt.c
"	/* try /dev/ttyN, then /dev/vc/N */
	sprintf(filename, VTNAME, curvt);
	if (stat(filename, &buf)) {
		int errsv = errno;
		sprintf(filename, VTNAME2, curvt);
",1,unused,136,unused,"	/* try /dev/ttyN, then /dev/vc/N */
	sprintf(filename, VTNAME, curvt);
	if (stat(filename, &buf)) {
		int errsv = errno;
		sprintf(filename, VTNAME2, curvt);
",unused,kbdsource-src2Fopenvt.c
"		int errsv = errno;
		sprintf(filename, VTNAME2, curvt);
		if (stat(filename, &buf)) {
			/* give error message for first attempt */
			sprintf(filename, VTNAME, curvt);
",1,unused,139,unused,"		int errsv = errno;
		sprintf(filename, VTNAME2, curvt);
		if (stat(filename, &buf)) {
			/* give error message for first attempt */
			sprintf(filename, VTNAME, curvt);
",unused,kbdsource-src2Fopenvt.c
"
	/* check to make sure that user has a process on that tty */
	/* this will fail for example when X is running on the tty */
	while ((dentp = readdir(dp))) {
		sprintf(filename, ""/proc/%s/fd/0"", dentp->d_name);
",1,unused,154,unused,"
	/* check to make sure that user has a process on that tty */
	/* this will fail for example when X is running on the tty */
	while ((dentp = readdir(dp))) {
		sprintf(filename, ""/proc/%s/fd/0"", dentp->d_name);
",unused,kbdsource-src2Fopenvt.c
"			cmd = xmalloc(strlen(argv[optind]) + 2);
		}

		if (login)
			strcpy(cmd, ""-"");
",1,unused,311,unused,"			cmd = xmalloc(strlen(argv[optind]) + 2);
		}

		if (login)
			strcpy(cmd, ""-"");
",unused,kbdsource-src2Fopenvt.c
"		else
			cmd[0] = '\0';

		if (def_cmd)
			strcat(cmd, def_cmd);
",1,unused,316,unused,"		else
			cmd[0] = '\0';

		if (def_cmd)
			strcat(cmd, def_cmd);
",unused,kbdsource-src2Fopenvt.c
"
		if (def_cmd)
			strcat(cmd, def_cmd);
		else
			strcat(cmd, argv[optind]);
",1,unused,318,unused,"
		if (def_cmd)
			strcat(cmd, def_cmd);
		else
			strcat(cmd, argv[optind]);
",unused,kbdsource-src2Fopenvt.c
"#endif				/* ESIX_5_3_2_D */
				openvt_fatal(5, errno, _(""Unable to set new session""));
		}

		sprintf(vtname, VTNAME, vtno);
",1,unused,339,unused,"#endif				/* ESIX_5_3_2_D */
				openvt_fatal(5, errno, _(""Unable to set new session""));
		}

		sprintf(vtname, VTNAME, vtno);
",unused,kbdsource-src2Fopenvt.c
"				   used it and did a chown.  Try a few vt's more
				   before giving up. Note: the 16 is a kernel limitation. */
				for (i = vtno + 1; i < 16; i++) {
					if ((vtstat.v_state & (1 << i)) == 0) {
						sprintf(vtname, VTNAME, i);
",1,unused,351,unused,"				   used it and did a chown.  Try a few vt's more
				   before giving up. Note: the 16 is a kernel limitation. */
				for (i = vtno + 1; i < 16; i++) {
					if ((vtstat.v_state & (1 << i)) == 0) {
						sprintf(vtname, VTNAME, i);
",unused,kbdsource-src2Fopenvt.c
"							goto got_vtno;
						}
					}
				}
				sprintf(vtname, VTNAME, vtno);
",1,unused,358,unused,"							goto got_vtno;
						}
					}
				}
				sprintf(vtname, VTNAME, vtno);
",unused,kbdsource-src2Fopenvt.c
"      usage();

    if (mode == MODE_RESTORETEXTMODE) {
        /* prepare for: restoretextmode -r 80x25 */
        sprintf(infile, ""%dx%d"", cc, rr);
",1,unused,151,unused,"      usage();

    if (mode == MODE_RESTORETEXTMODE) {
        /* prepare for: restoretextmode -r 80x25 */
        sprintf(infile, ""%dx%d"", cc, rr);
",unused,kbdsource-src2Fresizecons.c
"    }

    if (mode == MODE_RESTORETEXTMODE) {
	/* do: restoretextmode -r 25x80 */
	sprintf(cmd, ""restoretextmode -r %s\n"", pathname);
",1,unused,247,unused,"    }

    if (mode == MODE_RESTORETEXTMODE) {
	/* do: restoretextmode -r 25x80 */
	sprintf(cmd, ""restoretextmode -r %s\n"", pathname);
",unused,kbdsource-src2Fresizecons.c
"    winsize.ws_row = rr;
    winsize.ws_col = cc;
    for (i=0; i<16; i++)
      if (vtstat.v_state & (1<<i)) {
	  sprintf(tty, ""/dev/tty%d"", i);
",1,unused,268,unused,"    winsize.ws_row = rr;
    winsize.ws_col = cc;
    for (i=0; i<16; i++)
      if (vtstat.v_state & (1<<i)) {
	  sprintf(tty, ""/dev/tty%d"", i);
",unused,kbdsource-src2Fresizecons.c
"      if (vtstat.v_state & (1<<i)) {
	  sprintf(tty, ""/dev/tty%d"", i);
	  fd = open(tty, O_RDONLY);
	  if (fd < 0 && errno == ENOENT) {
	      sprintf(tty, ""/dev/vc/%d"", i);
",1,unused,271,unused,"      if (vtstat.v_state & (1<<i)) {
	  sprintf(tty, ""/dev/tty%d"", i);
	  fd = open(tty, O_RDONLY);
	  if (fd < 0 && errno == ENOENT) {
	      sprintf(tty, ""/dev/vc/%d"", i);
",unused,kbdsource-src2Fresizecons.c
"    case 16 :
    default : defaultfont = ""default8x16""; break;
    }

    sprintf(cmd, ""setfont %s"", defaultfont);
",1,unused,316,unused,"    case 16 :
    default : defaultfont = ""default8x16""; break;
    }

    sprintf(cmd, ""setfont %s"", defaultfont);
",unused,kbdsource-src2Fresizecons.c
"				fprintf(stderr, _(""Cannot find default font\n""));
				exit(EX_NOINPUT);
			}
		} else {
			sprintf(defname, ""default8x%d"", iunit);
",1,unused,491,unused,"				fprintf(stderr, _(""Cannot find default font\n""));
				exit(EX_NOINPUT);
			}
		} else {
			sprintf(defname, ""default8x%d"", iunit);
",unused,kbdsource-src2Fsetfont.c
"		if ((st.st_rdev >> 8) != 4)
			break;

		i = st.st_rdev & 0xff;
		sprintf(path, ""/dev/vcsa%u"", i);
",1,unused,59,unused,"		if ((st.st_rdev >> 8) != 4)
			break;

		i = st.st_rdev & 0xff;
		sprintf(path, ""/dev/vcsa%u"", i);
",unused,kbdsource-src2Fvlock2Fscreen.c
"			for (i = charsets[i].start; i < 256; i++,p++) {
				if(p->name[0])
					syms[0].table[i] = p->name;
			}
			strcpy(chosen_charset, charset);
",1,unused,1703,unused,"			for (i = charsets[i].start; i < 256; i++,p++) {
				if(p->name[0])
					syms[0].table[i] = p->name;
			}
			strcpy(chosen_charset, charset);
",unused,kbdxenial-src2Fksyms.c
"		len = strlen(t);
		include_dirpath2[0] = t;
		include_dirpath2[1] = t1 = xmalloc(len + 12);
		include_dirpath2[2] = t2 = xmalloc(len + 15);
		strcpy(t1, t);
",1,unused,952,unused,"		len = strlen(t);
		include_dirpath2[0] = t;
		include_dirpath2[1] = t1 = xmalloc(len + 12);
		include_dirpath2[2] = t2 = xmalloc(len + 15);
		strcpy(t1, t);
",unused,kbdxenial-src2Floadkeys.analyze.c
"		include_dirpath2[0] = t;
		include_dirpath2[1] = t1 = xmalloc(len + 12);
		include_dirpath2[2] = t2 = xmalloc(len + 15);
		strcpy(t1, t);
		strcat(t1, ""../include/"");
",1,unused,953,unused,"		include_dirpath2[0] = t;
		include_dirpath2[1] = t1 = xmalloc(len + 12);
		include_dirpath2[2] = t2 = xmalloc(len + 15);
		strcpy(t1, t);
		strcat(t1, ""../include/"");
",unused,kbdxenial-src2Floadkeys.analyze.c
"		include_dirpath2[1] = t1 = xmalloc(len + 12);
		include_dirpath2[2] = t2 = xmalloc(len + 15);
		strcpy(t1, t);
		strcat(t1, ""../include/"");
		strcpy(t2, t);
",1,unused,954,unused,"		include_dirpath2[1] = t1 = xmalloc(len + 12);
		include_dirpath2[2] = t2 = xmalloc(len + 15);
		strcpy(t1, t);
		strcat(t1, ""../include/"");
		strcpy(t2, t);
",unused,kbdxenial-src2Floadkeys.analyze.c
"		include_dirpath2[2] = t2 = xmalloc(len + 15);
		strcpy(t1, t);
		strcat(t1, ""../include/"");
		strcpy(t2, t);
		strcat(t2, ""../../include/"");
",1,unused,955,unused,"		include_dirpath2[2] = t2 = xmalloc(len + 15);
		strcpy(t1, t);
		strcat(t1, ""../include/"");
		strcpy(t2, t);
		strcat(t2, ""../../include/"");
",unused,kbdxenial-src2Floadkeys.analyze.c
"			if (buf[0] == '/') {
				f = find_incl_file_near_fn(s, buf);

			} else if (strlen(filename) + n < sizeof(path)) {
				strcpy(path, filename);
",1,unused,984,unused,"			if (buf[0] == '/') {
				f = find_incl_file_near_fn(s, buf);

			} else if (strlen(filename) + n < sizeof(path)) {
				strcpy(path, filename);
",unused,kbdxenial-src2Floadkeys.analyze.c
"				path[sizeof(path) - 1] = 0;
				ptr = strrchr(path, '/');
				if (ptr)
					ptr[1] = 0;
				strcat(path, buf);
",1,unused,989,unused,"				path[sizeof(path) - 1] = 0;
				ptr = strrchr(path, '/');
				if (ptr)
					ptr[1] = 0;
				strcat(path, buf);
",unused,kbdxenial-src2Floadkeys.analyze.c
"				char *ptmp = p;
				p += strlen(yytext);
				if (p > pmax)
					lkfatal(_(""string too long""));
				strcpy(ptmp, yytext);
",1,unused,1675,unused,"				char *ptmp = p;
				p += strlen(yytext);
				if (p > pmax)
					lkfatal(_(""string too long""));
				strcpy(ptmp, yytext);
",unused,kbdxenial-src2Floadkeys.analyze.c
"	fp += sh;
	r = fp;
	while (q > ptr)
		*--r = *--q;
	strcpy(ptr, (char *)kbs.kb_string);
",1,unused,334,unused,"	fp += sh;
	r = fp;
	while (q > ptr)
		*--r = *--q;
	strcpy(ptr, (char *)kbs.kb_string);
",unused,kbdxenial-src2Floadkeys.c
"	for (i = 0; i < MAX_NR_FUNC; i++) {
		kbs_buf.kb_func = i;

		if ((ptr = func_table[i])) {
			strcpy((char *)kbs_buf.kb_string, ptr);
",1,unused,508,unused,"	for (i = 0; i < MAX_NR_FUNC; i++) {
		kbs_buf.kb_func = i;

		if ((ptr = func_table[i])) {
			strcpy((char *)kbs_buf.kb_string, ptr);
",unused,kbdxenial-src2Floadkeys.c
"	buf[0] = 0;
	for (i = 0; i < 8; i++)
		if (modifier & (1 << i)) {
			if (buf[0])
				strcat(buf, ""_"");
",1,unused,774,unused,"	buf[0] = 0;
	for (i = 0; i < 8; i++)
		if (modifier & (1 << i)) {
			if (buf[0])
				strcat(buf, ""_"");
",unused,kbdxenial-src2Floadkeys.c
"	for (i = 0; i < 8; i++)
		if (modifier & (1 << i)) {
			if (buf[0])
				strcat(buf, ""_"");
			strcat(buf, modifiers[i]);
",1,unused,775,unused,"	for (i = 0; i < 8; i++)
		if (modifier & (1 << i)) {
			if (buf[0])
				strcat(buf, ""_"");
			strcat(buf, modifiers[i]);
",unused,kbdxenial-src2Floadkeys.c
"		}
		parse_keymap(f);

	} else if (optind == argc) {
		strcpy(pathname, ""<stdin>"");
",1,unused,2859,unused,"		}
		parse_keymap(f);

	} else if (optind == argc) {
		strcpy(pathname, ""<stdin>"");
",unused,kbdxenial-src2Floadkeys.c
"
	for (i = optind; argv[i]; i++) {
		if (!strcmp(argv[i], ""-"")) {
			f = stdin;
			strcpy(pathname, ""<stdin>"");
",1,unused,2866,unused,"
	for (i = optind; argv[i]; i++) {
		if (!strcmp(argv[i], ""-"")) {
			f = stdin;
			strcpy(pathname, ""<stdin>"");
",unused,kbdxenial-src2Floadkeys.c
"					  strlen(layout);
				if (variant) {
					cmdsize += 1 + strlen(variant);
					cmd = xmalloc(cmdsize);
					sprintf(cmd, ""ckbcomp -model pc105 %s %s"",
",1,unused,2899,unused,"					  strlen(layout);
				if (variant) {
					cmdsize += 1 + strlen(variant);
					cmd = xmalloc(cmdsize);
					sprintf(cmd, ""ckbcomp -model pc105 %s %s"",
",unused,kbdxenial-src2Floadkeys.c
"					sprintf(cmd, ""ckbcomp -model pc105 %s %s"",
						layout, variant);
				} else {
					cmd = xmalloc(cmdsize);
					sprintf(cmd, ""ckbcomp -model pc105 %s"",
",1,unused,2903,unused,"					sprintf(cmd, ""ckbcomp -model pc105 %s %s"",
						layout, variant);
				} else {
					cmd = xmalloc(cmdsize);
					sprintf(cmd, ""ckbcomp -model pc105 %s"",
",unused,kbdxenial-src2Floadkeys.c
"		openvt_fatal(1, errno, ""opendir(/proc)"");

	/* get the current tty */
	/* try /dev/ttyN, then /dev/vc/N */
	sprintf(filename, VTNAME, curvt);
",1,unused,133,unused,"		openvt_fatal(1, errno, ""opendir(/proc)"");

	/* get the current tty */
	/* try /dev/ttyN, then /dev/vc/N */
	sprintf(filename, VTNAME, curvt);
",unused,kbdxenial-src2Fopenvt.c
"	/* try /dev/ttyN, then /dev/vc/N */
	sprintf(filename, VTNAME, curvt);
	if (stat(filename, &buf)) {
		int errsv = errno;
		sprintf(filename, VTNAME2, curvt);
",1,unused,136,unused,"	/* try /dev/ttyN, then /dev/vc/N */
	sprintf(filename, VTNAME, curvt);
	if (stat(filename, &buf)) {
		int errsv = errno;
		sprintf(filename, VTNAME2, curvt);
",unused,kbdxenial-src2Fopenvt.c
"		int errsv = errno;
		sprintf(filename, VTNAME2, curvt);
		if (stat(filename, &buf)) {
			/* give error message for first attempt */
			sprintf(filename, VTNAME, curvt);
",1,unused,139,unused,"		int errsv = errno;
		sprintf(filename, VTNAME2, curvt);
		if (stat(filename, &buf)) {
			/* give error message for first attempt */
			sprintf(filename, VTNAME, curvt);
",unused,kbdxenial-src2Fopenvt.c
"
	/* check to make sure that user has a process on that tty */
	/* this will fail for example when X is running on the tty */
	while ((dentp = readdir(dp))) {
		sprintf(filename, ""/proc/%s/fd/0"", dentp->d_name);
",1,unused,154,unused,"
	/* check to make sure that user has a process on that tty */
	/* this will fail for example when X is running on the tty */
	while ((dentp = readdir(dp))) {
		sprintf(filename, ""/proc/%s/fd/0"", dentp->d_name);
",unused,kbdxenial-src2Fopenvt.c
"			cmd = xmalloc(strlen(argv[optind]) + 2);
		}

		if (login)
			strcpy(cmd, ""-"");
",1,unused,313,unused,"			cmd = xmalloc(strlen(argv[optind]) + 2);
		}

		if (login)
			strcpy(cmd, ""-"");
",unused,kbdxenial-src2Fopenvt.c
"		else
			cmd[0] = '\0';

		if (def_cmd)
			strcat(cmd, def_cmd);
",1,unused,318,unused,"		else
			cmd[0] = '\0';

		if (def_cmd)
			strcat(cmd, def_cmd);
",unused,kbdxenial-src2Fopenvt.c
"
		if (def_cmd)
			strcat(cmd, def_cmd);
		else
			strcat(cmd, argv[optind]);
",1,unused,320,unused,"
		if (def_cmd)
			strcat(cmd, def_cmd);
		else
			strcat(cmd, argv[optind]);
",unused,kbdxenial-src2Fopenvt.c
"#endif				/* ESIX_5_3_2_D */
				openvt_fatal(5, errno, _(""Unable to set new session""));
		}

		sprintf(vtname, VTNAME, vtno);
",1,unused,341,unused,"#endif				/* ESIX_5_3_2_D */
				openvt_fatal(5, errno, _(""Unable to set new session""));
		}

		sprintf(vtname, VTNAME, vtno);
",unused,kbdxenial-src2Fopenvt.c
"				   used it and did a chown.  Try a few vt's more
				   before giving up. Note: the 16 is a kernel limitation. */
				for (i = vtno + 1; i < 16; i++) {
					if ((vtstat.v_state & (1 << i)) == 0) {
						sprintf(vtname, VTNAME, i);
",1,unused,353,unused,"				   used it and did a chown.  Try a few vt's more
				   before giving up. Note: the 16 is a kernel limitation. */
				for (i = vtno + 1; i < 16; i++) {
					if ((vtstat.v_state & (1 << i)) == 0) {
						sprintf(vtname, VTNAME, i);
",unused,kbdxenial-src2Fopenvt.c
"							goto got_vtno;
						}
					}
				}
				sprintf(vtname, VTNAME, vtno);
",1,unused,360,unused,"							goto got_vtno;
						}
					}
				}
				sprintf(vtname, VTNAME, vtno);
",unused,kbdxenial-src2Fopenvt.c
"      usage();

    if (mode == MODE_RESTORETEXTMODE) {
        /* prepare for: restoretextmode -r 80x25 */
        sprintf(infile, ""%dx%d"", cc, rr);
",1,unused,151,unused,"      usage();

    if (mode == MODE_RESTORETEXTMODE) {
        /* prepare for: restoretextmode -r 80x25 */
        sprintf(infile, ""%dx%d"", cc, rr);
",unused,kbdxenial-src2Fresizecons.c
"    }

    if (mode == MODE_RESTORETEXTMODE) {
	/* do: restoretextmode -r 25x80 */
	sprintf(cmd, ""restoretextmode -r %s\n"", pathname);
",1,unused,247,unused,"    }

    if (mode == MODE_RESTORETEXTMODE) {
	/* do: restoretextmode -r 25x80 */
	sprintf(cmd, ""restoretextmode -r %s\n"", pathname);
",unused,kbdxenial-src2Fresizecons.c
"    winsize.ws_row = rr;
    winsize.ws_col = cc;
    for (i=0; i<16; i++)
      if (vtstat.v_state & (1<<i)) {
	  sprintf(tty, ""/dev/tty%d"", i);
",1,unused,268,unused,"    winsize.ws_row = rr;
    winsize.ws_col = cc;
    for (i=0; i<16; i++)
      if (vtstat.v_state & (1<<i)) {
	  sprintf(tty, ""/dev/tty%d"", i);
",unused,kbdxenial-src2Fresizecons.c
"      if (vtstat.v_state & (1<<i)) {
	  sprintf(tty, ""/dev/tty%d"", i);
	  fd = open(tty, O_RDONLY);
	  if (fd < 0 && errno == ENOENT) {
	      sprintf(tty, ""/dev/vc/%d"", i);
",1,unused,271,unused,"      if (vtstat.v_state & (1<<i)) {
	  sprintf(tty, ""/dev/tty%d"", i);
	  fd = open(tty, O_RDONLY);
	  if (fd < 0 && errno == ENOENT) {
	      sprintf(tty, ""/dev/vc/%d"", i);
",unused,kbdxenial-src2Fresizecons.c
"    case 16 :
    default : defaultfont = ""default8x16""; break;
    }

    sprintf(cmd, ""setfont %s"", defaultfont);
",1,unused,316,unused,"    case 16 :
    default : defaultfont = ""default8x16""; break;
    }

    sprintf(cmd, ""setfont %s"", defaultfont);
",unused,kbdxenial-src2Fresizecons.c
"				fprintf(stderr, _(""Cannot find default font\n""));
				exit(EX_NOINPUT);
			}
		} else {
			sprintf(defname, ""default8x%d"", iunit);
",1,unused,491,unused,"				fprintf(stderr, _(""Cannot find default font\n""));
				exit(EX_NOINPUT);
			}
		} else {
			sprintf(defname, ""default8x%d"", iunit);
",unused,kbdxenial-src2Fsetfont.c
"		if ((st.st_rdev >> 8) != 4)
			break;

		i = st.st_rdev & 0xff;
		sprintf(path, ""/dev/vcsa%u"", i);
",1,unused,59,unused,"		if ((st.st_rdev >> 8) != 4)
			break;

		i = st.st_rdev & 0xff;
		sprintf(path, ""/dev/vcsa%u"", i);
",unused,kbdxenial-src2Fvlock2Fscreen.c
"
		if (sym->owner == NULL)
			continue;

		strcpy(alias + baselen, sym->name);
",1,unused,1944,unused,"
		if (sym->owner == NULL)
			continue;

		strcpy(alias + baselen, sym->name);
",unused,kbdxenpatch-tools2Fdepmod.c
"	strncpy(infname, name, sizeof (infname)-1);
	infname[sizeof (infname)-1] = '\0';
	p = strrchr(infname, '.');
	if (p != 0 && &p[4] < &name[sizeof (infname)]) {
		strcpy(&p[1], ""inf"");
",1,unused,75,unused,"	strncpy(infname, name, sizeof (infname)-1);
	infname[sizeof (infname)-1] = '\0';
	p = strrchr(infname, '.');
	if (p != 0 && &p[4] < &name[sizeof (infname)]) {
		strcpy(&p[1], ""inf"");
",unused,kek-123-cdrecord2Fauinfo.c
"	char	*ret;

	ret = malloc(strlen(str)+1);
	if (ret)
		strcpy(ret, str);
",1,unused,403,unused,"	char	*ret;

	ret = malloc(strlen(str)+1);
	if (ret)
		strcpy(ret, str);
",unused,kek-123-cdrecord2Fauinfo.c
"		if (*p < '0' || *p > '9')
			comerrno(EX_BAD, _(""MCN '%s' contains illegal character '%c'.\n""), mcn, *p);
	}
	p = malloc(14);
	strcpy(p, mcn);
",1,unused,464,unused,"		if (*p < '0' || *p > '9')
			comerrno(EX_BAD, _(""MCN '%s' contains illegal character '%c'.\n""), mcn, *p);
	}
	p = malloc(14);
	strcpy(p, mcn);
",unused,kek-123-cdrecord2Fauinfo.c
"		goto illchar;
	}
	*ip = '\0';
	p = malloc(13);
	strcpy(p, ibuf);
",1,unused,560,unused,"		goto illchar;
	}
	*ip = '\0';
	p = malloc(13);
	strcpy(p, ibuf);
",unused,kek-123-cdrecord2Fauinfo.c
"	int len = strlen(s);

	p = malloc(len+1);
	if (p)
		strcpy(p, s);
",1,unused,271,unused,"	int len = strlen(s);

	p = malloc(len+1);
	if (p)
		strcpy(p, s);
",unused,kek-123-libcdrdeflt2Fcdrdeflt.c
"#else
		erg[off++] = FDT_UNKN;	/* Platzhalter: ^A vor jeden Namen  */
#endif

		strcpy(&erg[off], name);
",1,unused,204,unused,"#else
		erg[off++] = FDT_UNKN;	/* Platzhalter: ^A vor jeden Namen  */
#endif

		strcpy(&erg[off], name);
",unused,kek-123-libfind2Ffetchdir.c
"			_(""No space for arg '%s'.\n""), f);
		return (FALSE);
	}
	cp = pp->laststr - slen;
	strcpy(cp, f);
",1,unused,2291,unused,"			_(""No space for arg '%s'.\n""), f);
		return (FALSE);
	}
	cp = pp->laststr - slen;
	strcpy(cp, f);
",unused,kek-123-libfind2Ffind.c
"		if (ic_nameuid(nuid, sizeof (nuid), fs->st_uid)) {
			uname = nuid;
			umaxlen = sizeof (nuid)-1;
		} else {
			sprintf(nuid, ""%llu"", (Llong)fs->st_uid);
",1,unused,178,unused,"		if (ic_nameuid(nuid, sizeof (nuid), fs->st_uid)) {
			uname = nuid;
			umaxlen = sizeof (nuid)-1;
		} else {
			sprintf(nuid, ""%llu"", (Llong)fs->st_uid);
",unused,kek-123-libfind2Ffind_list.c
"		if (ic_namegid(ngid, sizeof (ngid), fs->st_gid)) {
			gname = ngid;
			gmaxlen = sizeof (ngid)-1;
		} else {
			sprintf(ngid, ""%llu"", (Llong)fs->st_gid);
",1,unused,187,unused,"		if (ic_namegid(ngid, sizeof (ngid), fs->st_gid)) {
			gname = ngid;
			gmaxlen = sizeof (ngid)-1;
		} else {
			sprintf(ngid, ""%llu"", (Llong)fs->st_gid);
",unused,kek-123-libfind2Ffind_list.c
"{
  if (v_getvol(&vol) < 0)
    return -1;

  strcpy(ent->name, vol->mdb.drVN);
",1,unused,456,unused,"{
  if (v_getvol(&vol) < 0)
    return -1;

  strcpy(ent->name, vol->mdb.drVN);
",unused,kek-123-libhfs_iso2Fhfs.c
"#endif /* APPLE_HYB */
  vol.mdb.drNxtCNID  = HFS_CNID_ROOTDIR;  /* modified later */
  vol.mdb.drFreeBks  = vol.mdb.drNmAlBlks;

  strcpy(vol.mdb.drVN, vname);
",1,unused,610,unused,"#endif /* APPLE_HYB */
  vol.mdb.drNxtCNID  = HFS_CNID_ROOTDIR;  /* modified later */
  vol.mdb.drFreeBks  = vol.mdb.drNmAlBlks;

  strcpy(vol.mdb.drVN, vname);
",unused,kek-123-libhfs_iso2Fhfs.c
"  /* create extents overflow file */

  ext->f.vol   = &vol;
  ext->f.parid = 0;
  strcpy(ext->f.name, ""extents overflow"");
",1,unused,729,unused,"  /* create extents overflow file */

  ext->f.vol   = &vol;
  ext->f.parid = 0;
  strcpy(ext->f.name, ""extents overflow"");
",unused,kek-123-libhfs_iso2Fhfs.c
"  /* create catalog file */

  cat->f.vol   = &vol;
  cat->f.parid = 0;
  strcpy(cat->f.name, ""catalog"");
",1,unused,816,unused,"  /* create catalog file */

  cat->f.vol   = &vol;
  cat->f.parid = 0;
  strcpy(cat->f.name, ""catalog"");
",unused,kek-123-libhfs_iso2Fhfs.c
"
  *id = thread.u.dthd.thdParID;

  if (name)
    strcpy(name, thread.u.dthd.thdCName);
",1,unused,1020,unused,"
  *id = thread.u.dthd.thdParID;

  if (name)
    strcpy(name, thread.u.dthd.thdCName);
",unused,kek-123-libhfs_iso2Fhfs.c
"      dst.cdrType == cdrDirRec &&
      dst.u.dir.dirDirID != src.u.dir.dirDirID)
    {
      dstid = dst.u.dir.dirDirID;
      strcpy(dstname, srcname);
",1,unused,1961,unused,"      dst.cdrType == cdrDirRec &&
      dst.u.dir.dirDirID != src.u.dir.dirDirID)
    {
      dstid = dst.u.dir.dirDirID;
      strcpy(dstname, srcname);
",unused,kek-123-libhfs_iso2Fhfs.c
"      else
	++ptr;

      if (*ptr)
	strcpy(dstname, ptr);
",1,unused,1981,unused,"      else
	++ptr;

      if (*ptr)
	strcpy(dstname, ptr);
",unused,kek-123-libhfs_iso2Fhfs.c
"	  ERROR(ENAMETOOLONG, 0);
	  return -1;
	}

      strcpy(vol->mdb.drVN, dstname);
",1,unused,2044,unused,"	  ERROR(ENAMETOOLONG, 0);
	  return -1;
	}

      strcpy(vol->mdb.drVN, dstname);
",unused,kek-123-libhfs_iso2Fhfs.c
"      if (v_getdthread(vol, src.u.dir.dirDirID, &dst, &n) <= 0)
	return -1;

      dst.u.dthd.thdParID = dstid;
      strcpy(dst.u.dthd.thdCName, dstname);
",1,unused,2073,unused,"      if (v_getdthread(vol, src.u.dir.dirDirID, &dst, &n) <= 0)
	return -1;

      dst.u.dthd.thdParID = dstid;
      strcpy(dst.u.dthd.thdCName, dstname);
",unused,kek-123-libhfs_iso2Fhfs.c
"
      if (found)
	{
	  dst.u.fthd.fthdParID = dstid;
	  strcpy(dst.u.fthd.fthdCName, dstname);
",1,unused,2087,unused,"
      if (found)
	{
	  dst.u.fthd.fthdParID = dstid;
	  strcpy(dst.u.fthd.fthdCName, dstname);
",unused,kek-123-libhfs_iso2Fhfs.c
"  /* extents pseudo-file structs */

  ext->vol   = vol;
  ext->parid = 0;
  strcpy(ext->name, ""extents overflow"");
",1,unused,296,unused,"  /* extents pseudo-file structs */

  ext->vol   = vol;
  ext->parid = 0;
  strcpy(ext->name, ""extents overflow"");
",unused,kek-123-libhfs_iso2Flow.c
"  /* catalog pseudo-file structs */

  cat->vol   = vol;
  cat->parid = 0;
  strcpy(cat->name, ""catalog"");
",1,unused,333,unused,"  /* catalog pseudo-file structs */

  cat->vol   = vol;
  cat->parid = 0;
  strcpy(cat->name, ""catalog"");
",unused,kek-123-libhfs_iso2Flow.c
"  key->ckrKeyLen = 0x05 + len + (len & 1);
  key->ckrResrv1 = 0;
  key->ckrParID  = parid;

  strcpy(key->ckrCName, name);
",1,unused,438,unused,"  key->ckrKeyLen = 0x05 + len + (len & 1);
  key->ckrResrv1 = 0;
  key->ckrParID  = parid;

  strcpy(key->ckrCName, name);
",unused,kek-123-libhfs_iso2Frecord.c
"	char		*name;
	CatDataRec	*data;
	hfsdirent	*ent;
{
  strcpy(ent->name, name);
",1,unused,469,unused,"	char		*name;
	CatDataRec	*data;
	hfsdirent	*ent;
{
  strcpy(ent->name, name);
",unused,kek-123-libhfs_iso2Frecord.c
"
  if (cname)
    {
      r_unpackcatkey(ptr, &key);
      strcpy(cname, key.ckrCName);
",1,unused,73,unused,"
  if (cname)
    {
      r_unpackcatkey(ptr, &key);
      strcpy(cname, key.ckrCName);
",unused,kek-123-libhfs_iso2Fvolume.c
"	  if (*path && parid)
	    *parid = 0;

	  if (*path == 0 && fname)
	    strcpy(fname, name);
",1,unused,424,unused,"	  if (*path && parid)
	    *parid = 0;

	  if (*path == 0 && fname)
	    strcpy(fname, name);
",unused,kek-123-libhfs_iso2Fvolume.c
"
  data.u.dthd.thdResrv[0] = 0;
  data.u.dthd.thdResrv[1] = 0;
  data.u.dthd.thdParID    = parid;
  strcpy(data.u.dthd.thdCName, name);
",1,unused,623,unused,"
  data.u.dthd.thdResrv[0] = 0;
  data.u.dthd.thdResrv[1] = 0;
  data.u.dthd.thdParID    = parid;
  strcpy(data.u.dthd.thdCName, name);
",unused,kek-123-libhfs_iso2Fvolume.c
"		char	*tbuf = malloc(len);
		if (tbuf == NULL)
			return (NULL);
#endif
		strcpy(tbuf, absp);
",1,unused,108,unused,"		char	*tbuf = malloc(len);
		if (tbuf == NULL)
			return (NULL);
#endif
		strcpy(tbuf, absp);
",unused,kek-123-libschily2Fabspath.c
"	char	*s;
	double	val;
{
	if (isnan(val)) {
		strcpy(s, _js_nan);
",1,unused,417,unused,"	char	*s;
	double	val;
{
	if (isnan(val)) {
		strcpy(s, _js_nan);
",unused,kek-123-libschily2Ffconv.c
"	/*
	 * Check first for NaN because finite() will return 1 on Nan too.
	 */
	if (isinf(val)) {
		strcpy(s, _js_inf);
",1,unused,425,unused,"	/*
	 * Check first for NaN because finite() will return 1 on Nan too.
	 */
	if (isinf(val)) {
		strcpy(s, _js_inf);
",unused,kek-123-libschily2Ffconv.c
"{
	char	*ret = __fjmalloc(f, strlen(s)+1, ""saved string"", jmp);

	if (ret != NULL)
		strcpy(ret, s);
",1,unused,122,unused,"{
	char	*ret = __fjmalloc(f, strlen(s)+1, ""saved string"", jmp);

	if (ret != NULL)
		strcpy(ret, s);
",unused,kek-123-libschily2Ffjmem.c
"{
	char	*ret = __jmalloc(strlen(s)+1, ""saved string"", jmp);

	if (ret != NULL)
		strcpy(ret, s);
",1,unused,111,unused,"{
	char	*ret = __jmalloc(strlen(s)+1, ""saved string"", jmp);

	if (ret != NULL)
		strcpy(ret, s);
",unused,kek-123-libschily2Fjmem.c
"	const char	*s;
{
	char	*ret = ___malloc(strlen(s)+1, ""saved string"");

	strcpy(ret, s);
",1,unused,102,unused,"	const char	*s;
{
	char	*ret = ___malloc(strlen(s)+1, ""saved string"");

	strcpy(ret, s);
",unused,kek-123-libschily2Fmem.c
"	else
		av0_saved = malloc(slen);

	if (av0_saved) {
		strcpy(av0_saved, av0);
",1,unused,85,unused,"	else
		av0_saved = malloc(slen);

	if (av0_saved) {
		strcpy(av0_saved, av0);
",unused,kek-123-libschily2Fsaveargs.c
"	else
		progpath_saved = malloc(slen);

	if (progpath_saved) {
		strcpy(progpath_saved, name);
",1,unused,140,unused,"	else
		progpath_saved = malloc(slen);

	if (progpath_saved) {
		strcpy(progpath_saved, name);
",unused,kek-123-libschily2Fsaveargs.c
"	}
	if (ret != TYPE_NONE) {
		/* see if we can find the details of this file */
		if ((hfs_info = match_key(hfs_info, dname)) != NULL) {
			strcpy(hfs_ent->name, hfs_info->name);
",1,unused,1641,unused,"	}
	if (ret != TYPE_NONE) {
		/* see if we can find the details of this file */
		if ((hfs_info = match_key(hfs_info, dname)) != NULL) {
			strcpy(hfs_ent->name, hfs_info->name);
",unused,kek-123-mkisofs2Fapple.c
"
		/* see if we can find the details of this file */
		if ((hfs_info = match_key(hfs_info, dn)) != NULL) {

			strcpy(hfs_ent->name, hfs_info->name);
",1,unused,1706,unused,"
		/* see if we can find the details of this file */
		if ((hfs_info = match_key(hfs_info, dn)) != NULL) {

			strcpy(hfs_ent->name, hfs_info->name);
",unused,kek-123-mkisofs2Fapple.c
"	if (ret != TYPE_NONE) {
		/* key is (hopefully) the real Mac name */
		cstrncpy(tmp, dname, strlen(dname));
		if ((hfs_info = match_key(hfs_info, tmp)) != NULL) {
			strcpy(hfs_ent->name, hfs_info->name);
",1,unused,1753,unused,"	if (ret != TYPE_NONE) {
		/* key is (hopefully) the real Mac name */
		cstrncpy(tmp, dname, strlen(dname));
		if ((hfs_info = match_key(hfs_info, tmp)) != NULL) {
			strcpy(hfs_ent->name, hfs_info->name);
",unused,kek-123-mkisofs2Fapple.c
"		 */
		cstrncpy(tmp, dname, strlen(dname));
		if ((hfs_info = match_key(hfs_info, tmp)) != NULL) {

			strcpy(hfs_ent->name, hfs_info->name);
",1,unused,1800,unused,"		 */
		cstrncpy(tmp, dname, strlen(dname));
		if ((hfs_info = match_key(hfs_info, tmp)) != NULL) {

			strcpy(hfs_ent->name, hfs_info->name);
",unused,kek-123-mkisofs2Fapple.c
"				*(hfs_types[i].info) == TYPE_NONE) {
			continue;
		}

		strcpy(htmp, wname);
",1,unused,2067,unused,"				*(hfs_types[i].info) == TYPE_NONE) {
			continue;
		}

		strcpy(htmp, wname);
",unused,kek-123-mkisofs2Fapple.c
"		} else {

			/* append or insert finderinfo filename part */
			if (hfs_types[i].flags & APPEND)
				strcat(htmp, hfs_types[i].info);
",1,unused,2082,unused,"		} else {

			/* append or insert finderinfo filename part */
			if (hfs_types[i].flags & APPEND)
				strcat(htmp, hfs_types[i].info);
",unused,kek-123-mkisofs2Fapple.c
"			/* append or insert finderinfo filename part */
			if (hfs_types[i].flags & APPEND)
				strcat(htmp, hfs_types[i].info);
			else
				sprintf(htmp + wlen, ""%s%s"", hfs_types[i].info,
",1,unused,2084,unused,"			/* append or insert finderinfo filename part */
			if (hfs_types[i].flags & APPEND)
				strcat(htmp, hfs_types[i].info);
			else
				sprintf(htmp + wlen, ""%s%s"", hfs_types[i].info,
",unused,kek-123-mkisofs2Fapple.c
"					(hfs_types[i].flags & NOPEND) ? """" : dname);

			/* hack time ... Netatalk is a special case ... */
			if (i == TYPE_NETA) {
				strcpy(htmp, wname);
",1,unused,2089,unused,"					(hfs_types[i].flags & NOPEND) ? """" : dname);

			/* hack time ... Netatalk is a special case ... */
			if (i == TYPE_NETA) {
				strcpy(htmp, wname);
",unused,kek-123-mkisofs2Fapple.c
"
			/* hack time ... Netatalk is a special case ... */
			if (i == TYPE_NETA) {
				strcpy(htmp, wname);
				strcat(htmp, ""/.AppleDouble/.Parent"");
",1,unused,2090,unused,"
			/* hack time ... Netatalk is a special case ... */
			if (i == TYPE_NETA) {
				strcpy(htmp, wname);
				strcat(htmp, ""/.AppleDouble/.Parent"");
",unused,kek-123-mkisofs2Fapple.c
"	if (s_entry->hfs_type != TYPE_NONE) {

		type = s_entry->hfs_type;

		strcpy(tmp, wname);
",1,unused,2172,unused,"	if (s_entry->hfs_type != TYPE_NONE) {

		type = s_entry->hfs_type;

		strcpy(tmp, wname);
",unused,kek-123-mkisofs2Fapple.c
"		strcpy(tmp, wname);

		/* append or insert finderinfo filename part */
		if (hfs_types[type].flags & APPEND)
			strcat(tmp, hfs_types[type].info);
",1,unused,2176,unused,"		strcpy(tmp, wname);

		/* append or insert finderinfo filename part */
		if (hfs_types[type].flags & APPEND)
			strcat(tmp, hfs_types[type].info);
",unused,kek-123-mkisofs2Fapple.c
"		/* append or insert finderinfo filename part */
		if (hfs_types[type].flags & APPEND)
			strcat(tmp, hfs_types[type].info);
		else
			sprintf(tmp + wlen, ""%s%s"", hfs_types[type].info,
",1,unused,2178,unused,"		/* append or insert finderinfo filename part */
		if (hfs_types[type].flags & APPEND)
			strcat(tmp, hfs_types[type].info);
		else
			sprintf(tmp + wlen, ""%s%s"", hfs_types[type].info,
",unused,kek-123-mkisofs2Fapple.c
"				*(hfs_types[i].info) == TYPE_NONE) {
			continue;
		}

		strcpy(tmp, wname);
",1,unused,2194,unused,"				*(hfs_types[i].info) == TYPE_NONE) {
			continue;
		}

		strcpy(tmp, wname);
",unused,kek-123-mkisofs2Fapple.c
"		strcpy(tmp, wname);

		/* append or insert finderinfo filename part */
		if (hfs_types[i].flags & APPEND) {
			strcat(tmp, hfs_types[i].info);
",1,unused,2198,unused,"		strcpy(tmp, wname);

		/* append or insert finderinfo filename part */
		if (hfs_types[i].flags & APPEND) {
			strcat(tmp, hfs_types[i].info);
",unused,kek-123-mkisofs2Fapple.c
"		/* append or insert finderinfo filename part */
		if (hfs_types[i].flags & APPEND) {
			strcat(tmp, hfs_types[i].info);
		} else {
			sprintf(tmp + wlen, ""%s%s"", hfs_types[i].info,
",1,unused,2200,unused,"		/* append or insert finderinfo filename part */
		if (hfs_types[i].flags & APPEND) {
			strcat(tmp, hfs_types[i].info);
		} else {
			sprintf(tmp + wlen, ""%s%s"", hfs_types[i].info,
",unused,kek-123-mkisofs2Fapple.c
"		/* skip if don't want to probe the files - (default) */
		if (hfs_types[i].flags & PROBE)
			continue;

		strcpy(rname, wname);
",1,unused,2247,unused,"		/* skip if don't want to probe the files - (default) */
		if (hfs_types[i].flags & PROBE)
			continue;

		strcpy(rname, wname);
",unused,kek-123-mkisofs2Fapple.c
"			/* first test the Info file */

			/* append or insert finderinfo filename part */
			if (hfs_types[i].flags & APPEND) {
				strcat(rname, hfs_types[i].info);
",1,unused,2255,unused,"			/* first test the Info file */

			/* append or insert finderinfo filename part */
			if (hfs_types[i].flags & APPEND) {
				strcat(rname, hfs_types[i].info);
",unused,kek-123-mkisofs2Fapple.c
"			/* append or insert finderinfo filename part */
			if (hfs_types[i].flags & APPEND) {
				strcat(rname, hfs_types[i].info);
			} else {
				sprintf(rname + wlen, ""%s%s"", hfs_types[i].info,
",1,unused,2257,unused,"			/* append or insert finderinfo filename part */
			if (hfs_types[i].flags & APPEND) {
				strcat(rname, hfs_types[i].info);
			} else {
				sprintf(rname + wlen, ""%s%s"", hfs_types[i].info,
",unused,kek-123-mkisofs2Fapple.c
"
			/* if it exists, then check the Rsrc file */
			if (!access(rname, R_OK)) {
				if (hfs_types[i].flags & APPEND) {
					sprintf(rname + wlen, ""%s%s"", dname,
",1,unused,2265,unused,"
			/* if it exists, then check the Rsrc file */
			if (!access(rname, R_OK)) {
				if (hfs_types[i].flags & APPEND) {
					sprintf(rname + wlen, ""%s%s"", dname,
",unused,kek-123-mkisofs2Fapple.c
"				if (hfs_types[i].flags & APPEND) {
					sprintf(rname + wlen, ""%s%s"", dname,
						hfs_types[i].rsrc);
				} else {
					sprintf(rname + wlen, ""%s%s"",
",1,unused,2268,unused,"				if (hfs_types[i].flags & APPEND) {
					sprintf(rname + wlen, ""%s%s"", dname,
						hfs_types[i].rsrc);
				} else {
					sprintf(rname + wlen, ""%s%s"",
",unused,kek-123-mkisofs2Fapple.c
"	case TYPE_FEU:
	case TYPE_ESH:
	case TYPE_NETA:
	case TYPE_CAP:
		strcpy(compare, ""/"");
",1,unused,2677,unused,"	case TYPE_FEU:
	case TYPE_ESH:
	case TYPE_NETA:
	case TYPE_CAP:
		strcpy(compare, ""/"");
",unused,kek-123-mkisofs2Fapple.c
"	case TYPE_ESH:
	case TYPE_NETA:
	case TYPE_CAP:
		strcpy(compare, ""/"");
		strcat(compare, hfs_types[hfstype].rsrc);
",1,unused,2678,unused,"	case TYPE_ESH:
	case TYPE_NETA:
	case TYPE_CAP:
		strcpy(compare, ""/"");
		strcat(compare, hfs_types[hfstype].rsrc);
",unused,kek-123-mkisofs2Fapple.c
"		break;
	case TYPE_XDBL:
	case TYPE_SFM:
	case TYPE_DBL:
		strcpy(compare, ""/"");
",1,unused,2686,unused,"		break;
	case TYPE_XDBL:
	case TYPE_SFM:
	case TYPE_DBL:
		strcpy(compare, ""/"");
",unused,kek-123-mkisofs2Fapple.c
"	case TYPE_XDBL:
	case TYPE_SFM:
	case TYPE_DBL:
		strcpy(compare, ""/"");
		strcat(compare, hfs_types[hfstype].rsrc);
",1,unused,2687,unused,"	case TYPE_XDBL:
	case TYPE_SFM:
	case TYPE_DBL:
		strcpy(compare, ""/"");
		strcat(compare, hfs_types[hfstype].rsrc);
",unused,kek-123-mkisofs2Fapple.c
"	/* set default values */
	defmap->extn = DEFMATCH;

	/* make sure creator and type are 4 chars long */
	strcpy(defmap->type, BLANK);
",1,unused,2765,unused,"	/* set default values */
	defmap->extn = DEFMATCH;

	/* make sure creator and type are 4 chars long */
	strcpy(defmap->type, BLANK);
",unused,kek-123-mkisofs2Fapple.c
"	defmap->extn = DEFMATCH;

	/* make sure creator and type are 4 chars long */
	strcpy(defmap->type, BLANK);
	strcpy(defmap->creator, BLANK);
",1,unused,2766,unused,"	defmap->extn = DEFMATCH;

	/* make sure creator and type are 4 chars long */
	strcpy(defmap->type, BLANK);
	strcpy(defmap->creator, BLANK);
",unused,kek-123-mkisofs2Fapple.c
"	}

	if (use_sunx86boot) {
		if (sx86_label.dkl_vtoc.v_asciilabel[0] == '\0')
			strcpy(sx86_label.dkl_vtoc.v_asciilabel, CD_X86LABEL);
",1,unused,461,unused,"	}

	if (use_sunx86boot) {
		if (sx86_label.dkl_vtoc.v_asciilabel[0] == '\0')
			strcpy(sx86_label.dkl_vtoc.v_asciilabel, CD_X86LABEL);
",unused,kek-123-mkisofs2Fboot.c
"		 * If we don't already have a Sun disk label text
		 * set up the default.
		 */
		if (cd_label.dkl_ascilabel[0] == '\0')
			strcpy(cd_label.dkl_ascilabel, CD_DEFLABEL);
",1,unused,481,unused,"		 * If we don't already have a Sun disk label text
		 * set up the default.
		 */
		if (cd_label.dkl_ascilabel[0] == '\0')
			strcpy(cd_label.dkl_ascilabel, CD_DEFLABEL);
",unused,kek-123-mkisofs2Fboot.c
"	 * changing Desktop DB/DF entries...
	 */
	memset(&ent, 0, sizeof (hfsdirent));	/* First clear all ... */
	ent.u.file.rsize = 0;			/* resource size == 0 */
	strcpy(ent.u.file.creator, DBFC);	/* creator */
",1,unused,89,unused,"	 * changing Desktop DB/DF entries...
	 */
	memset(&ent, 0, sizeof (hfsdirent));	/* First clear all ... */
	ent.u.file.rsize = 0;			/* resource size == 0 */
	strcpy(ent.u.file.creator, DBFC);	/* creator */
",unused,kek-123-mkisofs2Fdesktop.c
"	 */
	memset(&ent, 0, sizeof (hfsdirent));	/* First clear all ... */
	ent.u.file.rsize = 0;			/* resource size == 0 */
	strcpy(ent.u.file.creator, DBFC);	/* creator */
	strcpy(ent.u.file.type, DBT);		/* type */
",1,unused,90,unused,"	 */
	memset(&ent, 0, sizeof (hfsdirent));	/* First clear all ... */
	ent.u.file.rsize = 0;			/* resource size == 0 */
	strcpy(ent.u.file.creator, DBFC);	/* creator */
	strcpy(ent.u.file.type, DBT);		/* type */
",unused,kek-123-mkisofs2Fdesktop.c
"			perr(hfs_error);
	}

	/* setup ""Desktop DF"" file as an empty file */
	strcpy(ent.u.file.type, DFT);		/* type */
",1,unused,162,unused,"			perr(hfs_error);
	}

	/* setup ""Desktop DF"" file as an empty file */
	strcpy(ent.u.file.type, DFT);		/* type */
",unused,kek-123-mkisofs2Fdesktop.c
"				case 0:
					strncat(symlinkname, (char *)(pnts+2), pnts[1]);
					break;
				case 2:
					strcat(symlinkname, ""."");
",1,unused,344,unused,"				case 0:
					strncat(symlinkname, (char *)(pnts+2), pnts[1]);
					break;
				case 2:
					strcat(symlinkname, ""."");
",unused,kek-123-mkisofs2Fdiag2Fisodump.c
"				case 2:
					strcat(symlinkname, ""."");
					break;
				case 4:
					strcat(symlinkname, "".."");
",1,unused,347,unused,"				case 2:
					strcat(symlinkname, ""."");
					break;
				case 4:
					strcat(symlinkname, "".."");
",unused,kek-123-mkisofs2Fdiag2Fisodump.c
"					strcat(symlinkname, "".."");
					break;
				case 8:
					if ((pnts[0] & 1) == 0)
						strcat(symlinkname, ""/"");
",1,unused,351,unused,"					strcat(symlinkname, "".."");
					break;
				case 8:
					if ((pnts[0] & 1) == 0)
						strcat(symlinkname, ""/"");
",unused,kek-123-mkisofs2Fdiag2Fisodump.c
"					if ((pnts[0] & 1) == 0)
						strcat(symlinkname, ""/"");
					break;
				case 16:
					strcat(symlinkname, ""/mnt"");
",1,unused,354,unused,"					if ((pnts[0] & 1) == 0)
						strcat(symlinkname, ""/"");
					break;
				case 16:
					strcat(symlinkname, ""/mnt"");
",unused,kek-123-mkisofs2Fdiag2Fisodump.c
"					strcat(symlinkname, ""/mnt"");
					printf(_(""Warning - mount point requested""));
					break;
				case 32:
					strcat(symlinkname, ""kafka"");
",1,unused,358,unused,"					strcat(symlinkname, ""/mnt"");
					printf(_(""Warning - mount point requested""));
					break;
				case 32:
					strcat(symlinkname, ""kafka"");
",unused,kek-123-mkisofs2Fdiag2Fisodump.c
"				if ((pnts[0] & 0xfe) && pnts[1] != 0) {
					printf(_(""Incorrect length in symlink component""));
				}
				if ((pnts[0] & 1) == 0)
					strcat(symlinkname, ""/"");
",1,unused,370,unused,"				if ((pnts[0] & 0xfe) && pnts[1] != 0) {
					printf(_(""Incorrect length in symlink component""));
				}
				if ((pnts[0] & 1) == 0)
					strcat(symlinkname, ""/"");
",unused,kek-123-mkisofs2Fdiag2Fisodump.c
"				slen -= (pnts[1] + 2);
				pnts += (pnts[1] + 2);
			}
			if (cflag)
				strcat(symlinkname, ""+"");
",1,unused,376,unused,"				slen -= (pnts[1] + 2);
				pnts += (pnts[1] + 2);
			}
			if (cflag)
				strcat(symlinkname, ""+"");
",unused,kek-123-mkisofs2Fdiag2Fisodump.c
"	int		cont_offset;
	int		cont_size;
	char		symlinkname[1024];

	sprintf(lbuffer+iline, "" RRlen=%d "", len);
",1,unused,193,unused,"	int		cont_offset;
	int		cont_size;
	char		symlinkname[1024];

	sprintf(lbuffer+iline, "" RRlen=%d "", len);
",unused,kek-123-mkisofs2Fdiag2Fisovfy.c
"	flag1 = -1;
	flag2 = 0;
	while (len >= 4) {
		if (ncount)
			sprintf(lbuffer+iline, "","");
",1,unused,206,unused,"	flag1 = -1;
	flag2 = 0;
	while (len >= 4) {
		if (ncount)
			sprintf(lbuffer+iline, "","");
",unused,kek-123-mkisofs2Fdiag2Fisovfy.c
"	while (len >= 4) {
		if (ncount)
			sprintf(lbuffer+iline, "","");
		else
			sprintf(lbuffer+iline, ""["");
",1,unused,208,unused,"	while (len >= 4) {
		if (ncount)
			sprintf(lbuffer+iline, "","");
		else
			sprintf(lbuffer+iline, ""["");
",unused,kek-123-mkisofs2Fdiag2Fisovfy.c
"			sprintf(lbuffer+iline, "","");
		else
			sprintf(lbuffer+iline, ""["");
		iline += strlen(lbuffer + iline);
		sprintf(lbuffer+iline, ""%c%c"", pnt[0], pnt[1]);
",1,unused,210,unused,"			sprintf(lbuffer+iline, "","");
		else
			sprintf(lbuffer+iline, ""["");
		iline += strlen(lbuffer + iline);
		sprintf(lbuffer+iline, ""%c%c"", pnt[0], pnt[1]);
",unused,kek-123-mkisofs2Fdiag2Fisovfy.c
"		sprintf(lbuffer+iline, ""%c%c"", pnt[0], pnt[1]);
		iline += strlen(lbuffer + iline);
		if (pnt[0] < 'A' || pnt[0] > 'Z' || pnt[1] < 'A' ||
		    pnt[1] > 'Z') {
			sprintf(lbuffer+iline, _(""**BAD SUSP %d %d]""),
",1,unused,214,unused,"		sprintf(lbuffer+iline, ""%c%c"", pnt[0], pnt[1]);
		iline += strlen(lbuffer + iline);
		if (pnt[0] < 'A' || pnt[0] > 'Z' || pnt[1] < 'A' ||
		    pnt[1] > 'Z') {
			sprintf(lbuffer+iline, _(""**BAD SUSP %d %d]""),
",unused,kek-123-mkisofs2Fdiag2Fisovfy.c
"			return (flag2);
		}

		if (pnt[3] != 1 && pnt[3] != 2) {
			sprintf(lbuffer+iline, _(""**BAD RRVERSION (%d)\n""), pnt[3]);
",1,unused,222,unused,"			return (flag2);
		}

		if (pnt[3] != 1 && pnt[3] != 2) {
			sprintf(lbuffer+iline, _(""**BAD RRVERSION (%d)\n""), pnt[3]);
",unused,kek-123-mkisofs2Fdiag2Fisovfy.c
"			iline += strlen(lbuffer + iline);
			return (flag2);
		}
		if (pnt[2] < 4) {
			sprintf(lbuffer+iline,
",1,unused,228,unused,"			iline += strlen(lbuffer + iline);
			return (flag2);
		}
		if (pnt[2] < 4) {
			sprintf(lbuffer+iline,
",unused,kek-123-mkisofs2Fdiag2Fisovfy.c
"		if (strncmp((char *)pnt, ""CE"", 2) == 0) {
			cont_extent = (off_t)isonum_733((char *)pnt+4);
			cont_offset = isonum_733((char *)pnt+12);
			cont_size = isonum_733((char *)pnt+20);
			sprintf(lbuffer+iline, ""=[%x,%x,%d]"",
",1,unused,264,unused,"		if (strncmp((char *)pnt, ""CE"", 2) == 0) {
			cont_extent = (off_t)isonum_733((char *)pnt+4);
			cont_offset = isonum_733((char *)pnt+12);
			cont_size = isonum_733((char *)pnt+20);
			sprintf(lbuffer+iline, ""=[%x,%x,%d]"",
",unused,kek-123-mkisofs2Fdiag2Fisovfy.c
"		}

		if (strncmp((char *)pnt, ""PL"", 2) == 0 || strncmp((char *)pnt, ""CL"", 2) == 0) {
			extent = isonum_733((char *)pnt+4);
			sprintf(lbuffer+iline, ""=%x"", extent);
",1,unused,275,unused,"		}

		if (strncmp((char *)pnt, ""PL"", 2) == 0 || strncmp((char *)pnt, ""CL"", 2) == 0) {
			extent = isonum_733((char *)pnt+4);
			sprintf(lbuffer+iline, ""=%x"", extent);
",unused,kek-123-mkisofs2Fdiag2Fisovfy.c
"				case 0:
					strncat(symlinkname, (char *)(pnts+2), pnts[1]);
					break;
				case 2:
					strcat(symlinkname, ""."");
",1,unused,289,unused,"				case 0:
					strncat(symlinkname, (char *)(pnts+2), pnts[1]);
					break;
				case 2:
					strcat(symlinkname, ""."");
",unused,kek-123-mkisofs2Fdiag2Fisovfy.c
"				case 2:
					strcat(symlinkname, ""."");
					break;
				case 4:
					strcat(symlinkname, "".."");
",1,unused,292,unused,"				case 2:
					strcat(symlinkname, ""."");
					break;
				case 4:
					strcat(symlinkname, "".."");
",unused,kek-123-mkisofs2Fdiag2Fisovfy.c
"				case 4:
					strcat(symlinkname, "".."");
					break;
				case 8:
					strcat(symlinkname, ""/"");
",1,unused,295,unused,"				case 4:
					strcat(symlinkname, "".."");
					break;
				case 8:
					strcat(symlinkname, ""/"");
",unused,kek-123-mkisofs2Fdiag2Fisovfy.c
"				case 8:
					strcat(symlinkname, ""/"");
					break;
				case 16:
					strcat(symlinkname, ""/mnt"");
",1,unused,298,unused,"				case 8:
					strcat(symlinkname, ""/"");
					break;
				case 16:
					strcat(symlinkname, ""/mnt"");
",unused,kek-123-mkisofs2Fdiag2Fisovfy.c
"					strcat(symlinkname, ""/"");
					break;
				case 16:
					strcat(symlinkname, ""/mnt"");
					sprintf(lbuffer+iline, _(""Warning - mount point requested""));
",1,unused,299,unused,"					strcat(symlinkname, ""/"");
					break;
				case 16:
					strcat(symlinkname, ""/mnt"");
					sprintf(lbuffer+iline, _(""Warning - mount point requested""));
",unused,kek-123-mkisofs2Fdiag2Fisovfy.c
"					sprintf(lbuffer+iline, _(""Warning - mount point requested""));
					iline += strlen(lbuffer + iline);
					break;
				case 32:
					strcat(symlinkname, ""kafka"");
",1,unused,303,unused,"					sprintf(lbuffer+iline, _(""Warning - mount point requested""));
					iline += strlen(lbuffer + iline);
					break;
				case 32:
					strcat(symlinkname, ""kafka"");
",unused,kek-123-mkisofs2Fdiag2Fisovfy.c
"					iline += strlen(lbuffer + iline);
					break;
				case 32:
					strcat(symlinkname, ""kafka"");
					sprintf(lbuffer+iline, _(""Warning - host_name requested""));
",1,unused,304,unused,"					iline += strlen(lbuffer + iline);
					break;
				case 32:
					strcat(symlinkname, ""kafka"");
					sprintf(lbuffer+iline, _(""Warning - host_name requested""));
",unused,kek-123-mkisofs2Fdiag2Fisovfy.c
"					sprintf(lbuffer+iline, _(""Warning - host_name requested""));
					iline += strlen(lbuffer + iline);
					break;
				default:
					sprintf(lbuffer+iline, _(""Reserved bit setting in symlink""));
",1,unused,308,unused,"					sprintf(lbuffer+iline, _(""Warning - host_name requested""));
					iline += strlen(lbuffer + iline);
					break;
				default:
					sprintf(lbuffer+iline, _(""Reserved bit setting in symlink""));
",unused,kek-123-mkisofs2Fdiag2Fisovfy.c
"					iline += strlen(lbuffer + iline);
					break;
				}
				if ((pnts[0] & 0xfe) && pnts[1] != 0) {
					sprintf(lbuffer+iline, _(""Incorrect length in symlink component""));
",1,unused,314,unused,"					iline += strlen(lbuffer + iline);
					break;
				}
				if ((pnts[0] & 0xfe) && pnts[1] != 0) {
					sprintf(lbuffer+iline, _(""Incorrect length in symlink component""));
",unused,kek-123-mkisofs2Fdiag2Fisovfy.c
"					sprintf(lbuffer+iline, _(""Incorrect length in symlink component""));
					iline += strlen(lbuffer + iline);
				}
				if ((pnts[0] & 1) == 0)
					strcat(symlinkname, ""/"");
",1,unused,318,unused,"					sprintf(lbuffer+iline, _(""Incorrect length in symlink component""));
					iline += strlen(lbuffer + iline);
				}
				if ((pnts[0] & 1) == 0)
					strcat(symlinkname, ""/"");
",unused,kek-123-mkisofs2Fdiag2Fisovfy.c
"				slen -= (pnts[1] + 2);
				pnts += (pnts[1] + 2);
			}
			if (symlinkname[0] != 0) {
				sprintf(lbuffer+iline, ""=%s"", symlinkname);
",1,unused,323,unused,"				slen -= (pnts[1] + 2);
				pnts += (pnts[1] + 2);
			}
			if (symlinkname[0] != 0) {
				sprintf(lbuffer+iline, ""=%s"", symlinkname);
",unused,kek-123-mkisofs2Fdiag2Fisovfy.c
"#endif
		flag2 |= parse_rr(&sector[cont_offset], cont_size, 1);
	}
	if (ncount) {
		sprintf(lbuffer+iline, ""]"");
",1,unused,343,unused,"#endif
		flag2 |= parse_rr(&sector[cont_offset], cont_size, 1);
	}
	if (ncount) {
		sprintf(lbuffer+iline, ""]"");
",unused,kek-123-mkisofs2Fdiag2Fisovfy.c
"		sprintf(lbuffer+iline, ""]"");
		iline += strlen(lbuffer + iline);
	}
	if (!cont_flag && flag1 != -1 && flag1 != (flag2 & 0xFF)) {
		sprintf(lbuffer+iline, _(""Flag %x != %x""), flag1, flag2);
",1,unused,347,unused,"		sprintf(lbuffer+iline, ""]"");
		iline += strlen(lbuffer + iline);
	}
	if (!cont_flag && flag1 != -1 && flag1 != (flag2 & 0xFF)) {
		sprintf(lbuffer+iline, _(""Flag %x != %x""), flag1, flag2);
",unused,kek-123-mkisofs2Fdiag2Fisovfy.c
"		while (1 == 1) {
			goof = iline = 0;
			idr = (struct iso_directory_record *) &buffer[i];
			if (idr->length[0] == 0) break;
			sprintf(&lbuffer[iline], ""%3d "", idr->length[0]);
",1,unused,460,unused,"		while (1 == 1) {
			goof = iline = 0;
			idr = (struct iso_directory_record *) &buffer[i];
			if (idr->length[0] == 0) break;
			sprintf(&lbuffer[iline], ""%3d "", idr->length[0]);
",unused,kek-123-mkisofs2Fdiag2Fisovfy.c
"			sprintf(&lbuffer[iline], ""%3d "", idr->length[0]);
			iline += strlen(lbuffer + iline);
			extent = isonum_733(idr->extent);
			size = isonum_733(idr->size);
			sprintf(&lbuffer[iline], ""%5x "", extent);
",1,unused,464,unused,"			sprintf(&lbuffer[iline], ""%3d "", idr->length[0]);
			iline += strlen(lbuffer + iline);
			extent = isonum_733(idr->extent);
			size = isonum_733(idr->size);
			sprintf(&lbuffer[iline], ""%5x "", extent);
",unused,kek-123-mkisofs2Fdiag2Fisovfy.c
"			extent = isonum_733(idr->extent);
			size = isonum_733(idr->size);
			sprintf(&lbuffer[iline], ""%5x "", extent);
			iline += strlen(lbuffer + iline);
			sprintf(&lbuffer[iline], ""%8d "", size);
",1,unused,466,unused,"			extent = isonum_733(idr->extent);
			size = isonum_733(idr->size);
			sprintf(&lbuffer[iline], ""%5x "", extent);
			iline += strlen(lbuffer + iline);
			sprintf(&lbuffer[iline], ""%8d "", size);
",unused,kek-123-mkisofs2Fdiag2Fisovfy.c
"			sprintf(&lbuffer[iline], ""%5x "", extent);
			iline += strlen(lbuffer + iline);
			sprintf(&lbuffer[iline], ""%8d "", size);
			iline += strlen(lbuffer + iline);
			sprintf(&lbuffer[iline], ""%c"", (idr->flags[0] & 2) ? '*' : ' ');
",1,unused,468,unused,"			sprintf(&lbuffer[iline], ""%5x "", extent);
			iline += strlen(lbuffer + iline);
			sprintf(&lbuffer[iline], ""%8d "", size);
			iline += strlen(lbuffer + iline);
			sprintf(&lbuffer[iline], ""%c"", (idr->flags[0] & 2) ? '*' : ' ');
",unused,kek-123-mkisofs2Fdiag2Fisovfy.c
"			sprintf(&lbuffer[iline], ""%c"", (idr->flags[0] & 2) ? '*' : ' ');
			iline += strlen(lbuffer + iline);

			if (idr->name_len[0] > 33) {
				sprintf(&lbuffer[iline], _(""File name length=(%d)""),
",1,unused,472,unused,"			sprintf(&lbuffer[iline], ""%c"", (idr->flags[0] & 2) ? '*' : ' ');
			iline += strlen(lbuffer + iline);

			if (idr->name_len[0] > 33) {
				sprintf(&lbuffer[iline], _(""File name length=(%d)""),
",unused,kek-123-mkisofs2Fdiag2Fisovfy.c
"							idr->name_len[0]);
				goof++;
				iline += strlen(lbuffer + iline);
			} else if (idr->name_len[0] == 1 && idr->name[0] == 0) {
				sprintf(&lbuffer[iline], "".             "");
",1,unused,477,unused,"							idr->name_len[0]);
				goof++;
				iline += strlen(lbuffer + iline);
			} else if (idr->name_len[0] == 1 && idr->name[0] == 0) {
				sprintf(&lbuffer[iline], "".             "");
",unused,kek-123-mkisofs2Fdiag2Fisovfy.c
"							isonum_711((char *) idr->ext_attr_length))) {
#else
				if (orig_file_addr != (off_t)isonum_733(idr->extent)) {
#endif
					sprintf(&lbuffer[iline], _(""***** Directory has null extent.""));
",1,unused,486,unused,"							isonum_711((char *) idr->ext_attr_length))) {
#else
				if (orig_file_addr != (off_t)isonum_733(idr->extent)) {
#endif
					sprintf(&lbuffer[iline], _(""***** Directory has null extent.""));
",unused,kek-123-mkisofs2Fdiag2Fisovfy.c
"					goof++;
					iline += strlen(lbuffer + iline);
				}
				if (i1) {
					sprintf(&lbuffer[iline], _(""***** . not  first entry.""));
",1,unused,491,unused,"					goof++;
					iline += strlen(lbuffer + iline);
				}
				if (i1) {
					sprintf(&lbuffer[iline], _(""***** . not  first entry.""));
",unused,kek-123-mkisofs2Fdiag2Fisovfy.c
"					rr_goof++;
					iline += strlen(lbuffer + iline);
				}
			} else if (idr->name_len[0] == 1 && idr->name[0] == 1) {
				sprintf(&lbuffer[iline], ""..            "");
",1,unused,496,unused,"					rr_goof++;
					iline += strlen(lbuffer + iline);
				}
			} else if (idr->name_len[0] == 1 && idr->name[0] == 1) {
				sprintf(&lbuffer[iline], ""..            "");
",unused,kek-123-mkisofs2Fdiag2Fisovfy.c
"							isonum_711((char *) idr->ext_attr_length))) {
#else
				if (parent_file_addr != (off_t)isonum_733(idr->extent)) {
#endif
					sprintf(&lbuffer[iline], _(""***** Directory has null extent.""));
",1,unused,505,unused,"							isonum_711((char *) idr->ext_attr_length))) {
#else
				if (parent_file_addr != (off_t)isonum_733(idr->extent)) {
#endif
					sprintf(&lbuffer[iline], _(""***** Directory has null extent.""));
",unused,kek-123-mkisofs2Fdiag2Fisovfy.c
"					goof++;
					iline += strlen(lbuffer + iline);
				}
				if (i1 != 1) {
					sprintf(&lbuffer[iline], _(""***** .. not second entry.""));
",1,unused,510,unused,"					goof++;
					iline += strlen(lbuffer + iline);
				}
				if (i1 != 1) {
					sprintf(&lbuffer[iline], _(""***** .. not second entry.""));
",unused,kek-123-mkisofs2Fdiag2Fisovfy.c
"					iline += strlen(lbuffer + iline);
				}
			} else {
				if (i1 < 2) {
					sprintf(&lbuffer[iline], _("" Improper sorting.""));
",1,unused,516,unused,"					iline += strlen(lbuffer + iline);
				}
			} else {
				if (i1 < 2) {
					sprintf(&lbuffer[iline], _("" Improper sorting.""));
",unused,kek-123-mkisofs2Fdiag2Fisovfy.c
"					sprintf(&lbuffer[iline], _("" Improper sorting.""));
					rr_goof++;
				}
				for (j = 0; j < (int)idr->name_len[0]; j++) {
					sprintf(&lbuffer[iline], ""%c"", idr->name[j]);
",1,unused,520,unused,"					sprintf(&lbuffer[iline], _("" Improper sorting.""));
					rr_goof++;
				}
				for (j = 0; j < (int)idr->name_len[0]; j++) {
					sprintf(&lbuffer[iline], ""%c"", idr->name[j]);
",unused,kek-123-mkisofs2Fdiag2Fisovfy.c
"				for (j = 0; j < (int)idr->name_len[0]; j++) {
					sprintf(&lbuffer[iline], ""%c"", idr->name[j]);
				}
				for (j = 0; j < (14 - (int) idr->name_len[0]); j++) {
					sprintf(&lbuffer[iline], "" "");
",1,unused,523,unused,"				for (j = 0; j < (int)idr->name_len[0]; j++) {
					sprintf(&lbuffer[iline], ""%c"", idr->name[j]);
				}
				for (j = 0; j < (14 - (int) idr->name_len[0]); j++) {
					sprintf(&lbuffer[iline], "" "");
",unused,kek-123-mkisofs2Fdiag2Fisovfy.c
"				rflag = 1;
			}

			if (size && extent == 0) {
				sprintf(&lbuffer[iline], _(""****Extent==0, size != 0""));
",1,unused,530,unused,"				rflag = 1;
			}

			if (size && extent == 0) {
				sprintf(&lbuffer[iline], _(""****Extent==0, size != 0""));
",unused,kek-123-mkisofs2Fdiag2Fisovfy.c
"			}
#endif

			if (idr->flags[0] & 0xf5) {
				sprintf(&lbuffer[iline], _(""Flags=(%x) ""), idr->flags[0]);
",1,unused,544,unused,"			}
#endif

			if (idr->flags[0] & 0xf5) {
				sprintf(&lbuffer[iline], _(""Flags=(%x) ""), idr->flags[0]);
",unused,kek-123-mkisofs2Fdiag2Fisovfy.c
"				goof++;
				iline += strlen(lbuffer + iline);
			}
			if (idr->interleave[0]) {
				sprintf(&lbuffer[iline], _(""Interleave=(%d) ""), idr->interleave[0]);
",1,unused,549,unused,"				goof++;
				iline += strlen(lbuffer + iline);
			}
			if (idr->interleave[0]) {
				sprintf(&lbuffer[iline], _(""Interleave=(%d) ""), idr->interleave[0]);
",unused,kek-123-mkisofs2Fdiag2Fisovfy.c
"				iline += strlen(lbuffer + iline);
			}

			if (idr->file_unit_size[0]) {
				sprintf(&lbuffer[iline], _(""File unit size=(%d) ""), idr->file_unit_size[0]);
",1,unused,555,unused,"				iline += strlen(lbuffer + iline);
			}

			if (idr->file_unit_size[0]) {
				sprintf(&lbuffer[iline], _(""File unit size=(%d) ""), idr->file_unit_size[0]);
",unused,kek-123-mkisofs2Fdiag2Fisovfy.c
"				iline += strlen(lbuffer + iline);
			}

			if (idr->volume_sequence_number[0] != 1) {
				sprintf(&lbuffer[iline], _(""Volume sequence number=(%d) ""), idr->volume_sequence_number[0]);
",1,unused,561,unused,"				iline += strlen(lbuffer + iline);
			}

			if (idr->volume_sequence_number[0] != 1) {
				sprintf(&lbuffer[iline], _(""Volume sequence number=(%d) ""), idr->volume_sequence_number[0]);
",unused,kek-123-mkisofs2Fdiag2Fisovfy.c
"			if (use_rock) {
				dump_rr(idr);
				goof += rr_goof;
			}
			sprintf(&lbuffer[iline], ""\n"");
",1,unused,570,unused,"			if (use_rock) {
				dump_rr(idr);
				goof += rr_goof;
			}
			sprintf(&lbuffer[iline], ""\n"");
",unused,kek-123-mkisofs2Fdiag2Fisovfy.c
"
		if (cbe->boot_image == NULL)
			comerrno(EX_BAD, _(""Missing boot image name, use -eltorito-boot option.\n""));
		p = (char *)e_malloc(strlen(cbe->boot_image) + strlen(path) + 2);
		strcpy(p, path);
",1,unused,81,unused,"
		if (cbe->boot_image == NULL)
			comerrno(EX_BAD, _(""Missing boot image name, use -eltorito-boot option.\n""));
		p = (char *)e_malloc(strlen(cbe->boot_image) + strlen(path) + 2);
		strcpy(p, path);
",unused,kek-123-mkisofs2Feltorito.c
"			comerrno(EX_BAD, _(""Missing boot image name, use -eltorito-boot option.\n""));
		p = (char *)e_malloc(strlen(cbe->boot_image) + strlen(path) + 2);
		strcpy(p, path);
		if (p[strlen(p) - 1] != '/') {
			strcat(p, ""/"");
",1,unused,83,unused,"			comerrno(EX_BAD, _(""Missing boot image name, use -eltorito-boot option.\n""));
		p = (char *)e_malloc(strlen(cbe->boot_image) + strlen(path) + 2);
		strcpy(p, path);
		if (p[strlen(p) - 1] != '/') {
			strcat(p, ""/"");
",unused,kek-123-mkisofs2Feltorito.c
"		strcpy(p, path);
		if (p[strlen(p) - 1] != '/') {
			strcat(p, ""/"");
		}
		strcat(p, cbe->boot_image);
",1,unused,85,unused,"		strcpy(p, path);
		if (p[strlen(p) - 1] != '/') {
			strcat(p, ""/"");
		}
		strcat(p, cbe->boot_image);
",unused,kek-123-mkisofs2Feltorito.c
"		free(p);
	}
#endif
	bootcat_path = (char *)e_malloc(strlen(boot_catalog) + strlen(path) + 2);
	strcpy(bootcat_path, path);
",1,unused,91,unused,"		free(p);
	}
#endif
	bootcat_path = (char *)e_malloc(strlen(boot_catalog) + strlen(path) + 2);
	strcpy(bootcat_path, path);
",unused,kek-123-mkisofs2Feltorito.c
"#endif
	bootcat_path = (char *)e_malloc(strlen(boot_catalog) + strlen(path) + 2);
	strcpy(bootcat_path, path);
	if (bootcat_path[strlen(bootcat_path) - 1] != '/') {
		strcat(bootcat_path, ""/"");
",1,unused,93,unused,"#endif
	bootcat_path = (char *)e_malloc(strlen(boot_catalog) + strlen(path) + 2);
	strcpy(bootcat_path, path);
	if (bootcat_path[strlen(bootcat_path) - 1] != '/') {
		strcat(bootcat_path, ""/"");
",unused,kek-123-mkisofs2Feltorito.c
"	strcpy(bootcat_path, path);
	if (bootcat_path[strlen(bootcat_path) - 1] != '/') {
		strcat(bootcat_path, ""/"");
	}
	strcat(bootcat_path, boot_catalog);
",1,unused,95,unused,"	strcpy(bootcat_path, path);
	if (bootcat_path[strlen(bootcat_path) - 1] != '/') {
		strcat(bootcat_path, ""/"");
	}
	strcat(bootcat_path, boot_catalog);
",unused,kek-123-mkisofs2Feltorito.c
"	 * TRANS.TBL entries. So if we are generating tables,
	 * store the TRANS.TBL data here for the moment
	 */
	if (generate_tables && !(bcat_de_flags & INHIBIT_ISO9660_ENTRY)) {
		sprintf(buffer, ""F\t%s\n"", s_entry->name);
",1,unused,232,unused,"	 * TRANS.TBL entries. So if we are generating tables,
	 * store the TRANS.TBL data here for the moment
	 */
	if (generate_tables && !(bcat_de_flags & INHIBIT_ISO9660_ENTRY)) {
		sprintf(buffer, ""F\t%s\n"", s_entry->name);
",unused,kek-123-mkisofs2Feltorito.c
"	 * I don't really know what 1 and 2 are - perhaps a more limited
	 * Unicode set.
	 * FIXME(eric) - how does Romeo fit in here?
	 */
	sprintf(jvol_desc->escape_sequences, ""%%/%c"", ucs_codes[ucs_level]);
",1,unused,448,unused,"	 * I don't really know what 1 and 2 are - perhaps a more limited
	 * Unicode set.
	 * FIXME(eric) - how does Romeo fit in here?
	 */
	sprintf(jvol_desc->escape_sequences, ""%%/%c"", ucs_codes[ucs_level]);
",unused,kek-123-mkisofs2Fjoliet.c
"
	/* If we have a boot file, then open and check it */
	if (mac_boot->name) {
		if (stat(mac_boot->name, &stat_buf) < 0) {
			sprintf(hce->error, _(""unable to stat HFS boot file %s""),
",1,unused,179,unused,"
	/* If we have a boot file, then open and check it */
	if (mac_boot->name) {
		if (stat(mac_boot->name, &stat_buf) < 0) {
			sprintf(hce->error, _(""unable to stat HFS boot file %s""),
",unused,kek-123-mkisofs2Fmac_label.c
"								mac_boot->name);
			return (-1);
		}
		if ((fp = fopen(mac_boot->name, ""rb"")) == NULL) {
			sprintf(hce->error, _(""unable to open HFS boot file %s""),
",1,unused,184,unused,"								mac_boot->name);
			return (-1);
		}
		if ((fp = fopen(mac_boot->name, ""rb"")) == NULL) {
			sprintf(hce->error, _(""unable to open HFS boot file %s""),
",unused,kek-123-mkisofs2Fmac_label.c
"								mac_boot->name);
			return (-1);
		}
		if (fread(tmp, 1, SECTOR_SIZE, fp) != SECTOR_SIZE) {
			sprintf(hce->error, _(""unable to read HFS boot file %s""),
",1,unused,189,unused,"								mac_boot->name);
			return (-1);
		}
		if (fread(tmp, 1, SECTOR_SIZE, fp) != SECTOR_SIZE) {
			sprintf(hce->error, _(""unable to read HFS boot file %s""),
",unused,kek-123-mkisofs2Fmac_label.c
"		mac_part = (MacPart *)(tmp + HFS_BLOCKSZ);

		if (!(IS_MAC_PART(mac_part) &&
		    strncmp((char *)mac_part->pmPartType, pmPartType_2, 12) == 0)) {
			sprintf(hce->error, _(""%s is not a HFS boot file""),
",1,unused,199,unused,"		mac_part = (MacPart *)(tmp + HFS_BLOCKSZ);

		if (!(IS_MAC_PART(mac_part) &&
		    strncmp((char *)mac_part->pmPartType, pmPartType_2, 12) == 0)) {
			sprintf(hce->error, _(""%s is not a HFS boot file""),
",unused,kek-123-mkisofs2Fmac_label.c
"		}
		/* check we have a boot block as well - last 2 blocks of file */

		if (fseek(fp, (off_t)-2 * HFS_BLOCKSZ, SEEK_END) != 0) {
			sprintf(hce->error, _(""unable to seek HFS boot file %s""),
",1,unused,207,unused,"		}
		/* check we have a boot block as well - last 2 blocks of file */

		if (fseek(fp, (off_t)-2 * HFS_BLOCKSZ, SEEK_END) != 0) {
			sprintf(hce->error, _(""unable to seek HFS boot file %s""),
",unused,kek-123-mkisofs2Fmac_label.c
"			return (-1);
		}
		/* overwrite (empty) boot block for our HFS volume */
		if (fread(hce->hfs_hdr, 2, HFS_BLOCKSZ, fp) != HFS_BLOCKSZ) {
			sprintf(hce->error, _(""unable to read HFS boot block %s""),
",1,unused,214,unused,"			return (-1);
		}
		/* overwrite (empty) boot block for our HFS volume */
		if (fread(hce->hfs_hdr, 2, HFS_BLOCKSZ, fp) != HFS_BLOCKSZ) {
			sprintf(hce->error, _(""unable to read HFS boot block %s""),
",unused,kek-123-mkisofs2Fmac_label.c
"		fclose(fp);

		/* check boot block is valid */
		if (d_getw((unsigned char *)hce->hfs_hdr) != HFS_BB_SIGWORD) {
			sprintf(hce->error,
",1,unused,223,unused,"		fclose(fp);

		/* check boot block is valid */
		if (d_getw((unsigned char *)hce->hfs_hdr) != HFS_BB_SIGWORD) {
			sprintf(hce->error,
",unused,kek-123-mkisofs2Fmac_label.c
"							sizeof (filename)) {
			strlcpy(filename, pnt, sizeof (filename));
			if (strlen(rcfn) + 2 <=
			    (sizeof (filename) - strlen(filename))) {
				strcat(filename, ""/"");
",1,unused,1524,unused,"							sizeof (filename)) {
			strlcpy(filename, pnt, sizeof (filename));
			if (strlen(rcfn) + 2 <=
			    (sizeof (filename) - strlen(filename))) {
				strcat(filename, ""/"");
",unused,kek-123-mkisofs2Fmkisofs.c
"			strlcpy(filename, pnt, sizeof (filename));
			if (strlen(rcfn) + 2 <=
			    (sizeof (filename) - strlen(filename))) {
				strcat(filename, ""/"");
				strcat(filename, rcfn);
",1,unused,1525,unused,"			strlcpy(filename, pnt, sizeof (filename));
			if (strlen(rcfn) + 2 <=
			    (sizeof (filename) - strlen(filename))) {
				strcat(filename, ""/"");
				strcat(filename, rcfn);
",unused,kek-123-mkisofs2Fmkisofs.c
"	/*
	 * There was a comment here about breaking in the year 2000.
	 * That's not true, in 2000 tm_year == 100, so 1900+tm_year == 2000.
	 */
	sprintf(result, ""%4.4d%2.2d%2.2d%2.2d%2.2d%2.2d%2.2d"",
",1,unused,1923,unused,"	/*
	 * There was a comment here about breaking in the year 2000.
	 * That's not true, in 2000 tm_year == 100, so 1900+tm_year == 2000.
	 */
	sprintf(result, ""%4.4d%2.2d%2.2d%2.2d%2.2d%2.2d%2.2d"",
",unused,kek-123-mkisofs2Fmkisofs.c
"				 * append to name from previous NM records
				 */
				dpnt->name = realloc(dpnt->name, nlen +
							strlen(name_buf) + 1);
				strcpy(dpnt->name + nlen, name_buf);
",1,unused,408,unused,"				 * append to name from previous NM records
				 */
				dpnt->name = realloc(dpnt->name, nlen +
							strlen(name_buf) + 1);
				strcpy(dpnt->name + nlen, name_buf);
",unused,kek-123-mkisofs2Fmulti.c
"					 */
					if (strlen(p) > 0) {
						(*pnt)->table =
						    e_malloc(strlen(p) + 4);
						sprintf((*pnt)->table,
",1,unused,1055,unused,"					 */
					if (strlen(p) > 0) {
						(*pnt)->table =
						    e_malloc(strlen(p) + 4);
						sprintf((*pnt)->table,
",unused,kek-123-mkisofs2Fmulti.c
"		if (pnt[i]->name != NULL && pnt[i]->whole_name == NULL) {
			/* Set the name for this directory. */
			strlcpy(whole_path, this_dir->de_name,
							sizeof (whole_path));
			strcat(whole_path, SPATH_SEPARATOR);
",1,unused,1513,unused,"		if (pnt[i]->name != NULL && pnt[i]->whole_name == NULL) {
			/* Set the name for this directory. */
			strlcpy(whole_path, this_dir->de_name,
							sizeof (whole_path));
			strcat(whole_path, SPATH_SEPARATOR);
",unused,kek-123-mkisofs2Fmulti.c
"			/* Set the name for this directory. */
			strlcpy(whole_path, this_dir->de_name,
							sizeof (whole_path));
			strcat(whole_path, SPATH_SEPARATOR);
			strcat(whole_path, pnt[i]->name);
",1,unused,1514,unused,"			/* Set the name for this directory. */
			strlcpy(whole_path, this_dir->de_name,
							sizeof (whole_path));
			strcat(whole_path, SPATH_SEPARATOR);
			strcat(whole_path, pnt[i]->name);
",unused,kek-123-mkisofs2Fmulti.c
"	 */
	if ((t & S_IFMT) == 0)		/* 0 (unallocated) */
		return (""unallocated"");

	sprintf(unkn, ""octal '%o'"", t & S_IFMT);
",1,unused,157,unused,"	 */
	if ((t & S_IFMT) == 0)		/* 0 (unallocated) */
		return (""unallocated"");

	sprintf(unkn, ""octal '%o'"", t & S_IFMT);
",unused,kek-123-mkisofs2Ftree.c
"			if (d1 > 5)
				rootname[5] = 0;
		}
		new_reclen = strlen(rootname);
		sprintf(newname, ""%s000%s%s"",
",1,unused,389,unused,"			if (d1 > 5)
				rootname[5] = 0;
		}
		new_reclen = strlen(rootname);
		sprintf(newname, ""%s000%s%s"",
",unused,kek-123-mkisofs2Ftree.c
"			}
			if (new_reclen & 1)
				new_reclen++;	/* Pad to an even byte */
			s_entry->isorec.length[0] = new_reclen;
			strcpy(s_entry->isorec.name, newname);
",1,unused,458,unused,"			}
			if (new_reclen & 1)
				new_reclen++;	/* Pad to an even byte */
			s_entry->isorec.length[0] = new_reclen;
			strcpy(s_entry->isorec.name, newname);
",unused,kek-123-mkisofs2Ftree.c
"				    s_e && s_e->mxroot == s_entry->mxroot;
							s_e = s_e->next) {
					s_e->isorec.length[0] = new_reclen;
					s_e->isorec.name_len[0] = s_entry->isorec.name_len[0];
					strcpy(s_e->isorec.name, newname);
",1,unused,471,unused,"				    s_e && s_e->mxroot == s_entry->mxroot;
							s_e = s_e->next) {
					s_e->isorec.length[0] = new_reclen;
					s_e->isorec.name_len[0] = s_entry->isorec.name_len[0];
					strcpy(s_e->isorec.name, newname);
",unused,kek-123-mkisofs2Ftree.c
"				 * the data fork
				 */
				s_entry2->isorec.name_len[0] =
						s_entry->isorec.name_len[0];
				strcpy(s_entry2->isorec.name,
",1,unused,489,unused,"				 * the data fork
				 */
				s_entry2->isorec.name_len[0] =
						s_entry->isorec.name_len[0];
				strcpy(s_entry2->isorec.name,
",unused,kek-123-mkisofs2Ftree.c
"			}
			if (new_reclen & 1)
				new_reclen++;	/* Pad to an even byte */
			s_entry1->isorec.length[0] = new_reclen;
			strcpy(s_entry1->isorec.name, newname);
",1,unused,514,unused,"			}
			if (new_reclen & 1)
				new_reclen++;	/* Pad to an even byte */
			s_entry1->isorec.length[0] = new_reclen;
			strcpy(s_entry1->isorec.name, newname);
",unused,kek-123-mkisofs2Ftree.c
"				    s_e && s_e->mxroot == s_entry1->mxroot;
							s_e = s_e->next) {
					s_e->isorec.length[0] = new_reclen;
					s_e->isorec.name_len[0] = s_entry1->isorec.name_len[0];
					strcpy(s_e->isorec.name, newname);
",1,unused,527,unused,"				    s_e && s_e->mxroot == s_entry1->mxroot;
							s_e = s_e->next) {
					s_e->isorec.length[0] = new_reclen;
					s_e->isorec.name_len[0] = s_entry1->isorec.name_len[0];
					strcpy(s_e->isorec.name, newname);
",unused,kek-123-mkisofs2Ftree.c
"				 * the data fork
				 */
				s_entry2->isorec.name_len[0] =
						s_entry1->isorec.name_len[0];
				strcpy(s_entry2->isorec.name,
",1,unused,546,unused,"				 * the data fork
				 */
				s_entry2->isorec.name_len[0] =
						s_entry1->isorec.name_len[0];
				strcpy(s_entry2->isorec.name,
",unused,kek-123-mkisofs2Ftree.c
"			 * count.
			 * Old mkiofs introduced a space after the iso
			 * filename to make parsing TRANS.TBL easier.
			 */
			sprintf(table->table + count, ""%c %-*s%s"",
",1,unused,729,unused,"			 * count.
			 * Old mkiofs introduced a space after the iso
			 * filename to make parsing TRANS.TBL easier.
			 */
			sprintf(table->table + count, ""%c %-*s%s"",
",unused,kek-123-mkisofs2Ftree.c
"		 */
		strlcpy(whole_path, path, sizeof (whole_path));
#ifndef VMS
		if (whole_path[strlen(whole_path) - 1] != '/')
			strcat(whole_path, ""/"");
",1,unused,1310,unused,"		 */
		strlcpy(whole_path, path, sizeof (whole_path));
#ifndef VMS
		if (whole_path[strlen(whole_path) - 1] != '/')
			strcat(whole_path, ""/"");
",unused,kek-123-mkisofs2Ftree.c
"#ifndef VMS
		if (whole_path[strlen(whole_path) - 1] != '/')
			strcat(whole_path, ""/"");
#endif
		strcat(whole_path, d_name);
",1,unused,1312,unused,"#ifndef VMS
		if (whole_path[strlen(whole_path) - 1] != '/')
			strcat(whole_path, ""/"");
#endif
		strcat(whole_path, d_name);
",unused,kek-123-mkisofs2Ftree.c
"		int	nchar;

		switch (lstatbuf.st_mode & S_IFMT) {
		case S_IFDIR:
			sprintf(buffer, ""D\t%s\n"",
",1,unused,2124,unused,"		int	nchar;

		switch (lstatbuf.st_mode & S_IFMT) {
		case S_IFDIR:
			sprintf(buffer, ""D\t%s\n"",
",unused,kek-123-mkisofs2Ftree.c
"#endif

#ifdef S_IFBLK
		case S_IFBLK:
			sprintf(buffer, ""B\t%s\t%lu %lu\n"",
",1,unused,2149,unused,"#endif

#ifdef S_IFBLK
		case S_IFBLK:
			sprintf(buffer, ""B\t%s\t%lu %lu\n"",
",unused,kek-123-mkisofs2Ftree.c
"			break;
#endif
#ifdef S_IFIFO
		case S_IFIFO:
			sprintf(buffer, ""P\t%s\n"",
",1,unused,2157,unused,"			break;
#endif
#ifdef S_IFIFO
		case S_IFIFO:
			sprintf(buffer, ""P\t%s\n"",
",unused,kek-123-mkisofs2Ftree.c
"			break;
#endif
#ifdef S_IFCHR
		case S_IFCHR:
			sprintf(buffer, ""C\t%s\t%lu %lu\n"",
",1,unused,2163,unused,"			break;
#endif
#ifdef S_IFCHR
		case S_IFCHR:
			sprintf(buffer, ""C\t%s\t%lu %lu\n"",
",unused,kek-123-mkisofs2Ftree.c
"#else
			nchar = -1;
#endif
			symlink_buff[nchar < 0 ? 0 : nchar] = 0;
			sprintf(buffer, ""L\t%s\t%s\n"",
",1,unused,2183,unused,"#else
			nchar = -1;
#endif
			symlink_buff[nchar < 0 ? 0 : nchar] = 0;
			sprintf(buffer, ""L\t%s\t%s\n"",
",unused,kek-123-mkisofs2Ftree.c
"			break;
#endif
#ifdef S_IFSOCK
		case S_IFSOCK:
			sprintf(buffer, ""S\t%s\n"",
",1,unused,2189,unused,"			break;
#endif
#ifdef S_IFSOCK
		case S_IFSOCK:
			sprintf(buffer, ""S\t%s\n"",
",unused,kek-123-mkisofs2Ftree.c
"			break;
#endif
		case S_IFREG:
		default:
			sprintf(buffer, ""F\t%s\n"",
",1,unused,2195,unused,"			break;
#endif
		case S_IFREG:
		default:
			sprintf(buffer, ""F\t%s\n"",
",unused,kek-123-mkisofs2Ftree.c
"			 * copy the new ISO9660 name to the rsrc fork
			 * - if it exists
			 */
			if (s_entry->assoc)
				strcpy(s_entry->assoc->isorec.name,
",1,unused,2266,unused,"			 * copy the new ISO9660 name to the rsrc fork
			 * - if it exists
			 */
			if (s_entry->assoc)
				strcpy(s_entry->assoc->isorec.name,
",unused,kek-123-mkisofs2Ftree.c
"LOCAL void
set_impl_ident(ent)
	udf_EntityID	*ent;
{
	strcpy((char *)ent->ident, ""*mkisofs"");
",1,unused,593,unused,"LOCAL void
set_impl_ident(ent)
	udf_EntityID	*ent;
{
	strcpy((char *)ent->ident, ""*mkisofs"");
",unused,kek-123-mkisofs2Fudf.c
"	set16(&pvd->interchange_level, 2);
	set16(&pvd->maximum_interchange_level, 2);
	set32(&pvd->character_set_list, 1);
	set32(&pvd->maximum_character_set_list, 1);
	sprintf(temp, ""%08X%08X"", volume_set_id[0], volume_set_id[1]);
",1,unused,705,unused,"	set16(&pvd->interchange_level, 2);
	set16(&pvd->maximum_interchange_level, 2);
	set32(&pvd->character_set_list, 1);
	set32(&pvd->maximum_character_set_list, 1);
	sprintf(temp, ""%08X%08X"", volume_set_id[0], volume_set_id[1]);
",unused,kek-123-mkisofs2Fudf.c
"	UInt32_t	lba;
{
	udf_impl_use_volume_desc *iuvd = (udf_impl_use_volume_desc *)buf;
	set32(&iuvd->volume_desc_seq_number, 1);
	strcpy((char *)iuvd->impl_ident.ident, ""*UDF LV Info"");
",1,unused,725,unused,"	UInt32_t	lba;
{
	udf_impl_use_volume_desc *iuvd = (udf_impl_use_volume_desc *)buf;
	set32(&iuvd->volume_desc_seq_number, 1);
	strcpy((char *)iuvd->impl_ident.ident, ""*UDF LV Info"");
",unused,kek-123-mkisofs2Fudf.c
"	set32(&pd->volume_desc_seq_number, 2);
	set16(&pd->partition_flags, UDF_PARTITION_FLAG_ALLOCATED);
	/*set16(&pd->partition_number, 0);*/
	set8(&pd->partition_contents.flags, UDF_ENTITYID_FLAG_PROTECTED);	/*???*/
	strcpy((char *)pd->partition_contents.ident, ""+NSR02"");
",1,unused,748,unused,"	set32(&pd->volume_desc_seq_number, 2);
	set16(&pd->partition_flags, UDF_PARTITION_FLAG_ALLOCATED);
	/*set16(&pd->partition_number, 0);*/
	set8(&pd->partition_contents.flags, UDF_ENTITYID_FLAG_PROTECTED);	/*???*/
	strcpy((char *)pd->partition_contents.ident, ""+NSR02"");
",unused,kek-123-mkisofs2Fudf.c
"LOCAL void
set_domain_ident(ent)
	udf_EntityID	*ent;
{
	strcpy((char *)ent->ident, ""*OSTA UDF Compliant"");
",1,unused,761,unused,"LOCAL void
set_domain_ident(ent)
	udf_EntityID	*ent;
{
	strcpy((char *)ent->ident, ""*OSTA UDF Compliant"");
",unused,kek-123-mkisofs2Fudf.c
"	set32(&fe->ext_attribute_free_ea_space.attribute_type, SECTOR_SIZE);
	set8(&fe->ext_attribute_free_ea_space.attribute_subtype, 1);
	set32(&fe->ext_attribute_free_ea_space.attribute_length, 52);
	set32(&fe->ext_attribute_free_ea_space.impl_use_length, 4);
	strcpy((char *)fe->ext_attribute_free_ea_space.impl_ident.ident, ""*UDF FreeEASpace"");
",1,unused,1068,unused,"	set32(&fe->ext_attribute_free_ea_space.attribute_type, SECTOR_SIZE);
	set8(&fe->ext_attribute_free_ea_space.attribute_subtype, 1);
	set32(&fe->ext_attribute_free_ea_space.attribute_length, 52);
	set32(&fe->ext_attribute_free_ea_space.impl_use_length, 4);
	strcpy((char *)fe->ext_attribute_free_ea_space.impl_ident.ident, ""*UDF FreeEASpace"");
",unused,kek-123-mkisofs2Fudf.c
"	set32(&fe->ext_attribute_dvd_cgms_info.attribute_type, SECTOR_SIZE);
	set8(&fe->ext_attribute_dvd_cgms_info.attribute_subtype, 1);
	set32(&fe->ext_attribute_dvd_cgms_info.attribute_length, 56);
	set32(&fe->ext_attribute_dvd_cgms_info.impl_use_length, 8);
	strcpy((char *)fe->ext_attribute_dvd_cgms_info.impl_ident.ident, ""*UDF DVD CGMS Info"");
",1,unused,1080,unused,"	set32(&fe->ext_attribute_dvd_cgms_info.attribute_type, SECTOR_SIZE);
	set8(&fe->ext_attribute_dvd_cgms_info.attribute_subtype, 1);
	set32(&fe->ext_attribute_dvd_cgms_info.attribute_length, 56);
	set32(&fe->ext_attribute_dvd_cgms_info.impl_use_length, 8);
	strcpy((char *)fe->ext_attribute_dvd_cgms_info.impl_ident.ident, ""*UDF DVD CGMS Info"");
",unused,kek-123-mkisofs2Fudf.c
"	set32(&fe->ext_attribute_macfinderinfo.attribute_type, EXTATTR_IMP_USE);
	set8(&fe->ext_attribute_macfinderinfo.attribute_subtype, 1);
	set32(&fe->ext_attribute_macfinderinfo.attribute_length, 96);
	set32(&fe->ext_attribute_macfinderinfo.impl_use_length, 48);
	strcpy((char *)fe->ext_attribute_macfinderinfo.impl_ident.ident, ""*UDF Mac FinderInfo"");
",1,unused,1092,unused,"	set32(&fe->ext_attribute_macfinderinfo.attribute_type, EXTATTR_IMP_USE);
	set8(&fe->ext_attribute_macfinderinfo.attribute_subtype, 1);
	set32(&fe->ext_attribute_macfinderinfo.attribute_length, 96);
	set32(&fe->ext_attribute_macfinderinfo.impl_use_length, 48);
	strcpy((char *)fe->ext_attribute_macfinderinfo.impl_ident.ident, ""*UDF Mac FinderInfo"");
",unused,kek-123-mkisofs2Fudf.c
"	set32(&fe->ext_attribute_free_ea_space.attribute_type, SECTOR_SIZE);
	set8(&fe->ext_attribute_free_ea_space.attribute_subtype, 1);
	set32(&fe->ext_attribute_free_ea_space.attribute_length, 52);
	set32(&fe->ext_attribute_free_ea_space.impl_use_length, 4);
	strcpy((char *)fe->ext_attribute_free_ea_space.impl_ident.ident, ""*UDF FreeAppEASpace"");
",1,unused,1283,unused,"	set32(&fe->ext_attribute_free_ea_space.attribute_type, SECTOR_SIZE);
	set8(&fe->ext_attribute_free_ea_space.attribute_subtype, 1);
	set32(&fe->ext_attribute_free_ea_space.attribute_length, 52);
	set32(&fe->ext_attribute_free_ea_space.impl_use_length, 4);
	strcpy((char *)fe->ext_attribute_free_ea_space.impl_ident.ident, ""*UDF FreeAppEASpace"");
",unused,kek-123-mkisofs2Fudf.c
"	set32(&fe->ext_attribute_dvd_cgms_info.attribute_type, SECTOR_SIZE);
	set8(&fe->ext_attribute_dvd_cgms_info.attribute_subtype, 1);
	set32(&fe->ext_attribute_dvd_cgms_info.attribute_length, 56);
	set32(&fe->ext_attribute_dvd_cgms_info.impl_use_length, 8);
	strcpy((char *)fe->ext_attribute_dvd_cgms_info.impl_ident.ident, ""*UDF DVD CGMS Info"");
",1,unused,1295,unused,"	set32(&fe->ext_attribute_dvd_cgms_info.attribute_type, SECTOR_SIZE);
	set8(&fe->ext_attribute_dvd_cgms_info.attribute_subtype, 1);
	set32(&fe->ext_attribute_dvd_cgms_info.attribute_length, 56);
	set32(&fe->ext_attribute_dvd_cgms_info.impl_use_length, 8);
	strcpy((char *)fe->ext_attribute_dvd_cgms_info.impl_ident.ident, ""*UDF DVD CGMS Info"");
",unused,kek-123-mkisofs2Fudf.c
"	set32(&fe->ext_attribute_macvolumeinfo.attribute_type, EXTATTR_IMP_USE);
	set8(&fe->ext_attribute_macvolumeinfo.attribute_subtype, 1);
	set32(&fe->ext_attribute_macvolumeinfo.attribute_length, 108);
	set32(&fe->ext_attribute_macvolumeinfo.impl_use_length, 60);
	strcpy((char *)fe->ext_attribute_macvolumeinfo.impl_ident.ident, ""*UDF Mac VolumeInfo"");
",1,unused,1306,unused,"	set32(&fe->ext_attribute_macvolumeinfo.attribute_type, EXTATTR_IMP_USE);
	set8(&fe->ext_attribute_macvolumeinfo.attribute_subtype, 1);
	set32(&fe->ext_attribute_macvolumeinfo.attribute_length, 108);
	set32(&fe->ext_attribute_macvolumeinfo.impl_use_length, 60);
	strcpy((char *)fe->ext_attribute_macvolumeinfo.impl_ident.ident, ""*UDF Mac VolumeInfo"");
",unused,kek-123-mkisofs2Fudf.c
"	set32(&fe->ext_attribute_macfinderinfo.attribute_type, EXTATTR_IMP_USE);
	set8(&fe->ext_attribute_macfinderinfo.attribute_subtype, 1);
	set32(&fe->ext_attribute_macfinderinfo.attribute_length, 88);
	set32(&fe->ext_attribute_macfinderinfo.impl_use_length, 40);
	strcpy((char *)fe->ext_attribute_macfinderinfo.impl_ident.ident, ""*UDF Mac FinderInfo"");
",1,unused,1334,unused,"	set32(&fe->ext_attribute_macfinderinfo.attribute_type, EXTATTR_IMP_USE);
	set8(&fe->ext_attribute_macfinderinfo.attribute_subtype, 1);
	set32(&fe->ext_attribute_macfinderinfo.attribute_length, 88);
	set32(&fe->ext_attribute_macfinderinfo.impl_use_length, 40);
	strcpy((char *)fe->ext_attribute_macfinderinfo.impl_ident.ident, ""*UDF Mac FinderInfo"");
",unused,kek-123-mkisofs2Fudf.c
"	set32(&fe->ext_attribute_free_ea_space.attribute_type, SECTOR_SIZE);
	set8(&fe->ext_attribute_free_ea_space.attribute_subtype, 1);
	set32(&fe->ext_attribute_free_ea_space.attribute_length, 52);
	set32(&fe->ext_attribute_free_ea_space.impl_use_length, 4);
	strcpy((char *)fe->ext_attribute_free_ea_space.impl_ident.ident, ""*UDF FreeAppEASpace"");
",1,unused,1589,unused,"	set32(&fe->ext_attribute_free_ea_space.attribute_type, SECTOR_SIZE);
	set8(&fe->ext_attribute_free_ea_space.attribute_subtype, 1);
	set32(&fe->ext_attribute_free_ea_space.attribute_length, 52);
	set32(&fe->ext_attribute_free_ea_space.impl_use_length, 4);
	strcpy((char *)fe->ext_attribute_free_ea_space.impl_ident.ident, ""*UDF FreeAppEASpace"");
",unused,kek-123-mkisofs2Fudf.c
"	set32(&fe->ext_attribute_dvd_cgms_info.attribute_type, SECTOR_SIZE);
	set8(&fe->ext_attribute_dvd_cgms_info.attribute_subtype, 1);
	set32(&fe->ext_attribute_dvd_cgms_info.attribute_length, 56);
	set32(&fe->ext_attribute_dvd_cgms_info.impl_use_length, 8);
	strcpy((char *)fe->ext_attribute_dvd_cgms_info.impl_ident.ident, ""*UDF DVD CGMS Info"");
",1,unused,1601,unused,"	set32(&fe->ext_attribute_dvd_cgms_info.attribute_type, SECTOR_SIZE);
	set8(&fe->ext_attribute_dvd_cgms_info.attribute_subtype, 1);
	set32(&fe->ext_attribute_dvd_cgms_info.attribute_length, 56);
	set32(&fe->ext_attribute_dvd_cgms_info.impl_use_length, 8);
	strcpy((char *)fe->ext_attribute_dvd_cgms_info.impl_ident.ident, ""*UDF DVD CGMS Info"");
",unused,kek-123-mkisofs2Fudf.c
"	set32(&fe->ext_attribute_macfinderinfo.attribute_type, EXTATTR_IMP_USE);
	set8(&fe->ext_attribute_macfinderinfo.attribute_subtype, 1);
	set32(&fe->ext_attribute_macfinderinfo.attribute_length, 88);
	set32(&fe->ext_attribute_macfinderinfo.impl_use_length, 40);
	strcpy((char *)fe->ext_attribute_macfinderinfo.impl_ident.ident, ""*UDF Mac FinderInfo"");
",1,unused,1613,unused,"	set32(&fe->ext_attribute_macfinderinfo.attribute_type, EXTATTR_IMP_USE);
	set8(&fe->ext_attribute_macfinderinfo.attribute_subtype, 1);
	set32(&fe->ext_attribute_macfinderinfo.attribute_length, 88);
	set32(&fe->ext_attribute_macfinderinfo.impl_use_length, 40);
	strcpy((char *)fe->ext_attribute_macfinderinfo.impl_ident.ident, ""*UDF Mac FinderInfo"");
",unused,kek-123-mkisofs2Fudf.c
"	set32(&ea->attribute_type, EXTATTR_IMP_USE);
	set8(&ea->attribute_subtype, 1);
	set32(&ea->attribute_length, 2024);	/* SECTOR_SIZE - sizeof (udf_ext_attribute_header_desc) */
	set32(&ea->impl_use_length, 1976);	/* attribute_length - 48 */
	strcpy((char *)ea->impl_ident.ident, ""*UDF FreeEASpace"");
",1,unused,2159,unused,"	set32(&ea->attribute_type, EXTATTR_IMP_USE);
	set8(&ea->attribute_subtype, 1);
	set32(&ea->attribute_length, 2024);	/* SECTOR_SIZE - sizeof (udf_ext_attribute_header_desc) */
	set32(&ea->impl_use_length, 1976);	/* attribute_length - 48 */
	strcpy((char *)ea->impl_ident.ident, ""*UDF FreeEASpace"");
",unused,kek-123-mkisofs2Fudf.c
"	set32(&ea->impl_use_length, ls);
	if (ls % SECTOR_SIZE)
		ls += SECTOR_SIZE - (ls % SECTOR_SIZE);
	set32(&ea->attribute_length, ls);
	strcpy((char *)ea->impl_ident.ident, ""*UDF Mac ResourceFork"");
",1,unused,2193,unused,"	set32(&ea->impl_use_length, ls);
	if (ls % SECTOR_SIZE)
		ls += SECTOR_SIZE - (ls % SECTOR_SIZE);
	set32(&ea->attribute_length, ls);
	strcpy((char *)ea->impl_ident.ident, ""*UDF Mac ResourceFork"");
",unused,kek-123-mkisofs2Fudf.c
"			 * allocation size has changed, so update
			 * ISO volume size
			 */
			if ((vblen = get_adj_size(Csize)) < 0) {
				sprintf(hce->error,
",1,unused,260,unused,"			 * allocation size has changed, so update
			 * ISO volume size
			 */
			if ((vblen = get_adj_size(Csize)) < 0) {
				sprintf(hce->error,
",unused,kek-123-mkisofs2Fvolume.c
"	hce->Csize = Csize;

	/* format and mount the ""volume"" */
	if (hfs_format(hce, 0, vol_name) < 0) {
		sprintf(hce->error, _(""can't HFS format %s""), vol_name);
",1,unused,281,unused,"	hce->Csize = Csize;

	/* format and mount the ""volume"" */
	if (hfs_format(hce, 0, vol_name) < 0) {
		sprintf(hce->error, _(""can't HFS format %s""), vol_name);
",unused,kek-123-mkisofs2Fvolume.c
"					hce->hfs_hdr_size + hce->hfs_map_size);
		adj_size_other(dpnt);
	}
	if ((vol = hfs_mount(hce, 0, 0)) == 0) {
		sprintf(hce->error, _(""can't HFS mount %s""), vol_name);
",1,unused,294,unused,"					hce->hfs_hdr_size + hce->hfs_map_size);
		adj_size_other(dpnt);
	}
	if ((vol = hfs_mount(hce, 0, 0)) == 0) {
		sprintf(hce->error, _(""can't HFS mount %s""), vol_name);
",unused,kek-123-mkisofs2Fvolume.c
"					 * not an ""exist"" error, or we can't
					 * append as the filename is already
					 * HFS_MAX_FLEN chars
					 */
					sprintf(hce->error,
",1,unused,414,unused,"					 * not an ""exist"" error, or we can't
					 * append as the filename is already
					 * HFS_MAX_FLEN chars
					 */
					sprintf(hce->error,
",unused,kek-123-mkisofs2Fvolume.c
"					 */
					if (!new_name)
						new_name++;

					sprintf(ent->name +
",1,unused,426,unused,"					 */
					if (!new_name)
						new_name++;

					sprintf(ent->name +
",unused,kek-123-mkisofs2Fvolume.c
"						digits++;
					}
				} else {
					/* append '_' to get new name */
					strcat(ent->name, LCHAR);
",1,unused,436,unused,"						digits++;
					}
				} else {
					/* append '_' to get new name */
					strcat(ent->name, LCHAR);
",unused,kek-123-mkisofs2Fvolume.c
"				s_entry->whole_name);
		}
		/* open file */
		if ((hfp = hfs_open(vol, ent->name)) == 0) {
			sprintf(hce->error, _(""can't HFS open %s""),
",1,unused,452,unused,"				s_entry->whole_name);
		}
		/* open file */
		if ((hfp = hfs_open(vol, ent->name)) == 0) {
			sprintf(hce->error, _(""can't HFS open %s""),
",unused,kek-123-mkisofs2Fvolume.c
"			ent->fdflags |= HFS_FNDR_ISINVISIBLE;

		/* update any HFS file attributes */
		if ((hfs_fsetattr(hfp, ent)) < 0) {
			sprintf(hce->error, _(""can't HFS set attributes %s""),
",1,unused,473,unused,"			ent->fdflags |= HFS_FNDR_ISINVISIBLE;

		/* update any HFS file attributes */
		if ((hfs_fsetattr(hfp, ent)) < 0) {
			sprintf(hce->error, _(""can't HFS set attributes %s""),
",unused,kek-123-mkisofs2Fvolume.c
"		}

		/* close the file and update the starting blocks */
		if (hfs_close(hfp, dext, rext) < 0) {
			sprintf(hce->error, _(""can't HFS close file %s""),
",1,unused,502,unused,"		}

		/* close the file and update the starting blocks */
		if (hfs_close(hfp, dext, rext) < 0) {
			sprintf(hce->error, _(""can't HFS close file %s""),
",unused,kek-123-mkisofs2Fvolume.c
"			}

			/* have a problem - can't find the real directory */
			if (s_entry1 == NULL) {
				sprintf(hce->error,
",1,unused,533,unused,"			}

			/* have a problem - can't find the real directory */
			if (s_entry1 == NULL) {
				sprintf(hce->error,
",unused,kek-123-mkisofs2Fvolume.c
"				if (dpnt->self == s_entry1)
					break;
				dpnt = dpnt->next;
				if (!dpnt) {
					sprintf(hce->error,
",1,unused,555,unused,"				if (dpnt->self == s_entry1)
					break;
				dpnt = dpnt->next;
				if (!dpnt) {
					sprintf(hce->error,
",unused,kek-123-mkisofs2Fvolume.c
"						 * or we can't append as the
						 * filename is already
						 * HFS_MAX_FLEN chars
						 */
						sprintf(hce->error,
",1,unused,595,unused,"						 * or we can't append as the
						 * filename is already
						 * HFS_MAX_FLEN chars
						 */
						sprintf(hce->error,
",unused,kek-123-mkisofs2Fvolume.c
"						 */
						if (!new_name)
							new_name++;

						sprintf(ent->name +
",1,unused,607,unused,"						 */
						if (!new_name)
							new_name++;

						sprintf(ent->name +
",unused,kek-123-mkisofs2Fvolume.c
"							digits++;
						}
					} else {
						/* append '_' to get new name */
						strcat(ent->name, LCHAR);
",1,unused,617,unused,"							digits++;
						}
					} else {
						/* append '_' to get new name */
						strcat(ent->name, LCHAR);
",unused,kek-123-mkisofs2Fvolume.c
"	unsigned short	flags = 0;

	memset(&ent1, 0, sizeof (hfsdirent));

	sprintf(name, ""%s\r"", ICON);
",1,unused,691,unused,"	unsigned short	flags = 0;

	memset(&ent1, 0, sizeof (hfsdirent));

	sprintf(name, ""%s\r"", ICON);
",unused,kek-123-mkisofs2Fvolume.c
"		extern char	*outfile;

		if (idx == 0)
			unlink(outfile);
		sprintf(nbuf, ""%s_%02d"", outfile, idx++);
",1,unused,205,unused,"		extern char	*outfile;

		if (idx == 0)
			unlink(outfile);
		sprintf(nbuf, ""%s_%02d"", outfile, idx++);
",unused,kek-123-mkisofs2Fwrite.c
"#endif	/* APPLE_HYB */
				if (s_entry->inode == TABLE_INODE) {
					dwpnt->table = s_entry->table;
					dwpnt->name = NULL;
					sprintf(whole_path, ""%s%s%s"",
",1,unused,1319,unused,"#endif	/* APPLE_HYB */
				if (s_entry->inode == TABLE_INODE) {
					dwpnt->table = s_entry->table;
					dwpnt->name = NULL;
					sprintf(whole_path, ""%s%s%s"",
",unused,kek-123-mkisofs2Fwrite.c
"	extern int	path_ind;

	/* Now write the version descriptor. */
	memset(vers, 0, sizeof (vers));
	strcpy(vers, ""MKI "");			/* strcpy() OK here */
",1,unused,2215,unused,"	extern int	path_ind;

	/* Now write the version descriptor. */
	memset(vers, 0, sizeof (vers));
	strcpy(vers, ""MKI "");			/* strcpy() OK here */
",unused,kek-123-mkisofs2Fwrite.c
"   ksp = 1.0;
   if (g < 0.0)
     {
     con = 2.0 * HALF_PI * r_major;
     sprintf(mess,""Point projects into a circle of radius = %12.2lf"",con);
",1,unused,96,unused,"   ksp = 1.0;
   if (g < 0.0)
     {
     con = 2.0 * HALF_PI * r_major;
     sprintf(mess,""Point projects into a circle of radius = %12.2lf"",con);
",unused,key_bes-modules2Fhdf5_handler2Fgctp2Fsrc2Fazimfor.c
"     tsincos(delta_lon, &sin_delta_lon, &cos_delta_lon);
     g = sin_lat_o * sin_lat + cos_lat_o * cos_lat * cos_delta_lon;
     if (g == -1.0) 
       {
	 sprintf(mess, ""Point projects to a circle of radius = %lf\n"", 2.0 * R);
",1,unused,178,unused,"     tsincos(delta_lon, &sin_delta_lon, &cos_delta_lon);
     g = sin_lat_o * sin_lat + cos_lat_o * cos_lat * cos_delta_lon;
     if (g == -1.0) 
       {
	 sprintf(mess, ""Point projects to a circle of radius = %lf\n"", 2.0 * R);
",unused,key_bes-modules2Fhdf5_handler2Fgctp2Fsrc2Flamazfor.c
"      {
      return(6);
      }
   file_e = TRUE;
   strcpy(err_file,efile);
",1,unused,112,unused,"      {
      return(6);
      }
   file_e = TRUE;
   strcpy(err_file,efile);
",unused,key_bes-modules2Fhdf5_handler2Fgctp2Fsrc2Freport.c
"      p_error(""Output file name not specified"",""report-file"");
      return(6);
      }
   file_e = TRUE;
   strcpy(err_file,efile);
",1,unused,125,unused,"      p_error(""Output file name not specified"",""report-file"");
      return(6);
      }
   file_e = TRUE;
   strcpy(err_file,efile);
",unused,key_bes-modules2Fhdf5_handler2Fgctp2Fsrc2Freport.c
"      {
      return(6);
      }
   file_p = TRUE;
   strcpy(parm_file,pfile);
",1,unused,146,unused,"      {
      return(6);
      }
   file_p = TRUE;
   strcpy(parm_file,pfile);
",unused,key_bes-modules2Fhdf5_handler2Fgctp2Fsrc2Freport.c
"      p_error(""Output file name not specified"",""report-file"");
      return(6);
      }
   file_p = TRUE;
   strcpy(parm_file,pfile);
",1,unused,159,unused,"      p_error(""Output file name not specified"",""report-file"");
      return(6);
      }
   file_p = TRUE;
   strcpy(parm_file,pfile);
",unused,key_bes-modules2Fhdf5_handler2Fgctp2Fsrc2Freport.c
"       if(tlam>rlm&&tlam<rlm2) goto L300;
       if(tlam<rlm)tlamp=2.50*PI;
       if(tlam>=rlm2) tlamp=HALF_PI;
       goto L230;
L260:  sprintf(errorbuf,""50 iterations without conv\n"");
",1,unused,232,unused,"       if(tlam>rlm&&tlam<rlm2) goto L300;
       if(tlam<rlm)tlamp=2.50*PI;
       if(tlam>=rlm2) tlamp=HALF_PI;
       goto L230;
L260:  sprintf(errorbuf,""50 iterations without conv\n"");
",unused,key_bes-modules2Fhdf5_handler2Fgctp2Fsrc2Fsomfor.c
"      }
   }
if (ind == -1)
   {
   sprintf(buf,""Illegal zone #%4ld  for spheroid #%4ld"",zone,sphere);
",1,unused,110,unused,"      }
   }
if (ind == -1)
   {
   sprintf(buf,""Illegal zone #%4ld  for spheroid #%4ld"",zone,sphere);
",unused,key_bes-modules2Fhdf5_handler2Fgctp2Fsrc2Fstplnfor.c
"#endif

if (id <= 0)
     {
     sprintf(buf,""Illegal zone #%4ld  for spheroid #%4ld"",zone,sphere);
",1,unused,152,unused,"#endif

if (id <= 0)
     {
     sprintf(buf,""Illegal zone #%4ld  for spheroid #%4ld"",zone,sphere);
",unused,key_bes-modules2Fhdf5_handler2Fgctp2Fsrc2Fstplnfor.c
"      }
   }
   if (ind == -1)
      {
      sprintf(buf,""Illegal zone #%4ld  for spheroid #%4ld"",zone,sphere);
",1,unused,109,unused,"      }
   }
   if (ind == -1)
      {
      sprintf(buf,""Illegal zone #%4ld  for spheroid #%4ld"",zone,sphere);
",unused,key_bes-modules2Fhdf5_handler2Fgctp2Fsrc2Fstplninv.c
"#endif

   if (id <= 0)
      {
      sprintf(buf,""Illegal zone #%4ld  for spheroid #%4ld"",zone,sphere);
",1,unused,152,unused,"#endif

   if (id <= 0)
      {
      sprintf(buf,""Illegal zone #%4ld  for spheroid #%4ld"",zone,sphere);
",unused,key_bes-modules2Fhdf5_handler2Fgctp2Fsrc2Fstplninv.c
"
		if (sym->owner == NULL)
			continue;

		strcpy(alias + baselen, sym->name);
",1,unused,1944,unused,"
		if (sym->owner == NULL)
			continue;

		strcpy(alias + baselen, sym->name);
",unused,kmoddebstretchee-tools2Fdepmod.c
"
		if (sym->owner == NULL)
			continue;

		strcpy(alias + baselen, sym->name);
",1,unused,1944,unused,"
		if (sym->owner == NULL)
			continue;

		strcpy(alias + baselen, sym->name);
",unused,kmodxenial-tools2Fdepmod.c
"	c &= 0377;
	if ((c < 128 || !utf_mode) && !control_char(c))
		SNPRINTF1(buf, sizeof(buf), ""%c"", (int) c);
	else if (c == ESC)
		strcpy(buf, ""ESC"");
",1,unused,429,unused,"	c &= 0377;
	if ((c < 128 || !utf_mode) && !control_char(c))
		SNPRINTF1(buf, sizeof(buf), ""%c"", (int) c);
	else if (c == ESC)
		strcpy(buf, ""ESC"");
",unused,lessdebian-charset.c
"{
	static char buf[32];

	if (ch == ESC)
		strcpy(buf, ""ESC"");
",1,unused,461,unused,"{
	static char buf[32];

	if (ch == ESC)
		strcpy(buf, ""ESC"");
",unused,lessdebian-charset.c
"			if (s == NULL)
				s = """";
			cmd_home();
			clear_eol();
			strcpy(cmdbuf, s);
",1,unused,732,unused,"			if (s == NULL)
				s = """";
			cmd_home();
			clear_eol();
			strcpy(cmdbuf, s);
",unused,lessdebian-cmdbuf.c
"	char *filename;
{
	char lastch;
	char *tempname = ecalloc(1, strlen(filename)+1);
	strcpy(tempname, filename);
",1,unused,1557,unused,"	char *filename;
{
	char lastch;
	char *tempname = ecalloc(1, strlen(filename)+1);
	strcpy(tempname, filename);
",unused,lessdebian-cmdbuf.c
"{
	char *pathname;

	pathname = calloc(strlen(dirname) + strlen(filename) + 2, sizeof(char));
	strcpy(pathname, dirname);
",1,unused,233,unused,"{
	char *pathname;

	pathname = calloc(strlen(dirname) + strlen(filename) + 2, sizeof(char));
	strcpy(pathname, dirname);
",unused,lessdebian-lesskey.c
"	char *pathname;

	pathname = calloc(strlen(dirname) + strlen(filename) + 2, sizeof(char));
	strcpy(pathname, dirname);
	strcat(pathname, PATHNAME_SEP);
",1,unused,234,unused,"	char *pathname;

	pathname = calloc(strlen(dirname) + strlen(filename) + 2, sizeof(char));
	strcpy(pathname, dirname);
	strcat(pathname, PATHNAME_SEP);
",unused,lessdebian-lesskey.c
"
	pathname = calloc(strlen(dirname) + strlen(filename) + 2, sizeof(char));
	strcpy(pathname, dirname);
	strcat(pathname, PATHNAME_SEP);
	strcat(pathname, filename);
",1,unused,235,unused,"
	pathname = calloc(strlen(dirname) + strlen(filename) + 2, sizeof(char));
	strcpy(pathname, dirname);
	strcat(pathname, PATHNAME_SEP);
	strcat(pathname, filename);
",unused,lessdebian-lesskey.c
"		linenumtoa(linenum, buf);
		n = (int) strlen(buf);
		if (n < MIN_LINENUM_WIDTH)
			n = MIN_LINENUM_WIDTH;
		sprintf(linebuf+curr, ""%*s "", n, buf);
",1,unused,215,unused,"		linenumtoa(linenum, buf);
		n = (int) strlen(buf);
		if (n < MIN_LINENUM_WIDTH)
			n = MIN_LINENUM_WIDTH;
		sprintf(linebuf+curr, ""%*s "", n, buf);
",unused,lessdebian-line.c
"{
	register char *p;

	p = (char *) ecalloc(strlen(s)+1, sizeof(char));
	strcpy(p, s);
",1,unused,300,unused,"{
	register char *p;

	p = (char *) ecalloc(strlen(s)+1, sizeof(char));
	strcpy(p, s);
",unused,lessdebian-main.c
"			error(""Position target at screen line %d"", &parg);
		} else
		{

			sprintf(buf, "".%06d"", jump_sline_fraction);
",1,unused,182,unused,"			error(""Position target at screen line %d"", &parg);
		} else
		{

			sprintf(buf, "".%06d"", jump_sline_fraction);
",unused,lessdebian-optfunc.c
"			error(""Horizontal shift %d columns"", &parg);
		} else
		{

			sprintf(buf, "".%06d"", shift_count_fraction);
",1,unused,247,unused,"			error(""Horizontal shift %d columns"", &parg);
		} else
		{

			sprintf(buf, "".%06d"", shift_count_fraction);
",unused,lessdebian-optfunc.c
"		ntabstops = i;
		tabdefault = tabstops[ntabstops-1] - tabstops[ntabstops-2];
		break;
	case QUERY:
		strcpy(msg, ""Tab stops "");
",1,unused,651,unused,"		ntabstops = i;
		tabdefault = tabstops[ntabstops-1] - tabstops[ntabstops-2];
		break;
	case QUERY:
		strcpy(msg, ""Tab stops "");
",unused,lessdebian-optfunc.c
"		{
			for (i = 1;  i < ntabstops;  i++)
			{
				if (i > 1)
					strcat(msg, "","");
",1,unused,657,unused,"		{
			for (i = 1;  i < ntabstops;  i++)
			{
				if (i > 1)
					strcat(msg, "","");
",unused,lessdebian-optfunc.c
"			for (i = 1;  i < ntabstops;  i++)
			{
				if (i > 1)
					strcat(msg, "","");
				sprintf(msg+strlen(msg), ""%d"", tabstops[i]);
",1,unused,658,unused,"			for (i = 1;  i < ntabstops;  i++)
			{
				if (i > 1)
					strcat(msg, "","");
				sprintf(msg+strlen(msg), ""%d"", tabstops[i]);
",unused,lessdebian-optfunc.c
"				if (i > 1)
					strcat(msg, "","");
				sprintf(msg+strlen(msg), ""%d"", tabstops[i]);
			}
			sprintf(msg+strlen(msg), "" and then "");
",1,unused,660,unused,"				if (i > 1)
					strcat(msg, "","");
				sprintf(msg+strlen(msg), ""%d"", tabstops[i]);
			}
			sprintf(msg+strlen(msg), "" and then "");
",unused,lessdebian-optfunc.c
"				sprintf(msg+strlen(msg), ""%d"", tabstops[i]);
			}
			sprintf(msg+strlen(msg), "" and then "");
		}
		sprintf(msg+strlen(msg), ""every %d spaces"",
",1,unused,662,unused,"				sprintf(msg+strlen(msg), ""%d"", tabstops[i]);
			}
			sprintf(msg+strlen(msg), "" and then "");
		}
		sprintf(msg+strlen(msg), ""every %d spaces"",
",unused,lessdebian-optfunc.c
"	int c;
{
	static char buf[8];

	sprintf(buf, ""-%s"", prchar(c));
",1,unused,60,unused,"	int c;
{
	static char buf[8];

	sprintf(buf, ""-%s"", prchar(c));
",unused,lessdebian-option.c
"				return p->value;
		p = (struct env *) ecalloc(1, sizeof(struct env));
		p->name = save(capname);
		p->value = (char *) ecalloc(strlen(capname)+3, sizeof(char));
		sprintf(p->value, ""<%s>"", capname);
",1,unused,639,unused,"				return p->value;
		p = (struct env *) ecalloc(1, sizeof(struct env));
		p->name = save(capname);
		p->value = (char *) ecalloc(strlen(capname)+3, sizeof(char));
		sprintf(p->value, ""<%s>"", capname);
",unused,lessdebian-screen.c
"		p->next = envs;
		envs = p;
		return p->value;
	}
	strcpy(name, ""LESS_TERMCAP_"");
",1,unused,644,unused,"		p->next = envs;
		envs = p;
		return p->value;
	}
	strcpy(name, ""LESS_TERMCAP_"");
",unused,lessdebian-screen.c
"		envs = p;
		return p->value;
	}
	strcpy(name, ""LESS_TERMCAP_"");
	strcat(name, capname);
",1,unused,645,unused,"		envs = p;
		return p->value;
	}
	strcpy(name, ""LESS_TERMCAP_"");
	strcat(name, capname);
",unused,lessdebian-screen.c
"	if (*sc_move == '\0')
		t2 = """";
	else
	{
		strcpy(sp, tgoto(sc_move, 0, 0));
",1,unused,1281,unused,"	if (*sc_move == '\0')
		t2 = """";
	else
	{
		strcpy(sp, tgoto(sc_move, 0, 0));
",unused,lessdebian-screen.c
"	if (*sc_move == '\0')
		t2 = """";
	else
	{
		strcpy(sp, tgoto(sc_move, 0, sc_height-1));
",1,unused,1298,unused,"	if (*sc_move == '\0')
		t2 = """";
	else
	{
		strcpy(sp, tgoto(sc_move, 0, sc_height-1));
",unused,lessdebian-screen.c
"	info->text = NULL;
	if (pattern != NULL)
	{
		info->text = (char *) ecalloc(1, strlen(pattern)+1);
		strcpy(info->text, pattern);
",1,unused,161,unused,"	info->text = NULL;
	if (pattern != NULL)
	{
		info->text = (char *) ecalloc(1, strlen(pattern)+1);
		strcpy(info->text, pattern);
",unused,lessdebian-search.c
"	register struct tag *tp;

	tp = (struct tag *) ecalloc(sizeof(struct tag), 1);
	tp->tag_file = (char *) ecalloc(strlen(file) + 1, sizeof(char));
	strcpy(tp->tag_file, file);
",1,unused,124,unused,"	register struct tag *tp;

	tp = (struct tag *) ecalloc(sizeof(struct tag), 1);
	tp->tag_file = (char *) ecalloc(strlen(file) + 1, sizeof(char));
	strcpy(tp->tag_file, file);
",unused,lessdebian-tags.c
"		tp->tag_pattern = NULL;
	else
	{
		tp->tag_pattern = (char *) ecalloc(strlen(pattern) + 1, sizeof(char));
		strcpy(tp->tag_pattern, pattern);
",1,unused,132,unused,"		tp->tag_pattern = NULL;
	else
	{
		tp->tag_pattern = (char *) ecalloc(strlen(pattern) + 1, sizeof(char));
		strcpy(tp->tag_pattern, pattern);
",unused,lessdebian-tags.c
"		if (qtag == NULL)
			qtag = tag;
		command = (char *) ecalloc(strlen(cmd) + strlen(flag) +
				strlen(qtag) + 5, sizeof(char));
		sprintf(command, ""%s -x%s %s"", cmd, flag, qtag);
",1,unused,533,unused,"		if (qtag == NULL)
			qtag = tag;
		command = (char *) ecalloc(strlen(cmd) + strlen(flag) +
				strlen(qtag) + 5, sizeof(char));
		sprintf(command, ""%s -x%s %s"", cmd, flag, qtag);
",unused,lessdebian-tags.c
"	c &= 0377;
	if ((c < 128 || !utf_mode) && !control_char(c))
		SNPRINTF1(buf, sizeof(buf), ""%c"", (int) c);
	else if (c == ESC)
		strcpy(buf, ""ESC"");
",1,unused,429,unused,"	c &= 0377;
	if ((c < 128 || !utf_mode) && !control_char(c))
		SNPRINTF1(buf, sizeof(buf), ""%c"", (int) c);
	else if (c == ESC)
		strcpy(buf, ""ESC"");
",unused,lessdebxen-charset.c
"{
	static char buf[32];

	if (ch == ESC)
		strcpy(buf, ""ESC"");
",1,unused,461,unused,"{
	static char buf[32];

	if (ch == ESC)
		strcpy(buf, ""ESC"");
",unused,lessdebxen-charset.c
"			if (s == NULL)
				s = """";
			cmd_home();
			clear_eol();
			strcpy(cmdbuf, s);
",1,unused,732,unused,"			if (s == NULL)
				s = """";
			cmd_home();
			clear_eol();
			strcpy(cmdbuf, s);
",unused,lessdebxen-cmdbuf.c
"	char *filename;
{
	char lastch;
	char *tempname = ecalloc(1, strlen(filename)+1);
	strcpy(tempname, filename);
",1,unused,1557,unused,"	char *filename;
{
	char lastch;
	char *tempname = ecalloc(1, strlen(filename)+1);
	strcpy(tempname, filename);
",unused,lessdebxen-cmdbuf.c
"			{
				/*
				 * Add the escape char.
				 */
				strcpy(p, esc);
",1,unused,209,unused,"			{
				/*
				 * Add the escape char.
				 */
				strcpy(p, esc);
",unused,lessdebxen-filename.c
"				if (ifile == NULL_IFILE)
					*to++ = *fr;
				else
				{
					strcpy(to, get_filename(ifile));
",1,unused,388,unused,"				if (ifile == NULL_IFILE)
					*to++ = *fr;
				else
				{
					strcpy(to, get_filename(ifile));
",unused,lessdebxen-filename.c
"			 */
			len *= 2;
			*p = '\0';
			p = (char *) ecalloc(len, sizeof(char));
			strcpy(p, buf);
",1,unused,558,unused,"			 */
			len *= 2;
			*p = '\0';
			p = (char *) ecalloc(len, sizeof(char));
			strcpy(p, buf);
",unused,lessdebxen-filename.c
"	cmd = (char *) ecalloc(len, sizeof(char));
	SNPRINTF4(cmd, len, ""%s -p0x%x -d0x%x -e%s "", lessecho, openquote, closequote, esc);
	free(esc);
	for (s = metachars();  *s != '\0';  s++)
		sprintf(cmd + strlen(cmd), ""-n0x%x "", *s);
",1,unused,781,unused,"	cmd = (char *) ecalloc(len, sizeof(char));
	SNPRINTF4(cmd, len, ""%s -p0x%x -d0x%x -e%s "", lessecho, openquote, closequote, esc);
	free(esc);
	for (s = metachars();  *s != '\0';  s++)
		sprintf(cmd + strlen(cmd), ""-n0x%x "", *s);
",unused,lessdebxen-filename.c
"	SNPRINTF4(cmd, len, ""%s -p0x%x -d0x%x -e%s "", lessecho, openquote, closequote, esc);
	free(esc);
	for (s = metachars();  *s != '\0';  s++)
		sprintf(cmd + strlen(cmd), ""-n0x%x "", *s);
	sprintf(cmd + strlen(cmd), ""-- %s"", ofilename);
",1,unused,782,unused,"	SNPRINTF4(cmd, len, ""%s -p0x%x -d0x%x -e%s "", lessecho, openquote, closequote, esc);
	free(esc);
	for (s = metachars();  *s != '\0';  s++)
		sprintf(cmd + strlen(cmd), ""-n0x%x "", *s);
	sprintf(cmd + strlen(cmd), ""-- %s"", ofilename);
",unused,lessdebxen-filename.c
"		static char is_a_dir[] = "" is a directory"";

		m = (char *) ecalloc(strlen(filename) + sizeof(is_a_dir), 
			sizeof(char));
		strcpy(m, filename);
",1,unused,1052,unused,"		static char is_a_dir[] = "" is a directory"";

		m = (char *) ecalloc(strlen(filename) + sizeof(is_a_dir), 
			sizeof(char));
		strcpy(m, filename);
",unused,lessdebxen-filename.c
"
		m = (char *) ecalloc(strlen(filename) + sizeof(is_a_dir), 
			sizeof(char));
		strcpy(m, filename);
		strcat(m, is_a_dir);
",1,unused,1053,unused,"
		m = (char *) ecalloc(strlen(filename) + sizeof(is_a_dir), 
			sizeof(char));
		strcpy(m, filename);
		strcat(m, is_a_dir);
",unused,lessdebxen-filename.c
"		{
			static char not_reg[] = "" is not a regular file (use -f to see it)"";
			m = (char *) ecalloc(strlen(filename) + sizeof(not_reg),
				sizeof(char));
			strcpy(m, filename);
",1,unused,1072,unused,"		{
			static char not_reg[] = "" is not a regular file (use -f to see it)"";
			m = (char *) ecalloc(strlen(filename) + sizeof(not_reg),
				sizeof(char));
			strcpy(m, filename);
",unused,lessdebxen-filename.c
"			static char not_reg[] = "" is not a regular file (use -f to see it)"";
			m = (char *) ecalloc(strlen(filename) + sizeof(not_reg),
				sizeof(char));
			strcpy(m, filename);
			strcat(m, not_reg);
",1,unused,1073,unused,"			static char not_reg[] = "" is not a regular file (use -f to see it)"";
			m = (char *) ecalloc(strlen(filename) + sizeof(not_reg),
				sizeof(char));
			strcpy(m, filename);
			strcat(m, not_reg);
",unused,lessdebxen-filename.c
"{
	char *pathname;

	pathname = calloc(strlen(dirname) + strlen(filename) + 2, sizeof(char));
	strcpy(pathname, dirname);
",1,unused,233,unused,"{
	char *pathname;

	pathname = calloc(strlen(dirname) + strlen(filename) + 2, sizeof(char));
	strcpy(pathname, dirname);
",unused,lessdebxen-lesskey.c
"	char *pathname;

	pathname = calloc(strlen(dirname) + strlen(filename) + 2, sizeof(char));
	strcpy(pathname, dirname);
	strcat(pathname, PATHNAME_SEP);
",1,unused,234,unused,"	char *pathname;

	pathname = calloc(strlen(dirname) + strlen(filename) + 2, sizeof(char));
	strcpy(pathname, dirname);
	strcat(pathname, PATHNAME_SEP);
",unused,lessdebxen-lesskey.c
"
	pathname = calloc(strlen(dirname) + strlen(filename) + 2, sizeof(char));
	strcpy(pathname, dirname);
	strcat(pathname, PATHNAME_SEP);
	strcat(pathname, filename);
",1,unused,235,unused,"
	pathname = calloc(strlen(dirname) + strlen(filename) + 2, sizeof(char));
	strcpy(pathname, dirname);
	strcat(pathname, PATHNAME_SEP);
	strcat(pathname, filename);
",unused,lessdebxen-lesskey.c
"		linenumtoa(linenum, buf);
		n = (int) strlen(buf);
		if (n < MIN_LINENUM_WIDTH)
			n = MIN_LINENUM_WIDTH;
		sprintf(linebuf+curr, ""%*s "", n, buf);
",1,unused,215,unused,"		linenumtoa(linenum, buf);
		n = (int) strlen(buf);
		if (n < MIN_LINENUM_WIDTH)
			n = MIN_LINENUM_WIDTH;
		sprintf(linebuf+curr, ""%*s "", n, buf);
",unused,lessdebxen-line.c
"{
	register char *p;

	p = (char *) ecalloc(strlen(s)+1, sizeof(char));
	strcpy(p, s);
",1,unused,300,unused,"{
	register char *p;

	p = (char *) ecalloc(strlen(s)+1, sizeof(char));
	strcpy(p, s);
",unused,lessdebxen-main.c
"			error(""Position target at screen line %d"", &parg);
		} else
		{

			sprintf(buf, "".%06d"", jump_sline_fraction);
",1,unused,182,unused,"			error(""Position target at screen line %d"", &parg);
		} else
		{

			sprintf(buf, "".%06d"", jump_sline_fraction);
",unused,lessdebxen-optfunc.c
"			error(""Horizontal shift %d columns"", &parg);
		} else
		{

			sprintf(buf, "".%06d"", shift_count_fraction);
",1,unused,247,unused,"			error(""Horizontal shift %d columns"", &parg);
		} else
		{

			sprintf(buf, "".%06d"", shift_count_fraction);
",unused,lessdebxen-optfunc.c
"		ntabstops = i;
		tabdefault = tabstops[ntabstops-1] - tabstops[ntabstops-2];
		break;
	case QUERY:
		strcpy(msg, ""Tab stops "");
",1,unused,651,unused,"		ntabstops = i;
		tabdefault = tabstops[ntabstops-1] - tabstops[ntabstops-2];
		break;
	case QUERY:
		strcpy(msg, ""Tab stops "");
",unused,lessdebxen-optfunc.c
"		{
			for (i = 1;  i < ntabstops;  i++)
			{
				if (i > 1)
					strcat(msg, "","");
",1,unused,657,unused,"		{
			for (i = 1;  i < ntabstops;  i++)
			{
				if (i > 1)
					strcat(msg, "","");
",unused,lessdebxen-optfunc.c
"			for (i = 1;  i < ntabstops;  i++)
			{
				if (i > 1)
					strcat(msg, "","");
				sprintf(msg+strlen(msg), ""%d"", tabstops[i]);
",1,unused,658,unused,"			for (i = 1;  i < ntabstops;  i++)
			{
				if (i > 1)
					strcat(msg, "","");
				sprintf(msg+strlen(msg), ""%d"", tabstops[i]);
",unused,lessdebxen-optfunc.c
"				if (i > 1)
					strcat(msg, "","");
				sprintf(msg+strlen(msg), ""%d"", tabstops[i]);
			}
			sprintf(msg+strlen(msg), "" and then "");
",1,unused,660,unused,"				if (i > 1)
					strcat(msg, "","");
				sprintf(msg+strlen(msg), ""%d"", tabstops[i]);
			}
			sprintf(msg+strlen(msg), "" and then "");
",unused,lessdebxen-optfunc.c
"				sprintf(msg+strlen(msg), ""%d"", tabstops[i]);
			}
			sprintf(msg+strlen(msg), "" and then "");
		}
		sprintf(msg+strlen(msg), ""every %d spaces"",
",1,unused,662,unused,"				sprintf(msg+strlen(msg), ""%d"", tabstops[i]);
			}
			sprintf(msg+strlen(msg), "" and then "");
		}
		sprintf(msg+strlen(msg), ""every %d spaces"",
",unused,lessdebxen-optfunc.c
"	int c;
{
	static char buf[8];

	sprintf(buf, ""-%s"", prchar(c));
",1,unused,60,unused,"	int c;
{
	static char buf[8];

	sprintf(buf, ""-%s"", prchar(c));
",unused,lessdebxen-option.c
"	register struct tag *tp;

	tp = (struct tag *) ecalloc(sizeof(struct tag), 1);
	tp->tag_file = (char *) ecalloc(strlen(file) + 1, sizeof(char));
	strcpy(tp->tag_file, file);
",1,unused,124,unused,"	register struct tag *tp;

	tp = (struct tag *) ecalloc(sizeof(struct tag), 1);
	tp->tag_file = (char *) ecalloc(strlen(file) + 1, sizeof(char));
	strcpy(tp->tag_file, file);
",unused,lessdebxen-tags.c
"		tp->tag_pattern = NULL;
	else
	{
		tp->tag_pattern = (char *) ecalloc(strlen(pattern) + 1, sizeof(char));
		strcpy(tp->tag_pattern, pattern);
",1,unused,132,unused,"		tp->tag_pattern = NULL;
	else
	{
		tp->tag_pattern = (char *) ecalloc(strlen(pattern) + 1, sizeof(char));
		strcpy(tp->tag_pattern, pattern);
",unused,lessdebxen-tags.c
"		if (qtag == NULL)
			qtag = tag;
		command = (char *) ecalloc(strlen(cmd) + strlen(flag) +
				strlen(qtag) + 5, sizeof(char));
		sprintf(command, ""%s -x%s %s"", cmd, flag, qtag);
",1,unused,533,unused,"		if (qtag == NULL)
			qtag = tag;
		command = (char *) ecalloc(strlen(cmd) + strlen(flag) +
				strlen(qtag) + 5, sizeof(char));
		sprintf(command, ""%s -x%s %s"", cmd, flag, qtag);
",unused,lessdebxen-tags.c
"	c &= 0377;
	if ((c < 128 || !utf_mode) && !control_char(c))
		SNPRINTF1(buf, sizeof(buf), ""%c"", (int) c);
	else if (c == ESC)
		strcpy(buf, ""ESC"");
",1,unused,429,unused,"	c &= 0377;
	if ((c < 128 || !utf_mode) && !control_char(c))
		SNPRINTF1(buf, sizeof(buf), ""%c"", (int) c);
	else if (c == ESC)
		strcpy(buf, ""ESC"");
",unused,lesstrusty-charset.c
"{
	static char buf[32];

	if (ch == ESC)
		strcpy(buf, ""ESC"");
",1,unused,461,unused,"{
	static char buf[32];

	if (ch == ESC)
		strcpy(buf, ""ESC"");
",unused,lesstrusty-charset.c
"			if (s == NULL)
				s = """";
			cmd_home();
			clear_eol();
			strcpy(cmdbuf, s);
",1,unused,732,unused,"			if (s == NULL)
				s = """";
			cmd_home();
			clear_eol();
			strcpy(cmdbuf, s);
",unused,lesstrusty-cmdbuf.c
"			{
				/*
				 * Add the escape char.
				 */
				strcpy(p, esc);
",1,unused,209,unused,"			{
				/*
				 * Add the escape char.
				 */
				strcpy(p, esc);
",unused,lesstrusty-filename.c
"				if (ifile == NULL_IFILE)
					*to++ = *fr;
				else
				{
					strcpy(to, get_filename(ifile));
",1,unused,388,unused,"				if (ifile == NULL_IFILE)
					*to++ = *fr;
				else
				{
					strcpy(to, get_filename(ifile));
",unused,lesstrusty-filename.c
"			 */
			len *= 2;
			*p = '\0';
			p = (char *) ecalloc(len, sizeof(char));
			strcpy(p, buf);
",1,unused,550,unused,"			 */
			len *= 2;
			*p = '\0';
			p = (char *) ecalloc(len, sizeof(char));
			strcpy(p, buf);
",unused,lesstrusty-filename.c
"	cmd = (char *) ecalloc(len, sizeof(char));
	SNPRINTF4(cmd, len, ""%s -p0x%x -d0x%x -e%s "", lessecho, openquote, closequote, esc);
	free(esc);
	for (s = metachars();  *s != '\0';  s++)
		sprintf(cmd + strlen(cmd), ""-n0x%x "", *s);
",1,unused,773,unused,"	cmd = (char *) ecalloc(len, sizeof(char));
	SNPRINTF4(cmd, len, ""%s -p0x%x -d0x%x -e%s "", lessecho, openquote, closequote, esc);
	free(esc);
	for (s = metachars();  *s != '\0';  s++)
		sprintf(cmd + strlen(cmd), ""-n0x%x "", *s);
",unused,lesstrusty-filename.c
"	SNPRINTF4(cmd, len, ""%s -p0x%x -d0x%x -e%s "", lessecho, openquote, closequote, esc);
	free(esc);
	for (s = metachars();  *s != '\0';  s++)
		sprintf(cmd + strlen(cmd), ""-n0x%x "", *s);
	sprintf(cmd + strlen(cmd), ""-- %s"", ofilename);
",1,unused,774,unused,"	SNPRINTF4(cmd, len, ""%s -p0x%x -d0x%x -e%s "", lessecho, openquote, closequote, esc);
	free(esc);
	for (s = metachars();  *s != '\0';  s++)
		sprintf(cmd + strlen(cmd), ""-n0x%x "", *s);
	sprintf(cmd + strlen(cmd), ""-- %s"", ofilename);
",unused,lesstrusty-filename.c
"		static char is_a_dir[] = "" is a directory"";

		m = (char *) ecalloc(strlen(filename) + sizeof(is_a_dir), 
			sizeof(char));
		strcpy(m, filename);
",1,unused,1039,unused,"		static char is_a_dir[] = "" is a directory"";

		m = (char *) ecalloc(strlen(filename) + sizeof(is_a_dir), 
			sizeof(char));
		strcpy(m, filename);
",unused,lesstrusty-filename.c
"
		m = (char *) ecalloc(strlen(filename) + sizeof(is_a_dir), 
			sizeof(char));
		strcpy(m, filename);
		strcat(m, is_a_dir);
",1,unused,1040,unused,"
		m = (char *) ecalloc(strlen(filename) + sizeof(is_a_dir), 
			sizeof(char));
		strcpy(m, filename);
		strcat(m, is_a_dir);
",unused,lesstrusty-filename.c
"		{
			static char not_reg[] = "" is not a regular file (use -f to see it)"";
			m = (char *) ecalloc(strlen(filename) + sizeof(not_reg),
				sizeof(char));
			strcpy(m, filename);
",1,unused,1059,unused,"		{
			static char not_reg[] = "" is not a regular file (use -f to see it)"";
			m = (char *) ecalloc(strlen(filename) + sizeof(not_reg),
				sizeof(char));
			strcpy(m, filename);
",unused,lesstrusty-filename.c
"			static char not_reg[] = "" is not a regular file (use -f to see it)"";
			m = (char *) ecalloc(strlen(filename) + sizeof(not_reg),
				sizeof(char));
			strcpy(m, filename);
			strcat(m, not_reg);
",1,unused,1060,unused,"			static char not_reg[] = "" is not a regular file (use -f to see it)"";
			m = (char *) ecalloc(strlen(filename) + sizeof(not_reg),
				sizeof(char));
			strcpy(m, filename);
			strcat(m, not_reg);
",unused,lesstrusty-filename.c
"{
	char *pathname;

	pathname = calloc(strlen(dirname) + strlen(filename) + 2, sizeof(char));
	strcpy(pathname, dirname);
",1,unused,232,unused,"{
	char *pathname;

	pathname = calloc(strlen(dirname) + strlen(filename) + 2, sizeof(char));
	strcpy(pathname, dirname);
",unused,lesstrusty-lesskey.c
"	char *pathname;

	pathname = calloc(strlen(dirname) + strlen(filename) + 2, sizeof(char));
	strcpy(pathname, dirname);
	strcat(pathname, PATHNAME_SEP);
",1,unused,233,unused,"	char *pathname;

	pathname = calloc(strlen(dirname) + strlen(filename) + 2, sizeof(char));
	strcpy(pathname, dirname);
	strcat(pathname, PATHNAME_SEP);
",unused,lesstrusty-lesskey.c
"
	pathname = calloc(strlen(dirname) + strlen(filename) + 2, sizeof(char));
	strcpy(pathname, dirname);
	strcat(pathname, PATHNAME_SEP);
	strcat(pathname, filename);
",1,unused,234,unused,"
	pathname = calloc(strlen(dirname) + strlen(filename) + 2, sizeof(char));
	strcpy(pathname, dirname);
	strcat(pathname, PATHNAME_SEP);
	strcat(pathname, filename);
",unused,lesstrusty-lesskey.c
"		linenumtoa(linenum, buf);
		n = strlen(buf);
		if (n < MIN_LINENUM_WIDTH)
			n = MIN_LINENUM_WIDTH;
		sprintf(linebuf+curr, ""%*s "", n, buf);
",1,unused,215,unused,"		linenumtoa(linenum, buf);
		n = strlen(buf);
		if (n < MIN_LINENUM_WIDTH)
			n = MIN_LINENUM_WIDTH;
		sprintf(linebuf+curr, ""%*s "", n, buf);
",unused,lesstrusty-line.c
"{
	register char *p;

	p = (char *) ecalloc(strlen(s)+1, sizeof(char));
	strcpy(p, s);
",1,unused,304,unused,"{
	register char *p;

	p = (char *) ecalloc(strlen(s)+1, sizeof(char));
	strcpy(p, s);
",unused,lesstrusty-main.c
"			error(""Position target at screen line %d"", &parg);
		} else
		{

			sprintf(buf, "".%06d"", jump_sline_fraction);
",1,unused,178,unused,"			error(""Position target at screen line %d"", &parg);
		} else
		{

			sprintf(buf, "".%06d"", jump_sline_fraction);
",unused,lesstrusty-optfunc.c
"			error(""Horizontal shift %d columns"", &parg);
		} else
		{

			sprintf(buf, "".%06d"", shift_count_fraction);
",1,unused,243,unused,"			error(""Horizontal shift %d columns"", &parg);
		} else
		{

			sprintf(buf, "".%06d"", shift_count_fraction);
",unused,lesstrusty-optfunc.c
"		ntabstops = i;
		tabdefault = tabstops[ntabstops-1] - tabstops[ntabstops-2];
		break;
	case QUERY:
		strcpy(msg, ""Tab stops "");
",1,unused,637,unused,"		ntabstops = i;
		tabdefault = tabstops[ntabstops-1] - tabstops[ntabstops-2];
		break;
	case QUERY:
		strcpy(msg, ""Tab stops "");
",unused,lesstrusty-optfunc.c
"		{
			for (i = 1;  i < ntabstops;  i++)
			{
				if (i > 1)
					strcat(msg, "","");
",1,unused,643,unused,"		{
			for (i = 1;  i < ntabstops;  i++)
			{
				if (i > 1)
					strcat(msg, "","");
",unused,lesstrusty-optfunc.c
"			for (i = 1;  i < ntabstops;  i++)
			{
				if (i > 1)
					strcat(msg, "","");
				sprintf(msg+strlen(msg), ""%d"", tabstops[i]);
",1,unused,644,unused,"			for (i = 1;  i < ntabstops;  i++)
			{
				if (i > 1)
					strcat(msg, "","");
				sprintf(msg+strlen(msg), ""%d"", tabstops[i]);
",unused,lesstrusty-optfunc.c
"				if (i > 1)
					strcat(msg, "","");
				sprintf(msg+strlen(msg), ""%d"", tabstops[i]);
			}
			sprintf(msg+strlen(msg), "" and then "");
",1,unused,646,unused,"				if (i > 1)
					strcat(msg, "","");
				sprintf(msg+strlen(msg), ""%d"", tabstops[i]);
			}
			sprintf(msg+strlen(msg), "" and then "");
",unused,lesstrusty-optfunc.c
"				sprintf(msg+strlen(msg), ""%d"", tabstops[i]);
			}
			sprintf(msg+strlen(msg), "" and then "");
		}
		sprintf(msg+strlen(msg), ""every %d spaces"",
",1,unused,648,unused,"				sprintf(msg+strlen(msg), ""%d"", tabstops[i]);
			}
			sprintf(msg+strlen(msg), "" and then "");
		}
		sprintf(msg+strlen(msg), ""every %d spaces"",
",unused,lesstrusty-optfunc.c
"	int c;
{
	static char buf[8];

	sprintf(buf, ""-%s"", prchar(c));
",1,unused,60,unused,"	int c;
{
	static char buf[8];

	sprintf(buf, ""-%s"", prchar(c));
",unused,lesstrusty-option.c
"				return p->value;
		p = (struct env *) ecalloc(1, sizeof(struct env));
		p->name = save(capname);
		p->value = (char *) ecalloc(strlen(capname)+3, sizeof(char));
		sprintf(p->value, ""<%s>"", capname);
",1,unused,639,unused,"				return p->value;
		p = (struct env *) ecalloc(1, sizeof(struct env));
		p->name = save(capname);
		p->value = (char *) ecalloc(strlen(capname)+3, sizeof(char));
		sprintf(p->value, ""<%s>"", capname);
",unused,lesstrusty-screen.c
"		p->next = envs;
		envs = p;
		return p->value;
	}
	strcpy(name, ""LESS_TERMCAP_"");
",1,unused,644,unused,"		p->next = envs;
		envs = p;
		return p->value;
	}
	strcpy(name, ""LESS_TERMCAP_"");
",unused,lesstrusty-screen.c
"		envs = p;
		return p->value;
	}
	strcpy(name, ""LESS_TERMCAP_"");
	strcat(name, capname);
",1,unused,645,unused,"		envs = p;
		return p->value;
	}
	strcpy(name, ""LESS_TERMCAP_"");
	strcat(name, capname);
",unused,lesstrusty-screen.c
"	if (*sc_move == '\0')
		t2 = """";
	else
	{
		strcpy(sp, tgoto(sc_move, 0, 0));
",1,unused,1281,unused,"	if (*sc_move == '\0')
		t2 = """";
	else
	{
		strcpy(sp, tgoto(sc_move, 0, 0));
",unused,lesstrusty-screen.c
"	if (*sc_move == '\0')
		t2 = """";
	else
	{
		strcpy(sp, tgoto(sc_move, 0, sc_height-1));
",1,unused,1298,unused,"	if (*sc_move == '\0')
		t2 = """";
	else
	{
		strcpy(sp, tgoto(sc_move, 0, sc_height-1));
",unused,lesstrusty-screen.c
"	info->text = NULL;
	if (pattern != NULL)
	{
		info->text = (char *) ecalloc(1, strlen(pattern)+1);
		strcpy(info->text, pattern);
",1,unused,119,unused,"	info->text = NULL;
	if (pattern != NULL)
	{
		info->text = (char *) ecalloc(1, strlen(pattern)+1);
		strcpy(info->text, pattern);
",unused,lesstrusty-search.c
"	register struct tag *tp;

	tp = (struct tag *) ecalloc(sizeof(struct tag), 1);
	tp->tag_file = (char *) ecalloc(strlen(file) + 1, sizeof(char));
	strcpy(tp->tag_file, file);
",1,unused,123,unused,"	register struct tag *tp;

	tp = (struct tag *) ecalloc(sizeof(struct tag), 1);
	tp->tag_file = (char *) ecalloc(strlen(file) + 1, sizeof(char));
	strcpy(tp->tag_file, file);
",unused,lesstrusty-tags.c
"		tp->tag_pattern = NULL;
	else
	{
		tp->tag_pattern = (char *) ecalloc(strlen(pattern) + 1, sizeof(char));
		strcpy(tp->tag_pattern, pattern);
",1,unused,131,unused,"		tp->tag_pattern = NULL;
	else
	{
		tp->tag_pattern = (char *) ecalloc(strlen(pattern) + 1, sizeof(char));
		strcpy(tp->tag_pattern, pattern);
",unused,lesstrusty-tags.c
"		if (qtag == NULL)
			qtag = tag;
		command = (char *) ecalloc(strlen(cmd) + strlen(flag) +
				strlen(qtag) + 5, sizeof(char));
		sprintf(command, ""%s -x%s %s"", cmd, flag, qtag);
",1,unused,532,unused,"		if (qtag == NULL)
			qtag = tag;
		command = (char *) ecalloc(strlen(cmd) + strlen(flag) +
				strlen(qtag) + 5, sizeof(char));
		sprintf(command, ""%s -x%s %s"", cmd, flag, qtag);
",unused,lesstrusty-tags.c
"	c &= 0377;
	if ((c < 128 || !utf_mode) && !control_char(c))
		SNPRINTF1(buf, sizeof(buf), ""%c"", (int) c);
	else if (c == ESC)
		strcpy(buf, ""ESC"");
",1,unused,429,unused,"	c &= 0377;
	if ((c < 128 || !utf_mode) && !control_char(c))
		SNPRINTF1(buf, sizeof(buf), ""%c"", (int) c);
	else if (c == ESC)
		strcpy(buf, ""ESC"");
",unused,lessxenial-charset.c
"{
	static char buf[32];

	if (ch == ESC)
		strcpy(buf, ""ESC"");
",1,unused,461,unused,"{
	static char buf[32];

	if (ch == ESC)
		strcpy(buf, ""ESC"");
",unused,lessxenial-charset.c
"			if (s == NULL)
				s = """";
			cmd_home();
			clear_eol();
			strcpy(cmdbuf, s);
",1,unused,732,unused,"			if (s == NULL)
				s = """";
			cmd_home();
			clear_eol();
			strcpy(cmdbuf, s);
",unused,lessxenial-cmdbuf.c
"	char *filename;
{
	char lastch;
	char *tempname = ecalloc(1, strlen(filename)+1);
	strcpy(tempname, filename);
",1,unused,1557,unused,"	char *filename;
{
	char lastch;
	char *tempname = ecalloc(1, strlen(filename)+1);
	strcpy(tempname, filename);
",unused,lessxenial-cmdbuf.c
"			{
				/*
				 * Add the escape char.
				 */
				strcpy(p, esc);
",1,unused,209,unused,"			{
				/*
				 * Add the escape char.
				 */
				strcpy(p, esc);
",unused,lessxenial-filename.c
"				if (ifile == NULL_IFILE)
					*to++ = *fr;
				else
				{
					strcpy(to, get_filename(ifile));
",1,unused,388,unused,"				if (ifile == NULL_IFILE)
					*to++ = *fr;
				else
				{
					strcpy(to, get_filename(ifile));
",unused,lessxenial-filename.c
"			 */
			len *= 2;
			*p = '\0';
			p = (char *) ecalloc(len, sizeof(char));
			strcpy(p, buf);
",1,unused,558,unused,"			 */
			len *= 2;
			*p = '\0';
			p = (char *) ecalloc(len, sizeof(char));
			strcpy(p, buf);
",unused,lessxenial-filename.c
"	cmd = (char *) ecalloc(len, sizeof(char));
	SNPRINTF4(cmd, len, ""%s -p0x%x -d0x%x -e%s "", lessecho, openquote, closequote, esc);
	free(esc);
	for (s = metachars();  *s != '\0';  s++)
		sprintf(cmd + strlen(cmd), ""-n0x%x "", *s);
",1,unused,781,unused,"	cmd = (char *) ecalloc(len, sizeof(char));
	SNPRINTF4(cmd, len, ""%s -p0x%x -d0x%x -e%s "", lessecho, openquote, closequote, esc);
	free(esc);
	for (s = metachars();  *s != '\0';  s++)
		sprintf(cmd + strlen(cmd), ""-n0x%x "", *s);
",unused,lessxenial-filename.c
"	SNPRINTF4(cmd, len, ""%s -p0x%x -d0x%x -e%s "", lessecho, openquote, closequote, esc);
	free(esc);
	for (s = metachars();  *s != '\0';  s++)
		sprintf(cmd + strlen(cmd), ""-n0x%x "", *s);
	sprintf(cmd + strlen(cmd), ""-- %s"", ofilename);
",1,unused,782,unused,"	SNPRINTF4(cmd, len, ""%s -p0x%x -d0x%x -e%s "", lessecho, openquote, closequote, esc);
	free(esc);
	for (s = metachars();  *s != '\0';  s++)
		sprintf(cmd + strlen(cmd), ""-n0x%x "", *s);
	sprintf(cmd + strlen(cmd), ""-- %s"", ofilename);
",unused,lessxenial-filename.c
"		static char is_a_dir[] = "" is a directory"";

		m = (char *) ecalloc(strlen(filename) + sizeof(is_a_dir), 
			sizeof(char));
		strcpy(m, filename);
",1,unused,1052,unused,"		static char is_a_dir[] = "" is a directory"";

		m = (char *) ecalloc(strlen(filename) + sizeof(is_a_dir), 
			sizeof(char));
		strcpy(m, filename);
",unused,lessxenial-filename.c
"
		m = (char *) ecalloc(strlen(filename) + sizeof(is_a_dir), 
			sizeof(char));
		strcpy(m, filename);
		strcat(m, is_a_dir);
",1,unused,1053,unused,"
		m = (char *) ecalloc(strlen(filename) + sizeof(is_a_dir), 
			sizeof(char));
		strcpy(m, filename);
		strcat(m, is_a_dir);
",unused,lessxenial-filename.c
"		{
			static char not_reg[] = "" is not a regular file (use -f to see it)"";
			m = (char *) ecalloc(strlen(filename) + sizeof(not_reg),
				sizeof(char));
			strcpy(m, filename);
",1,unused,1072,unused,"		{
			static char not_reg[] = "" is not a regular file (use -f to see it)"";
			m = (char *) ecalloc(strlen(filename) + sizeof(not_reg),
				sizeof(char));
			strcpy(m, filename);
",unused,lessxenial-filename.c
"			static char not_reg[] = "" is not a regular file (use -f to see it)"";
			m = (char *) ecalloc(strlen(filename) + sizeof(not_reg),
				sizeof(char));
			strcpy(m, filename);
			strcat(m, not_reg);
",1,unused,1073,unused,"			static char not_reg[] = "" is not a regular file (use -f to see it)"";
			m = (char *) ecalloc(strlen(filename) + sizeof(not_reg),
				sizeof(char));
			strcpy(m, filename);
			strcat(m, not_reg);
",unused,lessxenial-filename.c
"{
	char *pathname;

	pathname = calloc(strlen(dirname) + strlen(filename) + 2, sizeof(char));
	strcpy(pathname, dirname);
",1,unused,233,unused,"{
	char *pathname;

	pathname = calloc(strlen(dirname) + strlen(filename) + 2, sizeof(char));
	strcpy(pathname, dirname);
",unused,lessxenial-lesskey.c
"	char *pathname;

	pathname = calloc(strlen(dirname) + strlen(filename) + 2, sizeof(char));
	strcpy(pathname, dirname);
	strcat(pathname, PATHNAME_SEP);
",1,unused,234,unused,"	char *pathname;

	pathname = calloc(strlen(dirname) + strlen(filename) + 2, sizeof(char));
	strcpy(pathname, dirname);
	strcat(pathname, PATHNAME_SEP);
",unused,lessxenial-lesskey.c
"
	pathname = calloc(strlen(dirname) + strlen(filename) + 2, sizeof(char));
	strcpy(pathname, dirname);
	strcat(pathname, PATHNAME_SEP);
	strcat(pathname, filename);
",1,unused,235,unused,"
	pathname = calloc(strlen(dirname) + strlen(filename) + 2, sizeof(char));
	strcpy(pathname, dirname);
	strcat(pathname, PATHNAME_SEP);
	strcat(pathname, filename);
",unused,lessxenial-lesskey.c
"		linenumtoa(linenum, buf);
		n = (int) strlen(buf);
		if (n < MIN_LINENUM_WIDTH)
			n = MIN_LINENUM_WIDTH;
		sprintf(linebuf+curr, ""%*s "", n, buf);
",1,unused,215,unused,"		linenumtoa(linenum, buf);
		n = (int) strlen(buf);
		if (n < MIN_LINENUM_WIDTH)
			n = MIN_LINENUM_WIDTH;
		sprintf(linebuf+curr, ""%*s "", n, buf);
",unused,lessxenial-line.c
"{
	register char *p;

	p = (char *) ecalloc(strlen(s)+1, sizeof(char));
	strcpy(p, s);
",1,unused,300,unused,"{
	register char *p;

	p = (char *) ecalloc(strlen(s)+1, sizeof(char));
	strcpy(p, s);
",unused,lessxenial-main.c
"			error(""Position target at screen line %d"", &parg);
		} else
		{

			sprintf(buf, "".%06d"", jump_sline_fraction);
",1,unused,182,unused,"			error(""Position target at screen line %d"", &parg);
		} else
		{

			sprintf(buf, "".%06d"", jump_sline_fraction);
",unused,lessxenial-optfunc.c
"			error(""Horizontal shift %d columns"", &parg);
		} else
		{

			sprintf(buf, "".%06d"", shift_count_fraction);
",1,unused,247,unused,"			error(""Horizontal shift %d columns"", &parg);
		} else
		{

			sprintf(buf, "".%06d"", shift_count_fraction);
",unused,lessxenial-optfunc.c
"		ntabstops = i;
		tabdefault = tabstops[ntabstops-1] - tabstops[ntabstops-2];
		break;
	case QUERY:
		strcpy(msg, ""Tab stops "");
",1,unused,651,unused,"		ntabstops = i;
		tabdefault = tabstops[ntabstops-1] - tabstops[ntabstops-2];
		break;
	case QUERY:
		strcpy(msg, ""Tab stops "");
",unused,lessxenial-optfunc.c
"		{
			for (i = 1;  i < ntabstops;  i++)
			{
				if (i > 1)
					strcat(msg, "","");
",1,unused,657,unused,"		{
			for (i = 1;  i < ntabstops;  i++)
			{
				if (i > 1)
					strcat(msg, "","");
",unused,lessxenial-optfunc.c
"			for (i = 1;  i < ntabstops;  i++)
			{
				if (i > 1)
					strcat(msg, "","");
				sprintf(msg+strlen(msg), ""%d"", tabstops[i]);
",1,unused,658,unused,"			for (i = 1;  i < ntabstops;  i++)
			{
				if (i > 1)
					strcat(msg, "","");
				sprintf(msg+strlen(msg), ""%d"", tabstops[i]);
",unused,lessxenial-optfunc.c
"				if (i > 1)
					strcat(msg, "","");
				sprintf(msg+strlen(msg), ""%d"", tabstops[i]);
			}
			sprintf(msg+strlen(msg), "" and then "");
",1,unused,660,unused,"				if (i > 1)
					strcat(msg, "","");
				sprintf(msg+strlen(msg), ""%d"", tabstops[i]);
			}
			sprintf(msg+strlen(msg), "" and then "");
",unused,lessxenial-optfunc.c
"				sprintf(msg+strlen(msg), ""%d"", tabstops[i]);
			}
			sprintf(msg+strlen(msg), "" and then "");
		}
		sprintf(msg+strlen(msg), ""every %d spaces"",
",1,unused,662,unused,"				sprintf(msg+strlen(msg), ""%d"", tabstops[i]);
			}
			sprintf(msg+strlen(msg), "" and then "");
		}
		sprintf(msg+strlen(msg), ""every %d spaces"",
",unused,lessxenial-optfunc.c
"	int c;
{
	static char buf[8];

	sprintf(buf, ""-%s"", prchar(c));
",1,unused,60,unused,"	int c;
{
	static char buf[8];

	sprintf(buf, ""-%s"", prchar(c));
",unused,lessxenial-option.c
"				return p->value;
		p = (struct env *) ecalloc(1, sizeof(struct env));
		p->name = save(capname);
		p->value = (char *) ecalloc(strlen(capname)+3, sizeof(char));
		sprintf(p->value, ""<%s>"", capname);
",1,unused,639,unused,"				return p->value;
		p = (struct env *) ecalloc(1, sizeof(struct env));
		p->name = save(capname);
		p->value = (char *) ecalloc(strlen(capname)+3, sizeof(char));
		sprintf(p->value, ""<%s>"", capname);
",unused,lessxenial-screen.c
"		p->next = envs;
		envs = p;
		return p->value;
	}
	strcpy(name, ""LESS_TERMCAP_"");
",1,unused,644,unused,"		p->next = envs;
		envs = p;
		return p->value;
	}
	strcpy(name, ""LESS_TERMCAP_"");
",unused,lessxenial-screen.c
"		envs = p;
		return p->value;
	}
	strcpy(name, ""LESS_TERMCAP_"");
	strcat(name, capname);
",1,unused,645,unused,"		envs = p;
		return p->value;
	}
	strcpy(name, ""LESS_TERMCAP_"");
	strcat(name, capname);
",unused,lessxenial-screen.c
"	if (*sc_move == '\0')
		t2 = """";
	else
	{
		strcpy(sp, tgoto(sc_move, 0, 0));
",1,unused,1281,unused,"	if (*sc_move == '\0')
		t2 = """";
	else
	{
		strcpy(sp, tgoto(sc_move, 0, 0));
",unused,lessxenial-screen.c
"	if (*sc_move == '\0')
		t2 = """";
	else
	{
		strcpy(sp, tgoto(sc_move, 0, sc_height-1));
",1,unused,1298,unused,"	if (*sc_move == '\0')
		t2 = """";
	else
	{
		strcpy(sp, tgoto(sc_move, 0, sc_height-1));
",unused,lessxenial-screen.c
"	info->text = NULL;
	if (pattern != NULL)
	{
		info->text = (char *) ecalloc(1, strlen(pattern)+1);
		strcpy(info->text, pattern);
",1,unused,161,unused,"	info->text = NULL;
	if (pattern != NULL)
	{
		info->text = (char *) ecalloc(1, strlen(pattern)+1);
		strcpy(info->text, pattern);
",unused,lessxenial-search.c
"	register struct tag *tp;

	tp = (struct tag *) ecalloc(sizeof(struct tag), 1);
	tp->tag_file = (char *) ecalloc(strlen(file) + 1, sizeof(char));
	strcpy(tp->tag_file, file);
",1,unused,124,unused,"	register struct tag *tp;

	tp = (struct tag *) ecalloc(sizeof(struct tag), 1);
	tp->tag_file = (char *) ecalloc(strlen(file) + 1, sizeof(char));
	strcpy(tp->tag_file, file);
",unused,lessxenial-tags.c
"		tp->tag_pattern = NULL;
	else
	{
		tp->tag_pattern = (char *) ecalloc(strlen(pattern) + 1, sizeof(char));
		strcpy(tp->tag_pattern, pattern);
",1,unused,132,unused,"		tp->tag_pattern = NULL;
	else
	{
		tp->tag_pattern = (char *) ecalloc(strlen(pattern) + 1, sizeof(char));
		strcpy(tp->tag_pattern, pattern);
",unused,lessxenial-tags.c
"		if (qtag == NULL)
			qtag = tag;
		command = (char *) ecalloc(strlen(cmd) + strlen(flag) +
				strlen(qtag) + 5, sizeof(char));
		sprintf(command, ""%s -x%s %s"", cmd, flag, qtag);
",1,unused,533,unused,"		if (qtag == NULL)
			qtag = tag;
		command = (char *) ecalloc(strlen(cmd) + strlen(flag) +
				strlen(qtag) + 5, sizeof(char));
		sprintf(command, ""%s -x%s %s"", cmd, flag, qtag);
",unused,lessxenial-tags.c
"    sub->end_display_time = FFMAX(sub->end_display_time, 10 * duration);
    rects[sub->num_rects]       = av_mallocz(sizeof(*rects[0]));
    rects[sub->num_rects]->type = SUBTITLE_ASS;
    rects[sub->num_rects]->ass  = av_malloc(len + dlen + 1);
    strcpy (rects[sub->num_rects]->ass      , header);
",1,unused,121,unused,"    sub->end_display_time = FFMAX(sub->end_display_time, 10 * duration);
    rects[sub->num_rects]       = av_mallocz(sizeof(*rects[0]));
    rects[sub->num_rects]->type = SUBTITLE_ASS;
    rects[sub->num_rects]->ass  = av_malloc(len + dlen + 1);
    strcpy (rects[sub->num_rects]->ass      , header);
",unused,libav-libavcodec2Fass.c
"    int len, tag_close, sptr = 1, line_start = 1, an = 0, end = 0;
    SrtStack stack[16];

    stack[0].tag[0] = 0;
    strcpy(stack[0].param[PARAM_SIZE],  ""{\\fs}"");
",1,unused,57,unused,"    int len, tag_close, sptr = 1, line_start = 1, an = 0, end = 0;
    SrtStack stack[16];

    stack[0].tag[0] = 0;
    strcpy(stack[0].param[PARAM_SIZE],  ""{\\fs}"");
",unused,libav-libavcodec2Fsrtdec.c
"    SrtStack stack[16];

    stack[0].tag[0] = 0;
    strcpy(stack[0].param[PARAM_SIZE],  ""{\\fs}"");
    strcpy(stack[0].param[PARAM_COLOR], ""{\\c}"");
",1,unused,58,unused,"    SrtStack stack[16];

    stack[0].tag[0] = 0;
    strcpy(stack[0].param[PARAM_SIZE],  ""{\\fs}"");
    strcpy(stack[0].param[PARAM_COLOR], ""{\\c}"");
",unused,libav-libavcodec2Fsrtdec.c
"
    stack[0].tag[0] = 0;
    strcpy(stack[0].param[PARAM_SIZE],  ""{\\fs}"");
    strcpy(stack[0].param[PARAM_COLOR], ""{\\c}"");
    strcpy(stack[0].param[PARAM_FACE],  ""{\\fn}"");
",1,unused,59,unused,"
    stack[0].tag[0] = 0;
    strcpy(stack[0].param[PARAM_SIZE],  ""{\\fs}"");
    strcpy(stack[0].param[PARAM_COLOR], ""{\\c}"");
    strcpy(stack[0].param[PARAM_FACE],  ""{\\fn}"");
",unused,libav-libavcodec2Fsrtdec.c
"        goto fail;
    }
    uc->av_class = &ffurl_context_class;
    uc->filename = (char *)&uc[1];
    strcpy(uc->filename, filename);
",1,unused,126,unused,"        goto fail;
    }
    uc->av_class = &ffurl_context_class;
    uc->filename = (char *)&uc[1];
    strcpy(uc->filename, filename);
",unused,libav-libavformat2Favio.c
"    char proto_str[128], proto_nested[128], *ptr;
    size_t proto_len = strspn(filename, URL_SCHEME_CHARS);

    if (filename[proto_len] != ':' || is_dos_path(filename))
        strcpy(proto_str, ""file"");
",1,unused,191,unused,"    char proto_str[128], proto_nested[128], *ptr;
    size_t proto_len = strspn(filename, URL_SCHEME_CHARS);

    if (filename[proto_len] != ':' || is_dos_path(filename))
        strcpy(proto_str, ""file"");
",unused,libav-libavformat2Favio.c
"        ret = AVERROR(ENOMEM);
        goto fail;
    }

    strcpy(hls->basename, s->filename);
",1,unused,225,unused,"        ret = AVERROR(ENOMEM);
        goto fail;
    }

    strcpy(hls->basename, s->filename);
",unused,libav-libavformat2Fhlsenc.c
"    av_md5_sum(zres, buf, 64);
    ff_data_to_hex(response, zres, 16, 1);

    /* add tail */
    strcpy (response + 32, ""01d0a8e3"");
",1,unused,123,unused,"    av_md5_sum(zres, buf, 64);
    ff_data_to_hex(response, zres, 16, 1);

    /* add tail */
    strcpy (response + 32, ""01d0a8e3"");
",unused,libav-libavformat2Frdt.c
"     */
    if (!strcmp(value, """")) {
        av_log(s, AV_LOG_WARNING, ""AMR fmtp attribute %s had ""
                                  ""nonstandard empty value\n"", attr);
        strcpy(value, ""1"");
",1,unused,153,unused,"     */
    if (!strcmp(value, """")) {
        av_log(s, AV_LOG_WARNING, ""AMR fmtp attribute %s had ""
                                  ""nonstandard empty value\n"", attr);
        strcpy(value, ""1"");
",unused,libav-libavformat2Frtpdec_amr.c
"            continue;
        } else if (!av_strncasecmp(reply->server, ""WMServer/"", 9)) {
            rt->server_type = RTSP_SERVER_WMS;
        } else if (rt->server_type == RTSP_SERVER_REAL)
            strcpy(real_challenge, reply->real_challenge);
",1,unused,1781,unused,"            continue;
        } else if (!av_strncasecmp(reply->server, ""WMServer/"", 9)) {
            rt->server_type = RTSP_SERVER_WMS;
        } else if (rt->server_type == RTSP_SERVER_REAL)
            strcpy(real_challenge, reply->real_challenge);
",unused,libav-libavformat2Frtsp.c
"           av_free(buf);
           return;
        }
    } else if (type == 3 && length == 4) {
        strcpy(buf, avio_rl32(pb) ? ""true"" : ""false"");
",1,unused,514,unused,"           av_free(buf);
           return;
        }
    } else if (type == 3 && length == 4) {
        strcpy(buf, avio_rl32(pb) ? ""true"" : ""false"");
",unused,libav-libavformat2Fwtv.c
"    while (n--)
	histo[getstateflags(caps, n)]++;

    /* blank is not a valid capability set */
    p = sprintf(buf, ""=%s%s%s"",
",1,unused,383,unused,"    while (n--)
	histo[getstateflags(caps, n)]++;

    /* blank is not a valid capability set */
    p = sprintf(buf, ""=%s%s%s"",
",unused,libcap2debian-libcap2Fcap_text.c
"			cap_free(this_cap_name);
			errno = ERANGE;
			return NULL;
		    }
		    p += sprintf(p, ""%s,"", this_cap_name);
",1,unused,401,unused,"			cap_free(this_cap_name);
			errno = ERANGE;
			return NULL;
		    }
		    p += sprintf(p, ""%s,"", this_cap_name);
",unused,libcap2debian-libcap2Fcap_text.c
"		}
	    p--;
	    n = t & ~m;
	    if (n)
		p += sprintf(p, ""+%s%s%s"",
",1,unused,407,unused,"		}
	    p--;
	    n = t & ~m;
	    if (n)
		p += sprintf(p, ""+%s%s%s"",
",unused,libcap2debian-libcap2Fcap_text.c
"			     (n & LIBCAP_INH) ? ""i"" : """",
			     (n & LIBCAP_PER) ? ""p"" : """");
	    n = ~t & m;
	    if (n)
		p += sprintf(p, ""-%s%s%s"",
",1,unused,413,unused,"			     (n & LIBCAP_INH) ? ""i"" : """",
			     (n & LIBCAP_PER) ? ""p"" : """");
	    n = ~t & m;
	    if (n)
		p += sprintf(p, ""-%s%s%s"",
",unused,libcap2debian-libcap2Fcap_text.c
"		perror(""Out of memory for inh set"");
		exit(1);
	    }
	    if (argv[i][6] && strcmp(""none"", argv[i]+6)) {
		sprintf(ptr, ""%s %s+i"", text, argv[i]+6);
",1,unused,160,unused,"		perror(""Out of memory for inh set"");
		exit(1);
	    }
	    if (argv[i][6] && strcmp(""none"", argv[i]+6)) {
		sprintf(ptr, ""%s %s+i"", text, argv[i]+6);
",unused,libcap2debian-progs2Fcapsh.c
"	    }
	    if (argv[i][6] && strcmp(""none"", argv[i]+6)) {
		sprintf(ptr, ""%s %s+i"", text, argv[i]+6);
	    } else {
		strcpy(ptr, text);
",1,unused,162,unused,"	    }
	    if (argv[i][6] && strcmp(""none"", argv[i]+6)) {
		sprintf(ptr, ""%s %s+i"", text, argv[i]+6);
	    } else {
		strcpy(ptr, text);
",unused,libcap2debian-progs2Fcapsh.c
"	return NULL;
    }

    *(raw_data++) = CAP_S_MAGIC;
    strcpy((char *) raw_data, old);
",1,unused,77,unused,"	return NULL;
    }

    *(raw_data++) = CAP_S_MAGIC;
    strcpy((char *) raw_data, old);
",unused,libcap2trusty-libcap2Fcap_alloc.c
"    while (n--)
	histo[getstateflags(caps, n)]++;

    /* blank is not a valid capability set */
    p = sprintf(buf, ""=%s%s%s"",
",1,unused,383,unused,"    while (n--)
	histo[getstateflags(caps, n)]++;

    /* blank is not a valid capability set */
    p = sprintf(buf, ""=%s%s%s"",
",unused,libcap2trusty-libcap2Fcap_text.c
"			cap_free(this_cap_name);
			errno = ERANGE;
			return NULL;
		    }
		    p += sprintf(p, ""%s,"", this_cap_name);
",1,unused,401,unused,"			cap_free(this_cap_name);
			errno = ERANGE;
			return NULL;
		    }
		    p += sprintf(p, ""%s,"", this_cap_name);
",unused,libcap2trusty-libcap2Fcap_text.c
"		}
	    p--;
	    n = t & ~m;
	    if (n)
		p += sprintf(p, ""+%s%s%s"",
",1,unused,407,unused,"		}
	    p--;
	    n = t & ~m;
	    if (n)
		p += sprintf(p, ""+%s%s%s"",
",unused,libcap2trusty-libcap2Fcap_text.c
"			     (n & LIBCAP_INH) ? ""i"" : """",
			     (n & LIBCAP_PER) ? ""p"" : """");
	    n = ~t & m;
	    if (n)
		p += sprintf(p, ""-%s%s%s"",
",1,unused,413,unused,"			     (n & LIBCAP_INH) ? ""i"" : """",
			     (n & LIBCAP_PER) ? ""p"" : """");
	    n = ~t & m;
	    if (n)
		p += sprintf(p, ""-%s%s%s"",
",unused,libcap2trusty-libcap2Fcap_text.c
"	goto cleanup_epcaps;
    }

    if (!strcmp(conf_icaps, ""none"")) {
	sprintf(combined_caps, CAP_DROP_ALL, proc_epcaps);
",1,unused,151,unused,"	goto cleanup_epcaps;
    }

    if (!strcmp(conf_icaps, ""none"")) {
	sprintf(combined_caps, CAP_DROP_ALL, proc_epcaps);
",unused,libcap2trusty-pam_cap2Fpam_cap.c
"    if (!strcmp(conf_icaps, ""none"")) {
	sprintf(combined_caps, CAP_DROP_ALL, proc_epcaps);
    } else if (!strcmp(conf_icaps, ""all"")) {
	/* no change */
	sprintf(combined_caps, ""%s"", proc_epcaps);
",1,unused,154,unused,"    if (!strcmp(conf_icaps, ""none"")) {
	sprintf(combined_caps, CAP_DROP_ALL, proc_epcaps);
    } else if (!strcmp(conf_icaps, ""all"")) {
	/* no change */
	sprintf(combined_caps, ""%s"", proc_epcaps);
",unused,libcap2trusty-pam_cap2Fpam_cap.c
"    } else if (!strcmp(conf_icaps, ""all"")) {
	/* no change */
	sprintf(combined_caps, ""%s"", proc_epcaps);
    } else {
	sprintf(combined_caps, CAP_COMBINED_FORMAT, proc_epcaps, conf_icaps);
",1,unused,156,unused,"    } else if (!strcmp(conf_icaps, ""all"")) {
	/* no change */
	sprintf(combined_caps, ""%s"", proc_epcaps);
    } else {
	sprintf(combined_caps, CAP_COMBINED_FORMAT, proc_epcaps, conf_icaps);
",unused,libcap2trusty-pam_cap2Fpam_cap.c
"		perror(""Out of memory for inh set"");
		exit(1);
	    }
	    if (argv[i][6] && strcmp(""none"", argv[i]+6)) {
		sprintf(ptr, ""%s %s+i"", text, argv[i]+6);
",1,unused,160,unused,"		perror(""Out of memory for inh set"");
		exit(1);
	    }
	    if (argv[i][6] && strcmp(""none"", argv[i]+6)) {
		sprintf(ptr, ""%s %s+i"", text, argv[i]+6);
",unused,libcap2trusty-progs2Fcapsh.c
"	    }
	    if (argv[i][6] && strcmp(""none"", argv[i]+6)) {
		sprintf(ptr, ""%s %s+i"", text, argv[i]+6);
	    } else {
		strcpy(ptr, text);
",1,unused,162,unused,"	    }
	    if (argv[i][6] && strcmp(""none"", argv[i]+6)) {
		sprintf(ptr, ""%s %s+i"", text, argv[i]+6);
	    } else {
		strcpy(ptr, text);
",unused,libcap2trusty-progs2Fcapsh.c
"	return NULL;
    }

    *(raw_data++) = CAP_S_MAGIC;
    strcpy((char *) raw_data, old);
",1,unused,77,unused,"	return NULL;
    }

    *(raw_data++) = CAP_S_MAGIC;
    strcpy((char *) raw_data, old);
",unused,libcap2xenial-libcap2Fcap_alloc.c
"	goto cleanup_epcaps;
    }

    if (!strcmp(conf_icaps, ""none"")) {
	sprintf(combined_caps, CAP_DROP_ALL, proc_epcaps);
",1,unused,151,unused,"	goto cleanup_epcaps;
    }

    if (!strcmp(conf_icaps, ""none"")) {
	sprintf(combined_caps, CAP_DROP_ALL, proc_epcaps);
",unused,libcap2xenial-pam_cap2Fpam_cap.c
"    if (!strcmp(conf_icaps, ""none"")) {
	sprintf(combined_caps, CAP_DROP_ALL, proc_epcaps);
    } else if (!strcmp(conf_icaps, ""all"")) {
	/* no change */
	sprintf(combined_caps, ""%s"", proc_epcaps);
",1,unused,154,unused,"    if (!strcmp(conf_icaps, ""none"")) {
	sprintf(combined_caps, CAP_DROP_ALL, proc_epcaps);
    } else if (!strcmp(conf_icaps, ""all"")) {
	/* no change */
	sprintf(combined_caps, ""%s"", proc_epcaps);
",unused,libcap2xenial-pam_cap2Fpam_cap.c
"    } else if (!strcmp(conf_icaps, ""all"")) {
	/* no change */
	sprintf(combined_caps, ""%s"", proc_epcaps);
    } else {
	sprintf(combined_caps, CAP_COMBINED_FORMAT, proc_epcaps, conf_icaps);
",1,unused,156,unused,"    } else if (!strcmp(conf_icaps, ""all"")) {
	/* no change */
	sprintf(combined_caps, ""%s"", proc_epcaps);
    } else {
	sprintf(combined_caps, CAP_COMBINED_FORMAT, proc_epcaps, conf_icaps);
",unused,libcap2xenial-pam_cap2Fpam_cap.c
"	return NULL;
    }

    *(raw_data++) = CAP_S_MAGIC;
    strcpy((char *) raw_data, old);
",1,unused,77,unused,"	return NULL;
    }

    *(raw_data++) = CAP_S_MAGIC;
    strcpy((char *) raw_data, old);
",unused,libcap2xenpatch-libcap2Fcap_alloc.c
"    while (n--)
	histo[getstateflags(caps, n)]++;

    /* blank is not a valid capability set */
    p = sprintf(buf, ""=%s%s%s"",
",1,unused,383,unused,"    while (n--)
	histo[getstateflags(caps, n)]++;

    /* blank is not a valid capability set */
    p = sprintf(buf, ""=%s%s%s"",
",unused,libcap2xenpatch-libcap2Fcap_text.c
"			cap_free(this_cap_name);
			errno = ERANGE;
			return NULL;
		    }
		    p += sprintf(p, ""%s,"", this_cap_name);
",1,unused,401,unused,"			cap_free(this_cap_name);
			errno = ERANGE;
			return NULL;
		    }
		    p += sprintf(p, ""%s,"", this_cap_name);
",unused,libcap2xenpatch-libcap2Fcap_text.c
"		}
	    p--;
	    n = t & ~m;
	    if (n)
		p += sprintf(p, ""+%s%s%s"",
",1,unused,407,unused,"		}
	    p--;
	    n = t & ~m;
	    if (n)
		p += sprintf(p, ""+%s%s%s"",
",unused,libcap2xenpatch-libcap2Fcap_text.c
"			     (n & LIBCAP_INH) ? ""i"" : """",
			     (n & LIBCAP_PER) ? ""p"" : """");
	    n = ~t & m;
	    if (n)
		p += sprintf(p, ""-%s%s%s"",
",1,unused,413,unused,"			     (n & LIBCAP_INH) ? ""i"" : """",
			     (n & LIBCAP_PER) ? ""p"" : """");
	    n = ~t & m;
	    if (n)
		p += sprintf(p, ""-%s%s%s"",
",unused,libcap2xenpatch-libcap2Fcap_text.c
"	goto cleanup_epcaps;
    }

    if (!strcmp(conf_icaps, ""none"")) {
	sprintf(combined_caps, CAP_DROP_ALL, proc_epcaps);
",1,unused,151,unused,"	goto cleanup_epcaps;
    }

    if (!strcmp(conf_icaps, ""none"")) {
	sprintf(combined_caps, CAP_DROP_ALL, proc_epcaps);
",unused,libcap2xenpatch-pam_cap2Fpam_cap.c
"    if (!strcmp(conf_icaps, ""none"")) {
	sprintf(combined_caps, CAP_DROP_ALL, proc_epcaps);
    } else if (!strcmp(conf_icaps, ""all"")) {
	/* no change */
	sprintf(combined_caps, ""%s"", proc_epcaps);
",1,unused,154,unused,"    if (!strcmp(conf_icaps, ""none"")) {
	sprintf(combined_caps, CAP_DROP_ALL, proc_epcaps);
    } else if (!strcmp(conf_icaps, ""all"")) {
	/* no change */
	sprintf(combined_caps, ""%s"", proc_epcaps);
",unused,libcap2xenpatch-pam_cap2Fpam_cap.c
"    } else if (!strcmp(conf_icaps, ""all"")) {
	/* no change */
	sprintf(combined_caps, ""%s"", proc_epcaps);
    } else {
	sprintf(combined_caps, CAP_COMBINED_FORMAT, proc_epcaps, conf_icaps);
",1,unused,156,unused,"    } else if (!strcmp(conf_icaps, ""all"")) {
	/* no change */
	sprintf(combined_caps, ""%s"", proc_epcaps);
    } else {
	sprintf(combined_caps, CAP_COMBINED_FORMAT, proc_epcaps, conf_icaps);
",unused,libcap2xenpatch-pam_cap2Fpam_cap.c
"		perror(""Out of memory for inh set"");
		exit(1);
	    }
	    if (argv[i][6] && strcmp(""none"", argv[i]+6)) {
		sprintf(ptr, ""%s %s+i"", text, argv[i]+6);
",1,unused,160,unused,"		perror(""Out of memory for inh set"");
		exit(1);
	    }
	    if (argv[i][6] && strcmp(""none"", argv[i]+6)) {
		sprintf(ptr, ""%s %s+i"", text, argv[i]+6);
",unused,libcap2xenpatch-progs2Fcapsh.c
"	    }
	    if (argv[i][6] && strcmp(""none"", argv[i]+6)) {
		sprintf(ptr, ""%s %s+i"", text, argv[i]+6);
	    } else {
		strcpy(ptr, text);
",1,unused,162,unused,"	    }
	    if (argv[i][6] && strcmp(""none"", argv[i]+6)) {
		sprintf(ptr, ""%s %s+i"", text, argv[i]+6);
	    } else {
		strcpy(ptr, text);
",unused,libcap2xenpatch-progs2Fcapsh.c
"  ** Copy alarm code into send buffer and pad it with blanks upto ALMNUM_SIZE
  ** characters
  */

  strcpy(sndbuf.msgtxt, alarm_code);
",1,unused,247,unused,"  ** Copy alarm code into send buffer and pad it with blanks upto ALMNUM_SIZE
  ** characters
  */

  strcpy(sndbuf.msgtxt, alarm_code);
",unused,libcsa-libcsa-7B712035-8DD0-43A2-A4A8-6AD7B227CBA9-lib_alarm_msg.c
"
  /* Use 'format' to process rest of arguments into send buffer */
  vsprintf(&sndbuf.msgtxt[ALMNUM_SIZE-1], format, args);

  sprintf(msg.msgtxt, ""%+010d%+010d%s"", whscde, intalm, sndbuf.msgtxt); 
",1,unused,254,unused,"
  /* Use 'format' to process rest of arguments into send buffer */
  vsprintf(&sndbuf.msgtxt[ALMNUM_SIZE-1], format, args);

  sprintf(msg.msgtxt, ""%+010d%+010d%s"", whscde, intalm, sndbuf.msgtxt); 
",unused,libcsa-libcsa-7B712035-8DD0-43A2-A4A8-6AD7B227CBA9-lib_alarm_msg.c
"static char id [40];

  /* All process SQL error mestxt.almnum'stest have a 6 character process name,
    so truncate to 6 (e.g rdtusr0372 > rdtusr) */
  sprintf (id, ""%6.6s.01"", prcnam);
",1,unused,296,unused,"static char id [40];

  /* All process SQL error mestxt.almnum'stest have a 6 character process name,
    so truncate to 6 (e.g rdtusr0372 > rdtusr) */
  sprintf (id, ""%6.6s.01"", prcnam);
",unused,libcsa-libcsa-7B712035-8DD0-43A2-A4A8-6AD7B227CBA9-lib_alarm_msg.c
"  /* Use 'format' to process arguments into send buffer */
  vsprintf(sndbuf.msgtxt, format, args);


  sprintf (msg.msgtxt,""%+10.9d%-*.*s%-*.*s%-*.*s"", 
",1,unused,350,unused,"  /* Use 'format' to process arguments into send buffer */
  vsprintf(sndbuf.msgtxt, format, args);


  sprintf (msg.msgtxt,""%+10.9d%-*.*s%-*.*s%-*.*s"", 
",unused,libcsa-libcsa-7B712035-8DD0-43A2-A4A8-6AD7B227CBA9-lib_alarm_msg.c
"  while (len && (bptr - buffer) < 500) 
  {
    switch (*buf) 
    {
    case 0: sprintf (bptr, ""<NUL>""); break;
",1,unused,57,unused,"  while (len && (bptr - buffer) < 500) 
  {
    switch (*buf) 
    {
    case 0: sprintf (bptr, ""<NUL>""); break;
",unused,libcsa-libcsa-7B712035-8DD0-43A2-A4A8-6AD7B227CBA9-lib_bufprint.c
"  {
    switch (*buf) 
    {
    case 0: sprintf (bptr, ""<NUL>""); break;
    case 1: sprintf (bptr, ""<SOH>""); break;
",1,unused,58,unused,"  {
    switch (*buf) 
    {
    case 0: sprintf (bptr, ""<NUL>""); break;
    case 1: sprintf (bptr, ""<SOH>""); break;
",unused,libcsa-libcsa-7B712035-8DD0-43A2-A4A8-6AD7B227CBA9-lib_bufprint.c
"    switch (*buf) 
    {
    case 0: sprintf (bptr, ""<NUL>""); break;
    case 1: sprintf (bptr, ""<SOH>""); break;
    case 2: sprintf (bptr, ""<STX>""); break;
",1,unused,59,unused,"    switch (*buf) 
    {
    case 0: sprintf (bptr, ""<NUL>""); break;
    case 1: sprintf (bptr, ""<SOH>""); break;
    case 2: sprintf (bptr, ""<STX>""); break;
",unused,libcsa-libcsa-7B712035-8DD0-43A2-A4A8-6AD7B227CBA9-lib_bufprint.c
"    {
    case 0: sprintf (bptr, ""<NUL>""); break;
    case 1: sprintf (bptr, ""<SOH>""); break;
    case 2: sprintf (bptr, ""<STX>""); break;
    case 3: sprintf (bptr, ""<ETX>""); break;
",1,unused,60,unused,"    {
    case 0: sprintf (bptr, ""<NUL>""); break;
    case 1: sprintf (bptr, ""<SOH>""); break;
    case 2: sprintf (bptr, ""<STX>""); break;
    case 3: sprintf (bptr, ""<ETX>""); break;
",unused,libcsa-libcsa-7B712035-8DD0-43A2-A4A8-6AD7B227CBA9-lib_bufprint.c
"    case 0: sprintf (bptr, ""<NUL>""); break;
    case 1: sprintf (bptr, ""<SOH>""); break;
    case 2: sprintf (bptr, ""<STX>""); break;
    case 3: sprintf (bptr, ""<ETX>""); break;
    case 4: sprintf (bptr, ""<EOT>""); break;
",1,unused,61,unused,"    case 0: sprintf (bptr, ""<NUL>""); break;
    case 1: sprintf (bptr, ""<SOH>""); break;
    case 2: sprintf (bptr, ""<STX>""); break;
    case 3: sprintf (bptr, ""<ETX>""); break;
    case 4: sprintf (bptr, ""<EOT>""); break;
",unused,libcsa-libcsa-7B712035-8DD0-43A2-A4A8-6AD7B227CBA9-lib_bufprint.c
"    case 1: sprintf (bptr, ""<SOH>""); break;
    case 2: sprintf (bptr, ""<STX>""); break;
    case 3: sprintf (bptr, ""<ETX>""); break;
    case 4: sprintf (bptr, ""<EOT>""); break;
    case 5: sprintf (bptr, ""<ENQ>""); break;
",1,unused,62,unused,"    case 1: sprintf (bptr, ""<SOH>""); break;
    case 2: sprintf (bptr, ""<STX>""); break;
    case 3: sprintf (bptr, ""<ETX>""); break;
    case 4: sprintf (bptr, ""<EOT>""); break;
    case 5: sprintf (bptr, ""<ENQ>""); break;
",unused,libcsa-libcsa-7B712035-8DD0-43A2-A4A8-6AD7B227CBA9-lib_bufprint.c
"    case 2: sprintf (bptr, ""<STX>""); break;
    case 3: sprintf (bptr, ""<ETX>""); break;
    case 4: sprintf (bptr, ""<EOT>""); break;
    case 5: sprintf (bptr, ""<ENQ>""); break;
    case 6: sprintf (bptr, ""<ACK>""); break;
",1,unused,63,unused,"    case 2: sprintf (bptr, ""<STX>""); break;
    case 3: sprintf (bptr, ""<ETX>""); break;
    case 4: sprintf (bptr, ""<EOT>""); break;
    case 5: sprintf (bptr, ""<ENQ>""); break;
    case 6: sprintf (bptr, ""<ACK>""); break;
",unused,libcsa-libcsa-7B712035-8DD0-43A2-A4A8-6AD7B227CBA9-lib_bufprint.c
"    case 3: sprintf (bptr, ""<ETX>""); break;
    case 4: sprintf (bptr, ""<EOT>""); break;
    case 5: sprintf (bptr, ""<ENQ>""); break;
    case 6: sprintf (bptr, ""<ACK>""); break;
    case 7: sprintf (bptr, ""<BEL>""); break;
",1,unused,64,unused,"    case 3: sprintf (bptr, ""<ETX>""); break;
    case 4: sprintf (bptr, ""<EOT>""); break;
    case 5: sprintf (bptr, ""<ENQ>""); break;
    case 6: sprintf (bptr, ""<ACK>""); break;
    case 7: sprintf (bptr, ""<BEL>""); break;
",unused,libcsa-libcsa-7B712035-8DD0-43A2-A4A8-6AD7B227CBA9-lib_bufprint.c
"    case 4: sprintf (bptr, ""<EOT>""); break;
    case 5: sprintf (bptr, ""<ENQ>""); break;
    case 6: sprintf (bptr, ""<ACK>""); break;
    case 7: sprintf (bptr, ""<BEL>""); break;
    case 9: sprintf (bptr, ""<HT >""); break;
",1,unused,65,unused,"    case 4: sprintf (bptr, ""<EOT>""); break;
    case 5: sprintf (bptr, ""<ENQ>""); break;
    case 6: sprintf (bptr, ""<ACK>""); break;
    case 7: sprintf (bptr, ""<BEL>""); break;
    case 9: sprintf (bptr, ""<HT >""); break;
",unused,libcsa-libcsa-7B712035-8DD0-43A2-A4A8-6AD7B227CBA9-lib_bufprint.c
"    case 5: sprintf (bptr, ""<ENQ>""); break;
    case 6: sprintf (bptr, ""<ACK>""); break;
    case 7: sprintf (bptr, ""<BEL>""); break;
    case 9: sprintf (bptr, ""<HT >""); break;
    case 10: sprintf (bptr, ""<NL >""); break;
",1,unused,66,unused,"    case 5: sprintf (bptr, ""<ENQ>""); break;
    case 6: sprintf (bptr, ""<ACK>""); break;
    case 7: sprintf (bptr, ""<BEL>""); break;
    case 9: sprintf (bptr, ""<HT >""); break;
    case 10: sprintf (bptr, ""<NL >""); break;
",unused,libcsa-libcsa-7B712035-8DD0-43A2-A4A8-6AD7B227CBA9-lib_bufprint.c
"    case 6: sprintf (bptr, ""<ACK>""); break;
    case 7: sprintf (bptr, ""<BEL>""); break;
    case 9: sprintf (bptr, ""<HT >""); break;
    case 10: sprintf (bptr, ""<NL >""); break;
    case 11: sprintf (bptr, ""<VT >""); break;
",1,unused,67,unused,"    case 6: sprintf (bptr, ""<ACK>""); break;
    case 7: sprintf (bptr, ""<BEL>""); break;
    case 9: sprintf (bptr, ""<HT >""); break;
    case 10: sprintf (bptr, ""<NL >""); break;
    case 11: sprintf (bptr, ""<VT >""); break;
",unused,libcsa-libcsa-7B712035-8DD0-43A2-A4A8-6AD7B227CBA9-lib_bufprint.c
"    case 7: sprintf (bptr, ""<BEL>""); break;
    case 9: sprintf (bptr, ""<HT >""); break;
    case 10: sprintf (bptr, ""<NL >""); break;
    case 11: sprintf (bptr, ""<VT >""); break;
    case 13: sprintf (bptr, ""<CR >""); break;
",1,unused,68,unused,"    case 7: sprintf (bptr, ""<BEL>""); break;
    case 9: sprintf (bptr, ""<HT >""); break;
    case 10: sprintf (bptr, ""<NL >""); break;
    case 11: sprintf (bptr, ""<VT >""); break;
    case 13: sprintf (bptr, ""<CR >""); break;
",unused,libcsa-libcsa-7B712035-8DD0-43A2-A4A8-6AD7B227CBA9-lib_bufprint.c
"    case 9: sprintf (bptr, ""<HT >""); break;
    case 10: sprintf (bptr, ""<NL >""); break;
    case 11: sprintf (bptr, ""<VT >""); break;
    case 13: sprintf (bptr, ""<CR >""); break;
    case 16: sprintf (bptr, ""<DLE>""); break;
",1,unused,69,unused,"    case 9: sprintf (bptr, ""<HT >""); break;
    case 10: sprintf (bptr, ""<NL >""); break;
    case 11: sprintf (bptr, ""<VT >""); break;
    case 13: sprintf (bptr, ""<CR >""); break;
    case 16: sprintf (bptr, ""<DLE>""); break;
",unused,libcsa-libcsa-7B712035-8DD0-43A2-A4A8-6AD7B227CBA9-lib_bufprint.c
"    case 10: sprintf (bptr, ""<NL >""); break;
    case 11: sprintf (bptr, ""<VT >""); break;
    case 13: sprintf (bptr, ""<CR >""); break;
    case 16: sprintf (bptr, ""<DLE>""); break;
    case 21: sprintf (bptr, ""<NAK>""); break;
",1,unused,70,unused,"    case 10: sprintf (bptr, ""<NL >""); break;
    case 11: sprintf (bptr, ""<VT >""); break;
    case 13: sprintf (bptr, ""<CR >""); break;
    case 16: sprintf (bptr, ""<DLE>""); break;
    case 21: sprintf (bptr, ""<NAK>""); break;
",unused,libcsa-libcsa-7B712035-8DD0-43A2-A4A8-6AD7B227CBA9-lib_bufprint.c
"    case 11: sprintf (bptr, ""<VT >""); break;
    case 13: sprintf (bptr, ""<CR >""); break;
    case 16: sprintf (bptr, ""<DLE>""); break;
    case 21: sprintf (bptr, ""<NAK>""); break;
    case 27: sprintf (bptr, ""<ESC>""); break;
",1,unused,71,unused,"    case 11: sprintf (bptr, ""<VT >""); break;
    case 13: sprintf (bptr, ""<CR >""); break;
    case 16: sprintf (bptr, ""<DLE>""); break;
    case 21: sprintf (bptr, ""<NAK>""); break;
    case 27: sprintf (bptr, ""<ESC>""); break;
",unused,libcsa-libcsa-7B712035-8DD0-43A2-A4A8-6AD7B227CBA9-lib_bufprint.c
"    case 13: sprintf (bptr, ""<CR >""); break;
    case 16: sprintf (bptr, ""<DLE>""); break;
    case 21: sprintf (bptr, ""<NAK>""); break;
    case 27: sprintf (bptr, ""<ESC>""); break;
    case 30: sprintf (bptr, ""<RS >""); break;
",1,unused,72,unused,"    case 13: sprintf (bptr, ""<CR >""); break;
    case 16: sprintf (bptr, ""<DLE>""); break;
    case 21: sprintf (bptr, ""<NAK>""); break;
    case 27: sprintf (bptr, ""<ESC>""); break;
    case 30: sprintf (bptr, ""<RS >""); break;
",unused,libcsa-libcsa-7B712035-8DD0-43A2-A4A8-6AD7B227CBA9-lib_bufprint.c
"    case 16: sprintf (bptr, ""<DLE>""); break;
    case 21: sprintf (bptr, ""<NAK>""); break;
    case 27: sprintf (bptr, ""<ESC>""); break;
    case 30: sprintf (bptr, ""<RS >""); break;
    case 127: sprintf (bptr, ""<DEL>""); break;
",1,unused,73,unused,"    case 16: sprintf (bptr, ""<DLE>""); break;
    case 21: sprintf (bptr, ""<NAK>""); break;
    case 27: sprintf (bptr, ""<ESC>""); break;
    case 30: sprintf (bptr, ""<RS >""); break;
    case 127: sprintf (bptr, ""<DEL>""); break;
",unused,libcsa-libcsa-7B712035-8DD0-43A2-A4A8-6AD7B227CBA9-lib_bufprint.c
"    case 30: sprintf (bptr, ""<RS >""); break;
    case 127: sprintf (bptr, ""<DEL>""); break;
    default:
      if (*buf < ' ' || *buf >= 128)
        sprintf (bptr, ""<x%02X>"", *buf);
",1,unused,76,unused,"    case 30: sprintf (bptr, ""<RS >""); break;
    case 127: sprintf (bptr, ""<DEL>""); break;
    default:
      if (*buf < ' ' || *buf >= 128)
        sprintf (bptr, ""<x%02X>"", *buf);
",unused,libcsa-libcsa-7B712035-8DD0-43A2-A4A8-6AD7B227CBA9-lib_bufprint.c
"      if (*buf < ' ' || *buf >= 128)
        sprintf (bptr, ""<x%02X>"", *buf);
      else
      {
        sprintf (bptr, ""%c"", *buf);
",1,unused,79,unused,"      if (*buf < ' ' || *buf >= 128)
        sprintf (bptr, ""<x%02X>"", *buf);
      else
      {
        sprintf (bptr, ""%c"", *buf);
",unused,libcsa-libcsa-7B712035-8DD0-43A2-A4A8-6AD7B227CBA9-lib_bufprint.c
"    if (env_var == NULL || strlen(lib_rtrim(env_var)) == 0)
    {
      /* Standard system password.  Does this need further control? */
      obfuscate(stdpw, sizeof(stdpw)-1);
      strcpy(passwd, (char*)stdpw);
",1,unused,182,unused,"    if (env_var == NULL || strlen(lib_rtrim(env_var)) == 0)
    {
      /* Standard system password.  Does this need further control? */
      obfuscate(stdpw, sizeof(stdpw)-1);
      strcpy(passwd, (char*)stdpw);
",unused,libcsa-libcsa-7B712035-8DD0-43A2-A4A8-6AD7B227CBA9-lib_crypt.c
"      strcpy(passwd, (char*)stdpw);
    }
    else
    {
      strcpy(passwd, env_var);
",1,unused,186,unused,"      strcpy(passwd, (char*)stdpw);
    }
    else
    {
      strcpy(passwd, env_var);
",unused,libcsa-libcsa-7B712035-8DD0-43A2-A4A8-6AD7B227CBA9-lib_crypt.c
"    if (env_var == NULL || strlen(lib_rtrim(env_var)) == 0)
    {
      /* Standard system password.  Does this need further control? */
      obfuscate(stdpw, sizeof(stdpw)-1);
      strcpy(passwd, (char*)stdpw);
",1,unused,197,unused,"    if (env_var == NULL || strlen(lib_rtrim(env_var)) == 0)
    {
      /* Standard system password.  Does this need further control? */
      obfuscate(stdpw, sizeof(stdpw)-1);
      strcpy(passwd, (char*)stdpw);
",unused,libcsa-libcsa-7B712035-8DD0-43A2-A4A8-6AD7B227CBA9-lib_crypt.c
"      strcpy(passwd, (char*)stdpw);
    }
    else
    {
      strcpy(passwd, env_var);
",1,unused,201,unused,"      strcpy(passwd, (char*)stdpw);
    }
    else
    {
      strcpy(passwd, env_var);
",unused,libcsa-libcsa-7B712035-8DD0-43A2-A4A8-6AD7B227CBA9-lib_crypt.c
"    if (env_var == NULL || strlen(lib_rtrim(env_var)) == 0)
    {
      /* Standard sys password.  Does this need further control? */
      obfuscate(stdpw, sizeof(stdpw)-1);
      strcpy(passwd, (char*)stdpw);
",1,unused,212,unused,"    if (env_var == NULL || strlen(lib_rtrim(env_var)) == 0)
    {
      /* Standard sys password.  Does this need further control? */
      obfuscate(stdpw, sizeof(stdpw)-1);
      strcpy(passwd, (char*)stdpw);
",unused,libcsa-libcsa-7B712035-8DD0-43A2-A4A8-6AD7B227CBA9-lib_crypt.c
"      strcpy(passwd, (char*)stdpw);
    }
    else
    {
      strcpy(passwd, env_var);
",1,unused,216,unused,"      strcpy(passwd, (char*)stdpw);
    }
    else
    {
      strcpy(passwd, env_var);
",unused,libcsa-libcsa-7B712035-8DD0-43A2-A4A8-6AD7B227CBA9-lib_crypt.c
"    //Bug 2004 Dev: Database Username needs to be case insensitive
    char hash_uname[60] = """";
    char *sPtr = NULL;

    strcpy(hash_uname, db_uname);
",1,unused,325,unused,"    //Bug 2004 Dev: Database Username needs to be case insensitive
    char hash_uname[60] = """";
    char *sPtr = NULL;

    strcpy(hash_uname, db_uname);
",unused,libcsa-libcsa-7B712035-8DD0-43A2-A4A8-6AD7B227CBA9-lib_crypt.c
"
  buf[0] = tolower(b_ptr[4]);
  buf[1] = b_ptr[5];
  buf[2] = b_ptr[6];
  sprintf(&buf[3],""%2.2d"",atoi(&b_ptr[8]));
",1,unused,87,unused,"
  buf[0] = tolower(b_ptr[4]);
  buf[1] = b_ptr[5];
  buf[2] = b_ptr[6];
  sprintf(&buf[3],""%2.2d"",atoi(&b_ptr[8]));
",unused,libcsa-libcsa-7B712035-8DD0-43A2-A4A8-6AD7B227CBA9-lib_date.c
"	char l_mm[3] = """";
	char l_dd[3] = """";


	strcpy(l_mm, get_date_MM(p_dattim));
",1,unused,103,unused,"	char l_mm[3] = """";
	char l_dd[3] = """";


	strcpy(l_mm, get_date_MM(p_dattim));
",unused,libcsa-libcsa-7B712035-8DD0-43A2-A4A8-6AD7B227CBA9-lib_date.c
"	char l_dd[3] = """";


	strcpy(l_mm, get_date_MM(p_dattim));
	strcpy(l_dd, get_date_DD(p_dattim));
",1,unused,104,unused,"	char l_dd[3] = """";


	strcpy(l_mm, get_date_MM(p_dattim));
	strcpy(l_dd, get_date_DD(p_dattim));
",unused,libcsa-libcsa-7B712035-8DD0-43A2-A4A8-6AD7B227CBA9-lib_date.c
"
	strcpy(l_mm, get_date_MM(p_dattim));
	strcpy(l_dd, get_date_DD(p_dattim));

	sprintf(date_YYYYMMDD_str, ""%4.4s%2.2s%2.2s"",
",1,unused,106,unused,"
	strcpy(l_mm, get_date_MM(p_dattim));
	strcpy(l_dd, get_date_DD(p_dattim));

	sprintf(date_YYYYMMDD_str, ""%4.4s%2.2s%2.2s"",
",unused,libcsa-libcsa-7B712035-8DD0-43A2-A4A8-6AD7B227CBA9-lib_date.c
"	char l_mi[3] = """";
	char l_ss[3] = """";


	strcpy(l_h2, get_date_H2(p_dattim));
",1,unused,125,unused,"	char l_mi[3] = """";
	char l_ss[3] = """";


	strcpy(l_h2, get_date_H2(p_dattim));
",unused,libcsa-libcsa-7B712035-8DD0-43A2-A4A8-6AD7B227CBA9-lib_date.c
"	char l_ss[3] = """";


	strcpy(l_h2, get_date_H2(p_dattim));
	strcpy(l_mi, get_date_MI(p_dattim));
",1,unused,126,unused,"	char l_ss[3] = """";


	strcpy(l_h2, get_date_H2(p_dattim));
	strcpy(l_mi, get_date_MI(p_dattim));
",unused,libcsa-libcsa-7B712035-8DD0-43A2-A4A8-6AD7B227CBA9-lib_date.c
"

	strcpy(l_h2, get_date_H2(p_dattim));
	strcpy(l_mi, get_date_MI(p_dattim));
	strcpy(l_ss, get_date_SS(p_dattim));
",1,unused,127,unused,"

	strcpy(l_h2, get_date_H2(p_dattim));
	strcpy(l_mi, get_date_MI(p_dattim));
	strcpy(l_ss, get_date_SS(p_dattim));
",unused,libcsa-libcsa-7B712035-8DD0-43A2-A4A8-6AD7B227CBA9-lib_date.c
"	strcpy(l_h2, get_date_H2(p_dattim));
	strcpy(l_mi, get_date_MI(p_dattim));
	strcpy(l_ss, get_date_SS(p_dattim));

	sprintf(time_HHMMSS_str, ""%2.2s%2.2s%2.2s"", l_h2, l_mi, l_ss);
",1,unused,129,unused,"	strcpy(l_h2, get_date_H2(p_dattim));
	strcpy(l_mi, get_date_MI(p_dattim));
	strcpy(l_ss, get_date_SS(p_dattim));

	sprintf(time_HHMMSS_str, ""%2.2s%2.2s%2.2s"", l_h2, l_mi, l_ss);
",unused,libcsa-libcsa-7B712035-8DD0-43A2-A4A8-6AD7B227CBA9-lib_date.c
"	l_mon[3] = '\0';

	if (0 == strcmp(l_mon, ""Jan""))
	{
		strcpy(l_mm, ""01"");
",1,unused,185,unused,"	l_mon[3] = '\0';

	if (0 == strcmp(l_mon, ""Jan""))
	{
		strcpy(l_mm, ""01"");
",unused,libcsa-libcsa-7B712035-8DD0-43A2-A4A8-6AD7B227CBA9-lib_date.c
"		strcpy(l_mm, ""01"");
	}
	else if (0 == strcmp(l_mon, ""Feb""))
	{
		strcpy(l_mm, ""02"");
",1,unused,189,unused,"		strcpy(l_mm, ""01"");
	}
	else if (0 == strcmp(l_mon, ""Feb""))
	{
		strcpy(l_mm, ""02"");
",unused,libcsa-libcsa-7B712035-8DD0-43A2-A4A8-6AD7B227CBA9-lib_date.c
"		strcpy(l_mm, ""02"");
	}
	else if (0 == strcmp(l_mon, ""Mar""))
	{
		strcpy(l_mm, ""03"");
",1,unused,193,unused,"		strcpy(l_mm, ""02"");
	}
	else if (0 == strcmp(l_mon, ""Mar""))
	{
		strcpy(l_mm, ""03"");
",unused,libcsa-libcsa-7B712035-8DD0-43A2-A4A8-6AD7B227CBA9-lib_date.c
"		strcpy(l_mm, ""03"");
	}
	else if (0 == strcmp(l_mon, ""Apr""))
	{
		strcpy(l_mm, ""04"");
",1,unused,197,unused,"		strcpy(l_mm, ""03"");
	}
	else if (0 == strcmp(l_mon, ""Apr""))
	{
		strcpy(l_mm, ""04"");
",unused,libcsa-libcsa-7B712035-8DD0-43A2-A4A8-6AD7B227CBA9-lib_date.c
"		strcpy(l_mm, ""04"");
	}
	else if (0 == strcmp(l_mon, ""May""))
	{
		strcpy(l_mm, ""05"");
",1,unused,201,unused,"		strcpy(l_mm, ""04"");
	}
	else if (0 == strcmp(l_mon, ""May""))
	{
		strcpy(l_mm, ""05"");
",unused,libcsa-libcsa-7B712035-8DD0-43A2-A4A8-6AD7B227CBA9-lib_date.c
"		strcpy(l_mm, ""05"");
	}
	else if (0 == strcmp(l_mon, ""Jun""))
	{
		strcpy(l_mm, ""06"");
",1,unused,205,unused,"		strcpy(l_mm, ""05"");
	}
	else if (0 == strcmp(l_mon, ""Jun""))
	{
		strcpy(l_mm, ""06"");
",unused,libcsa-libcsa-7B712035-8DD0-43A2-A4A8-6AD7B227CBA9-lib_date.c
"		strcpy(l_mm, ""06"");
	}
	else if (0 == strcmp(l_mon, ""Jul""))
	{
		strcpy(l_mm, ""07"");
",1,unused,209,unused,"		strcpy(l_mm, ""06"");
	}
	else if (0 == strcmp(l_mon, ""Jul""))
	{
		strcpy(l_mm, ""07"");
",unused,libcsa-libcsa-7B712035-8DD0-43A2-A4A8-6AD7B227CBA9-lib_date.c
"		strcpy(l_mm, ""07"");
	}
	else if (0 == strcmp(l_mon, ""Aug""))
	{
		strcpy(l_mm, ""08"");
",1,unused,213,unused,"		strcpy(l_mm, ""07"");
	}
	else if (0 == strcmp(l_mon, ""Aug""))
	{
		strcpy(l_mm, ""08"");
",unused,libcsa-libcsa-7B712035-8DD0-43A2-A4A8-6AD7B227CBA9-lib_date.c
"		strcpy(l_mm, ""08"");
	}
	else if (0 == strcmp(l_mon, ""Sep""))
	{
		strcpy(l_mm, ""09"");
",1,unused,217,unused,"		strcpy(l_mm, ""08"");
	}
	else if (0 == strcmp(l_mon, ""Sep""))
	{
		strcpy(l_mm, ""09"");
",unused,libcsa-libcsa-7B712035-8DD0-43A2-A4A8-6AD7B227CBA9-lib_date.c
"		strcpy(l_mm, ""09"");
	}
	else if (0 == strcmp(l_mon, ""Oct""))
	{
		strcpy(l_mm, ""10"");
",1,unused,221,unused,"		strcpy(l_mm, ""09"");
	}
	else if (0 == strcmp(l_mon, ""Oct""))
	{
		strcpy(l_mm, ""10"");
",unused,libcsa-libcsa-7B712035-8DD0-43A2-A4A8-6AD7B227CBA9-lib_date.c
"		strcpy(l_mm, ""10"");
	}
	else if (0 == strcmp(l_mon, ""Nov""))
	{
		strcpy(l_mm, ""11"");
",1,unused,225,unused,"		strcpy(l_mm, ""10"");
	}
	else if (0 == strcmp(l_mon, ""Nov""))
	{
		strcpy(l_mm, ""11"");
",unused,libcsa-libcsa-7B712035-8DD0-43A2-A4A8-6AD7B227CBA9-lib_date.c
"		strcpy(l_mm, ""11"");
	}
	else if (0 == strcmp(l_mon, ""Dec""))
	{
		strcpy(l_mm, ""12"");
",1,unused,229,unused,"		strcpy(l_mm, ""11"");
	}
	else if (0 == strcmp(l_mon, ""Dec""))
	{
		strcpy(l_mm, ""12"");
",unused,libcsa-libcsa-7B712035-8DD0-43A2-A4A8-6AD7B227CBA9-lib_date.c
"		strcpy(l_mm, ""12"");
	}
	else
	{
		strcpy(l_mm, ""00"");
",1,unused,233,unused,"		strcpy(l_mm, ""12"");
	}
	else
	{
		strcpy(l_mm, ""00"");
",unused,libcsa-libcsa-7B712035-8DD0-43A2-A4A8-6AD7B227CBA9-lib_date.c
"	char l_char_dd[3] = """";
	static char l_dd[3] = """";


	sprintf(l_char_dd, ""%2.2s"", p_dattim + 8);
",1,unused,269,unused,"	char l_char_dd[3] = """";
	static char l_dd[3] = """";


	sprintf(l_char_dd, ""%2.2s"", p_dattim + 8);
",unused,libcsa-libcsa-7B712035-8DD0-43A2-A4A8-6AD7B227CBA9-lib_date.c
"

	sprintf(l_char_dd, ""%2.2s"", p_dattim + 8);
	l_char_dd[2] = '\0';
	sprintf(l_dd, ""%.2d"", atoi(l_char_dd));
",1,unused,271,unused,"

	sprintf(l_char_dd, ""%2.2s"", p_dattim + 8);
	l_char_dd[2] = '\0';
	sprintf(l_dd, ""%.2d"", atoi(l_char_dd));
",unused,libcsa-libcsa-7B712035-8DD0-43A2-A4A8-6AD7B227CBA9-lib_date.c
"	l_int_h1 = atoi(l_char_h1);

	if (0 == l_int_h1)
	{
		strcpy(l_h1, ""12"");
",1,unused,312,unused,"	l_int_h1 = atoi(l_char_h1);

	if (0 == l_int_h1)
	{
		strcpy(l_h1, ""12"");
",unused,libcsa-libcsa-7B712035-8DD0-43A2-A4A8-6AD7B227CBA9-lib_date.c
"		strcpy(l_h1, ""12"");
	}
	else if ((l_int_h1 > 0) && (l_int_h1 < 12))
	{
		sprintf(l_h1, ""%2.2s"", l_char_h1);
",1,unused,316,unused,"		strcpy(l_h1, ""12"");
	}
	else if ((l_int_h1 > 0) && (l_int_h1 < 12))
	{
		sprintf(l_h1, ""%2.2s"", l_char_h1);
",unused,libcsa-libcsa-7B712035-8DD0-43A2-A4A8-6AD7B227CBA9-lib_date.c
"		sprintf(l_h1, ""%2.2s"", l_char_h1);
	}
	else if (12 == l_int_h1)
	{
		strcpy(l_h1, ""12"");
",1,unused,320,unused,"		sprintf(l_h1, ""%2.2s"", l_char_h1);
	}
	else if (12 == l_int_h1)
	{
		strcpy(l_h1, ""12"");
",unused,libcsa-libcsa-7B712035-8DD0-43A2-A4A8-6AD7B227CBA9-lib_date.c
"		strcpy(l_h1, ""12"");
	}
	else
	{
		sprintf(l_h1, ""%.2d"", (l_int_h1 - 12));
",1,unused,324,unused,"		strcpy(l_h1, ""12"");
	}
	else
	{
		sprintf(l_h1, ""%.2d"", (l_int_h1 - 12));
",unused,libcsa-libcsa-7B712035-8DD0-43A2-A4A8-6AD7B227CBA9-lib_date.c
"	l_int_h1 = atoi(l_char_h1);

	if (0 == l_int_h1)
	{
		strcpy(l_ampm, ""AM"");
",1,unused,401,unused,"	l_int_h1 = atoi(l_char_h1);

	if (0 == l_int_h1)
	{
		strcpy(l_ampm, ""AM"");
",unused,libcsa-libcsa-7B712035-8DD0-43A2-A4A8-6AD7B227CBA9-lib_date.c
"		strcpy(l_ampm, ""AM"");
	}
	else if ((l_int_h1 > 0) && (l_int_h1 < 12))
	{
		strcpy(l_ampm, ""AM"");
",1,unused,405,unused,"		strcpy(l_ampm, ""AM"");
	}
	else if ((l_int_h1 > 0) && (l_int_h1 < 12))
	{
		strcpy(l_ampm, ""AM"");
",unused,libcsa-libcsa-7B712035-8DD0-43A2-A4A8-6AD7B227CBA9-lib_date.c
"		strcpy(l_ampm, ""AM"");
	}
	else if (12 == l_int_h1)
	{
		strcpy(l_ampm, ""PM"");
",1,unused,409,unused,"		strcpy(l_ampm, ""AM"");
	}
	else if (12 == l_int_h1)
	{
		strcpy(l_ampm, ""PM"");
",unused,libcsa-libcsa-7B712035-8DD0-43A2-A4A8-6AD7B227CBA9-lib_date.c
"		strcpy(l_ampm, ""PM"");
	}
	else
	{
		strcpy(l_ampm, ""PM"");
",1,unused,413,unused,"		strcpy(l_ampm, ""PM"");
	}
	else
	{
		strcpy(l_ampm, ""PM"");
",unused,libcsa-libcsa-7B712035-8DD0-43A2-A4A8-6AD7B227CBA9-lib_date.c
"/* Set not found values on first barcode */

  if (num_bcode == 1)
  {
    strcpy(sscc,"""");
",1,unused,152,unused,"/* Set not found values on first barcode */

  if (num_bcode == 1)
  {
    strcpy(sscc,"""");
",unused,libcsa-libcsa-7B712035-8DD0-43A2-A4A8-6AD7B227CBA9-lib_decode_ean.c
"    strcpy(sscc,"""");
    size_item = sizeof(item);
    memset(item, 0, size_item);
    *cases = 0;
    strcpy(bbdate,"""");
",1,unused,156,unused,"    strcpy(sscc,"""");
    size_item = sizeof(item);
    memset(item, 0, size_item);
    *cases = 0;
    strcpy(bbdate,"""");
",unused,libcsa-libcsa-7B712035-8DD0-43A2-A4A8-6AD7B227CBA9-lib_decode_ean.c
"    size_item = sizeof(item);
    memset(item, 0, size_item);
    *cases = 0;
    strcpy(bbdate,"""");
    strcpy(copdat,"""");
",1,unused,157,unused,"    size_item = sizeof(item);
    memset(item, 0, size_item);
    *cases = 0;
    strcpy(bbdate,"""");
    strcpy(copdat,"""");
",unused,libcsa-libcsa-7B712035-8DD0-43A2-A4A8-6AD7B227CBA9-lib_decode_ean.c
"    memset(item, 0, size_item);
    *cases = 0;
    strcpy(bbdate,"""");
    strcpy(copdat,"""");
    strcpy(prddat,"""");
",1,unused,158,unused,"    memset(item, 0, size_item);
    *cases = 0;
    strcpy(bbdate,"""");
    strcpy(copdat,"""");
    strcpy(prddat,"""");
",unused,libcsa-libcsa-7B712035-8DD0-43A2-A4A8-6AD7B227CBA9-lib_decode_ean.c
"    *cases = 0;
    strcpy(bbdate,"""");
    strcpy(copdat,"""");
    strcpy(prddat,"""");
    strcpy(usedat,"""");
",1,unused,159,unused,"    *cases = 0;
    strcpy(bbdate,"""");
    strcpy(copdat,"""");
    strcpy(prddat,"""");
    strcpy(usedat,"""");
",unused,libcsa-libcsa-7B712035-8DD0-43A2-A4A8-6AD7B227CBA9-lib_decode_ean.c
"    strcpy(bbdate,"""");
    strcpy(copdat,"""");
    strcpy(prddat,"""");
    strcpy(usedat,"""");
    strcpy(batref,"""");
",1,unused,160,unused,"    strcpy(bbdate,"""");
    strcpy(copdat,"""");
    strcpy(prddat,"""");
    strcpy(usedat,"""");
    strcpy(batref,"""");
",unused,libcsa-libcsa-7B712035-8DD0-43A2-A4A8-6AD7B227CBA9-lib_decode_ean.c
"    strcpy(copdat,"""");
    strcpy(prddat,"""");
    strcpy(usedat,"""");
    strcpy(batref,"""");
	strcpy(l_batref, """");
",1,unused,161,unused,"    strcpy(copdat,"""");
    strcpy(prddat,"""");
    strcpy(usedat,"""");
    strcpy(batref,"""");
	strcpy(l_batref, """");
",unused,libcsa-libcsa-7B712035-8DD0-43A2-A4A8-6AD7B227CBA9-lib_decode_ean.c
"    strcpy(prddat,"""");
    strcpy(usedat,"""");
    strcpy(batref,"""");
	strcpy(l_batref, """");
    strcpy(csn,"""");
",1,unused,162,unused,"    strcpy(prddat,"""");
    strcpy(usedat,"""");
    strcpy(batref,"""");
	strcpy(l_batref, """");
    strcpy(csn,"""");
",unused,libcsa-libcsa-7B712035-8DD0-43A2-A4A8-6AD7B227CBA9-lib_decode_ean.c
"	strcpy(l_batref, """");
    strcpy(csn,"""");
    if (strlen(serial) > 0)
    {
      strcpy(serial,"""");
",1,unused,165,unused,"	strcpy(l_batref, """");
    strcpy(csn,"""");
    if (strlen(serial) > 0)
    {
      strcpy(serial,"""");
",unused,libcsa-libcsa-7B712035-8DD0-43A2-A4A8-6AD7B227CBA9-lib_decode_ean.c
"      strcpy(serial,"""");
    }
    if (strlen(int_90) > 0)
    {
      strcpy(int_90,"""");
",1,unused,169,unused,"      strcpy(serial,"""");
    }
    if (strlen(int_90) > 0)
    {
      strcpy(int_90,"""");
",unused,libcsa-libcsa-7B712035-8DD0-43A2-A4A8-6AD7B227CBA9-lib_decode_ean.c
"          }

          /* Format to ANSI standard 'yyyy-mm-dd' from 'yymmdd' */
          if (b_ptr[0] < '9')
            strcpy(date_ptr,""20""); /* allow for 21st century */
",1,unused,344,unused,"          }

          /* Format to ANSI standard 'yyyy-mm-dd' from 'yymmdd' */
          if (b_ptr[0] < '9')
            strcpy(date_ptr,""20""); /* allow for 21st century */
",unused,libcsa-libcsa-7B712035-8DD0-43A2-A4A8-6AD7B227CBA9-lib_decode_ean.c
"          /* Format to ANSI standard 'yyyy-mm-dd' from 'yymmdd' */
          if (b_ptr[0] < '9')
            strcpy(date_ptr,""20""); /* allow for 21st century */
          else
            strcpy(date_ptr,""19"");
",1,unused,346,unused,"          /* Format to ANSI standard 'yyyy-mm-dd' from 'yymmdd' */
          if (b_ptr[0] < '9')
            strcpy(date_ptr,""20""); /* allow for 21st century */
          else
            strcpy(date_ptr,""19"");
",unused,libcsa-libcsa-7B712035-8DD0-43A2-A4A8-6AD7B227CBA9-lib_decode_ean.c
"      case 310: /* Net weight */
        itm_len = 6;
        decplace = (*b_ptr) - 48;  /* Next digit is no. decimal places */
        b_ptr++;
        strcpy(numb_buf, b_ptr);
",1,unused,397,unused,"      case 310: /* Net weight */
        itm_len = 6;
        decplace = (*b_ptr) - 48;  /* Next digit is no. decimal places */
        b_ptr++;
        strcpy(numb_buf, b_ptr);
",unused,libcsa-libcsa-7B712035-8DD0-43A2-A4A8-6AD7B227CBA9-lib_decode_ean.c
"  if (year % 4 == 0) months[1] = 29; /* Leap February */
  if (day == 0)
  {
    day = months[month-1];
    sprintf(daytxt, ""%02d"", day);
",1,unused,769,unused,"  if (year % 4 == 0) months[1] = 29; /* Leap February */
  if (day == 0)
  {
    day = months[month-1];
    sprintf(daytxt, ""%02d"", day);
",unused,libcsa-libcsa-7B712035-8DD0-43A2-A4A8-6AD7B227CBA9-lib_decode_ean.c
"
  strncpy(palnum, &pal_sscode[8], PALNUM_SIZE-1);
  /* barcode has a ""@"" char tacked on the end to make it harder for the users
     to key it in manually                                                   */
  strcat(palnum, ""@"");
",1,unused,916,unused,"
  strncpy(palnum, &pal_sscode[8], PALNUM_SIZE-1);
  /* barcode has a ""@"" char tacked on the end to make it harder for the users
     to key it in manually                                                   */
  strcat(palnum, ""@"");
",unused,libcsa-libcsa-7B712035-8DD0-43A2-A4A8-6AD7B227CBA9-lib_decode_ean.c
"		{
			fprintf(stderr, ""lib_log_output: ENVDIR is not defined\n"");
			goto lib_log_output_cleanup;
		}
		strcpy(envdir, env_env);
",1,unused,192,unused,"		{
			fprintf(stderr, ""lib_log_output: ENVDIR is not defined\n"");
			goto lib_log_output_cleanup;
		}
		strcpy(envdir, env_env);
",unused,libcsa-libcsa-7B712035-8DD0-43A2-A4A8-6AD7B227CBA9-lib_log_output.c
"		{
			printf(""lib_log_output: ENVDIR is not defined\n"");
			goto lib_log_output_cleanup;
		}
		strcpy(envdir, env_env);
",1,unused,347,unused,"		{
			printf(""lib_log_output: ENVDIR is not defined\n"");
			goto lib_log_output_cleanup;
		}
		strcpy(envdir, env_env);
",unused,libcsa-libcsa-7B712035-8DD0-43A2-A4A8-6AD7B227CBA9-lib_log_output.c
"  ** the size itself.)
  */
  msg_length = 11 + 7 +7 + 11 + (int)strlen(sndbuf->msgtxt);

  sprintf(full_msg_buf, ""%+10.9d %+10.9ld %6s %6s %+10.9ld %s"", 
",1,unused,128,unused,"  ** the size itself.)
  */
  msg_length = 11 + 7 +7 + 11 + (int)strlen(sndbuf->msgtxt);

  sprintf(full_msg_buf, ""%+10.9d %+10.9ld %6s %6s %+10.9ld %s"", 
",unused,libcsa-libcsa-7B712035-8DD0-43A2-A4A8-6AD7B227CBA9-lib_pipe.c
"                        rcvbuf->dstprc,
                        rcvbuf->sndprc,
                       &rcvbuf->fctnum);

  strcpy(rcvbuf->msgtxt, &full_msg_buf[11+7+7+11]);
",1,unused,209,unused,"                        rcvbuf->dstprc,
                        rcvbuf->sndprc,
                       &rcvbuf->fctnum);

  strcpy(rcvbuf->msgtxt, &full_msg_buf[11+7+7+11]);
",unused,libcsa-libcsa-7B712035-8DD0-43A2-A4A8-6AD7B227CBA9-lib_pipe.c
"  for (i = 0; i < NUM_PIPE_PROCESSES && pipe_info[i].server[0] != '\0' ; i++)
  {
    if ((strcmp(pipe_info[i].server, server) == 0))
    {
      sprintf(fname, ""%s/dat/%s.fifo"", getenv(""ENVDIR""), server);
",1,unused,245,unused,"  for (i = 0; i < NUM_PIPE_PROCESSES && pipe_info[i].server[0] != '\0' ; i++)
  {
    if ((strcmp(pipe_info[i].server, server) == 0))
    {
      sprintf(fname, ""%s/dat/%s.fifo"", getenv(""ENVDIR""), server);
",unused,libcsa-libcsa-7B712035-8DD0-43A2-A4A8-6AD7B227CBA9-lib_pipe.c
"    }
  }
  if (i < NUM_PIPE_PROCESSES)
  {
    strcpy(pipe_info[i].server,server);
",1,unused,251,unused,"    }
  }
  if (i < NUM_PIPE_PROCESSES)
  {
    strcpy(pipe_info[i].server,server);
",unused,libcsa-libcsa-7B712035-8DD0-43A2-A4A8-6AD7B227CBA9-lib_pipe.c
"  }
  if (i < NUM_PIPE_PROCESSES)
  {
    strcpy(pipe_info[i].server,server);
    sprintf(fname, ""%s/dat/%s.fifo"", getenv(""ENVDIR""), server);
",1,unused,252,unused,"  }
  if (i < NUM_PIPE_PROCESSES)
  {
    strcpy(pipe_info[i].server,server);
    sprintf(fname, ""%s/dat/%s.fifo"", getenv(""ENVDIR""), server);
",unused,libcsa-libcsa-7B712035-8DD0-43A2-A4A8-6AD7B227CBA9-lib_pipe.c
"        && strcmp(prcnam, prcdata[proc_idx].prcnam) != 0 ; proc_idx++);
      if (proc_idx < MAX_PROCESS)
      {
        last_db_connected = TRUE;
        strcpy(l_name,prcnam);
",1,unused,141,unused,"        && strcmp(prcnam, prcdata[proc_idx].prcnam) != 0 ; proc_idx++);
      if (proc_idx < MAX_PROCESS)
      {
        last_db_connected = TRUE;
        strcpy(l_name,prcnam);
",unused,libcsa-libcsa-7B712035-8DD0-43A2-A4A8-6AD7B227CBA9-lib_set_procstat.c
"  if(!name)
    name = ""unnamed"";

  file->name = (char*)malloc(strlen(name)+1);
  strcpy(file->name, name);
",1,unused,461,unused,"  if(!name)
    name = ""unnamed"";

  file->name = (char*)malloc(strlen(name)+1);
  strcpy(file->name, name);
",unused,libcsa-libcsa-7B712035-8DD0-43A2-A4A8-6AD7B227CBA9-lib_trace.c
"  /* Allocate the required space */
  char *line = (char*)malloc(time_len + msg_len + 1);

  /* Start with the date/time prefix */
  sprintf(line, ""%s.%03ld :"", timestr, (long)now.tv_usec / 1000);
",1,unused,547,unused,"  /* Allocate the required space */
  char *line = (char*)malloc(time_len + msg_len + 1);

  /* Start with the date/time prefix */
  sprintf(line, ""%s.%03ld :"", timestr, (long)now.tv_usec / 1000);
",unused,libcsa-libcsa-7B712035-8DD0-43A2-A4A8-6AD7B227CBA9-lib_trace.c
"              if (o > 5)
                break;
            }
          if (o < 5)
            strcpy(s+1, s+1+o);
",1,unused,169,unused,"              if (o > 5)
                break;
            }
          if (o < 5)
            strcpy(s+1, s+1+o);
",unused,libtiff-4.0.6-contrib2Fiptcutil2Fiptcutil.c
"        {
          if (html_codes[i].len <= len)
            if (STRNICMP(s, html_codes[i].code, html_codes[i].len) == 0)
              {
                strcpy(s+1, s+html_codes[i].len);
",1,unused,185,unused,"        {
          if (html_codes[i].len <= len)
            if (STRNICMP(s, html_codes[i].code, html_codes[i].len) == 0)
              {
                strcpy(s+1, s+html_codes[i].len);
",unused,libtiff-4.0.6-contrib2Fiptcutil2Fiptcutil.c
"{
	const TIFFCodec* c = TIFFFindCODEC(tif->tif_dir.td_compression);
        char compression_code[20];
        
        sprintf(compression_code, ""%d"",tif->tif_dir.td_compression );
",1,unused,111,unused,"{
	const TIFFCodec* c = TIFFFindCODEC(tif->tif_dir.td_compression);
        char compression_code[20];
        
        sprintf(compression_code, ""%d"",tif->tif_dir.td_compression );
",unused,libtiff-4.0.6-libtiff2Ftif_codec.c
"	if (cd != NULL) {
		cd->info = (TIFFCodec*) ((uint8*) cd + sizeof (codec_t));
		cd->info->name = (char*)
		    ((uint8*) cd->info + sizeof (TIFFCodec));
		strcpy(cd->info->name, name);
",1,unused,211,unused,"	if (cd != NULL) {
		cd->info = (TIFFCodec*) ((uint8*) cd + sizeof (codec_t));
		cd->info->name = (char*)
		    ((uint8*) cd->info + sizeof (TIFFCodec));
		strcpy(cd->info->name, name);
",unused,libtiff-4.0.6-libtiff2Ftif_compress.c
"    assert (link != NULL);
    link->next = tif->tif_clientinfo;
    link->name = (char *) _TIFFmalloc((tmsize_t)(strlen(name)+1));
    assert (link->name != NULL);
    strcpy(link->name, name);
",1,unused,107,unused,"    assert (link != NULL);
    link->next = tif->tif_clientinfo;
    link->name = (char *) _TIFFmalloc((tmsize_t)(strlen(name)+1));
    assert (link->name != NULL);
    strcpy(link->name, name);
",unused,libtiff-4.0.6-libtiff2Ftif_extension.c
"	uint16 photometric;
	int colorchannels;

	if (!tif->tif_decodestatus) {
		sprintf(emsg, ""Sorry, requested compression method is not configured"");
",1,unused,83,unused,"	uint16 photometric;
	int colorchannels;

	if (!tif->tif_decodestatus) {
		sprintf(emsg, ""Sorry, requested compression method is not configured"");
",unused,libtiff-4.0.6-libtiff2Ftif_getimage.c
"		case 8:
		case 16:
			break;
		default:
			sprintf(emsg, ""Sorry, can not handle images with %d-bit samples"",
",1,unused,94,unused,"		case 8:
		case 16:
			break;
		default:
			sprintf(emsg, ""Sorry, can not handle images with %d-bit samples"",
",unused,libtiff-4.0.6-libtiff2Ftif_getimage.c
"			case 3:
				photometric = PHOTOMETRIC_RGB;
				break;
			default:
				sprintf(emsg, ""Missing needed %s tag"", photoTag);
",1,unused,108,unused,"			case 3:
				photometric = PHOTOMETRIC_RGB;
				break;
			default:
				sprintf(emsg, ""Missing needed %s tag"", photoTag);
",unused,libtiff-4.0.6-libtiff2Ftif_getimage.c
"		case PHOTOMETRIC_PALETTE:
			if (td->td_planarconfig == PLANARCONFIG_CONTIG
			    && td->td_samplesperpixel != 1
			    && td->td_bitspersample < 8 ) {
				sprintf(emsg,
",1,unused,119,unused,"		case PHOTOMETRIC_PALETTE:
			if (td->td_planarconfig == PLANARCONFIG_CONTIG
			    && td->td_samplesperpixel != 1
			    && td->td_bitspersample < 8 ) {
				sprintf(emsg,
",unused,libtiff-4.0.6-libtiff2Ftif_getimage.c
"			 */
			break;
		case PHOTOMETRIC_RGB:
			if (colorchannels < 3) {
				sprintf(emsg, ""Sorry, can not handle RGB image with %s=%d"",
",1,unused,143,unused,"			 */
			break;
		case PHOTOMETRIC_RGB:
			if (colorchannels < 3) {
				sprintf(emsg, ""Sorry, can not handle RGB image with %s=%d"",
",unused,libtiff-4.0.6-libtiff2Ftif_getimage.c
"			{
				uint16 inkset;
				TIFFGetFieldDefaulted(tif, TIFFTAG_INKSET, &inkset);
				if (inkset != INKSET_CMYK) {
					sprintf(emsg,
",1,unused,153,unused,"			{
				uint16 inkset;
				TIFFGetFieldDefaulted(tif, TIFFTAG_INKSET, &inkset);
				if (inkset != INKSET_CMYK) {
					sprintf(emsg,
",unused,libtiff-4.0.6-libtiff2Ftif_getimage.c
"					    ""InkSet"", inkset);
					return 0;
				}
				if (td->td_samplesperpixel < 4) {
					sprintf(emsg,
",1,unused,159,unused,"					    ""InkSet"", inkset);
					return 0;
				}
				if (td->td_samplesperpixel < 4) {
					sprintf(emsg,
",unused,libtiff-4.0.6-libtiff2Ftif_getimage.c
"				break;
			}
		case PHOTOMETRIC_LOGL:
			if (td->td_compression != COMPRESSION_SGILOG) {
				sprintf(emsg, ""Sorry, LogL data must have %s=%d"",
",1,unused,168,unused,"				break;
			}
		case PHOTOMETRIC_LOGL:
			if (td->td_compression != COMPRESSION_SGILOG) {
				sprintf(emsg, ""Sorry, LogL data must have %s=%d"",
",unused,libtiff-4.0.6-libtiff2Ftif_getimage.c
"			break;
		case PHOTOMETRIC_LOGLUV:
			if (td->td_compression != COMPRESSION_SGILOG &&
			    td->td_compression != COMPRESSION_SGILOG24) {
				sprintf(emsg, ""Sorry, LogLuv data must have %s=%d or %d"",
",1,unused,176,unused,"			break;
		case PHOTOMETRIC_LOGLUV:
			if (td->td_compression != COMPRESSION_SGILOG &&
			    td->td_compression != COMPRESSION_SGILOG24) {
				sprintf(emsg, ""Sorry, LogLuv data must have %s=%d or %d"",
",unused,libtiff-4.0.6-libtiff2Ftif_getimage.c
"				    ""Compression"", COMPRESSION_SGILOG, COMPRESSION_SGILOG24);
				return (0);
			}
			if (td->td_planarconfig != PLANARCONFIG_CONTIG) {
				sprintf(emsg, ""Sorry, can not handle LogLuv images with %s=%d"",
",1,unused,181,unused,"				    ""Compression"", COMPRESSION_SGILOG, COMPRESSION_SGILOG24);
				return (0);
			}
			if (td->td_planarconfig != PLANARCONFIG_CONTIG) {
				sprintf(emsg, ""Sorry, can not handle LogLuv images with %s=%d"",
",unused,libtiff-4.0.6-libtiff2Ftif_getimage.c
"				return (0);
			}
			if( td->td_samplesperpixel != 3 )
            {
                sprintf(emsg,
",1,unused,187,unused,"				return (0);
			}
			if( td->td_samplesperpixel != 3 )
            {
                sprintf(emsg,
",unused,libtiff-4.0.6-libtiff2Ftif_getimage.c
"			break;
		case PHOTOMETRIC_CIELAB:
            if( td->td_samplesperpixel != 3 || td->td_bitspersample != 8 )
            {
                sprintf(emsg,
",1,unused,196,unused,"			break;
		case PHOTOMETRIC_CIELAB:
            if( td->td_samplesperpixel != 3 || td->td_bitspersample != 8 )
            {
                sprintf(emsg,
",unused,libtiff-4.0.6-libtiff2Ftif_getimage.c
"                return 0;
            }
			break;
		default:
			sprintf(emsg, ""Sorry, can not handle image with %s=%d"",
",1,unused,204,unused,"                return 0;
            }
			break;
		default:
			sprintf(emsg, ""Sorry, can not handle image with %s=%d"",
",unused,libtiff-4.0.6-libtiff2Ftif_getimage.c
"		case 8:
		case 16:
			break;
		default:
			sprintf(emsg, ""Sorry, can not handle images with %d-bit samples"",
",1,unused,278,unused,"		case 8:
		case 16:
			break;
		default:
			sprintf(emsg, ""Sorry, can not handle images with %d-bit samples"",
",unused,libtiff-4.0.6-libtiff2Ftif_getimage.c
"			case 3:
				img->photometric = PHOTOMETRIC_RGB;
				break;
			default:
				sprintf(emsg, ""Missing needed %s tag"", photoTag);
",1,unused,328,unused,"			case 3:
				img->photometric = PHOTOMETRIC_RGB;
				break;
			default:
				sprintf(emsg, ""Missing needed %s tag"", photoTag);
",unused,libtiff-4.0.6-libtiff2Ftif_getimage.c
"	switch (img->photometric) {
		case PHOTOMETRIC_PALETTE:
			if (!TIFFGetField(tif, TIFFTAG_COLORMAP,
			    &red_orig, &green_orig, &blue_orig)) {
				sprintf(emsg, ""Missing required \""Colormap\"" tag"");
",1,unused,336,unused,"	switch (img->photometric) {
		case PHOTOMETRIC_PALETTE:
			if (!TIFFGetField(tif, TIFFTAG_COLORMAP,
			    &red_orig, &green_orig, &blue_orig)) {
				sprintf(emsg, ""Missing required \""Colormap\"" tag"");
",unused,libtiff-4.0.6-libtiff2Ftif_getimage.c
"			img->redcmap = (uint16 *) _TIFFmalloc(sizeof(uint16)*n_color);
			img->greencmap = (uint16 *) _TIFFmalloc(sizeof(uint16)*n_color);
			img->bluecmap = (uint16 *) _TIFFmalloc(sizeof(uint16)*n_color);
			if( !img->redcmap || !img->greencmap || !img->bluecmap ) {
				sprintf(emsg, ""Out of memory for colormap copy"");
",1,unused,346,unused,"			img->redcmap = (uint16 *) _TIFFmalloc(sizeof(uint16)*n_color);
			img->greencmap = (uint16 *) _TIFFmalloc(sizeof(uint16)*n_color);
			img->bluecmap = (uint16 *) _TIFFmalloc(sizeof(uint16)*n_color);
			if( !img->redcmap || !img->greencmap || !img->bluecmap ) {
				sprintf(emsg, ""Out of memory for colormap copy"");
",unused,libtiff-4.0.6-libtiff2Ftif_getimage.c
"		case PHOTOMETRIC_MINISBLACK:
			if (planarconfig == PLANARCONFIG_CONTIG
			    && img->samplesperpixel != 1
			    && img->bitspersample < 8 ) {
				sprintf(emsg,
",1,unused,360,unused,"		case PHOTOMETRIC_MINISBLACK:
			if (planarconfig == PLANARCONFIG_CONTIG
			    && img->samplesperpixel != 1
			    && img->bitspersample < 8 ) {
				sprintf(emsg,
",unused,libtiff-4.0.6-libtiff2Ftif_getimage.c
"			 */
			break;
		case PHOTOMETRIC_RGB:
			if (colorchannels < 3) {
				sprintf(emsg, ""Sorry, can not handle RGB image with %s=%d"",
",1,unused,397,unused,"			 */
			break;
		case PHOTOMETRIC_RGB:
			if (colorchannels < 3) {
				sprintf(emsg, ""Sorry, can not handle RGB image with %s=%d"",
",unused,libtiff-4.0.6-libtiff2Ftif_getimage.c
"			{
				uint16 inkset;
				TIFFGetFieldDefaulted(tif, TIFFTAG_INKSET, &inkset);
				if (inkset != INKSET_CMYK) {
					sprintf(emsg, ""Sorry, can not handle separated image with %s=%d"",
",1,unused,407,unused,"			{
				uint16 inkset;
				TIFFGetFieldDefaulted(tif, TIFFTAG_INKSET, &inkset);
				if (inkset != INKSET_CMYK) {
					sprintf(emsg, ""Sorry, can not handle separated image with %s=%d"",
",unused,libtiff-4.0.6-libtiff2Ftif_getimage.c
"					    ""InkSet"", inkset);
                                        goto fail_return;
				}
				if (img->samplesperpixel < 4) {
					sprintf(emsg, ""Sorry, can not handle separated image with %s=%d"",
",1,unused,412,unused,"					    ""InkSet"", inkset);
                                        goto fail_return;
				}
				if (img->samplesperpixel < 4) {
					sprintf(emsg, ""Sorry, can not handle separated image with %s=%d"",
",unused,libtiff-4.0.6-libtiff2Ftif_getimage.c
"			}
			break;
		case PHOTOMETRIC_LOGL:
			if (compress != COMPRESSION_SGILOG) {
				sprintf(emsg, ""Sorry, LogL data must have %s=%d"",
",1,unused,420,unused,"			}
			break;
		case PHOTOMETRIC_LOGL:
			if (compress != COMPRESSION_SGILOG) {
				sprintf(emsg, ""Sorry, LogL data must have %s=%d"",
",unused,libtiff-4.0.6-libtiff2Ftif_getimage.c
"			img->bitspersample = 8;
			break;
		case PHOTOMETRIC_LOGLUV:
			if (compress != COMPRESSION_SGILOG && compress != COMPRESSION_SGILOG24) {
				sprintf(emsg, ""Sorry, LogLuv data must have %s=%d or %d"",
",1,unused,430,unused,"			img->bitspersample = 8;
			break;
		case PHOTOMETRIC_LOGLUV:
			if (compress != COMPRESSION_SGILOG && compress != COMPRESSION_SGILOG24) {
				sprintf(emsg, ""Sorry, LogLuv data must have %s=%d or %d"",
",unused,libtiff-4.0.6-libtiff2Ftif_getimage.c
"				    ""Compression"", COMPRESSION_SGILOG, COMPRESSION_SGILOG24);
                                goto fail_return;
			}
			if (planarconfig != PLANARCONFIG_CONTIG) {
				sprintf(emsg, ""Sorry, can not handle LogLuv images with %s=%d"",
",1,unused,435,unused,"				    ""Compression"", COMPRESSION_SGILOG, COMPRESSION_SGILOG24);
                                goto fail_return;
			}
			if (planarconfig != PLANARCONFIG_CONTIG) {
				sprintf(emsg, ""Sorry, can not handle LogLuv images with %s=%d"",
",unused,libtiff-4.0.6-libtiff2Ftif_getimage.c
"			break;
		case PHOTOMETRIC_CIELAB:
			break;
		default:
			sprintf(emsg, ""Sorry, can not handle image with %s=%d"",
",1,unused,446,unused,"			break;
		case PHOTOMETRIC_CIELAB:
			break;
		default:
			sprintf(emsg, ""Sorry, can not handle image with %s=%d"",
",unused,libtiff-4.0.6-libtiff2Ftif_getimage.c
"	img->isContig =
	    !(planarconfig == PLANARCONFIG_SEPARATE && img->samplesperpixel > 1);
	if (img->isContig) {
		if (!PickContigCase(img)) {
			sprintf(emsg, ""Sorry, can not handle image"");
",1,unused,464,unused,"	img->isContig =
	    !(planarconfig == PLANARCONFIG_SEPARATE && img->samplesperpixel > 1);
	if (img->isContig) {
		if (!PickContigCase(img)) {
			sprintf(emsg, ""Sorry, can not handle image"");
",unused,libtiff-4.0.6-libtiff2Ftif_getimage.c
"			goto fail_return;
		}
	} else {
		if (!PickSeparateCase(img)) {
			sprintf(emsg, ""Sorry, can not handle image"");
",1,unused,469,unused,"			goto fail_return;
		}
	} else {
		if (!PickSeparateCase(img)) {
			sprintf(emsg, ""Sorry, can not handle image"");
",unused,libtiff-4.0.6-libtiff2Ftif_getimage.c
"		goto bad2;
	}
	_TIFFmemset(tif, 0, sizeof (*tif));
	tif->tif_name = (char *)tif + sizeof (TIFF);
	strcpy(tif->tif_name, name);
",1,unused,126,unused,"		goto bad2;
	}
	_TIFFmemset(tif, 0, sizeof (*tif));
	tif->tif_name = (char *)tif + sizeof (TIFF);
	strcpy(tif->tif_name, name);
",unused,libtiff-4.0.6-libtiff2Ftif_open.c
"		case 'P':
                        switch (optarg[0])
                          {
                          case 'l':
                          case 'L': strcpy (pageOrientation, ""Landscape"");
",1,unused,330,unused,"		case 'P':
                        switch (optarg[0])
                          {
                          case 'l':
                          case 'L': strcpy (pageOrientation, ""Landscape"");
",unused,libtiff-4.0.6-tools2Ftiff2ps.c
"                          case 'l':
                          case 'L': strcpy (pageOrientation, ""Landscape"");
			            break; 
                          case 'p':
                          case 'P': strcpy (pageOrientation, ""Portrait"");
",1,unused,333,unused,"                          case 'l':
                          case 'L': strcpy (pageOrientation, ""Landscape"");
			            break; 
                          case 'p':
                          case 'P': strcpy (pageOrientation, ""Portrait"");
",unused,libtiff-4.0.6-tools2Ftiff2ps.c
"
	if ( useImagemask && (bitspersample == 1) )
		imageOp = ""imagemask"";

	(void)strcpy(im_x, ""0"");
",1,unused,1804,unused,"
	if ( useImagemask && (bitspersample == 1) )
		imageOp = ""imagemask"";

	(void)strcpy(im_x, ""0"");
",unused,libtiff-4.0.6-tools2Ftiff2ps.c
"			fputs(""0 0 1 1 rectclip\n"", fd);
		}
		if (tile_width < w) {
			fputs(""/im_x 0 def\n"", fd);
			(void)strcpy(im_x, ""im_x neg"");
",1,unused,1823,unused,"			fputs(""0 0 1 1 rectclip\n"", fd);
		}
		if (tile_width < w) {
			fputs(""/im_x 0 def\n"", fd);
			(void)strcpy(im_x, ""im_x neg"");
",unused,libtiff-4.0.6-tools2Ftiff2ps.c
"		if (repeat_count > 1) {
			fputs(""/im_y 0 def\n"", fd);
			fprintf(fd, ""/im_h %lu def\n"",
			    (unsigned long) tile_height);
			(void)strcpy(im_h, ""im_h"");
",1,unused,1838,unused,"		if (repeat_count > 1) {
			fputs(""/im_y 0 def\n"", fd);
			fprintf(fd, ""/im_h %lu def\n"",
			    (unsigned long) tile_height);
			(void)strcpy(im_h, ""im_h"");
",unused,libtiff-4.0.6-tools2Ftiff2ps.c
"                      /* check dump format value */
		      if (strncmp (opt_offset + 1, ""txt"", 3) == 0)
                        {
                        dump->format = DUMP_TEXT;
                        strcpy (dump->mode, ""w"");
",1,unused,1709,unused,"                      /* check dump format value */
		      if (strncmp (opt_offset + 1, ""txt"", 3) == 0)
                        {
                        dump->format = DUMP_TEXT;
                        strcpy (dump->mode, ""w"");
",unused,libtiff-4.0.6-tools2Ftiffcrop.c
"                        {
		        if (strncmp(opt_offset + 1, ""raw"", 3) == 0)
                          {
                          dump->format = DUMP_RAW;
                          strcpy (dump->mode, ""wb"");
",1,unused,1716,unused,"                        {
		        if (strncmp(opt_offset + 1, ""raw"", 3) == 0)
                          {
                          dump->format = DUMP_RAW;
                          strcpy (dump->mode, ""wb"");
",unused,libtiff-4.0.6-tools2Ftiffcrop.c
"		break;
      case 'P': /* page size selection */ 
	        if (sscanf(optarg, ""%lfx%lf"", &page->width, &page->length) == 2)
                  {
                  strcpy (page->name, ""Custom""); 
",1,unused,1910,unused,"		break;
      case 'P': /* page size selection */ 
	        if (sscanf(optarg, ""%lfx%lf"", &page->width, &page->length) == 2)
                  {
                  strcpy (page->name, ""Custom""); 
",unused,libtiff-4.0.6-tools2Ftiffcrop.c
"    TIFFClose (*tiffout);
    *tiffout = NULL;
    }

  strcpy (export_ext, "".tiff"");
",1,unused,2061,unused,"    TIFFClose (*tiffout);
    *tiffout = NULL;
    }

  strcpy (export_ext, "".tiff"");
",unused,libtiff-4.0.6-tools2Ftiffcrop.c
"      {
      for (j = 0, k = 7; j < 8; j++, k--)
        {
	bitset = (*(data + i)) & (((unsigned char)1 << k)) ? 1 : 0;
        sprintf(&dump_array[j], (bitset) ? ""1"" : ""0"");
",1,unused,2435,unused,"      {
      for (j = 0, k = 7; j < 8; j++, k--)
        {
	bitset = (*(data + i)) & (((unsigned char)1 << k)) ? 1 : 0;
        sprintf(&dump_array[j], (bitset) ? ""1"" : ""0"");
",unused,libtiff-4.0.6-tools2Ftiffcrop.c
"    fprintf (dumpfile,"" %s  "", dump_tag);
    for (j = 0, k = 7; j < 8; j++, k--)
      {
      bitset = data & (((unsigned char)1 << k)) ? 1 : 0;
      sprintf(&dump_array[j], (bitset) ? ""1"" : ""0"");
",1,unused,2472,unused,"    fprintf (dumpfile,"" %s  "", dump_tag);
    for (j = 0, k = 7; j < 8; j++, k--)
      {
      bitset = data & (((unsigned char)1 << k)) ? 1 : 0;
      sprintf(&dump_array[j], (bitset) ? ""1"" : ""0"");
",unused,libtiff-4.0.6-tools2Ftiffcrop.c
"    fprintf (dumpfile,"" %s  "", dump_tag);
    for (j = 0, k = 15; k >= 0; j++, k--)
      {
      bitset = data & (((unsigned char)1 << k)) ? 1 : 0;
      sprintf(&dump_array[j], (bitset) ? ""1"" : ""0"");
",1,unused,2507,unused,"    fprintf (dumpfile,"" %s  "", dump_tag);
    for (j = 0, k = 15; k >= 0; j++, k--)
      {
      bitset = data & (((unsigned char)1 << k)) ? 1 : 0;
      sprintf(&dump_array[j], (bitset) ? ""1"" : ""0"");
",unused,libtiff-4.0.6-tools2Ftiffcrop.c
"      {
      bitset = data & (((unsigned char)1 << k)) ? 1 : 0;
      sprintf(&dump_array[j], (bitset) ? ""1"" : ""0"");
      if ((k % 8) == 0)
          sprintf(&dump_array[++j], "" "");
",1,unused,2509,unused,"      {
      bitset = data & (((unsigned char)1 << k)) ? 1 : 0;
      sprintf(&dump_array[j], (bitset) ? ""1"" : ""0"");
      if ((k % 8) == 0)
          sprintf(&dump_array[++j], "" "");
",unused,libtiff-4.0.6-tools2Ftiffcrop.c
"    fprintf (dumpfile,"" %s  "", dump_tag);
    for (j = 0, k = 31; k >= 0; j++, k--)
      {
      bitset = data & (((uint32)1 << k)) ? 1 : 0;
      sprintf(&dump_array[j], (bitset) ? ""1"" : ""0"");
",1,unused,2544,unused,"    fprintf (dumpfile,"" %s  "", dump_tag);
    for (j = 0, k = 31; k >= 0; j++, k--)
      {
      bitset = data & (((uint32)1 << k)) ? 1 : 0;
      sprintf(&dump_array[j], (bitset) ? ""1"" : ""0"");
",unused,libtiff-4.0.6-tools2Ftiffcrop.c
"      {
      bitset = data & (((uint32)1 << k)) ? 1 : 0;
      sprintf(&dump_array[j], (bitset) ? ""1"" : ""0"");
      if ((k % 8) == 0)
          sprintf(&dump_array[++j], "" "");
",1,unused,2546,unused,"      {
      bitset = data & (((uint32)1 << k)) ? 1 : 0;
      sprintf(&dump_array[j], (bitset) ? ""1"" : ""0"");
      if ((k % 8) == 0)
          sprintf(&dump_array[++j], "" "");
",unused,libtiff-4.0.6-tools2Ftiffcrop.c
"    fprintf (dumpfile,"" %s  "", dump_tag);
    for (j = 0, k = 63; k >= 0; j++, k--)
      {
      bitset = data & (((uint64)1 << k)) ? 1 : 0;
      sprintf(&dump_array[j], (bitset) ? ""1"" : ""0"");
",1,unused,2580,unused,"    fprintf (dumpfile,"" %s  "", dump_tag);
    for (j = 0, k = 63; k >= 0; j++, k--)
      {
      bitset = data & (((uint64)1 << k)) ? 1 : 0;
      sprintf(&dump_array[j], (bitset) ? ""1"" : ""0"");
",unused,libtiff-4.0.6-tools2Ftiffcrop.c
"      {
      bitset = data & (((uint64)1 << k)) ? 1 : 0;
      sprintf(&dump_array[j], (bitset) ? ""1"" : ""0"");
      if ((k % 8) == 0)
          sprintf(&dump_array[++j], "" "");
",1,unused,2582,unused,"      {
      bitset = data & (((uint64)1 << k)) ? 1 : 0;
      sprintf(&dump_array[j], (bitset) ? ""1"" : ""0"");
      if ((k % 8) == 0)
          sprintf(&dump_array[++j], "" "");
",unused,libtiff-4.0.6-tools2Ftiffcrop.c
"          {
          *dst++ = buff2;
          buff2 = buff1;
          ready_bits -= 8;
          strcpy (action, ""Flush"");
",1,unused,3752,unused,"          {
          *dst++ = buff2;
          buff2 = buff1;
          ready_bits -= 8;
          strcpy (action, ""Flush"");
",unused,libtiff-4.0.6-tools2Ftiffcrop.c
"          }
        else
          {
          buff2 = (buff2 | (buff1 >> ready_bits));
          strcpy (action, ""Update"");
",1,unused,3757,unused,"          }
        else
          {
          buff2 = (buff2 | (buff1 >> ready_bits));
          strcpy (action, ""Update"");
",unused,libtiff-4.0.6-tools2Ftiffcrop.c
"	    *dst++ = bytebuff;
	    ready_bits -= 8;
	    /* shift in new bits */
	    buff2 = ((buff2 << 8) | (buff1 >> ready_bits));
	    strcpy (action, ""Flush"");
",1,unused,3858,unused,"	    *dst++ = bytebuff;
	    ready_bits -= 8;
	    /* shift in new bits */
	    buff2 = ((buff2 << 8) | (buff1 >> ready_bits));
	    strcpy (action, ""Flush"");
",unused,libtiff-4.0.6-tools2Ftiffcrop.c
"	else
	  { /* add another bps bits to the buffer */
	    bytebuff = 0;
	    buff2 = (buff2 | (buff1 >> ready_bits));
	    strcpy (action, ""Update"");
",1,unused,3864,unused,"	else
	  { /* add another bps bits to the buffer */
	    bytebuff = 0;
	    buff2 = (buff2 | (buff1 >> ready_bits));
	    strcpy (action, ""Update"");
",unused,libtiff-4.0.6-tools2Ftiffcrop.c
"	    ready_bits -= 16;

	    /* shift in new bits */
	    buff2 = ((buff2 << 16) | (buff1 >> ready_bits));
	    strcpy (action, ""Flush"");
",1,unused,3970,unused,"	    ready_bits -= 16;

	    /* shift in new bits */
	    buff2 = ((buff2 << 16) | (buff1 >> ready_bits));
	    strcpy (action, ""Flush"");
",unused,libtiff-4.0.6-tools2Ftiffcrop.c
"	else
	  { /* add another bps bits to the buffer */
	    bytebuff1 = bytebuff2 = 0;
	    buff2 = (buff2 | (buff1 >> ready_bits));
	    strcpy (action, ""Update"");
",1,unused,3976,unused,"	else
	  { /* add another bps bits to the buffer */
	    bytebuff1 = bytebuff2 = 0;
	    buff2 = (buff2 | (buff1 >> ready_bits));
	    strcpy (action, ""Update"");
",unused,libtiff-4.0.6-tools2Ftiffcrop.c
"	  ready_bits -= 32;
                    
	  /* shift in new bits */
	  buff2 = ((buff2 << 32) | (buff1 >> ready_bits));
	  strcpy (action, ""Flush"");
",1,unused,4107,unused,"	  ready_bits -= 32;
                    
	  /* shift in new bits */
	  buff2 = ((buff2 << 32) | (buff1 >> ready_bits));
	  strcpy (action, ""Flush"");
",unused,libtiff-4.0.6-tools2Ftiffcrop.c
"	else
	  { /* add another bps bits to the buffer */
	  bytebuff1 = bytebuff2 = bytebuff3 = bytebuff4 = 0;
	  buff2 = (buff2 | (buff1 >> ready_bits));
	  strcpy (action, ""Update"");
",1,unused,4113,unused,"	else
	  { /* add another bps bits to the buffer */
	  bytebuff1 = bytebuff2 = bytebuff3 = bytebuff4 = 0;
	  buff2 = (buff2 | (buff1 >> ready_bits));
	  strcpy (action, ""Update"");
",unused,libtiff-4.0.6-tools2Ftiffcrop.c
"          {
          *dst++ = buff2;
          buff2 = buff1;
          ready_bits -= 8;
          strcpy (action, ""Flush"");
",1,unused,4277,unused,"          {
          *dst++ = buff2;
          buff2 = buff1;
          ready_bits -= 8;
          strcpy (action, ""Flush"");
",unused,libtiff-4.0.6-tools2Ftiffcrop.c
"          }
        else
          {
          buff2 = (buff2 | (buff1 >> ready_bits));
          strcpy (action, ""Update"");
",1,unused,4282,unused,"          }
        else
          {
          buff2 = (buff2 | (buff1 >> ready_bits));
          strcpy (action, ""Update"");
",unused,libtiff-4.0.6-tools2Ftiffcrop.c
"	    *dst++ = bytebuff;
	    ready_bits -= 8;
	    /* shift in new bits */
	    buff2 = ((buff2 << 8) | (buff1 >> ready_bits));
	    strcpy (action, ""Flush"");
",1,unused,4382,unused,"	    *dst++ = bytebuff;
	    ready_bits -= 8;
	    /* shift in new bits */
	    buff2 = ((buff2 << 8) | (buff1 >> ready_bits));
	    strcpy (action, ""Flush"");
",unused,libtiff-4.0.6-tools2Ftiffcrop.c
"	else
	  { /* add another bps bits to the buffer */
	    bytebuff = 0;
	    buff2 = (buff2 | (buff1 >> ready_bits));
	    strcpy (action, ""Update"");
",1,unused,4388,unused,"	else
	  { /* add another bps bits to the buffer */
	    bytebuff = 0;
	    buff2 = (buff2 | (buff1 >> ready_bits));
	    strcpy (action, ""Update"");
",unused,libtiff-4.0.6-tools2Ftiffcrop.c
"	    ready_bits -= 16;

	    /* shift in new bits */
	    buff2 = ((buff2 << 16) | (buff1 >> ready_bits));
	    strcpy (action, ""Flush"");
",1,unused,4494,unused,"	    ready_bits -= 16;

	    /* shift in new bits */
	    buff2 = ((buff2 << 16) | (buff1 >> ready_bits));
	    strcpy (action, ""Flush"");
",unused,libtiff-4.0.6-tools2Ftiffcrop.c
"	else
	  { /* add another bps bits to the buffer */
	    bytebuff1 = bytebuff2 = 0;
	    buff2 = (buff2 | (buff1 >> ready_bits));
	    strcpy (action, ""Update"");
",1,unused,4500,unused,"	else
	  { /* add another bps bits to the buffer */
	    bytebuff1 = bytebuff2 = 0;
	    buff2 = (buff2 | (buff1 >> ready_bits));
	    strcpy (action, ""Update"");
",unused,libtiff-4.0.6-tools2Ftiffcrop.c
"	  ready_bits -= 32;
                    
	  /* shift in new bits */
	  buff2 = ((buff2 << 32) | (buff1 >> ready_bits));
	  strcpy (action, ""Flush"");
",1,unused,4632,unused,"	  ready_bits -= 32;
                    
	  /* shift in new bits */
	  buff2 = ((buff2 << 32) | (buff1 >> ready_bits));
	  strcpy (action, ""Flush"");
",unused,libtiff-4.0.6-tools2Ftiffcrop.c
"	else
	  { /* add another bps bits to the buffer */
	  bytebuff1 = bytebuff2 = bytebuff3 = bytebuff4 = 0;
	  buff2 = (buff2 | (buff1 >> ready_bits));
	  strcpy (action, ""Update"");
",1,unused,4638,unused,"	else
	  { /* add another bps bits to the buffer */
	  bytebuff1 = bytebuff2 = bytebuff3 = bytebuff4 = 0;
	  buff2 = (buff2 | (buff1 >> ready_bits));
	  strcpy (action, ""Update"");
",unused,libtiff-4.0.6-tools2Ftiffcrop.c
"               struct buffinfo seg_buffs[])
   {
   int i; 

   strcpy (page->name, """");
",1,unused,4898,unused,"               struct buffinfo seg_buffs[])
   {
   int i; 

   strcpy (page->name, """");
",unused,libtiff-4.0.6-tools2Ftiffcrop.c
"  {
  dump->debug  = 0;
  dump->format = DUMP_NONE;
  dump->level  = 1;
  sprintf (dump->mode, ""w"");
",1,unused,4993,unused,"  {
  dump->debug  = 0;
  dump->format = DUMP_NONE;
  dump->level  = 1;
  sprintf (dump->mode, ""w"");
",unused,libtiff-4.0.6-tools2Ftiffcrop.c
"  filename  = MALLOC (char, filename_len + 1);
  if (!filename)
    return 1;

  sprintf (filename, ""%.*s/%s"", (int) dirname_len, dirname, dlname);
",1,unused,522,unused,"  filename  = MALLOC (char, filename_len + 1);
  if (!filename)
    return 1;

  sprintf (filename, ""%.*s/%s"", (int) dirname_len, dirname, dlname);
",unused,libtoolsources2.4.6-libltdl2Fltdl.c
"	    goto cleanup;
	}

	assert (filenamesize > lendir);
	strcpy (filename, dir_name);
",1,unused,718,unused,"	    goto cleanup;
	}

	assert (filenamesize > lendir);
	strcpy (filename, dir_name);
",unused,libtoolsources2.4.6-libltdl2Fltdl.c
"	if (base_name && *base_name)
	  {
	    if (filename[lendir -1] != '/')
	      filename[lendir++] = '/';
	    strcpy (filename +lendir, base_name);
",1,unused,724,unused,"	if (base_name && *base_name)
	  {
	    if (filename[lendir -1] != '/')
	      filename[lendir++] = '/';
	    strcpy (filename +lendir, base_name);
",unused,libtoolsources2.4.6-libltdl2Fltdl.c
"      attempt = MALLOC (char, LT_STRLEN (filename) + LT_STRLEN (ext) + 1);
      if (!attempt)
	return 1;

      sprintf(attempt, ""%s%s"", filename, ext);
",1,unused,1212,unused,"      attempt = MALLOC (char, LT_STRLEN (filename) + LT_STRLEN (ext) + 1);
      if (!attempt)
	return 1;

      sprintf(attempt, ""%s%s"", filename, ext);
",unused,libtoolsources2.4.6-libltdl2Fltdl.c
"	  /* Preloaded modules are always named according to their old
	     archive name.  */
	  if (strncmp(name, ""lib"", 3) == 0)
	    {
	      sprintf (archive_name, ""%s%s.%s"", libprefix, name + 3, libext);
",1,unused,1307,unused,"	  /* Preloaded modules are always named according to their old
	     archive name.  */
	  if (strncmp(name, ""lib"", 3) == 0)
	    {
	      sprintf (archive_name, ""%s%s.%s"", libprefix, name + 3, libext);
",unused,libtoolsources2.4.6-libltdl2Fltdl.c
"	      sprintf (archive_name, ""%s%s.%s"", libprefix, name + 3, libext);
	    }
	  else
	    {
	      sprintf (archive_name, ""%s.%s"", name, libext);
",1,unused,1311,unused,"	      sprintf (archive_name, ""%s%s.%s"", libprefix, name + 3, libext);
	    }
	  else
	    {
	      sprintf (archive_name, ""%s.%s"", name, libext);
",unused,libtoolsources2.4.6-libltdl2Fltdl.c
"    return ++errors;

  assert (buf);

  strcpy  (buf, dirnam);
",1,unused,1820,unused,"    return ++errors;

  assert (buf);

  strcpy  (buf, dirnam);
",unused,libtoolsources2.4.6-libltdl2Fltdl.c
"
  assert (buf);

  strcpy  (buf, dirnam);
  strcat  (buf, ""/"");
",1,unused,1821,unused,"
  assert (buf);

  strcpy  (buf, dirnam);
  strcat  (buf, ""/"");
",unused,libtoolsources2.4.6-libltdl2Fltdl.c
"
      /* this is a libtool module */
      if (handle->vtable->sym_prefix)
	{
	  strcpy(sym, handle->vtable->sym_prefix);
",1,unused,2063,unused,"
      /* this is a libtool module */
      if (handle->vtable->sym_prefix)
	{
	  strcpy(sym, handle->vtable->sym_prefix);
",unused,libtoolsources2.4.6-libltdl2Fltdl.c
"      /* this is a libtool module */
      if (handle->vtable->sym_prefix)
	{
	  strcpy(sym, handle->vtable->sym_prefix);
	  strcat(sym, handle->info.name);
",1,unused,2064,unused,"      /* this is a libtool module */
      if (handle->vtable->sym_prefix)
	{
	  strcpy(sym, handle->vtable->sym_prefix);
	  strcat(sym, handle->info.name);
",unused,libtoolsources2.4.6-libltdl2Fltdl.c
"	  strcat(sym, handle->info.name);
	}
      else
	{
	  strcpy(sym, handle->info.name);
",1,unused,2068,unused,"	  strcat(sym, handle->info.name);
	}
      else
	{
	  strcpy(sym, handle->info.name);
",unused,libtoolsources2.4.6-libltdl2Fltdl.c
"	{
	  strcpy(sym, handle->info.name);
	}

      strcat(sym, ""_LTX_"");
",1,unused,2071,unused,"	{
	  strcpy(sym, handle->info.name);
	}

      strcat(sym, ""_LTX_"");
",unused,libtoolsources2.4.6-libltdl2Fltdl.c
"	  strcpy(sym, handle->info.name);
	}

      strcat(sym, ""_LTX_"");
      strcat(sym, symbol);
",1,unused,2072,unused,"	  strcpy(sym, handle->info.name);
	}

      strcat(sym, ""_LTX_"");
      strcat(sym, symbol);
",unused,libtoolsources2.4.6-libltdl2Fltdl.c
"
  /* otherwise try ""symbol"" */
  if (handle->vtable->sym_prefix)
    {
      strcpy(sym, handle->vtable->sym_prefix);
",1,unused,2090,unused,"
  /* otherwise try ""symbol"" */
  if (handle->vtable->sym_prefix)
    {
      strcpy(sym, handle->vtable->sym_prefix);
",unused,libtoolsources2.4.6-libltdl2Fltdl.c
"  /* otherwise try ""symbol"" */
  if (handle->vtable->sym_prefix)
    {
      strcpy(sym, handle->vtable->sym_prefix);
      strcat(sym, symbol);
",1,unused,2091,unused,"  /* otherwise try ""symbol"" */
  if (handle->vtable->sym_prefix)
    {
      strcpy(sym, handle->vtable->sym_prefix);
      strcat(sym, symbol);
",unused,libtoolsources2.4.6-libltdl2Fltdl.c
"      strcat(sym, symbol);
    }
  else
    {
      strcpy(sym, symbol);
",1,unused,2095,unused,"      strcat(sym, symbol);
    }
  else
    {
      strcpy(sym, symbol);
",unused,libtoolsources2.4.6-libltdl2Fltdl.c
"    }

    strncpy(keyword, regname, 3);
    if (strlen(regname) == 2)
        strcat(keyword, "" ="");
",1,unused,250,unused,"    }

    strncpy(keyword, regname, 3);
    if (strlen(regname) == 2)
        strcat(keyword, "" ="");
",unused,libvmi-libvmi2Fdriver2Fkvm2Fkvm.c
"    strncpy(keyword, regname, 3);
    if (strlen(regname) == 2)
        strcat(keyword, "" ="");
    else
        strcat(keyword, ""="");
",1,unused,252,unused,"    strncpy(keyword, regname, 3);
    if (strlen(regname) == 2)
        strcat(keyword, "" ="");
    else
        strcat(keyword, ""="");
",unused,libvmi-libvmi2Fdriver2Fkvm2Fkvm.c
"    }

    address.sun_family = AF_UNIX;
    address_length =
        sizeof(address.sun_family) + sprintf(address.sun_path, ""%s"",
",1,unused,387,unused,"    }

    address.sun_family = AF_UNIX;
    address_length =
        sizeof(address.sun_family) + sprintf(address.sun_path, ""%s"",
",unused,libvmi-libvmi2Fdriver2Fkvm2Fkvm.c
"    memset(result, 0, sizeof(result)); /* ""Thu, 26 Jun 2001"" */
                                       /*  0123456789 12345 */

    strncpy(result, str, 20);
    strcpy(result+20, ""???"");          /* tzname doesn't work, fake it */
",1,unused,269,unused,"    memset(result, 0, sizeof(result)); /* ""Thu, 26 Jun 2001"" */
                                       /*  0123456789 12345 */

    strncpy(result, str, 20);
    strcpy(result+20, ""???"");          /* tzname doesn't work, fake it */
",unused,libxslt-1.1.28-libxslt2Fextra.c
"        xmlXPathFreeObject(obj);

    val = (long)((char *)cur - (char *)&base_address);
    if (val >= 0) {
      sprintf((char *)str, ""idp%ld"", val);
",1,unused,722,unused,"        xmlXPathFreeObject(obj);

    val = (long)((char *)cur - (char *)&base_address);
    if (val >= 0) {
      sprintf((char *)str, ""idp%ld"", val);
",unused,libxslt-1.1.28-libxslt2Ffunctions.c
"    val = (long)((char *)cur - (char *)&base_address);
    if (val >= 0) {
      sprintf((char *)str, ""idp%ld"", val);
    } else {
      sprintf((char *)str, ""idm%ld"", -val);
",1,unused,724,unused,"    val = (long)((char *)cur - (char *)&base_address);
    if (val >= 0) {
      sprintf((char *)str, ""idp%ld"", val);
    } else {
      sprintf((char *)str, ""idm%ld"", -val);
",unused,libxslt-1.1.28-libxslt2Ffunctions.c
"              if (templates[k] == templ2)
                break;
            }
            t=templ2?templ2->time:totalt;
            sprintf(times_str,""%8.3f"",(float)t/XSLT_TIMESTAMP_TICS_PER_SEC);
",1,unused,2090,unused,"              if (templates[k] == templ2)
                break;
            }
            t=templ2?templ2->time:totalt;
            sprintf(times_str,""%8.3f"",(float)t/XSLT_TIMESTAMP_TICS_PER_SEC);
",unused,libxslt-1.1.28-libxslt2Fxsltutils.c
"                break;
            }
            t=templ2?templ2->time:totalt;
            sprintf(times_str,""%8.3f"",(float)t/XSLT_TIMESTAMP_TICS_PER_SEC);
            sprintf(timec_str,""%8.3f"",(float)childt[k]/XSLT_TIMESTAMP_TICS_PER_SEC);
",1,unused,2091,unused,"                break;
            }
            t=templ2?templ2->time:totalt;
            sprintf(times_str,""%8.3f"",(float)t/XSLT_TIMESTAMP_TICS_PER_SEC);
            sprintf(timec_str,""%8.3f"",(float)childt[k]/XSLT_TIMESTAMP_TICS_PER_SEC);
",unused,libxslt-1.1.28-libxslt2Fxsltutils.c
"            }
            t=templ2?templ2->time:totalt;
            sprintf(times_str,""%8.3f"",(float)t/XSLT_TIMESTAMP_TICS_PER_SEC);
            sprintf(timec_str,""%8.3f"",(float)childt[k]/XSLT_TIMESTAMP_TICS_PER_SEC);
            sprintf(called_str,""%6d/%d"",
",1,unused,2092,unused,"            }
            t=templ2?templ2->time:totalt;
            sprintf(times_str,""%8.3f"",(float)t/XSLT_TIMESTAMP_TICS_PER_SEC);
            sprintf(timec_str,""%8.3f"",(float)childt[k]/XSLT_TIMESTAMP_TICS_PER_SEC);
            sprintf(called_str,""%6d/%d"",
",unused,libxslt-1.1.28-libxslt2Fxsltutils.c
"                times_str,timec_str,called_str,
                (templ2?(templ2->name?(char *)templ2->name:pretty_templ_match(templ2)):""-""),k);
        }
        /* this */
        sprintf(ix_str,""[%d]"",i);
",1,unused,2101,unused,"                times_str,timec_str,called_str,
                (templ2?(templ2->name?(char *)templ2->name:pretty_templ_match(templ2)):""-""),k);
        }
        /* this */
        sprintf(ix_str,""[%d]"",i);
",unused,libxslt-1.1.28-libxslt2Fxsltutils.c
"                (templ2?(templ2->name?(char *)templ2->name:pretty_templ_match(templ2)):""-""),k);
        }
        /* this */
        sprintf(ix_str,""[%d]"",i);
        sprintf(timep_str,""%6.2f"",(float)templ1->time*100.0/totalt);
",1,unused,2102,unused,"                (templ2?(templ2->name?(char *)templ2->name:pretty_templ_match(templ2)):""-""),k);
        }
        /* this */
        sprintf(ix_str,""[%d]"",i);
        sprintf(timep_str,""%6.2f"",(float)templ1->time*100.0/totalt);
",unused,libxslt-1.1.28-libxslt2Fxsltutils.c
"        }
        /* this */
        sprintf(ix_str,""[%d]"",i);
        sprintf(timep_str,""%6.2f"",(float)templ1->time*100.0/totalt);
        sprintf(times_str,""%8.3f"",(float)templ1->time/XSLT_TIMESTAMP_TICS_PER_SEC);
",1,unused,2103,unused,"        }
        /* this */
        sprintf(ix_str,""[%d]"",i);
        sprintf(timep_str,""%6.2f"",(float)templ1->time*100.0/totalt);
        sprintf(times_str,""%8.3f"",(float)templ1->time/XSLT_TIMESTAMP_TICS_PER_SEC);
",unused,libxslt-1.1.28-libxslt2Fxsltutils.c
"        /* this */
        sprintf(ix_str,""[%d]"",i);
        sprintf(timep_str,""%6.2f"",(float)templ1->time*100.0/totalt);
        sprintf(times_str,""%8.3f"",(float)templ1->time/XSLT_TIMESTAMP_TICS_PER_SEC);
        sprintf(timec_str,""%8.3f"",(float)childt[i]/XSLT_TIMESTAMP_TICS_PER_SEC);
",1,unused,2104,unused,"        /* this */
        sprintf(ix_str,""[%d]"",i);
        sprintf(timep_str,""%6.2f"",(float)templ1->time*100.0/totalt);
        sprintf(times_str,""%8.3f"",(float)templ1->time/XSLT_TIMESTAMP_TICS_PER_SEC);
        sprintf(timec_str,""%8.3f"",(float)childt[i]/XSLT_TIMESTAMP_TICS_PER_SEC);
",unused,libxslt-1.1.28-libxslt2Fxsltutils.c
"        for (k = 0; k < nb; k++) {
            templ2 = templates[k];
            for (l = 0; l < templ2->templNr; l++) {
                if (templ2->templCalledTab[l] == templ1) {
                    sprintf(times_str,""%8.3f"",(float)templ2->time/XSLT_TIMESTAMP_TICS_PER_SEC);
",1,unused,2126,unused,"        for (k = 0; k < nb; k++) {
            templ2 = templates[k];
            for (l = 0; l < templ2->templNr; l++) {
                if (templ2->templCalledTab[l] == templ1) {
                    sprintf(times_str,""%8.3f"",(float)templ2->time/XSLT_TIMESTAMP_TICS_PER_SEC);
",unused,libxslt-1.1.28-libxslt2Fxsltutils.c
"            templ2 = templates[k];
            for (l = 0; l < templ2->templNr; l++) {
                if (templ2->templCalledTab[l] == templ1) {
                    sprintf(times_str,""%8.3f"",(float)templ2->time/XSLT_TIMESTAMP_TICS_PER_SEC);
                    sprintf(timec_str,""%8.3f"",(float)childt[k]/XSLT_TIMESTAMP_TICS_PER_SEC);
",1,unused,2127,unused,"            templ2 = templates[k];
            for (l = 0; l < templ2->templNr; l++) {
                if (templ2->templCalledTab[l] == templ1) {
                    sprintf(times_str,""%8.3f"",(float)templ2->time/XSLT_TIMESTAMP_TICS_PER_SEC);
                    sprintf(timec_str,""%8.3f"",(float)childt[k]/XSLT_TIMESTAMP_TICS_PER_SEC);
",unused,libxslt-1.1.28-libxslt2Fxsltutils.c
"            for (l = 0; l < templ2->templNr; l++) {
                if (templ2->templCalledTab[l] == templ1) {
                    sprintf(times_str,""%8.3f"",(float)templ2->time/XSLT_TIMESTAMP_TICS_PER_SEC);
                    sprintf(timec_str,""%8.3f"",(float)childt[k]/XSLT_TIMESTAMP_TICS_PER_SEC);
                    sprintf(called_str,""%6d/%d"",
",1,unused,2128,unused,"            for (l = 0; l < templ2->templNr; l++) {
                if (templ2->templCalledTab[l] == templ1) {
                    sprintf(times_str,""%8.3f"",(float)templ2->time/XSLT_TIMESTAMP_TICS_PER_SEC);
                    sprintf(timec_str,""%8.3f"",(float)childt[k]/XSLT_TIMESTAMP_TICS_PER_SEC);
                    sprintf(called_str,""%6d/%d"",
",unused,libxslt-1.1.28-libxslt2Fxsltutils.c
"    xmlDocSetRootElement(ret, root);

    for (i = 0; i < nb; i++) {
        child = xmlNewChild(root, NULL, BAD_CAST ""template"", NULL);
        sprintf(buf, ""%d"", i + 1);
",1,unused,2248,unused,"    xmlDocSetRootElement(ret, root);

    for (i = 0; i < nb; i++) {
        child = xmlNewChild(root, NULL, BAD_CAST ""template"", NULL);
        sprintf(buf, ""%d"", i + 1);
",unused,libxslt-1.1.28-libxslt2Fxsltutils.c
"        xmlSetProp(child, BAD_CAST ""match"", BAD_CAST templates[i]->match);
        xmlSetProp(child, BAD_CAST ""name"", BAD_CAST templates[i]->name);
        xmlSetProp(child, BAD_CAST ""mode"", BAD_CAST templates[i]->mode);

        sprintf(buf, ""%d"", templates[i]->nbCalls);
",1,unused,2254,unused,"        xmlSetProp(child, BAD_CAST ""match"", BAD_CAST templates[i]->match);
        xmlSetProp(child, BAD_CAST ""name"", BAD_CAST templates[i]->name);
        xmlSetProp(child, BAD_CAST ""mode"", BAD_CAST templates[i]->mode);

        sprintf(buf, ""%d"", templates[i]->nbCalls);
",unused,libxslt-1.1.28-libxslt2Fxsltutils.c
"
        sprintf(buf, ""%d"", templates[i]->nbCalls);
        xmlSetProp(child, BAD_CAST ""calls"", BAD_CAST buf);

        sprintf(buf, ""%ld"", templates[i]->time);
",1,unused,2257,unused,"
        sprintf(buf, ""%d"", templates[i]->nbCalls);
        xmlSetProp(child, BAD_CAST ""calls"", BAD_CAST buf);

        sprintf(buf, ""%ld"", templates[i]->time);
",unused,libxslt-1.1.28-libxslt2Fxsltutils.c
"
        sprintf(buf, ""%ld"", templates[i]->time);
        xmlSetProp(child, BAD_CAST ""time"", BAD_CAST buf);

        sprintf(buf, ""%ld"", templates[i]->time / templates[i]->nbCalls);
",1,unused,2260,unused,"
        sprintf(buf, ""%ld"", templates[i]->time);
        xmlSetProp(child, BAD_CAST ""time"", BAD_CAST buf);

        sprintf(buf, ""%ld"", templates[i]->time / templates[i]->nbCalls);
",unused,libxslt-1.1.28-libxslt2Fxsltutils.c
"	}
	i = pvalue_to_int(val);
	delete_pvalue_ptr(&val);
	if (i < 1 || i > 26)
		sprintf(scratch, ""_"");
",1,unused,1155,unused,"	}
	i = pvalue_to_int(val);
	delete_pvalue_ptr(&val);
	if (i < 1 || i > 26)
		sprintf(scratch, ""_"");
",unused,lifelines_lifelines-src2Finterp2Fbuiltin.c
"	INT name_length = len - tmp1_length - 1;
	name_length = max(0, name_length);
	name = indi_to_name(indi, name_length);
	ASSERT(name_length + tmp1_length < ARRSIZE(scratch));
	strcpy(scratch, name);
",1,unused,705,unused,"	INT name_length = len - tmp1_length - 1;
	name_length = max(0, name_length);
	name = indi_to_name(indi, name_length);
	ASSERT(name_length + tmp1_length < ARRSIZE(scratch));
	strcpy(scratch, name);
",unused,lifelines_lifelines-src2Fliflines2Fshow.c
"	name_length = max(0, name_length);
	name = indi_to_name(indi, name_length);
	ASSERT(name_length + tmp1_length < ARRSIZE(scratch));
	strcpy(scratch, name);
	strcat(scratch, tmp1);
",1,unused,706,unused,"	name_length = max(0, name_length);
	name = indi_to_name(indi, name_length);
	ASSERT(name_length + tmp1_length < ARRSIZE(scratch));
	strcpy(scratch, name);
	strcat(scratch, tmp1);
",unused,lifelines_lifelines-src2Fliflines2Fshow.c
"	FILE *fi;
	INDEX index;
	INT offset = 0;

	sprintf(scratch, ""%s/aa/aa"", dir);
",1,unused,218,unused,"	FILE *fi;
	INDEX index;
	INT offset = 0;

	sprintf(scratch, ""%s/aa/aa"", dir);
",unused,lifelines_lifelines-src2Ftools2Flldump.c
"	FILE *fb;
	BLOCK block;
	INT offset = 0;

	sprintf(scratch, ""%s/ab/aa"", dir);
",1,unused,302,unused,"	FILE *fb;
	BLOCK block;
	INT offset = 0;

	sprintf(scratch, ""%s/ab/aa"", dir);
",unused,lifelines_lifelines-src2Ftools2Flldump.c
"	KEYFILE2 kfile2;
	FILE *fk;
	long size;

	sprintf(scratch, ""%s/key"", dir);
",1,unused,390,unused,"	KEYFILE2 kfile2;
	FILE *fk;
	long size;

	sprintf(scratch, ""%s/key"", dir);
",unused,lifelines_lifelines-src2Ftools2Flldump.c
"
  // Obtain the errno message.
  (void)memset(errmsg, '\0', sizeof(errmsg));
  if (perr == true) {
    (void)sprintf(errmsg, "": %s"", strerror(save));
",1,unused,184,unused,"
  // Obtain the errno message.
  (void)memset(errmsg, '\0', sizeof(errmsg));
  if (perr == true) {
    (void)sprintf(errmsg, "": %s"", strerror(save));
",unused,lovasko_nemo-core-src2Fcommon2Flog.c
"
  // Format the level name.
  (void)memset(lstr, '\0', sizeof(lstr));
  if (log_col == true) {
    (void)sprintf(lstr, ""\x1b[%dm%s\x1b[0m"", lcol[lvl], lname[lvl]);
",1,unused,190,unused,"
  // Format the level name.
  (void)memset(lstr, '\0', sizeof(lstr));
  if (log_col == true) {
    (void)sprintf(lstr, ""\x1b[%dm%s\x1b[0m"", lcol[lvl], lname[lvl]);
",unused,lovasko_nemo-core-src2Fcommon2Flog.c
"                          res_size = 0;
                          free (old_res_ptr);
                          break;
                        }
                      strcpy (res_ptr + res_size - (l2 + 1) - (l1 + 1), buf1);
",1,unused,239,unused,"                          res_size = 0;
                          free (old_res_ptr);
                          break;
                        }
                      strcpy (res_ptr + res_size - (l2 + 1) - (l1 + 1), buf1);
",unused,m4debianstretche1.18-lib2Flocalcharset.c
"                          free (old_res_ptr);
                          break;
                        }
                      strcpy (res_ptr + res_size - (l2 + 1) - (l1 + 1), buf1);
                      strcpy (res_ptr + res_size - (l2 + 1), buf2);
",1,unused,240,unused,"                          free (old_res_ptr);
                          break;
                        }
                      strcpy (res_ptr + res_size - (l2 + 1) - (l1 + 1), buf1);
                      strcpy (res_ptr + res_size - (l2 + 1), buf2);
",unused,m4debianstretche1.18-lib2Flocalcharset.c
"      return -1;
    }

  memcpy (tmpl, dir, dlen);
  sprintf (tmpl + dlen, &""/%.*sXXXXXX""[!add_slash], (int) plen, pfx);
",1,unused,157,unused,"      return -1;
    }

  memcpy (tmpl, dir, dlen);
  sprintf (tmpl + dlen, &""/%.*sXXXXXX""[!add_slash], (int) plen, pfx);
",unused,m4sources1.18-lib2Ftmpdir.c
"                          res_size = 0;
                          free (old_res_ptr);
                          break;
                        }
                      strcpy (res_ptr + res_size - (l2 + 1) - (l1 + 1), buf1);
",1,unused,238,unused,"                          res_size = 0;
                          free (old_res_ptr);
                          break;
                        }
                      strcpy (res_ptr + res_size - (l2 + 1) - (l1 + 1), buf1);
",unused,m4ubuntuartful1.17-lib2Flocalcharset.c
"                          free (old_res_ptr);
                          break;
                        }
                      strcpy (res_ptr + res_size - (l2 + 1) - (l1 + 1), buf1);
                      strcpy (res_ptr + res_size - (l2 + 1), buf2);
",1,unused,239,unused,"                          free (old_res_ptr);
                          break;
                        }
                      strcpy (res_ptr + res_size - (l2 + 1) - (l1 + 1), buf1);
                      strcpy (res_ptr + res_size - (l2 + 1), buf2);
",unused,m4ubuntuartful1.17-lib2Flocalcharset.c
"      return -1;
    }

  memcpy (tmpl, dir, dlen);
  sprintf (tmpl + dlen, &""/%.*sXXXXXX""[!add_slash], (int) plen, pfx);
",1,unused,157,unused,"      return -1;
    }

  memcpy (tmpl, dir, dlen);
  sprintf (tmpl + dlen, &""/%.*sXXXXXX""[!add_slash], (int) plen, pfx);
",unused,m4ubuntuartful1.17-lib2Ftmpdir.c
"                          res_size = 0;
                          free (old_res_ptr);
                          break;
                        }
                      strcpy (res_ptr + res_size - (l2 + 1) - (l1 + 1), buf1);
",1,unused,238,unused,"                          res_size = 0;
                          free (old_res_ptr);
                          break;
                        }
                      strcpy (res_ptr + res_size - (l2 + 1) - (l1 + 1), buf1);
",unused,m4xenpatch-lib2Flocalcharset.c
"                          free (old_res_ptr);
                          break;
                        }
                      strcpy (res_ptr + res_size - (l2 + 1) - (l1 + 1), buf1);
                      strcpy (res_ptr + res_size - (l2 + 1), buf2);
",1,unused,239,unused,"                          free (old_res_ptr);
                          break;
                        }
                      strcpy (res_ptr + res_size - (l2 + 1) - (l1 + 1), buf1);
                      strcpy (res_ptr + res_size - (l2 + 1), buf2);
",unused,m4xenpatch-lib2Flocalcharset.c
"      return -1;
    }

  memcpy (tmpl, dir, dlen);
  sprintf (tmpl + dlen, &""/%.*sXXXXXX""[!add_slash], (int) plen, pfx);
",1,unused,157,unused,"      return -1;
    }

  memcpy (tmpl, dir, dlen);
  sprintf (tmpl + dlen, &""/%.*sXXXXXX""[!add_slash], (int) plen, pfx);
",unused,m4xenpatch-lib2Ftmpdir.c
"#if defined(ARFMAG) || defined(ARFZMAG) || defined(AIAMAG) || defined(WINDOWS32)
  /* Advance member's time to that time */
  for (ui = 0; ui < sizeof ar_hdr.ar_date; ui++)
    ar_hdr.ar_date[ui] = ' ';
  sprintf (TOCHAR (ar_hdr.ar_date), ""%ld"", (long int) statbuf.st_mtime);
",1,unused,912,unused,"#if defined(ARFMAG) || defined(ARFZMAG) || defined(AIAMAG) || defined(WINDOWS32)
  /* Advance member's time to that time */
  for (ui = 0; ui < sizeof ar_hdr.ar_date; ui++)
    ar_hdr.ar_date[ui] = ' ';
  sprintf (TOCHAR (ar_hdr.ar_date), ""%ld"", (long int) statbuf.st_mtime);
",unused,makedebianstretche4.1-arscan.c
"
  while (find_next_token (&word_iterator, NULL) != 0)
    ++i;

  sprintf (buf, ""%d"", i);
",1,unused,734,unused,"
  while (find_next_token (&word_iterator, NULL) != 0)
    ++i;

  sprintf (buf, ""%d"", i);
",unused,makedebianstretche4.1-function.c
"  p = msg = alloca (len + 1);

  for (argvp=argv; argvp[1] != 0; ++argvp)
    {
      strcpy (p, *argvp);
",1,unused,1113,unused,"  p = msg = alloca (len + 1);

  for (argvp=argv; argvp[1] != 0; ++argvp)
    {
      strcpy (p, *argvp);
",unused,makedebianstretche4.1-function.c
"      p += strlen (*argvp);
      *(p++) = ',';
      *(p++) = ' ';
    }
  strcpy (p, *argvp);
",1,unused,1118,unused,"      p += strlen (*argvp);
      *(p++) = ',';
      *(p++) = ' ';
    }
  strcpy (p, *argvp);
",unused,makedebianstretche4.1-function.c
"  /* For error messages.  */
  if (reading_file && reading_file->filenm)
    {
      char *p = alloca (strlen (reading_file->filenm)+11+4);
      sprintf (p, ""%s:%lu: "", reading_file->filenm, reading_file->lineno);
",1,unused,1712,unused,"  /* For error messages.  */
  if (reading_file && reading_file->filenm)
    {
      char *p = alloca (strlen (reading_file->filenm)+11+4);
      sprintf (p, ""%s:%lu: "", reading_file->filenm, reading_file->lineno);
",unused,makedebianstretche4.1-function.c
"      /* It is unlikely we would make it until here but just to make sure. */
      if (!starting_directory)
        return NULL;

      strcpy (apath, starting_directory);
",1,unused,2024,unused,"      /* It is unlikely we would make it until here but just to make sure. */
      if (!starting_directory)
        return NULL;

      strcpy (apath, starting_directory);
",unused,makedebianstretche4.1-function.c
"  for (i=0; *argv; ++i, ++argv)
    {
      char num[11];

      sprintf (num, ""%d"", i);
",1,unused,2543,unused,"  for (i=0; *argv; ++i, ++argv)
    {
      char num[11];

      sprintf (num, ""%d"", i);
",unused,makedebianstretche4.1-function.c
"  for (; i < max_args; ++i)
    {
      char num[11];

      sprintf (num, ""%d"", i);
",1,unused,2556,unused,"  for (; i < max_args; ++i)
    {
      char num[11];

      sprintf (num, ""%d"", i);
",unused,makedebianstretche4.1-function.c
"              if (! dep->need_2nd_expansion)
                {
                  p = strchr (nptr, '%');
                  if (p == 0)
                    strcpy (depname, nptr);
",1,unused,535,unused,"              if (! dep->need_2nd_expansion)
                {
                  p = strchr (nptr, '%');
                  if (p == 0)
                    strcpy (depname, nptr);
",unused,makedebianstretche4.1-implicit.c
"                      memcpy (o, nptr, p - nptr);
                      o += p - nptr;
                      memcpy (o, stem_str, stemlen);
                      o += stemlen;
                      strcpy (o, p + 1);
",1,unused,548,unused,"                      memcpy (o, nptr, p - nptr);
                      o += p - nptr;
                      memcpy (o, stem_str, stemlen);
                      o += stemlen;
                      strcpy (o, p + 1);
",unused,makedebianstretche4.1-implicit.c
"  /* %Id is only needed for 64-builds, which were not supported by
      older versions of Windows compilers.  */
  sprintf (pidstring, ""%Id"", pid);
#else
  sprintf (pidstring, ""%lu"", (unsigned long) pid);
",1,unused,207,unused,"  /* %Id is only needed for 64-builds, which were not supported by
      older versions of Windows compilers.  */
  sprintf (pidstring, ""%Id"", pid);
#else
  sprintf (pidstring, ""%lu"", (unsigned long) pid);
",unused,makedebianstretche4.1-job.c
"    nm = _(""<builtin>"");
  else
    {
      char *a = alloca (strlen (flocp->filenm) + 1 + 11 + 1);
      sprintf (a, ""%s:%lu"", flocp->filenm, flocp->lineno);
",1,unused,504,unused,"    nm = _(""<builtin>"");
  else
    {
      char *a = alloca (strlen (flocp->filenm) + 1 + 11 + 1);
      sprintf (a, ""%s:%lu"", flocp->filenm, flocp->lineno);
",unused,makedebianstretche4.1-job.c
"        nm = _(""<builtin>"");
      else
        {
          char *n = alloca (strlen (cmds->fileinfo.filenm) + 1 + 11 + 1);
          sprintf (n, ""%s:%lu"", cmds->fileinfo.filenm, cmds->fileinfo.lineno);
",1,unused,2066,unused,"        nm = _(""<builtin>"");
      else
        {
          char *n = alloca (strlen (cmds->fileinfo.filenm) + 1 + 11 + 1);
          sprintf (n, ""%s:%lu"", cmds->fileinfo.filenm, cmds->fileinfo.lineno);
",unused,makedebianstretche4.1-job.c
"       unsigned j;
       memcpy (ap, eval_line, sizeof (eval_line) - 1);
       ap += sizeof (eval_line) - 1;
       for (j = 1; j <= 2 * line_len / (MAX_ARG_STRLEN - 2); j++)
         ap += sprintf (ap, ""\\$\\{%u\\}"", j);
",1,unused,3338,unused,"       unsigned j;
       memcpy (ap, eval_line, sizeof (eval_line) - 1);
       ap += sizeof (eval_line) - 1;
       for (j = 1; j <= 2 * line_len / (MAX_ARG_STRLEN - 2); j++)
         ap += sprintf (ap, ""\\$\\{%u\\}"", j);
",unused,makedebianstretche4.1-job.c
"      else
        ++fp;
      while (isalnum (*fp) || *fp == '_')
        *(p++) = *(fp++);
      strcpy (p, SYMBOL_EXTENSION);
",1,unused,201,unused,"      else
        ++fp;
      while (isalnum (*fp) || *fp == '_')
        *(p++) = *(fp++);
      strcpy (p, SYMBOL_EXTENSION);
",unused,makedebianstretche4.1-load.c
"               )
              tmpdir = DEFAULT_TMPDIR;

            template = alloca (strlen (tmpdir) + CSTRLEN (DEFAULT_TMPFILE) + 2);
            strcpy (template, tmpdir);
",1,unused,1770,unused,"               )
              tmpdir = DEFAULT_TMPDIR;

            template = alloca (strlen (tmpdir) + CSTRLEN (DEFAULT_TMPFILE) + 2);
            strcpy (template, tmpdir);
",unused,makedebianstretche4.1-main.c
"              strcat (template, ""/"");
#else
# ifndef VMS
            if (template[strlen (template) - 1] != '/')
              strcat (template, ""/"");
",1,unused,1778,unused,"              strcat (template, ""/"");
#else
# ifndef VMS
            if (template[strlen (template) - 1] != '/')
              strcat (template, ""/"");
",unused,makedebianstretche4.1-main.c
"              strcat (template, ""/"");
# endif /* !VMS */
#endif /* !HAVE_DOS_PATHS */

            strcat (template, DEFAULT_TMPFILE);
",1,unused,1782,unused,"              strcat (template, ""/"");
# endif /* !VMS */
#endif /* !HAVE_DOS_PATHS */

            strcat (template, DEFAULT_TMPFILE);
",unused,makedebianstretche4.1-main.c
"
      p = value = alloca (len);
      for (i = 0; i < eval_strings->idx; ++i)
        {
          strcpy (p, ""--eval="");
",1,unused,1888,unused,"
      p = value = alloca (len);
      for (i = 0; i < eval_strings->idx; ++i)
        {
          strcpy (p, ""--eval="");
",unused,makedebianstretche4.1-main.c
"      jobserver_fds = xmalloc (MAX_PATH + 1);
      strcpy (jobserver_fds, get_jobserver_semaphore_name ());
#else
      jobserver_fds = xmalloc ((INTSTR_LENGTH * 2) + 2);
      sprintf (jobserver_fds, ""%d,%d"", job_fds[0], job_fds[1]);
",1,unused,2044,unused,"      jobserver_fds = xmalloc (MAX_PATH + 1);
      strcpy (jobserver_fds, get_jobserver_semaphore_name ());
#else
      jobserver_fds = xmalloc ((INTSTR_LENGTH * 2) + 2);
      sprintf (jobserver_fds, ""%d,%d"", job_fds[0], job_fds[1]);
",unused,makedebianstretche4.1-main.c
"              {
                if (strneq (*p, MAKELEVEL_NAME ""="", MAKELEVEL_LENGTH+1))
                  {
                    *p = alloca (40);
                    sprintf (*p, ""%s=%u"", MAKELEVEL_NAME, makelevel);
",1,unused,2362,unused,"              {
                if (strneq (*p, MAKELEVEL_NAME ""="", MAKELEVEL_LENGTH+1))
                  {
                    *p = alloca (40);
                    sprintf (*p, ""%s=%u"", MAKELEVEL_NAME, makelevel);
",unused,makedebianstretche4.1-main.c
"                  }
                else if (strneq (*p, ""MAKE_RESTARTS="", CSTRLEN (""MAKE_RESTARTS="")))
                  {
                    *p = alloca (40);
                    sprintf (*p, ""MAKE_RESTARTS=%s%u"",
",1,unused,2367,unused,"                  }
                else if (strneq (*p, ""MAKE_RESTARTS="", CSTRLEN (""MAKE_RESTARTS="")))
                  {
                    *p = alloca (40);
                    sprintf (*p, ""MAKE_RESTARTS=%s%u"",
",unused,makedebianstretche4.1-main.c
"          /* If we didn't set the restarts variable yet, add it.  */
          if (restarts)
            {
              char *b = alloca (40);
              sprintf (b, ""MAKE_RESTARTS=%s%u"",
",1,unused,2390,unused,"          /* If we didn't set the restarts variable yet, add it.  */
          if (restarts)
            {
              char *b = alloca (40);
              sprintf (b, ""MAKE_RESTARTS=%s%u"",
",unused,makedebianstretche4.1-main.c
"                ADD_FLAG ("""", 0); /* Optional value omitted; see below.  */
              else
                {
                  char *buf = alloca (30);
                  sprintf (buf, ""%u"", *(unsigned int *) cs->value_ptr);
",1,unused,3101,unused,"                ADD_FLAG ("""", 0); /* Optional value omitted; see below.  */
              else
                {
                  char *buf = alloca (30);
                  sprintf (buf, ""%u"", *(unsigned int *) cs->value_ptr);
",unused,makedebianstretche4.1-main.c
"                ADD_FLAG ("""", 0); /* Optional value omitted; see below.  */
              else
                {
                  char *buf = alloca (100);
                  sprintf (buf, ""%g"", *(double *) cs->value_ptr);
",1,unused,3122,unused,"                ADD_FLAG ("""", 0); /* Optional value omitted; see below.  */
              else
                {
                  char *buf = alloca (100);
                  sprintf (buf, ""%g"", *(double *) cs->value_ptr);
",unused,makedebianstretche4.1-main.c
"      else
        {
          /* Long options require a double-dash.  */
          *p++ = '-';
          strcpy (p, flags->cs->long_name);
",1,unused,3190,unused,"      else
        {
          /* Long options require a double-dash.  */
          *p++ = '-';
          strcpy (p, flags->cs->long_name);
",unused,makedebianstretche4.1-main.c
"      /* Write a reference to $(MAKEOVERRIDES), which contains all the
         command-line variable definitions.  Separate the variables from the
         switches with a ""--"" arg.  */

      strcpy (p, "" -- "");
",1,unused,3233,unused,"      /* Write a reference to $(MAKEOVERRIDES), which contains all the
         command-line variable definitions.  Separate the variables from the
         switches with a ""--"" arg.  */

      strcpy (p, "" -- "");
",unused,makedebianstretche4.1-main.c
"    }

  if (makelevel == 0)
    if (starting_directory == 0)
      sprintf (p, fmt , program);
",1,unused,141,unused,"    }

  if (makelevel == 0)
    if (starting_directory == 0)
      sprintf (p, fmt , program);
",unused,makedebianstretche4.1-output.c
"  if (makelevel == 0)
    if (starting_directory == 0)
      sprintf (p, fmt , program);
    else
      sprintf (p, fmt, program, starting_directory);
",1,unused,143,unused,"  if (makelevel == 0)
    if (starting_directory == 0)
      sprintf (p, fmt , program);
    else
      sprintf (p, fmt, program, starting_directory);
",unused,makedebianstretche4.1-output.c
"      sprintf (p, fmt , program);
    else
      sprintf (p, fmt, program, starting_directory);
  else if (starting_directory == 0)
    sprintf (p, fmt, program, makelevel);
",1,unused,145,unused,"      sprintf (p, fmt , program);
    else
      sprintf (p, fmt, program, starting_directory);
  else if (starting_directory == 0)
    sprintf (p, fmt, program, makelevel);
",unused,makedebianstretche4.1-output.c
"      sprintf (p, fmt, program, starting_directory);
  else if (starting_directory == 0)
    sprintf (p, fmt, program, makelevel);
  else
    sprintf (p, fmt, program, makelevel, starting_directory);
",1,unused,147,unused,"      sprintf (p, fmt, program, starting_directory);
  else if (starting_directory == 0)
    sprintf (p, fmt, program, makelevel);
  else
    sprintf (p, fmt, program, makelevel, starting_directory);
",unused,makedebianstretche4.1-output.c
"#else
# define TEMPLATE_LEN   L_tmpnam
#endif
  *name = xmalloc (TEMPLATE_LEN + 1);
  strcpy (*name, template);
",1,unused,427,unused,"#else
# define TEMPLATE_LEN   L_tmpnam
#endif
  *name = xmalloc (TEMPLATE_LEN + 1);
  strcpy (*name, template);
",unused,makedebianstretche4.1-output.c
"
  if (prefix)
    {
      if (makelevel == 0)
        sprintf (p, ""%s: "", program);
",1,unused,624,unused,"
  if (prefix)
    {
      if (makelevel == 0)
        sprintf (p, ""%s: "", program);
",unused,makedebianstretche4.1-output.c
"    {
      if (makelevel == 0)
        sprintf (p, ""%s: "", program);
      else
        sprintf (p, ""%s[%u]: "", program, makelevel);
",1,unused,626,unused,"    {
      if (makelevel == 0)
        sprintf (p, ""%s: "", program);
      else
        sprintf (p, ""%s[%u]: "", program, makelevel);
",unused,makedebianstretche4.1-output.c
"  va_start (args, fmt);
  vsprintf (p, fmt, args);
  va_end (args);

  strcat (p, ""\n"");
",1,unused,634,unused,"  va_start (args, fmt);
  vsprintf (p, fmt, args);
  va_end (args);

  strcat (p, ""\n"");
",unused,makedebianstretche4.1-output.c
"          + INTSTR_LENGTH + 4 + 1 + 1);
  p = get_buffer (len);

  if (flocp && flocp->filenm)
    sprintf (p, ""%s:%lu: "", flocp->filenm, flocp->lineno);
",1,unused,654,unused,"          + INTSTR_LENGTH + 4 + 1 + 1);
  p = get_buffer (len);

  if (flocp && flocp->filenm)
    sprintf (p, ""%s:%lu: "", flocp->filenm, flocp->lineno);
",unused,makedebianstretche4.1-output.c
"
  if (flocp && flocp->filenm)
    sprintf (p, ""%s:%lu: "", flocp->filenm, flocp->lineno);
  else if (makelevel == 0)
    sprintf (p, ""%s: "", program);
",1,unused,656,unused,"
  if (flocp && flocp->filenm)
    sprintf (p, ""%s:%lu: "", flocp->filenm, flocp->lineno);
  else if (makelevel == 0)
    sprintf (p, ""%s: "", program);
",unused,makedebianstretche4.1-output.c
"    sprintf (p, ""%s:%lu: "", flocp->filenm, flocp->lineno);
  else if (makelevel == 0)
    sprintf (p, ""%s: "", program);
  else
    sprintf (p, ""%s[%u]: "", program, makelevel);
",1,unused,658,unused,"    sprintf (p, ""%s:%lu: "", flocp->filenm, flocp->lineno);
  else if (makelevel == 0)
    sprintf (p, ""%s: "", program);
  else
    sprintf (p, ""%s[%u]: "", program, makelevel);
",unused,makedebianstretche4.1-output.c
"  va_start (args, fmt);
  vsprintf (p, fmt, args);
  va_end (args);

  strcat (p, ""\n"");
",1,unused,665,unused,"  va_start (args, fmt);
  vsprintf (p, fmt, args);
  va_end (args);

  strcat (p, ""\n"");
",unused,makedebianstretche4.1-output.c
"          + INTSTR_LENGTH + 8 + strlen (stop) + 1);
  p = get_buffer (len);

  if (flocp && flocp->filenm)
    sprintf (p, ""%s:%lu: *** "", flocp->filenm, flocp->lineno);
",1,unused,686,unused,"          + INTSTR_LENGTH + 8 + strlen (stop) + 1);
  p = get_buffer (len);

  if (flocp && flocp->filenm)
    sprintf (p, ""%s:%lu: *** "", flocp->filenm, flocp->lineno);
",unused,makedebianstretche4.1-output.c
"
  if (flocp && flocp->filenm)
    sprintf (p, ""%s:%lu: *** "", flocp->filenm, flocp->lineno);
  else if (makelevel == 0)
    sprintf (p, ""%s: *** "", program);
",1,unused,688,unused,"
  if (flocp && flocp->filenm)
    sprintf (p, ""%s:%lu: *** "", flocp->filenm, flocp->lineno);
  else if (makelevel == 0)
    sprintf (p, ""%s: *** "", program);
",unused,makedebianstretche4.1-output.c
"    sprintf (p, ""%s:%lu: *** "", flocp->filenm, flocp->lineno);
  else if (makelevel == 0)
    sprintf (p, ""%s: *** "", program);
  else
    sprintf (p, ""%s[%u]: *** "", program, makelevel);
",1,unused,690,unused,"    sprintf (p, ""%s:%lu: *** "", flocp->filenm, flocp->lineno);
  else if (makelevel == 0)
    sprintf (p, ""%s: *** "", program);
  else
    sprintf (p, ""%s[%u]: *** "", program, makelevel);
",unused,makedebianstretche4.1-output.c
"  va_start (args, fmt);
  vsprintf (p, fmt, args);
  va_end (args);

  strcat (p, stop);
",1,unused,697,unused,"  va_start (args, fmt);
  vsprintf (p, fmt, args);
  va_end (args);

  strcat (p, stop);
",unused,makedebianstretche4.1-output.c
"          free (collapsed);
          /* Don't need xrealloc: we don't need to preserve the content.  */
          collapsed = xmalloc (collapsed_length);
        }
      strcpy (collapsed, line);
",1,unused,715,unused,"          free (collapsed);
          /* Don't need xrealloc: we don't need to preserve the content.  */
          collapsed = xmalloc (collapsed_length);
        }
      strcpy (collapsed, line);
",unused,makedebianstretche4.1-read.c
"                    / 1e9));
              char from_now_string[100];

              if (from_now >= 99 && from_now <= ULONG_MAX)
                sprintf (from_now_string, ""%lu"", (unsigned long) from_now);
",1,unused,1413,unused,"                    / 1e9));
              char from_now_string[100];

              if (from_now >= 99 && from_now <= ULONG_MAX)
                sprintf (from_now_string, ""%lu"", (unsigned long) from_now);
",unused,makedebianstretche4.1-remake.c
"
              if (from_now >= 99 && from_now <= ULONG_MAX)
                sprintf (from_now_string, ""%lu"", (unsigned long) from_now);
              else
                sprintf (from_now_string, ""%.2g"", from_now);
",1,unused,1415,unused,"
              if (from_now >= 99 && from_now <= ULONG_MAX)
                sprintf (from_now_string, ""%lu"", (unsigned long) from_now);
              else
                sprintf (from_now_string, ""%.2g"", from_now);
",unused,makedebianstretche4.1-remake.c
"         Note that we have already successfully dereferenced all the links
         above.  So, if we run into any error trying to lstat(), or
         readlink(), or whatever, something bizarre-o happened.  Just give up
         and use whatever mtime we've already computed at that point.  */
      strcpy (lpath, name);
",1,unused,1492,unused,"         Note that we have already successfully dereferenced all the links
         above.  So, if we run into any error trying to lstat(), or
         readlink(), or whatever, something bizarre-o happened.  Just give up
         and use whatever mtime we've already computed at that point.  */
      strcpy (lpath, name);
",unused,makedebianstretche4.1-remake.c
"          /* If the target is fully-qualified or the source is just a
             filename, then the new path is the target.  Otherwise it's the
             source directory plus the target.  */
          if (lbuf[0] == '/' || (p = strrchr (lpath, '/')) == NULL)
            strcpy (lpath, lbuf);
",1,unused,1533,unused,"          /* If the target is fully-qualified or the source is just a
             filename, then the new path is the target.  Otherwise it's the
             source directory plus the target.  */
          if (lbuf[0] == '/' || (p = strrchr (lpath, '/')) == NULL)
            strcpy (lpath, lbuf);
",unused,makedebianstretche4.1-remake.c
"            /* Eh?  Path too long!  Again, just go with what we have.  */
            break;
          else
            /* Create the next step in the symlink chain.  */
            strcpy (p+1, lbuf);
",1,unused,1539,unused,"            /* Eh?  Path too long!  Again, just go with what we have.  */
            break;
          else
            /* Create the next step in the symlink chain.  */
            strcpy (p+1, lbuf);
",unused,makedebianstretche4.1-remake.c
"        unsigned int vpath_index = ~((unsigned int)0) - std_dirs;

        for (dp = dirs; *dp != 0; ++dp)
          {
            sprintf (buf, ""%s/%s"", *dp, libbuf);
",1,unused,1701,unused,"        unsigned int vpath_index = ~((unsigned int)0) - std_dirs;

        for (dp = dirs; *dp != 0; ++dp)
          {
            sprintf (buf, ""%s/%s"", *dp, libbuf);
",unused,makedebianstretche4.1-remake.c
"  extern const char* default_shell;
  struct variable *v;
  char buf[200];

  sprintf (buf, ""%u"", makelevel);
",1,unused,791,unused,"  extern const char* default_shell;
  struct variable *v;
  char buf[200];

  sprintf (buf, ""%u"", makelevel);
",unused,makedebianstretche4.1-variable.c
"
  sprintf (buf, ""%u"", makelevel);
  define_variable_cname (MAKELEVEL_NAME, buf, o_env, 0);

  sprintf (buf, ""%s%s%s"",
",1,unused,794,unused,"
  sprintf (buf, ""%u"", makelevel);
  define_variable_cname (MAKELEVEL_NAME, buf, o_env, 0);

  sprintf (buf, ""%s%s%s"",
",unused,makedebianstretche4.1-variable.c
"          }
      }

  *result = xmalloc (100);
  sprintf (*result, ""%s=%u"", MAKELEVEL_NAME, makelevel + 1);
",1,unused,1083,unused,"          }
      }

  *result = xmalloc (100);
  sprintf (*result, ""%s=%u"", MAKELEVEL_NAME, makelevel + 1);
",unused,makedebianstretche4.1-variable.c
"    {
      int l = strlen (file->name);
      char *t = alloca (l + 3);

      strcpy (t, file->name);
",1,unused,1744,unused,"    {
      int l = strlen (file->name);
      char *t = alloca (l + 3);

      strcpy (t, file->name);
",unused,makedebianstretche4.1-variable.c
"#if defined(ARFMAG) || defined(ARFZMAG) || defined(AIAMAG) || defined(WINDOWS32)
  /* Advance member's time to that time */
  for (ui = 0; ui < sizeof ar_hdr.ar_date; ui++)
    ar_hdr.ar_date[ui] = ' ';
  sprintf (TOCHAR (ar_hdr.ar_date), ""%ld"", (long int) statbuf.st_mtime);
",1,unused,912,unused,"#if defined(ARFMAG) || defined(ARFZMAG) || defined(AIAMAG) || defined(WINDOWS32)
  /* Advance member's time to that time */
  for (ui = 0; ui < sizeof ar_hdr.ar_date; ui++)
    ar_hdr.ar_date[ui] = ' ';
  sprintf (TOCHAR (ar_hdr.ar_date), ""%ld"", (long int) statbuf.st_mtime);
",unused,makepatchxen-arscan.c
"  time_t t = FILE_TIMESTAMP_S (ts);
  struct tm *tm = localtime (&t);

  if (tm)
    sprintf (p, ""%04d-%02d-%02d %02d:%02d:%02d"",
",1,unused,880,unused,"  time_t t = FILE_TIMESTAMP_S (ts);
  struct tm *tm = localtime (&t);

  if (tm)
    sprintf (p, ""%04d-%02d-%02d %02d:%02d:%02d"",
",unused,makepatchxen-file.c
"    sprintf (p, ""%04d-%02d-%02d %02d:%02d:%02d"",
             tm->tm_year + 1900, tm->tm_mon + 1, tm->tm_mday,
             tm->tm_hour, tm->tm_min, tm->tm_sec);
  else if (t < 0)
    sprintf (p, ""%ld"", (long) t);
",1,unused,884,unused,"    sprintf (p, ""%04d-%02d-%02d %02d:%02d:%02d"",
             tm->tm_year + 1900, tm->tm_mon + 1, tm->tm_mday,
             tm->tm_hour, tm->tm_min, tm->tm_sec);
  else if (t < 0)
    sprintf (p, ""%ld"", (long) t);
",unused,makepatchxen-file.c
"             tm->tm_hour, tm->tm_min, tm->tm_sec);
  else if (t < 0)
    sprintf (p, ""%ld"", (long) t);
  else
    sprintf (p, ""%lu"", (unsigned long) t);
",1,unused,886,unused,"             tm->tm_hour, tm->tm_min, tm->tm_sec);
  else if (t < 0)
    sprintf (p, ""%ld"", (long) t);
  else
    sprintf (p, ""%lu"", (unsigned long) t);
",unused,makepatchxen-file.c
"  /* Append nanoseconds as a fraction, but remove trailing zeros.  We don't
     know the actual timestamp resolution, since clock_getres applies only to
     local times, whereas this timestamp might come from a remote filesystem.
     So removing trailing zeros is the best guess that we can do.  */
  sprintf (p, "".%09d"", FILE_TIMESTAMP_NS (ts));
",1,unused,893,unused,"  /* Append nanoseconds as a fraction, but remove trailing zeros.  We don't
     know the actual timestamp resolution, since clock_getres applies only to
     local times, whereas this timestamp might come from a remote filesystem.
     So removing trailing zeros is the best guess that we can do.  */
  sprintf (p, "".%09d"", FILE_TIMESTAMP_NS (ts));
",unused,makepatchxen-file.c
"
  while (find_next_token (&word_iterator, NULL) != 0)
    ++i;

  sprintf (buf, ""%d"", i);
",1,unused,734,unused,"
  while (find_next_token (&word_iterator, NULL) != 0)
    ++i;

  sprintf (buf, ""%d"", i);
",unused,makepatchxen-function.c
"  p = msg = alloca (len + 1);

  for (argvp=argv; argvp[1] != 0; ++argvp)
    {
      strcpy (p, *argvp);
",1,unused,1113,unused,"  p = msg = alloca (len + 1);

  for (argvp=argv; argvp[1] != 0; ++argvp)
    {
      strcpy (p, *argvp);
",unused,makepatchxen-function.c
"      p += strlen (*argvp);
      *(p++) = ',';
      *(p++) = ' ';
    }
  strcpy (p, *argvp);
",1,unused,1118,unused,"      p += strlen (*argvp);
      *(p++) = ',';
      *(p++) = ' ';
    }
  strcpy (p, *argvp);
",unused,makepatchxen-function.c
"  /* For error messages.  */
  if (reading_file && reading_file->filenm)
    {
      char *p = alloca (strlen (reading_file->filenm)+11+4);
      sprintf (p, ""%s:%lu: "", reading_file->filenm, reading_file->lineno);
",1,unused,1712,unused,"  /* For error messages.  */
  if (reading_file && reading_file->filenm)
    {
      char *p = alloca (strlen (reading_file->filenm)+11+4);
      sprintf (p, ""%s:%lu: "", reading_file->filenm, reading_file->lineno);
",unused,makepatchxen-function.c
"      /* It is unlikely we would make it until here but just to make sure. */
      if (!starting_directory)
        return NULL;

      strcpy (apath, starting_directory);
",1,unused,2024,unused,"      /* It is unlikely we would make it until here but just to make sure. */
      if (!starting_directory)
        return NULL;

      strcpy (apath, starting_directory);
",unused,makepatchxen-function.c
"  for (i=0; *argv; ++i, ++argv)
    {
      char num[11];

      sprintf (num, ""%d"", i);
",1,unused,2543,unused,"  for (i=0; *argv; ++i, ++argv)
    {
      char num[11];

      sprintf (num, ""%d"", i);
",unused,makepatchxen-function.c
"  for (; i < max_args; ++i)
    {
      char num[11];

      sprintf (num, ""%d"", i);
",1,unused,2556,unused,"  for (; i < max_args; ++i)
    {
      char num[11];

      sprintf (num, ""%d"", i);
",unused,makepatchxen-function.c
"  /* %Id is only needed for 64-builds, which were not supported by
      older versions of Windows compilers.  */
  sprintf (pidstring, ""%Id"", pid);
#else
  sprintf (pidstring, ""%lu"", (unsigned long) pid);
",1,unused,207,unused,"  /* %Id is only needed for 64-builds, which were not supported by
      older versions of Windows compilers.  */
  sprintf (pidstring, ""%Id"", pid);
#else
  sprintf (pidstring, ""%lu"", (unsigned long) pid);
",unused,makepatchxen-job.c
"    nm = _(""<builtin>"");
  else
    {
      char *a = alloca (strlen (flocp->filenm) + 1 + 11 + 1);
      sprintf (a, ""%s:%lu"", flocp->filenm, flocp->lineno);
",1,unused,504,unused,"    nm = _(""<builtin>"");
  else
    {
      char *a = alloca (strlen (flocp->filenm) + 1 + 11 + 1);
      sprintf (a, ""%s:%lu"", flocp->filenm, flocp->lineno);
",unused,makepatchxen-job.c
"        nm = _(""<builtin>"");
      else
        {
          char *n = alloca (strlen (cmds->fileinfo.filenm) + 1 + 11 + 1);
          sprintf (n, ""%s:%lu"", cmds->fileinfo.filenm, cmds->fileinfo.lineno);
",1,unused,2058,unused,"        nm = _(""<builtin>"");
      else
        {
          char *n = alloca (strlen (cmds->fileinfo.filenm) + 1 + 11 + 1);
          sprintf (n, ""%s:%lu"", cmds->fileinfo.filenm, cmds->fileinfo.lineno);
",unused,makepatchxen-job.c
"       unsigned j;
       memcpy (ap, eval_line, sizeof (eval_line) - 1);
       ap += sizeof (eval_line) - 1;
       for (j = 1; j <= 2 * line_len / (MAX_ARG_STRLEN - 2); j++)
         ap += sprintf (ap, ""\\$\\{%u\\}"", j);
",1,unused,3330,unused,"       unsigned j;
       memcpy (ap, eval_line, sizeof (eval_line) - 1);
       ap += sizeof (eval_line) - 1;
       for (j = 1; j <= 2 * line_len / (MAX_ARG_STRLEN - 2); j++)
         ap += sprintf (ap, ""\\$\\{%u\\}"", j);
",unused,makepatchxen-job.c
"               )
              tmpdir = DEFAULT_TMPDIR;

            template = alloca (strlen (tmpdir) + CSTRLEN (DEFAULT_TMPFILE) + 2);
            strcpy (template, tmpdir);
",1,unused,1770,unused,"               )
              tmpdir = DEFAULT_TMPDIR;

            template = alloca (strlen (tmpdir) + CSTRLEN (DEFAULT_TMPFILE) + 2);
            strcpy (template, tmpdir);
",unused,makepatchxen-main.c
"              strcat (template, ""/"");
#else
# ifndef VMS
            if (template[strlen (template) - 1] != '/')
              strcat (template, ""/"");
",1,unused,1778,unused,"              strcat (template, ""/"");
#else
# ifndef VMS
            if (template[strlen (template) - 1] != '/')
              strcat (template, ""/"");
",unused,makepatchxen-main.c
"              strcat (template, ""/"");
# endif /* !VMS */
#endif /* !HAVE_DOS_PATHS */

            strcat (template, DEFAULT_TMPFILE);
",1,unused,1782,unused,"              strcat (template, ""/"");
# endif /* !VMS */
#endif /* !HAVE_DOS_PATHS */

            strcat (template, DEFAULT_TMPFILE);
",unused,makepatchxen-main.c
"
      p = value = alloca (len);
      for (i = 0; i < eval_strings->idx; ++i)
        {
          strcpy (p, ""--eval="");
",1,unused,1888,unused,"
      p = value = alloca (len);
      for (i = 0; i < eval_strings->idx; ++i)
        {
          strcpy (p, ""--eval="");
",unused,makepatchxen-main.c
"      jobserver_fds = xmalloc (MAX_PATH + 1);
      strcpy (jobserver_fds, get_jobserver_semaphore_name ());
#else
      jobserver_fds = xmalloc ((INTSTR_LENGTH * 2) + 2);
      sprintf (jobserver_fds, ""%d,%d"", job_fds[0], job_fds[1]);
",1,unused,2044,unused,"      jobserver_fds = xmalloc (MAX_PATH + 1);
      strcpy (jobserver_fds, get_jobserver_semaphore_name ());
#else
      jobserver_fds = xmalloc ((INTSTR_LENGTH * 2) + 2);
      sprintf (jobserver_fds, ""%d,%d"", job_fds[0], job_fds[1]);
",unused,makepatchxen-main.c
"              {
                if (strneq (*p, MAKELEVEL_NAME ""="", MAKELEVEL_LENGTH+1))
                  {
                    *p = alloca (40);
                    sprintf (*p, ""%s=%u"", MAKELEVEL_NAME, makelevel);
",1,unused,2362,unused,"              {
                if (strneq (*p, MAKELEVEL_NAME ""="", MAKELEVEL_LENGTH+1))
                  {
                    *p = alloca (40);
                    sprintf (*p, ""%s=%u"", MAKELEVEL_NAME, makelevel);
",unused,makepatchxen-main.c
"                  }
                else if (strneq (*p, ""MAKE_RESTARTS="", CSTRLEN (""MAKE_RESTARTS="")))
                  {
                    *p = alloca (40);
                    sprintf (*p, ""MAKE_RESTARTS=%s%u"",
",1,unused,2367,unused,"                  }
                else if (strneq (*p, ""MAKE_RESTARTS="", CSTRLEN (""MAKE_RESTARTS="")))
                  {
                    *p = alloca (40);
                    sprintf (*p, ""MAKE_RESTARTS=%s%u"",
",unused,makepatchxen-main.c
"          /* If we didn't set the restarts variable yet, add it.  */
          if (restarts)
            {
              char *b = alloca (40);
              sprintf (b, ""MAKE_RESTARTS=%s%u"",
",1,unused,2390,unused,"          /* If we didn't set the restarts variable yet, add it.  */
          if (restarts)
            {
              char *b = alloca (40);
              sprintf (b, ""MAKE_RESTARTS=%s%u"",
",unused,makepatchxen-main.c
"                ADD_FLAG ("""", 0); /* Optional value omitted; see below.  */
              else
                {
                  char *buf = alloca (30);
                  sprintf (buf, ""%u"", *(unsigned int *) cs->value_ptr);
",1,unused,3096,unused,"                ADD_FLAG ("""", 0); /* Optional value omitted; see below.  */
              else
                {
                  char *buf = alloca (30);
                  sprintf (buf, ""%u"", *(unsigned int *) cs->value_ptr);
",unused,makepatchxen-main.c
"                ADD_FLAG ("""", 0); /* Optional value omitted; see below.  */
              else
                {
                  char *buf = alloca (100);
                  sprintf (buf, ""%g"", *(double *) cs->value_ptr);
",1,unused,3117,unused,"                ADD_FLAG ("""", 0); /* Optional value omitted; see below.  */
              else
                {
                  char *buf = alloca (100);
                  sprintf (buf, ""%g"", *(double *) cs->value_ptr);
",unused,makepatchxen-main.c
"      else
        {
          /* Long options require a double-dash.  */
          *p++ = '-';
          strcpy (p, flags->cs->long_name);
",1,unused,3185,unused,"      else
        {
          /* Long options require a double-dash.  */
          *p++ = '-';
          strcpy (p, flags->cs->long_name);
",unused,makepatchxen-main.c
"      /* Write a reference to $(MAKEOVERRIDES), which contains all the
         command-line variable definitions.  Separate the variables from the
         switches with a ""--"" arg.  */

      strcpy (p, "" -- "");
",1,unused,3228,unused,"      /* Write a reference to $(MAKEOVERRIDES), which contains all the
         command-line variable definitions.  Separate the variables from the
         switches with a ""--"" arg.  */

      strcpy (p, "" -- "");
",unused,makepatchxen-main.c
"    }

  if (makelevel == 0)
    if (starting_directory == 0)
      sprintf (p, fmt , program);
",1,unused,141,unused,"    }

  if (makelevel == 0)
    if (starting_directory == 0)
      sprintf (p, fmt , program);
",unused,makepatchxen-output.c
"  if (makelevel == 0)
    if (starting_directory == 0)
      sprintf (p, fmt , program);
    else
      sprintf (p, fmt, program, starting_directory);
",1,unused,143,unused,"  if (makelevel == 0)
    if (starting_directory == 0)
      sprintf (p, fmt , program);
    else
      sprintf (p, fmt, program, starting_directory);
",unused,makepatchxen-output.c
"      sprintf (p, fmt , program);
    else
      sprintf (p, fmt, program, starting_directory);
  else if (starting_directory == 0)
    sprintf (p, fmt, program, makelevel);
",1,unused,145,unused,"      sprintf (p, fmt , program);
    else
      sprintf (p, fmt, program, starting_directory);
  else if (starting_directory == 0)
    sprintf (p, fmt, program, makelevel);
",unused,makepatchxen-output.c
"      sprintf (p, fmt, program, starting_directory);
  else if (starting_directory == 0)
    sprintf (p, fmt, program, makelevel);
  else
    sprintf (p, fmt, program, makelevel, starting_directory);
",1,unused,147,unused,"      sprintf (p, fmt, program, starting_directory);
  else if (starting_directory == 0)
    sprintf (p, fmt, program, makelevel);
  else
    sprintf (p, fmt, program, makelevel, starting_directory);
",unused,makepatchxen-output.c
"#else
# define TEMPLATE_LEN   L_tmpnam
#endif
  *name = xmalloc (TEMPLATE_LEN + 1);
  strcpy (*name, template);
",1,unused,427,unused,"#else
# define TEMPLATE_LEN   L_tmpnam
#endif
  *name = xmalloc (TEMPLATE_LEN + 1);
  strcpy (*name, template);
",unused,makepatchxen-output.c
"
  if (prefix)
    {
      if (makelevel == 0)
        sprintf (p, ""%s: "", program);
",1,unused,624,unused,"
  if (prefix)
    {
      if (makelevel == 0)
        sprintf (p, ""%s: "", program);
",unused,makepatchxen-output.c
"    {
      if (makelevel == 0)
        sprintf (p, ""%s: "", program);
      else
        sprintf (p, ""%s[%u]: "", program, makelevel);
",1,unused,626,unused,"    {
      if (makelevel == 0)
        sprintf (p, ""%s: "", program);
      else
        sprintf (p, ""%s[%u]: "", program, makelevel);
",unused,makepatchxen-output.c
"  va_start (args, fmt);
  vsprintf (p, fmt, args);
  va_end (args);

  strcat (p, ""\n"");
",1,unused,634,unused,"  va_start (args, fmt);
  vsprintf (p, fmt, args);
  va_end (args);

  strcat (p, ""\n"");
",unused,makepatchxen-output.c
"          + INTSTR_LENGTH + 4 + 1 + 1);
  p = get_buffer (len);

  if (flocp && flocp->filenm)
    sprintf (p, ""%s:%lu: "", flocp->filenm, flocp->lineno);
",1,unused,654,unused,"          + INTSTR_LENGTH + 4 + 1 + 1);
  p = get_buffer (len);

  if (flocp && flocp->filenm)
    sprintf (p, ""%s:%lu: "", flocp->filenm, flocp->lineno);
",unused,makepatchxen-output.c
"
  if (flocp && flocp->filenm)
    sprintf (p, ""%s:%lu: "", flocp->filenm, flocp->lineno);
  else if (makelevel == 0)
    sprintf (p, ""%s: "", program);
",1,unused,656,unused,"
  if (flocp && flocp->filenm)
    sprintf (p, ""%s:%lu: "", flocp->filenm, flocp->lineno);
  else if (makelevel == 0)
    sprintf (p, ""%s: "", program);
",unused,makepatchxen-output.c
"    sprintf (p, ""%s:%lu: "", flocp->filenm, flocp->lineno);
  else if (makelevel == 0)
    sprintf (p, ""%s: "", program);
  else
    sprintf (p, ""%s[%u]: "", program, makelevel);
",1,unused,658,unused,"    sprintf (p, ""%s:%lu: "", flocp->filenm, flocp->lineno);
  else if (makelevel == 0)
    sprintf (p, ""%s: "", program);
  else
    sprintf (p, ""%s[%u]: "", program, makelevel);
",unused,makepatchxen-output.c
"  va_start (args, fmt);
  vsprintf (p, fmt, args);
  va_end (args);

  strcat (p, ""\n"");
",1,unused,665,unused,"  va_start (args, fmt);
  vsprintf (p, fmt, args);
  va_end (args);

  strcat (p, ""\n"");
",unused,makepatchxen-output.c
"          + INTSTR_LENGTH + 8 + strlen (stop) + 1);
  p = get_buffer (len);

  if (flocp && flocp->filenm)
    sprintf (p, ""%s:%lu: *** "", flocp->filenm, flocp->lineno);
",1,unused,686,unused,"          + INTSTR_LENGTH + 8 + strlen (stop) + 1);
  p = get_buffer (len);

  if (flocp && flocp->filenm)
    sprintf (p, ""%s:%lu: *** "", flocp->filenm, flocp->lineno);
",unused,makepatchxen-output.c
"
  if (flocp && flocp->filenm)
    sprintf (p, ""%s:%lu: *** "", flocp->filenm, flocp->lineno);
  else if (makelevel == 0)
    sprintf (p, ""%s: *** "", program);
",1,unused,688,unused,"
  if (flocp && flocp->filenm)
    sprintf (p, ""%s:%lu: *** "", flocp->filenm, flocp->lineno);
  else if (makelevel == 0)
    sprintf (p, ""%s: *** "", program);
",unused,makepatchxen-output.c
"    sprintf (p, ""%s:%lu: *** "", flocp->filenm, flocp->lineno);
  else if (makelevel == 0)
    sprintf (p, ""%s: *** "", program);
  else
    sprintf (p, ""%s[%u]: *** "", program, makelevel);
",1,unused,690,unused,"    sprintf (p, ""%s:%lu: *** "", flocp->filenm, flocp->lineno);
  else if (makelevel == 0)
    sprintf (p, ""%s: *** "", program);
  else
    sprintf (p, ""%s[%u]: *** "", program, makelevel);
",unused,makepatchxen-output.c
"  va_start (args, fmt);
  vsprintf (p, fmt, args);
  va_end (args);

  strcat (p, stop);
",1,unused,697,unused,"  va_start (args, fmt);
  vsprintf (p, fmt, args);
  va_end (args);

  strcat (p, stop);
",unused,makepatchxen-output.c
"          free (collapsed);
          /* Don't need xrealloc: we don't need to preserve the content.  */
          collapsed = xmalloc (collapsed_length);
        }
      strcpy (collapsed, line);
",1,unused,715,unused,"          free (collapsed);
          /* Don't need xrealloc: we don't need to preserve the content.  */
          collapsed = xmalloc (collapsed_length);
        }
      strcpy (collapsed, line);
",unused,makepatchxen-read.c
"                    / 1e9));
              char from_now_string[100];

              if (from_now >= 99 && from_now <= ULONG_MAX)
                sprintf (from_now_string, ""%lu"", (unsigned long) from_now);
",1,unused,1413,unused,"                    / 1e9));
              char from_now_string[100];

              if (from_now >= 99 && from_now <= ULONG_MAX)
                sprintf (from_now_string, ""%lu"", (unsigned long) from_now);
",unused,makepatchxen-remake.c
"
              if (from_now >= 99 && from_now <= ULONG_MAX)
                sprintf (from_now_string, ""%lu"", (unsigned long) from_now);
              else
                sprintf (from_now_string, ""%.2g"", from_now);
",1,unused,1415,unused,"
              if (from_now >= 99 && from_now <= ULONG_MAX)
                sprintf (from_now_string, ""%lu"", (unsigned long) from_now);
              else
                sprintf (from_now_string, ""%.2g"", from_now);
",unused,makepatchxen-remake.c
"         Note that we have already successfully dereferenced all the links
         above.  So, if we run into any error trying to lstat(), or
         readlink(), or whatever, something bizarre-o happened.  Just give up
         and use whatever mtime we've already computed at that point.  */
      strcpy (lpath, name);
",1,unused,1492,unused,"         Note that we have already successfully dereferenced all the links
         above.  So, if we run into any error trying to lstat(), or
         readlink(), or whatever, something bizarre-o happened.  Just give up
         and use whatever mtime we've already computed at that point.  */
      strcpy (lpath, name);
",unused,makepatchxen-remake.c
"          /* If the target is fully-qualified or the source is just a
             filename, then the new path is the target.  Otherwise it's the
             source directory plus the target.  */
          if (lbuf[0] == '/' || (p = strrchr (lpath, '/')) == NULL)
            strcpy (lpath, lbuf);
",1,unused,1533,unused,"          /* If the target is fully-qualified or the source is just a
             filename, then the new path is the target.  Otherwise it's the
             source directory plus the target.  */
          if (lbuf[0] == '/' || (p = strrchr (lpath, '/')) == NULL)
            strcpy (lpath, lbuf);
",unused,makepatchxen-remake.c
"            /* Eh?  Path too long!  Again, just go with what we have.  */
            break;
          else
            /* Create the next step in the symlink chain.  */
            strcpy (p+1, lbuf);
",1,unused,1539,unused,"            /* Eh?  Path too long!  Again, just go with what we have.  */
            break;
          else
            /* Create the next step in the symlink chain.  */
            strcpy (p+1, lbuf);
",unused,makepatchxen-remake.c
"        unsigned int vpath_index = ~((unsigned int)0) - std_dirs;

        for (dp = dirs; *dp != 0; ++dp)
          {
            sprintf (buf, ""%s/%s"", *dp, libbuf);
",1,unused,1701,unused,"        unsigned int vpath_index = ~((unsigned int)0) - std_dirs;

        for (dp = dirs; *dp != 0; ++dp)
          {
            sprintf (buf, ""%s/%s"", *dp, libbuf);
",unused,makepatchxen-remake.c
"  time_t t = FILE_TIMESTAMP_S (ts);
  struct tm *tm = localtime (&t);

  if (tm)
    sprintf (p, ""%04d-%02d-%02d %02d:%02d:%02d"",
",1,unused,880,unused,"  time_t t = FILE_TIMESTAMP_S (ts);
  struct tm *tm = localtime (&t);

  if (tm)
    sprintf (p, ""%04d-%02d-%02d %02d:%02d:%02d"",
",unused,makesources4.1-file.c
"    sprintf (p, ""%04d-%02d-%02d %02d:%02d:%02d"",
             tm->tm_year + 1900, tm->tm_mon + 1, tm->tm_mday,
             tm->tm_hour, tm->tm_min, tm->tm_sec);
  else if (t < 0)
    sprintf (p, ""%ld"", (long) t);
",1,unused,884,unused,"    sprintf (p, ""%04d-%02d-%02d %02d:%02d:%02d"",
             tm->tm_year + 1900, tm->tm_mon + 1, tm->tm_mday,
             tm->tm_hour, tm->tm_min, tm->tm_sec);
  else if (t < 0)
    sprintf (p, ""%ld"", (long) t);
",unused,makesources4.1-file.c
"             tm->tm_hour, tm->tm_min, tm->tm_sec);
  else if (t < 0)
    sprintf (p, ""%ld"", (long) t);
  else
    sprintf (p, ""%lu"", (unsigned long) t);
",1,unused,886,unused,"             tm->tm_hour, tm->tm_min, tm->tm_sec);
  else if (t < 0)
    sprintf (p, ""%ld"", (long) t);
  else
    sprintf (p, ""%lu"", (unsigned long) t);
",unused,makesources4.1-file.c
"  /* Append nanoseconds as a fraction, but remove trailing zeros.  We don't
     know the actual timestamp resolution, since clock_getres applies only to
     local times, whereas this timestamp might come from a remote filesystem.
     So removing trailing zeros is the best guess that we can do.  */
  sprintf (p, "".%09d"", FILE_TIMESTAMP_NS (ts));
",1,unused,893,unused,"  /* Append nanoseconds as a fraction, but remove trailing zeros.  We don't
     know the actual timestamp resolution, since clock_getres applies only to
     local times, whereas this timestamp might come from a remote filesystem.
     So removing trailing zeros is the best guess that we can do.  */
  sprintf (p, "".%09d"", FILE_TIMESTAMP_NS (ts));
",unused,makesources4.1-file.c
"
  while (find_next_token (&word_iterator, NULL) != 0)
    ++i;

  sprintf (buf, ""%d"", i);
",1,unused,734,unused,"
  while (find_next_token (&word_iterator, NULL) != 0)
    ++i;

  sprintf (buf, ""%d"", i);
",unused,makesources4.1-function.c
"  p = msg = alloca (len + 1);

  for (argvp=argv; argvp[1] != 0; ++argvp)
    {
      strcpy (p, *argvp);
",1,unused,1113,unused,"  p = msg = alloca (len + 1);

  for (argvp=argv; argvp[1] != 0; ++argvp)
    {
      strcpy (p, *argvp);
",unused,makesources4.1-function.c
"      p += strlen (*argvp);
      *(p++) = ',';
      *(p++) = ' ';
    }
  strcpy (p, *argvp);
",1,unused,1118,unused,"      p += strlen (*argvp);
      *(p++) = ',';
      *(p++) = ' ';
    }
  strcpy (p, *argvp);
",unused,makesources4.1-function.c
"  /* For error messages.  */
  if (reading_file && reading_file->filenm)
    {
      char *p = alloca (strlen (reading_file->filenm)+11+4);
      sprintf (p, ""%s:%lu: "", reading_file->filenm, reading_file->lineno);
",1,unused,1712,unused,"  /* For error messages.  */
  if (reading_file && reading_file->filenm)
    {
      char *p = alloca (strlen (reading_file->filenm)+11+4);
      sprintf (p, ""%s:%lu: "", reading_file->filenm, reading_file->lineno);
",unused,makesources4.1-function.c
"      /* It is unlikely we would make it until here but just to make sure. */
      if (!starting_directory)
        return NULL;

      strcpy (apath, starting_directory);
",1,unused,2024,unused,"      /* It is unlikely we would make it until here but just to make sure. */
      if (!starting_directory)
        return NULL;

      strcpy (apath, starting_directory);
",unused,makesources4.1-function.c
"  for (i=0; *argv; ++i, ++argv)
    {
      char num[11];

      sprintf (num, ""%d"", i);
",1,unused,2543,unused,"  for (i=0; *argv; ++i, ++argv)
    {
      char num[11];

      sprintf (num, ""%d"", i);
",unused,makesources4.1-function.c
"  for (; i < max_args; ++i)
    {
      char num[11];

      sprintf (num, ""%d"", i);
",1,unused,2556,unused,"  for (; i < max_args; ++i)
    {
      char num[11];

      sprintf (num, ""%d"", i);
",unused,makesources4.1-function.c
"              if (! dep->need_2nd_expansion)
                {
                  p = strchr (nptr, '%');
                  if (p == 0)
                    strcpy (depname, nptr);
",1,unused,535,unused,"              if (! dep->need_2nd_expansion)
                {
                  p = strchr (nptr, '%');
                  if (p == 0)
                    strcpy (depname, nptr);
",unused,makesources4.1-implicit.c
"                      memcpy (o, nptr, p - nptr);
                      o += p - nptr;
                      memcpy (o, stem_str, stemlen);
                      o += stemlen;
                      strcpy (o, p + 1);
",1,unused,548,unused,"                      memcpy (o, nptr, p - nptr);
                      o += p - nptr;
                      memcpy (o, stem_str, stemlen);
                      o += stemlen;
                      strcpy (o, p + 1);
",unused,makesources4.1-implicit.c
"  /* %Id is only needed for 64-builds, which were not supported by
      older versions of Windows compilers.  */
  sprintf (pidstring, ""%Id"", pid);
#else
  sprintf (pidstring, ""%lu"", (unsigned long) pid);
",1,unused,199,unused,"  /* %Id is only needed for 64-builds, which were not supported by
      older versions of Windows compilers.  */
  sprintf (pidstring, ""%Id"", pid);
#else
  sprintf (pidstring, ""%lu"", (unsigned long) pid);
",unused,makesources4.1-job.c
"    nm = _(""<builtin>"");
  else
    {
      char *a = alloca (strlen (flocp->filenm) + 1 + 11 + 1);
      sprintf (a, ""%s:%lu"", flocp->filenm, flocp->lineno);
",1,unused,496,unused,"    nm = _(""<builtin>"");
  else
    {
      char *a = alloca (strlen (flocp->filenm) + 1 + 11 + 1);
      sprintf (a, ""%s:%lu"", flocp->filenm, flocp->lineno);
",unused,makesources4.1-job.c
"        nm = _(""<builtin>"");
      else
        {
          char *n = alloca (strlen (cmds->fileinfo.filenm) + 1 + 11 + 1);
          sprintf (n, ""%s:%lu"", cmds->fileinfo.filenm, cmds->fileinfo.lineno);
",1,unused,2050,unused,"        nm = _(""<builtin>"");
      else
        {
          char *n = alloca (strlen (cmds->fileinfo.filenm) + 1 + 11 + 1);
          sprintf (n, ""%s:%lu"", cmds->fileinfo.filenm, cmds->fileinfo.lineno);
",unused,makesources4.1-job.c
"      else
        ++fp;
      while (isalnum (*fp) || *fp == '_')
        *(p++) = *(fp++);
      strcpy (p, SYMBOL_EXTENSION);
",1,unused,201,unused,"      else
        ++fp;
      while (isalnum (*fp) || *fp == '_')
        *(p++) = *(fp++);
      strcpy (p, SYMBOL_EXTENSION);
",unused,makesources4.1-load.c
"               )
              tmpdir = DEFAULT_TMPDIR;

            template = alloca (strlen (tmpdir) + CSTRLEN (DEFAULT_TMPFILE) + 2);
            strcpy (template, tmpdir);
",1,unused,1765,unused,"               )
              tmpdir = DEFAULT_TMPDIR;

            template = alloca (strlen (tmpdir) + CSTRLEN (DEFAULT_TMPFILE) + 2);
            strcpy (template, tmpdir);
",unused,makesources4.1-main.c
"              strcat (template, ""/"");
#else
# ifndef VMS
            if (template[strlen (template) - 1] != '/')
              strcat (template, ""/"");
",1,unused,1773,unused,"              strcat (template, ""/"");
#else
# ifndef VMS
            if (template[strlen (template) - 1] != '/')
              strcat (template, ""/"");
",unused,makesources4.1-main.c
"              strcat (template, ""/"");
# endif /* !VMS */
#endif /* !HAVE_DOS_PATHS */

            strcat (template, DEFAULT_TMPFILE);
",1,unused,1777,unused,"              strcat (template, ""/"");
# endif /* !VMS */
#endif /* !HAVE_DOS_PATHS */

            strcat (template, DEFAULT_TMPFILE);
",unused,makesources4.1-main.c
"
      p = value = alloca (len);
      for (i = 0; i < eval_strings->idx; ++i)
        {
          strcpy (p, ""--eval="");
",1,unused,1883,unused,"
      p = value = alloca (len);
      for (i = 0; i < eval_strings->idx; ++i)
        {
          strcpy (p, ""--eval="");
",unused,makesources4.1-main.c
"      jobserver_fds = xmalloc (MAX_PATH + 1);
      strcpy (jobserver_fds, get_jobserver_semaphore_name ());
#else
      jobserver_fds = xmalloc ((INTSTR_LENGTH * 2) + 2);
      sprintf (jobserver_fds, ""%d,%d"", job_fds[0], job_fds[1]);
",1,unused,2039,unused,"      jobserver_fds = xmalloc (MAX_PATH + 1);
      strcpy (jobserver_fds, get_jobserver_semaphore_name ());
#else
      jobserver_fds = xmalloc ((INTSTR_LENGTH * 2) + 2);
      sprintf (jobserver_fds, ""%d,%d"", job_fds[0], job_fds[1]);
",unused,makesources4.1-main.c
"              {
                if (strneq (*p, MAKELEVEL_NAME ""="", MAKELEVEL_LENGTH+1))
                  {
                    *p = alloca (40);
                    sprintf (*p, ""%s=%u"", MAKELEVEL_NAME, makelevel);
",1,unused,2357,unused,"              {
                if (strneq (*p, MAKELEVEL_NAME ""="", MAKELEVEL_LENGTH+1))
                  {
                    *p = alloca (40);
                    sprintf (*p, ""%s=%u"", MAKELEVEL_NAME, makelevel);
",unused,makesources4.1-main.c
"                  }
                else if (strneq (*p, ""MAKE_RESTARTS="", CSTRLEN (""MAKE_RESTARTS="")))
                  {
                    *p = alloca (40);
                    sprintf (*p, ""MAKE_RESTARTS=%s%u"",
",1,unused,2362,unused,"                  }
                else if (strneq (*p, ""MAKE_RESTARTS="", CSTRLEN (""MAKE_RESTARTS="")))
                  {
                    *p = alloca (40);
                    sprintf (*p, ""MAKE_RESTARTS=%s%u"",
",unused,makesources4.1-main.c
"          /* If we didn't set the restarts variable yet, add it.  */
          if (restarts)
            {
              char *b = alloca (40);
              sprintf (b, ""MAKE_RESTARTS=%s%u"",
",1,unused,2385,unused,"          /* If we didn't set the restarts variable yet, add it.  */
          if (restarts)
            {
              char *b = alloca (40);
              sprintf (b, ""MAKE_RESTARTS=%s%u"",
",unused,makesources4.1-main.c
"                ADD_FLAG ("""", 0); /* Optional value omitted; see below.  */
              else
                {
                  char *buf = alloca (30);
                  sprintf (buf, ""%u"", *(unsigned int *) cs->value_ptr);
",1,unused,3091,unused,"                ADD_FLAG ("""", 0); /* Optional value omitted; see below.  */
              else
                {
                  char *buf = alloca (30);
                  sprintf (buf, ""%u"", *(unsigned int *) cs->value_ptr);
",unused,makesources4.1-main.c
"                ADD_FLAG ("""", 0); /* Optional value omitted; see below.  */
              else
                {
                  char *buf = alloca (100);
                  sprintf (buf, ""%g"", *(double *) cs->value_ptr);
",1,unused,3112,unused,"                ADD_FLAG ("""", 0); /* Optional value omitted; see below.  */
              else
                {
                  char *buf = alloca (100);
                  sprintf (buf, ""%g"", *(double *) cs->value_ptr);
",unused,makesources4.1-main.c
"      else
        {
          /* Long options require a double-dash.  */
          *p++ = '-';
          strcpy (p, flags->cs->long_name);
",1,unused,3180,unused,"      else
        {
          /* Long options require a double-dash.  */
          *p++ = '-';
          strcpy (p, flags->cs->long_name);
",unused,makesources4.1-main.c
"      /* Write a reference to $(MAKEOVERRIDES), which contains all the
         command-line variable definitions.  Separate the variables from the
         switches with a ""--"" arg.  */

      strcpy (p, "" -- "");
",1,unused,3223,unused,"      /* Write a reference to $(MAKEOVERRIDES), which contains all the
         command-line variable definitions.  Separate the variables from the
         switches with a ""--"" arg.  */

      strcpy (p, "" -- "");
",unused,makesources4.1-main.c
"    }

  if (makelevel == 0)
    if (starting_directory == 0)
      sprintf (p, fmt , program);
",1,unused,141,unused,"    }

  if (makelevel == 0)
    if (starting_directory == 0)
      sprintf (p, fmt , program);
",unused,makesources4.1-output.c
"  if (makelevel == 0)
    if (starting_directory == 0)
      sprintf (p, fmt , program);
    else
      sprintf (p, fmt, program, starting_directory);
",1,unused,143,unused,"  if (makelevel == 0)
    if (starting_directory == 0)
      sprintf (p, fmt , program);
    else
      sprintf (p, fmt, program, starting_directory);
",unused,makesources4.1-output.c
"      sprintf (p, fmt , program);
    else
      sprintf (p, fmt, program, starting_directory);
  else if (starting_directory == 0)
    sprintf (p, fmt, program, makelevel);
",1,unused,145,unused,"      sprintf (p, fmt , program);
    else
      sprintf (p, fmt, program, starting_directory);
  else if (starting_directory == 0)
    sprintf (p, fmt, program, makelevel);
",unused,makesources4.1-output.c
"      sprintf (p, fmt, program, starting_directory);
  else if (starting_directory == 0)
    sprintf (p, fmt, program, makelevel);
  else
    sprintf (p, fmt, program, makelevel, starting_directory);
",1,unused,147,unused,"      sprintf (p, fmt, program, starting_directory);
  else if (starting_directory == 0)
    sprintf (p, fmt, program, makelevel);
  else
    sprintf (p, fmt, program, makelevel, starting_directory);
",unused,makesources4.1-output.c
"#else
# define TEMPLATE_LEN   L_tmpnam
#endif
  *name = xmalloc (TEMPLATE_LEN + 1);
  strcpy (*name, template);
",1,unused,427,unused,"#else
# define TEMPLATE_LEN   L_tmpnam
#endif
  *name = xmalloc (TEMPLATE_LEN + 1);
  strcpy (*name, template);
",unused,makesources4.1-output.c
"
  if (prefix)
    {
      if (makelevel == 0)
        sprintf (p, ""%s: "", program);
",1,unused,624,unused,"
  if (prefix)
    {
      if (makelevel == 0)
        sprintf (p, ""%s: "", program);
",unused,makesources4.1-output.c
"    {
      if (makelevel == 0)
        sprintf (p, ""%s: "", program);
      else
        sprintf (p, ""%s[%u]: "", program, makelevel);
",1,unused,626,unused,"    {
      if (makelevel == 0)
        sprintf (p, ""%s: "", program);
      else
        sprintf (p, ""%s[%u]: "", program, makelevel);
",unused,makesources4.1-output.c
"  va_start (args, fmt);
  vsprintf (p, fmt, args);
  va_end (args);

  strcat (p, ""\n"");
",1,unused,634,unused,"  va_start (args, fmt);
  vsprintf (p, fmt, args);
  va_end (args);

  strcat (p, ""\n"");
",unused,makesources4.1-output.c
"          + INTSTR_LENGTH + 4 + 1 + 1);
  p = get_buffer (len);

  if (flocp && flocp->filenm)
    sprintf (p, ""%s:%lu: "", flocp->filenm, flocp->lineno);
",1,unused,654,unused,"          + INTSTR_LENGTH + 4 + 1 + 1);
  p = get_buffer (len);

  if (flocp && flocp->filenm)
    sprintf (p, ""%s:%lu: "", flocp->filenm, flocp->lineno);
",unused,makesources4.1-output.c
"
  if (flocp && flocp->filenm)
    sprintf (p, ""%s:%lu: "", flocp->filenm, flocp->lineno);
  else if (makelevel == 0)
    sprintf (p, ""%s: "", program);
",1,unused,656,unused,"
  if (flocp && flocp->filenm)
    sprintf (p, ""%s:%lu: "", flocp->filenm, flocp->lineno);
  else if (makelevel == 0)
    sprintf (p, ""%s: "", program);
",unused,makesources4.1-output.c
"    sprintf (p, ""%s:%lu: "", flocp->filenm, flocp->lineno);
  else if (makelevel == 0)
    sprintf (p, ""%s: "", program);
  else
    sprintf (p, ""%s[%u]: "", program, makelevel);
",1,unused,658,unused,"    sprintf (p, ""%s:%lu: "", flocp->filenm, flocp->lineno);
  else if (makelevel == 0)
    sprintf (p, ""%s: "", program);
  else
    sprintf (p, ""%s[%u]: "", program, makelevel);
",unused,makesources4.1-output.c
"  va_start (args, fmt);
  vsprintf (p, fmt, args);
  va_end (args);

  strcat (p, ""\n"");
",1,unused,665,unused,"  va_start (args, fmt);
  vsprintf (p, fmt, args);
  va_end (args);

  strcat (p, ""\n"");
",unused,makesources4.1-output.c
"          + INTSTR_LENGTH + 8 + strlen (stop) + 1);
  p = get_buffer (len);

  if (flocp && flocp->filenm)
    sprintf (p, ""%s:%lu: *** "", flocp->filenm, flocp->lineno);
",1,unused,686,unused,"          + INTSTR_LENGTH + 8 + strlen (stop) + 1);
  p = get_buffer (len);

  if (flocp && flocp->filenm)
    sprintf (p, ""%s:%lu: *** "", flocp->filenm, flocp->lineno);
",unused,makesources4.1-output.c
"
  if (flocp && flocp->filenm)
    sprintf (p, ""%s:%lu: *** "", flocp->filenm, flocp->lineno);
  else if (makelevel == 0)
    sprintf (p, ""%s: *** "", program);
",1,unused,688,unused,"
  if (flocp && flocp->filenm)
    sprintf (p, ""%s:%lu: *** "", flocp->filenm, flocp->lineno);
  else if (makelevel == 0)
    sprintf (p, ""%s: *** "", program);
",unused,makesources4.1-output.c
"    sprintf (p, ""%s:%lu: *** "", flocp->filenm, flocp->lineno);
  else if (makelevel == 0)
    sprintf (p, ""%s: *** "", program);
  else
    sprintf (p, ""%s[%u]: *** "", program, makelevel);
",1,unused,690,unused,"    sprintf (p, ""%s:%lu: *** "", flocp->filenm, flocp->lineno);
  else if (makelevel == 0)
    sprintf (p, ""%s: *** "", program);
  else
    sprintf (p, ""%s[%u]: *** "", program, makelevel);
",unused,makesources4.1-output.c
"  va_start (args, fmt);
  vsprintf (p, fmt, args);
  va_end (args);

  strcat (p, stop);
",1,unused,697,unused,"  va_start (args, fmt);
  vsprintf (p, fmt, args);
  va_end (args);

  strcat (p, stop);
",unused,makesources4.1-output.c
"          free (collapsed);
          /* Don't need xrealloc: we don't need to preserve the content.  */
          collapsed = xmalloc (collapsed_length);
        }
      strcpy (collapsed, line);
",1,unused,715,unused,"          free (collapsed);
          /* Don't need xrealloc: we don't need to preserve the content.  */
          collapsed = xmalloc (collapsed_length);
        }
      strcpy (collapsed, line);
",unused,makesources4.1-read.c
"                    / 1e9));
              char from_now_string[100];

              if (from_now >= 99 && from_now <= ULONG_MAX)
                sprintf (from_now_string, ""%lu"", (unsigned long) from_now);
",1,unused,1407,unused,"                    / 1e9));
              char from_now_string[100];

              if (from_now >= 99 && from_now <= ULONG_MAX)
                sprintf (from_now_string, ""%lu"", (unsigned long) from_now);
",unused,makesources4.1-remake.c
"
              if (from_now >= 99 && from_now <= ULONG_MAX)
                sprintf (from_now_string, ""%lu"", (unsigned long) from_now);
              else
                sprintf (from_now_string, ""%.2g"", from_now);
",1,unused,1409,unused,"
              if (from_now >= 99 && from_now <= ULONG_MAX)
                sprintf (from_now_string, ""%lu"", (unsigned long) from_now);
              else
                sprintf (from_now_string, ""%.2g"", from_now);
",unused,makesources4.1-remake.c
"         Note that we have already successfully dereferenced all the links
         above.  So, if we run into any error trying to lstat(), or
         readlink(), or whatever, something bizarre-o happened.  Just give up
         and use whatever mtime we've already computed at that point.  */
      strcpy (lpath, name);
",1,unused,1486,unused,"         Note that we have already successfully dereferenced all the links
         above.  So, if we run into any error trying to lstat(), or
         readlink(), or whatever, something bizarre-o happened.  Just give up
         and use whatever mtime we've already computed at that point.  */
      strcpy (lpath, name);
",unused,makesources4.1-remake.c
"          /* If the target is fully-qualified or the source is just a
             filename, then the new path is the target.  Otherwise it's the
             source directory plus the target.  */
          if (lbuf[0] == '/' || (p = strrchr (lpath, '/')) == NULL)
            strcpy (lpath, lbuf);
",1,unused,1527,unused,"          /* If the target is fully-qualified or the source is just a
             filename, then the new path is the target.  Otherwise it's the
             source directory plus the target.  */
          if (lbuf[0] == '/' || (p = strrchr (lpath, '/')) == NULL)
            strcpy (lpath, lbuf);
",unused,makesources4.1-remake.c
"            /* Eh?  Path too long!  Again, just go with what we have.  */
            break;
          else
            /* Create the next step in the symlink chain.  */
            strcpy (p+1, lbuf);
",1,unused,1533,unused,"            /* Eh?  Path too long!  Again, just go with what we have.  */
            break;
          else
            /* Create the next step in the symlink chain.  */
            strcpy (p+1, lbuf);
",unused,makesources4.1-remake.c
"        unsigned int vpath_index = ~((unsigned int)0) - std_dirs;

        for (dp = dirs; *dp != 0; ++dp)
          {
            sprintf (buf, ""%s/%s"", *dp, libbuf);
",1,unused,1681,unused,"        unsigned int vpath_index = ~((unsigned int)0) - std_dirs;

        for (dp = dirs; *dp != 0; ++dp)
          {
            sprintf (buf, ""%s/%s"", *dp, libbuf);
",unused,makesources4.1-remake.c
"  extern const char* default_shell;
  struct variable *v;
  char buf[200];

  sprintf (buf, ""%u"", makelevel);
",1,unused,791,unused,"  extern const char* default_shell;
  struct variable *v;
  char buf[200];

  sprintf (buf, ""%u"", makelevel);
",unused,makesources4.1-variable.c
"
  sprintf (buf, ""%u"", makelevel);
  define_variable_cname (MAKELEVEL_NAME, buf, o_env, 0);

  sprintf (buf, ""%s%s%s"",
",1,unused,794,unused,"
  sprintf (buf, ""%u"", makelevel);
  define_variable_cname (MAKELEVEL_NAME, buf, o_env, 0);

  sprintf (buf, ""%s%s%s"",
",unused,makesources4.1-variable.c
"          }
      }

  *result = xmalloc (100);
  sprintf (*result, ""%s=%u"", MAKELEVEL_NAME, makelevel + 1);
",1,unused,1083,unused,"          }
      }

  *result = xmalloc (100);
  sprintf (*result, ""%s=%u"", MAKELEVEL_NAME, makelevel + 1);
",unused,makesources4.1-variable.c
"    {
      int l = strlen (file->name);
      char *t = alloca (l + 3);

      strcpy (t, file->name);
",1,unused,1744,unused,"    {
      int l = strlen (file->name);
      char *t = alloca (l + 3);

      strcpy (t, file->name);
",unused,makesources4.1-variable.c
"{
    if (metrics == NULL) return out;

    for (size_t i = 0; i < cvss_metrics_component_num(metrics); ++i)
        out += sprintf(out, ""%s/"", cvss_valtab(metrics->category | i, metrics->metrics.ANY[i], NULL, NULL)->vector_str);
",1,unused,342,unused,"{
    if (metrics == NULL) return out;

    for (size_t i = 0; i < cvss_metrics_component_num(metrics); ++i)
        out += sprintf(out, ""%s/"", cvss_valtab(metrics->category | i, metrics->metrics.ANY[i], NULL, NULL)->vector_str);
",unused,matejak_openscap-src2FCVSS2Fcvss.c
"			char concat[len_cat];
			*concat = '\0';
			for (idx0 = 0; idx0 < len_subcomps; idx0++)
				if (texts[idx0])
					strcat(concat, texts[idx0]);
",1,unused,1619,unused,"			char concat[len_cat];
			*concat = '\0';
			for (idx0 = 0; idx0 < len_subcomps; idx0++)
				if (texts[idx0])
					strcat(concat, texts[idx0]);
",unused,matejak_openscap-src2FOVAL2Foval_component.c
"			char *text = oval_value_get_text(oval_value_iterator_next(values));
			if (len_delim) {
				char split[strlen(text) + 2], *split0 = split;
				*split0 = '\0';
				strcat(split0, text);
",1,unused,1766,unused,"			char *text = oval_value_get_text(oval_value_iterator_next(values));
			if (len_delim) {
				char split[strlen(text) + 2], *split0 = split;
				*split0 = '\0';
				strcat(split0, text);
",unused,matejak_openscap-src2FOVAL2Foval_component.c
"		char *newtitle = (char *)malloc(newsize * sizeof(char));
		if (newtitle == NULL)
			return;

		strcpy(newtitle, title);
",1,unused,341,unused,"		char *newtitle = (char *)malloc(newsize * sizeof(char));
		if (newtitle == NULL)
			return;

		strcpy(newtitle, title);
",unused,matejak_openscap-src2FOVAL2Foval_definition.c
"		if (newtitle == NULL)
			return;

		strcpy(newtitle, title);
		strcat(newtitle, string);
",1,unused,342,unused,"		if (newtitle == NULL)
			return;

		strcpy(newtitle, title);
		strcat(newtitle, string);
",unused,matejak_openscap-src2FOVAL2Foval_definition.c
"		if (newdescription == NULL)
			return;

		*newdescription = '\0';
		strcpy(newdescription, description);
",1,unused,364,unused,"		if (newdescription == NULL)
			return;

		*newdescription = '\0';
		strcpy(newdescription, description);
",unused,matejak_openscap-src2FOVAL2Foval_definition.c
"			return;

		*newdescription = '\0';
		strcpy(newdescription, description);
		strcat(newdescription, string);
",1,unused,365,unused,"			return;

		*newdescription = '\0';
		strcpy(newdescription, description);
		strcat(newdescription, string);
",unused,matejak_openscap-src2FOVAL2Foval_definition.c
"
	/* get object name */
	const char *subtype_text = oval_subtype_get_text(subtype);
	char object_name[strlen(subtype_text) + 8];
	sprintf(object_name, ""%s_object"", subtype_text);
",1,unused,405,unused,"
	/* get object name */
	const char *subtype_text = oval_subtype_get_text(subtype);
	char object_name[strlen(subtype_text) + 8];
	sprintf(object_name, ""%s_object"", subtype_text);
",unused,matejak_openscap-src2FOVAL2Foval_object.c
"	/* get state name */
	oval_subtype_t subtype = oval_state_get_subtype(state);
	const char *subtype_text = oval_subtype_get_text(subtype);
	char state_name[strlen(subtype_text) + 7];
	sprintf(state_name, ""%s_state"", subtype_text);
",1,unused,338,unused,"	/* get state name */
	oval_subtype_t subtype = oval_state_get_subtype(state);
	const char *subtype_text = oval_subtype_get_text(subtype);
	char state_name[strlen(subtype_text) + 7];
	sprintf(state_name, ""%s_state"", subtype_text);
",unused,matejak_openscap-src2FOVAL2Foval_state.c
"		if (subtype) {
			/* get item subtype */
			const char *subtype_text = oval_subtype_get_text(subtype);
			char tagname[strlen(subtype_text) + 6];
			sprintf(tagname, ""%s_item"", subtype_text);
",1,unused,261,unused,"		if (subtype) {
			/* get item subtype */
			const char *subtype_text = oval_subtype_get_text(subtype);
			char tagname[strlen(subtype_text) + 6];
			sprintf(tagname, ""%s_item"", subtype_text);
",unused,matejak_openscap-src2FOVAL2Foval_sysItem.c
"
	/* get test name */
	const char *subtype_text = oval_subtype_get_text(subtype);
	char test_name[strlen(subtype_text) + 6];
	sprintf(test_name, ""%s_test"", subtype_text);
",1,unused,456,unused,"
	/* get test name */
	const char *subtype_text = oval_subtype_get_text(subtype);
	char test_name[strlen(subtype_text) + 6];
	sprintf(test_name, ""%s_test"", subtype_text);
",unused,matejak_openscap-src2FOVAL2Foval_test.c
"			continue;
		}
		SEXP_free(pid_sexp);

		sprintf(env_file, ""/proc/%d/environ"", pid);
",1,unused,102,unused,"			continue;
		}
		SEXP_free(pid_sexp);

		sprintf(env_file, ""/proc/%d/environ"", pid);
",unused,matejak_openscap-src2FOVAL2Fprobes2Findependent2Fenvironmentvariable58.c
"                  (     suffix ? strlen(suffix)      : 0) + 2) < (sizeof base/sizeof(char)),
                 PROBE_ERANGE);

        if (relative_dn != NULL) {
                strcpy(base, relative_dn);
",1,unused,180,unused,"                  (     suffix ? strlen(suffix)      : 0) + 2) < (sizeof base/sizeof(char)),
                 PROBE_ERANGE);

        if (relative_dn != NULL) {
                strcpy(base, relative_dn);
",unused,matejak_openscap-src2FOVAL2Fprobes2Findependent2Fldap57.c
"                 PROBE_ERANGE);

        if (relative_dn != NULL) {
                strcpy(base, relative_dn);
                strcat(base, "","");
",1,unused,181,unused,"                 PROBE_ERANGE);

        if (relative_dn != NULL) {
                strcpy(base, relative_dn);
                strcat(base, "","");
",unused,matejak_openscap-src2FOVAL2Fprobes2Findependent2Fldap57.c
"
        if (relative_dn != NULL) {
                strcpy(base, relative_dn);
                strcat(base, "","");
                strcat(base, suffix);
",1,unused,182,unused,"
        if (relative_dn != NULL) {
                strcpy(base, relative_dn);
                strcat(base, "","");
                strcat(base, suffix);
",unused,matejak_openscap-src2FOVAL2Fprobes2Findependent2Fldap57.c
"                strcpy(base, relative_dn);
                strcat(base, "","");
                strcat(base, suffix);
        } else
                strcpy(base, suffix);
",1,unused,184,unused,"                strcpy(base, relative_dn);
                strcat(base, "","");
                strcat(base, suffix);
        } else
                strcpy(base, suffix);
",unused,matejak_openscap-src2FOVAL2Fprobes2Findependent2Fldap57.c
"                return (NULL);
        }

        if (strlen(subtype_name) + strlen(""_item"") < sizeof item_name) {
                strcpy(item_name, subtype_name);
",1,unused,1423,unused,"                return (NULL);
        }

        if (strlen(subtype_name) + strlen(""_item"") < sizeof item_name) {
                strcpy(item_name, subtype_name);
",unused,matejak_openscap-src2FOVAL2Fprobes2Fprobe-api.c
"        }

        if (strlen(subtype_name) + strlen(""_item"") < sizeof item_name) {
                strcpy(item_name, subtype_name);
                strcat(item_name, ""_item"");
",1,unused,1424,unused,"        }

        if (strlen(subtype_name) + strlen(""_item"") < sizeof item_name) {
                strcpy(item_name, subtype_name);
                strcat(item_name, ""_item"");
",unused,matejak_openscap-src2FOVAL2Fprobes2Fprobe-api.c
"	*mp = mac_buf;
	*tp = """";

	memset(&ifr, 0, sizeof(struct ifreq));
	strcpy(ifr.ifr_name, ifa->ifa_name);
",1,unused,87,unused,"	*mp = mac_buf;
	*tp = """";

	memset(&ifr, 0, sizeof(struct ifreq));
	strcpy(ifr.ifr_name, ifa->ifa_name);
",unused,matejak_openscap-src2FOVAL2Fprobes2Funix2Finterface.c
"    if(!tmn) return 0;
    if(tmn->major_number == maj && tmn->minor_first <= min && tmn->minor_last >= min) break;
    tmn = tmn->next;
  }
  sprintf(buf, ""/dev/%s%d"", tmn->name, min);  /* like ""/dev/ttyZZ255"" */
",1,unused,133,unused,"    if(!tmn) return 0;
    if(tmn->major_number == maj && tmn->minor_first <= min && tmn->minor_last >= min) break;
    tmn = tmn->next;
  }
  sprintf(buf, ""/dev/%s%d"", tmn->name, min);  /* like ""/dev/ttyZZ255"" */
",unused,matejak_openscap-src2FOVAL2Fprobes2Funix2Fprocess58-devname.c
"  }
  sprintf(buf, ""/dev/%s%d"", tmn->name, min);  /* like ""/dev/ttyZZ255"" */
  if(stat(buf, &sbuf) < 0){
    if(tmn->devfs_type) return 0;
    sprintf(buf, ""/dev/%s"", tmn->name);  /* like ""/dev/ttyZZ255"" */
",1,unused,136,unused,"  }
  sprintf(buf, ""/dev/%s%d"", tmn->name, min);  /* like ""/dev/ttyZZ255"" */
  if(stat(buf, &sbuf) < 0){
    if(tmn->devfs_type) return 0;
    sprintf(buf, ""/dev/%s"", tmn->name);  /* like ""/dev/ttyZZ255"" */
",unused,matejak_openscap-src2FOVAL2Fprobes2Funix2Fprocess58-devname.c
"  case   3:      /* /dev/[pt]ty[p-za-o][0-9a-z] is 936 */
    if(tmpmin > 255) return 0;   // should never happen; array index protection
    t0 = ""pqrstuvwxyzabcde""[tmpmin>>4];
    t1 = ""0123456789abcdef""[tmpmin&0x0f];
    sprintf(buf, ""/dev/tty%c%c"", t0, t1);
",1,unused,210,unused,"  case   3:      /* /dev/[pt]ty[p-za-o][0-9a-z] is 936 */
    if(tmpmin > 255) return 0;   // should never happen; array index protection
    t0 = ""pqrstuvwxyzabcde""[tmpmin>>4];
    t1 = ""0123456789abcdef""[tmpmin&0x0f];
    sprintf(buf, ""/dev/tty%c%c"", t0, t1);
",unused,matejak_openscap-src2FOVAL2Fprobes2Funix2Fprocess58-devname.c
"    sprintf(buf, ""/dev/tty%c%c"", t0, t1);
    break;
  case   4:
    if(min<64){
      sprintf(buf, ""/dev/tty%d"", min);
",1,unused,214,unused,"    sprintf(buf, ""/dev/tty%c%c"", t0, t1);
    break;
  case   4:
    if(min<64){
      sprintf(buf, ""/dev/tty%d"", min);
",unused,matejak_openscap-src2FOVAL2Fprobes2Funix2Fprocess58-devname.c
"    if(min<64){
      sprintf(buf, ""/dev/tty%d"", min);
      break;
    }
    sprintf(buf, ""/dev/ttyS%d"", min-64);
",1,unused,217,unused,"    if(min<64){
      sprintf(buf, ""/dev/tty%d"", min);
      break;
    }
    sprintf(buf, ""/dev/ttyS%d"", min-64);
",unused,matejak_openscap-src2FOVAL2Fprobes2Funix2Fprocess58-devname.c
"      break;
    }
    sprintf(buf, ""/dev/ttyS%d"", min-64);
    break;
  case  11:  sprintf(buf, ""/dev/ttyB%d"",  min); break;
",1,unused,219,unused,"      break;
    }
    sprintf(buf, ""/dev/ttyS%d"", min-64);
    break;
  case  11:  sprintf(buf, ""/dev/ttyB%d"",  min); break;
",unused,matejak_openscap-src2FOVAL2Fprobes2Funix2Fprocess58-devname.c
"    }
    sprintf(buf, ""/dev/ttyS%d"", min-64);
    break;
  case  11:  sprintf(buf, ""/dev/ttyB%d"",  min); break;
  case  17:  sprintf(buf, ""/dev/ttyH%d"",  min); break;
",1,unused,220,unused,"    }
    sprintf(buf, ""/dev/ttyS%d"", min-64);
    break;
  case  11:  sprintf(buf, ""/dev/ttyB%d"",  min); break;
  case  17:  sprintf(buf, ""/dev/ttyH%d"",  min); break;
",unused,matejak_openscap-src2FOVAL2Fprobes2Funix2Fprocess58-devname.c
"    sprintf(buf, ""/dev/ttyS%d"", min-64);
    break;
  case  11:  sprintf(buf, ""/dev/ttyB%d"",  min); break;
  case  17:  sprintf(buf, ""/dev/ttyH%d"",  min); break;
  case  19:  sprintf(buf, ""/dev/ttyC%d"",  min); break;
",1,unused,221,unused,"    sprintf(buf, ""/dev/ttyS%d"", min-64);
    break;
  case  11:  sprintf(buf, ""/dev/ttyB%d"",  min); break;
  case  17:  sprintf(buf, ""/dev/ttyH%d"",  min); break;
  case  19:  sprintf(buf, ""/dev/ttyC%d"",  min); break;
",unused,matejak_openscap-src2FOVAL2Fprobes2Funix2Fprocess58-devname.c
"    break;
  case  11:  sprintf(buf, ""/dev/ttyB%d"",  min); break;
  case  17:  sprintf(buf, ""/dev/ttyH%d"",  min); break;
  case  19:  sprintf(buf, ""/dev/ttyC%d"",  min); break;
  case  22:  sprintf(buf, ""/dev/ttyD%d"",  min); break; /* devices.txt */
",1,unused,222,unused,"    break;
  case  11:  sprintf(buf, ""/dev/ttyB%d"",  min); break;
  case  17:  sprintf(buf, ""/dev/ttyH%d"",  min); break;
  case  19:  sprintf(buf, ""/dev/ttyC%d"",  min); break;
  case  22:  sprintf(buf, ""/dev/ttyD%d"",  min); break; /* devices.txt */
",unused,matejak_openscap-src2FOVAL2Fprobes2Funix2Fprocess58-devname.c
"  case  11:  sprintf(buf, ""/dev/ttyB%d"",  min); break;
  case  17:  sprintf(buf, ""/dev/ttyH%d"",  min); break;
  case  19:  sprintf(buf, ""/dev/ttyC%d"",  min); break;
  case  22:  sprintf(buf, ""/dev/ttyD%d"",  min); break; /* devices.txt */
  case  23:  sprintf(buf, ""/dev/ttyD%d"",  min); break; /* driver code */
",1,unused,223,unused,"  case  11:  sprintf(buf, ""/dev/ttyB%d"",  min); break;
  case  17:  sprintf(buf, ""/dev/ttyH%d"",  min); break;
  case  19:  sprintf(buf, ""/dev/ttyC%d"",  min); break;
  case  22:  sprintf(buf, ""/dev/ttyD%d"",  min); break; /* devices.txt */
  case  23:  sprintf(buf, ""/dev/ttyD%d"",  min); break; /* driver code */
",unused,matejak_openscap-src2FOVAL2Fprobes2Funix2Fprocess58-devname.c
"  case  17:  sprintf(buf, ""/dev/ttyH%d"",  min); break;
  case  19:  sprintf(buf, ""/dev/ttyC%d"",  min); break;
  case  22:  sprintf(buf, ""/dev/ttyD%d"",  min); break; /* devices.txt */
  case  23:  sprintf(buf, ""/dev/ttyD%d"",  min); break; /* driver code */
  case  24:  sprintf(buf, ""/dev/ttyE%d"",  min); break;
",1,unused,224,unused,"  case  17:  sprintf(buf, ""/dev/ttyH%d"",  min); break;
  case  19:  sprintf(buf, ""/dev/ttyC%d"",  min); break;
  case  22:  sprintf(buf, ""/dev/ttyD%d"",  min); break; /* devices.txt */
  case  23:  sprintf(buf, ""/dev/ttyD%d"",  min); break; /* driver code */
  case  24:  sprintf(buf, ""/dev/ttyE%d"",  min); break;
",unused,matejak_openscap-src2FOVAL2Fprobes2Funix2Fprocess58-devname.c
"  case  19:  sprintf(buf, ""/dev/ttyC%d"",  min); break;
  case  22:  sprintf(buf, ""/dev/ttyD%d"",  min); break; /* devices.txt */
  case  23:  sprintf(buf, ""/dev/ttyD%d"",  min); break; /* driver code */
  case  24:  sprintf(buf, ""/dev/ttyE%d"",  min); break;
  case  32:  sprintf(buf, ""/dev/ttyX%d"",  min); break;
",1,unused,225,unused,"  case  19:  sprintf(buf, ""/dev/ttyC%d"",  min); break;
  case  22:  sprintf(buf, ""/dev/ttyD%d"",  min); break; /* devices.txt */
  case  23:  sprintf(buf, ""/dev/ttyD%d"",  min); break; /* driver code */
  case  24:  sprintf(buf, ""/dev/ttyE%d"",  min); break;
  case  32:  sprintf(buf, ""/dev/ttyX%d"",  min); break;
",unused,matejak_openscap-src2FOVAL2Fprobes2Funix2Fprocess58-devname.c
"  case  22:  sprintf(buf, ""/dev/ttyD%d"",  min); break; /* devices.txt */
  case  23:  sprintf(buf, ""/dev/ttyD%d"",  min); break; /* driver code */
  case  24:  sprintf(buf, ""/dev/ttyE%d"",  min); break;
  case  32:  sprintf(buf, ""/dev/ttyX%d"",  min); break;
  case  43:  sprintf(buf, ""/dev/ttyI%d"",  min); break;
",1,unused,226,unused,"  case  22:  sprintf(buf, ""/dev/ttyD%d"",  min); break; /* devices.txt */
  case  23:  sprintf(buf, ""/dev/ttyD%d"",  min); break; /* driver code */
  case  24:  sprintf(buf, ""/dev/ttyE%d"",  min); break;
  case  32:  sprintf(buf, ""/dev/ttyX%d"",  min); break;
  case  43:  sprintf(buf, ""/dev/ttyI%d"",  min); break;
",unused,matejak_openscap-src2FOVAL2Fprobes2Funix2Fprocess58-devname.c
"  case  23:  sprintf(buf, ""/dev/ttyD%d"",  min); break; /* driver code */
  case  24:  sprintf(buf, ""/dev/ttyE%d"",  min); break;
  case  32:  sprintf(buf, ""/dev/ttyX%d"",  min); break;
  case  43:  sprintf(buf, ""/dev/ttyI%d"",  min); break;
  case  46:  sprintf(buf, ""/dev/ttyR%d"",  min); break;
",1,unused,227,unused,"  case  23:  sprintf(buf, ""/dev/ttyD%d"",  min); break; /* driver code */
  case  24:  sprintf(buf, ""/dev/ttyE%d"",  min); break;
  case  32:  sprintf(buf, ""/dev/ttyX%d"",  min); break;
  case  43:  sprintf(buf, ""/dev/ttyI%d"",  min); break;
  case  46:  sprintf(buf, ""/dev/ttyR%d"",  min); break;
",unused,matejak_openscap-src2FOVAL2Fprobes2Funix2Fprocess58-devname.c
"  case  24:  sprintf(buf, ""/dev/ttyE%d"",  min); break;
  case  32:  sprintf(buf, ""/dev/ttyX%d"",  min); break;
  case  43:  sprintf(buf, ""/dev/ttyI%d"",  min); break;
  case  46:  sprintf(buf, ""/dev/ttyR%d"",  min); break;
  case  48:  sprintf(buf, ""/dev/ttyL%d"",  min); break;
",1,unused,228,unused,"  case  24:  sprintf(buf, ""/dev/ttyE%d"",  min); break;
  case  32:  sprintf(buf, ""/dev/ttyX%d"",  min); break;
  case  43:  sprintf(buf, ""/dev/ttyI%d"",  min); break;
  case  46:  sprintf(buf, ""/dev/ttyR%d"",  min); break;
  case  48:  sprintf(buf, ""/dev/ttyL%d"",  min); break;
",unused,matejak_openscap-src2FOVAL2Fprobes2Funix2Fprocess58-devname.c
"  case  32:  sprintf(buf, ""/dev/ttyX%d"",  min); break;
  case  43:  sprintf(buf, ""/dev/ttyI%d"",  min); break;
  case  46:  sprintf(buf, ""/dev/ttyR%d"",  min); break;
  case  48:  sprintf(buf, ""/dev/ttyL%d"",  min); break;
  case  57:  sprintf(buf, ""/dev/ttyP%d"",  min); break;
",1,unused,229,unused,"  case  32:  sprintf(buf, ""/dev/ttyX%d"",  min); break;
  case  43:  sprintf(buf, ""/dev/ttyI%d"",  min); break;
  case  46:  sprintf(buf, ""/dev/ttyR%d"",  min); break;
  case  48:  sprintf(buf, ""/dev/ttyL%d"",  min); break;
  case  57:  sprintf(buf, ""/dev/ttyP%d"",  min); break;
",unused,matejak_openscap-src2FOVAL2Fprobes2Funix2Fprocess58-devname.c
"  case  43:  sprintf(buf, ""/dev/ttyI%d"",  min); break;
  case  46:  sprintf(buf, ""/dev/ttyR%d"",  min); break;
  case  48:  sprintf(buf, ""/dev/ttyL%d"",  min); break;
  case  57:  sprintf(buf, ""/dev/ttyP%d"",  min); break;
  case  71:  sprintf(buf, ""/dev/ttyF%d"",  min); break;
",1,unused,230,unused,"  case  43:  sprintf(buf, ""/dev/ttyI%d"",  min); break;
  case  46:  sprintf(buf, ""/dev/ttyR%d"",  min); break;
  case  48:  sprintf(buf, ""/dev/ttyL%d"",  min); break;
  case  57:  sprintf(buf, ""/dev/ttyP%d"",  min); break;
  case  71:  sprintf(buf, ""/dev/ttyF%d"",  min); break;
",unused,matejak_openscap-src2FOVAL2Fprobes2Funix2Fprocess58-devname.c
"  case  46:  sprintf(buf, ""/dev/ttyR%d"",  min); break;
  case  48:  sprintf(buf, ""/dev/ttyL%d"",  min); break;
  case  57:  sprintf(buf, ""/dev/ttyP%d"",  min); break;
  case  71:  sprintf(buf, ""/dev/ttyF%d"",  min); break;
  case  75:  sprintf(buf, ""/dev/ttyW%d"",  min); break;
",1,unused,231,unused,"  case  46:  sprintf(buf, ""/dev/ttyR%d"",  min); break;
  case  48:  sprintf(buf, ""/dev/ttyL%d"",  min); break;
  case  57:  sprintf(buf, ""/dev/ttyP%d"",  min); break;
  case  71:  sprintf(buf, ""/dev/ttyF%d"",  min); break;
  case  75:  sprintf(buf, ""/dev/ttyW%d"",  min); break;
",unused,matejak_openscap-src2FOVAL2Fprobes2Funix2Fprocess58-devname.c
"  case  48:  sprintf(buf, ""/dev/ttyL%d"",  min); break;
  case  57:  sprintf(buf, ""/dev/ttyP%d"",  min); break;
  case  71:  sprintf(buf, ""/dev/ttyF%d"",  min); break;
  case  75:  sprintf(buf, ""/dev/ttyW%d"",  min); break;
  case  78:  sprintf(buf, ""/dev/ttyM%d"",  min); break; /* conflict */
",1,unused,232,unused,"  case  48:  sprintf(buf, ""/dev/ttyL%d"",  min); break;
  case  57:  sprintf(buf, ""/dev/ttyP%d"",  min); break;
  case  71:  sprintf(buf, ""/dev/ttyF%d"",  min); break;
  case  75:  sprintf(buf, ""/dev/ttyW%d"",  min); break;
  case  78:  sprintf(buf, ""/dev/ttyM%d"",  min); break; /* conflict */
",unused,matejak_openscap-src2FOVAL2Fprobes2Funix2Fprocess58-devname.c
"  case  57:  sprintf(buf, ""/dev/ttyP%d"",  min); break;
  case  71:  sprintf(buf, ""/dev/ttyF%d"",  min); break;
  case  75:  sprintf(buf, ""/dev/ttyW%d"",  min); break;
  case  78:  sprintf(buf, ""/dev/ttyM%d"",  min); break; /* conflict */
  case 105:  sprintf(buf, ""/dev/ttyV%d"",  min); break;
",1,unused,233,unused,"  case  57:  sprintf(buf, ""/dev/ttyP%d"",  min); break;
  case  71:  sprintf(buf, ""/dev/ttyF%d"",  min); break;
  case  75:  sprintf(buf, ""/dev/ttyW%d"",  min); break;
  case  78:  sprintf(buf, ""/dev/ttyM%d"",  min); break; /* conflict */
  case 105:  sprintf(buf, ""/dev/ttyV%d"",  min); break;
",unused,matejak_openscap-src2FOVAL2Fprobes2Funix2Fprocess58-devname.c
"  case  71:  sprintf(buf, ""/dev/ttyF%d"",  min); break;
  case  75:  sprintf(buf, ""/dev/ttyW%d"",  min); break;
  case  78:  sprintf(buf, ""/dev/ttyM%d"",  min); break; /* conflict */
  case 105:  sprintf(buf, ""/dev/ttyV%d"",  min); break;
  case 112:  sprintf(buf, ""/dev/ttyM%d"",  min); break; /* conflict */
",1,unused,234,unused,"  case  71:  sprintf(buf, ""/dev/ttyF%d"",  min); break;
  case  75:  sprintf(buf, ""/dev/ttyW%d"",  min); break;
  case  78:  sprintf(buf, ""/dev/ttyM%d"",  min); break; /* conflict */
  case 105:  sprintf(buf, ""/dev/ttyV%d"",  min); break;
  case 112:  sprintf(buf, ""/dev/ttyM%d"",  min); break; /* conflict */
",unused,matejak_openscap-src2FOVAL2Fprobes2Funix2Fprocess58-devname.c
"  case  78:  sprintf(buf, ""/dev/ttyM%d"",  min); break; /* conflict */
  case 105:  sprintf(buf, ""/dev/ttyV%d"",  min); break;
  case 112:  sprintf(buf, ""/dev/ttyM%d"",  min); break; /* conflict */
  /* 136 ... 143 are /dev/pts/0, /dev/pts/1, /dev/pts/2 ... */
  case 136 ... 143:  sprintf(buf, ""/dev/pts/%d"",  min+(maj-136)*256); break;
",1,unused,236,unused,"  case  78:  sprintf(buf, ""/dev/ttyM%d"",  min); break; /* conflict */
  case 105:  sprintf(buf, ""/dev/ttyV%d"",  min); break;
  case 112:  sprintf(buf, ""/dev/ttyM%d"",  min); break; /* conflict */
  /* 136 ... 143 are /dev/pts/0, /dev/pts/1, /dev/pts/2 ... */
  case 136 ... 143:  sprintf(buf, ""/dev/pts/%d"",  min+(maj-136)*256); break;
",unused,matejak_openscap-src2FOVAL2Fprobes2Funix2Fprocess58-devname.c
"  case 105:  sprintf(buf, ""/dev/ttyV%d"",  min); break;
  case 112:  sprintf(buf, ""/dev/ttyM%d"",  min); break; /* conflict */
  /* 136 ... 143 are /dev/pts/0, /dev/pts/1, /dev/pts/2 ... */
  case 136 ... 143:  sprintf(buf, ""/dev/pts/%d"",  min+(maj-136)*256); break;
  case 148:  sprintf(buf, ""/dev/ttyT%d"",  min); break;
",1,unused,237,unused,"  case 105:  sprintf(buf, ""/dev/ttyV%d"",  min); break;
  case 112:  sprintf(buf, ""/dev/ttyM%d"",  min); break; /* conflict */
  /* 136 ... 143 are /dev/pts/0, /dev/pts/1, /dev/pts/2 ... */
  case 136 ... 143:  sprintf(buf, ""/dev/pts/%d"",  min+(maj-136)*256); break;
  case 148:  sprintf(buf, ""/dev/ttyT%d"",  min); break;
",unused,matejak_openscap-src2FOVAL2Fprobes2Funix2Fprocess58-devname.c
"  case 112:  sprintf(buf, ""/dev/ttyM%d"",  min); break; /* conflict */
  /* 136 ... 143 are /dev/pts/0, /dev/pts/1, /dev/pts/2 ... */
  case 136 ... 143:  sprintf(buf, ""/dev/pts/%d"",  min+(maj-136)*256); break;
  case 148:  sprintf(buf, ""/dev/ttyT%d"",  min); break;
  case 154:  sprintf(buf, ""/dev/ttySR%d"", min); break;
",1,unused,238,unused,"  case 112:  sprintf(buf, ""/dev/ttyM%d"",  min); break; /* conflict */
  /* 136 ... 143 are /dev/pts/0, /dev/pts/1, /dev/pts/2 ... */
  case 136 ... 143:  sprintf(buf, ""/dev/pts/%d"",  min+(maj-136)*256); break;
  case 148:  sprintf(buf, ""/dev/ttyT%d"",  min); break;
  case 154:  sprintf(buf, ""/dev/ttySR%d"", min); break;
",unused,matejak_openscap-src2FOVAL2Fprobes2Funix2Fprocess58-devname.c
"  /* 136 ... 143 are /dev/pts/0, /dev/pts/1, /dev/pts/2 ... */
  case 136 ... 143:  sprintf(buf, ""/dev/pts/%d"",  min+(maj-136)*256); break;
  case 148:  sprintf(buf, ""/dev/ttyT%d"",  min); break;
  case 154:  sprintf(buf, ""/dev/ttySR%d"", min); break;
  case 156:  sprintf(buf, ""/dev/ttySR%d"", min+256); break;
",1,unused,239,unused,"  /* 136 ... 143 are /dev/pts/0, /dev/pts/1, /dev/pts/2 ... */
  case 136 ... 143:  sprintf(buf, ""/dev/pts/%d"",  min+(maj-136)*256); break;
  case 148:  sprintf(buf, ""/dev/ttyT%d"",  min); break;
  case 154:  sprintf(buf, ""/dev/ttySR%d"", min); break;
  case 156:  sprintf(buf, ""/dev/ttySR%d"", min+256); break;
",unused,matejak_openscap-src2FOVAL2Fprobes2Funix2Fprocess58-devname.c
"  case 136 ... 143:  sprintf(buf, ""/dev/pts/%d"",  min+(maj-136)*256); break;
  case 148:  sprintf(buf, ""/dev/ttyT%d"",  min); break;
  case 154:  sprintf(buf, ""/dev/ttySR%d"", min); break;
  case 156:  sprintf(buf, ""/dev/ttySR%d"", min+256); break;
  case 164:  sprintf(buf, ""/dev/ttyCH%d"",  min); break;
",1,unused,240,unused,"  case 136 ... 143:  sprintf(buf, ""/dev/pts/%d"",  min+(maj-136)*256); break;
  case 148:  sprintf(buf, ""/dev/ttyT%d"",  min); break;
  case 154:  sprintf(buf, ""/dev/ttySR%d"", min); break;
  case 156:  sprintf(buf, ""/dev/ttySR%d"", min+256); break;
  case 164:  sprintf(buf, ""/dev/ttyCH%d"",  min); break;
",unused,matejak_openscap-src2FOVAL2Fprobes2Funix2Fprocess58-devname.c
"  case 148:  sprintf(buf, ""/dev/ttyT%d"",  min); break;
  case 154:  sprintf(buf, ""/dev/ttySR%d"", min); break;
  case 156:  sprintf(buf, ""/dev/ttySR%d"", min+256); break;
  case 164:  sprintf(buf, ""/dev/ttyCH%d"",  min); break;
  case 166:  sprintf(buf, ""/dev/ttyACM%d"", min); break; /* bummer, 9-char */
",1,unused,241,unused,"  case 148:  sprintf(buf, ""/dev/ttyT%d"",  min); break;
  case 154:  sprintf(buf, ""/dev/ttySR%d"", min); break;
  case 156:  sprintf(buf, ""/dev/ttySR%d"", min+256); break;
  case 164:  sprintf(buf, ""/dev/ttyCH%d"",  min); break;
  case 166:  sprintf(buf, ""/dev/ttyACM%d"", min); break; /* bummer, 9-char */
",unused,matejak_openscap-src2FOVAL2Fprobes2Funix2Fprocess58-devname.c
"  case 154:  sprintf(buf, ""/dev/ttySR%d"", min); break;
  case 156:  sprintf(buf, ""/dev/ttySR%d"", min+256); break;
  case 164:  sprintf(buf, ""/dev/ttyCH%d"",  min); break;
  case 166:  sprintf(buf, ""/dev/ttyACM%d"", min); break; /* bummer, 9-char */
  case 172:  sprintf(buf, ""/dev/ttyMX%d"",  min); break;
",1,unused,242,unused,"  case 154:  sprintf(buf, ""/dev/ttySR%d"", min); break;
  case 156:  sprintf(buf, ""/dev/ttySR%d"", min+256); break;
  case 164:  sprintf(buf, ""/dev/ttyCH%d"",  min); break;
  case 166:  sprintf(buf, ""/dev/ttyACM%d"", min); break; /* bummer, 9-char */
  case 172:  sprintf(buf, ""/dev/ttyMX%d"",  min); break;
",unused,matejak_openscap-src2FOVAL2Fprobes2Funix2Fprocess58-devname.c
"  case 156:  sprintf(buf, ""/dev/ttySR%d"", min+256); break;
  case 164:  sprintf(buf, ""/dev/ttyCH%d"",  min); break;
  case 166:  sprintf(buf, ""/dev/ttyACM%d"", min); break; /* bummer, 9-char */
  case 172:  sprintf(buf, ""/dev/ttyMX%d"",  min); break;
  case 174:  sprintf(buf, ""/dev/ttySI%d"",  min); break;
",1,unused,243,unused,"  case 156:  sprintf(buf, ""/dev/ttySR%d"", min+256); break;
  case 164:  sprintf(buf, ""/dev/ttyCH%d"",  min); break;
  case 166:  sprintf(buf, ""/dev/ttyACM%d"", min); break; /* bummer, 9-char */
  case 172:  sprintf(buf, ""/dev/ttyMX%d"",  min); break;
  case 174:  sprintf(buf, ""/dev/ttySI%d"",  min); break;
",unused,matejak_openscap-src2FOVAL2Fprobes2Funix2Fprocess58-devname.c
"  case 164:  sprintf(buf, ""/dev/ttyCH%d"",  min); break;
  case 166:  sprintf(buf, ""/dev/ttyACM%d"", min); break; /* bummer, 9-char */
  case 172:  sprintf(buf, ""/dev/ttyMX%d"",  min); break;
  case 174:  sprintf(buf, ""/dev/ttySI%d"",  min); break;
  case 188:  sprintf(buf, ""/dev/ttyUSB%d"", min); break; /* bummer, 9-char */
",1,unused,244,unused,"  case 164:  sprintf(buf, ""/dev/ttyCH%d"",  min); break;
  case 166:  sprintf(buf, ""/dev/ttyACM%d"", min); break; /* bummer, 9-char */
  case 172:  sprintf(buf, ""/dev/ttyMX%d"",  min); break;
  case 174:  sprintf(buf, ""/dev/ttySI%d"",  min); break;
  case 188:  sprintf(buf, ""/dev/ttyUSB%d"", min); break; /* bummer, 9-char */
",unused,matejak_openscap-src2FOVAL2Fprobes2Funix2Fprocess58-devname.c
"    memcpy(buf+8, low_density_names[min], sizeof low_density_names[0]);
    buf[8 + sizeof low_density_names[0]] = '\0';
//    snprintf(buf, 9 + sizeof low_density_names[0], ""/dev/tty%.*s"", sizeof low_density_names[0], low_density_names[min]);
    break;
  case 208:  sprintf(buf, ""/dev/ttyU%d"",  min); break;
",1,unused,252,unused,"    memcpy(buf+8, low_density_names[min], sizeof low_density_names[0]);
    buf[8 + sizeof low_density_names[0]] = '\0';
//    snprintf(buf, 9 + sizeof low_density_names[0], ""/dev/tty%.*s"", sizeof low_density_names[0], low_density_names[min]);
    break;
  case 208:  sprintf(buf, ""/dev/ttyU%d"",  min); break;
",unused,matejak_openscap-src2FOVAL2Fprobes2Funix2Fprocess58-devname.c
"    buf[8 + sizeof low_density_names[0]] = '\0';
//    snprintf(buf, 9 + sizeof low_density_names[0], ""/dev/tty%.*s"", sizeof low_density_names[0], low_density_names[min]);
    break;
  case 208:  sprintf(buf, ""/dev/ttyU%d"",  min); break;
  case 216:  sprintf(buf, ""/dev/ttyUB%d"",  min); break; // ""/dev/rfcomm%d"" now?
",1,unused,253,unused,"    buf[8 + sizeof low_density_names[0]] = '\0';
//    snprintf(buf, 9 + sizeof low_density_names[0], ""/dev/tty%.*s"", sizeof low_density_names[0], low_density_names[min]);
    break;
  case 208:  sprintf(buf, ""/dev/ttyU%d"",  min); break;
  case 216:  sprintf(buf, ""/dev/ttyUB%d"",  min); break; // ""/dev/rfcomm%d"" now?
",unused,matejak_openscap-src2FOVAL2Fprobes2Funix2Fprocess58-devname.c
"//    snprintf(buf, 9 + sizeof low_density_names[0], ""/dev/tty%.*s"", sizeof low_density_names[0], low_density_names[min]);
    break;
  case 208:  sprintf(buf, ""/dev/ttyU%d"",  min); break;
  case 216:  sprintf(buf, ""/dev/ttyUB%d"",  min); break; // ""/dev/rfcomm%d"" now?
  case 224:  sprintf(buf, ""/dev/ttyY%d"",  min); break;
",1,unused,254,unused,"//    snprintf(buf, 9 + sizeof low_density_names[0], ""/dev/tty%.*s"", sizeof low_density_names[0], low_density_names[min]);
    break;
  case 208:  sprintf(buf, ""/dev/ttyU%d"",  min); break;
  case 216:  sprintf(buf, ""/dev/ttyUB%d"",  min); break; // ""/dev/rfcomm%d"" now?
  case 224:  sprintf(buf, ""/dev/ttyY%d"",  min); break;
",unused,matejak_openscap-src2FOVAL2Fprobes2Funix2Fprocess58-devname.c
"    break;
  case 208:  sprintf(buf, ""/dev/ttyU%d"",  min); break;
  case 216:  sprintf(buf, ""/dev/ttyUB%d"",  min); break; // ""/dev/rfcomm%d"" now?
  case 224:  sprintf(buf, ""/dev/ttyY%d"",  min); break;
  case 227:  sprintf(buf, ""/dev/3270/tty%d"", min); break; /* bummer, HUGE */
",1,unused,255,unused,"    break;
  case 208:  sprintf(buf, ""/dev/ttyU%d"",  min); break;
  case 216:  sprintf(buf, ""/dev/ttyUB%d"",  min); break; // ""/dev/rfcomm%d"" now?
  case 224:  sprintf(buf, ""/dev/ttyY%d"",  min); break;
  case 227:  sprintf(buf, ""/dev/3270/tty%d"", min); break; /* bummer, HUGE */
",unused,matejak_openscap-src2FOVAL2Fprobes2Funix2Fprocess58-devname.c
"  case 208:  sprintf(buf, ""/dev/ttyU%d"",  min); break;
  case 216:  sprintf(buf, ""/dev/ttyUB%d"",  min); break; // ""/dev/rfcomm%d"" now?
  case 224:  sprintf(buf, ""/dev/ttyY%d"",  min); break;
  case 227:  sprintf(buf, ""/dev/3270/tty%d"", min); break; /* bummer, HUGE */
  case 229:  sprintf(buf, ""/dev/iseries/vtty%d"",  min); break; /* bummer, HUGE */
",1,unused,256,unused,"  case 208:  sprintf(buf, ""/dev/ttyU%d"",  min); break;
  case 216:  sprintf(buf, ""/dev/ttyUB%d"",  min); break; // ""/dev/rfcomm%d"" now?
  case 224:  sprintf(buf, ""/dev/ttyY%d"",  min); break;
  case 227:  sprintf(buf, ""/dev/3270/tty%d"", min); break; /* bummer, HUGE */
  case 229:  sprintf(buf, ""/dev/iseries/vtty%d"",  min); break; /* bummer, HUGE */
",unused,matejak_openscap-src2FOVAL2Fprobes2Funix2Fprocess58-devname.c
"  case 216:  sprintf(buf, ""/dev/ttyUB%d"",  min); break; // ""/dev/rfcomm%d"" now?
  case 224:  sprintf(buf, ""/dev/ttyY%d"",  min); break;
  case 227:  sprintf(buf, ""/dev/3270/tty%d"", min); break; /* bummer, HUGE */
  case 229:  sprintf(buf, ""/dev/iseries/vtty%d"",  min); break; /* bummer, HUGE */
  case 256:  sprintf(buf, ""/dev/ttyEQ%d"",  min); break;
",1,unused,257,unused,"  case 216:  sprintf(buf, ""/dev/ttyUB%d"",  min); break; // ""/dev/rfcomm%d"" now?
  case 224:  sprintf(buf, ""/dev/ttyY%d"",  min); break;
  case 227:  sprintf(buf, ""/dev/3270/tty%d"", min); break; /* bummer, HUGE */
  case 229:  sprintf(buf, ""/dev/iseries/vtty%d"",  min); break; /* bummer, HUGE */
  case 256:  sprintf(buf, ""/dev/ttyEQ%d"",  min); break;
",unused,matejak_openscap-src2FOVAL2Fprobes2Funix2Fprocess58-devname.c
"static int link_name(char *restrict const buf, unsigned maj, unsigned min, int pid, const char *restrict name){
  struct stat sbuf;
  char path[32];
  int count;
  sprintf(path, ""/proc/%d/%s"", pid, name);  /* often permission denied */
",1,unused,274,unused,"static int link_name(char *restrict const buf, unsigned maj, unsigned min, int pid, const char *restrict name){
  struct stat sbuf;
  char path[32];
  int count;
  sprintf(path, ""/proc/%d/%s"", pid, name);  /* often permission denied */
",unused,matejak_openscap-src2FOVAL2Fprobes2Funix2Fprocess58-devname.c
"  if( guess_name(tmp, MAJOR_OF(dev), MINOR_OF(dev)               )) goto abbrev;
  if(  link_name(tmp, MAJOR_OF(dev), MINOR_OF(dev), pid, ""fd/255"")) goto abbrev;
  // fall through if unable to find a device file
no_tty:
  strcpy(ret, ""?"");
",1,unused,298,unused,"  if( guess_name(tmp, MAJOR_OF(dev), MINOR_OF(dev)               )) goto abbrev;
  if(  link_name(tmp, MAJOR_OF(dev), MINOR_OF(dev), pid, ""fd/255"")) goto abbrev;
  // fall through if unable to find a device file
no_tty:
  strcpy(ret, ""?"");
",unused,matejak_openscap-src2FOVAL2Fprobes2Funix2Fprocess58-devname.c
"						dW(""Can't open includedir: %s; %d, %s."", inclarg, errno, strerror (errno));
						break;
					}

					strcpy (pathbuf, inclarg);
",1,unused,759,unused,"						dW(""Can't open includedir: %s; %d, %s."", inclarg, errno, strerror (errno));
						break;
					}

					strcpy (pathbuf, inclarg);
",unused,matejak_openscap-src2FOVAL2Fprobes2Funix2Fxinetd.c
"							dI(""Skipping: %s"", dent.d_name);
							continue;
						}

						strcpy(pathbuf + incllen, dent.d_name);
",1,unused,790,unused,"							dI(""Skipping: %s"", dent.d_name);
							continue;
						}

						strcpy(pathbuf + incllen, dent.d_name);
",unused,matejak_openscap-src2FOVAL2Fprobes2Funix2Fxinetd.c
"		 * Add entry to the ttree for (name, protocol) -> (id) translation
		 * (in case it's not already there)
		 */
		st = NULL;
		strcpy(st_key, scur->name);
",1,unused,1130,unused,"		 * Add entry to the ttree for (name, protocol) -> (id) translation
		 * (in case it's not already there)
		 */
		st = NULL;
		strcpy(st_key, scur->name);
",unused,matejak_openscap-src2FOVAL2Fprobes2Funix2Fxinetd.c
"		 * (in case it's not already there)
		 */
		st = NULL;
		strcpy(st_key, scur->name);
		strcat(st_key, scur->protocol);
",1,unused,1131,unused,"		 * (in case it's not already there)
		 */
		st = NULL;
		strcpy(st_key, scur->name);
		strcat(st_key, scur->protocol);
",unused,matejak_openscap-src2FOVAL2Fprobes2Funix2Fxinetd.c
"
	if (strlen(name) + strlen(prot) > XICFG_STRANS_MAXKEYLEN)
		return (NULL);

	strcpy(strans_key, name);
",1,unused,1204,unused,"
	if (strlen(name) + strlen(prot) > XICFG_STRANS_MAXKEYLEN)
		return (NULL);

	strcpy(strans_key, name);
",unused,matejak_openscap-src2FOVAL2Fprobes2Funix2Fxinetd.c
"	if (strlen(name) + strlen(prot) > XICFG_STRANS_MAXKEYLEN)
		return (NULL);

	strcpy(strans_key, name);
	strcat(strans_key, prot);
",1,unused,1205,unused,"	if (strlen(name) + strlen(prot) > XICFG_STRANS_MAXKEYLEN)
		return (NULL);

	strcpy(strans_key, name);
	strcat(strans_key, prot);
",unused,matejak_openscap-src2FOVAL2Fprobes2Funix2Fxinetd.c
"	int len = strlen(""(null)"");;
	char buf[32];
	if (str)
		len = strlen(str);
	sprintf(buf, ""%%.%ds"", max);
",1,unused,465,unused,"	int len = strlen(""(null)"");;
	char buf[32];
	if (str)
		len = strlen(str);
	sprintf(buf, ""%%.%ds"", max);
",unused,matejak_openscap-src2FXCCDF2Felements.c
"
bool xccdf_target_fact_set_number(struct xccdf_target_fact *fact, xccdf_numeric val)
{
    char buff[XCCDF_NUMERIC_SIZE];
    sprintf(buff, XCCDF_NUMERIC_FORMAT, val);
",1,unused,411,unused,"
bool xccdf_target_fact_set_number(struct xccdf_target_fact *fact, xccdf_numeric val)
{
    char buff[XCCDF_NUMERIC_SIZE];
    sprintf(buff, XCCDF_NUMERIC_FORMAT, val);
",unused,matejak_openscap-src2FXCCDF2Fresult.c
"    {
        // we have to enforce a certain type of ids for XCCDF 1.2+

        char rid[32+strlen(id)];
        sprintf(rid, ""xccdf_org.open-scap_testresult_%s"", id);
",1,unused,2051,unused,"    {
        // we have to enforce a certain type of ids for XCCDF 1.2+

        char rid[32+strlen(id)];
        sprintf(rid, ""xccdf_org.open-scap_testresult_%s"", id);
",unused,matejak_openscap-src2FXCCDF_POLICY2Fxccdf_policy.c
"
    	// previous behaviour for backwards compatibility

        char rid[11+strlen(id)];
        sprintf(rid, ""OSCAP-Test-%s"", id);
",1,unused,2059,unused,"
    	// previous behaviour for backwards compatibility

        char rid[11+strlen(id)];
        sprintf(rid, ""OSCAP-Test-%s"", id);
",unused,matejak_openscap-src2FXCCDF_POLICY2Fxccdf_policy.c
"	        radeonScreen->device_id);

	driGetRendererString(buffer, hardwarename, agp_mode);

	strcat(buffer, "" DRI2"");
",1,unused,96,unused,"	        radeonScreen->device_id);

	driGetRendererString(buffer, hardwarename, agp_mode);

	strcat(buffer, "" DRI2"");
",unused,mesa-release-src2Fmesa2Fdrivers2Fdri2Fr2002Fradeon_common_context.c
"	if (r->parent == r->id) mm_sprintf_lite(s, ""\ts2:i:%d"", r->subsc);
	if (r->div >= 0.0f && r->div <= 1.0f) {
		char buf[8];
		if (r->div == 0.0f) buf[0] = '0', buf[1] = 0;
		else sprintf(buf, ""%.4f"", r->div);
",1,unused,253,unused,"	if (r->parent == r->id) mm_sprintf_lite(s, ""\ts2:i:%d"", r->subsc);
	if (r->div >= 0.0f && r->div <= 1.0f) {
		char buf[8];
		if (r->div == 0.0f) buf[0] = '0', buf[1] = 0;
		else sprintf(buf, ""%.4f"", r->div);
",unused,minimap2-1-format.c
"				mm_idx_seq_t *seq = &p->mi->seq[p->mi->n_seq];
				uint32_t j;
				if (!(p->mi->flag & MM_I_NO_NAME)) {
					seq->name = (char*)kmalloc(p->mi->km, strlen(s->seq[i].name) + 1);
					strcpy(seq->name, s->seq[i].name);
",1,unused,298,unused,"				mm_idx_seq_t *seq = &p->mi->seq[p->mi->n_seq];
				uint32_t j;
				if (!(p->mi->flag & MM_I_NO_NAME)) {
					seq->name = (char*)kmalloc(p->mi->km, strlen(s->seq[i].name) + 1);
					strcpy(seq->name, s->seq[i].name);
",unused,minimap2-1-index.c
"		mm_idx_seq_t *p = &mi->seq[i];
		uint32_t j;
		if (name && name[i]) {
			p->name = (char*)kmalloc(mi->km, strlen(name[i]) + 1);
			strcpy(p->name, name[i]);
",1,unused,390,unused,"		mm_idx_seq_t *p = &mi->seq[i];
		uint32_t j;
		if (name && name[i]) {
			p->name = (char*)kmalloc(mi->km, strlen(name[i]) + 1);
			strcpy(p->name, name[i]);
",unused,minimap2-1-index.c
"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    /* FIX: Use a fixed string that does not contain a format specifier */
    strcpy(data, ""fixedstringtest"");
",1,unused,109,unused,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    /* FIX: Use a fixed string that does not contain a format specifier */
    strcpy(data, ""fixedstringtest"");
",unused,minime-CWE134_Uncontrolled_Format_String__char_connect_socket_fprintf_01.c
"    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = (char *)calloc(100, sizeof(char));
    if (data == NULL) {exit(-1);}
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",1,unused,32,unused,"    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = (char *)calloc(100, sizeof(char));
    if (data == NULL) {exit(-1);}
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",unused,minime-CWE401_Memory_Leak__char_calloc_01.c
"    data = NULL;
    /* FIX: Use memory allocated on the stack with ALLOCA */
    data = (char *)ALLOCA(100*sizeof(char));
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",1,unused,50,unused,"    data = NULL;
    /* FIX: Use memory allocated on the stack with ALLOCA */
    data = (char *)ALLOCA(100*sizeof(char));
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",unused,minime-CWE401_Memory_Leak__char_calloc_01.c
"    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = (char *)calloc(100, sizeof(char));
    if (data == NULL) {exit(-1);}
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",1,unused,65,unused,"    /* POTENTIAL FLAW: Allocate memory on the heap */
    data = (char *)calloc(100, sizeof(char));
    if (data == NULL) {exit(-1);}
    /* Initialize and make use of data */
    strcpy(data, ""A String"");
",unused,minime-CWE401_Memory_Leak__char_calloc_01.c
"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    /* FLAW: the full path is not specified */
    strcpy(data, BAD_OS_COMMAND);
",1,unused,31,unused,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    /* FLAW: the full path is not specified */
    strcpy(data, BAD_OS_COMMAND);
",unused,minime-CWE426_Untrusted_Search_Path__char_popen_01.c
"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    /* FIX: full path is specified */
    strcpy(data, GOOD_OS_COMMAND);
",1,unused,55,unused,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    /* FIX: full path is specified */
    strcpy(data, GOOD_OS_COMMAND);
",unused,minime-CWE426_Untrusted_Search_Path__char_popen_01.c
"{
    {
        char dataBuffer[100] = """";
        char * data = dataBuffer;
        strcpy(data, ""abcdefghijklmnopqrstuvwxyz"");
",1,unused,27,unused,"{
    {
        char dataBuffer[100] = """";
        char * data = dataBuffer;
        strcpy(data, ""abcdefghijklmnopqrstuvwxyz"");
",unused,minime-CWE475_Undefined_Behavior_for_Input_to_API__char_01.c
"{
    {
        char dataBuffer[100] = """";
        char * data = dataBuffer;
        strcpy(data, ""abcdefghijklmnopqrstuvwxyz"");
",1,unused,43,unused,"{
    {
        char dataBuffer[100] = """";
        char * data = dataBuffer;
        strcpy(data, ""abcdefghijklmnopqrstuvwxyz"");
",unused,minime-CWE475_Undefined_Behavior_for_Input_to_API__char_01.c
"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    /* FIX: Set data to a number less than MAX_LOOP */
    strcpy(data, ""15"");
",1,unused,85,unused,"    char * data;
    char dataBuffer[100] = """";
    data = dataBuffer;
    /* FIX: Set data to a number less than MAX_LOOP */
    strcpy(data, ""15"");
",unused,minime-CWE606_Unchecked_Loop_Condition__char_console_01.c
"        char source[100];
        memset(source, 'C', 100-1); /* fill with 'C's */
        source[100-1] = '\0'; /* null terminate */
        /* POTENTIAL FLAW: If data is not initialized properly, strcat() may not function correctly */
        strcat(data, source);
",1,unused,35,unused,"        char source[100];
        memset(source, 'C', 100-1); /* fill with 'C's */
        source[100-1] = '\0'; /* null terminate */
        /* POTENTIAL FLAW: If data is not initialized properly, strcat() may not function correctly */
        strcat(data, source);
",unused,minime-CWE665_Improper_Initialization__char_cat_01.c
"        char source[100];
        memset(source, 'C', 100-1); /* fill with 'C's */
        source[100-1] = '\0'; /* null terminate */
        /* POTENTIAL FLAW: If data is not initialized properly, strcat() may not function correctly */
        strcat(data, source);
",1,unused,57,unused,"        char source[100];
        memset(source, 'C', 100-1); /* fill with 'C's */
        source[100-1] = '\0'; /* null terminate */
        /* POTENTIAL FLAW: If data is not initialized properly, strcat() may not function correctly */
        strcat(data, source);
",unused,minime-CWE665_Improper_Initialization__char_cat_01.c
"{
    {
        char dest[DEST_SIZE];
        /* FLAW: Incorrect number of arguments */
        sprintf(dest, ""%s %s"", SOURCE_STRING);
",1,unused,28,unused,"{
    {
        char dest[DEST_SIZE];
        /* FLAW: Incorrect number of arguments */
        sprintf(dest, ""%s %s"", SOURCE_STRING);
",unused,minime-CWE685_Function_Call_With_Incorrect_Number_of_Arguments__basic_01.c
"{
    {
        char dest[DEST_SIZE];
        /* FIX: Use the correct number of arguments */
        sprintf(dest, ""%s %s"", SOURCE_STRING, SOURCE_STRING);
",1,unused,42,unused,"{
    {
        char dest[DEST_SIZE];
        /* FIX: Use the correct number of arguments */
        sprintf(dest, ""%s %s"", SOURCE_STRING, SOURCE_STRING);
",unused,minime-CWE685_Function_Call_With_Incorrect_Number_of_Arguments__basic_01.c
"    data = NULL; /* Initialize data */
    /* POTENTIAL FLAW: Allocate memory without checking if the memory allocation function failed */
    data = (char *)calloc(20, sizeof(char));
    /* FLAW: Initialize memory buffer without checking to see if the memory allocation function failed */
    strcpy(data, ""Initialize"");
",1,unused,30,unused,"    data = NULL; /* Initialize data */
    /* POTENTIAL FLAW: Allocate memory without checking if the memory allocation function failed */
    data = (char *)calloc(20, sizeof(char));
    /* FLAW: Initialize memory buffer without checking to see if the memory allocation function failed */
    strcpy(data, ""Initialize"");
",unused,minime-CWE690_NULL_Deref_From_Return__char_calloc_01.c
"    data = (char *)calloc(20, sizeof(char));
    /* FIX: Check to see if the memory allocation function was successful before initializing the memory buffer */
    if (data != NULL)
    {
        strcpy(data, ""Initialize"");
",1,unused,49,unused,"    data = (char *)calloc(20, sizeof(char));
    /* FIX: Check to see if the memory allocation function was successful before initializing the memory buffer */
    if (data != NULL)
    {
        strcpy(data, ""Initialize"");
",unused,minime-CWE690_NULL_Deref_From_Return__char_calloc_01.c
"        {
            myString = (char *)malloc(data*sizeof(char));
            if (myString == NULL) {exit(-1);}
            /* Copy a small string into myString */
            strcpy(myString, HELLO_STRING);
",1,unused,95,unused,"        {
            myString = (char *)malloc(data*sizeof(char));
            if (myString == NULL) {exit(-1);}
            /* Copy a small string into myString */
            strcpy(myString, HELLO_STRING);
",unused,minime-CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_01.c
"        {
            myString = (char *)malloc(data*sizeof(char));
            if (myString == NULL) {exit(-1);}
            /* Copy a small string into myString */
            strcpy(myString, HELLO_STRING);
",1,unused,128,unused,"        {
            myString = (char *)malloc(data*sizeof(char));
            if (myString == NULL) {exit(-1);}
            /* Copy a small string into myString */
            strcpy(myString, HELLO_STRING);
",unused,minime-CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_01.c
"        {
            myString = (char *)malloc(data*sizeof(char));
            if (myString == NULL) {exit(-1);}
            /* Copy a small string into myString */
            strcpy(myString, HELLO_STRING);
",1,unused,194,unused,"        {
            myString = (char *)malloc(data*sizeof(char));
            if (myString == NULL) {exit(-1);}
            /* Copy a small string into myString */
            strcpy(myString, HELLO_STRING);
",unused,minime-CWE789_Uncontrolled_Mem_Alloc__malloc_char_connect_socket_01.c
"  if (special)
    {
      /* special number: nan or inf */
      pretty = mpc_alloc_str (sz);
      strcpy (pretty, str);
",1,unused,94,unused,"  if (special)
    {
      /* special number: nan or inf */
      pretty = mpc_alloc_str (sz);
      strcpy (pretty, str);
",unused,mpclib3debstretche-src2Fget_x.c
"#endif
  *p = '\0';

  /* 3. other significant digits */
  strcat (pretty, s);
",1,unused,161,unused,"#endif
  *p = '\0';

  /* 3. other significant digits */
  strcat (pretty, s);
",unused,mpclib3debstretche-src2Fget_x.c
"    }

  *p = '\0';

  sprintf (p, ""%+""MPC_EXP_FORMAT_SPEC, x);
",1,unused,184,unused,"    }

  *p = '\0';

  sprintf (p, ""%+""MPC_EXP_FORMAT_SPEC, x);
",unused,mpclib3debstretche-src2Fget_x.c
"
  complex_str = mpc_alloc_str (needed_size);
MPC_ASSERT (complex_str != NULL);

  strcpy (complex_str, ""("");
",1,unused,226,unused,"
  complex_str = mpc_alloc_str (needed_size);
MPC_ASSERT (complex_str != NULL);

  strcpy (complex_str, ""("");
",unused,mpclib3debstretche-src2Fget_x.c
"  complex_str = mpc_alloc_str (needed_size);
MPC_ASSERT (complex_str != NULL);

  strcpy (complex_str, ""("");
  strcat (complex_str, real_str);
",1,unused,227,unused,"  complex_str = mpc_alloc_str (needed_size);
MPC_ASSERT (complex_str != NULL);

  strcpy (complex_str, ""("");
  strcat (complex_str, real_str);
",unused,mpclib3debstretche-src2Fget_x.c
"MPC_ASSERT (complex_str != NULL);

  strcpy (complex_str, ""("");
  strcat (complex_str, real_str);
  strcat (complex_str, "" "");
",1,unused,228,unused,"MPC_ASSERT (complex_str != NULL);

  strcpy (complex_str, ""("");
  strcat (complex_str, real_str);
  strcat (complex_str, "" "");
",unused,mpclib3debstretche-src2Fget_x.c
"
  strcpy (complex_str, ""("");
  strcat (complex_str, real_str);
  strcat (complex_str, "" "");
  strcat (complex_str, imag_str);
",1,unused,229,unused,"
  strcpy (complex_str, ""("");
  strcat (complex_str, real_str);
  strcat (complex_str, "" "");
  strcat (complex_str, imag_str);
",unused,mpclib3debstretche-src2Fget_x.c
"  strcpy (complex_str, ""("");
  strcat (complex_str, real_str);
  strcat (complex_str, "" "");
  strcat (complex_str, imag_str);
  strcat (complex_str, "")"");
",1,unused,230,unused,"  strcpy (complex_str, ""("");
  strcat (complex_str, real_str);
  strcat (complex_str, "" "");
  strcat (complex_str, imag_str);
  strcat (complex_str, "")"");
",unused,mpclib3debstretche-src2Fget_x.c
"      strsize = nread + 1;
    }

    /* Warning: the sprintf does not allow overlap between arguments. */
    ret = sprintf (str + lenstr, ""(%s"", suffix);
",1,unused,135,unused,"      strsize = nread + 1;
    }

    /* Warning: the sprintf does not allow overlap between arguments. */
    ret = sprintf (str + lenstr, ""(%s"", suffix);
",unused,mpclib3debstretche-src2Finp_str.c
"       imag_str = extract_string (stream);
       nread += strlen (imag_str);

       str = mpc_alloc_str (nread + 2);
       ret = sprintf (str, ""(%s %s"", real_str, imag_str);
",1,unused,201,unused,"       imag_str = extract_string (stream);
       nread += strlen (imag_str);

       str = mpc_alloc_str (nread + 2);
       ret = sprintf (str, ""(%s %s"", real_str, imag_str);
",unused,mpclib3debstretche-src2Finp_str.c
"  if (special)
    {
      /* special number: nan or inf */
      pretty = mpc_alloc_str (sz);
      strcpy (pretty, str);
",1,unused,94,unused,"  if (special)
    {
      /* special number: nan or inf */
      pretty = mpc_alloc_str (sz);
      strcpy (pretty, str);
",unused,mpclib3patchxen-src2Fget_x.c
"#endif
  *p = '\0';

  /* 3. other significant digits */
  strcat (pretty, s);
",1,unused,161,unused,"#endif
  *p = '\0';

  /* 3. other significant digits */
  strcat (pretty, s);
",unused,mpclib3patchxen-src2Fget_x.c
"    }

  *p = '\0';

  sprintf (p, ""%+""MPC_EXP_FORMAT_SPEC, x);
",1,unused,184,unused,"    }

  *p = '\0';

  sprintf (p, ""%+""MPC_EXP_FORMAT_SPEC, x);
",unused,mpclib3patchxen-src2Fget_x.c
"
  complex_str = mpc_alloc_str (needed_size);
MPC_ASSERT (complex_str != NULL);

  strcpy (complex_str, ""("");
",1,unused,226,unused,"
  complex_str = mpc_alloc_str (needed_size);
MPC_ASSERT (complex_str != NULL);

  strcpy (complex_str, ""("");
",unused,mpclib3patchxen-src2Fget_x.c
"  complex_str = mpc_alloc_str (needed_size);
MPC_ASSERT (complex_str != NULL);

  strcpy (complex_str, ""("");
  strcat (complex_str, real_str);
",1,unused,227,unused,"  complex_str = mpc_alloc_str (needed_size);
MPC_ASSERT (complex_str != NULL);

  strcpy (complex_str, ""("");
  strcat (complex_str, real_str);
",unused,mpclib3patchxen-src2Fget_x.c
"MPC_ASSERT (complex_str != NULL);

  strcpy (complex_str, ""("");
  strcat (complex_str, real_str);
  strcat (complex_str, "" "");
",1,unused,228,unused,"MPC_ASSERT (complex_str != NULL);

  strcpy (complex_str, ""("");
  strcat (complex_str, real_str);
  strcat (complex_str, "" "");
",unused,mpclib3patchxen-src2Fget_x.c
"
  strcpy (complex_str, ""("");
  strcat (complex_str, real_str);
  strcat (complex_str, "" "");
  strcat (complex_str, imag_str);
",1,unused,229,unused,"
  strcpy (complex_str, ""("");
  strcat (complex_str, real_str);
  strcat (complex_str, "" "");
  strcat (complex_str, imag_str);
",unused,mpclib3patchxen-src2Fget_x.c
"  strcpy (complex_str, ""("");
  strcat (complex_str, real_str);
  strcat (complex_str, "" "");
  strcat (complex_str, imag_str);
  strcat (complex_str, "")"");
",1,unused,230,unused,"  strcpy (complex_str, ""("");
  strcat (complex_str, real_str);
  strcat (complex_str, "" "");
  strcat (complex_str, imag_str);
  strcat (complex_str, "")"");
",unused,mpclib3patchxen-src2Fget_x.c
"      strsize = nread + 1;
    }

    /* Warning: the sprintf does not allow overlap between arguments. */
    ret = sprintf (str + lenstr, ""(%s"", suffix);
",1,unused,135,unused,"      strsize = nread + 1;
    }

    /* Warning: the sprintf does not allow overlap between arguments. */
    ret = sprintf (str + lenstr, ""(%s"", suffix);
",unused,mpclib3patchxen-src2Finp_str.c
"       imag_str = extract_string (stream);
       nread += strlen (imag_str);

       str = mpc_alloc_str (nread + 2);
       ret = sprintf (str, ""(%s %s"", real_str, imag_str);
",1,unused,201,unused,"       imag_str = extract_string (stream);
       nread += strlen (imag_str);

       str = mpc_alloc_str (nread + 2);
       ret = sprintf (str, ""(%s %s"", real_str, imag_str);
",unused,mpclib3patchxen-src2Finp_str.c
"  if (special)
    {
      /* special number: nan or inf */
      pretty = mpc_alloc_str (sz);
      strcpy (pretty, str);
",1,unused,94,unused,"  if (special)
    {
      /* special number: nan or inf */
      pretty = mpc_alloc_str (sz);
      strcpy (pretty, str);
",unused,mpclib3trusty-src2Fget_x.c
"#endif
  *p = '\0';

  /* 3. other significant digits */
  strcat (pretty, s);
",1,unused,161,unused,"#endif
  *p = '\0';

  /* 3. other significant digits */
  strcat (pretty, s);
",unused,mpclib3trusty-src2Fget_x.c
"    }

  *p = '\0';

  sprintf (p, ""%+""MPC_EXP_FORMAT_SPEC, x);
",1,unused,184,unused,"    }

  *p = '\0';

  sprintf (p, ""%+""MPC_EXP_FORMAT_SPEC, x);
",unused,mpclib3trusty-src2Fget_x.c
"
  complex_str = mpc_alloc_str (needed_size);
MPC_ASSERT (complex_str != NULL);

  strcpy (complex_str, ""("");
",1,unused,226,unused,"
  complex_str = mpc_alloc_str (needed_size);
MPC_ASSERT (complex_str != NULL);

  strcpy (complex_str, ""("");
",unused,mpclib3trusty-src2Fget_x.c
"  complex_str = mpc_alloc_str (needed_size);
MPC_ASSERT (complex_str != NULL);

  strcpy (complex_str, ""("");
  strcat (complex_str, real_str);
",1,unused,227,unused,"  complex_str = mpc_alloc_str (needed_size);
MPC_ASSERT (complex_str != NULL);

  strcpy (complex_str, ""("");
  strcat (complex_str, real_str);
",unused,mpclib3trusty-src2Fget_x.c
"MPC_ASSERT (complex_str != NULL);

  strcpy (complex_str, ""("");
  strcat (complex_str, real_str);
  strcat (complex_str, "" "");
",1,unused,228,unused,"MPC_ASSERT (complex_str != NULL);

  strcpy (complex_str, ""("");
  strcat (complex_str, real_str);
  strcat (complex_str, "" "");
",unused,mpclib3trusty-src2Fget_x.c
"
  strcpy (complex_str, ""("");
  strcat (complex_str, real_str);
  strcat (complex_str, "" "");
  strcat (complex_str, imag_str);
",1,unused,229,unused,"
  strcpy (complex_str, ""("");
  strcat (complex_str, real_str);
  strcat (complex_str, "" "");
  strcat (complex_str, imag_str);
",unused,mpclib3trusty-src2Fget_x.c
"  strcpy (complex_str, ""("");
  strcat (complex_str, real_str);
  strcat (complex_str, "" "");
  strcat (complex_str, imag_str);
  strcat (complex_str, "")"");
",1,unused,230,unused,"  strcpy (complex_str, ""("");
  strcat (complex_str, real_str);
  strcat (complex_str, "" "");
  strcat (complex_str, imag_str);
  strcat (complex_str, "")"");
",unused,mpclib3trusty-src2Fget_x.c
"      strsize = nread + 1;
    }

    /* Warning: the sprintf does not allow overlap between arguments. */
    ret = sprintf (str + lenstr, ""(%s"", suffix);
",1,unused,135,unused,"      strsize = nread + 1;
    }

    /* Warning: the sprintf does not allow overlap between arguments. */
    ret = sprintf (str + lenstr, ""(%s"", suffix);
",unused,mpclib3trusty-src2Finp_str.c
"       imag_str = extract_string (stream);
       nread += strlen (imag_str);

       str = mpc_alloc_str (nread + 2);
       ret = sprintf (str, ""(%s %s"", real_str, imag_str);
",1,unused,201,unused,"       imag_str = extract_string (stream);
       nread += strlen (imag_str);

       str = mpc_alloc_str (nread + 2);
       ret = sprintf (str, ""(%s %s"", real_str, imag_str);
",unused,mpclib3trusty-src2Finp_str.c
"  if (special)
    {
      /* special number: nan or inf */
      pretty = mpc_alloc_str (sz);
      strcpy (pretty, str);
",1,unused,94,unused,"  if (special)
    {
      /* special number: nan or inf */
      pretty = mpc_alloc_str (sz);
      strcpy (pretty, str);
",unused,mpclib3xenial-src2Fget_x.c
"#endif
  *p = '\0';

  /* 3. other significant digits */
  strcat (pretty, s);
",1,unused,161,unused,"#endif
  *p = '\0';

  /* 3. other significant digits */
  strcat (pretty, s);
",unused,mpclib3xenial-src2Fget_x.c
"    }

  *p = '\0';

  sprintf (p, ""%+""MPC_EXP_FORMAT_SPEC, x);
",1,unused,184,unused,"    }

  *p = '\0';

  sprintf (p, ""%+""MPC_EXP_FORMAT_SPEC, x);
",unused,mpclib3xenial-src2Fget_x.c
"
  complex_str = mpc_alloc_str (needed_size);
MPC_ASSERT (complex_str != NULL);

  strcpy (complex_str, ""("");
",1,unused,226,unused,"
  complex_str = mpc_alloc_str (needed_size);
MPC_ASSERT (complex_str != NULL);

  strcpy (complex_str, ""("");
",unused,mpclib3xenial-src2Fget_x.c
"  complex_str = mpc_alloc_str (needed_size);
MPC_ASSERT (complex_str != NULL);

  strcpy (complex_str, ""("");
  strcat (complex_str, real_str);
",1,unused,227,unused,"  complex_str = mpc_alloc_str (needed_size);
MPC_ASSERT (complex_str != NULL);

  strcpy (complex_str, ""("");
  strcat (complex_str, real_str);
",unused,mpclib3xenial-src2Fget_x.c
"MPC_ASSERT (complex_str != NULL);

  strcpy (complex_str, ""("");
  strcat (complex_str, real_str);
  strcat (complex_str, "" "");
",1,unused,228,unused,"MPC_ASSERT (complex_str != NULL);

  strcpy (complex_str, ""("");
  strcat (complex_str, real_str);
  strcat (complex_str, "" "");
",unused,mpclib3xenial-src2Fget_x.c
"
  strcpy (complex_str, ""("");
  strcat (complex_str, real_str);
  strcat (complex_str, "" "");
  strcat (complex_str, imag_str);
",1,unused,229,unused,"
  strcpy (complex_str, ""("");
  strcat (complex_str, real_str);
  strcat (complex_str, "" "");
  strcat (complex_str, imag_str);
",unused,mpclib3xenial-src2Fget_x.c
"  strcpy (complex_str, ""("");
  strcat (complex_str, real_str);
  strcat (complex_str, "" "");
  strcat (complex_str, imag_str);
  strcat (complex_str, "")"");
",1,unused,230,unused,"  strcpy (complex_str, ""("");
  strcat (complex_str, real_str);
  strcat (complex_str, "" "");
  strcat (complex_str, imag_str);
  strcat (complex_str, "")"");
",unused,mpclib3xenial-src2Fget_x.c
"      strsize = nread + 1;
    }

    /* Warning: the sprintf does not allow overlap between arguments. */
    ret = sprintf (str + lenstr, ""(%s"", suffix);
",1,unused,135,unused,"      strsize = nread + 1;
    }

    /* Warning: the sprintf does not allow overlap between arguments. */
    ret = sprintf (str + lenstr, ""(%s"", suffix);
",unused,mpclib3xenial-src2Finp_str.c
"       imag_str = extract_string (stream);
       nread += strlen (imag_str);

       str = mpc_alloc_str (nread + 2);
       ret = sprintf (str, ""(%s %s"", real_str, imag_str);
",1,unused,201,unused,"       imag_str = extract_string (stream);
       nread += strlen (imag_str);

       str = mpc_alloc_str (nread + 2);
       ret = sprintf (str, ""(%s %s"", real_str, imag_str);
",unused,mpclib3xenial-src2Finp_str.c
"  if (MPFR_UNLIKELY (MPFR_IS_NAN (x)))
    {
      if (s == NULL)
        s = (char *) (*__gmp_allocate_func) (6);
      strcpy (s, ""@NaN@"");
",1,unused,2272,unused,"  if (MPFR_UNLIKELY (MPFR_IS_NAN (x)))
    {
      if (s == NULL)
        s = (char *) (*__gmp_allocate_func) (6);
      strcpy (s, ""@NaN@"");
",unused,mpfr4xenial-src2Fget_str.c
"  if (MPFR_UNLIKELY (MPFR_IS_INF (x)))
    {
      if (s == NULL)
        s = (char *) (*__gmp_allocate_func) (neg + 6);
      strcpy (s, (neg) ? ""-@Inf@"" : ""@Inf@"");
",1,unused,2282,unused,"  if (MPFR_UNLIKELY (MPFR_IS_INF (x)))
    {
      if (s == NULL)
        s = (char *) (*__gmp_allocate_func) (neg + 6);
      strcpy (s, (neg) ? ""-@Inf@"" : ""@Inf@"");
",unused,mpfr4xenial-src2Fget_str.c
"  char *str;
  int ret;

  GET_STR (ret, str, fmt);
  ret = sprintf (buf, ""%s"", str);
",1,unused,143,unused,"  char *str;
  int ret;

  GET_STR (ret, str, fmt);
  ret = sprintf (buf, ""%s"", str);
",unused,mpfr4xenial-src2Fprintf.c
"  char *str;
  int ret;

  GET_STR_VA (ret, str, fmt, ap);
  ret = sprintf (buf, ""%s"", str);
",1,unused,156,unused,"  char *str;
  int ret;

  GET_STR_VA (ret, str, fmt, ap);
  ret = sprintf (buf, ""%s"", str);
",unused,mpfr4xenial-src2Fprintf.c
"                         or ""P%+.2li"" */

    exp_fmt[0] = uppercase ? 'P' : 'p';
    exp_fmt[1] = '\0';
    strcat (exp_fmt, ""%+.1"" MPFR_EXP_FSPEC ""d"");
",1,unused,1037,unused,"                         or ""P%+.2li"" */

    exp_fmt[0] = uppercase ? 'P' : 'p';
    exp_fmt[1] = '\0';
    strcat (exp_fmt, ""%+.1"" MPFR_EXP_FSPEC ""d"");
",unused,mpfr4xenial-src2Fvasprintf.c
"    exp_fmt[0] = uppercase ? 'P' : 'p';
    exp_fmt[1] = '\0';
    strcat (exp_fmt, ""%+.1"" MPFR_EXP_FSPEC ""d"");

    if (sprintf (str, exp_fmt, (mpfr_eexp_t) exp) < 0)
",1,unused,1039,unused,"    exp_fmt[0] = uppercase ? 'P' : 'p';
    exp_fmt[1] = '\0';
    strcat (exp_fmt, ""%+.1"" MPFR_EXP_FSPEC ""d"");

    if (sprintf (str, exp_fmt, (mpfr_eexp_t) exp) < 0)
",unused,mpfr4xenial-src2Fvasprintf.c
"    char exp_fmt[8];  /* e.g. ""e%+.2i"", or ""E%+.2li"" */

    exp_fmt[0] = uppercase ? 'E' : 'e';
    exp_fmt[1] = '\0';
    strcat (exp_fmt, ""%+.2"" MPFR_EXP_FSPEC ""d"");
",1,unused,1164,unused,"    char exp_fmt[8];  /* e.g. ""e%+.2i"", or ""E%+.2li"" */

    exp_fmt[0] = uppercase ? 'E' : 'e';
    exp_fmt[1] = '\0';
    strcat (exp_fmt, ""%+.2"" MPFR_EXP_FSPEC ""d"");
",unused,mpfr4xenial-src2Fvasprintf.c
"    exp_fmt[0] = uppercase ? 'E' : 'e';
    exp_fmt[1] = '\0';
    strcat (exp_fmt, ""%+.2"" MPFR_EXP_FSPEC ""d"");

    if (sprintf (str, exp_fmt, (mpfr_eexp_t) exp) < 0)
",1,unused,1166,unused,"    exp_fmt[0] = uppercase ? 'E' : 'e';
    exp_fmt[1] = '\0';
    strcat (exp_fmt, ""%+.2"" MPFR_EXP_FSPEC ""d"");

    if (sprintf (str, exp_fmt, (mpfr_eexp_t) exp) < 0)
",unused,mpfr4xenial-src2Fvasprintf.c
"          if (uppercase)
            {
              np->ip_size = MPFR_NAN_STRING_LENGTH;
              str = (char *) (*__gmp_allocate_func) (1 + np->ip_size);
              strcpy (str, MPFR_NAN_STRING_UC);
",1,unused,1495,unused,"          if (uppercase)
            {
              np->ip_size = MPFR_NAN_STRING_LENGTH;
              str = (char *) (*__gmp_allocate_func) (1 + np->ip_size);
              strcpy (str, MPFR_NAN_STRING_UC);
",unused,mpfr4xenial-src2Fvasprintf.c
"          else
            {
              np->ip_size = MPFR_NAN_STRING_LENGTH;
              str = (char *) (*__gmp_allocate_func) (1 + np->ip_size);
              strcpy (str, MPFR_NAN_STRING_LC);
",1,unused,1502,unused,"          else
            {
              np->ip_size = MPFR_NAN_STRING_LENGTH;
              str = (char *) (*__gmp_allocate_func) (1 + np->ip_size);
              strcpy (str, MPFR_NAN_STRING_LC);
",unused,mpfr4xenial-src2Fvasprintf.c
"          if (uppercase)
            {
              np->ip_size = MPFR_INF_STRING_LENGTH;
              str = (char *) (*__gmp_allocate_func) (1 + np->ip_size);
              strcpy (str, MPFR_INF_STRING_UC);
",1,unused,1520,unused,"          if (uppercase)
            {
              np->ip_size = MPFR_INF_STRING_LENGTH;
              str = (char *) (*__gmp_allocate_func) (1 + np->ip_size);
              strcpy (str, MPFR_INF_STRING_UC);
",unused,mpfr4xenial-src2Fvasprintf.c
"          else
            {
              np->ip_size = MPFR_INF_STRING_LENGTH;
              str = (char *) (*__gmp_allocate_func) (1 + np->ip_size);
              strcpy (str, MPFR_INF_STRING_LC);
",1,unused,1527,unused,"          else
            {
              np->ip_size = MPFR_INF_STRING_LENGTH;
              str = (char *) (*__gmp_allocate_func) (1 + np->ip_size);
              strcpy (str, MPFR_INF_STRING_LC);
",unused,mpfr4xenial-src2Fvasprintf.c
"            {
              np->exp_size = (spec.spec == 'e' || spec.spec == 'E') ? 4 : 3;
              str = (char *) (*__gmp_allocate_func) (1 + np->exp_size);
              if (spec.spec == 'e' || spec.spec == 'E')
                strcpy (str, uppercase ? ""E+00"" : ""e+00"");
",1,unused,1579,unused,"            {
              np->exp_size = (spec.spec == 'e' || spec.spec == 'E') ? 4 : 3;
              str = (char *) (*__gmp_allocate_func) (1 + np->exp_size);
              if (spec.spec == 'e' || spec.spec == 'E')
                strcpy (str, uppercase ? ""E+00"" : ""e+00"");
",unused,mpfr4xenial-src2Fvasprintf.c
"              str = (char *) (*__gmp_allocate_func) (1 + np->exp_size);
              if (spec.spec == 'e' || spec.spec == 'E')
                strcpy (str, uppercase ? ""E+00"" : ""e+00"");
              else
                strcpy (str, uppercase ? ""P+0"" : ""p+0"");
",1,unused,1581,unused,"              str = (char *) (*__gmp_allocate_func) (1 + np->exp_size);
              if (spec.spec == 'e' || spec.spec == 'E')
                strcpy (str, uppercase ? ""E+00"" : ""e+00"");
              else
                strcpy (str, uppercase ? ""P+0"" : ""p+0"");
",unused,mpfr4xenial-src2Fvasprintf.c
"          format[1] = '*';
          format[2] = '.';
          format[3] = '*';
          format[4] = '\0';
          strcat (format, MPFR_PREC_FORMAT_TYPE);
",1,unused,1993,unused,"          format[1] = '*';
          format[2] = '.';
          format[3] = '*';
          format[4] = '\0';
          strcat (format, MPFR_PREC_FORMAT_TYPE);
",unused,mpfr4xenial-src2Fvasprintf.c
"  if (MPFR_UNLIKELY (MPFR_IS_NAN (x)))
    {
      if (s == NULL)
        s = (char *) (*__gmp_allocate_func) (6);
      strcpy (s, ""@NaN@"");
",1,unused,2272,unused,"  if (MPFR_UNLIKELY (MPFR_IS_NAN (x)))
    {
      if (s == NULL)
        s = (char *) (*__gmp_allocate_func) (6);
      strcpy (s, ""@NaN@"");
",unused,mprf4debstretche-src2Fget_str.c
"  if (MPFR_UNLIKELY (MPFR_IS_INF (x)))
    {
      if (s == NULL)
        s = (char *) (*__gmp_allocate_func) (neg + 6);
      strcpy (s, (neg) ? ""-@Inf@"" : ""@Inf@"");
",1,unused,2282,unused,"  if (MPFR_UNLIKELY (MPFR_IS_INF (x)))
    {
      if (s == NULL)
        s = (char *) (*__gmp_allocate_func) (neg + 6);
      strcpy (s, (neg) ? ""-@Inf@"" : ""@Inf@"");
",unused,mprf4debstretche-src2Fget_str.c
"  char *str;
  int ret;

  GET_STR (ret, str, fmt);
  ret = sprintf (buf, ""%s"", str);
",1,unused,143,unused,"  char *str;
  int ret;

  GET_STR (ret, str, fmt);
  ret = sprintf (buf, ""%s"", str);
",unused,mprf4debstretche-src2Fprintf.c
"  char *str;
  int ret;

  GET_STR_VA (ret, str, fmt, ap);
  ret = sprintf (buf, ""%s"", str);
",1,unused,156,unused,"  char *str;
  int ret;

  GET_STR_VA (ret, str, fmt, ap);
  ret = sprintf (buf, ""%s"", str);
",unused,mprf4debstretche-src2Fprintf.c
"                         or ""P%+.2li"" */

    exp_fmt[0] = uppercase ? 'P' : 'p';
    exp_fmt[1] = '\0';
    strcat (exp_fmt, ""%+.1"" MPFR_EXP_FSPEC ""d"");
",1,unused,1037,unused,"                         or ""P%+.2li"" */

    exp_fmt[0] = uppercase ? 'P' : 'p';
    exp_fmt[1] = '\0';
    strcat (exp_fmt, ""%+.1"" MPFR_EXP_FSPEC ""d"");
",unused,mprf4debstretche-src2Fvasprintf.c
"    exp_fmt[0] = uppercase ? 'P' : 'p';
    exp_fmt[1] = '\0';
    strcat (exp_fmt, ""%+.1"" MPFR_EXP_FSPEC ""d"");

    if (sprintf (str, exp_fmt, (mpfr_eexp_t) exp) < 0)
",1,unused,1039,unused,"    exp_fmt[0] = uppercase ? 'P' : 'p';
    exp_fmt[1] = '\0';
    strcat (exp_fmt, ""%+.1"" MPFR_EXP_FSPEC ""d"");

    if (sprintf (str, exp_fmt, (mpfr_eexp_t) exp) < 0)
",unused,mprf4debstretche-src2Fvasprintf.c
"    char exp_fmt[8];  /* e.g. ""e%+.2i"", or ""E%+.2li"" */

    exp_fmt[0] = uppercase ? 'E' : 'e';
    exp_fmt[1] = '\0';
    strcat (exp_fmt, ""%+.2"" MPFR_EXP_FSPEC ""d"");
",1,unused,1164,unused,"    char exp_fmt[8];  /* e.g. ""e%+.2i"", or ""E%+.2li"" */

    exp_fmt[0] = uppercase ? 'E' : 'e';
    exp_fmt[1] = '\0';
    strcat (exp_fmt, ""%+.2"" MPFR_EXP_FSPEC ""d"");
",unused,mprf4debstretche-src2Fvasprintf.c
"    exp_fmt[0] = uppercase ? 'E' : 'e';
    exp_fmt[1] = '\0';
    strcat (exp_fmt, ""%+.2"" MPFR_EXP_FSPEC ""d"");

    if (sprintf (str, exp_fmt, (mpfr_eexp_t) exp) < 0)
",1,unused,1166,unused,"    exp_fmt[0] = uppercase ? 'E' : 'e';
    exp_fmt[1] = '\0';
    strcat (exp_fmt, ""%+.2"" MPFR_EXP_FSPEC ""d"");

    if (sprintf (str, exp_fmt, (mpfr_eexp_t) exp) < 0)
",unused,mprf4debstretche-src2Fvasprintf.c
"          if (uppercase)
            {
              np->ip_size = MPFR_NAN_STRING_LENGTH;
              str = (char *) (*__gmp_allocate_func) (1 + np->ip_size);
              strcpy (str, MPFR_NAN_STRING_UC);
",1,unused,1495,unused,"          if (uppercase)
            {
              np->ip_size = MPFR_NAN_STRING_LENGTH;
              str = (char *) (*__gmp_allocate_func) (1 + np->ip_size);
              strcpy (str, MPFR_NAN_STRING_UC);
",unused,mprf4debstretche-src2Fvasprintf.c
"          else
            {
              np->ip_size = MPFR_NAN_STRING_LENGTH;
              str = (char *) (*__gmp_allocate_func) (1 + np->ip_size);
              strcpy (str, MPFR_NAN_STRING_LC);
",1,unused,1502,unused,"          else
            {
              np->ip_size = MPFR_NAN_STRING_LENGTH;
              str = (char *) (*__gmp_allocate_func) (1 + np->ip_size);
              strcpy (str, MPFR_NAN_STRING_LC);
",unused,mprf4debstretche-src2Fvasprintf.c
"          if (uppercase)
            {
              np->ip_size = MPFR_INF_STRING_LENGTH;
              str = (char *) (*__gmp_allocate_func) (1 + np->ip_size);
              strcpy (str, MPFR_INF_STRING_UC);
",1,unused,1520,unused,"          if (uppercase)
            {
              np->ip_size = MPFR_INF_STRING_LENGTH;
              str = (char *) (*__gmp_allocate_func) (1 + np->ip_size);
              strcpy (str, MPFR_INF_STRING_UC);
",unused,mprf4debstretche-src2Fvasprintf.c
"          else
            {
              np->ip_size = MPFR_INF_STRING_LENGTH;
              str = (char *) (*__gmp_allocate_func) (1 + np->ip_size);
              strcpy (str, MPFR_INF_STRING_LC);
",1,unused,1527,unused,"          else
            {
              np->ip_size = MPFR_INF_STRING_LENGTH;
              str = (char *) (*__gmp_allocate_func) (1 + np->ip_size);
              strcpy (str, MPFR_INF_STRING_LC);
",unused,mprf4debstretche-src2Fvasprintf.c
"            {
              np->exp_size = (spec.spec == 'e' || spec.spec == 'E') ? 4 : 3;
              str = (char *) (*__gmp_allocate_func) (1 + np->exp_size);
              if (spec.spec == 'e' || spec.spec == 'E')
                strcpy (str, uppercase ? ""E+00"" : ""e+00"");
",1,unused,1579,unused,"            {
              np->exp_size = (spec.spec == 'e' || spec.spec == 'E') ? 4 : 3;
              str = (char *) (*__gmp_allocate_func) (1 + np->exp_size);
              if (spec.spec == 'e' || spec.spec == 'E')
                strcpy (str, uppercase ? ""E+00"" : ""e+00"");
",unused,mprf4debstretche-src2Fvasprintf.c
"              str = (char *) (*__gmp_allocate_func) (1 + np->exp_size);
              if (spec.spec == 'e' || spec.spec == 'E')
                strcpy (str, uppercase ? ""E+00"" : ""e+00"");
              else
                strcpy (str, uppercase ? ""P+0"" : ""p+0"");
",1,unused,1581,unused,"              str = (char *) (*__gmp_allocate_func) (1 + np->exp_size);
              if (spec.spec == 'e' || spec.spec == 'E')
                strcpy (str, uppercase ? ""E+00"" : ""e+00"");
              else
                strcpy (str, uppercase ? ""P+0"" : ""p+0"");
",unused,mprf4debstretche-src2Fvasprintf.c
"          format[1] = '*';
          format[2] = '.';
          format[3] = '*';
          format[4] = '\0';
          strcat (format, MPFR_PREC_FORMAT_TYPE);
",1,unused,1993,unused,"          format[1] = '*';
          format[2] = '.';
          format[3] = '*';
          format[4] = '\0';
          strcat (format, MPFR_PREC_FORMAT_TYPE);
",unused,mprf4debstretche-src2Fvasprintf.c
"	case 'm':
	  maxPairEndedDistance = atoi(optarg);
	  break;					
	case 'g':
	  strcpy(readGroup, optarg);
",1,unused,198,unused,"	case 'm':
	  maxPairEndedDistance = atoi(optarg);
	  break;					
	case 'g':
	  strcpy(readGroup, optarg);
",unused,mrFast1-CommandLineParser.c
"	case 'g':
	  strcpy(readGroup, optarg);
	  break;					
	case 'p':
	  strcpy(sampleName, optarg);
",1,unused,201,unused,"	case 'g':
	  strcpy(readGroup, optarg);
	  break;					
	case 'p':
	  strcpy(sampleName, optarg);
",unused,mrFast1-CommandLineParser.c
"	case 'p':
	  strcpy(sampleName, optarg);
	  break;					
	case 'r':
	  strcpy(libName, optarg);
",1,unused,204,unused,"	case 'p':
	  strcpy(sampleName, optarg);
	  break;					
	case 'r':
	  strcpy(libName, optarg);
",unused,mrFast1-CommandLineParser.c
"	}

    }

  sprintf(fileName[0], ""%s"", fastaFile);
",1,unused,344,unused,"	}

    }

  sprintf(fileName[0], ""%s"", fastaFile);
",unused,mrFast1-CommandLineParser.c
"
    }

  sprintf(fileName[0], ""%s"", fastaFile);
  sprintf(fileName[1], ""%s.index"", fileName[0]); 
",1,unused,345,unused,"
    }

  sprintf(fileName[0], ""%s"", fastaFile);
  sprintf(fileName[1], ""%s.index"", fileName[0]); 
",unused,mrFast1-CommandLineParser.c
"    }

  if (pos != -1)
    {
      sprintf(*fileName, ""%s%c"", (full+pos+1), '\0');
",1,unused,188,unused,"    }

  if (pos != -1)
    {
      sprintf(*fileName, ""%s%c"", (full+pos+1), '\0');
",unused,mrFast1-Common.c
"  if (pos != -1)
    {
      sprintf(*fileName, ""%s%c"", (full+pos+1), '\0');
      full[pos+1]='\0';
      sprintf(*path,""%s%c"", full, '\0');
",1,unused,190,unused,"  if (pos != -1)
    {
      sprintf(*fileName, ""%s%c"", (full+pos+1), '\0');
      full[pos+1]='\0';
      sprintf(*path,""%s%c"", full, '\0');
",unused,mrFast1-Common.c
"      sprintf(*path,""%s%c"", full, '\0');
    }
  else
    {
      sprintf(*fileName, ""%s%c"", full, '\0');
",1,unused,194,unused,"      sprintf(*path,""%s%c"", full, '\0');
    }
  else
    {
      sprintf(*fileName, ""%s%c"", full, '\0');
",unused,mrFast1-Common.c
"    }
  else
    {
      sprintf(*fileName, ""%s%c"", full, '\0');
      sprintf(*path,""%c"", '\0');
",1,unused,195,unused,"    }
  else
    {
      sprintf(*fileName, ""%s%c"", full, '\0');
      sprintf(*path,""%c"", '\0');
",unused,mrFast1-Common.c
"      if ( strcmp(prev, refGenName) != 0)
	{
	  fprintf(stderr, ""\n - %s "", refGenName);
	  fflush(stderr);
	  sprintf(prev, ""%s"", refGenName);
",1,unused,245,unused,"      if ( strcmp(prev, refGenName) != 0)
	{
	  fprintf(stderr, ""\n - %s "", refGenName);
	  fflush(stderr);
	  sprintf(prev, ""%s"", refGenName);
",unused,mrFast1-HashTable.c
"      _msf_optionalFields = getMem(2 * sizeof(OPT_FIELDS));
    }

    for (i = 0; i < 200; i++) {
      sprintf(_msf_numbers[i], ""%d%c"", i, '\0');
",1,unused,885,unused,"      _msf_optionalFields = getMem(2 * sizeof(OPT_FIELDS));
    }

    for (i = 0; i < 200; i++) {
      sprintf(_msf_numbers[i], ""%d%c"", i, '\0');
",unused,mrFast1-MrFAST.c
"
    for (i = 0; i < 200; i++) {
      sprintf(_msf_numbers[i], ""%d%c"", i, '\0');
    }
    sprintf(_msf_cigar, ""%dM"", SEQ_LENGTH);
",1,unused,887,unused,"
    for (i = 0; i < 200; i++) {
      sprintf(_msf_numbers[i], ""%d%c"", i, '\0');
    }
    sprintf(_msf_cigar, ""%dM"", SEQ_LENGTH);
",unused,mrFast1-MrFAST.c
"  char rmatrixR[SEQ_MAX_LENGTH];

  reverse(matrixR, rmatrixR, strlen(matrixR));

  sprintf(matrix, ""%s%s%s"", matrixL, middle, rmatrixR);
",1,unused,1382,unused,"  char rmatrixR[SEQ_MAX_LENGTH];

  reverse(matrixR, rmatrixR, strlen(matrixR));

  sprintf(matrix, ""%s%s%s"", matrixL, middle, rmatrixR);
",unused,mrFast1-MrFAST.c
"  while (i < matrixLength) {
    if (matrix[i] == 'M') {
      counterM++;
      if (counterI != 0) {
	sprintf(cigar, ""%s%dI"", cigar, counterI);
",1,unused,1416,unused,"  while (i < matrixLength) {
    if (matrix[i] == 'M') {
      counterM++;
      if (counterI != 0) {
	sprintf(cigar, ""%s%dI"", cigar, counterI);
",unused,mrFast1-MrFAST.c
"	cigarSize += addCigarSize(counterI) + 1;
	cigar[cigarSize] = '\0';
	counterI = 0;
      } else if (counterD != 0) {
	sprintf(cigar, ""%s%dD"", cigar, counterD);
",1,unused,1421,unused,"	cigarSize += addCigarSize(counterI) + 1;
	cigar[cigarSize] = '\0';
	counterI = 0;
      } else if (counterD != 0) {
	sprintf(cigar, ""%s%dD"", cigar, counterD);
",unused,mrFast1-MrFAST.c
"	counterD = 0;
      }
    } else if (matrix[i] == 'I') {
      if (counterM != 0) {
	sprintf(cigar, ""%s%dM"", cigar, counterM);
",1,unused,1428,unused,"	counterD = 0;
      }
    } else if (matrix[i] == 'I') {
      if (counterM != 0) {
	sprintf(cigar, ""%s%dM"", cigar, counterM);
",unused,mrFast1-MrFAST.c
"	cigarSize += addCigarSize(counterM) + 1;
	cigar[cigarSize] = '\0';
	counterM = 0;
      } else if (counterD != 0) {
	sprintf(cigar, ""%s%dD"", cigar, counterD);
",1,unused,1433,unused,"	cigarSize += addCigarSize(counterM) + 1;
	cigar[cigarSize] = '\0';
	counterM = 0;
      } else if (counterD != 0) {
	sprintf(cigar, ""%s%dD"", cigar, counterD);
",unused,mrFast1-MrFAST.c
"      i++;

    } else if (matrix[i] == 'D') {
      if (counterM != 0) {
	sprintf(cigar, ""%s%dM"", cigar, counterM);
",1,unused,1443,unused,"      i++;

    } else if (matrix[i] == 'D') {
      if (counterM != 0) {
	sprintf(cigar, ""%s%dM"", cigar, counterM);
",unused,mrFast1-MrFAST.c
"	cigarSize += addCigarSize(counterM) + 1;
	cigar[cigarSize] = '\0';
	counterM = 0;
      } else if (counterI != 0) {
	sprintf(cigar, ""%s%dI"", cigar, counterI);
",1,unused,1448,unused,"	cigarSize += addCigarSize(counterM) + 1;
	cigar[cigarSize] = '\0';
	counterM = 0;
      } else if (counterI != 0) {
	sprintf(cigar, ""%s%dI"", cigar, counterI);
",unused,mrFast1-MrFAST.c
"
    } else {
      counterM++;
      if (counterI != 0) {
	sprintf(cigar, ""%s%dI"", cigar, counterI);
",1,unused,1460,unused,"
    } else {
      counterM++;
      if (counterI != 0) {
	sprintf(cigar, ""%s%dI"", cigar, counterI);
",unused,mrFast1-MrFAST.c
"	cigarSize += addCigarSize(counterI) + 1;
	cigar[cigarSize] = '\0';
	counterI = 0;
      } else if (counterD != 0) {
	sprintf(cigar, ""%s%dD"", cigar, counterD);
",1,unused,1465,unused,"	cigarSize += addCigarSize(counterI) + 1;
	cigar[cigarSize] = '\0';
	counterI = 0;
      } else if (counterD != 0) {
	sprintf(cigar, ""%s%dD"", cigar, counterD);
",unused,mrFast1-MrFAST.c
"    i++;
  }

  if (counterM != 0) {
    sprintf(cigar, ""%s%dM"", cigar, counterM);
",1,unused,1475,unused,"    i++;
  }

  if (counterM != 0) {
    sprintf(cigar, ""%s%dM"", cigar, counterM);
",unused,mrFast1-MrFAST.c
"    cigarSize += addCigarSize(counterM) + 1;
    cigar[cigarSize] = '\0';
    counterM = 0;
  } else if (counterI != 0) {
    sprintf(cigar, ""%s%dI"", cigar, counterI);
",1,unused,1480,unused,"    cigarSize += addCigarSize(counterM) + 1;
    cigar[cigarSize] = '\0';
    counterM = 0;
  } else if (counterI != 0) {
    sprintf(cigar, ""%s%dI"", cigar, counterI);
",unused,mrFast1-MrFAST.c
"    cigarSize += addCigarSize(counterI) + 1;
    cigar[cigarSize] = '\0';
    counterI = 0;
  } else if (counterD != 0) {
    sprintf(cigar, ""%s%dD"", cigar, counterD);
",1,unused,1485,unused,"    cigarSize += addCigarSize(counterI) + 1;
    cigar[cigarSize] = '\0';
    counterI = 0;
  } else if (counterD != 0) {
    sprintf(cigar, ""%s%dD"", cigar, counterD);
",unused,mrFast1-MrFAST.c
"      counterM++;
      if (counterD != 0) {
	delete[counterD] = '\0';
	counterD = 0;
	sprintf(outputSNP, ""%s^%s"", outputSNP, delete);
",1,unused,1556,unused,"      counterM++;
      if (counterD != 0) {
	delete[counterD] = '\0';
	counterD = 0;
	sprintf(outputSNP, ""%s^%s"", outputSNP, delete);
",unused,mrFast1-MrFAST.c
"	delete[0] = '\0';
      }
    } else if (matrix[i] == 'D') {
      if (counterM != 0) {
	sprintf(outputSNP, ""%s%d"", outputSNP, counterM);
",1,unused,1563,unused,"	delete[0] = '\0';
      }
    } else if (matrix[i] == 'D') {
      if (counterM != 0) {
	sprintf(outputSNP, ""%s%d"", outputSNP, counterM);
",unused,mrFast1-MrFAST.c
"	// sprintf(outputSNP, ""%s%d\0"", outputSNP, counterM);
	//counterM++;
      } else if (counterD != 0) {
	delete[counterD] = '\0';
	sprintf(outputSNP, ""%s^%s"", outputSNP, delete);
",1,unused,1585,unused,"	// sprintf(outputSNP, ""%s%d\0"", outputSNP, counterM);
	//counterM++;
      } else if (counterD != 0) {
	delete[counterD] = '\0';
	sprintf(outputSNP, ""%s^%s"", outputSNP, delete);
",unused,mrFast1-MrFAST.c
"      i++;

    } else {
      if (counterM != 0) {
	sprintf(outputSNP, ""%s%d"", outputSNP, counterM);
",1,unused,1595,unused,"      i++;

    } else {
      if (counterM != 0) {
	sprintf(outputSNP, ""%s%d"", outputSNP, counterM);
",unused,mrFast1-MrFAST.c
"      }
      if (counterD != 0) {
	delete[counterD] = '\0';
	counterD = 0;
	sprintf(outputSNP, ""%s^%s"", outputSNP, delete);
",1,unused,1603,unused,"      }
      if (counterD != 0) {
	delete[counterD] = '\0';
	counterD = 0;
	sprintf(outputSNP, ""%s^%s"", outputSNP, delete);
",unused,mrFast1-MrFAST.c
"	snpSize += strlen(delete) + 1;
	outputSNP[snpSize] = '\0';
	delete[0] = '\0';
      }
      sprintf(outputSNP, ""%s%c"", outputSNP, matrix[i]);
",1,unused,1608,unused,"	snpSize += strlen(delete) + 1;
	outputSNP[snpSize] = '\0';
	delete[0] = '\0';
      }
      sprintf(outputSNP, ""%s%c"", outputSNP, matrix[i]);
",unused,mrFast1-MrFAST.c
"    i++;
  }

  if (counterM != 0) {
    sprintf(outputSNP, ""%s%d"", outputSNP, counterM);
",1,unused,1616,unused,"    i++;
  }

  if (counterM != 0) {
    sprintf(outputSNP, ""%s%d"", outputSNP, counterM);
",unused,mrFast1-MrFAST.c
"    outputSNP[snpSize] = '\0';
    counterM = 0;
  } else if (counterD != 0) {
    delete[counterD] = '\0';
    sprintf(outputSNP, ""%s^%s"", outputSNP, delete);
",1,unused,1622,unused,"    outputSNP[snpSize] = '\0';
    counterM = 0;
  } else if (counterD != 0) {
    delete[counterD] = '\0';
    sprintf(outputSNP, ""%s^%s"", outputSNP, delete);
",unused,mrFast1-MrFAST.c
"	tmp->next = NULL;
	tmp->loc[0] = genLoc * d; // d is required: DHL
	tmp->err[0] = err;
	tmp->cigarSize[0] = strlen(cigar);
	sprintf(tmp->cigar[0], ""%s"", cigar);
",1,unused,2131,unused,"	tmp->next = NULL;
	tmp->loc[0] = genLoc * d; // d is required: DHL
	tmp->err[0] = err;
	tmp->cigarSize[0] = strlen(cigar);
	sprintf(tmp->cigar[0], ""%s"", cigar);
",unused,mrFast1-MrFAST.c
"	tmp->err[0] = err;
	tmp->cigarSize[0] = strlen(cigar);
	sprintf(tmp->cigar[0], ""%s"", cigar);
	tmp->mdSize[0] = strlen(editString);
	sprintf(tmp->md[0], ""%s"", editString);
",1,unused,2133,unused,"	tmp->err[0] = err;
	tmp->cigarSize[0] = strlen(cigar);
	sprintf(tmp->cigar[0], ""%s"", cigar);
	tmp->mdSize[0] = strlen(editString);
	sprintf(tmp->md[0], ""%s"", editString);
",unused,mrFast1-MrFAST.c
"	}
	child->loc[_msf_mappingInfo[r].size % MAP_CHUNKS] = genLoc * d;
	child->err[_msf_mappingInfo[r].size % MAP_CHUNKS] = err;
	child->cigarSize[_msf_mappingInfo[r].size % MAP_CHUNKS] = strlen(cigar);
	sprintf(child->cigar[_msf_mappingInfo[r].size % MAP_CHUNKS], ""%s"", cigar);
",1,unused,2150,unused,"	}
	child->loc[_msf_mappingInfo[r].size % MAP_CHUNKS] = genLoc * d;
	child->err[_msf_mappingInfo[r].size % MAP_CHUNKS] = err;
	child->cigarSize[_msf_mappingInfo[r].size % MAP_CHUNKS] = strlen(cigar);
	sprintf(child->cigar[_msf_mappingInfo[r].size % MAP_CHUNKS], ""%s"", cigar);
",unused,mrFast1-MrFAST.c
"	child->err[_msf_mappingInfo[r].size % MAP_CHUNKS] = err;
	child->cigarSize[_msf_mappingInfo[r].size % MAP_CHUNKS] = strlen(cigar);
	sprintf(child->cigar[_msf_mappingInfo[r].size % MAP_CHUNKS], ""%s"", cigar);
	child->mdSize[_msf_mappingInfo[r].size % MAP_CHUNKS] = strlen(editString);
	sprintf(child->md[_msf_mappingInfo[r].size % MAP_CHUNKS], ""%s"", editString);
",1,unused,2152,unused,"	child->err[_msf_mappingInfo[r].size % MAP_CHUNKS] = err;
	child->cigarSize[_msf_mappingInfo[r].size % MAP_CHUNKS] = strlen(cigar);
	sprintf(child->cigar[_msf_mappingInfo[r].size % MAP_CHUNKS], ""%s"", cigar);
	child->mdSize[_msf_mappingInfo[r].size % MAP_CHUNKS] = strlen(editString);
	sprintf(child->md[_msf_mappingInfo[r].size % MAP_CHUNKS], ""%s"", editString);
",unused,mrFast1-MrFAST.c
"  MappingLocations *cur;
  int tmpOut;
  int lmax = 0, rmax = 0;

  sprintf(fname1, ""%s__%s__%s__%d__1.tmp"", mappingOutputPath, _msf_refGenName,
",1,unused,2246,unused,"  MappingLocations *cur;
  int tmpOut;
  int lmax = 0, rmax = 0;

  sprintf(fname1, ""%s__%s__%s__%d__1.tmp"", mappingOutputPath, _msf_refGenName,
",unused,mrFast1-MrFAST.c
"  int lmax = 0, rmax = 0;

  sprintf(fname1, ""%s__%s__%s__%d__1.tmp"", mappingOutputPath, _msf_refGenName,
	  mappingOutput, _msf_openFiles);
  sprintf(fname2, ""%s__%s__%s__%d__2.tmp"", mappingOutputPath, _msf_refGenName,
",1,unused,2248,unused,"  int lmax = 0, rmax = 0;

  sprintf(fname1, ""%s__%s__%s__%d__1.tmp"", mappingOutputPath, _msf_refGenName,
	  mappingOutput, _msf_openFiles);
  sprintf(fname2, ""%s__%s__%s__%d__2.tmp"", mappingOutputPath, _msf_refGenName,
",unused,mrFast1-MrFAST.c
"
  loadRefGenome(&_msf_refGen, &_msf_refGenName, &tmpOut);

  if (pairedEndDiscordantMode) {
    sprintf(fname3, ""%s__%s__disc"", mappingOutputPath, mappingOutput);
",1,unused,2644,unused,"
  loadRefGenome(&_msf_refGen, &_msf_refGenName, &tmpOut);

  if (pairedEndDiscordantMode) {
    sprintf(fname3, ""%s__%s__disc"", mappingOutputPath, mappingOutput);
",unused,mrFast1-MrFAST.c
"  loadRefGenome(&_msf_refGen, &_msf_refGenName, &tmpOut);

  if (pairedEndDiscordantMode) {
    sprintf(fname3, ""%s__%s__disc"", mappingOutputPath, mappingOutput);
    sprintf(fname4, ""%s__%s__oea"", mappingOutputPath, mappingOutput);
",1,unused,2645,unused,"  loadRefGenome(&_msf_refGen, &_msf_refGenName, &tmpOut);

  if (pairedEndDiscordantMode) {
    sprintf(fname3, ""%s__%s__disc"", mappingOutputPath, mappingOutput);
    sprintf(fname4, ""%s__%s__oea"", mappingOutputPath, mappingOutput);
",unused,mrFast1-MrFAST.c
"  FullMappingInfo *mi2 = getMem(sizeof(FullMappingInfo) * _msf_maxRSize);

  _msf_fileCount[_msf_maxFile] = 0;
  for (i = 0; i < _msf_openFiles; i++) {
    sprintf(fname1[i], ""%s__%s__%s__%d__1.tmp"", mappingOutputPath,
",1,unused,2655,unused,"  FullMappingInfo *mi2 = getMem(sizeof(FullMappingInfo) * _msf_maxRSize);

  _msf_fileCount[_msf_maxFile] = 0;
  for (i = 0; i < _msf_openFiles; i++) {
    sprintf(fname1[i], ""%s__%s__%s__%d__1.tmp"", mappingOutputPath,
",unused,mrFast1-MrFAST.c
"  _msf_fileCount[_msf_maxFile] = 0;
  for (i = 0; i < _msf_openFiles; i++) {
    sprintf(fname1[i], ""%s__%s__%s__%d__1.tmp"", mappingOutputPath,
	    _msf_refGenName, mappingOutput, i);
    sprintf(_msf_fileName[_msf_maxFile][_msf_fileCount[_msf_maxFile]][0],
",1,unused,2657,unused,"  _msf_fileCount[_msf_maxFile] = 0;
  for (i = 0; i < _msf_openFiles; i++) {
    sprintf(fname1[i], ""%s__%s__%s__%d__1.tmp"", mappingOutputPath,
	    _msf_refGenName, mappingOutput, i);
    sprintf(_msf_fileName[_msf_maxFile][_msf_fileCount[_msf_maxFile]][0],
",unused,mrFast1-MrFAST.c
"	    _msf_refGenName, mappingOutput, i);
    sprintf(_msf_fileName[_msf_maxFile][_msf_fileCount[_msf_maxFile]][0],
	    ""%s"", fname1[i]);

    sprintf(fname2[i], ""%s__%s__%s__%d__2.tmp"", mappingOutputPath,
",1,unused,2660,unused,"	    _msf_refGenName, mappingOutput, i);
    sprintf(_msf_fileName[_msf_maxFile][_msf_fileCount[_msf_maxFile]][0],
	    ""%s"", fname1[i]);

    sprintf(fname2[i], ""%s__%s__%s__%d__2.tmp"", mappingOutputPath,
",unused,mrFast1-MrFAST.c
"	    ""%s"", fname1[i]);

    sprintf(fname2[i], ""%s__%s__%s__%d__2.tmp"", mappingOutputPath,
	    _msf_refGenName, mappingOutput, i);
    sprintf(_msf_fileName[_msf_maxFile][_msf_fileCount[_msf_maxFile]][1],
",1,unused,2662,unused,"	    ""%s"", fname1[i]);

    sprintf(fname2[i], ""%s__%s__%s__%d__2.tmp"", mappingOutputPath,
	    _msf_refGenName, mappingOutput, i);
    sprintf(_msf_fileName[_msf_maxFile][_msf_fileCount[_msf_maxFile]][1],
",unused,mrFast1-MrFAST.c
"  int rNo, lrNo = -1;
  int tmp;
  FILE *in, *out;

  sprintf(fname1, ""%s__%s__disc"", mappingOutputPath, mappingOutput);
",1,unused,3541,unused,"  int rNo, lrNo = -1;
  int tmp;
  FILE *in, *out;

  sprintf(fname1, ""%s__%s__disc"", mappingOutputPath, mappingOutput);
",unused,mrFast1-MrFAST.c
"  int tmp;
  FILE *in, *out;

  sprintf(fname1, ""%s__%s__disc"", mappingOutputPath, mappingOutput);
  sprintf(fname2, ""%s%s_DIVET.vh"", mappingOutputPath, mappingOutput);
",1,unused,3542,unused,"  int tmp;
  FILE *in, *out;

  sprintf(fname1, ""%s__%s__disc"", mappingOutputPath, mappingOutput);
  sprintf(fname2, ""%s%s_DIVET.vh"", mappingOutputPath, mappingOutput);
",unused,mrFast1-MrFAST.c
"  qual2 = NULL;

  rqual1[0] = '\0';

  sprintf(fname1, ""%s%s_OEA.sam"", mappingOutputPath, mappingOutput);
",1,unused,3705,unused,"  qual2 = NULL;

  rqual1[0] = '\0';

  sprintf(fname1, ""%s%s_OEA.sam"", mappingOutputPath, mappingOutput);
",unused,mrFast1-MrFAST.c
"
  SAMheaderTX(fp_out1, 0);
  in = NULL;
  if (pairedEndDiscordantMode) {
    sprintf(fname2, ""%s__%s__oea"", mappingOutputPath, mappingOutput);
",1,unused,3712,unused,"
  SAMheaderTX(fp_out1, 0);
  in = NULL;
  if (pairedEndDiscordantMode) {
    sprintf(fname2, ""%s__%s__oea"", mappingOutputPath, mappingOutput);
",unused,mrFast1-MrFAST.c
"{
  if (compressed)
    {
      char newFileName[strlen(fileName)+4];
      sprintf(newFileName, ""%s.gz"", fileName);
",1,unused,209,unused,"{
  if (compressed)
    {
      char newFileName[strlen(fileName)+4];
      sprintf(newFileName, ""%s.gz"", fileName);
",unused,mrFast1-Output.c
"  int chromlen;
  char rest[FILE_NAME_LENGTH];
  char *ret = NULL;

  sprintf(fainame, ""%s.fai"",fileName[0]);
",1,unused,254,unused,"  int chromlen;
  char rest[FILE_NAME_LENGTH];
  char *ret = NULL;

  sprintf(fainame, ""%s.fai"",fileName[0]);
",unused,mrFast1-Output.c
"  int chromlen;
  char rest[FILE_NAME_LENGTH];
  char *ret = NULL;

  sprintf(fainame, ""%s.fai"",fileName[0]);
",1,unused,289,unused,"  int chromlen;
  char rest[FILE_NAME_LENGTH];
  char *ret = NULL;

  sprintf(fainame, ""%s.fai"",fileName[0]);
",unused,mrFast1-Output.c
"	  qual1[strlen(qual1)-1] = '\0';
	}
      else
	{
	  sprintf(qual1, ""*"");
",1,unused,264,unused,"	  qual1[strlen(qual1)-1] = '\0';
	}
      else
	{
	  sprintf(qual1, ""*"");
",unused,mrFast1-Reads.c
"	      qual2[strlen(qual2)-1] = '\0';
	    }
	  else
	    {
	      sprintf(qual2, ""*"");
",1,unused,322,unused,"	      qual2[strlen(qual2)-1] = '\0';
	    }
	  else
	    {
	      sprintf(qual2, ""*"");
",unused,mrFast1-Reads.c
"	    }
	  
	  list[seqCnt].rseq[_mtmp]=list[seqCnt].qual[_mtmp]='\0';	
	
	  sprintf(list[seqCnt].name,""%s%c"", ((char*)name1)+1,'\0');
",1,unused,404,unused,"	    }
	  
	  list[seqCnt].rseq[_mtmp]=list[seqCnt].qual[_mtmp]='\0';	
	
	  sprintf(list[seqCnt].name,""%s%c"", ((char*)name1)+1,'\0');
",unused,mrFast1-Reads.c
"
	  name1[tmplen]='\0';
	  list[seqCnt].rseq[_mtmp]=list[seqCnt].qual[_mtmp]='\0';

	  sprintf(list[seqCnt].name,""%s%c"", ((char*)name1)+1,'\0');
",1,unused,446,unused,"
	  name1[tmplen]='\0';
	  list[seqCnt].rseq[_mtmp]=list[seqCnt].qual[_mtmp]='\0';

	  sprintf(list[seqCnt].name,""%s%c"", ((char*)name1)+1,'\0');
",unused,mrFast1-Reads.c
"
	  name2[tmplen]='\0';
	  list[seqCnt].rseq[_mtmp]=list[seqCnt].qual[_mtmp]='\0';

	  sprintf(list[seqCnt].name,""%s%c"", ((char*)name2)+1,'\0');
",1,unused,475,unused,"
	  name2[tmplen]='\0';
	  list[seqCnt].rseq[_mtmp]=list[seqCnt].qual[_mtmp]='\0';

	  sprintf(list[seqCnt].name,""%s%c"", ((char*)name2)+1,'\0');
",unused,mrFast1-Reads.c
"	      maxPairEndedDiscordantDistance = maxPairEndedDiscordantDistance - SEQ_LENGTH + 2;
	      minPairEndedDiscordantDistance = minPairEndedDiscordantDistance - SEQ_LENGTH + 2;
	    }
			
	  sprintf(fname1, ""__%s__1"", mappingOutput);
",1,unused,133,unused,"	      maxPairEndedDiscordantDistance = maxPairEndedDiscordantDistance - SEQ_LENGTH + 2;
	      minPairEndedDiscordantDistance = minPairEndedDiscordantDistance - SEQ_LENGTH + 2;
	    }
			
	  sprintf(fname1, ""__%s__1"", mappingOutput);
",unused,mrFast1-baseFAST.c
"	      minPairEndedDiscordantDistance = minPairEndedDiscordantDistance - SEQ_LENGTH + 2;
	    }
			
	  sprintf(fname1, ""__%s__1"", mappingOutput);
	  sprintf(fname2, ""__%s__2"", mappingOutput);
",1,unused,134,unused,"	      minPairEndedDiscordantDistance = minPairEndedDiscordantDistance - SEQ_LENGTH + 2;
	    }
			
	  sprintf(fname1, ""__%s__1"", mappingOutput);
	  sprintf(fname2, ""__%s__2"", mappingOutput);
",unused,mrFast1-baseFAST.c
"	    }
			
	  sprintf(fname1, ""__%s__1"", mappingOutput);
	  sprintf(fname2, ""__%s__2"", mappingOutput);
	  sprintf(fname3, ""__%s__disc"", mappingOutput);
",1,unused,135,unused,"	    }
			
	  sprintf(fname1, ""__%s__1"", mappingOutput);
	  sprintf(fname2, ""__%s__2"", mappingOutput);
	  sprintf(fname3, ""__%s__disc"", mappingOutput);
",unused,mrFast1-baseFAST.c
"			
	  sprintf(fname1, ""__%s__1"", mappingOutput);
	  sprintf(fname2, ""__%s__2"", mappingOutput);
	  sprintf(fname3, ""__%s__disc"", mappingOutput);
	  sprintf(fname4, ""__%s__oea1"", mappingOutput);
",1,unused,136,unused,"			
	  sprintf(fname1, ""__%s__1"", mappingOutput);
	  sprintf(fname2, ""__%s__2"", mappingOutput);
	  sprintf(fname3, ""__%s__disc"", mappingOutput);
	  sprintf(fname4, ""__%s__oea1"", mappingOutput);
",unused,mrFast1-baseFAST.c
"	  sprintf(fname1, ""__%s__1"", mappingOutput);
	  sprintf(fname2, ""__%s__2"", mappingOutput);
	  sprintf(fname3, ""__%s__disc"", mappingOutput);
	  sprintf(fname4, ""__%s__oea1"", mappingOutput);
	  sprintf(fname5, ""__%s__oea2"", mappingOutput);
",1,unused,137,unused,"	  sprintf(fname1, ""__%s__1"", mappingOutput);
	  sprintf(fname2, ""__%s__2"", mappingOutput);
	  sprintf(fname3, ""__%s__disc"", mappingOutput);
	  sprintf(fname4, ""__%s__oea1"", mappingOutput);
	  sprintf(fname5, ""__%s__oea2"", mappingOutput);
",unused,mrFast1-baseFAST.c
"	  unlink(fname4);
	  unlink(fname5);
	}

      sprintf(outputFileName, ""%s%s"",mappingOutputPath , mappingOutput);
",1,unused,145,unused,"	  unlink(fname4);
	  unlink(fname5);
	}

      sprintf(outputFileName, ""%s%s"",mappingOutputPath , mappingOutput);
",unused,mrFast1-baseFAST.c
"
	      // First Time
	      if (flag && prevGen[0]== '\0')
		{
		  sprintf(prevGen, ""%s"", curGen);
",1,unused,181,unused,"
	      // First Time
	      if (flag && prevGen[0]== '\0')
		{
		  sprintf(prevGen, ""%s"", curGen);
",unused,mrFast1-baseFAST.c
"			  prevGen,loadingTime, mappingTime, maxMem, mappingCnt , mappedSeqCnt);
		  fflush(stderr);
		}

	      sprintf(prevGen, ""%s"", curGen);
",1,unused,211,unused,"			  prevGen,loadingTime, mappingTime, maxMem, mappingCnt , mappedSeqCnt);
		  fflush(stderr);
		}

	      sprintf(prevGen, ""%s"", curGen);
",unused,mrFast1-baseFAST.c
"
	      // First Time
	      if (flag && prevGen[0]== '\0')
		{
		  sprintf(prevGen, ""%s"", curGen);
",1,unused,265,unused,"
	      // First Time
	      if (flag && prevGen[0]== '\0')
		{
		  sprintf(prevGen, ""%s"", curGen);
",unused,mrFast1-baseFAST.c
"			  prevGen,loadingTime, mappingTime, maxMem, mappingCnt , mappedSeqCnt);
		  fflush(stderr);
		}

	      sprintf(prevGen, ""%s"", curGen);
",1,unused,300,unused,"			  prevGen,loadingTime, mappingTime, maxMem, mappingCnt , mappedSeqCnt);
		  fflush(stderr);
		}

	      sprintf(prevGen, ""%s"", curGen);
",unused,mrFast1-baseFAST.c
"
				
	  if(pairedEndMode)
	    {		
	      sprintf(outputFileName, ""%s%s"",mappingOutputPath , mappingOutput);		
",1,unused,319,unused,"
				
	  if(pairedEndMode)
	    {		
	      sprintf(outputFileName, ""%s%s"",mappingOutputPath , mappingOutput);		
",unused,mrFast1-baseFAST.c
"/*------------------------------------------------------------------------*/

static char * yals_strdup (Yals * yals, const char * str) {
  assert (str);
  return strcpy (yals_malloc (yals, strlen (str) + 1), str);
",1,unused,690,unused,"/*------------------------------------------------------------------------*/

static char * yals_strdup (Yals * yals, const char * str) {
  assert (str);
  return strcpy (yals_malloc (yals, strlen (str) + 1), str);
",unused,msoos_cryptominisat-src2Fyals.c
"static void yals_envopt (Yals * yals, const char * name, Opt * opt) {
  int len = strlen (name) + strlen (""YALS"") + 1, val, ch;
  char * env = yals_malloc (yals, len), * p;
  const char * str;
  sprintf (env, ""yals%s"",name);
",1,unused,2401,unused,"static void yals_envopt (Yals * yals, const char * name, Opt * opt) {
  int len = strlen (name) + strlen (""YALS"") + 1, val, ch;
  char * env = yals_malloc (yals, len), * p;
  const char * str;
  sprintf (env, ""yals%s"",name);
",unused,msoos_cryptominisat-src2Fyals.c
"    for (pass = 0; pass < 2; ++pass) {
	for (s = d = 0; src[s] != '\0'; ++s) {
	    if (src[s] == ' ') {
		if (pass) {
		    strcpy(&result[d], fill);
",1,unused,532,unused,"    for (pass = 0; pass < 2; ++pass) {
	for (s = d = 0; src[s] != '\0'; ++s) {
	    if (src[s] == ' ') {
		if (pass) {
		    strcpy(&result[d], fill);
",unused,ncursesdebian-progs2Fdump_entry.c
"    for (pass = 0; pass < 2; ++pass) {
	for (s = d = 0; src[s] != '\0'; ++s) {
	    if (src[s] == ' ') {
		if (pass) {
		    strcpy(&result[d], fill);
",1,unused,532,unused,"    for (pass = 0; pass < 2; ++pass) {
	for (s = d = 0; src[s] != '\0'; ++s) {
	    if (src[s] == ' ') {
		if (pass) {
		    strcpy(&result[d], fill);
",unused,ncursesdebstretch-progs2Fdump_entry.c
"    for (pass = 0; pass < 2; ++pass) {
	for (s = d = 0; src[s] != '\0'; ++s) {
	    if (src[s] == ' ') {
		if (pass) {
		    strcpy(&result[d], fill);
",1,unused,532,unused,"    for (pass = 0; pass < 2; ++pass) {
	for (s = d = 0; src[s] != '\0'; ++s) {
	    if (src[s] == ' ') {
		if (pass) {
		    strcpy(&result[d], fill);
",unused,ncursessources6.0-progs2Fdump_entry.c
"		    first = FALSE;
		} else {
		    *target++ = '|';
		}
		strcpy(target, scr_attrs[n].name);
",1,unused,666,unused,"		    first = FALSE;
		} else {
		    *target++ = '|';
		}
		strcpy(target, scr_attrs[n].name);
",unused,ncursesubuntuxenial6.0-ncurses2Fbase2Flib_screen.c
"	}
	if ((source & A_COLOR) != (prior & A_COLOR)) {
	    if (!first)
		*target++ = '|';
	    sprintf(target, ""C%d"", PAIR_NUMBER((int) source));
",1,unused,673,unused,"	}
	if ((source & A_COLOR) != (prior & A_COLOR)) {
	    if (!first)
		*target++ = '|';
	    sprintf(target, ""C%d"", PAIR_NUMBER((int) source));
",unused,ncursesubuntuxenial6.0-ncurses2Fbase2Flib_screen.c
"    }
    target += strlen(target);
    *target++ = MARKER;
    if (ch < 32 || ch >= 127) {
	sprintf(target, ""%03o"", UChar(ch));
",1,unused,739,unused,"    }
    target += strlen(target);
    *target++ = MARKER;
    if (ch < 32 || ch >= 127) {
	sprintf(target, ""%03o"", UChar(ch));
",unused,ncursesubuntuxenial6.0-ncurses2Fbase2Flib_screen.c
"	sprintf(target, ""%03o"", UChar(ch));
    } else {
	switch (ch) {
	case ' ':
	    strcpy(target, ""s"");
",1,unused,743,unused,"	sprintf(target, ""%03o"", UChar(ch));
    } else {
	switch (ch) {
	case ' ':
	    strcpy(target, ""s"");
",unused,ncursesubuntuxenial6.0-ncurses2Fbase2Flib_screen.c
"	    *target++ = MARKER;
	    *target = '\0';
	    break;
	default:
	    sprintf(--target, ""%c"", UChar(ch));
",1,unused,750,unused,"	    *target++ = MARKER;
	    *target = '\0';
	    break;
	default:
	    sprintf(--target, ""%c"", UChar(ch));
",unused,ncursesubuntuxenial6.0-ncurses2Fbase2Flib_screen.c
"	    case pBOOL:
		if (!(*(const bool *) data)) {
		    continue;
		}
		strcpy(buffer, name);
",1,unused,801,unused,"	    case pBOOL:
		if (!(*(const bool *) data)) {
		    continue;
		}
		strcpy(buffer, name);
",unused,ncursesubuntuxenial6.0-ncurses2Fbase2Flib_screen.c
"		break;
	    case pINT:
		if (!(*(const int *) dp))
		    continue;
		sprintf(buffer, ""%d"", *(const int *) dp);
",1,unused,810,unused,"		break;
	    case pINT:
		if (!(*(const int *) dp))
		    continue;
		sprintf(buffer, ""%d"", *(const int *) dp);
",unused,ncursesubuntuxenial6.0-ncurses2Fbase2Flib_screen.c
"		break;
	    case pSHORT:
		if (!(*(const short *) dp))
		    continue;
		sprintf(buffer, ""%d"", *(const short *) dp);
",1,unused,815,unused,"		break;
	    case pSHORT:
		if (!(*(const short *) dp))
		    continue;
		sprintf(buffer, ""%d"", *(const short *) dp);
",unused,ncursesubuntuxenial6.0-ncurses2Fbase2Flib_screen.c
"		break;
	    case pSIZE:
		if (!(*(const NCURSES_SIZE_T *) dp))
		    continue;
		sprintf(buffer, ""%d"", *(const NCURSES_SIZE_T *) dp);
",1,unused,820,unused,"		break;
	    case pSIZE:
		if (!(*(const NCURSES_SIZE_T *) dp))
		    continue;
		sprintf(buffer, ""%d"", *(const NCURSES_SIZE_T *) dp);
",unused,ncursesubuntuxenial6.0-ncurses2Fbase2Flib_screen.c
"		if (outbuf.used)
		    wrap_concat(""\n"");
		wrap_concat(""hex:"");
		for (n = 0; n < offset; ++n) {
		    sprintf(numbuf, ""%02X"", UChar(bigbuf[n]));
",1,unused,1180,unused,"		if (outbuf.used)
		    wrap_concat(""\n"");
		wrap_concat(""hex:"");
		for (n = 0; n < offset; ++n) {
		    sprintf(numbuf, ""%02X"", UChar(bigbuf[n]));
",unused,ncursesubuntuxenial6.0-progs2Fdump_entry.c
"
    *next++ = '\0';
    for (k = 1; k <= NUM_PARM; k++) {
	numbers[k] = count;
	sprintf(next, ""XYZ%d"", count);
",1,unused,1779,unused,"
    *next++ = '\0';
    for (k = 1; k <= NUM_PARM; k++) {
	numbers[k] = count;
	sprintf(next, ""XYZ%d"", count);
",unused,ncursesubuntuxenial6.0-progs2Ftic.c
"		c = live[0];
	    } else {
		char buf[BUFSIZ];

		(void) sprintf(buf,
",1,unused,318,unused,"		c = live[0];
	    } else {
		char buf[BUFSIZ];

		(void) sprintf(buf,
",unused,ncursesubuntuxenial6.0-test2Fblue.c
"	case '.':		/* change from current position */
	    (void) wattrset(win, AttrArg(COLOR_PAIR(st.pair), st.attr));
	    if (st.count > 0) {
		need = (unsigned) st.count + 1;
		sprintf(fmt, ""%%c%%%ds%%c"", st.count);
",1,unused,337,unused,"	case '.':		/* change from current position */
	    (void) wattrset(win, AttrArg(COLOR_PAIR(st.pair), st.attr));
	    if (st.count > 0) {
		need = (unsigned) st.count + 1;
		sprintf(fmt, ""%%c%%%ds%%c"", st.count);
",unused,ncursesubuntuxenial6.0-test2Fclip_printw.c
"		need = (unsigned) st.count + 1;
		sprintf(fmt, ""%%c%%%ds%%c"", st.count);
	    } else {
		need = (unsigned) getmaxx(win) - 1;
		strcpy(fmt, ""%c%s%c"");
",1,unused,340,unused,"		need = (unsigned) st.count + 1;
		sprintf(fmt, ""%%c%%%ds%%c"", st.count);
	    } else {
		need = (unsigned) getmaxx(win) - 1;
		strcpy(fmt, ""%c%s%c"");
",unused,ncursesubuntuxenial6.0-test2Fclip_printw.c
"     * keypad() initializes the corresponding data.
     */
    for (n = 0; n < 255; ++n) {
	char temp[10];
	sprintf(temp, ""\033%c"", n);
",1,unused,107,unused,"     * keypad() initializes the corresponding data.
     */
    for (n = 0; n < 255; ++n) {
	char temp[10];
	sprintf(temp, ""\033%c"", n);
",unused,ncursesubuntuxenial6.0-test2Fdemo_altkeys.c
"    for (n = KEY_MIN; n < KEY_MAX; ++n) {
	char *value;
	if ((value = keybound(n, 0)) != 0) {
	    char *temp = typeMalloc(char, strlen(value) + 2);
	    sprintf(temp, ""\033%s"", value);
",1,unused,114,unused,"    for (n = KEY_MIN; n < KEY_MAX; ++n) {
	char *value;
	if ((value = keybound(n, 0)) != 0) {
	    char *temp = typeMalloc(char, strlen(value) + 2);
	    sprintf(temp, ""\033%s"", value);
",unused,ncursesubuntuxenial6.0-test2Fdemo_altkeys.c
"
    ch = UChar(ch);
    assert(ch >= 0 && ch < 256);
    if (ch == '\\') {
	strcpy(temp, ""\\\\"");
",1,unused,81,unused,"
    ch = UChar(ch);
    assert(ch >= 0 && ch < 256);
    if (ch == '\\') {
	strcpy(temp, ""\\\\"");
",unused,ncursesubuntuxenial6.0-test2Fdemo_defkey.c
"    assert(ch >= 0 && ch < 256);
    if (ch == '\\') {
	strcpy(temp, ""\\\\"");
    } else if (ch == '\033') {
	strcpy(temp, ""\\E"");
",1,unused,83,unused,"    assert(ch >= 0 && ch < 256);
    if (ch == '\\') {
	strcpy(temp, ""\\\\"");
    } else if (ch == '\033') {
	strcpy(temp, ""\\E"");
",unused,ncursesubuntuxenial6.0-test2Fdemo_defkey.c
"	strcpy(temp, ""\\\\"");
    } else if (ch == '\033') {
	strcpy(temp, ""\\E"");
    } else if (ch < ' ') {
	sprintf(temp, ""\\%03o"", ch);
",1,unused,85,unused,"	strcpy(temp, ""\\\\"");
    } else if (ch == '\033') {
	strcpy(temp, ""\\E"");
    } else if (ch < ' ') {
	sprintf(temp, ""\\%03o"", ch);
",unused,ncursesubuntuxenial6.0-test2Fdemo_defkey.c
"	strcpy(temp, ""\\E"");
    } else if (ch < ' ') {
	sprintf(temp, ""\\%03o"", ch);
    } else if (ch >= 127) {
	sprintf(temp, ""\\%03o"", ch);
",1,unused,87,unused,"	strcpy(temp, ""\\E"");
    } else if (ch < ' ') {
	sprintf(temp, ""\\%03o"", ch);
    } else if (ch >= 127) {
	sprintf(temp, ""\\%03o"", ch);
",unused,ncursesubuntuxenial6.0-test2Fdemo_defkey.c
"	sprintf(temp, ""\\%03o"", ch);
    } else if (ch >= 127) {
	sprintf(temp, ""\\%03o"", ch);
    } else {
	sprintf(temp, ""%c"", ch);
",1,unused,89,unused,"	sprintf(temp, ""\\%03o"", ch);
    } else if (ch >= 127) {
	sprintf(temp, ""\\%03o"", ch);
    } else {
	sprintf(temp, ""%c"", ch);
",unused,ncursesubuntuxenial6.0-test2Fdemo_defkey.c
"	    for (n = 0; string[n] != '\0'; ++n) {
		char temp[80];
		strncpy(temp, visichar(string[n]), sizeof(temp) - 2);
		if (pass)
		    strcat(result, temp);
",1,unused,111,unused,"	    for (n = 0; string[n] != '\0'; ++n) {
		char temp[80];
		strncpy(temp, visichar(string[n]), sizeof(temp) - 2);
		if (pass)
		    strcat(result, temp);
",unused,ncursesubuntuxenial6.0-test2Fdemo_defkey.c
"    char *vis_string = 0;
    char temp[80];

    if (code_name == 0) {
	sprintf(temp, ""Keycode %d"", code);
",1,unused,134,unused,"    char *vis_string = 0;
    char temp[80];

    if (code_name == 0) {
	sprintf(temp, ""Keycode %d"", code);
",unused,ncursesubuntuxenial6.0-test2Fdemo_defkey.c
"	} else if (!strncmp(value, ""\033O"", (size_t) 2)) {
	    prefix = ""\033["";
	}
	if (prefix != 0) {
	    sprintf(temp, ""%s%s"", prefix, value + 2);
",1,unused,195,unused,"	} else if (!strncmp(value, ""\033O"", (size_t) 2)) {
	    prefix = ""\033["";
	}
	if (prefix != 0) {
	    sprintf(temp, ""%s%s"", prefix, value + 2);
",unused,ncursesubuntuxenial6.0-test2Fdemo_defkey.c
"     * keypad() initializes the corresponding data.
     */
    for (n = 0; n < 12; ++n) {
	char name[10];
	sprintf(name, ""kf%d"", n + 1);
",1,unused,242,unused,"     * keypad() initializes the corresponding data.
     */
    for (n = 0; n < 12; ++n) {
	char name[10];
	sprintf(name, ""kf%d"", n + 1);
",unused,ncursesubuntuxenial6.0-test2Fdemo_defkey.c
"static char *
make_dbitem(char *p, char *q)
{
    char *result = malloc(strlen(e_opt) + 2 + (size_t) (p - q));
    sprintf(result, ""%s=%.*s"", e_opt, (int) (p - q), q);
",1,unused,104,unused,"static char *
make_dbitem(char *p, char *q)
{
    char *result = malloc(strlen(e_opt) + 2 + (size_t) (p - q));
    sprintf(result, ""%s=%.*s"", e_opt, (int) (p - q), q);
",unused,ncursesubuntuxenial6.0-test2Fdemo_termcap.c
"	    if (pass == 0) {
		length += chunk;
	    } else {
		result[count] = unused;
		strcpy(unused, list[count]);
",1,unused,702,unused,"	    if (pass == 0) {
		length += chunk;
	    } else {
		result[count] = unused;
		strcpy(unused, list[count]);
",unused,ncursesubuntuxenial6.0-test2Fdemo_termcap.c
"static char *
make_dbitem(char *p, char *q)
{
    char *result = malloc(strlen(e_opt) + 2 + (size_t) (p - q));
    sprintf(result, ""%s=%.*s"", e_opt, (int) (p - q), q);
",1,unused,99,unused,"static char *
make_dbitem(char *p, char *q)
{
    char *result = malloc(strlen(e_opt) + 2 + (size_t) (p - q));
    sprintf(result, ""%s=%.*s"", e_opt, (int) (p - q), q);
",unused,ncursesubuntuxenial6.0-test2Fdemo_terminfo.c
"			    !strcmp(xterm_keys[n], ""kLFT"") ||
			    !strcmp(xterm_keys[n], ""kRIT"")) {
			    continue;
			}
			sprintf(temp, ""%.*s"", 8, xterm_keys[n]);
",1,unused,399,unused,"			    !strcmp(xterm_keys[n], ""kLFT"") ||
			    !strcmp(xterm_keys[n], ""kRIT"")) {
			    continue;
			}
			sprintf(temp, ""%.*s"", 8, xterm_keys[n]);
",unused,ncursesubuntuxenial6.0-test2Fdemo_terminfo.c
"			    continue;
			}
			sprintf(temp, ""%.*s"", 8, xterm_keys[n]);
		    } else {
			sprintf(temp, ""%.*s%d"", 8, xterm_keys[n], mod);
",1,unused,401,unused,"			    continue;
			}
			sprintf(temp, ""%.*s"", 8, xterm_keys[n]);
		    } else {
			sprintf(temp, ""%.*s%d"", 8, xterm_keys[n], mod);
",unused,ncursesubuntuxenial6.0-test2Fdemo_terminfo.c
"	    if (pass == 0) {
		length += chunk;
	    } else {
		result[count] = unused;
		strcpy(unused, list[count]);
",1,unused,736,unused,"	    if (pass == 0) {
		length += chunk;
	    } else {
		result[count] = unused;
		strcpy(unused, list[count]);
",unused,ncursesubuntuxenial6.0-test2Fdemo_terminfo.c
"    if (strrchr(slave_name, '/') == 0) {
	errno = EISDIR;
	failed(slave_name);
    }
    sprintf(s_option, ""-S%s/%d"", slave_name, aslave);
",1,unused,170,unused,"    if (strrchr(slave_name, '/') == 0) {
	errno = EISDIR;
	failed(slave_name);
    }
    sprintf(s_option, ""-S%s/%d"", slave_name, aslave);
",unused,ncursesubuntuxenial6.0-test2Fditto.c
"		      &second,
		      final) == 3
	    && *final != ';'
	    && (value = strdup(info[j].value)) != 0) {
	    sprintf(value, ""\033[%d%c"", first, *final);
",1,unused,166,unused,"		      &second,
		      final) == 3
	    && *final != ';'
	    && (value = strdup(info[j].value)) != 0) {
	    sprintf(value, ""\033[%d%c"", first, *final);
",unused,ncursesubuntuxenial6.0-test2Ffoldkeys.c
"		    break;
		}
	    }
	    if (info[j].state == 0) {
		sprintf(value, ""\033O%c"", *final);
",1,unused,175,unused,"		    break;
		}
	    }
	    if (info[j].state == 0) {
		sprintf(value, ""\033O%c"", *final);
",unused,ncursesubuntuxenial6.0-test2Ffoldkeys.c
"    if (first) {
	static char cmd[80];
	setlocale(LC_ALL, """");

	putenv(strcpy(cmd, ""TABSIZE=8""));
",1,unused,164,unused,"    if (first) {
	static char cmd[80];
	setlocale(LC_ALL, """");

	putenv(strcpy(cmd, ""TABSIZE=8""));
",unused,ncursesubuntuxenial6.0-test2Finserts.c
"mouse_decode(MEVENT const *ep)
{
    static char buf[80 + (5 * 10) + (32 * 15)];

    (void) sprintf(buf, ""id %2d at (%2d, %2d, %d) state %4lx = {"",
",1,unused,518,unused,"mouse_decode(MEVENT const *ep)
{
    static char buf[80 + (5 * 10) + (32 * 15)];

    (void) sprintf(buf, ""id %2d at (%2d, %2d, %d) state %4lx = {"",
",unused,ncursesubuntuxenial6.0-test2Fncurses.c
"#undef SHOW

    if (buf[strlen(buf) - 1] == ' ')
	buf[strlen(buf) - 2] = '\0';
    (void) strcat(buf, ""}"");
",1,unused,577,unused,"#undef SHOW

    if (buf[strlen(buf) - 1] == ' ')
	buf[strlen(buf) - 2] = '\0';
    (void) strcat(buf, ""}"");
",unused,ncursesubuntuxenial6.0-test2Fncurses.c
"	char temp[80];
	int width = 8;

	if (wide) {
	    sprintf(temp, ""%02d"", color);
",1,unused,2087,unused,"	char temp[80];
	int width = 8;

	if (wide) {
	    sprintf(temp, ""%02d"", color);
",unused,ncursesubuntuxenial6.0-test2Fncurses.c
"	if (wide) {
	    sprintf(temp, ""%02d"", color);
	    width = 4;
	} else if (color >= 8) {
	    sprintf(temp, ""[%02d]"", color);
",1,unused,2090,unused,"	if (wide) {
	    sprintf(temp, ""%02d"", color);
	    width = 4;
	} else if (color >= 8) {
	    sprintf(temp, ""[%02d]"", color);
",unused,ncursesubuntuxenial6.0-test2Fncurses.c
"	    width = 4;
	} else if (color >= 8) {
	    sprintf(temp, ""[%02d]"", color);
	} else if (color < 0) {
	    strcpy(temp, ""default"");
",1,unused,2092,unused,"	    width = 4;
	} else if (color >= 8) {
	    sprintf(temp, ""[%02d]"", color);
	} else if (color < 0) {
	    strcpy(temp, ""default"");
",unused,ncursesubuntuxenial6.0-test2Fncurses.c
"	    sprintf(temp, ""[%02d]"", color);
	} else if (color < 0) {
	    strcpy(temp, ""default"");
	} else {
	    sprintf(temp, ""%.*s"", 16, the_color_names[color]);
",1,unused,2094,unused,"	    sprintf(temp, ""[%02d]"", color);
	} else if (color < 0) {
	    strcpy(temp, ""default"");
	} else {
	    sprintf(temp, ""%.*s"", 16, the_color_names[color]);
",unused,ncursesubuntuxenial6.0-test2Fncurses.c
"		if (opt_revs)
		    attron(A_REVERSE);

		if (opt_nums) {
		    sprintf(numbered, ""{%02X}"", (int) i);
",1,unused,2281,unused,"		if (opt_revs)
		    attron(A_REVERSE);

		if (opt_nums) {
		    sprintf(numbered, ""{%02X}"", (int) i);
",unused,ncursesubuntuxenial6.0-test2Fncurses.c
"	     (i - top_color < page_size)
	     && (i < max_colors); i++) {
	    char numeric[80];

	    sprintf(numeric, ""[%d]"", i);
",1,unused,2701,unused,"	     (i - top_color < page_size)
	     && (i < max_colors); i++) {
	    char numeric[80];

	    sprintf(numeric, ""[%d]"", i);
",unused,ncursesubuntuxenial6.0-test2Fncurses.c
"	case '6':
	case '7':
	case '8':
	    MvAddStr(SLK_WORK, 0, ""Please enter the label value: "");
	    strcpy(buf, """");
",1,unused,3078,unused,"	case '6':
	case '7':
	case '8':
	    MvAddStr(SLK_WORK, 0, ""Please enter the label value: "");
	    strcpy(buf, """");
",unused,ncursesubuntuxenial6.0-test2Fncurses.c
"	int count = repeat;
	int row = 2 + ((int) (code - first) % (pagesize / 2));
	int col = ((int) (code - first) / (pagesize / 2)) * COLS / 2;
	char tmp[80];
	sprintf(tmp, ""%3u (0x%x)"", code, code);
",1,unused,3336,unused,"	int count = repeat;
	int row = 2 + ((int) (code - first) % (pagesize / 2));
	int col = ((int) (code - first) / (pagesize / 2)) * COLS / 2;
	char tmp[80];
	sprintf(tmp, ""%3u (0x%x)"", code, code);
",unused,ncursesubuntuxenial6.0-test2Fncurses.c
"    move(LINES - 4, 0);
    for (n = 0; n < SIZEOF(legend); n++) {
	switch (legend[n].code) {
	default:
	    strcpy(buf, legend[n].msg);
",1,unused,4349,unused,"    move(LINES - 4, 0);
    for (n = 0; n < SIZEOF(legend); n++) {
	switch (legend[n].code) {
	default:
	    strcpy(buf, legend[n].msg);
",unused,ncursesubuntuxenial6.0-test2Fncurses.c
"	default:
	    strcpy(buf, legend[n].msg);
	    break;
	case 1:
	    sprintf(buf, legend[n].msg, do_keypad ? ""yes"" : ""no"");
",1,unused,4352,unused,"	default:
	    strcpy(buf, legend[n].msg);
	    break;
	case 1:
	    sprintf(buf, legend[n].msg, do_keypad ? ""yes"" : ""no"");
",unused,ncursesubuntuxenial6.0-test2Fncurses.c
"	case 1:
	    sprintf(buf, legend[n].msg, do_keypad ? ""yes"" : ""no"");
	    break;
	case 2:
	    sprintf(buf, legend[n].msg, do_scroll ? ""yes"" : ""no"");
",1,unused,4355,unused,"	case 1:
	    sprintf(buf, legend[n].msg, do_keypad ? ""yes"" : ""no"");
	    break;
	case 2:
	    sprintf(buf, legend[n].msg, do_scroll ? ""yes"" : ""no"");
",unused,ncursesubuntuxenial6.0-test2Fncurses.c
"	case 2:
	    sprintf(buf, legend[n].msg, do_scroll ? ""yes"" : ""no"");
	    break;
	case 3:
	    sprintf(buf, legend[n].msg, do_keypad ? ""/ESC"" : """");
",1,unused,4358,unused,"	case 2:
	    sprintf(buf, legend[n].msg, do_scroll ? ""yes"" : ""no"");
	    break;
	case 3:
	    sprintf(buf, legend[n].msg, do_keypad ? ""/ESC"" : """");
",unused,ncursesubuntuxenial6.0-test2Fncurses.c
"
	switch (row) {
	case 0:
	    flavors[row] = 0;
	    sprintf(msg, ""refresh %s, then %s, then doupdate."", ths, tht);
",1,unused,6528,unused,"
	switch (row) {
	case 0:
	    flavors[row] = 0;
	    sprintf(msg, ""refresh %s, then %s, then doupdate."", ths, tht);
",unused,ncursesubuntuxenial6.0-test2Fncurses.c
"	    } else {
		flavors[row] %= 2;
	    }
	    overlap_test_1_attr(stdscr, flavors[row], col);
	    sprintf(msg, ""fill window %s with letter %s."", ths, ths);
",1,unused,6537,unused,"	    } else {
		flavors[row] %= 2;
	    }
	    overlap_test_1_attr(stdscr, flavors[row], col);
	    sprintf(msg, ""fill window %s with letter %s."", ths, ths);
",unused,ncursesubuntuxenial6.0-test2Fncurses.c
"		flavors[row] %= 2;
	    }
	    switch (flavors[row]) {
	    case 0:
		sprintf(msg, ""cross pattern in window %s."", ths);
",1,unused,6547,unused,"		flavors[row] %= 2;
	    }
	    switch (flavors[row]) {
	    case 0:
		sprintf(msg, ""cross pattern in window %s."", ths);
",unused,ncursesubuntuxenial6.0-test2Fncurses.c
"	    case 0:
		sprintf(msg, ""cross pattern in window %s."", ths);
		break;
	    case 1:
		sprintf(msg, ""draw box in window %s."", ths);
",1,unused,6550,unused,"	    case 0:
		sprintf(msg, ""cross pattern in window %s."", ths);
		break;
	    case 1:
		sprintf(msg, ""draw box in window %s."", ths);
",unused,ncursesubuntuxenial6.0-test2Fncurses.c
"	    case 1:
		sprintf(msg, ""draw box in window %s."", ths);
		break;
	    case 2:
		sprintf(msg, ""set background of window %s."", ths);
",1,unused,6553,unused,"	    case 1:
		sprintf(msg, ""draw box in window %s."", ths);
		break;
	    case 2:
		sprintf(msg, ""set background of window %s."", ths);
",unused,ncursesubuntuxenial6.0-test2Fncurses.c
"	    case 2:
		sprintf(msg, ""set background of window %s."", ths);
		break;
	    case 3:
		sprintf(msg, ""reset background of window %s."", ths);
",1,unused,6556,unused,"	    case 2:
		sprintf(msg, ""set background of window %s."", ths);
		break;
	    case 3:
		sprintf(msg, ""reset background of window %s."", ths);
",unused,ncursesubuntuxenial6.0-test2Fncurses.c
"	    }
	    break;
	case 3:
	    flavors[row] = 0;
	    sprintf(msg, ""clear window %s."", ths);
",1,unused,6562,unused,"	    }
	    break;
	case 3:
	    flavors[row] = 0;
	    sprintf(msg, ""clear window %s."", ths);
",unused,ncursesubuntuxenial6.0-test2Fncurses.c
"	case 4:
	    flavors[row] %= 4;
	    switch (flavors[row]) {
	    case 0:
		sprintf(msg, ""overwrite %s onto %s."", ths, tht);
",1,unused,6568,unused,"	case 4:
	    flavors[row] %= 4;
	    switch (flavors[row]) {
	    case 0:
		sprintf(msg, ""overwrite %s onto %s."", ths, tht);
",unused,ncursesubuntuxenial6.0-test2Fncurses.c
"	    case 0:
		sprintf(msg, ""overwrite %s onto %s."", ths, tht);
		break;
	    case 1:
		sprintf(msg, ""copywin(FALSE) %s onto %s."", ths, tht);
",1,unused,6571,unused,"	    case 0:
		sprintf(msg, ""overwrite %s onto %s."", ths, tht);
		break;
	    case 1:
		sprintf(msg, ""copywin(FALSE) %s onto %s."", ths, tht);
",unused,ncursesubuntuxenial6.0-test2Fncurses.c
"	    case 1:
		sprintf(msg, ""copywin(FALSE) %s onto %s."", ths, tht);
		break;
	    case 2:
		sprintf(msg, ""copywin(TRUE) %s onto %s."", ths, tht);
",1,unused,6574,unused,"	    case 1:
		sprintf(msg, ""copywin(FALSE) %s onto %s."", ths, tht);
		break;
	    case 2:
		sprintf(msg, ""copywin(TRUE) %s onto %s."", ths, tht);
",unused,ncursesubuntuxenial6.0-test2Fncurses.c
"	    case 2:
		sprintf(msg, ""copywin(TRUE) %s onto %s."", ths, tht);
		break;
	    case 3:
		sprintf(msg, ""overlay %s onto %s."", ths, tht);
",1,unused,6577,unused,"	    case 2:
		sprintf(msg, ""copywin(TRUE) %s onto %s."", ths, tht);
		break;
	    case 3:
		sprintf(msg, ""overlay %s onto %s."", ths, tht);
",unused,ncursesubuntuxenial6.0-test2Fncurses.c
"	set_colors(win, 6, COLOR_YELLOW, COLOR_WHITE);
	message = messages[j = 0];
	i = 1;
	w = width - 2;
	strcpy(buffer, message);
",1,unused,302,unused,"	set_colors(win, 6, COLOR_YELLOW, COLOR_WHITE);
	message = messages[j = 0];
	i = 1;
	w = width - 2;
	strcpy(buffer, message);
",unused,ncursesubuntuxenial6.0-test2Fnewdemo.c
"	w = width - 2;
	strcpy(buffer, message);
	while (j < NMESSAGES) {
	    while ((int) strlen(buffer) < w) {
		strcat(buffer, "" ... "");
",1,unused,305,unused,"	w = width - 2;
	strcpy(buffer, message);
	while (j < NMESSAGES) {
	    while ((int) strlen(buffer) < w) {
		strcat(buffer, "" ... "");
",unused,ncursesubuntuxenial6.0-test2Fnewdemo.c
"	strcpy(buffer, message);
	while (j < NMESSAGES) {
	    while ((int) strlen(buffer) < w) {
		strcat(buffer, "" ... "");
		strcat(buffer, messages[++j % NMESSAGES]);
",1,unused,306,unused,"	strcpy(buffer, message);
	while (j < NMESSAGES) {
	    while ((int) strlen(buffer) < w) {
		strcat(buffer, "" ... "");
		strcat(buffer, messages[++j % NMESSAGES]);
",unused,ncursesubuntuxenial6.0-test2Fnewdemo.c
"    for (i = 0; i < 12; i++) {
	sangle = (i + 1) * (2.0 * PI) / 12.0;
	sdx = A2X(sangle, sradius);
	sdy = A2Y(sangle, sradius);
	sprintf(szChar, ""%d"", i + 1);
",1,unused,178,unused,"    for (i = 0; i < 12; i++) {
	sangle = (i + 1) * (2.0 * PI) / 12.0;
	sdx = A2X(sangle, sradius);
	sdy = A2Y(sangle, sradius);
	sprintf(szChar, ""%d"", i + 1);
",unused,ncursesubuntuxenial6.0-test2Ftclock.c
"    if (first) {
	static char cmd[80];
	setlocale(LC_ALL, """");

	putenv(strcpy(cmd, ""TABSIZE=8""));
",1,unused,236,unused,"    if (first) {
	static char cmd[80];
	setlocale(LC_ALL, """");

	putenv(strcpy(cmd, ""TABSIZE=8""));
",unused,ncursesubuntuxenial6.0-test2Ftest_addchstr.c
"    if (first) {
	static char cmd[80];
	setlocale(LC_ALL, """");

	putenv(strcpy(cmd, ""TABSIZE=8""));
",1,unused,158,unused,"    if (first) {
	static char cmd[80];
	setlocale(LC_ALL, """");

	putenv(strcpy(cmd, ""TABSIZE=8""));
",unused,ncursesubuntuxenial6.0-test2Ftest_addstr.c
"static char *
make_dbitem(char *p, char *q)
{
    char *result = malloc(strlen(e_opt) + 2 + (size_t) (p - q));
    sprintf(result, ""%s=%.*s"", e_opt, (int) (p - q), q);
",1,unused,65,unused,"static char *
make_dbitem(char *p, char *q)
{
    char *result = malloc(strlen(e_opt) + 2 + (size_t) (p - q));
    sprintf(result, ""%s=%.*s"", e_opt, (int) (p - q), q);
",unused,ncursesubuntuxenial6.0-test2Ftest_sgr.c
"	    if (isprint(UChar(*d))) {
		col++;
		d++;
	    } else {
		sprintf(d, ""\\%03o"", UChar(*s));
",1,unused,356,unused,"	    if (isprint(UChar(*d))) {
		col++;
		d++;
	    } else {
		sprintf(d, ""\\%03o"", UChar(*s));
",unused,ncursesubuntuxenial6.0-test2Fview.c
"    NCURSES_CH_T *s;
    time_t this_time;

#if CAN_RESIZE
    sprintf(temp, ""%.20s (%3dx%3d) col %d "", tag, LINES, COLS, shift);
",1,unused,569,unused,"    NCURSES_CH_T *s;
    time_t this_time;

#if CAN_RESIZE
    sprintf(temp, ""%.20s (%3dx%3d) col %d "", tag, LINES, COLS, shift);
",unused,ncursesubuntuxenial6.0-test2Fview.c
"#if CAN_RESIZE
    sprintf(temp, ""%.20s (%3dx%3d) col %d "", tag, LINES, COLS, shift);
    i = (int) strlen(temp);
    if ((i + 7) < (int) sizeof(temp)) {
	sprintf(temp + i, ""view %.*s"",
",1,unused,572,unused,"#if CAN_RESIZE
    sprintf(temp, ""%.20s (%3dx%3d) col %d "", tag, LINES, COLS, shift);
    i = (int) strlen(temp);
    if ((i + 7) < (int) sizeof(temp)) {
	sprintf(temp + i, ""view %.*s"",
",unused,ncursesubuntuxenial6.0-test2Fview.c
"		    first = FALSE;
		} else {
		    *target++ = '|';
		}
		strcpy(target, scr_attrs[n].name);
",1,unused,666,unused,"		    first = FALSE;
		} else {
		    *target++ = '|';
		}
		strcpy(target, scr_attrs[n].name);
",unused,ncursesxenialubuntu-ncurses2Fbase2Flib_screen.c
"	}
	if ((source & A_COLOR) != (prior & A_COLOR)) {
	    if (!first)
		*target++ = '|';
	    sprintf(target, ""C%d"", PAIR_NUMBER((int) source));
",1,unused,673,unused,"	}
	if ((source & A_COLOR) != (prior & A_COLOR)) {
	    if (!first)
		*target++ = '|';
	    sprintf(target, ""C%d"", PAIR_NUMBER((int) source));
",unused,ncursesxenialubuntu-ncurses2Fbase2Flib_screen.c
"    }
    target += strlen(target);
    *target++ = MARKER;
    if (ch < 32 || ch >= 127) {
	sprintf(target, ""%03o"", UChar(ch));
",1,unused,739,unused,"    }
    target += strlen(target);
    *target++ = MARKER;
    if (ch < 32 || ch >= 127) {
	sprintf(target, ""%03o"", UChar(ch));
",unused,ncursesxenialubuntu-ncurses2Fbase2Flib_screen.c
"	sprintf(target, ""%03o"", UChar(ch));
    } else {
	switch (ch) {
	case ' ':
	    strcpy(target, ""s"");
",1,unused,743,unused,"	sprintf(target, ""%03o"", UChar(ch));
    } else {
	switch (ch) {
	case ' ':
	    strcpy(target, ""s"");
",unused,ncursesxenialubuntu-ncurses2Fbase2Flib_screen.c
"	    *target++ = MARKER;
	    *target = '\0';
	    break;
	default:
	    sprintf(--target, ""%c"", UChar(ch));
",1,unused,750,unused,"	    *target++ = MARKER;
	    *target = '\0';
	    break;
	default:
	    sprintf(--target, ""%c"", UChar(ch));
",unused,ncursesxenialubuntu-ncurses2Fbase2Flib_screen.c
"	    case pBOOL:
		if (!(*(const bool *) data)) {
		    continue;
		}
		strcpy(buffer, name);
",1,unused,801,unused,"	    case pBOOL:
		if (!(*(const bool *) data)) {
		    continue;
		}
		strcpy(buffer, name);
",unused,ncursesxenialubuntu-ncurses2Fbase2Flib_screen.c
"		break;
	    case pINT:
		if (!(*(const int *) dp))
		    continue;
		sprintf(buffer, ""%d"", *(const int *) dp);
",1,unused,810,unused,"		break;
	    case pINT:
		if (!(*(const int *) dp))
		    continue;
		sprintf(buffer, ""%d"", *(const int *) dp);
",unused,ncursesxenialubuntu-ncurses2Fbase2Flib_screen.c
"		break;
	    case pSHORT:
		if (!(*(const short *) dp))
		    continue;
		sprintf(buffer, ""%d"", *(const short *) dp);
",1,unused,815,unused,"		break;
	    case pSHORT:
		if (!(*(const short *) dp))
		    continue;
		sprintf(buffer, ""%d"", *(const short *) dp);
",unused,ncursesxenialubuntu-ncurses2Fbase2Flib_screen.c
"		break;
	    case pSIZE:
		if (!(*(const NCURSES_SIZE_T *) dp))
		    continue;
		sprintf(buffer, ""%d"", *(const NCURSES_SIZE_T *) dp);
",1,unused,820,unused,"		break;
	    case pSIZE:
		if (!(*(const NCURSES_SIZE_T *) dp))
		    continue;
		sprintf(buffer, ""%d"", *(const NCURSES_SIZE_T *) dp);
",unused,ncursesxenialubuntu-ncurses2Fbase2Flib_screen.c
"		if (outbuf.used)
		    wrap_concat(""\n"");
		wrap_concat(""hex:"");
		for (n = 0; n < offset; ++n) {
		    sprintf(numbuf, ""%02X"", UChar(bigbuf[n]));
",1,unused,1180,unused,"		if (outbuf.used)
		    wrap_concat(""\n"");
		wrap_concat(""hex:"");
		for (n = 0; n < offset; ++n) {
		    sprintf(numbuf, ""%02X"", UChar(bigbuf[n]));
",unused,ncursesxenialubuntu-progs2Fdump_entry.c
"		c = live[0];
	    } else {
		char buf[BUFSIZ];

		(void) sprintf(buf,
",1,unused,318,unused,"		c = live[0];
	    } else {
		char buf[BUFSIZ];

		(void) sprintf(buf,
",unused,ncursesxenialubuntu-test2Fblue.c
"	if (card->content != 0 && (offset = strlen(card->content)) != 0) {
	    total += 1 + offset;
	    card->content = typeRealloc(char, total + 1, card->content);
	    if (card->content)
		strcpy(card->content + offset++, "" "");
",1,unused,136,unused,"	if (card->content != 0 && (offset = strlen(card->content)) != 0) {
	    total += 1 + offset;
	    card->content = typeRealloc(char, total + 1, card->content);
	    if (card->content)
		strcpy(card->content + offset++, "" "");
",unused,ncursesxenialubuntu-test2Fcardfile.c
"		free(card->content);
	    card->content = typeMalloc(char, total + 1);
	}
	if (card->content)
	    strcpy(card->content + offset, content);
",1,unused,144,unused,"		free(card->content);
	    card->content = typeMalloc(char, total + 1);
	}
	if (card->content)
	    strcpy(card->content + offset, content);
",unused,ncursesxenialubuntu-test2Fcardfile.c
"	case '.':		/* change from current position */
	    (void) wattrset(win, AttrArg(COLOR_PAIR(st.pair), st.attr));
	    if (st.count > 0) {
		need = (unsigned) st.count + 1;
		sprintf(fmt, ""%%c%%%ds%%c"", st.count);
",1,unused,337,unused,"	case '.':		/* change from current position */
	    (void) wattrset(win, AttrArg(COLOR_PAIR(st.pair), st.attr));
	    if (st.count > 0) {
		need = (unsigned) st.count + 1;
		sprintf(fmt, ""%%c%%%ds%%c"", st.count);
",unused,ncursesxenialubuntu-test2Fclip_printw.c
"		need = (unsigned) st.count + 1;
		sprintf(fmt, ""%%c%%%ds%%c"", st.count);
	    } else {
		need = (unsigned) getmaxx(win) - 1;
		strcpy(fmt, ""%c%s%c"");
",1,unused,340,unused,"		need = (unsigned) st.count + 1;
		sprintf(fmt, ""%%c%%%ds%%c"", st.count);
	    } else {
		need = (unsigned) getmaxx(win) - 1;
		strcpy(fmt, ""%c%s%c"");
",unused,ncursesxenialubuntu-test2Fclip_printw.c
"     * keypad() initializes the corresponding data.
     */
    for (n = 0; n < 255; ++n) {
	char temp[10];
	sprintf(temp, ""\033%c"", n);
",1,unused,107,unused,"     * keypad() initializes the corresponding data.
     */
    for (n = 0; n < 255; ++n) {
	char temp[10];
	sprintf(temp, ""\033%c"", n);
",unused,ncursesxenialubuntu-test2Fdemo_altkeys.c
"    for (n = KEY_MIN; n < KEY_MAX; ++n) {
	char *value;
	if ((value = keybound(n, 0)) != 0) {
	    char *temp = typeMalloc(char, strlen(value) + 2);
	    sprintf(temp, ""\033%s"", value);
",1,unused,114,unused,"    for (n = KEY_MIN; n < KEY_MAX; ++n) {
	char *value;
	if ((value = keybound(n, 0)) != 0) {
	    char *temp = typeMalloc(char, strlen(value) + 2);
	    sprintf(temp, ""\033%s"", value);
",unused,ncursesxenialubuntu-test2Fdemo_altkeys.c
"
    ch = UChar(ch);
    assert(ch >= 0 && ch < 256);
    if (ch == '\\') {
	strcpy(temp, ""\\\\"");
",1,unused,81,unused,"
    ch = UChar(ch);
    assert(ch >= 0 && ch < 256);
    if (ch == '\\') {
	strcpy(temp, ""\\\\"");
",unused,ncursesxenialubuntu-test2Fdemo_defkey.c
"    assert(ch >= 0 && ch < 256);
    if (ch == '\\') {
	strcpy(temp, ""\\\\"");
    } else if (ch == '\033') {
	strcpy(temp, ""\\E"");
",1,unused,83,unused,"    assert(ch >= 0 && ch < 256);
    if (ch == '\\') {
	strcpy(temp, ""\\\\"");
    } else if (ch == '\033') {
	strcpy(temp, ""\\E"");
",unused,ncursesxenialubuntu-test2Fdemo_defkey.c
"	strcpy(temp, ""\\\\"");
    } else if (ch == '\033') {
	strcpy(temp, ""\\E"");
    } else if (ch < ' ') {
	sprintf(temp, ""\\%03o"", ch);
",1,unused,85,unused,"	strcpy(temp, ""\\\\"");
    } else if (ch == '\033') {
	strcpy(temp, ""\\E"");
    } else if (ch < ' ') {
	sprintf(temp, ""\\%03o"", ch);
",unused,ncursesxenialubuntu-test2Fdemo_defkey.c
"	strcpy(temp, ""\\E"");
    } else if (ch < ' ') {
	sprintf(temp, ""\\%03o"", ch);
    } else if (ch >= 127) {
	sprintf(temp, ""\\%03o"", ch);
",1,unused,87,unused,"	strcpy(temp, ""\\E"");
    } else if (ch < ' ') {
	sprintf(temp, ""\\%03o"", ch);
    } else if (ch >= 127) {
	sprintf(temp, ""\\%03o"", ch);
",unused,ncursesxenialubuntu-test2Fdemo_defkey.c
"	sprintf(temp, ""\\%03o"", ch);
    } else if (ch >= 127) {
	sprintf(temp, ""\\%03o"", ch);
    } else {
	sprintf(temp, ""%c"", ch);
",1,unused,89,unused,"	sprintf(temp, ""\\%03o"", ch);
    } else if (ch >= 127) {
	sprintf(temp, ""\\%03o"", ch);
    } else {
	sprintf(temp, ""%c"", ch);
",unused,ncursesxenialubuntu-test2Fdemo_defkey.c
"	    for (n = 0; string[n] != '\0'; ++n) {
		char temp[80];
		strncpy(temp, visichar(string[n]), sizeof(temp) - 2);
		if (pass)
		    strcat(result, temp);
",1,unused,111,unused,"	    for (n = 0; string[n] != '\0'; ++n) {
		char temp[80];
		strncpy(temp, visichar(string[n]), sizeof(temp) - 2);
		if (pass)
		    strcat(result, temp);
",unused,ncursesxenialubuntu-test2Fdemo_defkey.c
"    char *vis_string = 0;
    char temp[80];

    if (code_name == 0) {
	sprintf(temp, ""Keycode %d"", code);
",1,unused,134,unused,"    char *vis_string = 0;
    char temp[80];

    if (code_name == 0) {
	sprintf(temp, ""Keycode %d"", code);
",unused,ncursesxenialubuntu-test2Fdemo_defkey.c
"	} else if (!strncmp(value, ""\033O"", (size_t) 2)) {
	    prefix = ""\033["";
	}
	if (prefix != 0) {
	    sprintf(temp, ""%s%s"", prefix, value + 2);
",1,unused,195,unused,"	} else if (!strncmp(value, ""\033O"", (size_t) 2)) {
	    prefix = ""\033["";
	}
	if (prefix != 0) {
	    sprintf(temp, ""%s%s"", prefix, value + 2);
",unused,ncursesxenialubuntu-test2Fdemo_defkey.c
"     * keypad() initializes the corresponding data.
     */
    for (n = 0; n < 12; ++n) {
	char name[10];
	sprintf(name, ""kf%d"", n + 1);
",1,unused,242,unused,"     * keypad() initializes the corresponding data.
     */
    for (n = 0; n < 12; ++n) {
	char name[10];
	sprintf(name, ""kf%d"", n + 1);
",unused,ncursesxenialubuntu-test2Fdemo_defkey.c
"		    size_t need = strlen(buffer) + 2 + strlen(prior);
		    char *value = typeRealloc(char, need, prior);
		    if (value == 0)
			failed(""realloc"");
		    strcat(value, ""\n"");
",1,unused,152,unused,"		    size_t need = strlen(buffer) + 2 + strlen(prior);
		    char *value = typeRealloc(char, need, prior);
		    if (value == 0)
			failed(""realloc"");
		    strcat(value, ""\n"");
",unused,ncursesxenialubuntu-test2Fdemo_forms.c
"		    char *value = typeRealloc(char, need, prior);
		    if (value == 0)
			failed(""realloc"");
		    strcat(value, ""\n"");
		    strcat(value, buffer);
",1,unused,153,unused,"		    char *value = typeRealloc(char, need, prior);
		    if (value == 0)
			failed(""realloc"");
		    strcat(value, ""\n"");
		    strcat(value, buffer);
",unused,ncursesxenialubuntu-test2Fdemo_forms.c
"    /* describe the form */
    memset(f, 0, sizeof(f));
    for (pg = 0; pg < 4; ++pg) {
	char label[80];
	sprintf(label, ""Sample Form Page %d"", pg + 1);
",1,unused,459,unused,"    /* describe the form */
    memset(f, 0, sizeof(f));
    for (pg = 0; pg < 4; ++pg) {
	char label[80];
	sprintf(label, ""Sample Form Page %d"", pg + 1);
",unused,ncursesxenialubuntu-test2Fdemo_forms.c
"	} else if (!unboxed) {
	    wbkgdset(win, A_BOLD | ' ');
	}
    }
    sprintf(userdata, ""p%d"", color % 8);
",1,unused,225,unused,"	} else if (!unboxed) {
	    wbkgdset(win, A_BOLD | ' ');
	}
    }
    sprintf(userdata, ""p%d"", color % 8);
",unused,ncursesxenialubuntu-test2Fdemo_panels.c
"    }

    if (code > 0) {
	char also[80];
	sprintf(also, "" (first %d,%d)"", y0, x0);
",1,unused,274,unused,"    }

    if (code > 0) {
	char also[80];
	sprintf(also, "" (first %d,%d)"", y0, x0);
",unused,ncursesxenialubuntu-test2Fdemo_panels.c
"	WINDOW *win = panel_window(pans[which]);
	char also[80];

	getbegyx(win, y0, x0);
	sprintf(also, "" (start %d,%d)"", y0, x0);
",1,unused,305,unused,"	WINDOW *win = panel_window(pans[which]);
	char also[80];

	getbegyx(win, y0, x0);
	sprintf(also, "" (start %d,%d)"", y0, x0);
",unused,ncursesxenialubuntu-test2Fdemo_panels.c
"	WINDOW *win = panel_window(pans[which]);
	char also[80];

	getbegyx(win, y0, x0);
	sprintf(also, "" (start %d,%d)"", y0, x0);
",1,unused,330,unused,"	WINDOW *win = panel_window(pans[which]);
	char also[80];

	getbegyx(win, y0, x0);
	sprintf(also, "" (start %d,%d)"", y0, x0);
",unused,ncursesxenialubuntu-test2Fdemo_panels.c
"static char *
make_dbitem(char *p, char *q)
{
    char *result = malloc(strlen(e_opt) + 2 + (size_t) (p - q));
    sprintf(result, ""%s=%.*s"", e_opt, (int) (p - q), q);
",1,unused,104,unused,"static char *
make_dbitem(char *p, char *q)
{
    char *result = malloc(strlen(e_opt) + 2 + (size_t) (p - q));
    sprintf(result, ""%s=%.*s"", e_opt, (int) (p - q), q);
",unused,ncursesxenialubuntu-test2Fdemo_termcap.c
"	    if (pass == 0) {
		length += chunk;
	    } else {
		result[count] = unused;
		strcpy(unused, list[count]);
",1,unused,702,unused,"	    if (pass == 0) {
		length += chunk;
	    } else {
		result[count] = unused;
		strcpy(unused, list[count]);
",unused,ncursesxenialubuntu-test2Fdemo_termcap.c
"static char *
make_dbitem(char *p, char *q)
{
    char *result = malloc(strlen(e_opt) + 2 + (size_t) (p - q));
    sprintf(result, ""%s=%.*s"", e_opt, (int) (p - q), q);
",1,unused,99,unused,"static char *
make_dbitem(char *p, char *q)
{
    char *result = malloc(strlen(e_opt) + 2 + (size_t) (p - q));
    sprintf(result, ""%s=%.*s"", e_opt, (int) (p - q), q);
",unused,ncursesxenialubuntu-test2Fdemo_terminfo.c
"			    !strcmp(xterm_keys[n], ""kLFT"") ||
			    !strcmp(xterm_keys[n], ""kRIT"")) {
			    continue;
			}
			sprintf(temp, ""%.*s"", 8, xterm_keys[n]);
",1,unused,399,unused,"			    !strcmp(xterm_keys[n], ""kLFT"") ||
			    !strcmp(xterm_keys[n], ""kRIT"")) {
			    continue;
			}
			sprintf(temp, ""%.*s"", 8, xterm_keys[n]);
",unused,ncursesxenialubuntu-test2Fdemo_terminfo.c
"			    continue;
			}
			sprintf(temp, ""%.*s"", 8, xterm_keys[n]);
		    } else {
			sprintf(temp, ""%.*s%d"", 8, xterm_keys[n], mod);
",1,unused,401,unused,"			    continue;
			}
			sprintf(temp, ""%.*s"", 8, xterm_keys[n]);
		    } else {
			sprintf(temp, ""%.*s%d"", 8, xterm_keys[n], mod);
",unused,ncursesxenialubuntu-test2Fdemo_terminfo.c
"	    if (pass == 0) {
		length += chunk;
	    } else {
		result[count] = unused;
		strcpy(unused, list[count]);
",1,unused,736,unused,"	    if (pass == 0) {
		length += chunk;
	    } else {
		result[count] = unused;
		strcpy(unused, list[count]);
",unused,ncursesxenialubuntu-test2Fdemo_terminfo.c
"    if (strrchr(slave_name, '/') == 0) {
	errno = EISDIR;
	failed(slave_name);
    }
    sprintf(s_option, ""-S%s/%d"", slave_name, aslave);
",1,unused,170,unused,"    if (strrchr(slave_name, '/') == 0) {
	errno = EISDIR;
	failed(slave_name);
    }
    sprintf(s_option, ""-S%s/%d"", slave_name, aslave);
",unused,ncursesxenialubuntu-test2Fditto.c
"     * will execute as a comment.
     */
#ifdef KEY_EVENT
    if (code == KEY_EVENT)
	strcpy(buffer, ""# event!"");
",1,unused,66,unused,"     * will execute as a comment.
     */
#ifdef KEY_EVENT
    if (code == KEY_EVENT)
	strcpy(buffer, ""# event!"");
",unused,ncursesxenialubuntu-test2Ffilter.c
"	strcpy(buffer, ""# event!"");
#endif
#ifdef KEY_RESIZE
    if (code == KEY_RESIZE) {
	strcpy(buffer, ""# resize!"");
",1,unused,70,unused,"	strcpy(buffer, ""# event!"");
#endif
#ifdef KEY_RESIZE
    if (code == KEY_RESIZE) {
	strcpy(buffer, ""# resize!"");
",unused,ncursesxenialubuntu-test2Ffilter.c
"		      &second,
		      final) == 3
	    && *final != ';'
	    && (value = strdup(info[j].value)) != 0) {
	    sprintf(value, ""\033[%d%c"", first, *final);
",1,unused,166,unused,"		      &second,
		      final) == 3
	    && *final != ';'
	    && (value = strdup(info[j].value)) != 0) {
	    sprintf(value, ""\033[%d%c"", first, *final);
",unused,ncursesxenialubuntu-test2Ffoldkeys.c
"		    break;
		}
	    }
	    if (info[j].state == 0) {
		sprintf(value, ""\033O%c"", *final);
",1,unused,175,unused,"		    break;
		}
	    }
	    if (info[j].state == 0) {
		sprintf(value, ""\033O%c"", *final);
",unused,ncursesxenialubuntu-test2Ffoldkeys.c
"    if (first) {
	static char cmd[80];
	setlocale(LC_ALL, """");

	putenv(strcpy(cmd, ""TABSIZE=8""));
",1,unused,164,unused,"    if (first) {
	static char cmd[80];
	setlocale(LC_ALL, """");

	putenv(strcpy(cmd, ""TABSIZE=8""));
",unused,ncursesxenialubuntu-test2Finserts.c
"mouse_decode(MEVENT const *ep)
{
    static char buf[80 + (5 * 10) + (32 * 15)];

    (void) sprintf(buf, ""id %2d at (%2d, %2d, %d) state %4lx = {"",
",1,unused,518,unused,"mouse_decode(MEVENT const *ep)
{
    static char buf[80 + (5 * 10) + (32 * 15)];

    (void) sprintf(buf, ""id %2d at (%2d, %2d, %d) state %4lx = {"",
",unused,ncursesxenialubuntu-test2Fncurses.c
"#undef SHOW

    if (buf[strlen(buf) - 1] == ' ')
	buf[strlen(buf) - 2] = '\0';
    (void) strcat(buf, ""}"");
",1,unused,577,unused,"#undef SHOW

    if (buf[strlen(buf) - 1] == ' ')
	buf[strlen(buf) - 2] = '\0';
    (void) strcat(buf, ""}"");
",unused,ncursesxenialubuntu-test2Fncurses.c
"	char temp[80];
	int width = 8;

	if (wide) {
	    sprintf(temp, ""%02d"", color);
",1,unused,2087,unused,"	char temp[80];
	int width = 8;

	if (wide) {
	    sprintf(temp, ""%02d"", color);
",unused,ncursesxenialubuntu-test2Fncurses.c
"	if (wide) {
	    sprintf(temp, ""%02d"", color);
	    width = 4;
	} else if (color >= 8) {
	    sprintf(temp, ""[%02d]"", color);
",1,unused,2090,unused,"	if (wide) {
	    sprintf(temp, ""%02d"", color);
	    width = 4;
	} else if (color >= 8) {
	    sprintf(temp, ""[%02d]"", color);
",unused,ncursesxenialubuntu-test2Fncurses.c
"	    width = 4;
	} else if (color >= 8) {
	    sprintf(temp, ""[%02d]"", color);
	} else if (color < 0) {
	    strcpy(temp, ""default"");
",1,unused,2092,unused,"	    width = 4;
	} else if (color >= 8) {
	    sprintf(temp, ""[%02d]"", color);
	} else if (color < 0) {
	    strcpy(temp, ""default"");
",unused,ncursesxenialubuntu-test2Fncurses.c
"	    sprintf(temp, ""[%02d]"", color);
	} else if (color < 0) {
	    strcpy(temp, ""default"");
	} else {
	    sprintf(temp, ""%.*s"", 16, the_color_names[color]);
",1,unused,2094,unused,"	    sprintf(temp, ""[%02d]"", color);
	} else if (color < 0) {
	    strcpy(temp, ""default"");
	} else {
	    sprintf(temp, ""%.*s"", 16, the_color_names[color]);
",unused,ncursesxenialubuntu-test2Fncurses.c
"		if (opt_revs)
		    attron(A_REVERSE);

		if (opt_nums) {
		    sprintf(numbered, ""{%02X}"", (int) i);
",1,unused,2281,unused,"		if (opt_revs)
		    attron(A_REVERSE);

		if (opt_nums) {
		    sprintf(numbered, ""{%02X}"", (int) i);
",unused,ncursesxenialubuntu-test2Fncurses.c
"	     (i - top_color < page_size)
	     && (i < max_colors); i++) {
	    char numeric[80];

	    sprintf(numeric, ""[%d]"", i);
",1,unused,2701,unused,"	     (i - top_color < page_size)
	     && (i < max_colors); i++) {
	    char numeric[80];

	    sprintf(numeric, ""[%d]"", i);
",unused,ncursesxenialubuntu-test2Fncurses.c
"	case '6':
	case '7':
	case '8':
	    MvAddStr(SLK_WORK, 0, ""Please enter the label value: "");
	    strcpy(buf, """");
",1,unused,3078,unused,"	case '6':
	case '7':
	case '8':
	    MvAddStr(SLK_WORK, 0, ""Please enter the label value: "");
	    strcpy(buf, """");
",unused,ncursesxenialubuntu-test2Fncurses.c
"	int count = repeat;
	int row = 2 + ((int) (code - first) % (pagesize / 2));
	int col = ((int) (code - first) / (pagesize / 2)) * COLS / 2;
	char tmp[80];
	sprintf(tmp, ""%3u (0x%x)"", code, code);
",1,unused,3336,unused,"	int count = repeat;
	int row = 2 + ((int) (code - first) % (pagesize / 2));
	int col = ((int) (code - first) / (pagesize / 2)) * COLS / 2;
	char tmp[80];
	sprintf(tmp, ""%3u (0x%x)"", code, code);
",unused,ncursesxenialubuntu-test2Fncurses.c
"    move(LINES - 4, 0);
    for (n = 0; n < SIZEOF(legend); n++) {
	switch (legend[n].code) {
	default:
	    strcpy(buf, legend[n].msg);
",1,unused,4349,unused,"    move(LINES - 4, 0);
    for (n = 0; n < SIZEOF(legend); n++) {
	switch (legend[n].code) {
	default:
	    strcpy(buf, legend[n].msg);
",unused,ncursesxenialubuntu-test2Fncurses.c
"	default:
	    strcpy(buf, legend[n].msg);
	    break;
	case 1:
	    sprintf(buf, legend[n].msg, do_keypad ? ""yes"" : ""no"");
",1,unused,4352,unused,"	default:
	    strcpy(buf, legend[n].msg);
	    break;
	case 1:
	    sprintf(buf, legend[n].msg, do_keypad ? ""yes"" : ""no"");
",unused,ncursesxenialubuntu-test2Fncurses.c
"	case 1:
	    sprintf(buf, legend[n].msg, do_keypad ? ""yes"" : ""no"");
	    break;
	case 2:
	    sprintf(buf, legend[n].msg, do_scroll ? ""yes"" : ""no"");
",1,unused,4355,unused,"	case 1:
	    sprintf(buf, legend[n].msg, do_keypad ? ""yes"" : ""no"");
	    break;
	case 2:
	    sprintf(buf, legend[n].msg, do_scroll ? ""yes"" : ""no"");
",unused,ncursesxenialubuntu-test2Fncurses.c
"	case 2:
	    sprintf(buf, legend[n].msg, do_scroll ? ""yes"" : ""no"");
	    break;
	case 3:
	    sprintf(buf, legend[n].msg, do_keypad ? ""/ESC"" : """");
",1,unused,4358,unused,"	case 2:
	    sprintf(buf, legend[n].msg, do_scroll ? ""yes"" : ""no"");
	    break;
	case 3:
	    sprintf(buf, legend[n].msg, do_keypad ? ""/ESC"" : """");
",unused,ncursesxenialubuntu-test2Fncurses.c
"
	switch (row) {
	case 0:
	    flavors[row] = 0;
	    sprintf(msg, ""refresh %s, then %s, then doupdate."", ths, tht);
",1,unused,6528,unused,"
	switch (row) {
	case 0:
	    flavors[row] = 0;
	    sprintf(msg, ""refresh %s, then %s, then doupdate."", ths, tht);
",unused,ncursesxenialubuntu-test2Fncurses.c
"	    } else {
		flavors[row] %= 2;
	    }
	    overlap_test_1_attr(stdscr, flavors[row], col);
	    sprintf(msg, ""fill window %s with letter %s."", ths, ths);
",1,unused,6537,unused,"	    } else {
		flavors[row] %= 2;
	    }
	    overlap_test_1_attr(stdscr, flavors[row], col);
	    sprintf(msg, ""fill window %s with letter %s."", ths, ths);
",unused,ncursesxenialubuntu-test2Fncurses.c
"		flavors[row] %= 2;
	    }
	    switch (flavors[row]) {
	    case 0:
		sprintf(msg, ""cross pattern in window %s."", ths);
",1,unused,6547,unused,"		flavors[row] %= 2;
	    }
	    switch (flavors[row]) {
	    case 0:
		sprintf(msg, ""cross pattern in window %s."", ths);
",unused,ncursesxenialubuntu-test2Fncurses.c
"	    case 0:
		sprintf(msg, ""cross pattern in window %s."", ths);
		break;
	    case 1:
		sprintf(msg, ""draw box in window %s."", ths);
",1,unused,6550,unused,"	    case 0:
		sprintf(msg, ""cross pattern in window %s."", ths);
		break;
	    case 1:
		sprintf(msg, ""draw box in window %s."", ths);
",unused,ncursesxenialubuntu-test2Fncurses.c
"	    case 1:
		sprintf(msg, ""draw box in window %s."", ths);
		break;
	    case 2:
		sprintf(msg, ""set background of window %s."", ths);
",1,unused,6553,unused,"	    case 1:
		sprintf(msg, ""draw box in window %s."", ths);
		break;
	    case 2:
		sprintf(msg, ""set background of window %s."", ths);
",unused,ncursesxenialubuntu-test2Fncurses.c
"	    case 2:
		sprintf(msg, ""set background of window %s."", ths);
		break;
	    case 3:
		sprintf(msg, ""reset background of window %s."", ths);
",1,unused,6556,unused,"	    case 2:
		sprintf(msg, ""set background of window %s."", ths);
		break;
	    case 3:
		sprintf(msg, ""reset background of window %s."", ths);
",unused,ncursesxenialubuntu-test2Fncurses.c
"	    }
	    break;
	case 3:
	    flavors[row] = 0;
	    sprintf(msg, ""clear window %s."", ths);
",1,unused,6562,unused,"	    }
	    break;
	case 3:
	    flavors[row] = 0;
	    sprintf(msg, ""clear window %s."", ths);
",unused,ncursesxenialubuntu-test2Fncurses.c
"	case 4:
	    flavors[row] %= 4;
	    switch (flavors[row]) {
	    case 0:
		sprintf(msg, ""overwrite %s onto %s."", ths, tht);
",1,unused,6568,unused,"	case 4:
	    flavors[row] %= 4;
	    switch (flavors[row]) {
	    case 0:
		sprintf(msg, ""overwrite %s onto %s."", ths, tht);
",unused,ncursesxenialubuntu-test2Fncurses.c
"	    case 0:
		sprintf(msg, ""overwrite %s onto %s."", ths, tht);
		break;
	    case 1:
		sprintf(msg, ""copywin(FALSE) %s onto %s."", ths, tht);
",1,unused,6571,unused,"	    case 0:
		sprintf(msg, ""overwrite %s onto %s."", ths, tht);
		break;
	    case 1:
		sprintf(msg, ""copywin(FALSE) %s onto %s."", ths, tht);
",unused,ncursesxenialubuntu-test2Fncurses.c
"	    case 1:
		sprintf(msg, ""copywin(FALSE) %s onto %s."", ths, tht);
		break;
	    case 2:
		sprintf(msg, ""copywin(TRUE) %s onto %s."", ths, tht);
",1,unused,6574,unused,"	    case 1:
		sprintf(msg, ""copywin(FALSE) %s onto %s."", ths, tht);
		break;
	    case 2:
		sprintf(msg, ""copywin(TRUE) %s onto %s."", ths, tht);
",unused,ncursesxenialubuntu-test2Fncurses.c
"	    case 2:
		sprintf(msg, ""copywin(TRUE) %s onto %s."", ths, tht);
		break;
	    case 3:
		sprintf(msg, ""overlay %s onto %s."", ths, tht);
",1,unused,6577,unused,"	    case 2:
		sprintf(msg, ""copywin(TRUE) %s onto %s."", ths, tht);
		break;
	    case 3:
		sprintf(msg, ""overlay %s onto %s."", ths, tht);
",unused,ncursesxenialubuntu-test2Fncurses.c
"    for (i = 0; i < 12; i++) {
	sangle = (i + 1) * (2.0 * PI) / 12.0;
	sdx = A2X(sangle, sradius);
	sdy = A2Y(sangle, sradius);
	sprintf(szChar, ""%d"", i + 1);
",1,unused,178,unused,"    for (i = 0; i < 12; i++) {
	sangle = (i + 1) * (2.0 * PI) / 12.0;
	sdx = A2X(sangle, sradius);
	sdy = A2Y(sangle, sradius);
	sprintf(szChar, ""%d"", i + 1);
",unused,ncursesxenialubuntu-test2Ftclock.c
"    if (first) {
	static char cmd[80];
	setlocale(LC_ALL, """");

	putenv(strcpy(cmd, ""TABSIZE=8""));
",1,unused,236,unused,"    if (first) {
	static char cmd[80];
	setlocale(LC_ALL, """");

	putenv(strcpy(cmd, ""TABSIZE=8""));
",unused,ncursesxenialubuntu-test2Ftest_addchstr.c
"    if (first) {
	static char cmd[80];
	setlocale(LC_ALL, """");

	putenv(strcpy(cmd, ""TABSIZE=8""));
",1,unused,158,unused,"    if (first) {
	static char cmd[80];
	setlocale(LC_ALL, """");

	putenv(strcpy(cmd, ""TABSIZE=8""));
",unused,ncursesxenialubuntu-test2Ftest_addstr.c
"static char *
make_dbitem(char *p, char *q)
{
    char *result = malloc(strlen(e_opt) + 2 + (size_t) (p - q));
    sprintf(result, ""%s=%.*s"", e_opt, (int) (p - q), q);
",1,unused,65,unused,"static char *
make_dbitem(char *p, char *q)
{
    char *result = malloc(strlen(e_opt) + 2 + (size_t) (p - q));
    sprintf(result, ""%s=%.*s"", e_opt, (int) (p - q), q);
",unused,ncursesxenialubuntu-test2Ftest_sgr.c
"	    if (isprint(UChar(*d))) {
		col++;
		d++;
	    } else {
		sprintf(d, ""\\%03o"", UChar(*s));
",1,unused,356,unused,"	    if (isprint(UChar(*d))) {
		col++;
		d++;
	    } else {
		sprintf(d, ""\\%03o"", UChar(*s));
",unused,ncursesxenialubuntu-test2Fview.c
"    NCURSES_CH_T *s;
    time_t this_time;

#if CAN_RESIZE
    sprintf(temp, ""%.20s (%3dx%3d) col %d "", tag, LINES, COLS, shift);
",1,unused,569,unused,"    NCURSES_CH_T *s;
    time_t this_time;

#if CAN_RESIZE
    sprintf(temp, ""%.20s (%3dx%3d) col %d "", tag, LINES, COLS, shift);
",unused,ncursesxenialubuntu-test2Fview.c
"#if CAN_RESIZE
    sprintf(temp, ""%.20s (%3dx%3d) col %d "", tag, LINES, COLS, shift);
    i = (int) strlen(temp);
    if ((i + 7) < (int) sizeof(temp)) {
	sprintf(temp + i, ""view %.*s"",
",1,unused,572,unused,"#if CAN_RESIZE
    sprintf(temp, ""%.20s (%3dx%3d) col %d "", tag, LINES, COLS, shift);
    i = (int) strlen(temp);
    if ((i + 7) < (int) sizeof(temp)) {
	sprintf(temp + i, ""view %.*s"",
",unused,ncursesxenialubuntu-test2Fview.c
"		    first = FALSE;
		} else {
		    *target++ = '|';
		}
		strcpy(target, scr_attrs[n].name);
",1,unused,666,unused,"		    first = FALSE;
		} else {
		    *target++ = '|';
		}
		strcpy(target, scr_attrs[n].name);
",unused,ncursesxenpatch-ncurses2Fbase2Flib_screen.c
"	}
	if ((source & A_COLOR) != (prior & A_COLOR)) {
	    if (!first)
		*target++ = '|';
	    sprintf(target, ""C%d"", PAIR_NUMBER((int) source));
",1,unused,673,unused,"	}
	if ((source & A_COLOR) != (prior & A_COLOR)) {
	    if (!first)
		*target++ = '|';
	    sprintf(target, ""C%d"", PAIR_NUMBER((int) source));
",unused,ncursesxenpatch-ncurses2Fbase2Flib_screen.c
"    }
    target += strlen(target);
    *target++ = MARKER;
    if (ch < 32 || ch >= 127) {
	sprintf(target, ""%03o"", UChar(ch));
",1,unused,739,unused,"    }
    target += strlen(target);
    *target++ = MARKER;
    if (ch < 32 || ch >= 127) {
	sprintf(target, ""%03o"", UChar(ch));
",unused,ncursesxenpatch-ncurses2Fbase2Flib_screen.c
"	sprintf(target, ""%03o"", UChar(ch));
    } else {
	switch (ch) {
	case ' ':
	    strcpy(target, ""s"");
",1,unused,743,unused,"	sprintf(target, ""%03o"", UChar(ch));
    } else {
	switch (ch) {
	case ' ':
	    strcpy(target, ""s"");
",unused,ncursesxenpatch-ncurses2Fbase2Flib_screen.c
"	    *target++ = MARKER;
	    *target = '\0';
	    break;
	default:
	    sprintf(--target, ""%c"", UChar(ch));
",1,unused,750,unused,"	    *target++ = MARKER;
	    *target = '\0';
	    break;
	default:
	    sprintf(--target, ""%c"", UChar(ch));
",unused,ncursesxenpatch-ncurses2Fbase2Flib_screen.c
"	    case pBOOL:
		if (!(*(const bool *) data)) {
		    continue;
		}
		strcpy(buffer, name);
",1,unused,801,unused,"	    case pBOOL:
		if (!(*(const bool *) data)) {
		    continue;
		}
		strcpy(buffer, name);
",unused,ncursesxenpatch-ncurses2Fbase2Flib_screen.c
"		break;
	    case pINT:
		if (!(*(const int *) dp))
		    continue;
		sprintf(buffer, ""%d"", *(const int *) dp);
",1,unused,810,unused,"		break;
	    case pINT:
		if (!(*(const int *) dp))
		    continue;
		sprintf(buffer, ""%d"", *(const int *) dp);
",unused,ncursesxenpatch-ncurses2Fbase2Flib_screen.c
"		break;
	    case pSHORT:
		if (!(*(const short *) dp))
		    continue;
		sprintf(buffer, ""%d"", *(const short *) dp);
",1,unused,815,unused,"		break;
	    case pSHORT:
		if (!(*(const short *) dp))
		    continue;
		sprintf(buffer, ""%d"", *(const short *) dp);
",unused,ncursesxenpatch-ncurses2Fbase2Flib_screen.c
"		break;
	    case pSIZE:
		if (!(*(const NCURSES_SIZE_T *) dp))
		    continue;
		sprintf(buffer, ""%d"", *(const NCURSES_SIZE_T *) dp);
",1,unused,820,unused,"		break;
	    case pSIZE:
		if (!(*(const NCURSES_SIZE_T *) dp))
		    continue;
		sprintf(buffer, ""%d"", *(const NCURSES_SIZE_T *) dp);
",unused,ncursesxenpatch-ncurses2Fbase2Flib_screen.c
"		if (outbuf.used)
		    wrap_concat(""\n"");
		wrap_concat(""hex:"");
		for (n = 0; n < offset; ++n) {
		    sprintf(numbuf, ""%02X"", UChar(bigbuf[n]));
",1,unused,1180,unused,"		if (outbuf.used)
		    wrap_concat(""\n"");
		wrap_concat(""hex:"");
		for (n = 0; n < offset; ++n) {
		    sprintf(numbuf, ""%02X"", UChar(bigbuf[n]));
",unused,ncursesxenpatch-progs2Fdump_entry.c
"
    *next++ = '\0';
    for (k = 1; k <= NUM_PARM; k++) {
	numbers[k] = count;
	sprintf(next, ""XYZ%d"", count);
",1,unused,1779,unused,"
    *next++ = '\0';
    for (k = 1; k <= NUM_PARM; k++) {
	numbers[k] = count;
	sprintf(next, ""XYZ%d"", count);
",unused,ncursesxenpatch-progs2Ftic.c
"		c = live[0];
	    } else {
		char buf[BUFSIZ];

		(void) sprintf(buf,
",1,unused,318,unused,"		c = live[0];
	    } else {
		char buf[BUFSIZ];

		(void) sprintf(buf,
",unused,ncursesxenpatch-test2Fblue.c
"	if (card->content != 0 && (offset = strlen(card->content)) != 0) {
	    total += 1 + offset;
	    card->content = typeRealloc(char, total + 1, card->content);
	    if (card->content)
		strcpy(card->content + offset++, "" "");
",1,unused,136,unused,"	if (card->content != 0 && (offset = strlen(card->content)) != 0) {
	    total += 1 + offset;
	    card->content = typeRealloc(char, total + 1, card->content);
	    if (card->content)
		strcpy(card->content + offset++, "" "");
",unused,ncursesxenpatch-test2Fcardfile.c
"		free(card->content);
	    card->content = typeMalloc(char, total + 1);
	}
	if (card->content)
	    strcpy(card->content + offset, content);
",1,unused,144,unused,"		free(card->content);
	    card->content = typeMalloc(char, total + 1);
	}
	if (card->content)
	    strcpy(card->content + offset, content);
",unused,ncursesxenpatch-test2Fcardfile.c
"	case '.':		/* change from current position */
	    (void) wattrset(win, AttrArg(COLOR_PAIR(st.pair), st.attr));
	    if (st.count > 0) {
		need = (unsigned) st.count + 1;
		sprintf(fmt, ""%%c%%%ds%%c"", st.count);
",1,unused,337,unused,"	case '.':		/* change from current position */
	    (void) wattrset(win, AttrArg(COLOR_PAIR(st.pair), st.attr));
	    if (st.count > 0) {
		need = (unsigned) st.count + 1;
		sprintf(fmt, ""%%c%%%ds%%c"", st.count);
",unused,ncursesxenpatch-test2Fclip_printw.c
"		need = (unsigned) st.count + 1;
		sprintf(fmt, ""%%c%%%ds%%c"", st.count);
	    } else {
		need = (unsigned) getmaxx(win) - 1;
		strcpy(fmt, ""%c%s%c"");
",1,unused,340,unused,"		need = (unsigned) st.count + 1;
		sprintf(fmt, ""%%c%%%ds%%c"", st.count);
	    } else {
		need = (unsigned) getmaxx(win) - 1;
		strcpy(fmt, ""%c%s%c"");
",unused,ncursesxenpatch-test2Fclip_printw.c
"     * keypad() initializes the corresponding data.
     */
    for (n = 0; n < 255; ++n) {
	char temp[10];
	sprintf(temp, ""\033%c"", n);
",1,unused,107,unused,"     * keypad() initializes the corresponding data.
     */
    for (n = 0; n < 255; ++n) {
	char temp[10];
	sprintf(temp, ""\033%c"", n);
",unused,ncursesxenpatch-test2Fdemo_altkeys.c
"    for (n = KEY_MIN; n < KEY_MAX; ++n) {
	char *value;
	if ((value = keybound(n, 0)) != 0) {
	    char *temp = typeMalloc(char, strlen(value) + 2);
	    sprintf(temp, ""\033%s"", value);
",1,unused,114,unused,"    for (n = KEY_MIN; n < KEY_MAX; ++n) {
	char *value;
	if ((value = keybound(n, 0)) != 0) {
	    char *temp = typeMalloc(char, strlen(value) + 2);
	    sprintf(temp, ""\033%s"", value);
",unused,ncursesxenpatch-test2Fdemo_altkeys.c
"		    size_t need = strlen(buffer) + 2 + strlen(prior);
		    char *value = typeRealloc(char, need, prior);
		    if (value == 0)
			failed(""realloc"");
		    strcat(value, ""\n"");
",1,unused,152,unused,"		    size_t need = strlen(buffer) + 2 + strlen(prior);
		    char *value = typeRealloc(char, need, prior);
		    if (value == 0)
			failed(""realloc"");
		    strcat(value, ""\n"");
",unused,ncursesxenpatch-test2Fdemo_forms.c
"		    char *value = typeRealloc(char, need, prior);
		    if (value == 0)
			failed(""realloc"");
		    strcat(value, ""\n"");
		    strcat(value, buffer);
",1,unused,153,unused,"		    char *value = typeRealloc(char, need, prior);
		    if (value == 0)
			failed(""realloc"");
		    strcat(value, ""\n"");
		    strcat(value, buffer);
",unused,ncursesxenpatch-test2Fdemo_forms.c
"    /* describe the form */
    memset(f, 0, sizeof(f));
    for (pg = 0; pg < 4; ++pg) {
	char label[80];
	sprintf(label, ""Sample Form Page %d"", pg + 1);
",1,unused,459,unused,"    /* describe the form */
    memset(f, 0, sizeof(f));
    for (pg = 0; pg < 4; ++pg) {
	char label[80];
	sprintf(label, ""Sample Form Page %d"", pg + 1);
",unused,ncursesxenpatch-test2Fdemo_forms.c
"	} else if (!unboxed) {
	    wbkgdset(win, A_BOLD | ' ');
	}
    }
    sprintf(userdata, ""p%d"", color % 8);
",1,unused,225,unused,"	} else if (!unboxed) {
	    wbkgdset(win, A_BOLD | ' ');
	}
    }
    sprintf(userdata, ""p%d"", color % 8);
",unused,ncursesxenpatch-test2Fdemo_panels.c
"    }

    if (code > 0) {
	char also[80];
	sprintf(also, "" (first %d,%d)"", y0, x0);
",1,unused,274,unused,"    }

    if (code > 0) {
	char also[80];
	sprintf(also, "" (first %d,%d)"", y0, x0);
",unused,ncursesxenpatch-test2Fdemo_panels.c
"	WINDOW *win = panel_window(pans[which]);
	char also[80];

	getbegyx(win, y0, x0);
	sprintf(also, "" (start %d,%d)"", y0, x0);
",1,unused,305,unused,"	WINDOW *win = panel_window(pans[which]);
	char also[80];

	getbegyx(win, y0, x0);
	sprintf(also, "" (start %d,%d)"", y0, x0);
",unused,ncursesxenpatch-test2Fdemo_panels.c
"	WINDOW *win = panel_window(pans[which]);
	char also[80];

	getbegyx(win, y0, x0);
	sprintf(also, "" (start %d,%d)"", y0, x0);
",1,unused,330,unused,"	WINDOW *win = panel_window(pans[which]);
	char also[80];

	getbegyx(win, y0, x0);
	sprintf(also, "" (start %d,%d)"", y0, x0);
",unused,ncursesxenpatch-test2Fdemo_panels.c
"static char *
make_dbitem(char *p, char *q)
{
    char *result = malloc(strlen(e_opt) + 2 + (size_t) (p - q));
    sprintf(result, ""%s=%.*s"", e_opt, (int) (p - q), q);
",1,unused,104,unused,"static char *
make_dbitem(char *p, char *q)
{
    char *result = malloc(strlen(e_opt) + 2 + (size_t) (p - q));
    sprintf(result, ""%s=%.*s"", e_opt, (int) (p - q), q);
",unused,ncursesxenpatch-test2Fdemo_termcap.c
"	    if (pass == 0) {
		length += chunk;
	    } else {
		result[count] = unused;
		strcpy(unused, list[count]);
",1,unused,702,unused,"	    if (pass == 0) {
		length += chunk;
	    } else {
		result[count] = unused;
		strcpy(unused, list[count]);
",unused,ncursesxenpatch-test2Fdemo_termcap.c
"static char *
make_dbitem(char *p, char *q)
{
    char *result = malloc(strlen(e_opt) + 2 + (size_t) (p - q));
    sprintf(result, ""%s=%.*s"", e_opt, (int) (p - q), q);
",1,unused,99,unused,"static char *
make_dbitem(char *p, char *q)
{
    char *result = malloc(strlen(e_opt) + 2 + (size_t) (p - q));
    sprintf(result, ""%s=%.*s"", e_opt, (int) (p - q), q);
",unused,ncursesxenpatch-test2Fdemo_terminfo.c
"			    !strcmp(xterm_keys[n], ""kLFT"") ||
			    !strcmp(xterm_keys[n], ""kRIT"")) {
			    continue;
			}
			sprintf(temp, ""%.*s"", 8, xterm_keys[n]);
",1,unused,399,unused,"			    !strcmp(xterm_keys[n], ""kLFT"") ||
			    !strcmp(xterm_keys[n], ""kRIT"")) {
			    continue;
			}
			sprintf(temp, ""%.*s"", 8, xterm_keys[n]);
",unused,ncursesxenpatch-test2Fdemo_terminfo.c
"			    continue;
			}
			sprintf(temp, ""%.*s"", 8, xterm_keys[n]);
		    } else {
			sprintf(temp, ""%.*s%d"", 8, xterm_keys[n], mod);
",1,unused,401,unused,"			    continue;
			}
			sprintf(temp, ""%.*s"", 8, xterm_keys[n]);
		    } else {
			sprintf(temp, ""%.*s%d"", 8, xterm_keys[n], mod);
",unused,ncursesxenpatch-test2Fdemo_terminfo.c
"	    if (pass == 0) {
		length += chunk;
	    } else {
		result[count] = unused;
		strcpy(unused, list[count]);
",1,unused,736,unused,"	    if (pass == 0) {
		length += chunk;
	    } else {
		result[count] = unused;
		strcpy(unused, list[count]);
",unused,ncursesxenpatch-test2Fdemo_terminfo.c
"    if (strrchr(slave_name, '/') == 0) {
	errno = EISDIR;
	failed(slave_name);
    }
    sprintf(s_option, ""-S%s/%d"", slave_name, aslave);
",1,unused,170,unused,"    if (strrchr(slave_name, '/') == 0) {
	errno = EISDIR;
	failed(slave_name);
    }
    sprintf(s_option, ""-S%s/%d"", slave_name, aslave);
",unused,ncursesxenpatch-test2Fditto.c
"mouse_decode(MEVENT const *ep)
{
    static char buf[80 + (5 * 10) + (32 * 15)];

    (void) sprintf(buf, ""id %2d at (%2d, %2d, %d) state %4lx = {"",
",1,unused,518,unused,"mouse_decode(MEVENT const *ep)
{
    static char buf[80 + (5 * 10) + (32 * 15)];

    (void) sprintf(buf, ""id %2d at (%2d, %2d, %d) state %4lx = {"",
",unused,ncursesxenpatch-test2Fncurses.c
"#undef SHOW

    if (buf[strlen(buf) - 1] == ' ')
	buf[strlen(buf) - 2] = '\0';
    (void) strcat(buf, ""}"");
",1,unused,577,unused,"#undef SHOW

    if (buf[strlen(buf) - 1] == ' ')
	buf[strlen(buf) - 2] = '\0';
    (void) strcat(buf, ""}"");
",unused,ncursesxenpatch-test2Fncurses.c
"	char temp[80];
	int width = 8;

	if (wide) {
	    sprintf(temp, ""%02d"", color);
",1,unused,2087,unused,"	char temp[80];
	int width = 8;

	if (wide) {
	    sprintf(temp, ""%02d"", color);
",unused,ncursesxenpatch-test2Fncurses.c
"	if (wide) {
	    sprintf(temp, ""%02d"", color);
	    width = 4;
	} else if (color >= 8) {
	    sprintf(temp, ""[%02d]"", color);
",1,unused,2090,unused,"	if (wide) {
	    sprintf(temp, ""%02d"", color);
	    width = 4;
	} else if (color >= 8) {
	    sprintf(temp, ""[%02d]"", color);
",unused,ncursesxenpatch-test2Fncurses.c
"	    width = 4;
	} else if (color >= 8) {
	    sprintf(temp, ""[%02d]"", color);
	} else if (color < 0) {
	    strcpy(temp, ""default"");
",1,unused,2092,unused,"	    width = 4;
	} else if (color >= 8) {
	    sprintf(temp, ""[%02d]"", color);
	} else if (color < 0) {
	    strcpy(temp, ""default"");
",unused,ncursesxenpatch-test2Fncurses.c
"	    sprintf(temp, ""[%02d]"", color);
	} else if (color < 0) {
	    strcpy(temp, ""default"");
	} else {
	    sprintf(temp, ""%.*s"", 16, the_color_names[color]);
",1,unused,2094,unused,"	    sprintf(temp, ""[%02d]"", color);
	} else if (color < 0) {
	    strcpy(temp, ""default"");
	} else {
	    sprintf(temp, ""%.*s"", 16, the_color_names[color]);
",unused,ncursesxenpatch-test2Fncurses.c
"		if (opt_revs)
		    attron(A_REVERSE);

		if (opt_nums) {
		    sprintf(numbered, ""{%02X}"", (int) i);
",1,unused,2281,unused,"		if (opt_revs)
		    attron(A_REVERSE);

		if (opt_nums) {
		    sprintf(numbered, ""{%02X}"", (int) i);
",unused,ncursesxenpatch-test2Fncurses.c
"	     (i - top_color < page_size)
	     && (i < max_colors); i++) {
	    char numeric[80];

	    sprintf(numeric, ""[%d]"", i);
",1,unused,2701,unused,"	     (i - top_color < page_size)
	     && (i < max_colors); i++) {
	    char numeric[80];

	    sprintf(numeric, ""[%d]"", i);
",unused,ncursesxenpatch-test2Fncurses.c
"	case '6':
	case '7':
	case '8':
	    MvAddStr(SLK_WORK, 0, ""Please enter the label value: "");
	    strcpy(buf, """");
",1,unused,3078,unused,"	case '6':
	case '7':
	case '8':
	    MvAddStr(SLK_WORK, 0, ""Please enter the label value: "");
	    strcpy(buf, """");
",unused,ncursesxenpatch-test2Fncurses.c
"	int count = repeat;
	int row = 2 + ((int) (code - first) % (pagesize / 2));
	int col = ((int) (code - first) / (pagesize / 2)) * COLS / 2;
	char tmp[80];
	sprintf(tmp, ""%3u (0x%x)"", code, code);
",1,unused,3336,unused,"	int count = repeat;
	int row = 2 + ((int) (code - first) % (pagesize / 2));
	int col = ((int) (code - first) / (pagesize / 2)) * COLS / 2;
	char tmp[80];
	sprintf(tmp, ""%3u (0x%x)"", code, code);
",unused,ncursesxenpatch-test2Fncurses.c
"    move(LINES - 4, 0);
    for (n = 0; n < SIZEOF(legend); n++) {
	switch (legend[n].code) {
	default:
	    strcpy(buf, legend[n].msg);
",1,unused,4349,unused,"    move(LINES - 4, 0);
    for (n = 0; n < SIZEOF(legend); n++) {
	switch (legend[n].code) {
	default:
	    strcpy(buf, legend[n].msg);
",unused,ncursesxenpatch-test2Fncurses.c
"	default:
	    strcpy(buf, legend[n].msg);
	    break;
	case 1:
	    sprintf(buf, legend[n].msg, do_keypad ? ""yes"" : ""no"");
",1,unused,4352,unused,"	default:
	    strcpy(buf, legend[n].msg);
	    break;
	case 1:
	    sprintf(buf, legend[n].msg, do_keypad ? ""yes"" : ""no"");
",unused,ncursesxenpatch-test2Fncurses.c
"	case 1:
	    sprintf(buf, legend[n].msg, do_keypad ? ""yes"" : ""no"");
	    break;
	case 2:
	    sprintf(buf, legend[n].msg, do_scroll ? ""yes"" : ""no"");
",1,unused,4355,unused,"	case 1:
	    sprintf(buf, legend[n].msg, do_keypad ? ""yes"" : ""no"");
	    break;
	case 2:
	    sprintf(buf, legend[n].msg, do_scroll ? ""yes"" : ""no"");
",unused,ncursesxenpatch-test2Fncurses.c
"	case 2:
	    sprintf(buf, legend[n].msg, do_scroll ? ""yes"" : ""no"");
	    break;
	case 3:
	    sprintf(buf, legend[n].msg, do_keypad ? ""/ESC"" : """");
",1,unused,4358,unused,"	case 2:
	    sprintf(buf, legend[n].msg, do_scroll ? ""yes"" : ""no"");
	    break;
	case 3:
	    sprintf(buf, legend[n].msg, do_keypad ? ""/ESC"" : """");
",unused,ncursesxenpatch-test2Fncurses.c
"
	switch (row) {
	case 0:
	    flavors[row] = 0;
	    sprintf(msg, ""refresh %s, then %s, then doupdate."", ths, tht);
",1,unused,6528,unused,"
	switch (row) {
	case 0:
	    flavors[row] = 0;
	    sprintf(msg, ""refresh %s, then %s, then doupdate."", ths, tht);
",unused,ncursesxenpatch-test2Fncurses.c
"	    } else {
		flavors[row] %= 2;
	    }
	    overlap_test_1_attr(stdscr, flavors[row], col);
	    sprintf(msg, ""fill window %s with letter %s."", ths, ths);
",1,unused,6537,unused,"	    } else {
		flavors[row] %= 2;
	    }
	    overlap_test_1_attr(stdscr, flavors[row], col);
	    sprintf(msg, ""fill window %s with letter %s."", ths, ths);
",unused,ncursesxenpatch-test2Fncurses.c
"		flavors[row] %= 2;
	    }
	    switch (flavors[row]) {
	    case 0:
		sprintf(msg, ""cross pattern in window %s."", ths);
",1,unused,6547,unused,"		flavors[row] %= 2;
	    }
	    switch (flavors[row]) {
	    case 0:
		sprintf(msg, ""cross pattern in window %s."", ths);
",unused,ncursesxenpatch-test2Fncurses.c
"	    case 0:
		sprintf(msg, ""cross pattern in window %s."", ths);
		break;
	    case 1:
		sprintf(msg, ""draw box in window %s."", ths);
",1,unused,6550,unused,"	    case 0:
		sprintf(msg, ""cross pattern in window %s."", ths);
		break;
	    case 1:
		sprintf(msg, ""draw box in window %s."", ths);
",unused,ncursesxenpatch-test2Fncurses.c
"	    case 1:
		sprintf(msg, ""draw box in window %s."", ths);
		break;
	    case 2:
		sprintf(msg, ""set background of window %s."", ths);
",1,unused,6553,unused,"	    case 1:
		sprintf(msg, ""draw box in window %s."", ths);
		break;
	    case 2:
		sprintf(msg, ""set background of window %s."", ths);
",unused,ncursesxenpatch-test2Fncurses.c
"	    case 2:
		sprintf(msg, ""set background of window %s."", ths);
		break;
	    case 3:
		sprintf(msg, ""reset background of window %s."", ths);
",1,unused,6556,unused,"	    case 2:
		sprintf(msg, ""set background of window %s."", ths);
		break;
	    case 3:
		sprintf(msg, ""reset background of window %s."", ths);
",unused,ncursesxenpatch-test2Fncurses.c
"	    }
	    break;
	case 3:
	    flavors[row] = 0;
	    sprintf(msg, ""clear window %s."", ths);
",1,unused,6562,unused,"	    }
	    break;
	case 3:
	    flavors[row] = 0;
	    sprintf(msg, ""clear window %s."", ths);
",unused,ncursesxenpatch-test2Fncurses.c
"	case 4:
	    flavors[row] %= 4;
	    switch (flavors[row]) {
	    case 0:
		sprintf(msg, ""overwrite %s onto %s."", ths, tht);
",1,unused,6568,unused,"	case 4:
	    flavors[row] %= 4;
	    switch (flavors[row]) {
	    case 0:
		sprintf(msg, ""overwrite %s onto %s."", ths, tht);
",unused,ncursesxenpatch-test2Fncurses.c
"	    case 0:
		sprintf(msg, ""overwrite %s onto %s."", ths, tht);
		break;
	    case 1:
		sprintf(msg, ""copywin(FALSE) %s onto %s."", ths, tht);
",1,unused,6571,unused,"	    case 0:
		sprintf(msg, ""overwrite %s onto %s."", ths, tht);
		break;
	    case 1:
		sprintf(msg, ""copywin(FALSE) %s onto %s."", ths, tht);
",unused,ncursesxenpatch-test2Fncurses.c
"	    case 1:
		sprintf(msg, ""copywin(FALSE) %s onto %s."", ths, tht);
		break;
	    case 2:
		sprintf(msg, ""copywin(TRUE) %s onto %s."", ths, tht);
",1,unused,6574,unused,"	    case 1:
		sprintf(msg, ""copywin(FALSE) %s onto %s."", ths, tht);
		break;
	    case 2:
		sprintf(msg, ""copywin(TRUE) %s onto %s."", ths, tht);
",unused,ncursesxenpatch-test2Fncurses.c
"	    case 2:
		sprintf(msg, ""copywin(TRUE) %s onto %s."", ths, tht);
		break;
	    case 3:
		sprintf(msg, ""overlay %s onto %s."", ths, tht);
",1,unused,6577,unused,"	    case 2:
		sprintf(msg, ""copywin(TRUE) %s onto %s."", ths, tht);
		break;
	    case 3:
		sprintf(msg, ""overlay %s onto %s."", ths, tht);
",unused,ncursesxenpatch-test2Fncurses.c
"	set_colors(win, 6, COLOR_YELLOW, COLOR_WHITE);
	message = messages[j = 0];
	i = 1;
	w = width - 2;
	strcpy(buffer, message);
",1,unused,302,unused,"	set_colors(win, 6, COLOR_YELLOW, COLOR_WHITE);
	message = messages[j = 0];
	i = 1;
	w = width - 2;
	strcpy(buffer, message);
",unused,ncursesxenpatch-test2Fnewdemo.c
"	w = width - 2;
	strcpy(buffer, message);
	while (j < NMESSAGES) {
	    while ((int) strlen(buffer) < w) {
		strcat(buffer, "" ... "");
",1,unused,305,unused,"	w = width - 2;
	strcpy(buffer, message);
	while (j < NMESSAGES) {
	    while ((int) strlen(buffer) < w) {
		strcat(buffer, "" ... "");
",unused,ncursesxenpatch-test2Fnewdemo.c
"	strcpy(buffer, message);
	while (j < NMESSAGES) {
	    while ((int) strlen(buffer) < w) {
		strcat(buffer, "" ... "");
		strcat(buffer, messages[++j % NMESSAGES]);
",1,unused,306,unused,"	strcpy(buffer, message);
	while (j < NMESSAGES) {
	    while ((int) strlen(buffer) < w) {
		strcat(buffer, "" ... "");
		strcat(buffer, messages[++j % NMESSAGES]);
",unused,ncursesxenpatch-test2Fnewdemo.c
"    for (i = 0; i < 12; i++) {
	sangle = (i + 1) * (2.0 * PI) / 12.0;
	sdx = A2X(sangle, sradius);
	sdy = A2Y(sangle, sradius);
	sprintf(szChar, ""%d"", i + 1);
",1,unused,178,unused,"    for (i = 0; i < 12; i++) {
	sangle = (i + 1) * (2.0 * PI) / 12.0;
	sdx = A2X(sangle, sradius);
	sdy = A2Y(sangle, sradius);
	sprintf(szChar, ""%d"", i + 1);
",unused,ncursesxenpatch-test2Ftclock.c
"    if (first) {
	static char cmd[80];
	setlocale(LC_ALL, """");

	putenv(strcpy(cmd, ""TABSIZE=8""));
",1,unused,236,unused,"    if (first) {
	static char cmd[80];
	setlocale(LC_ALL, """");

	putenv(strcpy(cmd, ""TABSIZE=8""));
",unused,ncursesxenpatch-test2Ftest_addchstr.c
"    if (first) {
	static char cmd[80];
	setlocale(LC_ALL, """");

	putenv(strcpy(cmd, ""TABSIZE=8""));
",1,unused,158,unused,"    if (first) {
	static char cmd[80];
	setlocale(LC_ALL, """");

	putenv(strcpy(cmd, ""TABSIZE=8""));
",unused,ncursesxenpatch-test2Ftest_addstr.c
"static char *
make_dbitem(char *p, char *q)
{
    char *result = malloc(strlen(e_opt) + 2 + (size_t) (p - q));
    sprintf(result, ""%s=%.*s"", e_opt, (int) (p - q), q);
",1,unused,65,unused,"static char *
make_dbitem(char *p, char *q)
{
    char *result = malloc(strlen(e_opt) + 2 + (size_t) (p - q));
    sprintf(result, ""%s=%.*s"", e_opt, (int) (p - q), q);
",unused,ncursesxenpatch-test2Ftest_sgr.c
"	    if (isprint(UChar(*d))) {
		col++;
		d++;
	    } else {
		sprintf(d, ""\\%03o"", UChar(*s));
",1,unused,356,unused,"	    if (isprint(UChar(*d))) {
		col++;
		d++;
	    } else {
		sprintf(d, ""\\%03o"", UChar(*s));
",unused,ncursesxenpatch-test2Fview.c
"    NCURSES_CH_T *s;
    time_t this_time;

#if CAN_RESIZE
    sprintf(temp, ""%.20s (%3dx%3d) col %d "", tag, LINES, COLS, shift);
",1,unused,569,unused,"    NCURSES_CH_T *s;
    time_t this_time;

#if CAN_RESIZE
    sprintf(temp, ""%.20s (%3dx%3d) col %d "", tag, LINES, COLS, shift);
",unused,ncursesxenpatch-test2Fview.c
"#if CAN_RESIZE
    sprintf(temp, ""%.20s (%3dx%3d) col %d "", tag, LINES, COLS, shift);
    i = (int) strlen(temp);
    if ((i + 7) < (int) sizeof(temp)) {
	sprintf(temp + i, ""view %.*s"",
",1,unused,572,unused,"#if CAN_RESIZE
    sprintf(temp, ""%.20s (%3dx%3d) col %d "", tag, LINES, COLS, shift);
    i = (int) strlen(temp);
    if ((i + 7) < (int) sizeof(temp)) {
	sprintf(temp + i, ""view %.*s"",
",unused,ncursesxenpatch-test2Fview.c
"    char t = '\0';
    int i = 0;

    for (; t != '\n'; i++) {
        if (scanf(""%s%c"", a[i], &t) != 2)
",1,unused,15,unused,"    char t = '\0';
    int i = 0;

    for (; t != '\n'; i++) {
        if (scanf(""%s%c"", a[i], &t) != 2)
",unused,nouname_lab1-app2Fmain.c
"    for (; t != '\n'; i++) {
        if (scanf(""%s%c"", a[i], &t) != 2)
            return 0;
    }

",1,unused,18,unused,"    for (; t != '\n'; i++) {
        if (scanf(""%s%c"", a[i], &t) != 2)
            return 0;
    }

",unused,nouname_lab1-app2Fmain.c
"    int i = 0;

    for (; t != '\n'; i++) {
        if (scanf(""%s%c"", a[i], &t) != 2)
            return 0;
",1,unused,16,unused,"    int i = 0;

    for (; t != '\n'; i++) {
        if (scanf(""%s%c"", a[i], &t) != 2)
            return 0;
",unused,nouname_lab1-app2Fmain.c
"  UNUSED(cursor);

  char line[MAXLINE];
  char output_line[MAXLINE];
  strcpy(line, contents);
",1,unused,34,unused,"  UNUSED(cursor);

  char line[MAXLINE];
  char output_line[MAXLINE];
  strcpy(line, contents);
",unused,nouname_lab2-app2Fshownum.c
"  /*        */
  if (cursor >= 0) {
    strncpy(output_line, line, cursor);
    output_line[cursor] = '|';
    strcpy(output_line + cursor + 1, line + cursor);
",1,unused,40,unused,"  /*        */
  if (cursor >= 0) {
    strncpy(output_line, line, cursor);
    output_line[cursor] = '|';
    strcpy(output_line + cursor + 1, line + cursor);
",unused,nouname_lab2-app2Fshownum.c
"
		preg = xmalloc (sizeof (regex_t));
		if (opt_exact) {
			re = xmalloc (strlen (opt_pattern) + 5);
			sprintf (re, ""^(%s)$"", opt_pattern);
",1,unused,464,unused,"
		preg = xmalloc (sizeof (regex_t));
		if (opt_exact) {
			re = xmalloc (strlen (opt_pattern) + 5);
			sprintf (re, ""^(%s)$"", opt_pattern);
",unused,oldversionprocps-pgrep.c
"		sig = signal_option(&argc, argv);
		if (-1 < sig)
			opt_signal = sig;
		/* These options are for pkill only */
		strcat (opts, ""e"");
",1,unused,724,unused,"		sig = signal_option(&argc, argv);
		if (-1 < sig)
			opt_signal = sig;
		/* These options are for pkill only */
		strcat (opts, ""e"");
",unused,oldversionprocps-pgrep.c
"		/* These options are for pkill only */
		strcat (opts, ""e"");
	} else {
		/* These options are for pgrep only */
		strcat (opts, ""lad:vw"");
",1,unused,727,unused,"		/* These options are for pkill only */
		strcat (opts, ""e"");
	} else {
		/* These options are for pgrep only */
		strcat (opts, ""lad:vw"");
",unused,oldversionprocps-pgrep.c
"		/* These options are for pgrep only */
		strcat (opts, ""lad:vw"");
	}

	strcat (opts, ""LF:cfnoxP:g:s:u:U:G:t:?Vh"");
",1,unused,730,unused,"		/* These options are for pgrep only */
		strcat (opts, ""lad:vw"");
	}

	strcat (opts, ""LF:cfnoxP:g:s:u:U:G:t:?Vh"");
",unused,oldversionprocps-pgrep.c
"					listtail->next = listnode;
				}
				listtail = listnode;
				/* listnode was calloc()ed so all fields are already NULL! */
				strcpy(listnode->description, detail_desc);
",1,unused,361,unused,"					listtail->next = listnode;
				}
				listtail = listnode;
				/* listnode was calloc()ed so all fields are already NULL! */
				strcpy(listnode->description, detail_desc);
",unused,oldversionprocps-pmap.c
"					xerrx(EXIT_FAILURE, ""ERROR: %s %s"",
					      _(""inconsistent detail field in smaps file, line:\n""),
					      mapbuf);
			}
			strcpy(listnode->value_str, value_str);
",1,unused,371,unused,"					xerrx(EXIT_FAILURE, ""ERROR: %s %s"",
					      _(""inconsistent detail field in smaps file, line:\n""),
					      mapbuf);
			}
			strcpy(listnode->value_str, value_str);
",unused,oldversionprocps-pmap.c
"	 */
	int maxcmd = 0xfffff;

	if (x_option || X_option || c_option) {
		sprintf(buf, ""/proc/%u/smaps"", p->tgid);
",1,unused,537,unused,"	 */
	int maxcmd = 0xfffff;

	if (x_option || X_option || c_option) {
		sprintf(buf, ""/proc/%u/smaps"", p->tgid);
",unused,oldversionprocps-pmap.c
"		sprintf(buf, ""/proc/%u/smaps"", p->tgid);
		if ((fp = fopen(buf, ""r"")) == NULL)
			return 1;
	} else {
		sprintf(buf, ""/proc/%u/maps"", p->tgid);
",1,unused,541,unused,"		sprintf(buf, ""/proc/%u/smaps"", p->tgid);
		if ((fp = fopen(buf, ""r"")) == NULL)
			return 1;
	} else {
		sprintf(buf, ""/proc/%u/maps"", p->tgid);
",unused,oldversionprocps-pmap.c
"        if (!p) {
            xalloc_err_handler(""%s failed to allocate %u bytes of memory"", __func__, size);
            exit(EXIT_FAILURE);
        }
        strcpy(p, str);
",1,unused,89,unused,"        if (!p) {
            xalloc_err_handler(""%s failed to allocate %u bytes of memory"", __func__, size);
            exit(EXIT_FAILURE);
        }
        strcpy(p, str);
",unused,oldversionprocps-proc2Falloc.c
"    if(!tmn) return 0;
    if(tmn->major_number == maj && tmn->minor_first <= min && tmn->minor_last >= min) break;
    tmn = tmn->next;
  }
  sprintf(buf, ""/dev/%s%d"", tmn->name, min);  /* like ""/dev/ttyZZ255"" */
",1,unused,134,unused,"    if(!tmn) return 0;
    if(tmn->major_number == maj && tmn->minor_first <= min && tmn->minor_last >= min) break;
    tmn = tmn->next;
  }
  sprintf(buf, ""/dev/%s%d"", tmn->name, min);  /* like ""/dev/ttyZZ255"" */
",unused,oldversionprocps-proc2Fdevname.c
"  }
  sprintf(buf, ""/dev/%s%d"", tmn->name, min);  /* like ""/dev/ttyZZ255"" */
  if(stat(buf, &sbuf) < 0){
    if(tmn->devfs_type) return 0;
    sprintf(buf, ""/dev/%s"", tmn->name);  /* like ""/dev/ttyZZ255"" */
",1,unused,137,unused,"  }
  sprintf(buf, ""/dev/%s%d"", tmn->name, min);  /* like ""/dev/ttyZZ255"" */
  if(stat(buf, &sbuf) < 0){
    if(tmn->devfs_type) return 0;
    sprintf(buf, ""/dev/%s"", tmn->name);  /* like ""/dev/ttyZZ255"" */
",unused,oldversionprocps-proc2Fdevname.c
"  case   3:      /* /dev/[pt]ty[p-za-o][0-9a-z] is 936 */
    if(tmpmin > 255) return 0;   // should never happen; array index protection
    t0 = ""pqrstuvwxyzabcde""[tmpmin>>4];
    t1 = ""0123456789abcdef""[tmpmin&0x0f];
    sprintf(buf, ""/dev/tty%c%c"", t0, t1);
",1,unused,211,unused,"  case   3:      /* /dev/[pt]ty[p-za-o][0-9a-z] is 936 */
    if(tmpmin > 255) return 0;   // should never happen; array index protection
    t0 = ""pqrstuvwxyzabcde""[tmpmin>>4];
    t1 = ""0123456789abcdef""[tmpmin&0x0f];
    sprintf(buf, ""/dev/tty%c%c"", t0, t1);
",unused,oldversionprocps-proc2Fdevname.c
"    sprintf(buf, ""/dev/tty%c%c"", t0, t1);
    break;
  case   4:
    if(min<64){
      sprintf(buf, ""/dev/tty%d"", min);
",1,unused,215,unused,"    sprintf(buf, ""/dev/tty%c%c"", t0, t1);
    break;
  case   4:
    if(min<64){
      sprintf(buf, ""/dev/tty%d"", min);
",unused,oldversionprocps-proc2Fdevname.c
"    if(min<64){
      sprintf(buf, ""/dev/tty%d"", min);
      break;
    }
    sprintf(buf, ""/dev/ttyS%d"", min-64);
",1,unused,218,unused,"    if(min<64){
      sprintf(buf, ""/dev/tty%d"", min);
      break;
    }
    sprintf(buf, ""/dev/ttyS%d"", min-64);
",unused,oldversionprocps-proc2Fdevname.c
"      break;
    }
    sprintf(buf, ""/dev/ttyS%d"", min-64);
    break;
  case  11:  sprintf(buf, ""/dev/ttyB%d"",  min); break;
",1,unused,220,unused,"      break;
    }
    sprintf(buf, ""/dev/ttyS%d"", min-64);
    break;
  case  11:  sprintf(buf, ""/dev/ttyB%d"",  min); break;
",unused,oldversionprocps-proc2Fdevname.c
"    }
    sprintf(buf, ""/dev/ttyS%d"", min-64);
    break;
  case  11:  sprintf(buf, ""/dev/ttyB%d"",  min); break;
  case  17:  sprintf(buf, ""/dev/ttyH%d"",  min); break;
",1,unused,221,unused,"    }
    sprintf(buf, ""/dev/ttyS%d"", min-64);
    break;
  case  11:  sprintf(buf, ""/dev/ttyB%d"",  min); break;
  case  17:  sprintf(buf, ""/dev/ttyH%d"",  min); break;
",unused,oldversionprocps-proc2Fdevname.c
"    sprintf(buf, ""/dev/ttyS%d"", min-64);
    break;
  case  11:  sprintf(buf, ""/dev/ttyB%d"",  min); break;
  case  17:  sprintf(buf, ""/dev/ttyH%d"",  min); break;
  case  19:  sprintf(buf, ""/dev/ttyC%d"",  min); break;
",1,unused,222,unused,"    sprintf(buf, ""/dev/ttyS%d"", min-64);
    break;
  case  11:  sprintf(buf, ""/dev/ttyB%d"",  min); break;
  case  17:  sprintf(buf, ""/dev/ttyH%d"",  min); break;
  case  19:  sprintf(buf, ""/dev/ttyC%d"",  min); break;
",unused,oldversionprocps-proc2Fdevname.c
"    break;
  case  11:  sprintf(buf, ""/dev/ttyB%d"",  min); break;
  case  17:  sprintf(buf, ""/dev/ttyH%d"",  min); break;
  case  19:  sprintf(buf, ""/dev/ttyC%d"",  min); break;
  case  22:  sprintf(buf, ""/dev/ttyD%d"",  min); break; /* devices.txt */
",1,unused,223,unused,"    break;
  case  11:  sprintf(buf, ""/dev/ttyB%d"",  min); break;
  case  17:  sprintf(buf, ""/dev/ttyH%d"",  min); break;
  case  19:  sprintf(buf, ""/dev/ttyC%d"",  min); break;
  case  22:  sprintf(buf, ""/dev/ttyD%d"",  min); break; /* devices.txt */
",unused,oldversionprocps-proc2Fdevname.c
"  case  11:  sprintf(buf, ""/dev/ttyB%d"",  min); break;
  case  17:  sprintf(buf, ""/dev/ttyH%d"",  min); break;
  case  19:  sprintf(buf, ""/dev/ttyC%d"",  min); break;
  case  22:  sprintf(buf, ""/dev/ttyD%d"",  min); break; /* devices.txt */
  case  23:  sprintf(buf, ""/dev/ttyD%d"",  min); break; /* driver code */
",1,unused,224,unused,"  case  11:  sprintf(buf, ""/dev/ttyB%d"",  min); break;
  case  17:  sprintf(buf, ""/dev/ttyH%d"",  min); break;
  case  19:  sprintf(buf, ""/dev/ttyC%d"",  min); break;
  case  22:  sprintf(buf, ""/dev/ttyD%d"",  min); break; /* devices.txt */
  case  23:  sprintf(buf, ""/dev/ttyD%d"",  min); break; /* driver code */
",unused,oldversionprocps-proc2Fdevname.c
"  case  17:  sprintf(buf, ""/dev/ttyH%d"",  min); break;
  case  19:  sprintf(buf, ""/dev/ttyC%d"",  min); break;
  case  22:  sprintf(buf, ""/dev/ttyD%d"",  min); break; /* devices.txt */
  case  23:  sprintf(buf, ""/dev/ttyD%d"",  min); break; /* driver code */
  case  24:  sprintf(buf, ""/dev/ttyE%d"",  min); break;
",1,unused,225,unused,"  case  17:  sprintf(buf, ""/dev/ttyH%d"",  min); break;
  case  19:  sprintf(buf, ""/dev/ttyC%d"",  min); break;
  case  22:  sprintf(buf, ""/dev/ttyD%d"",  min); break; /* devices.txt */
  case  23:  sprintf(buf, ""/dev/ttyD%d"",  min); break; /* driver code */
  case  24:  sprintf(buf, ""/dev/ttyE%d"",  min); break;
",unused,oldversionprocps-proc2Fdevname.c
"  case  19:  sprintf(buf, ""/dev/ttyC%d"",  min); break;
  case  22:  sprintf(buf, ""/dev/ttyD%d"",  min); break; /* devices.txt */
  case  23:  sprintf(buf, ""/dev/ttyD%d"",  min); break; /* driver code */
  case  24:  sprintf(buf, ""/dev/ttyE%d"",  min); break;
  case  32:  sprintf(buf, ""/dev/ttyX%d"",  min); break;
",1,unused,226,unused,"  case  19:  sprintf(buf, ""/dev/ttyC%d"",  min); break;
  case  22:  sprintf(buf, ""/dev/ttyD%d"",  min); break; /* devices.txt */
  case  23:  sprintf(buf, ""/dev/ttyD%d"",  min); break; /* driver code */
  case  24:  sprintf(buf, ""/dev/ttyE%d"",  min); break;
  case  32:  sprintf(buf, ""/dev/ttyX%d"",  min); break;
",unused,oldversionprocps-proc2Fdevname.c
"  case  22:  sprintf(buf, ""/dev/ttyD%d"",  min); break; /* devices.txt */
  case  23:  sprintf(buf, ""/dev/ttyD%d"",  min); break; /* driver code */
  case  24:  sprintf(buf, ""/dev/ttyE%d"",  min); break;
  case  32:  sprintf(buf, ""/dev/ttyX%d"",  min); break;
  case  43:  sprintf(buf, ""/dev/ttyI%d"",  min); break;
",1,unused,227,unused,"  case  22:  sprintf(buf, ""/dev/ttyD%d"",  min); break; /* devices.txt */
  case  23:  sprintf(buf, ""/dev/ttyD%d"",  min); break; /* driver code */
  case  24:  sprintf(buf, ""/dev/ttyE%d"",  min); break;
  case  32:  sprintf(buf, ""/dev/ttyX%d"",  min); break;
  case  43:  sprintf(buf, ""/dev/ttyI%d"",  min); break;
",unused,oldversionprocps-proc2Fdevname.c
"  case  23:  sprintf(buf, ""/dev/ttyD%d"",  min); break; /* driver code */
  case  24:  sprintf(buf, ""/dev/ttyE%d"",  min); break;
  case  32:  sprintf(buf, ""/dev/ttyX%d"",  min); break;
  case  43:  sprintf(buf, ""/dev/ttyI%d"",  min); break;
  case  46:  sprintf(buf, ""/dev/ttyR%d"",  min); break;
",1,unused,228,unused,"  case  23:  sprintf(buf, ""/dev/ttyD%d"",  min); break; /* driver code */
  case  24:  sprintf(buf, ""/dev/ttyE%d"",  min); break;
  case  32:  sprintf(buf, ""/dev/ttyX%d"",  min); break;
  case  43:  sprintf(buf, ""/dev/ttyI%d"",  min); break;
  case  46:  sprintf(buf, ""/dev/ttyR%d"",  min); break;
",unused,oldversionprocps-proc2Fdevname.c
"  case  24:  sprintf(buf, ""/dev/ttyE%d"",  min); break;
  case  32:  sprintf(buf, ""/dev/ttyX%d"",  min); break;
  case  43:  sprintf(buf, ""/dev/ttyI%d"",  min); break;
  case  46:  sprintf(buf, ""/dev/ttyR%d"",  min); break;
  case  48:  sprintf(buf, ""/dev/ttyL%d"",  min); break;
",1,unused,229,unused,"  case  24:  sprintf(buf, ""/dev/ttyE%d"",  min); break;
  case  32:  sprintf(buf, ""/dev/ttyX%d"",  min); break;
  case  43:  sprintf(buf, ""/dev/ttyI%d"",  min); break;
  case  46:  sprintf(buf, ""/dev/ttyR%d"",  min); break;
  case  48:  sprintf(buf, ""/dev/ttyL%d"",  min); break;
",unused,oldversionprocps-proc2Fdevname.c
"  case  32:  sprintf(buf, ""/dev/ttyX%d"",  min); break;
  case  43:  sprintf(buf, ""/dev/ttyI%d"",  min); break;
  case  46:  sprintf(buf, ""/dev/ttyR%d"",  min); break;
  case  48:  sprintf(buf, ""/dev/ttyL%d"",  min); break;
  case  57:  sprintf(buf, ""/dev/ttyP%d"",  min); break;
",1,unused,230,unused,"  case  32:  sprintf(buf, ""/dev/ttyX%d"",  min); break;
  case  43:  sprintf(buf, ""/dev/ttyI%d"",  min); break;
  case  46:  sprintf(buf, ""/dev/ttyR%d"",  min); break;
  case  48:  sprintf(buf, ""/dev/ttyL%d"",  min); break;
  case  57:  sprintf(buf, ""/dev/ttyP%d"",  min); break;
",unused,oldversionprocps-proc2Fdevname.c
"  case  43:  sprintf(buf, ""/dev/ttyI%d"",  min); break;
  case  46:  sprintf(buf, ""/dev/ttyR%d"",  min); break;
  case  48:  sprintf(buf, ""/dev/ttyL%d"",  min); break;
  case  57:  sprintf(buf, ""/dev/ttyP%d"",  min); break;
  case  71:  sprintf(buf, ""/dev/ttyF%d"",  min); break;
",1,unused,231,unused,"  case  43:  sprintf(buf, ""/dev/ttyI%d"",  min); break;
  case  46:  sprintf(buf, ""/dev/ttyR%d"",  min); break;
  case  48:  sprintf(buf, ""/dev/ttyL%d"",  min); break;
  case  57:  sprintf(buf, ""/dev/ttyP%d"",  min); break;
  case  71:  sprintf(buf, ""/dev/ttyF%d"",  min); break;
",unused,oldversionprocps-proc2Fdevname.c
"  case  46:  sprintf(buf, ""/dev/ttyR%d"",  min); break;
  case  48:  sprintf(buf, ""/dev/ttyL%d"",  min); break;
  case  57:  sprintf(buf, ""/dev/ttyP%d"",  min); break;
  case  71:  sprintf(buf, ""/dev/ttyF%d"",  min); break;
  case  75:  sprintf(buf, ""/dev/ttyW%d"",  min); break;
",1,unused,232,unused,"  case  46:  sprintf(buf, ""/dev/ttyR%d"",  min); break;
  case  48:  sprintf(buf, ""/dev/ttyL%d"",  min); break;
  case  57:  sprintf(buf, ""/dev/ttyP%d"",  min); break;
  case  71:  sprintf(buf, ""/dev/ttyF%d"",  min); break;
  case  75:  sprintf(buf, ""/dev/ttyW%d"",  min); break;
",unused,oldversionprocps-proc2Fdevname.c
"  case  48:  sprintf(buf, ""/dev/ttyL%d"",  min); break;
  case  57:  sprintf(buf, ""/dev/ttyP%d"",  min); break;
  case  71:  sprintf(buf, ""/dev/ttyF%d"",  min); break;
  case  75:  sprintf(buf, ""/dev/ttyW%d"",  min); break;
  case  78:  sprintf(buf, ""/dev/ttyM%d"",  min); break; /* conflict */
",1,unused,233,unused,"  case  48:  sprintf(buf, ""/dev/ttyL%d"",  min); break;
  case  57:  sprintf(buf, ""/dev/ttyP%d"",  min); break;
  case  71:  sprintf(buf, ""/dev/ttyF%d"",  min); break;
  case  75:  sprintf(buf, ""/dev/ttyW%d"",  min); break;
  case  78:  sprintf(buf, ""/dev/ttyM%d"",  min); break; /* conflict */
",unused,oldversionprocps-proc2Fdevname.c
"  case  57:  sprintf(buf, ""/dev/ttyP%d"",  min); break;
  case  71:  sprintf(buf, ""/dev/ttyF%d"",  min); break;
  case  75:  sprintf(buf, ""/dev/ttyW%d"",  min); break;
  case  78:  sprintf(buf, ""/dev/ttyM%d"",  min); break; /* conflict */
  case 105:  sprintf(buf, ""/dev/ttyV%d"",  min); break;
",1,unused,234,unused,"  case  57:  sprintf(buf, ""/dev/ttyP%d"",  min); break;
  case  71:  sprintf(buf, ""/dev/ttyF%d"",  min); break;
  case  75:  sprintf(buf, ""/dev/ttyW%d"",  min); break;
  case  78:  sprintf(buf, ""/dev/ttyM%d"",  min); break; /* conflict */
  case 105:  sprintf(buf, ""/dev/ttyV%d"",  min); break;
",unused,oldversionprocps-proc2Fdevname.c
"  case  71:  sprintf(buf, ""/dev/ttyF%d"",  min); break;
  case  75:  sprintf(buf, ""/dev/ttyW%d"",  min); break;
  case  78:  sprintf(buf, ""/dev/ttyM%d"",  min); break; /* conflict */
  case 105:  sprintf(buf, ""/dev/ttyV%d"",  min); break;
  case 112:  sprintf(buf, ""/dev/ttyM%d"",  min); break; /* conflict */
",1,unused,235,unused,"  case  71:  sprintf(buf, ""/dev/ttyF%d"",  min); break;
  case  75:  sprintf(buf, ""/dev/ttyW%d"",  min); break;
  case  78:  sprintf(buf, ""/dev/ttyM%d"",  min); break; /* conflict */
  case 105:  sprintf(buf, ""/dev/ttyV%d"",  min); break;
  case 112:  sprintf(buf, ""/dev/ttyM%d"",  min); break; /* conflict */
",unused,oldversionprocps-proc2Fdevname.c
"  case  78:  sprintf(buf, ""/dev/ttyM%d"",  min); break; /* conflict */
  case 105:  sprintf(buf, ""/dev/ttyV%d"",  min); break;
  case 112:  sprintf(buf, ""/dev/ttyM%d"",  min); break; /* conflict */
  /* 136 ... 143 are /dev/pts/0, /dev/pts/1, /dev/pts/2 ... */
  case 136 ... 143:  sprintf(buf, ""/dev/pts/%d"",  min+(maj-136)*256); break;
",1,unused,237,unused,"  case  78:  sprintf(buf, ""/dev/ttyM%d"",  min); break; /* conflict */
  case 105:  sprintf(buf, ""/dev/ttyV%d"",  min); break;
  case 112:  sprintf(buf, ""/dev/ttyM%d"",  min); break; /* conflict */
  /* 136 ... 143 are /dev/pts/0, /dev/pts/1, /dev/pts/2 ... */
  case 136 ... 143:  sprintf(buf, ""/dev/pts/%d"",  min+(maj-136)*256); break;
",unused,oldversionprocps-proc2Fdevname.c
"  case 105:  sprintf(buf, ""/dev/ttyV%d"",  min); break;
  case 112:  sprintf(buf, ""/dev/ttyM%d"",  min); break; /* conflict */
  /* 136 ... 143 are /dev/pts/0, /dev/pts/1, /dev/pts/2 ... */
  case 136 ... 143:  sprintf(buf, ""/dev/pts/%d"",  min+(maj-136)*256); break;
  case 148:  sprintf(buf, ""/dev/ttyT%d"",  min); break;
",1,unused,238,unused,"  case 105:  sprintf(buf, ""/dev/ttyV%d"",  min); break;
  case 112:  sprintf(buf, ""/dev/ttyM%d"",  min); break; /* conflict */
  /* 136 ... 143 are /dev/pts/0, /dev/pts/1, /dev/pts/2 ... */
  case 136 ... 143:  sprintf(buf, ""/dev/pts/%d"",  min+(maj-136)*256); break;
  case 148:  sprintf(buf, ""/dev/ttyT%d"",  min); break;
",unused,oldversionprocps-proc2Fdevname.c
"  case 112:  sprintf(buf, ""/dev/ttyM%d"",  min); break; /* conflict */
  /* 136 ... 143 are /dev/pts/0, /dev/pts/1, /dev/pts/2 ... */
  case 136 ... 143:  sprintf(buf, ""/dev/pts/%d"",  min+(maj-136)*256); break;
  case 148:  sprintf(buf, ""/dev/ttyT%d"",  min); break;
  case 154:  sprintf(buf, ""/dev/ttySR%d"", min); break;
",1,unused,239,unused,"  case 112:  sprintf(buf, ""/dev/ttyM%d"",  min); break; /* conflict */
  /* 136 ... 143 are /dev/pts/0, /dev/pts/1, /dev/pts/2 ... */
  case 136 ... 143:  sprintf(buf, ""/dev/pts/%d"",  min+(maj-136)*256); break;
  case 148:  sprintf(buf, ""/dev/ttyT%d"",  min); break;
  case 154:  sprintf(buf, ""/dev/ttySR%d"", min); break;
",unused,oldversionprocps-proc2Fdevname.c
"  /* 136 ... 143 are /dev/pts/0, /dev/pts/1, /dev/pts/2 ... */
  case 136 ... 143:  sprintf(buf, ""/dev/pts/%d"",  min+(maj-136)*256); break;
  case 148:  sprintf(buf, ""/dev/ttyT%d"",  min); break;
  case 154:  sprintf(buf, ""/dev/ttySR%d"", min); break;
  case 156:  sprintf(buf, ""/dev/ttySR%d"", min+256); break;
",1,unused,240,unused,"  /* 136 ... 143 are /dev/pts/0, /dev/pts/1, /dev/pts/2 ... */
  case 136 ... 143:  sprintf(buf, ""/dev/pts/%d"",  min+(maj-136)*256); break;
  case 148:  sprintf(buf, ""/dev/ttyT%d"",  min); break;
  case 154:  sprintf(buf, ""/dev/ttySR%d"", min); break;
  case 156:  sprintf(buf, ""/dev/ttySR%d"", min+256); break;
",unused,oldversionprocps-proc2Fdevname.c
"  case 136 ... 143:  sprintf(buf, ""/dev/pts/%d"",  min+(maj-136)*256); break;
  case 148:  sprintf(buf, ""/dev/ttyT%d"",  min); break;
  case 154:  sprintf(buf, ""/dev/ttySR%d"", min); break;
  case 156:  sprintf(buf, ""/dev/ttySR%d"", min+256); break;
  case 164:  sprintf(buf, ""/dev/ttyCH%d"",  min); break;
",1,unused,241,unused,"  case 136 ... 143:  sprintf(buf, ""/dev/pts/%d"",  min+(maj-136)*256); break;
  case 148:  sprintf(buf, ""/dev/ttyT%d"",  min); break;
  case 154:  sprintf(buf, ""/dev/ttySR%d"", min); break;
  case 156:  sprintf(buf, ""/dev/ttySR%d"", min+256); break;
  case 164:  sprintf(buf, ""/dev/ttyCH%d"",  min); break;
",unused,oldversionprocps-proc2Fdevname.c
"  case 148:  sprintf(buf, ""/dev/ttyT%d"",  min); break;
  case 154:  sprintf(buf, ""/dev/ttySR%d"", min); break;
  case 156:  sprintf(buf, ""/dev/ttySR%d"", min+256); break;
  case 164:  sprintf(buf, ""/dev/ttyCH%d"",  min); break;
  case 166:  sprintf(buf, ""/dev/ttyACM%d"", min); break; /* bummer, 9-char */
",1,unused,242,unused,"  case 148:  sprintf(buf, ""/dev/ttyT%d"",  min); break;
  case 154:  sprintf(buf, ""/dev/ttySR%d"", min); break;
  case 156:  sprintf(buf, ""/dev/ttySR%d"", min+256); break;
  case 164:  sprintf(buf, ""/dev/ttyCH%d"",  min); break;
  case 166:  sprintf(buf, ""/dev/ttyACM%d"", min); break; /* bummer, 9-char */
",unused,oldversionprocps-proc2Fdevname.c
"  case 154:  sprintf(buf, ""/dev/ttySR%d"", min); break;
  case 156:  sprintf(buf, ""/dev/ttySR%d"", min+256); break;
  case 164:  sprintf(buf, ""/dev/ttyCH%d"",  min); break;
  case 166:  sprintf(buf, ""/dev/ttyACM%d"", min); break; /* bummer, 9-char */
  case 172:  sprintf(buf, ""/dev/ttyMX%d"",  min); break;
",1,unused,243,unused,"  case 154:  sprintf(buf, ""/dev/ttySR%d"", min); break;
  case 156:  sprintf(buf, ""/dev/ttySR%d"", min+256); break;
  case 164:  sprintf(buf, ""/dev/ttyCH%d"",  min); break;
  case 166:  sprintf(buf, ""/dev/ttyACM%d"", min); break; /* bummer, 9-char */
  case 172:  sprintf(buf, ""/dev/ttyMX%d"",  min); break;
",unused,oldversionprocps-proc2Fdevname.c
"  case 156:  sprintf(buf, ""/dev/ttySR%d"", min+256); break;
  case 164:  sprintf(buf, ""/dev/ttyCH%d"",  min); break;
  case 166:  sprintf(buf, ""/dev/ttyACM%d"", min); break; /* bummer, 9-char */
  case 172:  sprintf(buf, ""/dev/ttyMX%d"",  min); break;
  case 174:  sprintf(buf, ""/dev/ttySI%d"",  min); break;
",1,unused,244,unused,"  case 156:  sprintf(buf, ""/dev/ttySR%d"", min+256); break;
  case 164:  sprintf(buf, ""/dev/ttyCH%d"",  min); break;
  case 166:  sprintf(buf, ""/dev/ttyACM%d"", min); break; /* bummer, 9-char */
  case 172:  sprintf(buf, ""/dev/ttyMX%d"",  min); break;
  case 174:  sprintf(buf, ""/dev/ttySI%d"",  min); break;
",unused,oldversionprocps-proc2Fdevname.c
"  case 164:  sprintf(buf, ""/dev/ttyCH%d"",  min); break;
  case 166:  sprintf(buf, ""/dev/ttyACM%d"", min); break; /* bummer, 9-char */
  case 172:  sprintf(buf, ""/dev/ttyMX%d"",  min); break;
  case 174:  sprintf(buf, ""/dev/ttySI%d"",  min); break;
  case 188:  sprintf(buf, ""/dev/ttyUSB%d"", min); break; /* bummer, 9-char */
",1,unused,245,unused,"  case 164:  sprintf(buf, ""/dev/ttyCH%d"",  min); break;
  case 166:  sprintf(buf, ""/dev/ttyACM%d"", min); break; /* bummer, 9-char */
  case 172:  sprintf(buf, ""/dev/ttyMX%d"",  min); break;
  case 174:  sprintf(buf, ""/dev/ttySI%d"",  min); break;
  case 188:  sprintf(buf, ""/dev/ttyUSB%d"", min); break; /* bummer, 9-char */
",unused,oldversionprocps-proc2Fdevname.c
"    memcpy(buf+8, low_density_names[min], sizeof low_density_names[0]);
    buf[8 + sizeof low_density_names[0]] = '\0';
//    snprintf(buf, 9 + sizeof low_density_names[0], ""/dev/tty%.*s"", sizeof low_density_names[0], low_density_names[min]);
    break;
  case 208:  sprintf(buf, ""/dev/ttyU%d"",  min); break;
",1,unused,253,unused,"    memcpy(buf+8, low_density_names[min], sizeof low_density_names[0]);
    buf[8 + sizeof low_density_names[0]] = '\0';
//    snprintf(buf, 9 + sizeof low_density_names[0], ""/dev/tty%.*s"", sizeof low_density_names[0], low_density_names[min]);
    break;
  case 208:  sprintf(buf, ""/dev/ttyU%d"",  min); break;
",unused,oldversionprocps-proc2Fdevname.c
"    buf[8 + sizeof low_density_names[0]] = '\0';
//    snprintf(buf, 9 + sizeof low_density_names[0], ""/dev/tty%.*s"", sizeof low_density_names[0], low_density_names[min]);
    break;
  case 208:  sprintf(buf, ""/dev/ttyU%d"",  min); break;
  case 216:  sprintf(buf, ""/dev/ttyUB%d"",  min); break; // ""/dev/rfcomm%d"" now?
",1,unused,254,unused,"    buf[8 + sizeof low_density_names[0]] = '\0';
//    snprintf(buf, 9 + sizeof low_density_names[0], ""/dev/tty%.*s"", sizeof low_density_names[0], low_density_names[min]);
    break;
  case 208:  sprintf(buf, ""/dev/ttyU%d"",  min); break;
  case 216:  sprintf(buf, ""/dev/ttyUB%d"",  min); break; // ""/dev/rfcomm%d"" now?
",unused,oldversionprocps-proc2Fdevname.c
"//    snprintf(buf, 9 + sizeof low_density_names[0], ""/dev/tty%.*s"", sizeof low_density_names[0], low_density_names[min]);
    break;
  case 208:  sprintf(buf, ""/dev/ttyU%d"",  min); break;
  case 216:  sprintf(buf, ""/dev/ttyUB%d"",  min); break; // ""/dev/rfcomm%d"" now?
  case 224:  sprintf(buf, ""/dev/ttyY%d"",  min); break;
",1,unused,255,unused,"//    snprintf(buf, 9 + sizeof low_density_names[0], ""/dev/tty%.*s"", sizeof low_density_names[0], low_density_names[min]);
    break;
  case 208:  sprintf(buf, ""/dev/ttyU%d"",  min); break;
  case 216:  sprintf(buf, ""/dev/ttyUB%d"",  min); break; // ""/dev/rfcomm%d"" now?
  case 224:  sprintf(buf, ""/dev/ttyY%d"",  min); break;
",unused,oldversionprocps-proc2Fdevname.c
"    break;
  case 208:  sprintf(buf, ""/dev/ttyU%d"",  min); break;
  case 216:  sprintf(buf, ""/dev/ttyUB%d"",  min); break; // ""/dev/rfcomm%d"" now?
  case 224:  sprintf(buf, ""/dev/ttyY%d"",  min); break;
  case 227:  sprintf(buf, ""/dev/3270/tty%d"", min); break; /* bummer, HUGE */
",1,unused,256,unused,"    break;
  case 208:  sprintf(buf, ""/dev/ttyU%d"",  min); break;
  case 216:  sprintf(buf, ""/dev/ttyUB%d"",  min); break; // ""/dev/rfcomm%d"" now?
  case 224:  sprintf(buf, ""/dev/ttyY%d"",  min); break;
  case 227:  sprintf(buf, ""/dev/3270/tty%d"", min); break; /* bummer, HUGE */
",unused,oldversionprocps-proc2Fdevname.c
"  case 208:  sprintf(buf, ""/dev/ttyU%d"",  min); break;
  case 216:  sprintf(buf, ""/dev/ttyUB%d"",  min); break; // ""/dev/rfcomm%d"" now?
  case 224:  sprintf(buf, ""/dev/ttyY%d"",  min); break;
  case 227:  sprintf(buf, ""/dev/3270/tty%d"", min); break; /* bummer, HUGE */
  case 229:  sprintf(buf, ""/dev/iseries/vtty%d"",  min); break; /* bummer, HUGE */
",1,unused,257,unused,"  case 208:  sprintf(buf, ""/dev/ttyU%d"",  min); break;
  case 216:  sprintf(buf, ""/dev/ttyUB%d"",  min); break; // ""/dev/rfcomm%d"" now?
  case 224:  sprintf(buf, ""/dev/ttyY%d"",  min); break;
  case 227:  sprintf(buf, ""/dev/3270/tty%d"", min); break; /* bummer, HUGE */
  case 229:  sprintf(buf, ""/dev/iseries/vtty%d"",  min); break; /* bummer, HUGE */
",unused,oldversionprocps-proc2Fdevname.c
"  case 216:  sprintf(buf, ""/dev/ttyUB%d"",  min); break; // ""/dev/rfcomm%d"" now?
  case 224:  sprintf(buf, ""/dev/ttyY%d"",  min); break;
  case 227:  sprintf(buf, ""/dev/3270/tty%d"", min); break; /* bummer, HUGE */
  case 229:  sprintf(buf, ""/dev/iseries/vtty%d"",  min); break; /* bummer, HUGE */
  case 256:  sprintf(buf, ""/dev/ttyEQ%d"",  min); break;
",1,unused,258,unused,"  case 216:  sprintf(buf, ""/dev/ttyUB%d"",  min); break; // ""/dev/rfcomm%d"" now?
  case 224:  sprintf(buf, ""/dev/ttyY%d"",  min); break;
  case 227:  sprintf(buf, ""/dev/3270/tty%d"", min); break; /* bummer, HUGE */
  case 229:  sprintf(buf, ""/dev/iseries/vtty%d"",  min); break; /* bummer, HUGE */
  case 256:  sprintf(buf, ""/dev/ttyEQ%d"",  min); break;
",unused,oldversionprocps-proc2Fdevname.c
"static int link_name(char *restrict const buf, unsigned maj, unsigned min, int pid, const char *restrict name){
  struct stat sbuf;
  char path[32];
  int count;
  sprintf(path, ""/proc/%d/%s"", pid, name);  /* often permission denied */
",1,unused,275,unused,"static int link_name(char *restrict const buf, unsigned maj, unsigned min, int pid, const char *restrict name){
  struct stat sbuf;
  char path[32];
  int count;
  sprintf(path, ""/proc/%d/%s"", pid, name);  /* often permission denied */
",unused,oldversionprocps-proc2Fdevname.c
"  if( guess_name(tmp, MAJOR_OF(dev), MINOR_OF(dev)               )) goto abbrev;
  if(  link_name(tmp, MAJOR_OF(dev), MINOR_OF(dev), pid, ""fd/255"")) goto abbrev;
  // fall through if unable to find a device file
no_tty:
  strcpy(ret, ""?"");
",1,unused,299,unused,"  if( guess_name(tmp, MAJOR_OF(dev), MINOR_OF(dev)               )) goto abbrev;
  if(  link_name(tmp, MAJOR_OF(dev), MINOR_OF(dev), pid, ""fd/255"")) goto abbrev;
  // fall through if unable to find a device file
no_tty:
  strcpy(ret, ""?"");
",unused,oldversionprocps-proc2Fdevname.c
"  }
  if(sysmap_data == (caddr_t) -1) goto bad_open;
  close(fd);
  fd = -1;
  sprintf(Version, ""Version_%d"", linux_version_code);
",1,unused,370,unused,"  }
  if(sysmap_data == (caddr_t) -1) goto bad_open;
  close(fd);
  fd = -1;
  sprintf(Version, ""Version_%d"", linux_version_code);
",unused,oldversionprocps-proc2Fksym.c
"    *p = (struct pwbuf *) xmalloc(sizeof(struct pwbuf));
    (*p)->uid = uid;
    pw = getpwuid(uid);
    if(!pw || strlen(pw->pw_name) >= P_G_SZ)
	sprintf((*p)->name, ""%u"", uid);
",1,unused,58,unused,"    *p = (struct pwbuf *) xmalloc(sizeof(struct pwbuf));
    (*p)->uid = uid;
    pw = getpwuid(uid);
    if(!pw || strlen(pw->pw_name) >= P_G_SZ)
	sprintf((*p)->name, ""%u"", uid);
",unused,oldversionprocps-proc2Fpwcache.c
"    pw = getpwuid(uid);
    if(!pw || strlen(pw->pw_name) >= P_G_SZ)
	sprintf((*p)->name, ""%u"", uid);
    else
        strcpy((*p)->name, pw->pw_name);
",1,unused,60,unused,"    pw = getpwuid(uid);
    if(!pw || strlen(pw->pw_name) >= P_G_SZ)
	sprintf((*p)->name, ""%u"", uid);
    else
        strcpy((*p)->name, pw->pw_name);
",unused,oldversionprocps-proc2Fpwcache.c
"    *g = (struct grpbuf *) xmalloc(sizeof(struct grpbuf));
    (*g)->gid = gid;
    gr = getgrgid(gid);
    if (!gr || strlen(gr->gr_name) >= P_G_SZ)
        sprintf((*g)->name, ""%u"", gid);
",1,unused,86,unused,"    *g = (struct grpbuf *) xmalloc(sizeof(struct grpbuf));
    (*g)->gid = gid;
    gr = getgrgid(gid);
    if (!gr || strlen(gr->gr_name) >= P_G_SZ)
        sprintf((*g)->name, ""%u"", gid);
",unused,oldversionprocps-proc2Fpwcache.c
"    gr = getgrgid(gid);
    if (!gr || strlen(gr->gr_name) >= P_G_SZ)
        sprintf((*g)->name, ""%u"", gid);
    else
        strcpy((*g)->name, gr->gr_name);
",1,unused,88,unused,"    gr = getgrgid(gid);
    if (!gr || strlen(gr->gr_name) >= P_G_SZ)
        sprintf((*g)->name, ""%u"", gid);
    else
        strcpy((*g)->name, gr->gr_name);
",unused,oldversionprocps-proc2Fpwcache.c
"       buffer will likely soon be used for another subdirectory anyway
       ( besides, with this xcalloc we will never need to use memcpy ) */
    if (ub->buf) ub->buf[0] = '\0';
    else ub->buf = xcalloc((ub->siz = buffGRW));
    sprintf(path, ""%s/%s"", directory, what);
",1,unused,633,unused,"       buffer will likely soon be used for another subdirectory anyway
       ( besides, with this xcalloc we will never need to use memcpy ) */
    if (ub->buf) ub->buf[0] = '\0';
    else ub->buf = xcalloc((ub->siz = buffGRW));
    sprintf(path, ""%s/%s"", directory, what);
",unused,oldversionprocps-proc2Freadproc.c
"    char *p, *rbuf = 0, *endbuf, **q, **ret;
    int fd, tot = 0, n, c, end_of_file = 0;
    int align;

    sprintf(buf, ""%s/%s"", directory, what);
",1,unused,653,unused,"    char *p, *rbuf = 0, *endbuf, **q, **ret;
    int fd, tot = 0, n, c, end_of_file = 0;
    int align;

    sprintf(buf, ""%s/%s"", directory, what);
",unused,oldversionprocps-proc2Freadproc.c
"  }
  p->tgid = strtoul(ent->d_name, NULL, 10);
  p->tid = p->tgid;
  memcpy(path, ""/proc/"", 6);
  strcpy(path+6, ent->d_name);  // trust /proc to not contain evil top-level entries
",1,unused,1112,unused,"  }
  p->tgid = strtoul(ent->d_name, NULL, 10);
  p->tid = p->tgid;
  memcpy(path, ""/proc/"", 6);
  strcpy(path+6, ent->d_name);  // trust /proc to not contain evil top-level entries
",unused,oldversionprocps-proc2Freadproc.c
"    struct utlbuf_s ub = { NULL, 0 };
    static char path[32];
    struct stat statbuf;

    sprintf(path, ""/proc/%d"", pid);
",1,unused,1523,unused,"    struct utlbuf_s ub = { NULL, 0 };
    static char path[32];
    struct stat statbuf;

    sprintf(path, ""/proc/%d"", pid);
",unused,oldversionprocps-proc2Freadproc.c
"    int fd;
    char c;

    if (!isdigit(ent->d_name[0])) continue;
    sprintf(tbuf, ""/proc/%s/stat"", ent->d_name);
",1,unused,417,unused,"    int fd;
    char c;

    if (!isdigit(ent->d_name[0])) continue;
    sprintf(tbuf, ""/proc/%s/stat"", ent->d_name);
",unused,oldversionprocps-proc2Fsysinfo.c
"    if(strlen(head) >= sizeof(namebuf)){
      head = tail+1;
      goto nextline;
    }
    strcpy(namebuf,head);
",1,unused,687,unused,"    if(strlen(head) >= sizeof(namebuf)){
      head = tail+1;
      goto nextline;
    }
    strcpy(namebuf,head);
",unused,oldversionprocps-proc2Fsysinfo.c
"    if(strlen(head) >= sizeof(namebuf)){
      head = tail+1;
      goto nextline;
    }
    strcpy(namebuf,head);
",1,unused,874,unused,"    if(strlen(head) >= sizeof(namebuf)){
      head = tail+1;
      goto nextline;
    }
    strcpy(namebuf,head);
",unused,oldversionprocps-proc2Fsysinfo.c
"
  if (!human_readable) {
    time(&realseconds);
    realtime = localtime(&realseconds);
    pos = sprintf(buf, "" %02d:%02d:%02d "",
",1,unused,59,unused,"
  if (!human_readable) {
    time(&realseconds);
    realtime = localtime(&realseconds);
    pos = sprintf(buf, "" %02d:%02d:%02d "",
",unused,oldversionprocps-proc2Fwhattime.c
"  }
  else
    updays = (int) uptime_secs / (60*60*24);

  strcat (buf, ""up "");
",1,unused,78,unused,"  }
  else
    updays = (int) uptime_secs / (60*60*24);

  strcat (buf, ""up "");
",unused,oldversionprocps-proc2Fwhattime.c
"  pos += 3;

  if (!human_readable) {
    if (updays)
      pos += sprintf(buf + pos, ""%d day%s, "", updays, (updays != 1) ? ""s"" : """");
",1,unused,83,unused,"  pos += 3;

  if (!human_readable) {
    if (updays)
      pos += sprintf(buf + pos, ""%d day%s, "", updays, (updays != 1) ? ""s"" : """");
",unused,oldversionprocps-proc2Fwhattime.c
"  upminutes = upminutes % 60;

  if (!human_readable) {
    if(uphours)
      pos += sprintf(buf + pos, ""%2d:%02d, "", uphours, upminutes);
",1,unused,93,unused,"  upminutes = upminutes % 60;

  if (!human_readable) {
    if(uphours)
      pos += sprintf(buf + pos, ""%2d:%02d, "", uphours, upminutes);
",unused,oldversionprocps-proc2Fwhattime.c
"  if (!human_readable) {
    if(uphours)
      pos += sprintf(buf + pos, ""%2d:%02d, "", uphours, upminutes);
    else
      pos += sprintf(buf + pos, ""%d min, "", upminutes);
",1,unused,95,unused,"  if (!human_readable) {
    if(uphours)
      pos += sprintf(buf + pos, ""%2d:%02d, "", uphours, upminutes);
    else
      pos += sprintf(buf + pos, ""%d min, "", upminutes);
",unused,oldversionprocps-proc2Fwhattime.c
"        numuser++;
    }
    endutent();

    pos += sprintf(buf + pos, ""%2d user%s, "", numuser, numuser == 1 ? """" : ""s"");
",1,unused,108,unused,"        numuser++;
    }
    endutent();

    pos += sprintf(buf + pos, ""%2d user%s, "", numuser, numuser == 1 ? """" : ""s"");
",unused,oldversionprocps-proc2Fwhattime.c
"    pos += sprintf(buf + pos, ""%2d user%s, "", numuser, numuser == 1 ? """" : ""s"");

    loadavg(&av[0], &av[1], &av[2]);

    pos += sprintf(buf + pos, "" load average: %.2f, %.2f, %.2f"",
",1,unused,112,unused,"    pos += sprintf(buf + pos, ""%2d user%s, "", numuser, numuser == 1 ? """" : ""s"");

    loadavg(&av[0], &av[1], &av[2]);

    pos += sprintf(buf + pos, "" load average: %.2f, %.2f, %.2f"",
",unused,oldversionprocps-proc2Fwhattime.c
"  if (human_readable) {
    comma = 0;

    if (updecades) {
      pos += sprintf(buf + pos, ""%d %s"", updecades,
",1,unused,120,unused,"  if (human_readable) {
    comma = 0;

    if (updecades) {
      pos += sprintf(buf + pos, ""%d %s"", updecades,
",unused,oldversionprocps-proc2Fwhattime.c
"      comma += 1;
    }

    if (upyears) {
      pos += sprintf(buf + pos, ""%s%d %s"", comma > 0 ? "", "" : """", upyears,
",1,unused,126,unused,"      comma += 1;
    }

    if (upyears) {
      pos += sprintf(buf + pos, ""%s%d %s"", comma > 0 ? "", "" : """", upyears,
",unused,oldversionprocps-proc2Fwhattime.c
"      comma += 1;
    }

    if (upweeks) {
      pos += sprintf(buf + pos, ""%s%d %s"", comma > 0 ? "", "" : """", upweeks,
",1,unused,132,unused,"      comma += 1;
    }

    if (upweeks) {
      pos += sprintf(buf + pos, ""%s%d %s"", comma > 0 ? "", "" : """", upweeks,
",unused,oldversionprocps-proc2Fwhattime.c
"      comma += 1;
    }

    if (updays) {
      pos += sprintf(buf + pos, ""%s%d %s"", comma > 0 ? "", "" : """", updays,
",1,unused,138,unused,"      comma += 1;
    }

    if (updays) {
      pos += sprintf(buf + pos, ""%s%d %s"", comma > 0 ? "", "" : """", updays,
",unused,oldversionprocps-proc2Fwhattime.c
"      comma += 1;
    }

    if (uphours) {
      pos += sprintf(buf + pos, ""%s%d %s"", comma > 0 ? "", "" : """", uphours,
",1,unused,144,unused,"      comma += 1;
    }

    if (uphours) {
      pos += sprintf(buf + pos, ""%s%d %s"", comma > 0 ? "", "" : """", uphours,
",unused,oldversionprocps-proc2Fwhattime.c
"      comma += 1;
    }

    if (upminutes) {
      pos += sprintf(buf + pos, ""%s%d %s"", comma > 0 ? "", "" : """", upminutes,
",1,unused,150,unused,"      comma += 1;
    }

    if (upminutes) {
      pos += sprintf(buf + pos, ""%s%d %s"", comma > 0 ? "", "" : """", upminutes,
",unused,oldversionprocps-proc2Fwhattime.c
"  /* Arrrgh! somebody defined unix as 1 */
  if(forest_type == 'u') goto unixy;
  while(*p){
    switch(*p){
    case ' ': strcpy(q, ""    "");  break;
",1,unused,334,unused,"  /* Arrrgh! somebody defined unix as 1 */
  if(forest_type == 'u') goto unixy;
  while(*p){
    switch(*p){
    case ' ': strcpy(q, ""    "");  break;
",unused,oldversionprocps-ps2Foutput.c
"  if(forest_type == 'u') goto unixy;
  while(*p){
    switch(*p){
    case ' ': strcpy(q, ""    "");  break;
    case 'L': strcpy(q, "" \\_ ""); break;
",1,unused,335,unused,"  if(forest_type == 'u') goto unixy;
  while(*p){
    switch(*p){
    case ' ': strcpy(q, ""    "");  break;
    case 'L': strcpy(q, "" \\_ ""); break;
",unused,oldversionprocps-ps2Foutput.c
"  while(*p){
    switch(*p){
    case ' ': strcpy(q, ""    "");  break;
    case 'L': strcpy(q, "" \\_ ""); break;
    case '+': strcpy(q, "" \\_ ""); break;
",1,unused,336,unused,"  while(*p){
    switch(*p){
    case ' ': strcpy(q, ""    "");  break;
    case 'L': strcpy(q, "" \\_ ""); break;
    case '+': strcpy(q, "" \\_ ""); break;
",unused,oldversionprocps-ps2Foutput.c
"    switch(*p){
    case ' ': strcpy(q, ""    "");  break;
    case 'L': strcpy(q, "" \\_ ""); break;
    case '+': strcpy(q, "" \\_ ""); break;
    case '|': strcpy(q, "" |  "");  break;
",1,unused,337,unused,"    switch(*p){
    case ' ': strcpy(q, ""    "");  break;
    case 'L': strcpy(q, "" \\_ ""); break;
    case '+': strcpy(q, "" \\_ ""); break;
    case '|': strcpy(q, "" |  "");  break;
",unused,oldversionprocps-ps2Foutput.c
"  return q-outbuf;   /* gcc likes this here */
unixy:
  while(*p){
    switch(*p){
    case ' ': strcpy(q, ""  ""); break;
",1,unused,352,unused,"  return q-outbuf;   /* gcc likes this here */
unixy:
  while(*p){
    switch(*p){
    case ' ': strcpy(q, ""  ""); break;
",unused,oldversionprocps-ps2Foutput.c
"unixy:
  while(*p){
    switch(*p){
    case ' ': strcpy(q, ""  ""); break;
    case 'L': strcpy(q, ""  ""); break;
",1,unused,353,unused,"unixy:
  while(*p){
    switch(*p){
    case ' ': strcpy(q, ""  ""); break;
    case 'L': strcpy(q, ""  ""); break;
",unused,oldversionprocps-ps2Foutput.c
"  while(*p){
    switch(*p){
    case ' ': strcpy(q, ""  ""); break;
    case 'L': strcpy(q, ""  ""); break;
    case '+': strcpy(q, ""  ""); break;
",1,unused,354,unused,"  while(*p){
    switch(*p){
    case ' ': strcpy(q, ""  ""); break;
    case 'L': strcpy(q, ""  ""); break;
    case '+': strcpy(q, ""  ""); break;
",unused,oldversionprocps-ps2Foutput.c
"    switch(*p){
    case ' ': strcpy(q, ""  ""); break;
    case 'L': strcpy(q, ""  ""); break;
    case '+': strcpy(q, ""  ""); break;
    case '|': strcpy(q, ""  ""); break;
",1,unused,355,unused,"    switch(*p){
    case ' ': strcpy(q, ""  ""); break;
    case 'L': strcpy(q, ""  ""); break;
    case '+': strcpy(q, ""  ""); break;
    case '|': strcpy(q, ""  ""); break;
",unused,oldversionprocps-ps2Foutput.c
"  time_t seconds_ago;
  start = getbtime() + pp->start_time / Hertz;
  seconds_ago = seconds_since_1970 - start;
  if(seconds_ago < 0) seconds_ago=0;
  if(seconds_ago > 3600*24)  strcpy(outbuf, ctime(&start)+4);
",1,unused,861,unused,"  time_t seconds_ago;
  start = getbtime() + pp->start_time / Hertz;
  seconds_ago = seconds_since_1970 - start;
  if(seconds_ago < 0) seconds_ago=0;
  if(seconds_ago > 3600*24)  strcpy(outbuf, ctime(&start)+4);
",unused,oldversionprocps-ps2Foutput.c
"  start = getbtime() + pp->start_time / Hertz;
  seconds_ago = seconds_since_1970 - start;
  if(seconds_ago < 0) seconds_ago=0;
  if(seconds_ago > 3600*24)  strcpy(outbuf, ctime(&start)+4);
  else                       strcpy(outbuf, ctime(&start)+10);
",1,unused,862,unused,"  start = getbtime() + pp->start_time / Hertz;
  seconds_ago = seconds_since_1970 - start;
  if(seconds_ago < 0) seconds_ago=0;
  if(seconds_ago > 3600*24)  strcpy(outbuf, ctime(&start)+4);
  else                       strcpy(outbuf, ctime(&start)+10);
",unused,oldversionprocps-ps2Foutput.c
"//		    active_cols, max_rightward, max_leftward, actual, correct);

    /* prepare data and calculate leftpad */
    if(likely(p) && likely(fmt->pr)) amount = (*fmt->pr)(outbuf,p);
    else amount = strlen(strcpy(outbuf, fmt->name)); /* AIX or headers */
",1,unused,1991,unused,"//		    active_cols, max_rightward, max_leftward, actual, correct);

    /* prepare data and calculate leftpad */
    if(likely(p) && likely(fmt->pr)) amount = (*fmt->pr)(outbuf,p);
    else amount = strlen(strcpy(outbuf, fmt->name)); /* AIX or headers */
",unused,oldversionprocps-ps2Foutput.c
"	int i;
	if (pid == my_pid || pid == 0)
		return;
	/* pid (cmd) state ppid pgrp session tty */
	sprintf(buf, ""/proc/%d/stat"", pid);
",1,unused,180,unused,"	int i;
	if (pid == my_pid || pid == 0)
		return;
	/* pid (cmd) state ppid pgrp session tty */
	sprintf(buf, ""/proc/%d/stat"", pid);
",unused,oldversionprocps-skill.c
"	slashdot(outname, '/', '.');

	/* used to open the file */
	tmpname = xmalloc(strlen(name) + strlen(PROC_PATH) + 2);
	strcpy(tmpname, PROC_PATH);
",1,unused,182,unused,"	slashdot(outname, '/', '.');

	/* used to open the file */
	tmpname = xmalloc(strlen(name) + strlen(PROC_PATH) + 2);
	strcpy(tmpname, PROC_PATH);
",unused,oldversionprocps-sysctl.c
"
	/* used to open the file */
	tmpname = xmalloc(strlen(name) + strlen(PROC_PATH) + 2);
	strcpy(tmpname, PROC_PATH);
	strcat(tmpname, name);
",1,unused,183,unused,"
	/* used to open the file */
	tmpname = xmalloc(strlen(name) + strlen(PROC_PATH) + 2);
	strcpy(tmpname, PROC_PATH);
	strcat(tmpname, name);
",unused,oldversionprocps-sysctl.c
"			tmpdir =
			    (char *restrict) xmalloc(strlen(path) +
						     strlen(de->d_name) +
						     2);
			sprintf(tmpdir, ""%s%s"", path, de->d_name);
",1,unused,330,unused,"			tmpdir =
			    (char *restrict) xmalloc(strlen(path) +
						     strlen(de->d_name) +
						     2);
			sprintf(tmpdir, ""%s%s"", path, de->d_name);
",unused,oldversionprocps-sysctl.c
"			if (rc2 != 0) {
				xwarn(_(""cannot stat %s""), tmpdir);
			} else {
				if (S_ISDIR(ts.st_mode)) {
					strcat(tmpdir, ""/"");
",1,unused,336,unused,"			if (rc2 != 0) {
				xwarn(_(""cannot stat %s""), tmpdir);
			} else {
				if (S_ISDIR(ts.st_mode)) {
					strcat(tmpdir, ""/"");
",unused,oldversionprocps-sysctl.c
"	}

	/* used to open the file */
	tmpname = xmalloc(equals - name + 1 + strlen(PROC_PATH));
	strcpy(tmpname, PROC_PATH);
",1,unused,389,unused,"	}

	/* used to open the file */
	tmpname = xmalloc(equals - name + 1 + strlen(PROC_PATH));
	strcpy(tmpname, PROC_PATH);
",unused,oldversionprocps-sysctl.c
"			while ((*value == ' ' || *value == '\t') && *value != 0)
				value++;

			/* should NameOnly affect this? */
			sprintf(buffer, ""%s=%s"", name, value);
",1,unused,563,unused,"			while ((*value == ' ' || *value == '\t') && *value != 0)
				value++;

			/* should NameOnly affect this? */
			sprintf(buffer, ""%s=%s"", name, value);
",unused,oldversionprocps-sysctl.c
"					    strlen(de->d_name) * 2 + 2 +
					    strlen(dirs[di]) + 1);
				cfgs[ncfgs]->name =
				    (char *)cfgs[ncfgs] + sizeof(struct pair);
				strcpy(cfgs[ncfgs]->name, de->d_name);
",1,unused,635,unused,"					    strlen(de->d_name) * 2 + 2 +
					    strlen(dirs[di]) + 1);
				cfgs[ncfgs]->name =
				    (char *)cfgs[ncfgs] + sizeof(struct pair);
				strcpy(cfgs[ncfgs]->name, de->d_name);
",unused,oldversionprocps-sysctl.c
"				strcpy(cfgs[ncfgs]->name, de->d_name);
				cfgs[ncfgs]->value =
				    (char *)cfgs[ncfgs] + sizeof(struct pair) +
				    strlen(cfgs[ncfgs]->name) + 1;
				sprintf(cfgs[ncfgs]->value, ""%s/%s"", dirs[di],
",1,unused,639,unused,"				strcpy(cfgs[ncfgs]->name, de->d_name);
				cfgs[ncfgs]->value =
				    (char *)cfgs[ncfgs] + sizeof(struct pair) +
				    strlen(cfgs[ncfgs]->name) + 1;
				sprintf(cfgs[ncfgs]->value, ""%s/%s"", dirs[di],
",unused,oldversionprocps-sysctl.c
"
			for (row = nrows - 2; row >= 0; --row)
				*(screen + row * ncols + col) = ' ';
		}
		i = sprintf(screen, "" %.2f, %.2f, %.2f"", av[0], av[1], av[2]);
",1,unused,206,unused,"
			for (row = nrows - 2; row >= 0; --row)
				*(screen + row * ncols + col) = ' ';
		}
		i = sprintf(screen, "" %.2f, %.2f, %.2f"", av[0], av[1], av[2]);
",unused,oldversionprocps-tload.c
"   if (1 > totpflgs) totpflgs = 1;
   if (1 > begpflgs) begpflgs = 1;
   snprintf(tmp1, sizeof(tmp1)
      , N_fmt(SCROLL_coord_fmt), Curwin->begtask + 1, begpflgs, totpflgs);
   strcpy(tmp2, tmp1);
",1,unused,902,unused,"   if (1 > totpflgs) totpflgs = 1;
   if (1 > begpflgs) begpflgs = 1;
   snprintf(tmp1, sizeof(tmp1)
      , N_fmt(SCROLL_coord_fmt), Curwin->begtask + 1, begpflgs, totpflgs);
   strcpy(tmp2, tmp1);
",unused,oldversionprocps-top2Ftop.c
"

static char *alloc_s (const char *str) MALLOC;
static char *alloc_s (const char *str) {
   return strcpy(alloc_c(strlen(str) +1), str);
",1,unused,943,unused,"

static char *alloc_s (const char *str) MALLOC;
static char *alloc_s (const char *str) {
   return strcpy(alloc_c(strlen(str) +1), str);
",unused,oldversionprocps-top2Ftop.c
"   // now let's convert old top's more limited fields...
   j = strlen(q->rc.fieldscur);
   if (j > CVT_FLDMAX)
      return 1;
   strcpy(fields_dst, fields_src);
",1,unused,3411,unused,"   // now let's convert old top's more limited fields...
   j = strlen(q->rc.fieldscur);
   if (j > CVT_FLDMAX)
      return 1;
   strcpy(fields_dst, fields_src);
",unused,oldversionprocps-top2Ftop.c
"   // if we turned any suse only fields off, turn 'em back on OUR way...
   if (p1) FLDon(fields_dst[p1 - q->rc.fieldscur]);
   if (p2) FLDon(fields_dst[p2 - q->rc.fieldscur]);
#endif
   strcpy(q->rc.fieldscur, fields_dst);
",1,unused,3434,unused,"   // if we turned any suse only fields off, turn 'em back on OUR way...
   if (p1) FLDon(fields_dst[p1 - q->rc.fieldscur]);
   if (p2) FLDon(fields_dst[p2 - q->rc.fieldscur]);
#endif
   strcpy(q->rc.fieldscur, fields_dst);
",unused,oldversionprocps-top2Ftop.c
"
         if (!fgets(fbuf, sizeof(fbuf), fp)) break;
         lraw += strlen(fbuf) +1;
         Inspect.raw = alloc_r(Inspect.raw, lraw);
         strcat(Inspect.raw, fbuf);
",1,unused,3559,unused,"
         if (!fgets(fbuf, sizeof(fbuf), fp)) break;
         lraw += strlen(fbuf) +1;
         Inspect.raw = alloc_r(Inspect.raw, lraw);
         strcat(Inspect.raw, fbuf);
",unused,oldversionprocps-top2Ftop.c
"   Curwin->osel_1st = osel;
   Curwin->osel_tot += 1;
   if (!Curwin->osel_prt) Curwin->osel_prt = alloc_c(strlen(raw) + 3);
   else Curwin->osel_prt = alloc_r(Curwin->osel_prt, strlen(Curwin->osel_prt) + strlen(raw) + 6);
   strcat(Curwin->osel_prt, fmtmk(""%s'%s'"", (Curwin->osel_tot > 1) ? "" + "" : """", raw));
",1,unused,4317,unused,"   Curwin->osel_1st = osel;
   Curwin->osel_tot += 1;
   if (!Curwin->osel_prt) Curwin->osel_prt = alloc_c(strlen(raw) + 3);
   else Curwin->osel_prt = alloc_r(Curwin->osel_prt, strlen(Curwin->osel_prt) + strlen(raw) + 6);
   strcat(Curwin->osel_prt, fmtmk(""%s'%s'"", (Curwin->osel_tot > 1) ? "" + "" : """", raw));
",unused,oldversionprocps-top2Ftop.c
"		}
		if (ut_addr_v6[1] || ut_addr_v6[2] || ut_addr_v6[3]) {
			/* IPv6 */
			if (!inet_ntop(AF_INET6, &ut_addr_v6, buf_ipv6, sizeof(buf_ipv6))) {
				strcpy(buf, """"); /* invalid address, clean the buffer */
",1,unused,199,unused,"		}
		if (ut_addr_v6[1] || ut_addr_v6[2] || ut_addr_v6[3]) {
			/* IPv6 */
			if (!inet_ntop(AF_INET6, &ut_addr_v6, buf_ipv6, sizeof(buf_ipv6))) {
				strcpy(buf, """"); /* invalid address, clean the buffer */
",unused,oldversionprocps-w.c
"			}
		} else {
			/* IPv4 */
			if (!(ut_addr_v6[0] && inet_ntop(AF_INET, &ut_addr_v6[0], buf, sizeof(buf)))) {
				strcpy(buf, """"); /* invalid address, clean the buffer */
",1,unused,206,unused,"			}
		} else {
			/* IPv4 */
			if (!(ut_addr_v6[0] && inet_ntop(AF_INET, &ut_addr_v6[0], buf, sizeof(buf)))) {
				strcpy(buf, """"); /* invalid address, clean the buffer */
",unused,oldversionprocps-w.c
"{
    if (metrics == NULL) return out;

    for (size_t i = 0; i < cvss_metrics_component_num(metrics); ++i)
        out += sprintf(out, ""%s/"", cvss_valtab(metrics->category | i, metrics->metrics.ANY[i], NULL, NULL)->vector_str);
",1,unused,342,unused,"{
    if (metrics == NULL) return out;

    for (size_t i = 0; i < cvss_metrics_component_num(metrics); ++i)
        out += sprintf(out, ""%s/"", cvss_valtab(metrics->category | i, metrics->metrics.ANY[i], NULL, NULL)->vector_str);
",unused,openscap-src2FCVSS2Fcvss.c
"			char concat[len_cat];
			*concat = '\0';
			for (idx0 = 0; idx0 < len_subcomps; idx0++)
				if (texts[idx0])
					strcat(concat, texts[idx0]);
",1,unused,1619,unused,"			char concat[len_cat];
			*concat = '\0';
			for (idx0 = 0; idx0 < len_subcomps; idx0++)
				if (texts[idx0])
					strcat(concat, texts[idx0]);
",unused,openscap-src2FOVAL2Foval_component.c
"			char *text = oval_value_get_text(oval_value_iterator_next(values));
			if (len_delim) {
				char split[strlen(text) + 2], *split0 = split;
				*split0 = '\0';
				strcat(split0, text);
",1,unused,1766,unused,"			char *text = oval_value_get_text(oval_value_iterator_next(values));
			if (len_delim) {
				char split[strlen(text) + 2], *split0 = split;
				*split0 = '\0';
				strcat(split0, text);
",unused,openscap-src2FOVAL2Foval_component.c
"		char *newtitle = (char *)malloc(newsize * sizeof(char));
		if (newtitle == NULL)
			return;

		strcpy(newtitle, title);
",1,unused,341,unused,"		char *newtitle = (char *)malloc(newsize * sizeof(char));
		if (newtitle == NULL)
			return;

		strcpy(newtitle, title);
",unused,openscap-src2FOVAL2Foval_definition.c
"		if (newtitle == NULL)
			return;

		strcpy(newtitle, title);
		strcat(newtitle, string);
",1,unused,342,unused,"		if (newtitle == NULL)
			return;

		strcpy(newtitle, title);
		strcat(newtitle, string);
",unused,openscap-src2FOVAL2Foval_definition.c
"		if (newdescription == NULL)
			return;

		*newdescription = '\0';
		strcpy(newdescription, description);
",1,unused,364,unused,"		if (newdescription == NULL)
			return;

		*newdescription = '\0';
		strcpy(newdescription, description);
",unused,openscap-src2FOVAL2Foval_definition.c
"			return;

		*newdescription = '\0';
		strcpy(newdescription, description);
		strcat(newdescription, string);
",1,unused,365,unused,"			return;

		*newdescription = '\0';
		strcpy(newdescription, description);
		strcat(newdescription, string);
",unused,openscap-src2FOVAL2Foval_definition.c
"		return NULL;
	}
	/* We need to allocate memory also for '#' and '\0'. */
	char family_uri[strlen(schema_ns) + 1 + strlen(family_text) + 1];
	sprintf(family_uri,""%s#%s"", schema_ns, family_text);
",1,unused,424,unused,"		return NULL;
	}
	/* We need to allocate memory also for '#' and '\0'. */
	char family_uri[strlen(schema_ns) + 1 + strlen(family_text) + 1];
	sprintf(family_uri,""%s#%s"", schema_ns, family_text);
",unused,openscap-src2FOVAL2Foval_enumerations.c
"
	/* get object name */
	const char *subtype_text = oval_subtype_get_text(subtype);
	char object_name[strlen(subtype_text) + 8];
	sprintf(object_name, ""%s_object"", subtype_text);
",1,unused,405,unused,"
	/* get object name */
	const char *subtype_text = oval_subtype_get_text(subtype);
	char object_name[strlen(subtype_text) + 8];
	sprintf(object_name, ""%s_object"", subtype_text);
",unused,openscap-src2FOVAL2Foval_object.c
"	/* get state name */
	oval_subtype_t subtype = oval_state_get_subtype(state);
	const char *subtype_text = oval_subtype_get_text(subtype);
	char state_name[strlen(subtype_text) + 7];
	sprintf(state_name, ""%s_state"", subtype_text);
",1,unused,338,unused,"	/* get state name */
	oval_subtype_t subtype = oval_state_get_subtype(state);
	const char *subtype_text = oval_subtype_get_text(subtype);
	char state_name[strlen(subtype_text) + 7];
	sprintf(state_name, ""%s_state"", subtype_text);
",unused,openscap-src2FOVAL2Foval_state.c
"		if (subtype) {
			/* get item subtype */
			const char *subtype_text = oval_subtype_get_text(subtype);
			char tagname[strlen(subtype_text) + 6];
			sprintf(tagname, ""%s_item"", subtype_text);
",1,unused,261,unused,"		if (subtype) {
			/* get item subtype */
			const char *subtype_text = oval_subtype_get_text(subtype);
			char tagname[strlen(subtype_text) + 6];
			sprintf(tagname, ""%s_item"", subtype_text);
",unused,openscap-src2FOVAL2Foval_sysItem.c
"
	/* get test name */
	const char *subtype_text = oval_subtype_get_text(subtype);
	char test_name[strlen(subtype_text) + 6];
	sprintf(test_name, ""%s_test"", subtype_text);
",1,unused,456,unused,"
	/* get test name */
	const char *subtype_text = oval_subtype_get_text(subtype);
	char test_name[strlen(subtype_text) + 6];
	sprintf(test_name, ""%s_test"", subtype_text);
",unused,openscap-src2FOVAL2Foval_test.c
"			continue;
		}
		SEXP_free(pid_sexp);

		sprintf(env_file, ""/proc/%d/environ"", pid);
",1,unused,102,unused,"			continue;
		}
		SEXP_free(pid_sexp);

		sprintf(env_file, ""/proc/%d/environ"", pid);
",unused,openscap-src2FOVAL2Fprobes2Findependent2Fenvironmentvariable58.c
"                  (     suffix ? strlen(suffix)      : 0) + 2) < (sizeof base/sizeof(char)),
                 PROBE_ERANGE);

        if (relative_dn != NULL) {
                strcpy(base, relative_dn);
",1,unused,180,unused,"                  (     suffix ? strlen(suffix)      : 0) + 2) < (sizeof base/sizeof(char)),
                 PROBE_ERANGE);

        if (relative_dn != NULL) {
                strcpy(base, relative_dn);
",unused,openscap-src2FOVAL2Fprobes2Findependent2Fldap57.c
"                 PROBE_ERANGE);

        if (relative_dn != NULL) {
                strcpy(base, relative_dn);
                strcat(base, "","");
",1,unused,181,unused,"                 PROBE_ERANGE);

        if (relative_dn != NULL) {
                strcpy(base, relative_dn);
                strcat(base, "","");
",unused,openscap-src2FOVAL2Fprobes2Findependent2Fldap57.c
"
        if (relative_dn != NULL) {
                strcpy(base, relative_dn);
                strcat(base, "","");
                strcat(base, suffix);
",1,unused,182,unused,"
        if (relative_dn != NULL) {
                strcpy(base, relative_dn);
                strcat(base, "","");
                strcat(base, suffix);
",unused,openscap-src2FOVAL2Fprobes2Findependent2Fldap57.c
"                strcpy(base, relative_dn);
                strcat(base, "","");
                strcat(base, suffix);
        } else
                strcpy(base, suffix);
",1,unused,184,unused,"                strcpy(base, relative_dn);
                strcat(base, "","");
                strcat(base, suffix);
        } else
                strcpy(base, suffix);
",unused,openscap-src2FOVAL2Fprobes2Findependent2Fldap57.c
"                return (NULL);
        }

        if (strlen(subtype_name) + strlen(""_item"") < sizeof item_name) {
                strcpy(item_name, subtype_name);
",1,unused,1423,unused,"                return (NULL);
        }

        if (strlen(subtype_name) + strlen(""_item"") < sizeof item_name) {
                strcpy(item_name, subtype_name);
",unused,openscap-src2FOVAL2Fprobes2Fprobe-api.c
"        }

        if (strlen(subtype_name) + strlen(""_item"") < sizeof item_name) {
                strcpy(item_name, subtype_name);
                strcat(item_name, ""_item"");
",1,unused,1424,unused,"        }

        if (strlen(subtype_name) + strlen(""_item"") < sizeof item_name) {
                strcpy(item_name, subtype_name);
                strcat(item_name, ""_item"");
",unused,openscap-src2FOVAL2Fprobes2Fprobe-api.c
"                        while ((ofts_ent = oval_fts_read(ofts)) != NULL) {
                                assume_r(ofts_ent->path_len
                                         + ofts_ent->file_len + 2 <= PATH_MAX, PROBE_EFATAL);

                                strcpy(gconf_addr, ofts_ent->path);
",1,unused,209,unused,"                        while ((ofts_ent = oval_fts_read(ofts)) != NULL) {
                                assume_r(ofts_ent->path_len
                                         + ofts_ent->file_len + 2 <= PATH_MAX, PROBE_EFATAL);

                                strcpy(gconf_addr, ofts_ent->path);
",unused,openscap-src2FOVAL2Fprobes2Funix2Fgconf.c
"                                         + ofts_ent->file_len + 2 <= PATH_MAX, PROBE_EFATAL);

                                strcpy(gconf_addr, ofts_ent->path);
                                gconf_addr[ofts_ent->path_len] = '/';
                                strcpy(gconf_addr + ofts_ent->path_len + 1, ofts_ent->file);
",1,unused,211,unused,"                                         + ofts_ent->file_len + 2 <= PATH_MAX, PROBE_EFATAL);

                                strcpy(gconf_addr, ofts_ent->path);
                                gconf_addr[ofts_ent->path_len] = '/';
                                strcpy(gconf_addr + ofts_ent->path_len + 1, ofts_ent->file);
",unused,openscap-src2FOVAL2Fprobes2Funix2Fgconf.c
"	*mp = mac_buf;
	*tp = """";

	memset(&ifr, 0, sizeof(struct ifreq));
	strcpy(ifr.ifr_name, ifa->ifa_name);
",1,unused,87,unused,"	*mp = mac_buf;
	*tp = """";

	memset(&ifr, 0, sizeof(struct ifreq));
	strcpy(ifr.ifr_name, ifa->ifa_name);
",unused,openscap-src2FOVAL2Fprobes2Funix2Finterface.c
"						dW(""Can't open includedir: %s; %d, %s."", inclarg, errno, strerror (errno));
						break;
					}

					strcpy (pathbuf, inclarg);
",1,unused,759,unused,"						dW(""Can't open includedir: %s; %d, %s."", inclarg, errno, strerror (errno));
						break;
					}

					strcpy (pathbuf, inclarg);
",unused,openscap-src2FOVAL2Fprobes2Funix2Fxinetd.c
"							dI(""Skipping: %s"", dent.d_name);
							continue;
						}

						strcpy(pathbuf + incllen, dent.d_name);
",1,unused,790,unused,"							dI(""Skipping: %s"", dent.d_name);
							continue;
						}

						strcpy(pathbuf + incllen, dent.d_name);
",unused,openscap-src2FOVAL2Fprobes2Funix2Fxinetd.c
"		 * Add entry to the ttree for (name, protocol) -> (id) translation
		 * (in case it's not already there)
		 */
		st = NULL;
		strcpy(st_key, scur->name);
",1,unused,1130,unused,"		 * Add entry to the ttree for (name, protocol) -> (id) translation
		 * (in case it's not already there)
		 */
		st = NULL;
		strcpy(st_key, scur->name);
",unused,openscap-src2FOVAL2Fprobes2Funix2Fxinetd.c
"		 * (in case it's not already there)
		 */
		st = NULL;
		strcpy(st_key, scur->name);
		strcat(st_key, scur->protocol);
",1,unused,1131,unused,"		 * (in case it's not already there)
		 */
		st = NULL;
		strcpy(st_key, scur->name);
		strcat(st_key, scur->protocol);
",unused,openscap-src2FOVAL2Fprobes2Funix2Fxinetd.c
"
	if (strlen(name) + strlen(prot) > XICFG_STRANS_MAXKEYLEN)
		return (NULL);

	strcpy(strans_key, name);
",1,unused,1204,unused,"
	if (strlen(name) + strlen(prot) > XICFG_STRANS_MAXKEYLEN)
		return (NULL);

	strcpy(strans_key, name);
",unused,openscap-src2FOVAL2Fprobes2Funix2Fxinetd.c
"	if (strlen(name) + strlen(prot) > XICFG_STRANS_MAXKEYLEN)
		return (NULL);

	strcpy(strans_key, name);
	strcat(strans_key, prot);
",1,unused,1205,unused,"	if (strlen(name) + strlen(prot) > XICFG_STRANS_MAXKEYLEN)
		return (NULL);

	strcpy(strans_key, name);
	strcat(strans_key, prot);
",unused,openscap-src2FOVAL2Fprobes2Funix2Fxinetd.c
"	int len = strlen(""(null)"");;
	char buf[32];
	if (str)
		len = strlen(str);
	sprintf(buf, ""%%.%ds"", max);
",1,unused,465,unused,"	int len = strlen(""(null)"");;
	char buf[32];
	if (str)
		len = strlen(str);
	sprintf(buf, ""%%.%ds"", max);
",unused,openscap-src2FXCCDF2Felements.c
"
bool xccdf_target_fact_set_number(struct xccdf_target_fact *fact, xccdf_numeric val)
{
    char buff[XCCDF_NUMERIC_SIZE];
    sprintf(buff, XCCDF_NUMERIC_FORMAT, val);
",1,unused,411,unused,"
bool xccdf_target_fact_set_number(struct xccdf_target_fact *fact, xccdf_numeric val)
{
    char buff[XCCDF_NUMERIC_SIZE];
    sprintf(buff, XCCDF_NUMERIC_FORMAT, val);
",unused,openscap-src2FXCCDF2Fresult.c
"	else {
		int size = strlen(platform) + strlen(text) + 1;
		char *newtext = (char *) malloc(size * sizeof(char));
		*newtext = 0;
		strcat(newtext, platform);
",1,unused,76,unused,"	else {
		int size = strlen(platform) + strlen(text) + 1;
		char *newtext = (char *) malloc(size * sizeof(char));
		*newtext = 0;
		strcat(newtext, platform);
",unused,openscap-src2Fcommon2Felements.c
"		int size = strlen(platform) + strlen(text) + 1;
		char *newtext = (char *) malloc(size * sizeof(char));
		*newtext = 0;
		strcat(newtext, platform);
		strcat(newtext, text);
",1,unused,77,unused,"		int size = strlen(platform) + strlen(text) + 1;
		char *newtext = (char *) malloc(size * sizeof(char));
		*newtext = 0;
		strcat(newtext, platform);
		strcat(newtext, text);
",unused,openscap-src2Fcommon2Felements.c
"                BIO_printf(bio_err, ""certificate file name too long\n"");
                goto err;
            }

            strcpy(buf[2], outdir);
",1,unused,1237,unused,"                BIO_printf(bio_err, ""certificate file name too long\n"");
                goto err;
            }

            strcpy(buf[2], outdir);
",unused,openssl1-apps2Fca.c
"        if (ret == NULL)
            return (NULL);
        /* else add to cache */
        if (strlen(name) < sizeof ghbn_cache[0].name) {
            strcpy(ghbn_cache[lowi].name, name);
",1,unused,596,unused,"        if (ret == NULL)
            return (NULL);
        /* else add to cache */
        if (strlen(name) < sizeof ghbn_cache[0].name) {
            strcpy(ghbn_cache[lowi].name, name);
",unused,openssl1-apps2Fs_socket.c
"    aout = DH_compute_key(abuf, b->pub_key, a);

    BIO_puts(out, ""key1 ="");
    for (i = 0; i < aout; i++) {
        sprintf(buf, ""%02X"", abuf[i]);
",1,unused,182,unused,"    aout = DH_compute_key(abuf, b->pub_key, a);

    BIO_puts(out, ""key1 ="");
    for (i = 0; i < aout; i++) {
        sprintf(buf, ""%02X"", abuf[i]);
",unused,openssl1-crypto2Fdh2Fdhtest.c
"    bout = DH_compute_key(bbuf, a->pub_key, b);

    BIO_puts(out, ""key2 ="");
    for (i = 0; i < bout; i++) {
        sprintf(buf, ""%02X"", bbuf[i]);
",1,unused,193,unused,"    bout = DH_compute_key(bbuf, a->pub_key, b);

    BIO_puts(out, ""key2 ="");
    for (i = 0; i < bout; i++) {
        sprintf(buf, ""%02X"", bbuf[i]);
",unused,openssl1-crypto2Fdh2Fdhtest.c
"        if (!merged) {
            DSOerr(DSO_F_DLFCN_MERGER, ERR_R_MALLOC_FAILURE);
            return (NULL);
        }
        strcpy(merged, filespec1);
",1,unused,305,unused,"        if (!merged) {
            DSOerr(DSO_F_DLFCN_MERGER, ERR_R_MALLOC_FAILURE);
            return (NULL);
        }
        strcpy(merged, filespec1);
",unused,openssl1-crypto2Fdso2Fdso_dlfcn.c
"        if (!merged) {
            DSOerr(DSO_F_DLFCN_MERGER, ERR_R_MALLOC_FAILURE);
            return (NULL);
        }
        strcpy(merged, filespec2);
",1,unused,316,unused,"        if (!merged) {
            DSOerr(DSO_F_DLFCN_MERGER, ERR_R_MALLOC_FAILURE);
            return (NULL);
        }
        strcpy(merged, filespec2);
",unused,openssl1-crypto2Fdso2Fdso_dlfcn.c
"        if (!merged) {
            DSOerr(DSO_F_DLFCN_MERGER, ERR_R_MALLOC_FAILURE);
            return (NULL);
        }
        strcpy(merged, filespec2);
",1,unused,339,unused,"        if (!merged) {
            DSOerr(DSO_F_DLFCN_MERGER, ERR_R_MALLOC_FAILURE);
            return (NULL);
        }
        strcpy(merged, filespec2);
",unused,openssl1-crypto2Fdso2Fdso_dlfcn.c
"            return (NULL);
        }
        strcpy(merged, filespec2);
        merged[spec2len] = '/';
        strcpy(&merged[spec2len + 1], filespec1);
",1,unused,341,unused,"            return (NULL);
        }
        strcpy(merged, filespec2);
        merged[spec2len] = '/';
        strcpy(&merged[spec2len + 1], filespec1);
",unused,openssl1-crypto2Fdso2Fdso_dlfcn.c
"        return (NULL);
    }
    if (transform) {
        if ((DSO_flags(dso) & DSO_FLAG_NAME_TRANSLATION_EXT_ONLY) == 0)
            sprintf(translated, ""lib%s"" DSO_ext, filename);
",1,unused,375,unused,"        return (NULL);
    }
    if (transform) {
        if ((DSO_flags(dso) & DSO_FLAG_NAME_TRANSLATION_EXT_ONLY) == 0)
            sprintf(translated, ""lib%s"" DSO_ext, filename);
",unused,openssl1-crypto2Fdso2Fdso_dlfcn.c
"    if (transform) {
        if ((DSO_flags(dso) & DSO_FLAG_NAME_TRANSLATION_EXT_ONLY) == 0)
            sprintf(translated, ""lib%s"" DSO_ext, filename);
        else
            sprintf(translated, ""%s"" DSO_ext, filename);
",1,unused,377,unused,"    if (transform) {
        if ((DSO_flags(dso) & DSO_FLAG_NAME_TRANSLATION_EXT_ONLY) == 0)
            sprintf(translated, ""lib%s"" DSO_ext, filename);
        else
            sprintf(translated, ""%s"" DSO_ext, filename);
",unused,openssl1-crypto2Fdso2Fdso_dlfcn.c
"            sprintf(translated, ""lib%s"" DSO_ext, filename);
        else
            sprintf(translated, ""%s"" DSO_ext, filename);
    } else
        sprintf(translated, ""%s"", filename);
",1,unused,379,unused,"            sprintf(translated, ""lib%s"" DSO_ext, filename);
        else
            sprintf(translated, ""%s"" DSO_ext, filename);
    } else
        sprintf(translated, ""%s"", filename);
",unused,openssl1-crypto2Fdso2Fdso_dlfcn.c
"        BN_print(out, y_b);
        BIO_printf(out, ""\n"");
        BIO_printf(out, ""generated key a: "");
        for (i = 0; i < bout; i++) {
            sprintf(buf, ""%02X"", bbuf[i]);
",1,unused,274,unused,"        BN_print(out, y_b);
        BIO_printf(out, ""\n"");
        BIO_printf(out, ""generated key a: "");
        for (i = 0; i < bout; i++) {
            sprintf(buf, ""%02X"", bbuf[i]);
",unused,openssl1-crypto2Fecdh2Fecdhtest.c
"        }
        BIO_printf(out, ""\n"");
        BIO_printf(out, ""generated key b: "");
        for (i = 0; i < aout; i++) {
            sprintf(buf, ""%02X"", abuf[i]);
",1,unused,280,unused,"        }
        BIO_printf(out, ""\n"");
        BIO_printf(out, ""generated key b: "");
        for (i = 0; i < aout; i++) {
            sprintf(buf, ""%02X"", abuf[i]);
",unused,openssl1-crypto2Fecdh2Fecdhtest.c
"    } else
        printf(""Successfully added and removed to an empty list!\n"");
    printf(""About to beef up the engine-type list\n"");
    for (loop = 0; loop < 512; loop++) {
        sprintf(buf, ""id%i"", loop);
",1,unused,209,unused,"    } else
        printf(""Successfully added and removed to an empty list!\n"");
    printf(""About to beef up the engine-type list\n"");
    for (loop = 0; loop < 512; loop++) {
        sprintf(buf, ""id%i"", loop);
",unused,openssl1-crypto2Fengine2Fenginetest.c
"    printf(""About to beef up the engine-type list\n"");
    for (loop = 0; loop < 512; loop++) {
        sprintf(buf, ""id%i"", loop);
        id = BUF_strdup(buf);
        sprintf(buf, ""Fake engine type %i"", loop);
",1,unused,211,unused,"    printf(""About to beef up the engine-type list\n"");
    for (loop = 0; loop < 512; loop++) {
        sprintf(buf, ""id%i"", loop);
        id = BUF_strdup(buf);
        sprintf(buf, ""Fake engine type %i"", loop);
",unused,openssl1-crypto2Fengine2Fenginetest.c
"    unsigned int i;
    static char buf[80];

    for (i = 0; i < len; i++)
        sprintf(&(buf[i * 2]), ""%02x"", md[i]);
",1,unused,328,unused,"    unsigned int i;
    static char buf[80];

    for (i = 0; i < len; i++)
        sprintf(&(buf[i * 2]), ""%02x"", md[i]);
",unused,openssl1-crypto2Fhmac2Fhmactest.c
"    int i;
    static char buf[80];

    for (i = 0; i < MD5_DIGEST_LENGTH; i++)
        sprintf(&(buf[i * 2]), ""%02x"", md[i]);
",1,unused,135,unused,"    int i;
    static char buf[80];

    for (i = 0; i < MD5_DIGEST_LENGTH; i++)
        sprintf(&(buf[i * 2]), ""%02x"", md[i]);
",unused,openssl1-crypto2Fmd52Fmd5test.c
"
    if (ret == NULL)
        return NULL;

    strcpy(ret, str);
",1,unused,371,unused,"
    if (ret == NULL)
        return NULL;

    strcpy(ret, str);
",unused,openssl1-crypto2Fmem.c
"    int i;
    static char buf[80];

    for (i = 0; i < RIPEMD160_DIGEST_LENGTH; i++)
        sprintf(&(buf[i * 2]), ""%02x"", md[i]);
",1,unused,140,unused,"    int i;
    static char buf[80];

    for (i = 0; i < RIPEMD160_DIGEST_LENGTH; i++)
        sprintf(&(buf[i * 2]), ""%02x"", md[i]);
",unused,openssl1-crypto2Fripemd2Frmdtest.c
"    int i;
    static char buf[80];

    for (i = 0; i < SHA_DIGEST_LENGTH; i++)
        sprintf(&(buf[i * 2]), ""%02x"", md[i]);
",1,unused,171,unused,"    int i;
    static char buf[80];

    for (i = 0; i < SHA_DIGEST_LENGTH; i++)
        sprintf(&(buf[i * 2]), ""%02x"", md[i]);
",unused,openssl1-crypto2Fsha2Fsha1test.c
"        for (i = 0; i < (int)TS_FAILURE_INFO_SIZE; ++i) {
            if (ASN1_BIT_STRING_get_bit(info->failure_info,
                                        TS_failure_info[i].code)) {
                if (!first)
                    strcat(failure_text, "","");
",1,unused,526,unused,"        for (i = 0; i < (int)TS_FAILURE_INFO_SIZE; ++i) {
            if (ASN1_BIT_STRING_get_bit(info->failure_info,
                                        TS_failure_info[i].code)) {
                if (!first)
                    strcat(failure_text, "","");
",unused,openssl1-crypto2Fts2Fts_rsp_verify.c
"                if (!first)
                    strcat(failure_text, "","");
                else
                    first = 0;
                strcat(failure_text, TS_failure_info[i].text);
",1,unused,529,unused,"                if (!first)
                    strcat(failure_text, "","");
                else
                    first = 0;
                strcat(failure_text, TS_failure_info[i].text);
",unused,openssl1-crypto2Fts2Fts_rsp_verify.c
"            }
        }
    }
    if (failure_text[0] == '\0')
        strcpy(failure_text, ""unspecified"");
",1,unused,534,unused,"            }
        }
    }
    if (failure_text[0] == '\0')
        strcpy(failure_text, ""unspecified"");
",unused,openssl1-crypto2Fts2Fts_rsp_verify.c
"            oline[0] = 0;
            for (i = 0; i < 8; i++) {
                BIO_snprintf(htmp, sizeof htmp, ""%X"", p[0] << 8 | p[1]);
                p += 2;
                strcat(oline, htmp);
",1,unused,160,unused,"            oline[0] = 0;
            for (i = 0; i < 8; i++) {
                BIO_snprintf(htmp, sizeof htmp, ""%X"", p[0] << 8 | p[1]);
                p += 2;
                strcat(oline, htmp);
",unused,openssl1-crypto2Fx509v32Fv3_alt.c
"                BIO_snprintf(htmp, sizeof htmp, ""%X"", p[0] << 8 | p[1]);
                p += 2;
                strcat(oline, htmp);
                if (i != 7)
                    strcat(oline, "":"");
",1,unused,162,unused,"                BIO_snprintf(htmp, sizeof htmp, ""%X"", p[0] << 8 | p[1]);
                p += 2;
                strcat(oline, htmp);
                if (i != 7)
                    strcat(oline, "":"");
",unused,openssl1-crypto2Fx509v32Fv3_alt.c
"                --p;
            *p = '\0';
            return buf;
        }
        strcpy(p, c->name);
",1,unused,1345,unused,"                --p;
            *p = '\0';
            return buf;
        }
        strcpy(p, c->name);
",unused,openssl1-ssl2Fssl_lib.c
"    aout = DH_compute_key(abuf, b->pub_key, a);

    BIO_puts(out, ""key1 ="");
    for (i = 0; i < aout; i++) {
        sprintf(buf, ""%02X"", abuf[i]);
",1,unused,182,unused,"    aout = DH_compute_key(abuf, b->pub_key, a);

    BIO_puts(out, ""key1 ="");
    for (i = 0; i < aout; i++) {
        sprintf(buf, ""%02X"", abuf[i]);
",unused,openssl1-test2Fdhtest.c
"    bout = DH_compute_key(bbuf, a->pub_key, b);

    BIO_puts(out, ""key2 ="");
    for (i = 0; i < bout; i++) {
        sprintf(buf, ""%02X"", bbuf[i]);
",1,unused,193,unused,"    bout = DH_compute_key(bbuf, a->pub_key, b);

    BIO_puts(out, ""key2 ="");
    for (i = 0; i < bout; i++) {
        sprintf(buf, ""%02X"", bbuf[i]);
",unused,openssl1-test2Fdhtest.c
"        BN_print(out, y_b);
        BIO_printf(out, ""\n"");
        BIO_printf(out, ""generated key a: "");
        for (i = 0; i < bout; i++) {
            sprintf(buf, ""%02X"", bbuf[i]);
",1,unused,274,unused,"        BN_print(out, y_b);
        BIO_printf(out, ""\n"");
        BIO_printf(out, ""generated key a: "");
        for (i = 0; i < bout; i++) {
            sprintf(buf, ""%02X"", bbuf[i]);
",unused,openssl1-test2Fecdhtest.c
"        }
        BIO_printf(out, ""\n"");
        BIO_printf(out, ""generated key b: "");
        for (i = 0; i < aout; i++) {
            sprintf(buf, ""%02X"", abuf[i]);
",1,unused,280,unused,"        }
        BIO_printf(out, ""\n"");
        BIO_printf(out, ""generated key b: "");
        for (i = 0; i < aout; i++) {
            sprintf(buf, ""%02X"", abuf[i]);
",unused,openssl1-test2Fecdhtest.c
"    } else
        printf(""Successfully added and removed to an empty list!\n"");
    printf(""About to beef up the engine-type list\n"");
    for (loop = 0; loop < 512; loop++) {
        sprintf(buf, ""id%i"", loop);
",1,unused,209,unused,"    } else
        printf(""Successfully added and removed to an empty list!\n"");
    printf(""About to beef up the engine-type list\n"");
    for (loop = 0; loop < 512; loop++) {
        sprintf(buf, ""id%i"", loop);
",unused,openssl1-test2Fenginetest.c
"    printf(""About to beef up the engine-type list\n"");
    for (loop = 0; loop < 512; loop++) {
        sprintf(buf, ""id%i"", loop);
        id = BUF_strdup(buf);
        sprintf(buf, ""Fake engine type %i"", loop);
",1,unused,211,unused,"    printf(""About to beef up the engine-type list\n"");
    for (loop = 0; loop < 512; loop++) {
        sprintf(buf, ""id%i"", loop);
        id = BUF_strdup(buf);
        sprintf(buf, ""Fake engine type %i"", loop);
",unused,openssl1-test2Fenginetest.c
"    unsigned int i;
    static char buf[80];

    for (i = 0; i < len; i++)
        sprintf(&(buf[i * 2]), ""%02x"", md[i]);
",1,unused,328,unused,"    unsigned int i;
    static char buf[80];

    for (i = 0; i < len; i++)
        sprintf(&(buf[i * 2]), ""%02x"", md[i]);
",unused,openssl1-test2Fhmactest.c
"    int i;
    static char buf[80];

    for (i = 0; i < MD4_DIGEST_LENGTH; i++)
        sprintf(&(buf[i * 2]), ""%02x"", md[i]);
",1,unused,130,unused,"    int i;
    static char buf[80];

    for (i = 0; i < MD4_DIGEST_LENGTH; i++)
        sprintf(&(buf[i * 2]), ""%02x"", md[i]);
",unused,openssl1-test2Fmd4test.c
"    int i;
    static char buf[80];

    for (i = 0; i < MD5_DIGEST_LENGTH; i++)
        sprintf(&(buf[i * 2]), ""%02x"", md[i]);
",1,unused,135,unused,"    int i;
    static char buf[80];

    for (i = 0; i < MD5_DIGEST_LENGTH; i++)
        sprintf(&(buf[i * 2]), ""%02x"", md[i]);
",unused,openssl1-test2Fmd5test.c
"    int i;
    static char buf[80];

    for (i = 0; i < RIPEMD160_DIGEST_LENGTH; i++)
        sprintf(&(buf[i * 2]), ""%02x"", md[i]);
",1,unused,140,unused,"    int i;
    static char buf[80];

    for (i = 0; i < RIPEMD160_DIGEST_LENGTH; i++)
        sprintf(&(buf[i * 2]), ""%02x"", md[i]);
",unused,openssl1-test2Frmdtest.c
"    int i;
    static char buf[80];

    for (i = 0; i < SHA_DIGEST_LENGTH; i++)
        sprintf(&(buf[i * 2]), ""%02x"", md[i]);
",1,unused,171,unused,"    int i;
    static char buf[80];

    for (i = 0; i < SHA_DIGEST_LENGTH; i++)
        sprintf(&(buf[i * 2]), ""%02x"", md[i]);
",unused,openssl1-test2Fsha1test.c
"    int i;
    static char buf[80];

    for (i = 0; i < SHA_DIGEST_LENGTH; i++)
        sprintf(&(buf[i * 2]), ""%02x"", md[i]);
",1,unused,171,unused,"    int i;
    static char buf[80];

    for (i = 0; i < SHA_DIGEST_LENGTH; i++)
        sprintf(&(buf[i * 2]), ""%02x"", md[i]);
",unused,openssl1-test2Fshatest.c
"//funcion para imprimir la line, para debug.. despues volar
void Print_Line(Line_t* L)
{
   char S[100];
   sprintf( S, ""Line: |0x%X|0x%X|%s|\r\n"",
",1,unused,85,unused,"//funcion para imprimir la line, para debug.. despues volar
void Print_Line(Line_t* L)
{
   char S[100];
   sprintf( S, ""Line: |0x%X|0x%X|%s|\r\n"",
",unused,pap-tp12Fsrc2Fline_parser.c
"}

char* Print_Qmpool_Struct(QMPool* Q,char* S)
{
   sprintf( S, ""mem pool\r\n----------\r\n""
",1,unused,69,unused,"}

char* Print_Qmpool_Struct(QMPool* Q,char* S)
{
   sprintf( S, ""mem pool\r\n----------\r\n""
",unused,pap-tp12Fsrc2Fqf_mem.c
"      /* Temporarily modify the buffer into its parent directory name,
         invoke pathconf on the directory, and then restore the buffer.  */
      char tmp[sizeof "".""];
      memcpy (tmp, base, sizeof ""."");
      strcpy (base, ""."");
",1,unused,107,unused,"      /* Temporarily modify the buffer into its parent directory name,
         invoke pathconf on the directory, and then restore the buffer.  */
      char tmp[sizeof "".""];
      memcpy (tmp, base, sizeof ""."");
      strcpy (base, ""."");
",unused,patchdebstretche-lib2Fbackupfile.c
"  /* Temporarily modify the buffer into its parent directory name,
     open the directory, and then restore the buffer.  */
  char tmp[sizeof "".""];
  memcpy (tmp, base, sizeof ""."");
  strcpy (base, ""."");
",1,unused,187,unused,"  /* Temporarily modify the buffer into its parent directory name,
     open the directory, and then restore the buffer.  */
  char tmp[sizeof "".""];
  memcpy (tmp, base, sizeof ""."");
  strcpy (base, ""."");
",unused,patchdebstretche-lib2Fbackupfile.c
"  memcpy (tmp, base, sizeof ""."");
  strcpy (base, ""."");
  dirp = opendir (buf);
  memcpy (base, tmp, sizeof ""."");
  strcpy (base + baselen, "".~1~"");
",1,unused,190,unused,"  memcpy (tmp, base, sizeof ""."");
  strcpy (base, ""."");
  dirp = opendir (buf);
  memcpy (base, tmp, sizeof ""."");
  strcpy (base + baselen, "".~1~"");
",unused,patchdebstretche-lib2Fbackupfile.c
"                          res_size = 0;
                          free (old_res_ptr);
                          break;
                        }
                      strcpy (res_ptr + res_size - (l2 + 1) - (l1 + 1), buf1);
",1,unused,239,unused,"                          res_size = 0;
                          free (old_res_ptr);
                          break;
                        }
                      strcpy (res_ptr + res_size - (l2 + 1) - (l1 + 1), buf1);
",unused,patchdebstretche-lib2Flocalcharset.c
"                          free (old_res_ptr);
                          break;
                        }
                      strcpy (res_ptr + res_size - (l2 + 1) - (l1 + 1), buf1);
                      strcpy (res_ptr + res_size - (l2 + 1), buf2);
",1,unused,240,unused,"                          free (old_res_ptr);
                          break;
                        }
                      strcpy (res_ptr + res_size - (l2 + 1) - (l1 + 1), buf1);
                      strcpy (res_ptr + res_size - (l2 + 1), buf2);
",unused,patchdebstretche-lib2Flocalcharset.c
"             that name resolves to /proc/self/fd, which was opened above.
             However, on Solaris, it may resolve to /proc/self/fd/fd, which
             cannot exist, since all names in /proc/self/fd are numeric.  */
          char dotdot_buf[PROC_SELF_FD_NAME_SIZE_BOUND (sizeof ""../fd"" - 1)];
          sprintf (dotdot_buf, PROC_SELF_FD_FORMAT, proc_self_fd, ""../fd"");
",1,unused,81,unused,"             that name resolves to /proc/self/fd, which was opened above.
             However, on Solaris, it may resolve to /proc/self/fd/fd, which
             cannot exist, since all names in /proc/self/fd are numeric.  */
          char dotdot_buf[PROC_SELF_FD_NAME_SIZE_BOUND (sizeof ""../fd"" - 1)];
          sprintf (dotdot_buf, PROC_SELF_FD_FORMAT, proc_self_fd, ""../fd"");
",unused,patchdebstretche-lib2Fopenat-proc.c
"          result = malloc (bufsize);
          if (! result)
            return NULL;
        }
      sprintf (result, PROC_SELF_FD_FORMAT, fd, file);
",1,unused,99,unused,"          result = malloc (bufsize);
          if (! result)
            return NULL;
        }
      sprintf (result, PROC_SELF_FD_FORMAT, fd, file);
",unused,patchdebstretche-lib2Fopenat-proc.c
"              char tz1buf[sizeof ""XXX+0:00""
                          + sizeof pc.time_zone * CHAR_BIT / 3];
              if (!tz_was_altered)
                tz0 = get_tz (tz0buf);
              sprintf (tz1buf, ""XXX%s%ld:%02d"", &""-""[time_zone < 0],
",1,unused,3200,unused,"              char tz1buf[sizeof ""XXX+0:00""
                          + sizeof pc.time_zone * CHAR_BIT / 3];
              if (!tz_was_altered)
                tz0 = get_tz (tz0buf);
              sprintf (tz1buf, ""XXX%s%ld:%02d"", &""-""[time_zone < 0],
",unused,patchdebstretche-lib2Fparse-datetime.c
"      /* Temporarily modify the buffer into its parent directory name,
         invoke pathconf on the directory, and then restore the buffer.  */
      char tmp[sizeof "".""];
      memcpy (tmp, base, sizeof ""."");
      strcpy (base, ""."");
",1,unused,107,unused,"      /* Temporarily modify the buffer into its parent directory name,
         invoke pathconf on the directory, and then restore the buffer.  */
      char tmp[sizeof "".""];
      memcpy (tmp, base, sizeof ""."");
      strcpy (base, ""."");
",unused,patchsource-lib2Fbackupfile.c
"  /* Temporarily modify the buffer into its parent directory name,
     open the directory, and then restore the buffer.  */
  char tmp[sizeof "".""];
  memcpy (tmp, base, sizeof ""."");
  strcpy (base, ""."");
",1,unused,187,unused,"  /* Temporarily modify the buffer into its parent directory name,
     open the directory, and then restore the buffer.  */
  char tmp[sizeof "".""];
  memcpy (tmp, base, sizeof ""."");
  strcpy (base, ""."");
",unused,patchsource-lib2Fbackupfile.c
"  memcpy (tmp, base, sizeof ""."");
  strcpy (base, ""."");
  dirp = opendir (buf);
  memcpy (base, tmp, sizeof ""."");
  strcpy (base + baselen, "".~1~"");
",1,unused,190,unused,"  memcpy (tmp, base, sizeof ""."");
  strcpy (base, ""."");
  dirp = opendir (buf);
  memcpy (base, tmp, sizeof ""."");
  strcpy (base + baselen, "".~1~"");
",unused,patchsource-lib2Fbackupfile.c
"                          res_size = 0;
                          free (old_res_ptr);
                          break;
                        }
                      strcpy (res_ptr + res_size - (l2 + 1) - (l1 + 1), buf1);
",1,unused,239,unused,"                          res_size = 0;
                          free (old_res_ptr);
                          break;
                        }
                      strcpy (res_ptr + res_size - (l2 + 1) - (l1 + 1), buf1);
",unused,patchsource-lib2Flocalcharset.c
"                          free (old_res_ptr);
                          break;
                        }
                      strcpy (res_ptr + res_size - (l2 + 1) - (l1 + 1), buf1);
                      strcpy (res_ptr + res_size - (l2 + 1), buf2);
",1,unused,240,unused,"                          free (old_res_ptr);
                          break;
                        }
                      strcpy (res_ptr + res_size - (l2 + 1) - (l1 + 1), buf1);
                      strcpy (res_ptr + res_size - (l2 + 1), buf2);
",unused,patchsource-lib2Flocalcharset.c
"             that name resolves to /proc/self/fd, which was opened above.
             However, on Solaris, it may resolve to /proc/self/fd/fd, which
             cannot exist, since all names in /proc/self/fd are numeric.  */
          char dotdot_buf[PROC_SELF_FD_NAME_SIZE_BOUND (sizeof ""../fd"" - 1)];
          sprintf (dotdot_buf, PROC_SELF_FD_FORMAT, proc_self_fd, ""../fd"");
",1,unused,81,unused,"             that name resolves to /proc/self/fd, which was opened above.
             However, on Solaris, it may resolve to /proc/self/fd/fd, which
             cannot exist, since all names in /proc/self/fd are numeric.  */
          char dotdot_buf[PROC_SELF_FD_NAME_SIZE_BOUND (sizeof ""../fd"" - 1)];
          sprintf (dotdot_buf, PROC_SELF_FD_FORMAT, proc_self_fd, ""../fd"");
",unused,patchsource-lib2Fopenat-proc.c
"          result = malloc (bufsize);
          if (! result)
            return NULL;
        }
      sprintf (result, PROC_SELF_FD_FORMAT, fd, file);
",1,unused,99,unused,"          result = malloc (bufsize);
          if (! result)
            return NULL;
        }
      sprintf (result, PROC_SELF_FD_FORMAT, fd, file);
",unused,patchsource-lib2Fopenat-proc.c
"              char tz1buf[sizeof ""XXX+0:00""
                          + sizeof pc.time_zone * CHAR_BIT / 3];
              if (!tz_was_altered)
                tz0 = get_tz (tz0buf);
              sprintf (tz1buf, ""XXX%s%ld:%02d"", &""-""[time_zone < 0],
",1,unused,3200,unused,"              char tz1buf[sizeof ""XXX+0:00""
                          + sizeof pc.time_zone * CHAR_BIT / 3];
              if (!tz_was_altered)
                tz0 = get_tz (tz0buf);
              sprintf (tz1buf, ""XXX%s%ld:%02d"", &""-""[time_zone < 0],
",unused,patchsource-lib2Fparse-datetime.c
"      /* Temporarily modify the buffer into its parent directory name,
         invoke pathconf on the directory, and then restore the buffer.  */
      char tmp[sizeof "".""];
      memcpy (tmp, base, sizeof ""."");
      strcpy (base, ""."");
",1,unused,107,unused,"      /* Temporarily modify the buffer into its parent directory name,
         invoke pathconf on the directory, and then restore the buffer.  */
      char tmp[sizeof "".""];
      memcpy (tmp, base, sizeof ""."");
      strcpy (base, ""."");
",unused,patchtrusty-lib2Fbackupfile.c
"  /* Temporarily modify the buffer into its parent directory name,
     open the directory, and then restore the buffer.  */
  char tmp[sizeof "".""];
  memcpy (tmp, base, sizeof ""."");
  strcpy (base, ""."");
",1,unused,187,unused,"  /* Temporarily modify the buffer into its parent directory name,
     open the directory, and then restore the buffer.  */
  char tmp[sizeof "".""];
  memcpy (tmp, base, sizeof ""."");
  strcpy (base, ""."");
",unused,patchtrusty-lib2Fbackupfile.c
"  memcpy (tmp, base, sizeof ""."");
  strcpy (base, ""."");
  dirp = opendir (buf);
  memcpy (base, tmp, sizeof ""."");
  strcpy (base + baselen, "".~1~"");
",1,unused,190,unused,"  memcpy (tmp, base, sizeof ""."");
  strcpy (base, ""."");
  dirp = opendir (buf);
  memcpy (base, tmp, sizeof ""."");
  strcpy (base + baselen, "".~1~"");
",unused,patchtrusty-lib2Fbackupfile.c
"                          res_size = 0;
                          free (old_res_ptr);
                          break;
                        }
                      strcpy (res_ptr + res_size - (l2 + 1) - (l1 + 1), buf1);
",1,unused,233,unused,"                          res_size = 0;
                          free (old_res_ptr);
                          break;
                        }
                      strcpy (res_ptr + res_size - (l2 + 1) - (l1 + 1), buf1);
",unused,patchtrusty-lib2Flocalcharset.c
"                          free (old_res_ptr);
                          break;
                        }
                      strcpy (res_ptr + res_size - (l2 + 1) - (l1 + 1), buf1);
                      strcpy (res_ptr + res_size - (l2 + 1), buf2);
",1,unused,234,unused,"                          free (old_res_ptr);
                          break;
                        }
                      strcpy (res_ptr + res_size - (l2 + 1) - (l1 + 1), buf1);
                      strcpy (res_ptr + res_size - (l2 + 1), buf2);
",unused,patchtrusty-lib2Flocalcharset.c
"              char tz1buf[sizeof ""XXX+0:00""
                          + sizeof pc.time_zone * CHAR_BIT / 3];
              if (!tz_was_altered)
                tz0 = get_tz (tz0buf);
              sprintf (tz1buf, ""XXX%s%ld:%02d"", ""-"" + (time_zone < 0),
",1,unused,3456,unused,"              char tz1buf[sizeof ""XXX+0:00""
                          + sizeof pc.time_zone * CHAR_BIT / 3];
              if (!tz_was_altered)
                tz0 = get_tz (tz0buf);
              sprintf (tz1buf, ""XXX%s%ld:%02d"", ""-"" + (time_zone < 0),
",unused,patchtrusty-lib2Fparse-datetime.c
"    register char *p;

    p = s;
    for(i = 0; i < 8; i++) {
        sprintf(p, ""%02X"", v->b[i] & 0xff);
",1,unused,22,unused,"    register char *p;

    p = s;
    for(i = 0; i < 8; i++) {
        sprintf(p, ""%02X"", v->b[i] & 0xff);
",unused,pdvcoincore-src2Flibrary.c
"    else
        digit_ver = 11 - val_mod;

    char out_v[12];
    sprintf(out_v, ""%d"", digit_ver);
",1,unused,78,unused,"    else
        digit_ver = 11 - val_mod;

    char out_v[12];
    sprintf(out_v, ""%d"", digit_ver);
",unused,pdvcoincore-src2Flibrary.c
"}

void getInfoPdv(InfoPdv *c, char *loj, char *caix, char *val, char *num, char *cartloja)
{
    strcpy(c->loja, loj);
",1,unused,164,unused,"}

void getInfoPdv(InfoPdv *c, char *loj, char *caix, char *val, char *num, char *cartloja)
{
    strcpy(c->loja, loj);
",unused,pdvcoincore-src2Flibrary.c
"
void getInfoPdv(InfoPdv *c, char *loj, char *caix, char *val, char *num, char *cartloja)
{
    strcpy(c->loja, loj);
    strcpy(c->caixa, caix);
",1,unused,165,unused,"
void getInfoPdv(InfoPdv *c, char *loj, char *caix, char *val, char *num, char *cartloja)
{
    strcpy(c->loja, loj);
    strcpy(c->caixa, caix);
",unused,pdvcoincore-src2Flibrary.c
"void getInfoPdv(InfoPdv *c, char *loj, char *caix, char *val, char *num, char *cartloja)
{
    strcpy(c->loja, loj);
    strcpy(c->caixa, caix);
    strcpy(c->valCompra, val);
",1,unused,166,unused,"void getInfoPdv(InfoPdv *c, char *loj, char *caix, char *val, char *num, char *cartloja)
{
    strcpy(c->loja, loj);
    strcpy(c->caixa, caix);
    strcpy(c->valCompra, val);
",unused,pdvcoincore-src2Flibrary.c
"{
    strcpy(c->loja, loj);
    strcpy(c->caixa, caix);
    strcpy(c->valCompra, val);
    strcpy(c->numCupomFiscal, num);
",1,unused,167,unused,"{
    strcpy(c->loja, loj);
    strcpy(c->caixa, caix);
    strcpy(c->valCompra, val);
    strcpy(c->numCupomFiscal, num);
",unused,pdvcoincore-src2Flibrary.c
"    strcpy(c->loja, loj);
    strcpy(c->caixa, caix);
    strcpy(c->valCompra, val);
    strcpy(c->numCupomFiscal, num);
    strcpy(c->cartaoloja, cartloja);
",1,unused,168,unused,"    strcpy(c->loja, loj);
    strcpy(c->caixa, caix);
    strcpy(c->valCompra, val);
    strcpy(c->numCupomFiscal, num);
    strcpy(c->cartaoloja, cartloja);
",unused,pdvcoincore-src2Flibrary.c
"    strcpy(c->cartaoloja, cartloja);
}

void getInfoKey(char *keyOri, char *datBegin, char *datEnd, int *mult, char *prefixo, char *keyRet) {
    strcpy(keyRet, keyOri);
",1,unused,172,unused,"    strcpy(c->cartaoloja, cartloja);
}

void getInfoKey(char *keyOri, char *datBegin, char *datEnd, int *mult, char *prefixo, char *keyRet) {
    strcpy(keyRet, keyOri);
",unused,pdvcoincore-src2Flibrary.c
"    asprintf(&chaveaberta, ""%llu"", ullwrkkey);

    // multiplo
    char multstr[10];
    strcpy(&multstr[0], &chaveaberta[12]);
",1,unused,200,unused,"    asprintf(&chaveaberta, ""%llu"", ullwrkkey);

    // multiplo
    char multstr[10];
    strcpy(&multstr[0], &chaveaberta[12]);
",unused,pdvcoincore-src2Flibrary.c
"
    // data de inicio
    char wrkData[20];

    strcpy(&wrkData[0], &chaveaberta[0]);
",1,unused,207,unused,"
    // data de inicio
    char wrkData[20];

    strcpy(&wrkData[0], &chaveaberta[0]);
",unused,pdvcoincore-src2Flibrary.c
"    char wrkData[20];

    strcpy(&wrkData[0], &chaveaberta[0]);
    wrkData[6]=0;
    strcpy(datBegin , &wrkData[0]);
",1,unused,209,unused,"    char wrkData[20];

    strcpy(&wrkData[0], &chaveaberta[0]);
    wrkData[6]=0;
    strcpy(datBegin , &wrkData[0]);
",unused,pdvcoincore-src2Flibrary.c
"    wrkData[6]=0;
    strcpy(datBegin , &wrkData[0]);

    // Data final
    strcpy(&wrkData[0], &chaveaberta[6]);
",1,unused,212,unused,"    wrkData[6]=0;
    strcpy(datBegin , &wrkData[0]);

    // Data final
    strcpy(&wrkData[0], &chaveaberta[6]);
",unused,pdvcoincore-src2Flibrary.c
"
    // Data final
    strcpy(&wrkData[0], &chaveaberta[6]);
    wrkData[6]=0;
    strcpy(datEnd , &wrkData[0]);
",1,unused,214,unused,"
    // Data final
    strcpy(&wrkData[0], &chaveaberta[6]);
    wrkData[6]=0;
    strcpy(datEnd , &wrkData[0]);
",unused,pdvcoincore-src2Flibrary.c
"    wrkData[6]=0;
    strcpy(datEnd , &wrkData[0]);

    // prefixo
    strcpy(prefixo, prefixoBase);
",1,unused,217,unused,"    wrkData[6]=0;
    strcpy(datEnd , &wrkData[0]);

    // prefixo
    strcpy(prefixo, prefixoBase);
",unused,pdvcoincore-src2Flibrary.c
"

    // checking the parameters
    if (strlen(info.loja) > 4) {
        strcpy(code, ""The length of store information is limited to 4 chars"");
",1,unused,247,unused,"

    // checking the parameters
    if (strlen(info.loja) > 4) {
        strcpy(code, ""The length of store information is limited to 4 chars"");
",unused,pdvcoincore-src2Flibrary.c
"    if (strlen(info.loja) > 4) {
        strcpy(code, ""The length of store information is limited to 4 chars"");
        return -5;
    } else if (isnumber(info.loja) == 0 ) {
        strcpy(code, ""The store should contain only numbers"");
",1,unused,250,unused,"    if (strlen(info.loja) > 4) {
        strcpy(code, ""The length of store information is limited to 4 chars"");
        return -5;
    } else if (isnumber(info.loja) == 0 ) {
        strcpy(code, ""The store should contain only numbers"");
",unused,pdvcoincore-src2Flibrary.c
"    } else if (isnumber(info.loja) == 0 ) {
        strcpy(code, ""The store should contain only numbers"");
        return -7;
    } else if (strlen(info.caixa) > 3) {
        strcpy(code, ""The length of PDV information is limited to 3 chars"");
",1,unused,253,unused,"    } else if (isnumber(info.loja) == 0 ) {
        strcpy(code, ""The store should contain only numbers"");
        return -7;
    } else if (strlen(info.caixa) > 3) {
        strcpy(code, ""The length of PDV information is limited to 3 chars"");
",unused,pdvcoincore-src2Flibrary.c
"    } else if (strlen(info.caixa) > 3) {
        strcpy(code, ""The length of PDV information is limited to 3 chars"");
        return -10;
    } else if (isnumber(info.caixa) == 0) {
        strcpy(code, ""The PDV should contain only numbers"");
",1,unused,256,unused,"    } else if (strlen(info.caixa) > 3) {
        strcpy(code, ""The length of PDV information is limited to 3 chars"");
        return -10;
    } else if (isnumber(info.caixa) == 0) {
        strcpy(code, ""The PDV should contain only numbers"");
",unused,pdvcoincore-src2Flibrary.c
"    } else if (isnumber(info.caixa) == 0) {
        strcpy(code, ""The PDV should contain only numbers"");
        return -12;
    } else if (strlen(info.numCupomFiscal) > 6) {
        strcpy(code, ""The length of COO information is limited to 6 chars"");
",1,unused,259,unused,"    } else if (isnumber(info.caixa) == 0) {
        strcpy(code, ""The PDV should contain only numbers"");
        return -12;
    } else if (strlen(info.numCupomFiscal) > 6) {
        strcpy(code, ""The length of COO information is limited to 6 chars"");
",unused,pdvcoincore-src2Flibrary.c
"    } else if (strlen(info.numCupomFiscal) > 6) {
        strcpy(code, ""The length of COO information is limited to 6 chars"");
        return -15;
    } else if (isnumber(info.numCupomFiscal) == 0) {
        strcpy(code, ""The COO should contain only numbers"");
",1,unused,262,unused,"    } else if (strlen(info.numCupomFiscal) > 6) {
        strcpy(code, ""The length of COO information is limited to 6 chars"");
        return -15;
    } else if (isnumber(info.numCupomFiscal) == 0) {
        strcpy(code, ""The COO should contain only numbers"");
",unused,pdvcoincore-src2Flibrary.c
"    } else if (isnumber(info.numCupomFiscal) == 0) {
        strcpy(code, ""The COO should contain only numbers"");
        return -15;
    } else if (strcmp(info.cartaoloja, ""S"") != 0 && strcmp(info.cartaoloja, ""N"") != 0) {
        strcpy(code, ""credit card status must be 'S' or 'N'"");
",1,unused,265,unused,"    } else if (isnumber(info.numCupomFiscal) == 0) {
        strcpy(code, ""The COO should contain only numbers"");
        return -15;
    } else if (strcmp(info.cartaoloja, ""S"") != 0 && strcmp(info.cartaoloja, ""N"") != 0) {
        strcpy(code, ""credit card status must be 'S' or 'N'"");
",unused,pdvcoincore-src2Flibrary.c
"

    // Decodificando a chave
    if (strlen(key) != 19) {
        strcpy(code, ""Invalid key length"");
",1,unused,272,unused,"

    // Decodificando a chave
    if (strlen(key) != 19) {
        strcpy(code, ""Invalid key length"");
",unused,pdvcoincore-src2Flibrary.c
"    char datBegin[7], datEnd[7], prefixo[3] = ""000"", keyRet[17] = ""00000000000000000"";
    getInfoKey(key, &datBegin[0], &datEnd[0], &multiplo, &prefixo[0], &keyRet[0]);

    if (multiplo <= 0){
        strcpy(code, ""Key - invalid value of multiple"");
",1,unused,280,unused,"    char datBegin[7], datEnd[7], prefixo[3] = ""000"", keyRet[17] = ""00000000000000000"";
    getInfoKey(key, &datBegin[0], &datEnd[0], &multiplo, &prefixo[0], &keyRet[0]);

    if (multiplo <= 0){
        strcpy(code, ""Key - invalid value of multiple"");
",unused,pdvcoincore-src2Flibrary.c
"    double valcompra = 0;

    sscanf(info.valCompra, ""%lf"", &valcompra);
    if (valcompra <= 0){
        strcpy(code, ""The purchase value should be a valid number"");
",1,unused,297,unused,"    double valcompra = 0;

    sscanf(info.valCompra, ""%lf"", &valcompra);
    if (valcompra <= 0){
        strcpy(code, ""The purchase value should be a valid number"");
",unused,pdvcoincore-src2Flibrary.c
"        return -35;
    }

    if (valcompra < multiplo){
        strcpy(code, ""The purchase value is smaller than the configured multi value"");
",1,unused,302,unused,"        return -35;
    }

    if (valcompra < multiplo){
        strcpy(code, ""The purchase value is smaller than the configured multi value"");
",unused,pdvcoincore-src2Flibrary.c
"    if (valcompra < multiplo){
        strcpy(code, ""The purchase value is smaller than the configured multi value"");
        return -37;
    } else if (valcompra > 1000000){
        strcpy(code, ""The purchase value is greater than 1000000"");
",1,unused,305,unused,"    if (valcompra < multiplo){
        strcpy(code, ""The purchase value is smaller than the configured multi value"");
        return -37;
    } else if (valcompra > 1000000){
        strcpy(code, ""The purchase value is greater than 1000000"");
",unused,pdvcoincore-src2Flibrary.c
"    numcupons = (int) valcompra / multiplo;
    char strncupons[12];

    if (numcupons <= 0) {
        strcpy(code, ""Invalid numbers of coupons"");
",1,unused,314,unused,"    numcupons = (int) valcompra / multiplo;
    char strncupons[12];

    if (numcupons <= 0) {
        strcpy(code, ""Invalid numbers of coupons"");
",unused,pdvcoincore-src2Flibrary.c
"    } else if (numcupons>999) {
        // Numero de cupons maior que o limite do campo
        numcupons=999;
    }
    sprintf(strncupons, ""%d"", numcupons);
",1,unused,320,unused,"    } else if (numcupons>999) {
        // Numero de cupons maior que o limite do campo
        numcupons=999;
    }
    sprintf(strncupons, ""%d"", numcupons);
",unused,pdvcoincore-src2Flibrary.c
"    int year, month, day;

    // Data Inicio
    if (testaData(datBegin)) {
        strcpy(code, ""Key1 - Invalid start date"");
",1,unused,330,unused,"    int year, month, day;

    // Data Inicio
    if (testaData(datBegin)) {
        strcpy(code, ""Key1 - Invalid start date"");
",unused,pdvcoincore-src2Flibrary.c
"
    // Data Inicio
    if (testaData(datBegin)) {
        strcpy(code, ""Key1 - Invalid start date"");
        strcpy(code, datBegin);
",1,unused,331,unused,"
    // Data Inicio
    if (testaData(datBegin)) {
        strcpy(code, ""Key1 - Invalid start date"");
        strcpy(code, datBegin);
",unused,pdvcoincore-src2Flibrary.c
"    time_t vDatInicio = mktime(&datinicio);

    // Data final
    if (testaData(datEnd)) {
        strcpy(code, ""Key - Invalid closing date"");
",1,unused,347,unused,"    time_t vDatInicio = mktime(&datinicio);

    // Data final
    if (testaData(datEnd)) {
        strcpy(code, ""Key - Invalid closing date"");
",unused,pdvcoincore-src2Flibrary.c
"    datfinal.tm_sec = 59;
    time_t vDatFinal = mktime(&datfinal);

    if (vDatInicio > vDatToday) {
        strcpy(code, ""Key - Promotion start date greater than today's date"");
",1,unused,362,unused,"    datfinal.tm_sec = 59;
    time_t vDatFinal = mktime(&datfinal);

    if (vDatInicio > vDatToday) {
        strcpy(code, ""Key - Promotion start date greater than today's date"");
",unused,pdvcoincore-src2Flibrary.c
"        strcpy(code, ""Key - Promotion start date greater than today's date"");
        return -55;
    }
    if (vDatFinal < vDatToday) {
        strcpy(code, ""Expired key"");
",1,unused,366,unused,"        strcpy(code, ""Key - Promotion start date greater than today's date"");
        return -55;
    }
    if (vDatFinal < vDatToday) {
        strcpy(code, ""Expired key"");
",unused,pdvcoincore-src2Flibrary.c
"            bvoucher[0] = 'K';
        bvoucher++;
    }

    strcpy(&ret_val[0], &prefixo[0]);   // Copiando o prefixo
",1,unused,388,unused,"            bvoucher[0] = 'K';
        bvoucher++;
    }

    strcpy(&ret_val[0], &prefixo[0]);   // Copiando o prefixo
",unused,pdvcoincore-src2Flibrary.c
"        bvoucher++;
    }

    strcpy(&ret_val[0], &prefixo[0]);   // Copiando o prefixo
    strcpy(&ret_val[0]+strlen(prefixo), voucher); // adicionando o valor do voucher
",1,unused,389,unused,"        bvoucher++;
    }

    strcpy(&ret_val[0], &prefixo[0]);   // Copiando o prefixo
    strcpy(&ret_val[0]+strlen(prefixo), voucher); // adicionando o valor do voucher
",unused,pdvcoincore-src2Flibrary.c
"
    strcpy(&ret_val[0], &prefixo[0]);   // Copiando o prefixo
    strcpy(&ret_val[0]+strlen(prefixo), voucher); // adicionando o valor do voucher

    strcpy(code, &ret_val[0]);
",1,unused,391,unused,"
    strcpy(&ret_val[0], &prefixo[0]);   // Copiando o prefixo
    strcpy(&ret_val[0]+strlen(prefixo), voucher); // adicionando o valor do voucher

    strcpy(code, &ret_val[0]);
",unused,pdvcoincore-src2Flibrary.c
"            {
              char *filename = g_malloc (dirnamelen + 1 + len + 1);
              strncpy (filename, dirname, dirnamelen);
              filename[dirnamelen] = G_DIR_SEPARATOR;
              strcpy (filename + dirnamelen + 1, dent->d_name);
",1,unused,198,unused,"            {
              char *filename = g_malloc (dirnamelen + 1 + len + 1);
              strncpy (filename, dirname, dirnamelen);
              filename[dirnamelen] = G_DIR_SEPARATOR;
              strcpy (filename + dirnamelen + 1, dent->d_name);
",unused,pkgconfigdebianstretche0.29-pkg.c
"
    str1 = g_alloca(strlen(a) + 1);
    str2 = g_alloca(strlen(b) + 1);

    strcpy(str1, a);
",1,unused,49,unused,"
    str1 = g_alloca(strlen(a) + 1);
    str2 = g_alloca(strlen(b) + 1);

    strcpy(str1, a);
",unused,pkgconfigdebianstretche0.29-rpmvercmp.c
"    str1 = g_alloca(strlen(a) + 1);
    str2 = g_alloca(strlen(b) + 1);

    strcpy(str1, a);
    strcpy(str2, b);
",1,unused,50,unused,"    str1 = g_alloca(strlen(a) + 1);
    str2 = g_alloca(strlen(b) + 1);

    strcpy(str1, a);
    strcpy(str2, b);
",unused,pkgconfigdebianstretche0.29-rpmvercmp.c
"            {
              char *filename = g_malloc (dirnamelen + 1 + len + 1);
              strncpy (filename, dirname, dirnamelen);
              filename[dirnamelen] = G_DIR_SEPARATOR;
              strcpy (filename + dirnamelen + 1, d_name);
",1,unused,198,unused,"            {
              char *filename = g_malloc (dirnamelen + 1 + len + 1);
              strncpy (filename, dirname, dirnamelen);
              filename[dirnamelen] = G_DIR_SEPARATOR;
              strcpy (filename + dirnamelen + 1, d_name);
",unused,pkgconfigpatchxen-pkg.c
"
    str1 = g_alloca(strlen(a) + 1);
    str2 = g_alloca(strlen(b) + 1);

    strcpy(str1, a);
",1,unused,49,unused,"
    str1 = g_alloca(strlen(a) + 1);
    str2 = g_alloca(strlen(b) + 1);

    strcpy(str1, a);
",unused,pkgconfigpatchxen-rpmvercmp.c
"    str1 = g_alloca(strlen(a) + 1);
    str2 = g_alloca(strlen(b) + 1);

    strcpy(str1, a);
    strcpy(str2, b);
",1,unused,50,unused,"    str1 = g_alloca(strlen(a) + 1);
    str2 = g_alloca(strlen(b) + 1);

    strcpy(str1, a);
    strcpy(str2, b);
",unused,pkgconfigpatchxen-rpmvercmp.c
"
    str1 = g_alloca(strlen(a) + 1);
    str2 = g_alloca(strlen(b) + 1);

    strcpy(str1, a);
",1,unused,49,unused,"
    str1 = g_alloca(strlen(a) + 1);
    str2 = g_alloca(strlen(b) + 1);

    strcpy(str1, a);
",unused,pkgconfigsources0.29-rpmvercmp.c
"    str1 = g_alloca(strlen(a) + 1);
    str2 = g_alloca(strlen(b) + 1);

    strcpy(str1, a);
    strcpy(str2, b);
",1,unused,50,unused,"    str1 = g_alloca(strlen(a) + 1);
    str2 = g_alloca(strlen(b) + 1);

    strcpy(str1, a);
    strcpy(str2, b);
",unused,pkgconfigsources0.29-rpmvercmp.c
"            {
              char *filename = g_malloc (dirnamelen + 1 + len + 1);
              strncpy (filename, dirname, dirnamelen);
              filename[dirnamelen] = G_DIR_SEPARATOR;
              strcpy (filename + dirnamelen + 1, d_name);
",1,unused,198,unused,"            {
              char *filename = g_malloc (dirnamelen + 1 + len + 1);
              strncpy (filename, dirname, dirnamelen);
              filename[dirnamelen] = G_DIR_SEPARATOR;
              strcpy (filename + dirnamelen + 1, d_name);
",unused,pkgconfigxenial0.29-pkg.c
"
    str1 = g_alloca(strlen(a) + 1);
    str2 = g_alloca(strlen(b) + 1);

    strcpy(str1, a);
",1,unused,49,unused,"
    str1 = g_alloca(strlen(a) + 1);
    str2 = g_alloca(strlen(b) + 1);

    strcpy(str1, a);
",unused,pkgconfigxenial0.29-rpmvercmp.c
"    str1 = g_alloca(strlen(a) + 1);
    str2 = g_alloca(strlen(b) + 1);

    strcpy(str1, a);
    strcpy(str2, b);
",1,unused,50,unused,"    str1 = g_alloca(strlen(a) + 1);
    str2 = g_alloca(strlen(b) + 1);

    strcpy(str1, a);
    strcpy(str2, b);
",unused,pkgconfigxenial0.29-rpmvercmp.c
"            {
              char *filename = g_malloc (dirnamelen + 1 + len + 1);
              strncpy (filename, dirname, dirnamelen);
              filename[dirnamelen] = G_DIR_SEPARATOR;
              strcpy (filename + dirnamelen + 1, d_name);
",1,unused,198,unused,"            {
              char *filename = g_malloc (dirnamelen + 1 + len + 1);
              strncpy (filename, dirname, dirnamelen);
              filename[dirnamelen] = G_DIR_SEPARATOR;
              strcpy (filename + dirnamelen + 1, d_name);
",unused,pkgconfigxenpatch-pkg.c
"
    str1 = g_alloca(strlen(a) + 1);
    str2 = g_alloca(strlen(b) + 1);

    strcpy(str1, a);
",1,unused,49,unused,"
    str1 = g_alloca(strlen(a) + 1);
    str2 = g_alloca(strlen(b) + 1);

    strcpy(str1, a);
",unused,pkgconfigxenpatch-rpmvercmp.c
"    str1 = g_alloca(strlen(a) + 1);
    str2 = g_alloca(strlen(b) + 1);

    strcpy(str1, a);
    strcpy(str2, b);
",1,unused,50,unused,"    str1 = g_alloca(strlen(a) + 1);
    str2 = g_alloca(strlen(b) + 1);

    strcpy(str1, a);
    strcpy(str2, b);
",unused,pkgconfigxenpatch-rpmvercmp.c
"
		preg = xmalloc (sizeof (regex_t));
		if (opt_exact) {
			re = xmalloc (strlen (opt_pattern) + 5);
			sprintf (re, ""^(%s)$"", opt_pattern);
",1,unused,464,unused,"
		preg = xmalloc (sizeof (regex_t));
		if (opt_exact) {
			re = xmalloc (strlen (opt_pattern) + 5);
			sprintf (re, ""^(%s)$"", opt_pattern);
",unused,ppp1-pgrep.c
"		sig = signal_option(&argc, argv);
		if (-1 < sig)
			opt_signal = sig;
		/* These options are for pkill only */
		strcat (opts, ""e"");
",1,unused,723,unused,"		sig = signal_option(&argc, argv);
		if (-1 < sig)
			opt_signal = sig;
		/* These options are for pkill only */
		strcat (opts, ""e"");
",unused,ppp1-pgrep.c
"		/* These options are for pkill only */
		strcat (opts, ""e"");
	} else {
		/* These options are for pgrep only */
		strcat (opts, ""lad:vw"");
",1,unused,726,unused,"		/* These options are for pkill only */
		strcat (opts, ""e"");
	} else {
		/* These options are for pgrep only */
		strcat (opts, ""lad:vw"");
",unused,ppp1-pgrep.c
"		/* These options are for pgrep only */
		strcat (opts, ""lad:vw"");
	}

	strcat (opts, ""LF:cfinoxP:g:s:u:U:G:t:?Vh"");
",1,unused,729,unused,"		/* These options are for pgrep only */
		strcat (opts, ""lad:vw"");
	}

	strcat (opts, ""LF:cfinoxP:g:s:u:U:G:t:?Vh"");
",unused,ppp1-pgrep.c
"					listtail->next = listnode;
				}
				listtail = listnode;
				/* listnode was calloc()ed so all fields are already NULL! */
				strcpy(listnode->description, detail_desc);
",1,unused,361,unused,"					listtail->next = listnode;
				}
				listtail = listnode;
				/* listnode was calloc()ed so all fields are already NULL! */
				strcpy(listnode->description, detail_desc);
",unused,ppp1-pmap.c
"					xerrx(EXIT_FAILURE, ""ERROR: %s %s"",
					      _(""inconsistent detail field in smaps file, line:\n""),
					      mapbuf);
			}
			strcpy(listnode->value_str, value_str);
",1,unused,371,unused,"					xerrx(EXIT_FAILURE, ""ERROR: %s %s"",
					      _(""inconsistent detail field in smaps file, line:\n""),
					      mapbuf);
			}
			strcpy(listnode->value_str, value_str);
",unused,ppp1-pmap.c
"		       ESC_ARGS | ESC_BRACKETS);
	printf(""%u:   %s\n"", p->tgid, cmdbuf);

	if (x_option || X_option || c_option) {
		sprintf(buf, ""/proc/%u/smaps"", p->tgid);
",1,unused,541,unused,"		       ESC_ARGS | ESC_BRACKETS);
	printf(""%u:   %s\n"", p->tgid, cmdbuf);

	if (x_option || X_option || c_option) {
		sprintf(buf, ""/proc/%u/smaps"", p->tgid);
",unused,ppp1-pmap.c
"		sprintf(buf, ""/proc/%u/smaps"", p->tgid);
		if ((fp = fopen(buf, ""r"")) == NULL)
			return 1;
	} else {
		sprintf(buf, ""/proc/%u/maps"", p->tgid);
",1,unused,545,unused,"		sprintf(buf, ""/proc/%u/smaps"", p->tgid);
		if ((fp = fopen(buf, ""r"")) == NULL)
			return 1;
	} else {
		sprintf(buf, ""/proc/%u/maps"", p->tgid);
",unused,ppp1-pmap.c
"        if (!p) {
            xalloc_err_handler(""%s failed to allocate %u bytes of memory"", __func__, size);
            exit(EXIT_FAILURE);
        }
        strcpy(p, str);
",1,unused,89,unused,"        if (!p) {
            xalloc_err_handler(""%s failed to allocate %u bytes of memory"", __func__, size);
            exit(EXIT_FAILURE);
        }
        strcpy(p, str);
",unused,ppp1-proc2Falloc.c
"    if(!tmn) return 0;
    if(tmn->major_number == maj && tmn->minor_first <= min && tmn->minor_last >= min) break;
    tmn = tmn->next;
  }
  sprintf(buf, ""/dev/%s%d"", tmn->name, min);  /* like ""/dev/ttyZZ255"" */
",1,unused,134,unused,"    if(!tmn) return 0;
    if(tmn->major_number == maj && tmn->minor_first <= min && tmn->minor_last >= min) break;
    tmn = tmn->next;
  }
  sprintf(buf, ""/dev/%s%d"", tmn->name, min);  /* like ""/dev/ttyZZ255"" */
",unused,ppp1-proc2Fdevname.c
"    tmn = tmn->next;
  }
  sprintf(buf, ""/dev/%s%d"", tmn->name, min);  /* like ""/dev/ttyZZ255"" */
  if(stat(buf, &sbuf) < 0){
    sprintf(buf, ""/dev/%s/%d"", tmn->name, min);  /* like ""/dev/pts/255"" */
",1,unused,136,unused,"    tmn = tmn->next;
  }
  sprintf(buf, ""/dev/%s%d"", tmn->name, min);  /* like ""/dev/ttyZZ255"" */
  if(stat(buf, &sbuf) < 0){
    sprintf(buf, ""/dev/%s/%d"", tmn->name, min);  /* like ""/dev/pts/255"" */
",unused,ppp1-proc2Fdevname.c
"  if(stat(buf, &sbuf) < 0){
    sprintf(buf, ""/dev/%s/%d"", tmn->name, min);  /* like ""/dev/pts/255"" */
    if(stat(buf, &sbuf) < 0){
      if(tmn->devfs_type) return 0;
      sprintf(buf, ""/dev/%s"", tmn->name);  /* like ""/dev/ttyZZ255"" */
",1,unused,139,unused,"  if(stat(buf, &sbuf) < 0){
    sprintf(buf, ""/dev/%s/%d"", tmn->name, min);  /* like ""/dev/pts/255"" */
    if(stat(buf, &sbuf) < 0){
      if(tmn->devfs_type) return 0;
      sprintf(buf, ""/dev/%s"", tmn->name);  /* like ""/dev/ttyZZ255"" */
",unused,ppp1-proc2Fdevname.c
"  case   3:      /* /dev/[pt]ty[p-za-o][0-9a-z] is 936 */
    if(tmpmin > 255) return 0;   // should never happen; array index protection
    t0 = ""pqrstuvwxyzabcde""[tmpmin>>4];
    t1 = ""0123456789abcdef""[tmpmin&0x0f];
    sprintf(buf, ""/dev/tty%c%c"", t0, t1);
",1,unused,214,unused,"  case   3:      /* /dev/[pt]ty[p-za-o][0-9a-z] is 936 */
    if(tmpmin > 255) return 0;   // should never happen; array index protection
    t0 = ""pqrstuvwxyzabcde""[tmpmin>>4];
    t1 = ""0123456789abcdef""[tmpmin&0x0f];
    sprintf(buf, ""/dev/tty%c%c"", t0, t1);
",unused,ppp1-proc2Fdevname.c
"    sprintf(buf, ""/dev/tty%c%c"", t0, t1);
    break;
  case   4:
    if(min<64){
      sprintf(buf, ""/dev/tty%d"", min);
",1,unused,218,unused,"    sprintf(buf, ""/dev/tty%c%c"", t0, t1);
    break;
  case   4:
    if(min<64){
      sprintf(buf, ""/dev/tty%d"", min);
",unused,ppp1-proc2Fdevname.c
"    if(min<64){
      sprintf(buf, ""/dev/tty%d"", min);
      break;
    }
    sprintf(buf, ""/dev/ttyS%d"", min-64);
",1,unused,221,unused,"    if(min<64){
      sprintf(buf, ""/dev/tty%d"", min);
      break;
    }
    sprintf(buf, ""/dev/ttyS%d"", min-64);
",unused,ppp1-proc2Fdevname.c
"      break;
    }
    sprintf(buf, ""/dev/ttyS%d"", min-64);
    break;
  case  11:  sprintf(buf, ""/dev/ttyB%d"",  min); break;
",1,unused,223,unused,"      break;
    }
    sprintf(buf, ""/dev/ttyS%d"", min-64);
    break;
  case  11:  sprintf(buf, ""/dev/ttyB%d"",  min); break;
",unused,ppp1-proc2Fdevname.c
"    }
    sprintf(buf, ""/dev/ttyS%d"", min-64);
    break;
  case  11:  sprintf(buf, ""/dev/ttyB%d"",  min); break;
  case  17:  sprintf(buf, ""/dev/ttyH%d"",  min); break;
",1,unused,224,unused,"    }
    sprintf(buf, ""/dev/ttyS%d"", min-64);
    break;
  case  11:  sprintf(buf, ""/dev/ttyB%d"",  min); break;
  case  17:  sprintf(buf, ""/dev/ttyH%d"",  min); break;
",unused,ppp1-proc2Fdevname.c
"    sprintf(buf, ""/dev/ttyS%d"", min-64);
    break;
  case  11:  sprintf(buf, ""/dev/ttyB%d"",  min); break;
  case  17:  sprintf(buf, ""/dev/ttyH%d"",  min); break;
  case  19:  sprintf(buf, ""/dev/ttyC%d"",  min); break;
",1,unused,225,unused,"    sprintf(buf, ""/dev/ttyS%d"", min-64);
    break;
  case  11:  sprintf(buf, ""/dev/ttyB%d"",  min); break;
  case  17:  sprintf(buf, ""/dev/ttyH%d"",  min); break;
  case  19:  sprintf(buf, ""/dev/ttyC%d"",  min); break;
",unused,ppp1-proc2Fdevname.c
"    break;
  case  11:  sprintf(buf, ""/dev/ttyB%d"",  min); break;
  case  17:  sprintf(buf, ""/dev/ttyH%d"",  min); break;
  case  19:  sprintf(buf, ""/dev/ttyC%d"",  min); break;
  case  22:  sprintf(buf, ""/dev/ttyD%d"",  min); break; /* devices.txt */
",1,unused,226,unused,"    break;
  case  11:  sprintf(buf, ""/dev/ttyB%d"",  min); break;
  case  17:  sprintf(buf, ""/dev/ttyH%d"",  min); break;
  case  19:  sprintf(buf, ""/dev/ttyC%d"",  min); break;
  case  22:  sprintf(buf, ""/dev/ttyD%d"",  min); break; /* devices.txt */
",unused,ppp1-proc2Fdevname.c
"  case  11:  sprintf(buf, ""/dev/ttyB%d"",  min); break;
  case  17:  sprintf(buf, ""/dev/ttyH%d"",  min); break;
  case  19:  sprintf(buf, ""/dev/ttyC%d"",  min); break;
  case  22:  sprintf(buf, ""/dev/ttyD%d"",  min); break; /* devices.txt */
  case  23:  sprintf(buf, ""/dev/ttyD%d"",  min); break; /* driver code */
",1,unused,227,unused,"  case  11:  sprintf(buf, ""/dev/ttyB%d"",  min); break;
  case  17:  sprintf(buf, ""/dev/ttyH%d"",  min); break;
  case  19:  sprintf(buf, ""/dev/ttyC%d"",  min); break;
  case  22:  sprintf(buf, ""/dev/ttyD%d"",  min); break; /* devices.txt */
  case  23:  sprintf(buf, ""/dev/ttyD%d"",  min); break; /* driver code */
",unused,ppp1-proc2Fdevname.c
"  case  17:  sprintf(buf, ""/dev/ttyH%d"",  min); break;
  case  19:  sprintf(buf, ""/dev/ttyC%d"",  min); break;
  case  22:  sprintf(buf, ""/dev/ttyD%d"",  min); break; /* devices.txt */
  case  23:  sprintf(buf, ""/dev/ttyD%d"",  min); break; /* driver code */
  case  24:  sprintf(buf, ""/dev/ttyE%d"",  min); break;
",1,unused,228,unused,"  case  17:  sprintf(buf, ""/dev/ttyH%d"",  min); break;
  case  19:  sprintf(buf, ""/dev/ttyC%d"",  min); break;
  case  22:  sprintf(buf, ""/dev/ttyD%d"",  min); break; /* devices.txt */
  case  23:  sprintf(buf, ""/dev/ttyD%d"",  min); break; /* driver code */
  case  24:  sprintf(buf, ""/dev/ttyE%d"",  min); break;
",unused,ppp1-proc2Fdevname.c
"  case  19:  sprintf(buf, ""/dev/ttyC%d"",  min); break;
  case  22:  sprintf(buf, ""/dev/ttyD%d"",  min); break; /* devices.txt */
  case  23:  sprintf(buf, ""/dev/ttyD%d"",  min); break; /* driver code */
  case  24:  sprintf(buf, ""/dev/ttyE%d"",  min); break;
  case  32:  sprintf(buf, ""/dev/ttyX%d"",  min); break;
",1,unused,229,unused,"  case  19:  sprintf(buf, ""/dev/ttyC%d"",  min); break;
  case  22:  sprintf(buf, ""/dev/ttyD%d"",  min); break; /* devices.txt */
  case  23:  sprintf(buf, ""/dev/ttyD%d"",  min); break; /* driver code */
  case  24:  sprintf(buf, ""/dev/ttyE%d"",  min); break;
  case  32:  sprintf(buf, ""/dev/ttyX%d"",  min); break;
",unused,ppp1-proc2Fdevname.c
"  case  22:  sprintf(buf, ""/dev/ttyD%d"",  min); break; /* devices.txt */
  case  23:  sprintf(buf, ""/dev/ttyD%d"",  min); break; /* driver code */
  case  24:  sprintf(buf, ""/dev/ttyE%d"",  min); break;
  case  32:  sprintf(buf, ""/dev/ttyX%d"",  min); break;
  case  43:  sprintf(buf, ""/dev/ttyI%d"",  min); break;
",1,unused,230,unused,"  case  22:  sprintf(buf, ""/dev/ttyD%d"",  min); break; /* devices.txt */
  case  23:  sprintf(buf, ""/dev/ttyD%d"",  min); break; /* driver code */
  case  24:  sprintf(buf, ""/dev/ttyE%d"",  min); break;
  case  32:  sprintf(buf, ""/dev/ttyX%d"",  min); break;
  case  43:  sprintf(buf, ""/dev/ttyI%d"",  min); break;
",unused,ppp1-proc2Fdevname.c
"  case  23:  sprintf(buf, ""/dev/ttyD%d"",  min); break; /* driver code */
  case  24:  sprintf(buf, ""/dev/ttyE%d"",  min); break;
  case  32:  sprintf(buf, ""/dev/ttyX%d"",  min); break;
  case  43:  sprintf(buf, ""/dev/ttyI%d"",  min); break;
  case  46:  sprintf(buf, ""/dev/ttyR%d"",  min); break;
",1,unused,231,unused,"  case  23:  sprintf(buf, ""/dev/ttyD%d"",  min); break; /* driver code */
  case  24:  sprintf(buf, ""/dev/ttyE%d"",  min); break;
  case  32:  sprintf(buf, ""/dev/ttyX%d"",  min); break;
  case  43:  sprintf(buf, ""/dev/ttyI%d"",  min); break;
  case  46:  sprintf(buf, ""/dev/ttyR%d"",  min); break;
",unused,ppp1-proc2Fdevname.c
"  case  24:  sprintf(buf, ""/dev/ttyE%d"",  min); break;
  case  32:  sprintf(buf, ""/dev/ttyX%d"",  min); break;
  case  43:  sprintf(buf, ""/dev/ttyI%d"",  min); break;
  case  46:  sprintf(buf, ""/dev/ttyR%d"",  min); break;
  case  48:  sprintf(buf, ""/dev/ttyL%d"",  min); break;
",1,unused,232,unused,"  case  24:  sprintf(buf, ""/dev/ttyE%d"",  min); break;
  case  32:  sprintf(buf, ""/dev/ttyX%d"",  min); break;
  case  43:  sprintf(buf, ""/dev/ttyI%d"",  min); break;
  case  46:  sprintf(buf, ""/dev/ttyR%d"",  min); break;
  case  48:  sprintf(buf, ""/dev/ttyL%d"",  min); break;
",unused,ppp1-proc2Fdevname.c
"  case  32:  sprintf(buf, ""/dev/ttyX%d"",  min); break;
  case  43:  sprintf(buf, ""/dev/ttyI%d"",  min); break;
  case  46:  sprintf(buf, ""/dev/ttyR%d"",  min); break;
  case  48:  sprintf(buf, ""/dev/ttyL%d"",  min); break;
  case  57:  sprintf(buf, ""/dev/ttyP%d"",  min); break;
",1,unused,233,unused,"  case  32:  sprintf(buf, ""/dev/ttyX%d"",  min); break;
  case  43:  sprintf(buf, ""/dev/ttyI%d"",  min); break;
  case  46:  sprintf(buf, ""/dev/ttyR%d"",  min); break;
  case  48:  sprintf(buf, ""/dev/ttyL%d"",  min); break;
  case  57:  sprintf(buf, ""/dev/ttyP%d"",  min); break;
",unused,ppp1-proc2Fdevname.c
"  case  43:  sprintf(buf, ""/dev/ttyI%d"",  min); break;
  case  46:  sprintf(buf, ""/dev/ttyR%d"",  min); break;
  case  48:  sprintf(buf, ""/dev/ttyL%d"",  min); break;
  case  57:  sprintf(buf, ""/dev/ttyP%d"",  min); break;
  case  71:  sprintf(buf, ""/dev/ttyF%d"",  min); break;
",1,unused,234,unused,"  case  43:  sprintf(buf, ""/dev/ttyI%d"",  min); break;
  case  46:  sprintf(buf, ""/dev/ttyR%d"",  min); break;
  case  48:  sprintf(buf, ""/dev/ttyL%d"",  min); break;
  case  57:  sprintf(buf, ""/dev/ttyP%d"",  min); break;
  case  71:  sprintf(buf, ""/dev/ttyF%d"",  min); break;
",unused,ppp1-proc2Fdevname.c
"  case  46:  sprintf(buf, ""/dev/ttyR%d"",  min); break;
  case  48:  sprintf(buf, ""/dev/ttyL%d"",  min); break;
  case  57:  sprintf(buf, ""/dev/ttyP%d"",  min); break;
  case  71:  sprintf(buf, ""/dev/ttyF%d"",  min); break;
  case  75:  sprintf(buf, ""/dev/ttyW%d"",  min); break;
",1,unused,235,unused,"  case  46:  sprintf(buf, ""/dev/ttyR%d"",  min); break;
  case  48:  sprintf(buf, ""/dev/ttyL%d"",  min); break;
  case  57:  sprintf(buf, ""/dev/ttyP%d"",  min); break;
  case  71:  sprintf(buf, ""/dev/ttyF%d"",  min); break;
  case  75:  sprintf(buf, ""/dev/ttyW%d"",  min); break;
",unused,ppp1-proc2Fdevname.c
"  case  48:  sprintf(buf, ""/dev/ttyL%d"",  min); break;
  case  57:  sprintf(buf, ""/dev/ttyP%d"",  min); break;
  case  71:  sprintf(buf, ""/dev/ttyF%d"",  min); break;
  case  75:  sprintf(buf, ""/dev/ttyW%d"",  min); break;
  case  78:  sprintf(buf, ""/dev/ttyM%d"",  min); break; /* conflict */
",1,unused,236,unused,"  case  48:  sprintf(buf, ""/dev/ttyL%d"",  min); break;
  case  57:  sprintf(buf, ""/dev/ttyP%d"",  min); break;
  case  71:  sprintf(buf, ""/dev/ttyF%d"",  min); break;
  case  75:  sprintf(buf, ""/dev/ttyW%d"",  min); break;
  case  78:  sprintf(buf, ""/dev/ttyM%d"",  min); break; /* conflict */
",unused,ppp1-proc2Fdevname.c
"  case  57:  sprintf(buf, ""/dev/ttyP%d"",  min); break;
  case  71:  sprintf(buf, ""/dev/ttyF%d"",  min); break;
  case  75:  sprintf(buf, ""/dev/ttyW%d"",  min); break;
  case  78:  sprintf(buf, ""/dev/ttyM%d"",  min); break; /* conflict */
  case 105:  sprintf(buf, ""/dev/ttyV%d"",  min); break;
",1,unused,237,unused,"  case  57:  sprintf(buf, ""/dev/ttyP%d"",  min); break;
  case  71:  sprintf(buf, ""/dev/ttyF%d"",  min); break;
  case  75:  sprintf(buf, ""/dev/ttyW%d"",  min); break;
  case  78:  sprintf(buf, ""/dev/ttyM%d"",  min); break; /* conflict */
  case 105:  sprintf(buf, ""/dev/ttyV%d"",  min); break;
",unused,ppp1-proc2Fdevname.c
"  case  71:  sprintf(buf, ""/dev/ttyF%d"",  min); break;
  case  75:  sprintf(buf, ""/dev/ttyW%d"",  min); break;
  case  78:  sprintf(buf, ""/dev/ttyM%d"",  min); break; /* conflict */
  case 105:  sprintf(buf, ""/dev/ttyV%d"",  min); break;
  case 112:  sprintf(buf, ""/dev/ttyM%d"",  min); break; /* conflict */
",1,unused,238,unused,"  case  71:  sprintf(buf, ""/dev/ttyF%d"",  min); break;
  case  75:  sprintf(buf, ""/dev/ttyW%d"",  min); break;
  case  78:  sprintf(buf, ""/dev/ttyM%d"",  min); break; /* conflict */
  case 105:  sprintf(buf, ""/dev/ttyV%d"",  min); break;
  case 112:  sprintf(buf, ""/dev/ttyM%d"",  min); break; /* conflict */
",unused,ppp1-proc2Fdevname.c
"  case  78:  sprintf(buf, ""/dev/ttyM%d"",  min); break; /* conflict */
  case 105:  sprintf(buf, ""/dev/ttyV%d"",  min); break;
  case 112:  sprintf(buf, ""/dev/ttyM%d"",  min); break; /* conflict */
  /* 136 ... 143 are /dev/pts/0, /dev/pts/1, /dev/pts/2 ... */
  case 136 ... 143:  sprintf(buf, ""/dev/pts/%d"",  min+(maj-136)*256); break;
",1,unused,240,unused,"  case  78:  sprintf(buf, ""/dev/ttyM%d"",  min); break; /* conflict */
  case 105:  sprintf(buf, ""/dev/ttyV%d"",  min); break;
  case 112:  sprintf(buf, ""/dev/ttyM%d"",  min); break; /* conflict */
  /* 136 ... 143 are /dev/pts/0, /dev/pts/1, /dev/pts/2 ... */
  case 136 ... 143:  sprintf(buf, ""/dev/pts/%d"",  min+(maj-136)*256); break;
",unused,ppp1-proc2Fdevname.c
"  case 105:  sprintf(buf, ""/dev/ttyV%d"",  min); break;
  case 112:  sprintf(buf, ""/dev/ttyM%d"",  min); break; /* conflict */
  /* 136 ... 143 are /dev/pts/0, /dev/pts/1, /dev/pts/2 ... */
  case 136 ... 143:  sprintf(buf, ""/dev/pts/%d"",  min+(maj-136)*256); break;
  case 148:  sprintf(buf, ""/dev/ttyT%d"",  min); break;
",1,unused,241,unused,"  case 105:  sprintf(buf, ""/dev/ttyV%d"",  min); break;
  case 112:  sprintf(buf, ""/dev/ttyM%d"",  min); break; /* conflict */
  /* 136 ... 143 are /dev/pts/0, /dev/pts/1, /dev/pts/2 ... */
  case 136 ... 143:  sprintf(buf, ""/dev/pts/%d"",  min+(maj-136)*256); break;
  case 148:  sprintf(buf, ""/dev/ttyT%d"",  min); break;
",unused,ppp1-proc2Fdevname.c
"  case 112:  sprintf(buf, ""/dev/ttyM%d"",  min); break; /* conflict */
  /* 136 ... 143 are /dev/pts/0, /dev/pts/1, /dev/pts/2 ... */
  case 136 ... 143:  sprintf(buf, ""/dev/pts/%d"",  min+(maj-136)*256); break;
  case 148:  sprintf(buf, ""/dev/ttyT%d"",  min); break;
  case 154:  sprintf(buf, ""/dev/ttySR%d"", min); break;
",1,unused,242,unused,"  case 112:  sprintf(buf, ""/dev/ttyM%d"",  min); break; /* conflict */
  /* 136 ... 143 are /dev/pts/0, /dev/pts/1, /dev/pts/2 ... */
  case 136 ... 143:  sprintf(buf, ""/dev/pts/%d"",  min+(maj-136)*256); break;
  case 148:  sprintf(buf, ""/dev/ttyT%d"",  min); break;
  case 154:  sprintf(buf, ""/dev/ttySR%d"", min); break;
",unused,ppp1-proc2Fdevname.c
"  /* 136 ... 143 are /dev/pts/0, /dev/pts/1, /dev/pts/2 ... */
  case 136 ... 143:  sprintf(buf, ""/dev/pts/%d"",  min+(maj-136)*256); break;
  case 148:  sprintf(buf, ""/dev/ttyT%d"",  min); break;
  case 154:  sprintf(buf, ""/dev/ttySR%d"", min); break;
  case 156:  sprintf(buf, ""/dev/ttySR%d"", min+256); break;
",1,unused,243,unused,"  /* 136 ... 143 are /dev/pts/0, /dev/pts/1, /dev/pts/2 ... */
  case 136 ... 143:  sprintf(buf, ""/dev/pts/%d"",  min+(maj-136)*256); break;
  case 148:  sprintf(buf, ""/dev/ttyT%d"",  min); break;
  case 154:  sprintf(buf, ""/dev/ttySR%d"", min); break;
  case 156:  sprintf(buf, ""/dev/ttySR%d"", min+256); break;
",unused,ppp1-proc2Fdevname.c
"  case 136 ... 143:  sprintf(buf, ""/dev/pts/%d"",  min+(maj-136)*256); break;
  case 148:  sprintf(buf, ""/dev/ttyT%d"",  min); break;
  case 154:  sprintf(buf, ""/dev/ttySR%d"", min); break;
  case 156:  sprintf(buf, ""/dev/ttySR%d"", min+256); break;
  case 164:  sprintf(buf, ""/dev/ttyCH%d"",  min); break;
",1,unused,244,unused,"  case 136 ... 143:  sprintf(buf, ""/dev/pts/%d"",  min+(maj-136)*256); break;
  case 148:  sprintf(buf, ""/dev/ttyT%d"",  min); break;
  case 154:  sprintf(buf, ""/dev/ttySR%d"", min); break;
  case 156:  sprintf(buf, ""/dev/ttySR%d"", min+256); break;
  case 164:  sprintf(buf, ""/dev/ttyCH%d"",  min); break;
",unused,ppp1-proc2Fdevname.c
"  case 148:  sprintf(buf, ""/dev/ttyT%d"",  min); break;
  case 154:  sprintf(buf, ""/dev/ttySR%d"", min); break;
  case 156:  sprintf(buf, ""/dev/ttySR%d"", min+256); break;
  case 164:  sprintf(buf, ""/dev/ttyCH%d"",  min); break;
  case 166:  sprintf(buf, ""/dev/ttyACM%d"", min); break; /* bummer, 9-char */
",1,unused,245,unused,"  case 148:  sprintf(buf, ""/dev/ttyT%d"",  min); break;
  case 154:  sprintf(buf, ""/dev/ttySR%d"", min); break;
  case 156:  sprintf(buf, ""/dev/ttySR%d"", min+256); break;
  case 164:  sprintf(buf, ""/dev/ttyCH%d"",  min); break;
  case 166:  sprintf(buf, ""/dev/ttyACM%d"", min); break; /* bummer, 9-char */
",unused,ppp1-proc2Fdevname.c
"  case 154:  sprintf(buf, ""/dev/ttySR%d"", min); break;
  case 156:  sprintf(buf, ""/dev/ttySR%d"", min+256); break;
  case 164:  sprintf(buf, ""/dev/ttyCH%d"",  min); break;
  case 166:  sprintf(buf, ""/dev/ttyACM%d"", min); break; /* bummer, 9-char */
  case 172:  sprintf(buf, ""/dev/ttyMX%d"",  min); break;
",1,unused,246,unused,"  case 154:  sprintf(buf, ""/dev/ttySR%d"", min); break;
  case 156:  sprintf(buf, ""/dev/ttySR%d"", min+256); break;
  case 164:  sprintf(buf, ""/dev/ttyCH%d"",  min); break;
  case 166:  sprintf(buf, ""/dev/ttyACM%d"", min); break; /* bummer, 9-char */
  case 172:  sprintf(buf, ""/dev/ttyMX%d"",  min); break;
",unused,ppp1-proc2Fdevname.c
"  case 156:  sprintf(buf, ""/dev/ttySR%d"", min+256); break;
  case 164:  sprintf(buf, ""/dev/ttyCH%d"",  min); break;
  case 166:  sprintf(buf, ""/dev/ttyACM%d"", min); break; /* bummer, 9-char */
  case 172:  sprintf(buf, ""/dev/ttyMX%d"",  min); break;
  case 174:  sprintf(buf, ""/dev/ttySI%d"",  min); break;
",1,unused,247,unused,"  case 156:  sprintf(buf, ""/dev/ttySR%d"", min+256); break;
  case 164:  sprintf(buf, ""/dev/ttyCH%d"",  min); break;
  case 166:  sprintf(buf, ""/dev/ttyACM%d"", min); break; /* bummer, 9-char */
  case 172:  sprintf(buf, ""/dev/ttyMX%d"",  min); break;
  case 174:  sprintf(buf, ""/dev/ttySI%d"",  min); break;
",unused,ppp1-proc2Fdevname.c
"  case 164:  sprintf(buf, ""/dev/ttyCH%d"",  min); break;
  case 166:  sprintf(buf, ""/dev/ttyACM%d"", min); break; /* bummer, 9-char */
  case 172:  sprintf(buf, ""/dev/ttyMX%d"",  min); break;
  case 174:  sprintf(buf, ""/dev/ttySI%d"",  min); break;
  case 188:  sprintf(buf, ""/dev/ttyUSB%d"", min); break; /* bummer, 9-char */
",1,unused,248,unused,"  case 164:  sprintf(buf, ""/dev/ttyCH%d"",  min); break;
  case 166:  sprintf(buf, ""/dev/ttyACM%d"", min); break; /* bummer, 9-char */
  case 172:  sprintf(buf, ""/dev/ttyMX%d"",  min); break;
  case 174:  sprintf(buf, ""/dev/ttySI%d"",  min); break;
  case 188:  sprintf(buf, ""/dev/ttyUSB%d"", min); break; /* bummer, 9-char */
",unused,ppp1-proc2Fdevname.c
"    memcpy(buf+8, low_density_names[min], sizeof low_density_names[0]);
    buf[8 + sizeof low_density_names[0]] = '\0';
//    snprintf(buf, 9 + sizeof low_density_names[0], ""/dev/tty%.*s"", sizeof low_density_names[0], low_density_names[min]);
    break;
  case 208:  sprintf(buf, ""/dev/ttyU%d"",  min); break;
",1,unused,256,unused,"    memcpy(buf+8, low_density_names[min], sizeof low_density_names[0]);
    buf[8 + sizeof low_density_names[0]] = '\0';
//    snprintf(buf, 9 + sizeof low_density_names[0], ""/dev/tty%.*s"", sizeof low_density_names[0], low_density_names[min]);
    break;
  case 208:  sprintf(buf, ""/dev/ttyU%d"",  min); break;
",unused,ppp1-proc2Fdevname.c
"    buf[8 + sizeof low_density_names[0]] = '\0';
//    snprintf(buf, 9 + sizeof low_density_names[0], ""/dev/tty%.*s"", sizeof low_density_names[0], low_density_names[min]);
    break;
  case 208:  sprintf(buf, ""/dev/ttyU%d"",  min); break;
  case 216:  sprintf(buf, ""/dev/ttyUB%d"",  min); break; // ""/dev/rfcomm%d"" now?
",1,unused,257,unused,"    buf[8 + sizeof low_density_names[0]] = '\0';
//    snprintf(buf, 9 + sizeof low_density_names[0], ""/dev/tty%.*s"", sizeof low_density_names[0], low_density_names[min]);
    break;
  case 208:  sprintf(buf, ""/dev/ttyU%d"",  min); break;
  case 216:  sprintf(buf, ""/dev/ttyUB%d"",  min); break; // ""/dev/rfcomm%d"" now?
",unused,ppp1-proc2Fdevname.c
"//    snprintf(buf, 9 + sizeof low_density_names[0], ""/dev/tty%.*s"", sizeof low_density_names[0], low_density_names[min]);
    break;
  case 208:  sprintf(buf, ""/dev/ttyU%d"",  min); break;
  case 216:  sprintf(buf, ""/dev/ttyUB%d"",  min); break; // ""/dev/rfcomm%d"" now?
  case 224:  sprintf(buf, ""/dev/ttyY%d"",  min); break;
",1,unused,258,unused,"//    snprintf(buf, 9 + sizeof low_density_names[0], ""/dev/tty%.*s"", sizeof low_density_names[0], low_density_names[min]);
    break;
  case 208:  sprintf(buf, ""/dev/ttyU%d"",  min); break;
  case 216:  sprintf(buf, ""/dev/ttyUB%d"",  min); break; // ""/dev/rfcomm%d"" now?
  case 224:  sprintf(buf, ""/dev/ttyY%d"",  min); break;
",unused,ppp1-proc2Fdevname.c
"    break;
  case 208:  sprintf(buf, ""/dev/ttyU%d"",  min); break;
  case 216:  sprintf(buf, ""/dev/ttyUB%d"",  min); break; // ""/dev/rfcomm%d"" now?
  case 224:  sprintf(buf, ""/dev/ttyY%d"",  min); break;
  case 227:  sprintf(buf, ""/dev/3270/tty%d"", min); break; /* bummer, HUGE */
",1,unused,259,unused,"    break;
  case 208:  sprintf(buf, ""/dev/ttyU%d"",  min); break;
  case 216:  sprintf(buf, ""/dev/ttyUB%d"",  min); break; // ""/dev/rfcomm%d"" now?
  case 224:  sprintf(buf, ""/dev/ttyY%d"",  min); break;
  case 227:  sprintf(buf, ""/dev/3270/tty%d"", min); break; /* bummer, HUGE */
",unused,ppp1-proc2Fdevname.c
"  case 208:  sprintf(buf, ""/dev/ttyU%d"",  min); break;
  case 216:  sprintf(buf, ""/dev/ttyUB%d"",  min); break; // ""/dev/rfcomm%d"" now?
  case 224:  sprintf(buf, ""/dev/ttyY%d"",  min); break;
  case 227:  sprintf(buf, ""/dev/3270/tty%d"", min); break; /* bummer, HUGE */
  case 229:  sprintf(buf, ""/dev/iseries/vtty%d"",  min); break; /* bummer, HUGE */
",1,unused,260,unused,"  case 208:  sprintf(buf, ""/dev/ttyU%d"",  min); break;
  case 216:  sprintf(buf, ""/dev/ttyUB%d"",  min); break; // ""/dev/rfcomm%d"" now?
  case 224:  sprintf(buf, ""/dev/ttyY%d"",  min); break;
  case 227:  sprintf(buf, ""/dev/3270/tty%d"", min); break; /* bummer, HUGE */
  case 229:  sprintf(buf, ""/dev/iseries/vtty%d"",  min); break; /* bummer, HUGE */
",unused,ppp1-proc2Fdevname.c
"  case 216:  sprintf(buf, ""/dev/ttyUB%d"",  min); break; // ""/dev/rfcomm%d"" now?
  case 224:  sprintf(buf, ""/dev/ttyY%d"",  min); break;
  case 227:  sprintf(buf, ""/dev/3270/tty%d"", min); break; /* bummer, HUGE */
  case 229:  sprintf(buf, ""/dev/iseries/vtty%d"",  min); break; /* bummer, HUGE */
  case 256:  sprintf(buf, ""/dev/ttyEQ%d"",  min); break;
",1,unused,261,unused,"  case 216:  sprintf(buf, ""/dev/ttyUB%d"",  min); break; // ""/dev/rfcomm%d"" now?
  case 224:  sprintf(buf, ""/dev/ttyY%d"",  min); break;
  case 227:  sprintf(buf, ""/dev/3270/tty%d"", min); break; /* bummer, HUGE */
  case 229:  sprintf(buf, ""/dev/iseries/vtty%d"",  min); break; /* bummer, HUGE */
  case 256:  sprintf(buf, ""/dev/ttyEQ%d"",  min); break;
",unused,ppp1-proc2Fdevname.c
"static int link_name(char *restrict const buf, unsigned maj, unsigned min, int pid, const char *restrict name){
  struct stat sbuf;
  char path[32];
  int count;
  sprintf(path, ""/proc/%d/%s"", pid, name);  /* often permission denied */
",1,unused,278,unused,"static int link_name(char *restrict const buf, unsigned maj, unsigned min, int pid, const char *restrict name){
  struct stat sbuf;
  char path[32];
  int count;
  sprintf(path, ""/proc/%d/%s"", pid, name);  /* often permission denied */
",unused,ppp1-proc2Fdevname.c
"  if( guess_name(tmp, MAJOR_OF(dev), MINOR_OF(dev)               )) goto abbrev;
  if(  link_name(tmp, MAJOR_OF(dev), MINOR_OF(dev), pid, ""fd/255"")) goto abbrev;
  // fall through if unable to find a device file
no_tty:
  strcpy(ret, ""?"");
",1,unused,302,unused,"  if( guess_name(tmp, MAJOR_OF(dev), MINOR_OF(dev)               )) goto abbrev;
  if(  link_name(tmp, MAJOR_OF(dev), MINOR_OF(dev), pid, ""fd/255"")) goto abbrev;
  // fall through if unable to find a device file
no_tty:
  strcpy(ret, ""?"");
",unused,ppp1-proc2Fdevname.c
"    *p = (struct pwbuf *) xmalloc(sizeof(struct pwbuf));
    (*p)->uid = uid;
    pw = getpwuid(uid);
    if(!pw || strlen(pw->pw_name) >= P_G_SZ)
	sprintf((*p)->name, ""%u"", uid);
",1,unused,58,unused,"    *p = (struct pwbuf *) xmalloc(sizeof(struct pwbuf));
    (*p)->uid = uid;
    pw = getpwuid(uid);
    if(!pw || strlen(pw->pw_name) >= P_G_SZ)
	sprintf((*p)->name, ""%u"", uid);
",unused,ppp1-proc2Fpwcache.c
"    pw = getpwuid(uid);
    if(!pw || strlen(pw->pw_name) >= P_G_SZ)
	sprintf((*p)->name, ""%u"", uid);
    else
        strcpy((*p)->name, pw->pw_name);
",1,unused,60,unused,"    pw = getpwuid(uid);
    if(!pw || strlen(pw->pw_name) >= P_G_SZ)
	sprintf((*p)->name, ""%u"", uid);
    else
        strcpy((*p)->name, pw->pw_name);
",unused,ppp1-proc2Fpwcache.c
"    *g = (struct grpbuf *) xmalloc(sizeof(struct grpbuf));
    (*g)->gid = gid;
    gr = getgrgid(gid);
    if (!gr || strlen(gr->gr_name) >= P_G_SZ)
        sprintf((*g)->name, ""%u"", gid);
",1,unused,86,unused,"    *g = (struct grpbuf *) xmalloc(sizeof(struct grpbuf));
    (*g)->gid = gid;
    gr = getgrgid(gid);
    if (!gr || strlen(gr->gr_name) >= P_G_SZ)
        sprintf((*g)->name, ""%u"", gid);
",unused,ppp1-proc2Fpwcache.c
"    gr = getgrgid(gid);
    if (!gr || strlen(gr->gr_name) >= P_G_SZ)
        sprintf((*g)->name, ""%u"", gid);
    else
        strcpy((*g)->name, gr->gr_name);
",1,unused,88,unused,"    gr = getgrgid(gid);
    if (!gr || strlen(gr->gr_name) >= P_G_SZ)
        sprintf((*g)->name, ""%u"", gid);
    else
        strcpy((*g)->name, gr->gr_name);
",unused,ppp1-proc2Fpwcache.c
"       buffer will likely soon be used for another subdirectory anyway
       ( besides, with this xcalloc we will never need to use memcpy ) */
    if (ub->buf) ub->buf[0] = '\0';
    else ub->buf = xcalloc((ub->siz = buffGRW));
    sprintf(path, ""%s/%s"", directory, what);
",1,unused,645,unused,"       buffer will likely soon be used for another subdirectory anyway
       ( besides, with this xcalloc we will never need to use memcpy ) */
    if (ub->buf) ub->buf[0] = '\0';
    else ub->buf = xcalloc((ub->siz = buffGRW));
    sprintf(path, ""%s/%s"", directory, what);
",unused,ppp1-proc2Freadproc.c
"    char *p, *rbuf = 0, *endbuf, **q, **ret;
    int fd, tot = 0, n, c, end_of_file = 0;
    int align;

    sprintf(buf, ""%s/%s"", directory, what);
",1,unused,665,unused,"    char *p, *rbuf = 0, *endbuf, **q, **ret;
    int fd, tot = 0, n, c, end_of_file = 0;
    int align;

    sprintf(buf, ""%s/%s"", directory, what);
",unused,ppp1-proc2Freadproc.c
"  }
  p->tgid = strtoul(ent->d_name, NULL, 10);
  p->tid = p->tgid;
  memcpy(path, ""/proc/"", 6);
  strcpy(path+6, ent->d_name);  // trust /proc to not contain evil top-level entries
",1,unused,1179,unused,"  }
  p->tgid = strtoul(ent->d_name, NULL, 10);
  p->tid = p->tgid;
  memcpy(path, ""/proc/"", 6);
  strcpy(path+6, ent->d_name);  // trust /proc to not contain evil top-level entries
",unused,ppp1-proc2Freadproc.c
"    struct utlbuf_s ub = { NULL, 0 };
    static char path[32];
    struct stat statbuf;

    sprintf(path, ""/proc/%d"", pid);
",1,unused,1590,unused,"    struct utlbuf_s ub = { NULL, 0 };
    static char path[32];
    struct stat statbuf;

    sprintf(path, ""/proc/%d"", pid);
",unused,ppp1-proc2Freadproc.c
"  while(n--){
    if(sigtable[n].num==signo) return sigtable[n].name;
  }
  if(signo == SIGRTMIN) return ""RTMIN"";
  if(signo) sprintf(buf, ""RTMIN+%d"", signo-SIGRTMIN);
",1,unused,170,unused,"  while(n--){
    if(sigtable[n].num==signo) return sigtable[n].name;
  }
  if(signo == SIGRTMIN) return ""RTMIN"";
  if(signo) sprintf(buf, ""RTMIN+%d"", signo-SIGRTMIN);
",unused,ppp1-proc2Fsig.c
"    if(sigtable[n].num==signo) return sigtable[n].name;
  }
  if(signo == SIGRTMIN) return ""RTMIN"";
  if(signo) sprintf(buf, ""RTMIN+%d"", signo-SIGRTMIN);
  else      strcpy(buf,""0"");  /* AIX has NULL; Solaris has EXIT */
",1,unused,171,unused,"    if(sigtable[n].num==signo) return sigtable[n].name;
  }
  if(signo == SIGRTMIN) return ""RTMIN"";
  if(signo) sprintf(buf, ""RTMIN+%d"", signo-SIGRTMIN);
  else      strcpy(buf,""0"");  /* AIX has NULL; Solaris has EXIT */
",unused,ppp1-proc2Fsig.c
"        fprintf(stderr, ""Signal \""%s\"" not known.\n"", txt);
        ret = 1;
        goto end;
      }
      amt = sprintf(tmpbuf, ""%s"", signal_number_to_name(val));
",1,unused,193,unused,"        fprintf(stderr, ""Signal \""%s\"" not known.\n"", txt);
        ret = 1;
        goto end;
      }
      amt = sprintf(tmpbuf, ""%s"", signal_number_to_name(val));
",unused,ppp1-proc2Fsig.c
"        fprintf(stderr, ""Signal \""%s\"" not known.\n"", txt);
        ret = 1;
        goto end;
      }
      amt = sprintf(tmpbuf, ""%d"", sno);
",1,unused,202,unused,"        fprintf(stderr, ""Signal \""%s\"" not known.\n"", txt);
        ret = 1;
        goto end;
      }
      amt = sprintf(tmpbuf, ""%d"", sno);
",unused,ppp1-proc2Fsig.c
"      amt = sprintf(tmpbuf, ""%d"", sno);
    }

    if(!place){
      strcpy(buf,tmpbuf);
",1,unused,206,unused,"      amt = sprintf(tmpbuf, ""%d"", sno);
    }

    if(!place){
      strcpy(buf,tmpbuf);
",unused,ppp1-proc2Fsig.c
"      goto end;
    }
    if(amt+place+1 > max_line){
      printf(""%s\n"", buf);
      strcpy(buf,tmpbuf);
",1,unused,212,unused,"      goto end;
    }
    if(amt+place+1 > max_line){
      printf(""%s\n"", buf);
      strcpy(buf,tmpbuf);
",unused,ppp1-proc2Fsig.c
"      strcpy(buf,tmpbuf);
      place = amt;
      goto end;
    }
    sprintf(buf+place, "" %s"", tmpbuf);
",1,unused,216,unused,"      strcpy(buf,tmpbuf);
      place = amt;
      goto end;
    }
    sprintf(buf+place, "" %s"", tmpbuf);
",unused,ppp1-proc2Fsig.c
"
  if (!human_readable) {
    time(&realseconds);
    realtime = localtime(&realseconds);
    pos = sprintf(buf, "" %02d:%02d:%02d "",
",1,unused,59,unused,"
  if (!human_readable) {
    time(&realseconds);
    realtime = localtime(&realseconds);
    pos = sprintf(buf, "" %02d:%02d:%02d "",
",unused,ppp1-proc2Fwhattime.c
"  }
  else
    updays = (int) uptime_secs / (60*60*24);

  strcat (buf, ""up "");
",1,unused,78,unused,"  }
  else
    updays = (int) uptime_secs / (60*60*24);

  strcat (buf, ""up "");
",unused,ppp1-proc2Fwhattime.c
"  pos += 3;

  if (!human_readable) {
    if (updays)
      pos += sprintf(buf + pos, ""%d day%s, "", updays, (updays != 1) ? ""s"" : """");
",1,unused,83,unused,"  pos += 3;

  if (!human_readable) {
    if (updays)
      pos += sprintf(buf + pos, ""%d day%s, "", updays, (updays != 1) ? ""s"" : """");
",unused,ppp1-proc2Fwhattime.c
"  upminutes = upminutes % 60;

  if (!human_readable) {
    if(uphours)
      pos += sprintf(buf + pos, ""%2d:%02d, "", uphours, upminutes);
",1,unused,93,unused,"  upminutes = upminutes % 60;

  if (!human_readable) {
    if(uphours)
      pos += sprintf(buf + pos, ""%2d:%02d, "", uphours, upminutes);
",unused,ppp1-proc2Fwhattime.c
"  if (!human_readable) {
    if(uphours)
      pos += sprintf(buf + pos, ""%2d:%02d, "", uphours, upminutes);
    else
      pos += sprintf(buf + pos, ""%d min, "", upminutes);
",1,unused,95,unused,"  if (!human_readable) {
    if(uphours)
      pos += sprintf(buf + pos, ""%2d:%02d, "", uphours, upminutes);
    else
      pos += sprintf(buf + pos, ""%d min, "", upminutes);
",unused,ppp1-proc2Fwhattime.c
"        numuser++;
    }
    endutent();

    pos += sprintf(buf + pos, ""%2d user%s, "", numuser, numuser == 1 ? """" : ""s"");
",1,unused,108,unused,"        numuser++;
    }
    endutent();

    pos += sprintf(buf + pos, ""%2d user%s, "", numuser, numuser == 1 ? """" : ""s"");
",unused,ppp1-proc2Fwhattime.c
"    pos += sprintf(buf + pos, ""%2d user%s, "", numuser, numuser == 1 ? """" : ""s"");

    loadavg(&av[0], &av[1], &av[2]);

    pos += sprintf(buf + pos, "" load average: %.2f, %.2f, %.2f"",
",1,unused,112,unused,"    pos += sprintf(buf + pos, ""%2d user%s, "", numuser, numuser == 1 ? """" : ""s"");

    loadavg(&av[0], &av[1], &av[2]);

    pos += sprintf(buf + pos, "" load average: %.2f, %.2f, %.2f"",
",unused,ppp1-proc2Fwhattime.c
"  if (human_readable) {
    comma = 0;

    if (updecades) {
      pos += sprintf(buf + pos, ""%d %s"", updecades,
",1,unused,120,unused,"  if (human_readable) {
    comma = 0;

    if (updecades) {
      pos += sprintf(buf + pos, ""%d %s"", updecades,
",unused,ppp1-proc2Fwhattime.c
"      comma += 1;
    }

    if (upyears) {
      pos += sprintf(buf + pos, ""%s%d %s"", comma > 0 ? "", "" : """", upyears,
",1,unused,126,unused,"      comma += 1;
    }

    if (upyears) {
      pos += sprintf(buf + pos, ""%s%d %s"", comma > 0 ? "", "" : """", upyears,
",unused,ppp1-proc2Fwhattime.c
"      comma += 1;
    }

    if (upweeks) {
      pos += sprintf(buf + pos, ""%s%d %s"", comma > 0 ? "", "" : """", upweeks,
",1,unused,132,unused,"      comma += 1;
    }

    if (upweeks) {
      pos += sprintf(buf + pos, ""%s%d %s"", comma > 0 ? "", "" : """", upweeks,
",unused,ppp1-proc2Fwhattime.c
"      comma += 1;
    }

    if (updays) {
      pos += sprintf(buf + pos, ""%s%d %s"", comma > 0 ? "", "" : """", updays,
",1,unused,138,unused,"      comma += 1;
    }

    if (updays) {
      pos += sprintf(buf + pos, ""%s%d %s"", comma > 0 ? "", "" : """", updays,
",unused,ppp1-proc2Fwhattime.c
"      comma += 1;
    }

    if (uphours) {
      pos += sprintf(buf + pos, ""%s%d %s"", comma > 0 ? "", "" : """", uphours,
",1,unused,144,unused,"      comma += 1;
    }

    if (uphours) {
      pos += sprintf(buf + pos, ""%s%d %s"", comma > 0 ? "", "" : """", uphours,
",unused,ppp1-proc2Fwhattime.c
"      comma += 1;
    }

    if (upminutes) {
      pos += sprintf(buf + pos, ""%s%d %s"", comma > 0 ? "", "" : """", upminutes,
",1,unused,150,unused,"      comma += 1;
    }

    if (upminutes) {
      pos += sprintf(buf + pos, ""%s%d %s"", comma > 0 ? "", "" : """", upminutes,
",unused,ppp1-proc2Fwhattime.c
"  /* Arrrgh! somebody defined unix as 1 */
  if(forest_type == 'u') goto unixy;
  while(*p){
    switch(*p){
    case ' ': strcpy(q, ""    "");  break;
",1,unused,345,unused,"  /* Arrrgh! somebody defined unix as 1 */
  if(forest_type == 'u') goto unixy;
  while(*p){
    switch(*p){
    case ' ': strcpy(q, ""    "");  break;
",unused,ppp1-ps2Foutput.c
"  if(forest_type == 'u') goto unixy;
  while(*p){
    switch(*p){
    case ' ': strcpy(q, ""    "");  break;
    case 'L': strcpy(q, "" \\_ ""); break;
",1,unused,346,unused,"  if(forest_type == 'u') goto unixy;
  while(*p){
    switch(*p){
    case ' ': strcpy(q, ""    "");  break;
    case 'L': strcpy(q, "" \\_ ""); break;
",unused,ppp1-ps2Foutput.c
"  while(*p){
    switch(*p){
    case ' ': strcpy(q, ""    "");  break;
    case 'L': strcpy(q, "" \\_ ""); break;
    case '+': strcpy(q, "" \\_ ""); break;
",1,unused,347,unused,"  while(*p){
    switch(*p){
    case ' ': strcpy(q, ""    "");  break;
    case 'L': strcpy(q, "" \\_ ""); break;
    case '+': strcpy(q, "" \\_ ""); break;
",unused,ppp1-ps2Foutput.c
"    switch(*p){
    case ' ': strcpy(q, ""    "");  break;
    case 'L': strcpy(q, "" \\_ ""); break;
    case '+': strcpy(q, "" \\_ ""); break;
    case '|': strcpy(q, "" |  "");  break;
",1,unused,348,unused,"    switch(*p){
    case ' ': strcpy(q, ""    "");  break;
    case 'L': strcpy(q, "" \\_ ""); break;
    case '+': strcpy(q, "" \\_ ""); break;
    case '|': strcpy(q, "" |  "");  break;
",unused,ppp1-ps2Foutput.c
"  return q-outbuf;   /* gcc likes this here */
unixy:
  while(*p){
    switch(*p){
    case ' ': strcpy(q, ""  ""); break;
",1,unused,363,unused,"  return q-outbuf;   /* gcc likes this here */
unixy:
  while(*p){
    switch(*p){
    case ' ': strcpy(q, ""  ""); break;
",unused,ppp1-ps2Foutput.c
"unixy:
  while(*p){
    switch(*p){
    case ' ': strcpy(q, ""  ""); break;
    case 'L': strcpy(q, ""  ""); break;
",1,unused,364,unused,"unixy:
  while(*p){
    switch(*p){
    case ' ': strcpy(q, ""  ""); break;
    case 'L': strcpy(q, ""  ""); break;
",unused,ppp1-ps2Foutput.c
"  while(*p){
    switch(*p){
    case ' ': strcpy(q, ""  ""); break;
    case 'L': strcpy(q, ""  ""); break;
    case '+': strcpy(q, ""  ""); break;
",1,unused,365,unused,"  while(*p){
    switch(*p){
    case ' ': strcpy(q, ""  ""); break;
    case 'L': strcpy(q, ""  ""); break;
    case '+': strcpy(q, ""  ""); break;
",unused,ppp1-ps2Foutput.c
"    switch(*p){
    case ' ': strcpy(q, ""  ""); break;
    case 'L': strcpy(q, ""  ""); break;
    case '+': strcpy(q, ""  ""); break;
    case '|': strcpy(q, ""  ""); break;
",1,unused,366,unused,"    switch(*p){
    case ' ': strcpy(q, ""  ""); break;
    case 'L': strcpy(q, ""  ""); break;
    case '+': strcpy(q, ""  ""); break;
    case '|': strcpy(q, ""  ""); break;
",unused,ppp1-ps2Foutput.c
"  time_t seconds_ago;
  start = getbtime() + pp->start_time / Hertz;
  seconds_ago = seconds_since_1970 - start;
  if(seconds_ago < 0) seconds_ago=0;
  if(seconds_ago > 3600*24)  strcpy(outbuf, ctime(&start)+4);
",1,unused,879,unused,"  time_t seconds_ago;
  start = getbtime() + pp->start_time / Hertz;
  seconds_ago = seconds_since_1970 - start;
  if(seconds_ago < 0) seconds_ago=0;
  if(seconds_ago > 3600*24)  strcpy(outbuf, ctime(&start)+4);
",unused,ppp1-ps2Foutput.c
"  start = getbtime() + pp->start_time / Hertz;
  seconds_ago = seconds_since_1970 - start;
  if(seconds_ago < 0) seconds_ago=0;
  if(seconds_ago > 3600*24)  strcpy(outbuf, ctime(&start)+4);
  else                       strcpy(outbuf, ctime(&start)+10);
",1,unused,880,unused,"  start = getbtime() + pp->start_time / Hertz;
  seconds_ago = seconds_since_1970 - start;
  if(seconds_ago < 0) seconds_ago=0;
  if(seconds_ago > 3600*24)  strcpy(outbuf, ctime(&start)+4);
  else                       strcpy(outbuf, ctime(&start)+10);
",unused,ppp1-ps2Foutput.c
"//		    active_cols, max_rightward, max_leftward, actual, correct);

    /* prepare data and calculate leftpad */
    if(likely(p) && likely(fmt->pr)) amount = (*fmt->pr)(outbuf,p);
    else amount = strlen(strcpy(outbuf, fmt->name)); /* AIX or headers */
",1,unused,1997,unused,"//		    active_cols, max_rightward, max_leftward, actual, correct);

    /* prepare data and calculate leftpad */
    if(likely(p) && likely(fmt->pr)) amount = (*fmt->pr)(outbuf,p);
    else amount = strlen(strcpy(outbuf, fmt->name)); /* AIX or headers */
",unused,ppp1-ps2Foutput.c
"	int i;
	if (pid == my_pid || pid == 0)
		return;
	/* pid (cmd) state ppid pgrp session tty */
	sprintf(buf, ""/proc/%d/stat"", pid);
",1,unused,180,unused,"	int i;
	if (pid == my_pid || pid == 0)
		return;
	/* pid (cmd) state ppid pgrp session tty */
	sprintf(buf, ""/proc/%d/stat"", pid);
",unused,ppp1-skill.c
"	slashdot(outname, '/', '.');

	/* used to open the file */
	tmpname = xmalloc(strlen(name) + strlen(PROC_PATH) + 2);
	strcpy(tmpname, PROC_PATH);
",1,unused,182,unused,"	slashdot(outname, '/', '.');

	/* used to open the file */
	tmpname = xmalloc(strlen(name) + strlen(PROC_PATH) + 2);
	strcpy(tmpname, PROC_PATH);
",unused,ppp1-sysctl.c
"
	/* used to open the file */
	tmpname = xmalloc(strlen(name) + strlen(PROC_PATH) + 2);
	strcpy(tmpname, PROC_PATH);
	strcat(tmpname, name);
",1,unused,183,unused,"
	/* used to open the file */
	tmpname = xmalloc(strlen(name) + strlen(PROC_PATH) + 2);
	strcpy(tmpname, PROC_PATH);
	strcat(tmpname, name);
",unused,ppp1-sysctl.c
"			tmpdir =
			    (char *restrict) xmalloc(strlen(path) +
						     strlen(de->d_name) +
						     2);
			sprintf(tmpdir, ""%s%s"", path, de->d_name);
",1,unused,330,unused,"			tmpdir =
			    (char *restrict) xmalloc(strlen(path) +
						     strlen(de->d_name) +
						     2);
			sprintf(tmpdir, ""%s%s"", path, de->d_name);
",unused,ppp1-sysctl.c
"			if (rc2 != 0) {
				xwarn(_(""cannot stat %s""), tmpdir);
			} else {
				if (S_ISDIR(ts.st_mode)) {
					strcat(tmpdir, ""/"");
",1,unused,336,unused,"			if (rc2 != 0) {
				xwarn(_(""cannot stat %s""), tmpdir);
			} else {
				if (S_ISDIR(ts.st_mode)) {
					strcat(tmpdir, ""/"");
",unused,ppp1-sysctl.c
"	}

	/* used to open the file */
	tmpname = xmalloc(equals - name + 1 + strlen(PROC_PATH));
	strcpy(tmpname, PROC_PATH);
",1,unused,389,unused,"	}

	/* used to open the file */
	tmpname = xmalloc(equals - name + 1 + strlen(PROC_PATH));
	strcpy(tmpname, PROC_PATH);
",unused,ppp1-sysctl.c
"			while ((*value == ' ' || *value == '\t') && *value != 0)
				value++;

			/* should NameOnly affect this? */
			sprintf(buffer, ""%s=%s"", name, value);
",1,unused,563,unused,"			while ((*value == ' ' || *value == '\t') && *value != 0)
				value++;

			/* should NameOnly affect this? */
			sprintf(buffer, ""%s=%s"", name, value);
",unused,ppp1-sysctl.c
"					    strlen(de->d_name) * 2 + 2 +
					    strlen(dirs[di]) + 1);
				cfgs[ncfgs]->name =
				    (char *)cfgs[ncfgs] + sizeof(struct pair);
				strcpy(cfgs[ncfgs]->name, de->d_name);
",1,unused,635,unused,"					    strlen(de->d_name) * 2 + 2 +
					    strlen(dirs[di]) + 1);
				cfgs[ncfgs]->name =
				    (char *)cfgs[ncfgs] + sizeof(struct pair);
				strcpy(cfgs[ncfgs]->name, de->d_name);
",unused,ppp1-sysctl.c
"				strcpy(cfgs[ncfgs]->name, de->d_name);
				cfgs[ncfgs]->value =
				    (char *)cfgs[ncfgs] + sizeof(struct pair) +
				    strlen(cfgs[ncfgs]->name) + 1;
				sprintf(cfgs[ncfgs]->value, ""%s/%s"", dirs[di],
",1,unused,639,unused,"				strcpy(cfgs[ncfgs]->name, de->d_name);
				cfgs[ncfgs]->value =
				    (char *)cfgs[ncfgs] + sizeof(struct pair) +
				    strlen(cfgs[ncfgs]->name) + 1;
				sprintf(cfgs[ncfgs]->value, ""%s/%s"", dirs[di],
",unused,ppp1-sysctl.c
"
			for (row = nrows - 2; row >= 0; --row)
				*(screen + row * ncols + col) = ' ';
		}
		i = sprintf(screen, "" %.2f, %.2f, %.2f"", av[0], av[1], av[2]);
",1,unused,206,unused,"
			for (row = nrows - 2; row >= 0; --row)
				*(screen + row * ncols + col) = ' ';
		}
		i = sprintf(screen, "" %.2f, %.2f, %.2f"", av[0], av[1], av[2]);
",unused,ppp1-tload.c
"		}
		if (ut_addr_v6[1] || ut_addr_v6[2] || ut_addr_v6[3]) {
			/* IPv6 */
			if (!inet_ntop(AF_INET6, &ut_addr_v6, buf_ipv6, sizeof(buf_ipv6))) {
				strcpy(buf, """"); /* invalid address, clean the buffer */
",1,unused,205,unused,"		}
		if (ut_addr_v6[1] || ut_addr_v6[2] || ut_addr_v6[3]) {
			/* IPv6 */
			if (!inet_ntop(AF_INET6, &ut_addr_v6, buf_ipv6, sizeof(buf_ipv6))) {
				strcpy(buf, """"); /* invalid address, clean the buffer */
",unused,ppp1-w.c
"			}
		} else {
			/* IPv4 */
			if (!(ut_addr_v6[0] && inet_ntop(AF_INET, &ut_addr_v6[0], buf, sizeof(buf)))) {
				strcpy(buf, """"); /* invalid address, clean the buffer */
",1,unused,212,unused,"			}
		} else {
			/* IPv4 */
			if (!(ut_addr_v6[0] && inet_ntop(AF_INET, &ut_addr_v6[0], buf, sizeof(buf)))) {
				strcpy(buf, """"); /* invalid address, clean the buffer */
",unused,ppp1-w.c
"{
	/* Bitcoin appends ""01"" to indicate the pubkey is compressed. */
	char *str = tal_arr(ctx, char, hex_str_size(sizeof(*secret) + 1));
	hex_encode(secret, sizeof(*secret), str, hex_str_size(sizeof(*secret)));
	strcat(str, ""01"");
",1,unused,12,unused,"{
	/* Bitcoin appends ""01"" to indicate the pubkey is compressed. */
	char *str = tal_arr(ctx, char, hex_str_size(sizeof(*secret) + 1));
	hex_encode(secret, sizeof(*secret), str, hex_str_size(sizeof(*secret)));
	strcat(str, ""01"");
",unused,practicalswift-lightning-bitcoin2Fprivkey.c
"
	fd = socket(AF_UNIX, SOCK_STREAM, 0);
	if (strlen(rpc_filename) + 1 > sizeof(addr.sun_path))
		errx(ERROR_USAGE, ""rpc filename '%s' too long"", rpc_filename);
	strcpy(addr.sun_path, rpc_filename);
",1,unused,349,unused,"
	fd = socket(AF_UNIX, SOCK_STREAM, 0);
	if (strlen(rpc_filename) + 1 > sizeof(addr.sun_path))
		errx(ERROR_USAGE, ""rpc filename '%s' too long"", rpc_filename);
	strcpy(addr.sun_path, rpc_filename);
",unused,practicalswift-lightning-cli2Flightning-cli.c
"			   sizeof(HEADER)
			   + sizeof(LOG_ENTRY) * NUM_ENTRIES
			   + sizeof(TAILER));

	strcpy(response, HEADER);
",1,unused,97,unused,"			   sizeof(HEADER)
			   + sizeof(LOG_ENTRY) * NUM_ENTRIES
			   + sizeof(TAILER));

	strcpy(response, HEADER);
",unused,practicalswift-lightning-cli2Ftest2Frun-large-input.c
"			return false;
		}
		/* Zero it out for passing across the wire */
		memset(addr->u.sockname, 0, sizeof(addr->u.sockname));
		strcpy(addr->u.sockname, arg);
",1,unused,433,unused,"			return false;
		}
		/* Zero it out for passing across the wire */
		memset(addr->u.sockname, 0, sizeof(addr->u.sockname));
		strcpy(addr->u.sockname, arg);
",unused,practicalswift-lightning-common2Fwireaddr.c
"	if (strlen(name) >= sizeof(addr->u.unresolved.name))
		return false;

	memset(addr->u.unresolved.name, 0, sizeof(addr->u.unresolved.name));
	strcpy(addr->u.unresolved.name, name);
",1,unused,488,unused,"	if (strlen(name) >= sizeof(addr->u.unresolved.name))
		return false;

	memset(addr->u.unresolved.name, 0, sizeof(addr->u.unresolved.name));
	strcpy(addr->u.unresolved.name, name);
",unused,practicalswift-lightning-common2Fwireaddr.c
"        r = fscanf(scidf, ""%5s ,%8s\n"", title, &title[6]);
	if (r != 2 || strcmp(title, ""scid"") != 0 || strcmp(&title[6], ""satoshis"") != 0)
		err(1, ""reading 'scid ,satoshis' from csv failed"");

        while(fscanf(scidf, ""%s ,%""SCNu64""\n"", str, &scidsats[i].sat.satoshis) == 2 ) { /* Raw: read from file */
",1,unused,44,unused,"        r = fscanf(scidf, ""%5s ,%8s\n"", title, &title[6]);
	if (r != 2 || strcmp(title, ""scid"") != 0 || strcmp(&title[6], ""satoshis"") != 0)
		err(1, ""reading 'scid ,satoshis' from csv failed"");

        while(fscanf(scidf, ""%s ,%""SCNu64""\n"", str, &scidsats[i].sat.satoshis) == 2 ) { /* Raw: read from file */
",unused,practicalswift-lightning-devtools2Fcreate-gossipstore.c
"	struct short_channel_id scid;
        struct amount_sat sat;
} scidsat;

/* read scid,satoshis csv file and create return an array of scidsat pointers */
",1,unused,26,unused,"	struct short_channel_id scid;
        struct amount_sat sat;
} scidsat;

/* read scid,satoshis csv file and create return an array of scidsat pointers */
",unused,practicalswift-lightning-devtools2Fcreate-gossipstore.c
"static struct scidsat *load_csv_file(FILE *scidf)
{
        int n, r;
	char title[15];
	int i = 0;
",1,unused,31,unused,"static struct scidsat *load_csv_file(FILE *scidf)
{
        int n, r;
	char title[15];
	int i = 0;
",unused,practicalswift-lightning-devtools2Fcreate-gossipstore.c
"		errx(1, ""domain socket creation failed"");
	}
	if (strlen(rpc_filename) + 1 > sizeof(addr.sun_path))
		errx(1, ""rpc filename '%s' too long"", rpc_filename);
	strcpy(addr.sun_path, rpc_filename);
",1,unused,899,unused,"		errx(1, ""domain socket creation failed"");
	}
	if (strlen(rpc_filename) + 1 > sizeof(addr.sun_path))
		errx(1, ""rpc filename '%s' too long"", rpc_filename);
	strcpy(addr.sun_path, rpc_filename);
",unused,practicalswift-lightning-lightningd2Fjsonrpc.c
"			       version() + strlen(version()) - taillen);
#endif
		assert(strlen(name) <= 32);
		ld->alias = tal_arrz(ld, u8, 33);
		strcpy((char*)ld->alias, name);
",1,unused,876,unused,"			       version() + strlen(version()) - taillen);
#endif
		assert(strlen(name) <= 32);
		ld->alias = tal_arrz(ld, u8, 33);
		strcpy((char*)ld->alias, name);
",unused,practicalswift-lightning-lightningd2Foptions.c
"	double small = 0.00000001;
	*theta = 0;
	*theta1 = 0;
	zeros_vector(v2);
	strcpy(error, ""ok"");
",1,unused,42,unused,"	double small = 0.00000001;
	*theta = 0;
	*theta1 = 0;
	zeros_vector(v2);
	strcpy(error, ""ok"");
",unused,preliminaryorbitdetermination-gibbs.c
"	unit(r1,r1n);
	*copa = asin(dot(pn,r1n));

	if ( fabs(dot(r1n,pn)) > 0.017452406 ) {
		strcpy(error, ""not coplanar"");
",1,unused,59,unused,"	unit(r1,r1n);
	*copa = asin(dot(pn,r1n));

	if ( fabs(dot(r1n,pn)) > 0.017452406 ) {
		strcpy(error, ""not coplanar"");
",unused,preliminaryorbitdetermination-gibbs.c
"	// determine if  the orbit is possible. both d and n must be in
	// the same direction, and non-zero.
	// -------------------------------------------------------------
	if ( ( fabs(magd)<small ) || ( fabs(magn)<small ) || ( dot(nn,dn) < small ) ){
		strcpy(error, ""impossible"");
",1,unused,89,unused,"	// determine if  the orbit is possible. both d and n must be in
	// the same direction, and non-zero.
	// -------------------------------------------------------------
	if ( ( fabs(magd)<small ) || ( fabs(magn)<small ) || ( dot(nn,dn) < small ) ){
		strcpy(error, ""impossible"");
",unused,preliminaryorbitdetermination-gibbs.c
"	double small = 0.00000001;
	*theta = 0;
	*theta1 = 0;
	zeros_vector(v2);
	strcpy(error, ""ok"");
",1,unused,42,unused,"	double small = 0.00000001;
	*theta = 0;
	*theta1 = 0;
	zeros_vector(v2);
	strcpy(error, ""ok"");
",unused,preliminaryorbitdetermination-gibbs.c
"	unit(r1,r1n);
	*copa = asin(dot(pn,r1n));

	if ( fabs(dot(r1n,pn)) > 0.017452406 ) {
		strcpy(error, ""not coplanar"");
",1,unused,59,unused,"	unit(r1,r1n);
	*copa = asin(dot(pn,r1n));

	if ( fabs(dot(r1n,pn)) > 0.017452406 ) {
		strcpy(error, ""not coplanar"");
",unused,preliminaryorbitdetermination-gibbs.c
"	// determine if  the orbit is possible. both d and n must be in
	// the same direction, and non-zero.
	// -------------------------------------------------------------
	if ( ( fabs(magd)<small ) || ( fabs(magn)<small ) || ( dot(nn,dn) < small ) ){
		strcpy(error, ""impossible"");
",1,unused,89,unused,"	// determine if  the orbit is possible. both d and n must be in
	// the same direction, and non-zero.
	// -------------------------------------------------------------
	if ( ( fabs(magd)<small ) || ( fabs(magn)<small ) || ( dot(nn,dn) < small ) ){
		strcpy(error, ""impossible"");
",unused,preliminaryorbitdetermination-gibbs.c
"        char typeorbit[]= ""ei"";
        if ( *ecc < small ){
            // ----------------  circular equatorial ---------------
            if  ((*incl<small) || (fabs(*incl-M_PI)<small)){
                strcpy(typeorbit,""ce"");
",1,unused,103,unused,"        char typeorbit[]= ""ei"";
        if ( *ecc < small ){
            // ----------------  circular equatorial ---------------
            if  ((*incl<small) || (fabs(*incl-M_PI)<small)){
                strcpy(typeorbit,""ce"");
",unused,preliminaryorbitdetermination-rv2coe.c
"            if  ((*incl<small) || (fabs(*incl-M_PI)<small)){
                strcpy(typeorbit,""ce"");
              }else{
                // --------------  circular inclined ---------------
                strcpy(typeorbit,""ci"");
",1,unused,106,unused,"            if  ((*incl<small) || (fabs(*incl-M_PI)<small)){
                strcpy(typeorbit,""ce"");
              }else{
                // --------------  circular inclined ---------------
                strcpy(typeorbit,""ci"");
",unused,preliminaryorbitdetermination-rv2coe.c
"            }
          }else{
            // - elliptical, parabolic, hyperbolic equatorial --
            if  ((*incl<small) || (fabs(*incl-M_PI)<small)){
                strcpy(typeorbit,""ee"");
",1,unused,111,unused,"            }
          }else{
            // - elliptical, parabolic, hyperbolic equatorial --
            if  ((*incl<small) || (fabs(*incl-M_PI)<small)){
                strcpy(typeorbit,""ee"");
",unused,preliminaryorbitdetermination-rv2coe.c
"        char typeorbit[]= ""ei"";
        if ( *ecc < small ){
            // ----------------  circular equatorial ---------------
            if  ((*incl<small) || (fabs(*incl-M_PI)<small)){
                strcpy(typeorbit,""ce"");
",1,unused,103,unused,"        char typeorbit[]= ""ei"";
        if ( *ecc < small ){
            // ----------------  circular equatorial ---------------
            if  ((*incl<small) || (fabs(*incl-M_PI)<small)){
                strcpy(typeorbit,""ce"");
",unused,preliminaryorbitdetermination-rv2coe.c
"            if  ((*incl<small) || (fabs(*incl-M_PI)<small)){
                strcpy(typeorbit,""ce"");
              }else{
                // --------------  circular inclined ---------------
                strcpy(typeorbit,""ci"");
",1,unused,106,unused,"            if  ((*incl<small) || (fabs(*incl-M_PI)<small)){
                strcpy(typeorbit,""ce"");
              }else{
                // --------------  circular inclined ---------------
                strcpy(typeorbit,""ci"");
",unused,preliminaryorbitdetermination-rv2coe.c
"            }
          }else{
            // - elliptical, parabolic, hyperbolic equatorial --
            if  ((*incl<small) || (fabs(*incl-M_PI)<small)){
                strcpy(typeorbit,""ee"");
",1,unused,111,unused,"            }
          }else{
            // - elliptical, parabolic, hyperbolic equatorial --
            if  ((*incl<small) || (fabs(*incl-M_PI)<small)){
                strcpy(typeorbit,""ee"");
",unused,preliminaryorbitdetermination-rv2coe.c
"
		preg = xmalloc (sizeof (regex_t));
		if (opt_exact) {
			re = xmalloc (strlen (opt_pattern) + 5);
			sprintf (re, ""^(%s)$"", opt_pattern);
",1,unused,464,unused,"
		preg = xmalloc (sizeof (regex_t));
		if (opt_exact) {
			re = xmalloc (strlen (opt_pattern) + 5);
			sprintf (re, ""^(%s)$"", opt_pattern);
",unused,procps123-pgrep.c
"		sig = signal_option(&argc, argv);
		if (-1 < sig)
			opt_signal = sig;
		/* These options are for pkill only */
		strcat (opts, ""e"");
",1,unused,723,unused,"		sig = signal_option(&argc, argv);
		if (-1 < sig)
			opt_signal = sig;
		/* These options are for pkill only */
		strcat (opts, ""e"");
",unused,procps123-pgrep.c
"		/* These options are for pkill only */
		strcat (opts, ""e"");
	} else {
		/* These options are for pgrep only */
		strcat (opts, ""lad:vw"");
",1,unused,726,unused,"		/* These options are for pkill only */
		strcat (opts, ""e"");
	} else {
		/* These options are for pgrep only */
		strcat (opts, ""lad:vw"");
",unused,procps123-pgrep.c
"		/* These options are for pgrep only */
		strcat (opts, ""lad:vw"");
	}

	strcat (opts, ""LF:cfinoxP:g:s:u:U:G:t:?Vh"");
",1,unused,729,unused,"		/* These options are for pgrep only */
		strcat (opts, ""lad:vw"");
	}

	strcat (opts, ""LF:cfinoxP:g:s:u:U:G:t:?Vh"");
",unused,procps123-pgrep.c
"					listtail->next = listnode;
				}
				listtail = listnode;
				/* listnode was calloc()ed so all fields are already NULL! */
				strcpy(listnode->description, detail_desc);
",1,unused,361,unused,"					listtail->next = listnode;
				}
				listtail = listnode;
				/* listnode was calloc()ed so all fields are already NULL! */
				strcpy(listnode->description, detail_desc);
",unused,procps123-pmap.c
"					xerrx(EXIT_FAILURE, ""ERROR: %s %s"",
					      _(""inconsistent detail field in smaps file, line:\n""),
					      mapbuf);
			}
			strcpy(listnode->value_str, value_str);
",1,unused,371,unused,"					xerrx(EXIT_FAILURE, ""ERROR: %s %s"",
					      _(""inconsistent detail field in smaps file, line:\n""),
					      mapbuf);
			}
			strcpy(listnode->value_str, value_str);
",unused,procps123-pmap.c
"		       ESC_ARGS | ESC_BRACKETS);
	printf(""%u:   %s\n"", p->tgid, cmdbuf);

	if (x_option || X_option || c_option) {
		sprintf(buf, ""/proc/%u/smaps"", p->tgid);
",1,unused,541,unused,"		       ESC_ARGS | ESC_BRACKETS);
	printf(""%u:   %s\n"", p->tgid, cmdbuf);

	if (x_option || X_option || c_option) {
		sprintf(buf, ""/proc/%u/smaps"", p->tgid);
",unused,procps123-pmap.c
"		sprintf(buf, ""/proc/%u/smaps"", p->tgid);
		if ((fp = fopen(buf, ""r"")) == NULL)
			return 1;
	} else {
		sprintf(buf, ""/proc/%u/maps"", p->tgid);
",1,unused,545,unused,"		sprintf(buf, ""/proc/%u/smaps"", p->tgid);
		if ((fp = fopen(buf, ""r"")) == NULL)
			return 1;
	} else {
		sprintf(buf, ""/proc/%u/maps"", p->tgid);
",unused,procps123-pmap.c
"        if (!p) {
            xalloc_err_handler(""%s failed to allocate %u bytes of memory"", __func__, size);
            exit(EXIT_FAILURE);
        }
        strcpy(p, str);
",1,unused,89,unused,"        if (!p) {
            xalloc_err_handler(""%s failed to allocate %u bytes of memory"", __func__, size);
            exit(EXIT_FAILURE);
        }
        strcpy(p, str);
",unused,procps123-proc2Falloc.c
"    if(!tmn) return 0;
    if(tmn->major_number == maj && tmn->minor_first <= min && tmn->minor_last >= min) break;
    tmn = tmn->next;
  }
  sprintf(buf, ""/dev/%s%d"", tmn->name, min);  /* like ""/dev/ttyZZ255"" */
",1,unused,134,unused,"    if(!tmn) return 0;
    if(tmn->major_number == maj && tmn->minor_first <= min && tmn->minor_last >= min) break;
    tmn = tmn->next;
  }
  sprintf(buf, ""/dev/%s%d"", tmn->name, min);  /* like ""/dev/ttyZZ255"" */
",unused,procps123-proc2Fdevname.c
"    tmn = tmn->next;
  }
  sprintf(buf, ""/dev/%s%d"", tmn->name, min);  /* like ""/dev/ttyZZ255"" */
  if(stat(buf, &sbuf) < 0){
    sprintf(buf, ""/dev/%s/%d"", tmn->name, min);  /* like ""/dev/pts/255"" */
",1,unused,136,unused,"    tmn = tmn->next;
  }
  sprintf(buf, ""/dev/%s%d"", tmn->name, min);  /* like ""/dev/ttyZZ255"" */
  if(stat(buf, &sbuf) < 0){
    sprintf(buf, ""/dev/%s/%d"", tmn->name, min);  /* like ""/dev/pts/255"" */
",unused,procps123-proc2Fdevname.c
"  if(stat(buf, &sbuf) < 0){
    sprintf(buf, ""/dev/%s/%d"", tmn->name, min);  /* like ""/dev/pts/255"" */
    if(stat(buf, &sbuf) < 0){
      if(tmn->devfs_type) return 0;
      sprintf(buf, ""/dev/%s"", tmn->name);  /* like ""/dev/ttyZZ255"" */
",1,unused,139,unused,"  if(stat(buf, &sbuf) < 0){
    sprintf(buf, ""/dev/%s/%d"", tmn->name, min);  /* like ""/dev/pts/255"" */
    if(stat(buf, &sbuf) < 0){
      if(tmn->devfs_type) return 0;
      sprintf(buf, ""/dev/%s"", tmn->name);  /* like ""/dev/ttyZZ255"" */
",unused,procps123-proc2Fdevname.c
"  case   3:      /* /dev/[pt]ty[p-za-o][0-9a-z] is 936 */
    if(tmpmin > 255) return 0;   // should never happen; array index protection
    t0 = ""pqrstuvwxyzabcde""[tmpmin>>4];
    t1 = ""0123456789abcdef""[tmpmin&0x0f];
    sprintf(buf, ""/dev/tty%c%c"", t0, t1);
",1,unused,214,unused,"  case   3:      /* /dev/[pt]ty[p-za-o][0-9a-z] is 936 */
    if(tmpmin > 255) return 0;   // should never happen; array index protection
    t0 = ""pqrstuvwxyzabcde""[tmpmin>>4];
    t1 = ""0123456789abcdef""[tmpmin&0x0f];
    sprintf(buf, ""/dev/tty%c%c"", t0, t1);
",unused,procps123-proc2Fdevname.c
"    sprintf(buf, ""/dev/tty%c%c"", t0, t1);
    break;
  case   4:
    if(min<64){
      sprintf(buf, ""/dev/tty%d"", min);
",1,unused,218,unused,"    sprintf(buf, ""/dev/tty%c%c"", t0, t1);
    break;
  case   4:
    if(min<64){
      sprintf(buf, ""/dev/tty%d"", min);
",unused,procps123-proc2Fdevname.c
"    if(min<64){
      sprintf(buf, ""/dev/tty%d"", min);
      break;
    }
    sprintf(buf, ""/dev/ttyS%d"", min-64);
",1,unused,221,unused,"    if(min<64){
      sprintf(buf, ""/dev/tty%d"", min);
      break;
    }
    sprintf(buf, ""/dev/ttyS%d"", min-64);
",unused,procps123-proc2Fdevname.c
"      break;
    }
    sprintf(buf, ""/dev/ttyS%d"", min-64);
    break;
  case  11:  sprintf(buf, ""/dev/ttyB%d"",  min); break;
",1,unused,223,unused,"      break;
    }
    sprintf(buf, ""/dev/ttyS%d"", min-64);
    break;
  case  11:  sprintf(buf, ""/dev/ttyB%d"",  min); break;
",unused,procps123-proc2Fdevname.c
"    }
    sprintf(buf, ""/dev/ttyS%d"", min-64);
    break;
  case  11:  sprintf(buf, ""/dev/ttyB%d"",  min); break;
  case  17:  sprintf(buf, ""/dev/ttyH%d"",  min); break;
",1,unused,224,unused,"    }
    sprintf(buf, ""/dev/ttyS%d"", min-64);
    break;
  case  11:  sprintf(buf, ""/dev/ttyB%d"",  min); break;
  case  17:  sprintf(buf, ""/dev/ttyH%d"",  min); break;
",unused,procps123-proc2Fdevname.c
"    sprintf(buf, ""/dev/ttyS%d"", min-64);
    break;
  case  11:  sprintf(buf, ""/dev/ttyB%d"",  min); break;
  case  17:  sprintf(buf, ""/dev/ttyH%d"",  min); break;
  case  19:  sprintf(buf, ""/dev/ttyC%d"",  min); break;
",1,unused,225,unused,"    sprintf(buf, ""/dev/ttyS%d"", min-64);
    break;
  case  11:  sprintf(buf, ""/dev/ttyB%d"",  min); break;
  case  17:  sprintf(buf, ""/dev/ttyH%d"",  min); break;
  case  19:  sprintf(buf, ""/dev/ttyC%d"",  min); break;
",unused,procps123-proc2Fdevname.c
"    break;
  case  11:  sprintf(buf, ""/dev/ttyB%d"",  min); break;
  case  17:  sprintf(buf, ""/dev/ttyH%d"",  min); break;
  case  19:  sprintf(buf, ""/dev/ttyC%d"",  min); break;
  case  22:  sprintf(buf, ""/dev/ttyD%d"",  min); break; /* devices.txt */
",1,unused,226,unused,"    break;
  case  11:  sprintf(buf, ""/dev/ttyB%d"",  min); break;
  case  17:  sprintf(buf, ""/dev/ttyH%d"",  min); break;
  case  19:  sprintf(buf, ""/dev/ttyC%d"",  min); break;
  case  22:  sprintf(buf, ""/dev/ttyD%d"",  min); break; /* devices.txt */
",unused,procps123-proc2Fdevname.c
"  case  11:  sprintf(buf, ""/dev/ttyB%d"",  min); break;
  case  17:  sprintf(buf, ""/dev/ttyH%d"",  min); break;
  case  19:  sprintf(buf, ""/dev/ttyC%d"",  min); break;
  case  22:  sprintf(buf, ""/dev/ttyD%d"",  min); break; /* devices.txt */
  case  23:  sprintf(buf, ""/dev/ttyD%d"",  min); break; /* driver code */
",1,unused,227,unused,"  case  11:  sprintf(buf, ""/dev/ttyB%d"",  min); break;
  case  17:  sprintf(buf, ""/dev/ttyH%d"",  min); break;
  case  19:  sprintf(buf, ""/dev/ttyC%d"",  min); break;
  case  22:  sprintf(buf, ""/dev/ttyD%d"",  min); break; /* devices.txt */
  case  23:  sprintf(buf, ""/dev/ttyD%d"",  min); break; /* driver code */
",unused,procps123-proc2Fdevname.c
"  case  17:  sprintf(buf, ""/dev/ttyH%d"",  min); break;
  case  19:  sprintf(buf, ""/dev/ttyC%d"",  min); break;
  case  22:  sprintf(buf, ""/dev/ttyD%d"",  min); break; /* devices.txt */
  case  23:  sprintf(buf, ""/dev/ttyD%d"",  min); break; /* driver code */
  case  24:  sprintf(buf, ""/dev/ttyE%d"",  min); break;
",1,unused,228,unused,"  case  17:  sprintf(buf, ""/dev/ttyH%d"",  min); break;
  case  19:  sprintf(buf, ""/dev/ttyC%d"",  min); break;
  case  22:  sprintf(buf, ""/dev/ttyD%d"",  min); break; /* devices.txt */
  case  23:  sprintf(buf, ""/dev/ttyD%d"",  min); break; /* driver code */
  case  24:  sprintf(buf, ""/dev/ttyE%d"",  min); break;
",unused,procps123-proc2Fdevname.c
"  case  19:  sprintf(buf, ""/dev/ttyC%d"",  min); break;
  case  22:  sprintf(buf, ""/dev/ttyD%d"",  min); break; /* devices.txt */
  case  23:  sprintf(buf, ""/dev/ttyD%d"",  min); break; /* driver code */
  case  24:  sprintf(buf, ""/dev/ttyE%d"",  min); break;
  case  32:  sprintf(buf, ""/dev/ttyX%d"",  min); break;
",1,unused,229,unused,"  case  19:  sprintf(buf, ""/dev/ttyC%d"",  min); break;
  case  22:  sprintf(buf, ""/dev/ttyD%d"",  min); break; /* devices.txt */
  case  23:  sprintf(buf, ""/dev/ttyD%d"",  min); break; /* driver code */
  case  24:  sprintf(buf, ""/dev/ttyE%d"",  min); break;
  case  32:  sprintf(buf, ""/dev/ttyX%d"",  min); break;
",unused,procps123-proc2Fdevname.c
"  case  22:  sprintf(buf, ""/dev/ttyD%d"",  min); break; /* devices.txt */
  case  23:  sprintf(buf, ""/dev/ttyD%d"",  min); break; /* driver code */
  case  24:  sprintf(buf, ""/dev/ttyE%d"",  min); break;
  case  32:  sprintf(buf, ""/dev/ttyX%d"",  min); break;
  case  43:  sprintf(buf, ""/dev/ttyI%d"",  min); break;
",1,unused,230,unused,"  case  22:  sprintf(buf, ""/dev/ttyD%d"",  min); break; /* devices.txt */
  case  23:  sprintf(buf, ""/dev/ttyD%d"",  min); break; /* driver code */
  case  24:  sprintf(buf, ""/dev/ttyE%d"",  min); break;
  case  32:  sprintf(buf, ""/dev/ttyX%d"",  min); break;
  case  43:  sprintf(buf, ""/dev/ttyI%d"",  min); break;
",unused,procps123-proc2Fdevname.c
"  case  23:  sprintf(buf, ""/dev/ttyD%d"",  min); break; /* driver code */
  case  24:  sprintf(buf, ""/dev/ttyE%d"",  min); break;
  case  32:  sprintf(buf, ""/dev/ttyX%d"",  min); break;
  case  43:  sprintf(buf, ""/dev/ttyI%d"",  min); break;
  case  46:  sprintf(buf, ""/dev/ttyR%d"",  min); break;
",1,unused,231,unused,"  case  23:  sprintf(buf, ""/dev/ttyD%d"",  min); break; /* driver code */
  case  24:  sprintf(buf, ""/dev/ttyE%d"",  min); break;
  case  32:  sprintf(buf, ""/dev/ttyX%d"",  min); break;
  case  43:  sprintf(buf, ""/dev/ttyI%d"",  min); break;
  case  46:  sprintf(buf, ""/dev/ttyR%d"",  min); break;
",unused,procps123-proc2Fdevname.c
"  case  24:  sprintf(buf, ""/dev/ttyE%d"",  min); break;
  case  32:  sprintf(buf, ""/dev/ttyX%d"",  min); break;
  case  43:  sprintf(buf, ""/dev/ttyI%d"",  min); break;
  case  46:  sprintf(buf, ""/dev/ttyR%d"",  min); break;
  case  48:  sprintf(buf, ""/dev/ttyL%d"",  min); break;
",1,unused,232,unused,"  case  24:  sprintf(buf, ""/dev/ttyE%d"",  min); break;
  case  32:  sprintf(buf, ""/dev/ttyX%d"",  min); break;
  case  43:  sprintf(buf, ""/dev/ttyI%d"",  min); break;
  case  46:  sprintf(buf, ""/dev/ttyR%d"",  min); break;
  case  48:  sprintf(buf, ""/dev/ttyL%d"",  min); break;
",unused,procps123-proc2Fdevname.c
"  case  32:  sprintf(buf, ""/dev/ttyX%d"",  min); break;
  case  43:  sprintf(buf, ""/dev/ttyI%d"",  min); break;
  case  46:  sprintf(buf, ""/dev/ttyR%d"",  min); break;
  case  48:  sprintf(buf, ""/dev/ttyL%d"",  min); break;
  case  57:  sprintf(buf, ""/dev/ttyP%d"",  min); break;
",1,unused,233,unused,"  case  32:  sprintf(buf, ""/dev/ttyX%d"",  min); break;
  case  43:  sprintf(buf, ""/dev/ttyI%d"",  min); break;
  case  46:  sprintf(buf, ""/dev/ttyR%d"",  min); break;
  case  48:  sprintf(buf, ""/dev/ttyL%d"",  min); break;
  case  57:  sprintf(buf, ""/dev/ttyP%d"",  min); break;
",unused,procps123-proc2Fdevname.c
"  case  43:  sprintf(buf, ""/dev/ttyI%d"",  min); break;
  case  46:  sprintf(buf, ""/dev/ttyR%d"",  min); break;
  case  48:  sprintf(buf, ""/dev/ttyL%d"",  min); break;
  case  57:  sprintf(buf, ""/dev/ttyP%d"",  min); break;
  case  71:  sprintf(buf, ""/dev/ttyF%d"",  min); break;
",1,unused,234,unused,"  case  43:  sprintf(buf, ""/dev/ttyI%d"",  min); break;
  case  46:  sprintf(buf, ""/dev/ttyR%d"",  min); break;
  case  48:  sprintf(buf, ""/dev/ttyL%d"",  min); break;
  case  57:  sprintf(buf, ""/dev/ttyP%d"",  min); break;
  case  71:  sprintf(buf, ""/dev/ttyF%d"",  min); break;
",unused,procps123-proc2Fdevname.c
"  case  46:  sprintf(buf, ""/dev/ttyR%d"",  min); break;
  case  48:  sprintf(buf, ""/dev/ttyL%d"",  min); break;
  case  57:  sprintf(buf, ""/dev/ttyP%d"",  min); break;
  case  71:  sprintf(buf, ""/dev/ttyF%d"",  min); break;
  case  75:  sprintf(buf, ""/dev/ttyW%d"",  min); break;
",1,unused,235,unused,"  case  46:  sprintf(buf, ""/dev/ttyR%d"",  min); break;
  case  48:  sprintf(buf, ""/dev/ttyL%d"",  min); break;
  case  57:  sprintf(buf, ""/dev/ttyP%d"",  min); break;
  case  71:  sprintf(buf, ""/dev/ttyF%d"",  min); break;
  case  75:  sprintf(buf, ""/dev/ttyW%d"",  min); break;
",unused,procps123-proc2Fdevname.c
"  case  48:  sprintf(buf, ""/dev/ttyL%d"",  min); break;
  case  57:  sprintf(buf, ""/dev/ttyP%d"",  min); break;
  case  71:  sprintf(buf, ""/dev/ttyF%d"",  min); break;
  case  75:  sprintf(buf, ""/dev/ttyW%d"",  min); break;
  case  78:  sprintf(buf, ""/dev/ttyM%d"",  min); break; /* conflict */
",1,unused,236,unused,"  case  48:  sprintf(buf, ""/dev/ttyL%d"",  min); break;
  case  57:  sprintf(buf, ""/dev/ttyP%d"",  min); break;
  case  71:  sprintf(buf, ""/dev/ttyF%d"",  min); break;
  case  75:  sprintf(buf, ""/dev/ttyW%d"",  min); break;
  case  78:  sprintf(buf, ""/dev/ttyM%d"",  min); break; /* conflict */
",unused,procps123-proc2Fdevname.c
"  case  57:  sprintf(buf, ""/dev/ttyP%d"",  min); break;
  case  71:  sprintf(buf, ""/dev/ttyF%d"",  min); break;
  case  75:  sprintf(buf, ""/dev/ttyW%d"",  min); break;
  case  78:  sprintf(buf, ""/dev/ttyM%d"",  min); break; /* conflict */
  case 105:  sprintf(buf, ""/dev/ttyV%d"",  min); break;
",1,unused,237,unused,"  case  57:  sprintf(buf, ""/dev/ttyP%d"",  min); break;
  case  71:  sprintf(buf, ""/dev/ttyF%d"",  min); break;
  case  75:  sprintf(buf, ""/dev/ttyW%d"",  min); break;
  case  78:  sprintf(buf, ""/dev/ttyM%d"",  min); break; /* conflict */
  case 105:  sprintf(buf, ""/dev/ttyV%d"",  min); break;
",unused,procps123-proc2Fdevname.c
"  case  71:  sprintf(buf, ""/dev/ttyF%d"",  min); break;
  case  75:  sprintf(buf, ""/dev/ttyW%d"",  min); break;
  case  78:  sprintf(buf, ""/dev/ttyM%d"",  min); break; /* conflict */
  case 105:  sprintf(buf, ""/dev/ttyV%d"",  min); break;
  case 112:  sprintf(buf, ""/dev/ttyM%d"",  min); break; /* conflict */
",1,unused,238,unused,"  case  71:  sprintf(buf, ""/dev/ttyF%d"",  min); break;
  case  75:  sprintf(buf, ""/dev/ttyW%d"",  min); break;
  case  78:  sprintf(buf, ""/dev/ttyM%d"",  min); break; /* conflict */
  case 105:  sprintf(buf, ""/dev/ttyV%d"",  min); break;
  case 112:  sprintf(buf, ""/dev/ttyM%d"",  min); break; /* conflict */
",unused,procps123-proc2Fdevname.c
"  case  78:  sprintf(buf, ""/dev/ttyM%d"",  min); break; /* conflict */
  case 105:  sprintf(buf, ""/dev/ttyV%d"",  min); break;
  case 112:  sprintf(buf, ""/dev/ttyM%d"",  min); break; /* conflict */
  /* 136 ... 143 are /dev/pts/0, /dev/pts/1, /dev/pts/2 ... */
  case 136 ... 143:  sprintf(buf, ""/dev/pts/%d"",  min+(maj-136)*256); break;
",1,unused,240,unused,"  case  78:  sprintf(buf, ""/dev/ttyM%d"",  min); break; /* conflict */
  case 105:  sprintf(buf, ""/dev/ttyV%d"",  min); break;
  case 112:  sprintf(buf, ""/dev/ttyM%d"",  min); break; /* conflict */
  /* 136 ... 143 are /dev/pts/0, /dev/pts/1, /dev/pts/2 ... */
  case 136 ... 143:  sprintf(buf, ""/dev/pts/%d"",  min+(maj-136)*256); break;
",unused,procps123-proc2Fdevname.c
"  case 105:  sprintf(buf, ""/dev/ttyV%d"",  min); break;
  case 112:  sprintf(buf, ""/dev/ttyM%d"",  min); break; /* conflict */
  /* 136 ... 143 are /dev/pts/0, /dev/pts/1, /dev/pts/2 ... */
  case 136 ... 143:  sprintf(buf, ""/dev/pts/%d"",  min+(maj-136)*256); break;
  case 148:  sprintf(buf, ""/dev/ttyT%d"",  min); break;
",1,unused,241,unused,"  case 105:  sprintf(buf, ""/dev/ttyV%d"",  min); break;
  case 112:  sprintf(buf, ""/dev/ttyM%d"",  min); break; /* conflict */
  /* 136 ... 143 are /dev/pts/0, /dev/pts/1, /dev/pts/2 ... */
  case 136 ... 143:  sprintf(buf, ""/dev/pts/%d"",  min+(maj-136)*256); break;
  case 148:  sprintf(buf, ""/dev/ttyT%d"",  min); break;
",unused,procps123-proc2Fdevname.c
"  case 112:  sprintf(buf, ""/dev/ttyM%d"",  min); break; /* conflict */
  /* 136 ... 143 are /dev/pts/0, /dev/pts/1, /dev/pts/2 ... */
  case 136 ... 143:  sprintf(buf, ""/dev/pts/%d"",  min+(maj-136)*256); break;
  case 148:  sprintf(buf, ""/dev/ttyT%d"",  min); break;
  case 154:  sprintf(buf, ""/dev/ttySR%d"", min); break;
",1,unused,242,unused,"  case 112:  sprintf(buf, ""/dev/ttyM%d"",  min); break; /* conflict */
  /* 136 ... 143 are /dev/pts/0, /dev/pts/1, /dev/pts/2 ... */
  case 136 ... 143:  sprintf(buf, ""/dev/pts/%d"",  min+(maj-136)*256); break;
  case 148:  sprintf(buf, ""/dev/ttyT%d"",  min); break;
  case 154:  sprintf(buf, ""/dev/ttySR%d"", min); break;
",unused,procps123-proc2Fdevname.c
"  /* 136 ... 143 are /dev/pts/0, /dev/pts/1, /dev/pts/2 ... */
  case 136 ... 143:  sprintf(buf, ""/dev/pts/%d"",  min+(maj-136)*256); break;
  case 148:  sprintf(buf, ""/dev/ttyT%d"",  min); break;
  case 154:  sprintf(buf, ""/dev/ttySR%d"", min); break;
  case 156:  sprintf(buf, ""/dev/ttySR%d"", min+256); break;
",1,unused,243,unused,"  /* 136 ... 143 are /dev/pts/0, /dev/pts/1, /dev/pts/2 ... */
  case 136 ... 143:  sprintf(buf, ""/dev/pts/%d"",  min+(maj-136)*256); break;
  case 148:  sprintf(buf, ""/dev/ttyT%d"",  min); break;
  case 154:  sprintf(buf, ""/dev/ttySR%d"", min); break;
  case 156:  sprintf(buf, ""/dev/ttySR%d"", min+256); break;
",unused,procps123-proc2Fdevname.c
"  case 136 ... 143:  sprintf(buf, ""/dev/pts/%d"",  min+(maj-136)*256); break;
  case 148:  sprintf(buf, ""/dev/ttyT%d"",  min); break;
  case 154:  sprintf(buf, ""/dev/ttySR%d"", min); break;
  case 156:  sprintf(buf, ""/dev/ttySR%d"", min+256); break;
  case 164:  sprintf(buf, ""/dev/ttyCH%d"",  min); break;
",1,unused,244,unused,"  case 136 ... 143:  sprintf(buf, ""/dev/pts/%d"",  min+(maj-136)*256); break;
  case 148:  sprintf(buf, ""/dev/ttyT%d"",  min); break;
  case 154:  sprintf(buf, ""/dev/ttySR%d"", min); break;
  case 156:  sprintf(buf, ""/dev/ttySR%d"", min+256); break;
  case 164:  sprintf(buf, ""/dev/ttyCH%d"",  min); break;
",unused,procps123-proc2Fdevname.c
"  case 148:  sprintf(buf, ""/dev/ttyT%d"",  min); break;
  case 154:  sprintf(buf, ""/dev/ttySR%d"", min); break;
  case 156:  sprintf(buf, ""/dev/ttySR%d"", min+256); break;
  case 164:  sprintf(buf, ""/dev/ttyCH%d"",  min); break;
  case 166:  sprintf(buf, ""/dev/ttyACM%d"", min); break; /* bummer, 9-char */
",1,unused,245,unused,"  case 148:  sprintf(buf, ""/dev/ttyT%d"",  min); break;
  case 154:  sprintf(buf, ""/dev/ttySR%d"", min); break;
  case 156:  sprintf(buf, ""/dev/ttySR%d"", min+256); break;
  case 164:  sprintf(buf, ""/dev/ttyCH%d"",  min); break;
  case 166:  sprintf(buf, ""/dev/ttyACM%d"", min); break; /* bummer, 9-char */
",unused,procps123-proc2Fdevname.c
"  case 154:  sprintf(buf, ""/dev/ttySR%d"", min); break;
  case 156:  sprintf(buf, ""/dev/ttySR%d"", min+256); break;
  case 164:  sprintf(buf, ""/dev/ttyCH%d"",  min); break;
  case 166:  sprintf(buf, ""/dev/ttyACM%d"", min); break; /* bummer, 9-char */
  case 172:  sprintf(buf, ""/dev/ttyMX%d"",  min); break;
",1,unused,246,unused,"  case 154:  sprintf(buf, ""/dev/ttySR%d"", min); break;
  case 156:  sprintf(buf, ""/dev/ttySR%d"", min+256); break;
  case 164:  sprintf(buf, ""/dev/ttyCH%d"",  min); break;
  case 166:  sprintf(buf, ""/dev/ttyACM%d"", min); break; /* bummer, 9-char */
  case 172:  sprintf(buf, ""/dev/ttyMX%d"",  min); break;
",unused,procps123-proc2Fdevname.c
"  case 156:  sprintf(buf, ""/dev/ttySR%d"", min+256); break;
  case 164:  sprintf(buf, ""/dev/ttyCH%d"",  min); break;
  case 166:  sprintf(buf, ""/dev/ttyACM%d"", min); break; /* bummer, 9-char */
  case 172:  sprintf(buf, ""/dev/ttyMX%d"",  min); break;
  case 174:  sprintf(buf, ""/dev/ttySI%d"",  min); break;
",1,unused,247,unused,"  case 156:  sprintf(buf, ""/dev/ttySR%d"", min+256); break;
  case 164:  sprintf(buf, ""/dev/ttyCH%d"",  min); break;
  case 166:  sprintf(buf, ""/dev/ttyACM%d"", min); break; /* bummer, 9-char */
  case 172:  sprintf(buf, ""/dev/ttyMX%d"",  min); break;
  case 174:  sprintf(buf, ""/dev/ttySI%d"",  min); break;
",unused,procps123-proc2Fdevname.c
"  case 164:  sprintf(buf, ""/dev/ttyCH%d"",  min); break;
  case 166:  sprintf(buf, ""/dev/ttyACM%d"", min); break; /* bummer, 9-char */
  case 172:  sprintf(buf, ""/dev/ttyMX%d"",  min); break;
  case 174:  sprintf(buf, ""/dev/ttySI%d"",  min); break;
  case 188:  sprintf(buf, ""/dev/ttyUSB%d"", min); break; /* bummer, 9-char */
",1,unused,248,unused,"  case 164:  sprintf(buf, ""/dev/ttyCH%d"",  min); break;
  case 166:  sprintf(buf, ""/dev/ttyACM%d"", min); break; /* bummer, 9-char */
  case 172:  sprintf(buf, ""/dev/ttyMX%d"",  min); break;
  case 174:  sprintf(buf, ""/dev/ttySI%d"",  min); break;
  case 188:  sprintf(buf, ""/dev/ttyUSB%d"", min); break; /* bummer, 9-char */
",unused,procps123-proc2Fdevname.c
"    memcpy(buf+8, low_density_names[min], sizeof low_density_names[0]);
    buf[8 + sizeof low_density_names[0]] = '\0';
//    snprintf(buf, 9 + sizeof low_density_names[0], ""/dev/tty%.*s"", sizeof low_density_names[0], low_density_names[min]);
    break;
  case 208:  sprintf(buf, ""/dev/ttyU%d"",  min); break;
",1,unused,256,unused,"    memcpy(buf+8, low_density_names[min], sizeof low_density_names[0]);
    buf[8 + sizeof low_density_names[0]] = '\0';
//    snprintf(buf, 9 + sizeof low_density_names[0], ""/dev/tty%.*s"", sizeof low_density_names[0], low_density_names[min]);
    break;
  case 208:  sprintf(buf, ""/dev/ttyU%d"",  min); break;
",unused,procps123-proc2Fdevname.c
"    buf[8 + sizeof low_density_names[0]] = '\0';
//    snprintf(buf, 9 + sizeof low_density_names[0], ""/dev/tty%.*s"", sizeof low_density_names[0], low_density_names[min]);
    break;
  case 208:  sprintf(buf, ""/dev/ttyU%d"",  min); break;
  case 216:  sprintf(buf, ""/dev/ttyUB%d"",  min); break; // ""/dev/rfcomm%d"" now?
",1,unused,257,unused,"    buf[8 + sizeof low_density_names[0]] = '\0';
//    snprintf(buf, 9 + sizeof low_density_names[0], ""/dev/tty%.*s"", sizeof low_density_names[0], low_density_names[min]);
    break;
  case 208:  sprintf(buf, ""/dev/ttyU%d"",  min); break;
  case 216:  sprintf(buf, ""/dev/ttyUB%d"",  min); break; // ""/dev/rfcomm%d"" now?
",unused,procps123-proc2Fdevname.c
"//    snprintf(buf, 9 + sizeof low_density_names[0], ""/dev/tty%.*s"", sizeof low_density_names[0], low_density_names[min]);
    break;
  case 208:  sprintf(buf, ""/dev/ttyU%d"",  min); break;
  case 216:  sprintf(buf, ""/dev/ttyUB%d"",  min); break; // ""/dev/rfcomm%d"" now?
  case 224:  sprintf(buf, ""/dev/ttyY%d"",  min); break;
",1,unused,258,unused,"//    snprintf(buf, 9 + sizeof low_density_names[0], ""/dev/tty%.*s"", sizeof low_density_names[0], low_density_names[min]);
    break;
  case 208:  sprintf(buf, ""/dev/ttyU%d"",  min); break;
  case 216:  sprintf(buf, ""/dev/ttyUB%d"",  min); break; // ""/dev/rfcomm%d"" now?
  case 224:  sprintf(buf, ""/dev/ttyY%d"",  min); break;
",unused,procps123-proc2Fdevname.c
"    break;
  case 208:  sprintf(buf, ""/dev/ttyU%d"",  min); break;
  case 216:  sprintf(buf, ""/dev/ttyUB%d"",  min); break; // ""/dev/rfcomm%d"" now?
  case 224:  sprintf(buf, ""/dev/ttyY%d"",  min); break;
  case 227:  sprintf(buf, ""/dev/3270/tty%d"", min); break; /* bummer, HUGE */
",1,unused,259,unused,"    break;
  case 208:  sprintf(buf, ""/dev/ttyU%d"",  min); break;
  case 216:  sprintf(buf, ""/dev/ttyUB%d"",  min); break; // ""/dev/rfcomm%d"" now?
  case 224:  sprintf(buf, ""/dev/ttyY%d"",  min); break;
  case 227:  sprintf(buf, ""/dev/3270/tty%d"", min); break; /* bummer, HUGE */
",unused,procps123-proc2Fdevname.c
"  case 208:  sprintf(buf, ""/dev/ttyU%d"",  min); break;
  case 216:  sprintf(buf, ""/dev/ttyUB%d"",  min); break; // ""/dev/rfcomm%d"" now?
  case 224:  sprintf(buf, ""/dev/ttyY%d"",  min); break;
  case 227:  sprintf(buf, ""/dev/3270/tty%d"", min); break; /* bummer, HUGE */
  case 229:  sprintf(buf, ""/dev/iseries/vtty%d"",  min); break; /* bummer, HUGE */
",1,unused,260,unused,"  case 208:  sprintf(buf, ""/dev/ttyU%d"",  min); break;
  case 216:  sprintf(buf, ""/dev/ttyUB%d"",  min); break; // ""/dev/rfcomm%d"" now?
  case 224:  sprintf(buf, ""/dev/ttyY%d"",  min); break;
  case 227:  sprintf(buf, ""/dev/3270/tty%d"", min); break; /* bummer, HUGE */
  case 229:  sprintf(buf, ""/dev/iseries/vtty%d"",  min); break; /* bummer, HUGE */
",unused,procps123-proc2Fdevname.c
"  case 216:  sprintf(buf, ""/dev/ttyUB%d"",  min); break; // ""/dev/rfcomm%d"" now?
  case 224:  sprintf(buf, ""/dev/ttyY%d"",  min); break;
  case 227:  sprintf(buf, ""/dev/3270/tty%d"", min); break; /* bummer, HUGE */
  case 229:  sprintf(buf, ""/dev/iseries/vtty%d"",  min); break; /* bummer, HUGE */
  case 256:  sprintf(buf, ""/dev/ttyEQ%d"",  min); break;
",1,unused,261,unused,"  case 216:  sprintf(buf, ""/dev/ttyUB%d"",  min); break; // ""/dev/rfcomm%d"" now?
  case 224:  sprintf(buf, ""/dev/ttyY%d"",  min); break;
  case 227:  sprintf(buf, ""/dev/3270/tty%d"", min); break; /* bummer, HUGE */
  case 229:  sprintf(buf, ""/dev/iseries/vtty%d"",  min); break; /* bummer, HUGE */
  case 256:  sprintf(buf, ""/dev/ttyEQ%d"",  min); break;
",unused,procps123-proc2Fdevname.c
"static int link_name(char *restrict const buf, unsigned maj, unsigned min, int pid, const char *restrict name){
  struct stat sbuf;
  char path[32];
  int count;
  sprintf(path, ""/proc/%d/%s"", pid, name);  /* often permission denied */
",1,unused,278,unused,"static int link_name(char *restrict const buf, unsigned maj, unsigned min, int pid, const char *restrict name){
  struct stat sbuf;
  char path[32];
  int count;
  sprintf(path, ""/proc/%d/%s"", pid, name);  /* often permission denied */
",unused,procps123-proc2Fdevname.c
"  if( guess_name(tmp, MAJOR_OF(dev), MINOR_OF(dev)               )) goto abbrev;
  if(  link_name(tmp, MAJOR_OF(dev), MINOR_OF(dev), pid, ""fd/255"")) goto abbrev;
  // fall through if unable to find a device file
no_tty:
  strcpy(ret, ""?"");
",1,unused,302,unused,"  if( guess_name(tmp, MAJOR_OF(dev), MINOR_OF(dev)               )) goto abbrev;
  if(  link_name(tmp, MAJOR_OF(dev), MINOR_OF(dev), pid, ""fd/255"")) goto abbrev;
  // fall through if unable to find a device file
no_tty:
  strcpy(ret, ""?"");
",unused,procps123-proc2Fdevname.c
"    *p = (struct pwbuf *) xmalloc(sizeof(struct pwbuf));
    (*p)->uid = uid;
    pw = getpwuid(uid);
    if(!pw || strlen(pw->pw_name) >= P_G_SZ)
	sprintf((*p)->name, ""%u"", uid);
",1,unused,58,unused,"    *p = (struct pwbuf *) xmalloc(sizeof(struct pwbuf));
    (*p)->uid = uid;
    pw = getpwuid(uid);
    if(!pw || strlen(pw->pw_name) >= P_G_SZ)
	sprintf((*p)->name, ""%u"", uid);
",unused,procps123-proc2Fpwcache.c
"    pw = getpwuid(uid);
    if(!pw || strlen(pw->pw_name) >= P_G_SZ)
	sprintf((*p)->name, ""%u"", uid);
    else
        strcpy((*p)->name, pw->pw_name);
",1,unused,60,unused,"    pw = getpwuid(uid);
    if(!pw || strlen(pw->pw_name) >= P_G_SZ)
	sprintf((*p)->name, ""%u"", uid);
    else
        strcpy((*p)->name, pw->pw_name);
",unused,procps123-proc2Fpwcache.c
"    *g = (struct grpbuf *) xmalloc(sizeof(struct grpbuf));
    (*g)->gid = gid;
    gr = getgrgid(gid);
    if (!gr || strlen(gr->gr_name) >= P_G_SZ)
        sprintf((*g)->name, ""%u"", gid);
",1,unused,86,unused,"    *g = (struct grpbuf *) xmalloc(sizeof(struct grpbuf));
    (*g)->gid = gid;
    gr = getgrgid(gid);
    if (!gr || strlen(gr->gr_name) >= P_G_SZ)
        sprintf((*g)->name, ""%u"", gid);
",unused,procps123-proc2Fpwcache.c
"    gr = getgrgid(gid);
    if (!gr || strlen(gr->gr_name) >= P_G_SZ)
        sprintf((*g)->name, ""%u"", gid);
    else
        strcpy((*g)->name, gr->gr_name);
",1,unused,88,unused,"    gr = getgrgid(gid);
    if (!gr || strlen(gr->gr_name) >= P_G_SZ)
        sprintf((*g)->name, ""%u"", gid);
    else
        strcpy((*g)->name, gr->gr_name);
",unused,procps123-proc2Fpwcache.c
"       buffer will likely soon be used for another subdirectory anyway
       ( besides, with this xcalloc we will never need to use memcpy ) */
    if (ub->buf) ub->buf[0] = '\0';
    else ub->buf = xcalloc((ub->siz = buffGRW));
    sprintf(path, ""%s/%s"", directory, what);
",1,unused,645,unused,"       buffer will likely soon be used for another subdirectory anyway
       ( besides, with this xcalloc we will never need to use memcpy ) */
    if (ub->buf) ub->buf[0] = '\0';
    else ub->buf = xcalloc((ub->siz = buffGRW));
    sprintf(path, ""%s/%s"", directory, what);
",unused,procps123-proc2Freadproc.c
"    char *p, *rbuf = 0, *endbuf, **q, **ret;
    int fd, tot = 0, n, c, end_of_file = 0;
    int align;

    sprintf(buf, ""%s/%s"", directory, what);
",1,unused,665,unused,"    char *p, *rbuf = 0, *endbuf, **q, **ret;
    int fd, tot = 0, n, c, end_of_file = 0;
    int align;

    sprintf(buf, ""%s/%s"", directory, what);
",unused,procps123-proc2Freadproc.c
"  }
  p->tgid = strtoul(ent->d_name, NULL, 10);
  p->tid = p->tgid;
  memcpy(path, ""/proc/"", 6);
  strcpy(path+6, ent->d_name);  // trust /proc to not contain evil top-level entries
",1,unused,1179,unused,"  }
  p->tgid = strtoul(ent->d_name, NULL, 10);
  p->tid = p->tgid;
  memcpy(path, ""/proc/"", 6);
  strcpy(path+6, ent->d_name);  // trust /proc to not contain evil top-level entries
",unused,procps123-proc2Freadproc.c
"    struct utlbuf_s ub = { NULL, 0 };
    static char path[32];
    struct stat statbuf;

    sprintf(path, ""/proc/%d"", pid);
",1,unused,1590,unused,"    struct utlbuf_s ub = { NULL, 0 };
    static char path[32];
    struct stat statbuf;

    sprintf(path, ""/proc/%d"", pid);
",unused,procps123-proc2Freadproc.c
"  while(n--){
    if(sigtable[n].num==signo) return sigtable[n].name;
  }
  if(signo == SIGRTMIN) return ""RTMIN"";
  if(signo) sprintf(buf, ""RTMIN+%d"", signo-SIGRTMIN);
",1,unused,168,unused,"  while(n--){
    if(sigtable[n].num==signo) return sigtable[n].name;
  }
  if(signo == SIGRTMIN) return ""RTMIN"";
  if(signo) sprintf(buf, ""RTMIN+%d"", signo-SIGRTMIN);
",unused,procps123-proc2Fsig.c
"    if(sigtable[n].num==signo) return sigtable[n].name;
  }
  if(signo == SIGRTMIN) return ""RTMIN"";
  if(signo) sprintf(buf, ""RTMIN+%d"", signo-SIGRTMIN);
  else      strcpy(buf,""0"");  /* AIX has NULL; Solaris has EXIT */
",1,unused,169,unused,"    if(sigtable[n].num==signo) return sigtable[n].name;
  }
  if(signo == SIGRTMIN) return ""RTMIN"";
  if(signo) sprintf(buf, ""RTMIN+%d"", signo-SIGRTMIN);
  else      strcpy(buf,""0"");  /* AIX has NULL; Solaris has EXIT */
",unused,procps123-proc2Fsig.c
"        fprintf(stderr, ""Signal \""%s\"" not known.\n"", txt);
        ret = 1;
        goto end;
      }
      amt = sprintf(tmpbuf, ""%s"", signal_number_to_name(val));
",1,unused,191,unused,"        fprintf(stderr, ""Signal \""%s\"" not known.\n"", txt);
        ret = 1;
        goto end;
      }
      amt = sprintf(tmpbuf, ""%s"", signal_number_to_name(val));
",unused,procps123-proc2Fsig.c
"        fprintf(stderr, ""Signal \""%s\"" not known.\n"", txt);
        ret = 1;
        goto end;
      }
      amt = sprintf(tmpbuf, ""%d"", sno);
",1,unused,200,unused,"        fprintf(stderr, ""Signal \""%s\"" not known.\n"", txt);
        ret = 1;
        goto end;
      }
      amt = sprintf(tmpbuf, ""%d"", sno);
",unused,procps123-proc2Fsig.c
"      amt = sprintf(tmpbuf, ""%d"", sno);
    }

    if(!place){
      strcpy(buf,tmpbuf);
",1,unused,204,unused,"      amt = sprintf(tmpbuf, ""%d"", sno);
    }

    if(!place){
      strcpy(buf,tmpbuf);
",unused,procps123-proc2Fsig.c
"      goto end;
    }
    if(amt+place+1 > max_line){
      printf(""%s\n"", buf);
      strcpy(buf,tmpbuf);
",1,unused,210,unused,"      goto end;
    }
    if(amt+place+1 > max_line){
      printf(""%s\n"", buf);
      strcpy(buf,tmpbuf);
",unused,procps123-proc2Fsig.c
"      strcpy(buf,tmpbuf);
      place = amt;
      goto end;
    }
    sprintf(buf+place, "" %s"", tmpbuf);
",1,unused,214,unused,"      strcpy(buf,tmpbuf);
      place = amt;
      goto end;
    }
    sprintf(buf+place, "" %s"", tmpbuf);
",unused,procps123-proc2Fsig.c
"    int fd;
    char c;

    if (!isdigit(ent->d_name[0])) continue;
    sprintf(tbuf, ""/proc/%s/stat"", ent->d_name);
",1,unused,417,unused,"    int fd;
    char c;

    if (!isdigit(ent->d_name[0])) continue;
    sprintf(tbuf, ""/proc/%s/stat"", ent->d_name);
",unused,procps123-proc2Fsysinfo.c
"    if(strlen(head) >= sizeof(namebuf)){
      head = tail+1;
      goto nextline;
    }
    strcpy(namebuf,head);
",1,unused,688,unused,"    if(strlen(head) >= sizeof(namebuf)){
      head = tail+1;
      goto nextline;
    }
    strcpy(namebuf,head);
",unused,procps123-proc2Fsysinfo.c
"    if(strlen(head) >= sizeof(namebuf)){
      head = tail+1;
      goto nextline;
    }
    strcpy(namebuf,head);
",1,unused,884,unused,"    if(strlen(head) >= sizeof(namebuf)){
      head = tail+1;
      goto nextline;
    }
    strcpy(namebuf,head);
",unused,procps123-proc2Fsysinfo.c
"
  if (!human_readable) {
    time(&realseconds);
    realtime = localtime(&realseconds);
    pos = sprintf(buf, "" %02d:%02d:%02d "",
",1,unused,59,unused,"
  if (!human_readable) {
    time(&realseconds);
    realtime = localtime(&realseconds);
    pos = sprintf(buf, "" %02d:%02d:%02d "",
",unused,procps123-proc2Fwhattime.c
"  }
  else
    updays = (int) uptime_secs / (60*60*24);

  strcat (buf, ""up "");
",1,unused,78,unused,"  }
  else
    updays = (int) uptime_secs / (60*60*24);

  strcat (buf, ""up "");
",unused,procps123-proc2Fwhattime.c
"  pos += 3;

  if (!human_readable) {
    if (updays)
      pos += sprintf(buf + pos, ""%d day%s, "", updays, (updays != 1) ? ""s"" : """");
",1,unused,83,unused,"  pos += 3;

  if (!human_readable) {
    if (updays)
      pos += sprintf(buf + pos, ""%d day%s, "", updays, (updays != 1) ? ""s"" : """");
",unused,procps123-proc2Fwhattime.c
"  upminutes = upminutes % 60;

  if (!human_readable) {
    if(uphours)
      pos += sprintf(buf + pos, ""%2d:%02d, "", uphours, upminutes);
",1,unused,93,unused,"  upminutes = upminutes % 60;

  if (!human_readable) {
    if(uphours)
      pos += sprintf(buf + pos, ""%2d:%02d, "", uphours, upminutes);
",unused,procps123-proc2Fwhattime.c
"  if (!human_readable) {
    if(uphours)
      pos += sprintf(buf + pos, ""%2d:%02d, "", uphours, upminutes);
    else
      pos += sprintf(buf + pos, ""%d min, "", upminutes);
",1,unused,95,unused,"  if (!human_readable) {
    if(uphours)
      pos += sprintf(buf + pos, ""%2d:%02d, "", uphours, upminutes);
    else
      pos += sprintf(buf + pos, ""%d min, "", upminutes);
",unused,procps123-proc2Fwhattime.c
"        numuser++;
    }
    endutent();

    pos += sprintf(buf + pos, ""%2d user%s, "", numuser, numuser == 1 ? """" : ""s"");
",1,unused,108,unused,"        numuser++;
    }
    endutent();

    pos += sprintf(buf + pos, ""%2d user%s, "", numuser, numuser == 1 ? """" : ""s"");
",unused,procps123-proc2Fwhattime.c
"    pos += sprintf(buf + pos, ""%2d user%s, "", numuser, numuser == 1 ? """" : ""s"");

    loadavg(&av[0], &av[1], &av[2]);

    pos += sprintf(buf + pos, "" load average: %.2f, %.2f, %.2f"",
",1,unused,112,unused,"    pos += sprintf(buf + pos, ""%2d user%s, "", numuser, numuser == 1 ? """" : ""s"");

    loadavg(&av[0], &av[1], &av[2]);

    pos += sprintf(buf + pos, "" load average: %.2f, %.2f, %.2f"",
",unused,procps123-proc2Fwhattime.c
"  if (human_readable) {
    comma = 0;

    if (updecades) {
      pos += sprintf(buf + pos, ""%d %s"", updecades,
",1,unused,120,unused,"  if (human_readable) {
    comma = 0;

    if (updecades) {
      pos += sprintf(buf + pos, ""%d %s"", updecades,
",unused,procps123-proc2Fwhattime.c
"      comma += 1;
    }

    if (upyears) {
      pos += sprintf(buf + pos, ""%s%d %s"", comma > 0 ? "", "" : """", upyears,
",1,unused,126,unused,"      comma += 1;
    }

    if (upyears) {
      pos += sprintf(buf + pos, ""%s%d %s"", comma > 0 ? "", "" : """", upyears,
",unused,procps123-proc2Fwhattime.c
"      comma += 1;
    }

    if (upweeks) {
      pos += sprintf(buf + pos, ""%s%d %s"", comma > 0 ? "", "" : """", upweeks,
",1,unused,132,unused,"      comma += 1;
    }

    if (upweeks) {
      pos += sprintf(buf + pos, ""%s%d %s"", comma > 0 ? "", "" : """", upweeks,
",unused,procps123-proc2Fwhattime.c
"      comma += 1;
    }

    if (updays) {
      pos += sprintf(buf + pos, ""%s%d %s"", comma > 0 ? "", "" : """", updays,
",1,unused,138,unused,"      comma += 1;
    }

    if (updays) {
      pos += sprintf(buf + pos, ""%s%d %s"", comma > 0 ? "", "" : """", updays,
",unused,procps123-proc2Fwhattime.c
"      comma += 1;
    }

    if (uphours) {
      pos += sprintf(buf + pos, ""%s%d %s"", comma > 0 ? "", "" : """", uphours,
",1,unused,144,unused,"      comma += 1;
    }

    if (uphours) {
      pos += sprintf(buf + pos, ""%s%d %s"", comma > 0 ? "", "" : """", uphours,
",unused,procps123-proc2Fwhattime.c
"      comma += 1;
    }

    if (upminutes) {
      pos += sprintf(buf + pos, ""%s%d %s"", comma > 0 ? "", "" : """", upminutes,
",1,unused,150,unused,"      comma += 1;
    }

    if (upminutes) {
      pos += sprintf(buf + pos, ""%s%d %s"", comma > 0 ? "", "" : """", upminutes,
",unused,procps123-proc2Fwhattime.c
"  /* Arrrgh! somebody defined unix as 1 */
  if(forest_type == 'u') goto unixy;
  while(*p){
    switch(*p){
    case ' ': strcpy(q, ""    "");  break;
",1,unused,345,unused,"  /* Arrrgh! somebody defined unix as 1 */
  if(forest_type == 'u') goto unixy;
  while(*p){
    switch(*p){
    case ' ': strcpy(q, ""    "");  break;
",unused,procps123-ps2Foutput.c
"  if(forest_type == 'u') goto unixy;
  while(*p){
    switch(*p){
    case ' ': strcpy(q, ""    "");  break;
    case 'L': strcpy(q, "" \\_ ""); break;
",1,unused,346,unused,"  if(forest_type == 'u') goto unixy;
  while(*p){
    switch(*p){
    case ' ': strcpy(q, ""    "");  break;
    case 'L': strcpy(q, "" \\_ ""); break;
",unused,procps123-ps2Foutput.c
"  while(*p){
    switch(*p){
    case ' ': strcpy(q, ""    "");  break;
    case 'L': strcpy(q, "" \\_ ""); break;
    case '+': strcpy(q, "" \\_ ""); break;
",1,unused,347,unused,"  while(*p){
    switch(*p){
    case ' ': strcpy(q, ""    "");  break;
    case 'L': strcpy(q, "" \\_ ""); break;
    case '+': strcpy(q, "" \\_ ""); break;
",unused,procps123-ps2Foutput.c
"    switch(*p){
    case ' ': strcpy(q, ""    "");  break;
    case 'L': strcpy(q, "" \\_ ""); break;
    case '+': strcpy(q, "" \\_ ""); break;
    case '|': strcpy(q, "" |  "");  break;
",1,unused,348,unused,"    switch(*p){
    case ' ': strcpy(q, ""    "");  break;
    case 'L': strcpy(q, "" \\_ ""); break;
    case '+': strcpy(q, "" \\_ ""); break;
    case '|': strcpy(q, "" |  "");  break;
",unused,procps123-ps2Foutput.c
"  return q-outbuf;   /* gcc likes this here */
unixy:
  while(*p){
    switch(*p){
    case ' ': strcpy(q, ""  ""); break;
",1,unused,363,unused,"  return q-outbuf;   /* gcc likes this here */
unixy:
  while(*p){
    switch(*p){
    case ' ': strcpy(q, ""  ""); break;
",unused,procps123-ps2Foutput.c
"unixy:
  while(*p){
    switch(*p){
    case ' ': strcpy(q, ""  ""); break;
    case 'L': strcpy(q, ""  ""); break;
",1,unused,364,unused,"unixy:
  while(*p){
    switch(*p){
    case ' ': strcpy(q, ""  ""); break;
    case 'L': strcpy(q, ""  ""); break;
",unused,procps123-ps2Foutput.c
"  while(*p){
    switch(*p){
    case ' ': strcpy(q, ""  ""); break;
    case 'L': strcpy(q, ""  ""); break;
    case '+': strcpy(q, ""  ""); break;
",1,unused,365,unused,"  while(*p){
    switch(*p){
    case ' ': strcpy(q, ""  ""); break;
    case 'L': strcpy(q, ""  ""); break;
    case '+': strcpy(q, ""  ""); break;
",unused,procps123-ps2Foutput.c
"    switch(*p){
    case ' ': strcpy(q, ""  ""); break;
    case 'L': strcpy(q, ""  ""); break;
    case '+': strcpy(q, ""  ""); break;
    case '|': strcpy(q, ""  ""); break;
",1,unused,366,unused,"    switch(*p){
    case ' ': strcpy(q, ""  ""); break;
    case 'L': strcpy(q, ""  ""); break;
    case '+': strcpy(q, ""  ""); break;
    case '|': strcpy(q, ""  ""); break;
",unused,procps123-ps2Foutput.c
"  time_t seconds_ago;
  start = getbtime() + pp->start_time / Hertz;
  seconds_ago = seconds_since_1970 - start;
  if(seconds_ago < 0) seconds_ago=0;
  if(seconds_ago > 3600*24)  strcpy(outbuf, ctime(&start)+4);
",1,unused,879,unused,"  time_t seconds_ago;
  start = getbtime() + pp->start_time / Hertz;
  seconds_ago = seconds_since_1970 - start;
  if(seconds_ago < 0) seconds_ago=0;
  if(seconds_ago > 3600*24)  strcpy(outbuf, ctime(&start)+4);
",unused,procps123-ps2Foutput.c
"  start = getbtime() + pp->start_time / Hertz;
  seconds_ago = seconds_since_1970 - start;
  if(seconds_ago < 0) seconds_ago=0;
  if(seconds_ago > 3600*24)  strcpy(outbuf, ctime(&start)+4);
  else                       strcpy(outbuf, ctime(&start)+10);
",1,unused,880,unused,"  start = getbtime() + pp->start_time / Hertz;
  seconds_ago = seconds_since_1970 - start;
  if(seconds_ago < 0) seconds_ago=0;
  if(seconds_ago > 3600*24)  strcpy(outbuf, ctime(&start)+4);
  else                       strcpy(outbuf, ctime(&start)+10);
",unused,procps123-ps2Foutput.c
"//		    active_cols, max_rightward, max_leftward, actual, correct);

    /* prepare data and calculate leftpad */
    if(likely(p) && likely(fmt->pr)) amount = (*fmt->pr)(outbuf,p);
    else amount = strlen(strcpy(outbuf, fmt->name)); /* AIX or headers */
",1,unused,1997,unused,"//		    active_cols, max_rightward, max_leftward, actual, correct);

    /* prepare data and calculate leftpad */
    if(likely(p) && likely(fmt->pr)) amount = (*fmt->pr)(outbuf,p);
    else amount = strlen(strcpy(outbuf, fmt->name)); /* AIX or headers */
",unused,procps123-ps2Foutput.c
"	int i;
	if (pid == my_pid || pid == 0)
		return;
	/* pid (cmd) state ppid pgrp session tty */
	sprintf(buf, ""/proc/%d/stat"", pid);
",1,unused,180,unused,"	int i;
	if (pid == my_pid || pid == 0)
		return;
	/* pid (cmd) state ppid pgrp session tty */
	sprintf(buf, ""/proc/%d/stat"", pid);
",unused,procps123-skill.c
"	slashdot(outname, '/', '.');

	/* used to open the file */
	tmpname = xmalloc(strlen(name) + strlen(PROC_PATH) + 2);
	strcpy(tmpname, PROC_PATH);
",1,unused,182,unused,"	slashdot(outname, '/', '.');

	/* used to open the file */
	tmpname = xmalloc(strlen(name) + strlen(PROC_PATH) + 2);
	strcpy(tmpname, PROC_PATH);
",unused,procps123-sysctl.c
"
	/* used to open the file */
	tmpname = xmalloc(strlen(name) + strlen(PROC_PATH) + 2);
	strcpy(tmpname, PROC_PATH);
	strcat(tmpname, name);
",1,unused,183,unused,"
	/* used to open the file */
	tmpname = xmalloc(strlen(name) + strlen(PROC_PATH) + 2);
	strcpy(tmpname, PROC_PATH);
	strcat(tmpname, name);
",unused,procps123-sysctl.c
"			tmpdir =
			    (char *restrict) xmalloc(strlen(path) +
						     strlen(de->d_name) +
						     2);
			sprintf(tmpdir, ""%s%s"", path, de->d_name);
",1,unused,330,unused,"			tmpdir =
			    (char *restrict) xmalloc(strlen(path) +
						     strlen(de->d_name) +
						     2);
			sprintf(tmpdir, ""%s%s"", path, de->d_name);
",unused,procps123-sysctl.c
"			if (rc2 != 0) {
				xwarn(_(""cannot stat %s""), tmpdir);
			} else {
				if (S_ISDIR(ts.st_mode)) {
					strcat(tmpdir, ""/"");
",1,unused,336,unused,"			if (rc2 != 0) {
				xwarn(_(""cannot stat %s""), tmpdir);
			} else {
				if (S_ISDIR(ts.st_mode)) {
					strcat(tmpdir, ""/"");
",unused,procps123-sysctl.c
"	}

	/* used to open the file */
	tmpname = xmalloc(equals - name + 1 + strlen(PROC_PATH));
	strcpy(tmpname, PROC_PATH);
",1,unused,389,unused,"	}

	/* used to open the file */
	tmpname = xmalloc(equals - name + 1 + strlen(PROC_PATH));
	strcpy(tmpname, PROC_PATH);
",unused,procps123-sysctl.c
"			while ((*value == ' ' || *value == '\t') && *value != 0)
				value++;

			/* should NameOnly affect this? */
			sprintf(buffer, ""%s=%s"", name, value);
",1,unused,563,unused,"			while ((*value == ' ' || *value == '\t') && *value != 0)
				value++;

			/* should NameOnly affect this? */
			sprintf(buffer, ""%s=%s"", name, value);
",unused,procps123-sysctl.c
"					    strlen(de->d_name) * 2 + 2 +
					    strlen(dirs[di]) + 1);
				cfgs[ncfgs]->name =
				    (char *)cfgs[ncfgs] + sizeof(struct pair);
				strcpy(cfgs[ncfgs]->name, de->d_name);
",1,unused,635,unused,"					    strlen(de->d_name) * 2 + 2 +
					    strlen(dirs[di]) + 1);
				cfgs[ncfgs]->name =
				    (char *)cfgs[ncfgs] + sizeof(struct pair);
				strcpy(cfgs[ncfgs]->name, de->d_name);
",unused,procps123-sysctl.c
"				strcpy(cfgs[ncfgs]->name, de->d_name);
				cfgs[ncfgs]->value =
				    (char *)cfgs[ncfgs] + sizeof(struct pair) +
				    strlen(cfgs[ncfgs]->name) + 1;
				sprintf(cfgs[ncfgs]->value, ""%s/%s"", dirs[di],
",1,unused,639,unused,"				strcpy(cfgs[ncfgs]->name, de->d_name);
				cfgs[ncfgs]->value =
				    (char *)cfgs[ncfgs] + sizeof(struct pair) +
				    strlen(cfgs[ncfgs]->name) + 1;
				sprintf(cfgs[ncfgs]->value, ""%s/%s"", dirs[di],
",unused,procps123-sysctl.c
"
			for (row = nrows - 2; row >= 0; --row)
				*(screen + row * ncols + col) = ' ';
		}
		i = sprintf(screen, "" %.2f, %.2f, %.2f"", av[0], av[1], av[2]);
",1,unused,206,unused,"
			for (row = nrows - 2; row >= 0; --row)
				*(screen + row * ncols + col) = ' ';
		}
		i = sprintf(screen, "" %.2f, %.2f, %.2f"", av[0], av[1], av[2]);
",unused,procps123-tload.c
"   if (1 > totpflgs) totpflgs = 1;
   if (1 > begpflgs) begpflgs = 1;
   snprintf(tmp1, sizeof(tmp1)
      , N_fmt(SCROLL_coord_fmt), Curwin->begtask + 1, begpflgs, totpflgs);
   strcpy(tmp2, tmp1);
",1,unused,890,unused,"   if (1 > totpflgs) totpflgs = 1;
   if (1 > begpflgs) begpflgs = 1;
   snprintf(tmp1, sizeof(tmp1)
      , N_fmt(SCROLL_coord_fmt), Curwin->begtask + 1, begpflgs, totpflgs);
   strcpy(tmp2, tmp1);
",unused,procps123-top2Ftop.c
"

static char *alloc_s (const char *str) MALLOC;
static char *alloc_s (const char *str) {
   return strcpy(alloc_c(strlen(str) +1), str);
",1,unused,931,unused,"

static char *alloc_s (const char *str) MALLOC;
static char *alloc_s (const char *str) {
   return strcpy(alloc_c(strlen(str) +1), str);
",unused,procps123-top2Ftop.c
"   // now let's convert old top's more limited fields...
   j = strlen(q->rc.fieldscur);
   if (j > CVT_FLDMAX)
      return 1;
   strcpy(fields_dst, fields_src);
",1,unused,3397,unused,"   // now let's convert old top's more limited fields...
   j = strlen(q->rc.fieldscur);
   if (j > CVT_FLDMAX)
      return 1;
   strcpy(fields_dst, fields_src);
",unused,procps123-top2Ftop.c
"   }
   // if we turned any suse only fields off, turn 'em back on OUR way...
   if (p1) FLDon(fields_dst[p1 - q->rc.fieldscur]);
   if (p2) FLDon(fields_dst[p2 - q->rc.fieldscur]);
   strcpy(q->rc.fieldscur, fields_dst);
",1,unused,3416,unused,"   }
   // if we turned any suse only fields off, turn 'em back on OUR way...
   if (p1) FLDon(fields_dst[p1 - q->rc.fieldscur]);
   if (p2) FLDon(fields_dst[p2 - q->rc.fieldscur]);
   strcpy(q->rc.fieldscur, fields_dst);
",unused,procps123-top2Ftop.c
"
         if (!fgets(fbuf, sizeof(fbuf), fp)) break;
         lraw += strlen(fbuf) +1;
         Inspect.raw = alloc_r(Inspect.raw, lraw);
         strcat(Inspect.raw, fbuf);
",1,unused,3542,unused,"
         if (!fgets(fbuf, sizeof(fbuf), fp)) break;
         lraw += strlen(fbuf) +1;
         Inspect.raw = alloc_r(Inspect.raw, lraw);
         strcat(Inspect.raw, fbuf);
",unused,procps123-top2Ftop.c
"   Curwin->osel_1st = osel;
   Curwin->osel_tot += 1;
   if (!Curwin->osel_prt) Curwin->osel_prt = alloc_c(strlen(raw) + 3);
   else Curwin->osel_prt = alloc_r(Curwin->osel_prt, strlen(Curwin->osel_prt) + strlen(raw) + 6);
   strcat(Curwin->osel_prt, fmtmk(""%s'%s'"", (Curwin->osel_tot > 1) ? "" + "" : """", raw));
",1,unused,4305,unused,"   Curwin->osel_1st = osel;
   Curwin->osel_tot += 1;
   if (!Curwin->osel_prt) Curwin->osel_prt = alloc_c(strlen(raw) + 3);
   else Curwin->osel_prt = alloc_r(Curwin->osel_prt, strlen(Curwin->osel_prt) + strlen(raw) + 6);
   strcat(Curwin->osel_prt, fmtmk(""%s'%s'"", (Curwin->osel_tot > 1) ? "" + "" : """", raw));
",unused,procps123-top2Ftop.c
"		}
		if (ut_addr_v6[1] || ut_addr_v6[2] || ut_addr_v6[3]) {
			/* IPv6 */
			if (!inet_ntop(AF_INET6, &ut_addr_v6, buf_ipv6, sizeof(buf_ipv6))) {
				strcpy(buf, """"); /* invalid address, clean the buffer */
",1,unused,205,unused,"		}
		if (ut_addr_v6[1] || ut_addr_v6[2] || ut_addr_v6[3]) {
			/* IPv6 */
			if (!inet_ntop(AF_INET6, &ut_addr_v6, buf_ipv6, sizeof(buf_ipv6))) {
				strcpy(buf, """"); /* invalid address, clean the buffer */
",unused,procps123-w.c
"			}
		} else {
			/* IPv4 */
			if (!(ut_addr_v6[0] && inet_ntop(AF_INET, &ut_addr_v6[0], buf, sizeof(buf)))) {
				strcpy(buf, """"); /* invalid address, clean the buffer */
",1,unused,212,unused,"			}
		} else {
			/* IPv4 */
			if (!(ut_addr_v6[0] && inet_ntop(AF_INET, &ut_addr_v6[0], buf, sizeof(buf)))) {
				strcpy(buf, """"); /* invalid address, clean the buffer */
",unused,procps123-w.c
"					listtail->next = listnode;
				}
				listtail = listnode;
				/* listnode was calloc()ed so all fields are already NULL! */
				strcpy(listnode->description, detail_desc);
",1,unused,361,unused,"					listtail->next = listnode;
				}
				listtail = listnode;
				/* listnode was calloc()ed so all fields are already NULL! */
				strcpy(listnode->description, detail_desc);
",unused,procpss-pmap.c
"					xerrx(EXIT_FAILURE, ""ERROR: %s %s"",
					      _(""inconsistent detail field in smaps file, line:\n""),
					      mapbuf);
			}
			strcpy(listnode->value_str, value_str);
",1,unused,371,unused,"					xerrx(EXIT_FAILURE, ""ERROR: %s %s"",
					      _(""inconsistent detail field in smaps file, line:\n""),
					      mapbuf);
			}
			strcpy(listnode->value_str, value_str);
",unused,procpss-pmap.c
"		       ESC_ARGS | ESC_BRACKETS);
	printf(""%u:   %s\n"", p->tgid, cmdbuf);

	if (x_option || X_option || c_option) {
		sprintf(buf, ""/proc/%u/smaps"", p->tgid);
",1,unused,541,unused,"		       ESC_ARGS | ESC_BRACKETS);
	printf(""%u:   %s\n"", p->tgid, cmdbuf);

	if (x_option || X_option || c_option) {
		sprintf(buf, ""/proc/%u/smaps"", p->tgid);
",unused,procpss-pmap.c
"		sprintf(buf, ""/proc/%u/smaps"", p->tgid);
		if ((fp = fopen(buf, ""r"")) == NULL)
			return 1;
	} else {
		sprintf(buf, ""/proc/%u/maps"", p->tgid);
",1,unused,545,unused,"		sprintf(buf, ""/proc/%u/smaps"", p->tgid);
		if ((fp = fopen(buf, ""r"")) == NULL)
			return 1;
	} else {
		sprintf(buf, ""/proc/%u/maps"", p->tgid);
",unused,procpss-pmap.c
"        if (!p) {
            xalloc_err_handler(""%s failed to allocate %u bytes of memory"", __func__, size);
            exit(EXIT_FAILURE);
        }
        strcpy(p, str);
",1,unused,89,unused,"        if (!p) {
            xalloc_err_handler(""%s failed to allocate %u bytes of memory"", __func__, size);
            exit(EXIT_FAILURE);
        }
        strcpy(p, str);
",unused,procpss-proc2Falloc.c
"    if(!tmn) return 0;
    if(tmn->major_number == maj && tmn->minor_first <= min && tmn->minor_last >= min) break;
    tmn = tmn->next;
  }
  sprintf(buf, ""/dev/%s%d"", tmn->name, min);  /* like ""/dev/ttyZZ255"" */
",1,unused,134,unused,"    if(!tmn) return 0;
    if(tmn->major_number == maj && tmn->minor_first <= min && tmn->minor_last >= min) break;
    tmn = tmn->next;
  }
  sprintf(buf, ""/dev/%s%d"", tmn->name, min);  /* like ""/dev/ttyZZ255"" */
",unused,procpss-proc2Fdevname.c
"    tmn = tmn->next;
  }
  sprintf(buf, ""/dev/%s%d"", tmn->name, min);  /* like ""/dev/ttyZZ255"" */
  if(stat(buf, &sbuf) < 0){
    sprintf(buf, ""/dev/%s/%d"", tmn->name, min);  /* like ""/dev/pts/255"" */
",1,unused,136,unused,"    tmn = tmn->next;
  }
  sprintf(buf, ""/dev/%s%d"", tmn->name, min);  /* like ""/dev/ttyZZ255"" */
  if(stat(buf, &sbuf) < 0){
    sprintf(buf, ""/dev/%s/%d"", tmn->name, min);  /* like ""/dev/pts/255"" */
",unused,procpss-proc2Fdevname.c
"  if(stat(buf, &sbuf) < 0){
    sprintf(buf, ""/dev/%s/%d"", tmn->name, min);  /* like ""/dev/pts/255"" */
    if(stat(buf, &sbuf) < 0){
      if(tmn->devfs_type) return 0;
      sprintf(buf, ""/dev/%s"", tmn->name);  /* like ""/dev/ttyZZ255"" */
",1,unused,139,unused,"  if(stat(buf, &sbuf) < 0){
    sprintf(buf, ""/dev/%s/%d"", tmn->name, min);  /* like ""/dev/pts/255"" */
    if(stat(buf, &sbuf) < 0){
      if(tmn->devfs_type) return 0;
      sprintf(buf, ""/dev/%s"", tmn->name);  /* like ""/dev/ttyZZ255"" */
",unused,procpss-proc2Fdevname.c
"  case   3:      /* /dev/[pt]ty[p-za-o][0-9a-z] is 936 */
    if(tmpmin > 255) return 0;   // should never happen; array index protection
    t0 = ""pqrstuvwxyzabcde""[tmpmin>>4];
    t1 = ""0123456789abcdef""[tmpmin&0x0f];
    sprintf(buf, ""/dev/tty%c%c"", t0, t1);
",1,unused,214,unused,"  case   3:      /* /dev/[pt]ty[p-za-o][0-9a-z] is 936 */
    if(tmpmin > 255) return 0;   // should never happen; array index protection
    t0 = ""pqrstuvwxyzabcde""[tmpmin>>4];
    t1 = ""0123456789abcdef""[tmpmin&0x0f];
    sprintf(buf, ""/dev/tty%c%c"", t0, t1);
",unused,procpss-proc2Fdevname.c
"    sprintf(buf, ""/dev/tty%c%c"", t0, t1);
    break;
  case   4:
    if(min<64){
      sprintf(buf, ""/dev/tty%d"", min);
",1,unused,218,unused,"    sprintf(buf, ""/dev/tty%c%c"", t0, t1);
    break;
  case   4:
    if(min<64){
      sprintf(buf, ""/dev/tty%d"", min);
",unused,procpss-proc2Fdevname.c
"    if(min<64){
      sprintf(buf, ""/dev/tty%d"", min);
      break;
    }
    sprintf(buf, ""/dev/ttyS%d"", min-64);
",1,unused,221,unused,"    if(min<64){
      sprintf(buf, ""/dev/tty%d"", min);
      break;
    }
    sprintf(buf, ""/dev/ttyS%d"", min-64);
",unused,procpss-proc2Fdevname.c
"      break;
    }
    sprintf(buf, ""/dev/ttyS%d"", min-64);
    break;
  case  11:  sprintf(buf, ""/dev/ttyB%d"",  min); break;
",1,unused,223,unused,"      break;
    }
    sprintf(buf, ""/dev/ttyS%d"", min-64);
    break;
  case  11:  sprintf(buf, ""/dev/ttyB%d"",  min); break;
",unused,procpss-proc2Fdevname.c
"    }
    sprintf(buf, ""/dev/ttyS%d"", min-64);
    break;
  case  11:  sprintf(buf, ""/dev/ttyB%d"",  min); break;
  case  17:  sprintf(buf, ""/dev/ttyH%d"",  min); break;
",1,unused,224,unused,"    }
    sprintf(buf, ""/dev/ttyS%d"", min-64);
    break;
  case  11:  sprintf(buf, ""/dev/ttyB%d"",  min); break;
  case  17:  sprintf(buf, ""/dev/ttyH%d"",  min); break;
",unused,procpss-proc2Fdevname.c
"    sprintf(buf, ""/dev/ttyS%d"", min-64);
    break;
  case  11:  sprintf(buf, ""/dev/ttyB%d"",  min); break;
  case  17:  sprintf(buf, ""/dev/ttyH%d"",  min); break;
  case  19:  sprintf(buf, ""/dev/ttyC%d"",  min); break;
",1,unused,225,unused,"    sprintf(buf, ""/dev/ttyS%d"", min-64);
    break;
  case  11:  sprintf(buf, ""/dev/ttyB%d"",  min); break;
  case  17:  sprintf(buf, ""/dev/ttyH%d"",  min); break;
  case  19:  sprintf(buf, ""/dev/ttyC%d"",  min); break;
",unused,procpss-proc2Fdevname.c
"    break;
  case  11:  sprintf(buf, ""/dev/ttyB%d"",  min); break;
  case  17:  sprintf(buf, ""/dev/ttyH%d"",  min); break;
  case  19:  sprintf(buf, ""/dev/ttyC%d"",  min); break;
  case  22:  sprintf(buf, ""/dev/ttyD%d"",  min); break; /* devices.txt */
",1,unused,226,unused,"    break;
  case  11:  sprintf(buf, ""/dev/ttyB%d"",  min); break;
  case  17:  sprintf(buf, ""/dev/ttyH%d"",  min); break;
  case  19:  sprintf(buf, ""/dev/ttyC%d"",  min); break;
  case  22:  sprintf(buf, ""/dev/ttyD%d"",  min); break; /* devices.txt */
",unused,procpss-proc2Fdevname.c
"  case  11:  sprintf(buf, ""/dev/ttyB%d"",  min); break;
  case  17:  sprintf(buf, ""/dev/ttyH%d"",  min); break;
  case  19:  sprintf(buf, ""/dev/ttyC%d"",  min); break;
  case  22:  sprintf(buf, ""/dev/ttyD%d"",  min); break; /* devices.txt */
  case  23:  sprintf(buf, ""/dev/ttyD%d"",  min); break; /* driver code */
",1,unused,227,unused,"  case  11:  sprintf(buf, ""/dev/ttyB%d"",  min); break;
  case  17:  sprintf(buf, ""/dev/ttyH%d"",  min); break;
  case  19:  sprintf(buf, ""/dev/ttyC%d"",  min); break;
  case  22:  sprintf(buf, ""/dev/ttyD%d"",  min); break; /* devices.txt */
  case  23:  sprintf(buf, ""/dev/ttyD%d"",  min); break; /* driver code */
",unused,procpss-proc2Fdevname.c
"  case  17:  sprintf(buf, ""/dev/ttyH%d"",  min); break;
  case  19:  sprintf(buf, ""/dev/ttyC%d"",  min); break;
  case  22:  sprintf(buf, ""/dev/ttyD%d"",  min); break; /* devices.txt */
  case  23:  sprintf(buf, ""/dev/ttyD%d"",  min); break; /* driver code */
  case  24:  sprintf(buf, ""/dev/ttyE%d"",  min); break;
",1,unused,228,unused,"  case  17:  sprintf(buf, ""/dev/ttyH%d"",  min); break;
  case  19:  sprintf(buf, ""/dev/ttyC%d"",  min); break;
  case  22:  sprintf(buf, ""/dev/ttyD%d"",  min); break; /* devices.txt */
  case  23:  sprintf(buf, ""/dev/ttyD%d"",  min); break; /* driver code */
  case  24:  sprintf(buf, ""/dev/ttyE%d"",  min); break;
",unused,procpss-proc2Fdevname.c
"  case  19:  sprintf(buf, ""/dev/ttyC%d"",  min); break;
  case  22:  sprintf(buf, ""/dev/ttyD%d"",  min); break; /* devices.txt */
  case  23:  sprintf(buf, ""/dev/ttyD%d"",  min); break; /* driver code */
  case  24:  sprintf(buf, ""/dev/ttyE%d"",  min); break;
  case  32:  sprintf(buf, ""/dev/ttyX%d"",  min); break;
",1,unused,229,unused,"  case  19:  sprintf(buf, ""/dev/ttyC%d"",  min); break;
  case  22:  sprintf(buf, ""/dev/ttyD%d"",  min); break; /* devices.txt */
  case  23:  sprintf(buf, ""/dev/ttyD%d"",  min); break; /* driver code */
  case  24:  sprintf(buf, ""/dev/ttyE%d"",  min); break;
  case  32:  sprintf(buf, ""/dev/ttyX%d"",  min); break;
",unused,procpss-proc2Fdevname.c
"  case  22:  sprintf(buf, ""/dev/ttyD%d"",  min); break; /* devices.txt */
  case  23:  sprintf(buf, ""/dev/ttyD%d"",  min); break; /* driver code */
  case  24:  sprintf(buf, ""/dev/ttyE%d"",  min); break;
  case  32:  sprintf(buf, ""/dev/ttyX%d"",  min); break;
  case  43:  sprintf(buf, ""/dev/ttyI%d"",  min); break;
",1,unused,230,unused,"  case  22:  sprintf(buf, ""/dev/ttyD%d"",  min); break; /* devices.txt */
  case  23:  sprintf(buf, ""/dev/ttyD%d"",  min); break; /* driver code */
  case  24:  sprintf(buf, ""/dev/ttyE%d"",  min); break;
  case  32:  sprintf(buf, ""/dev/ttyX%d"",  min); break;
  case  43:  sprintf(buf, ""/dev/ttyI%d"",  min); break;
",unused,procpss-proc2Fdevname.c
"  case  23:  sprintf(buf, ""/dev/ttyD%d"",  min); break; /* driver code */
  case  24:  sprintf(buf, ""/dev/ttyE%d"",  min); break;
  case  32:  sprintf(buf, ""/dev/ttyX%d"",  min); break;
  case  43:  sprintf(buf, ""/dev/ttyI%d"",  min); break;
  case  46:  sprintf(buf, ""/dev/ttyR%d"",  min); break;
",1,unused,231,unused,"  case  23:  sprintf(buf, ""/dev/ttyD%d"",  min); break; /* driver code */
  case  24:  sprintf(buf, ""/dev/ttyE%d"",  min); break;
  case  32:  sprintf(buf, ""/dev/ttyX%d"",  min); break;
  case  43:  sprintf(buf, ""/dev/ttyI%d"",  min); break;
  case  46:  sprintf(buf, ""/dev/ttyR%d"",  min); break;
",unused,procpss-proc2Fdevname.c
"  case  24:  sprintf(buf, ""/dev/ttyE%d"",  min); break;
  case  32:  sprintf(buf, ""/dev/ttyX%d"",  min); break;
  case  43:  sprintf(buf, ""/dev/ttyI%d"",  min); break;
  case  46:  sprintf(buf, ""/dev/ttyR%d"",  min); break;
  case  48:  sprintf(buf, ""/dev/ttyL%d"",  min); break;
",1,unused,232,unused,"  case  24:  sprintf(buf, ""/dev/ttyE%d"",  min); break;
  case  32:  sprintf(buf, ""/dev/ttyX%d"",  min); break;
  case  43:  sprintf(buf, ""/dev/ttyI%d"",  min); break;
  case  46:  sprintf(buf, ""/dev/ttyR%d"",  min); break;
  case  48:  sprintf(buf, ""/dev/ttyL%d"",  min); break;
",unused,procpss-proc2Fdevname.c
"  case  32:  sprintf(buf, ""/dev/ttyX%d"",  min); break;
  case  43:  sprintf(buf, ""/dev/ttyI%d"",  min); break;
  case  46:  sprintf(buf, ""/dev/ttyR%d"",  min); break;
  case  48:  sprintf(buf, ""/dev/ttyL%d"",  min); break;
  case  57:  sprintf(buf, ""/dev/ttyP%d"",  min); break;
",1,unused,233,unused,"  case  32:  sprintf(buf, ""/dev/ttyX%d"",  min); break;
  case  43:  sprintf(buf, ""/dev/ttyI%d"",  min); break;
  case  46:  sprintf(buf, ""/dev/ttyR%d"",  min); break;
  case  48:  sprintf(buf, ""/dev/ttyL%d"",  min); break;
  case  57:  sprintf(buf, ""/dev/ttyP%d"",  min); break;
",unused,procpss-proc2Fdevname.c
"  case  43:  sprintf(buf, ""/dev/ttyI%d"",  min); break;
  case  46:  sprintf(buf, ""/dev/ttyR%d"",  min); break;
  case  48:  sprintf(buf, ""/dev/ttyL%d"",  min); break;
  case  57:  sprintf(buf, ""/dev/ttyP%d"",  min); break;
  case  71:  sprintf(buf, ""/dev/ttyF%d"",  min); break;
",1,unused,234,unused,"  case  43:  sprintf(buf, ""/dev/ttyI%d"",  min); break;
  case  46:  sprintf(buf, ""/dev/ttyR%d"",  min); break;
  case  48:  sprintf(buf, ""/dev/ttyL%d"",  min); break;
  case  57:  sprintf(buf, ""/dev/ttyP%d"",  min); break;
  case  71:  sprintf(buf, ""/dev/ttyF%d"",  min); break;
",unused,procpss-proc2Fdevname.c
"  case  46:  sprintf(buf, ""/dev/ttyR%d"",  min); break;
  case  48:  sprintf(buf, ""/dev/ttyL%d"",  min); break;
  case  57:  sprintf(buf, ""/dev/ttyP%d"",  min); break;
  case  71:  sprintf(buf, ""/dev/ttyF%d"",  min); break;
  case  75:  sprintf(buf, ""/dev/ttyW%d"",  min); break;
",1,unused,235,unused,"  case  46:  sprintf(buf, ""/dev/ttyR%d"",  min); break;
  case  48:  sprintf(buf, ""/dev/ttyL%d"",  min); break;
  case  57:  sprintf(buf, ""/dev/ttyP%d"",  min); break;
  case  71:  sprintf(buf, ""/dev/ttyF%d"",  min); break;
  case  75:  sprintf(buf, ""/dev/ttyW%d"",  min); break;
",unused,procpss-proc2Fdevname.c
"  case  48:  sprintf(buf, ""/dev/ttyL%d"",  min); break;
  case  57:  sprintf(buf, ""/dev/ttyP%d"",  min); break;
  case  71:  sprintf(buf, ""/dev/ttyF%d"",  min); break;
  case  75:  sprintf(buf, ""/dev/ttyW%d"",  min); break;
  case  78:  sprintf(buf, ""/dev/ttyM%d"",  min); break; /* conflict */
",1,unused,236,unused,"  case  48:  sprintf(buf, ""/dev/ttyL%d"",  min); break;
  case  57:  sprintf(buf, ""/dev/ttyP%d"",  min); break;
  case  71:  sprintf(buf, ""/dev/ttyF%d"",  min); break;
  case  75:  sprintf(buf, ""/dev/ttyW%d"",  min); break;
  case  78:  sprintf(buf, ""/dev/ttyM%d"",  min); break; /* conflict */
",unused,procpss-proc2Fdevname.c
"  case  57:  sprintf(buf, ""/dev/ttyP%d"",  min); break;
  case  71:  sprintf(buf, ""/dev/ttyF%d"",  min); break;
  case  75:  sprintf(buf, ""/dev/ttyW%d"",  min); break;
  case  78:  sprintf(buf, ""/dev/ttyM%d"",  min); break; /* conflict */
  case 105:  sprintf(buf, ""/dev/ttyV%d"",  min); break;
",1,unused,237,unused,"  case  57:  sprintf(buf, ""/dev/ttyP%d"",  min); break;
  case  71:  sprintf(buf, ""/dev/ttyF%d"",  min); break;
  case  75:  sprintf(buf, ""/dev/ttyW%d"",  min); break;
  case  78:  sprintf(buf, ""/dev/ttyM%d"",  min); break; /* conflict */
  case 105:  sprintf(buf, ""/dev/ttyV%d"",  min); break;
",unused,procpss-proc2Fdevname.c
"  case  71:  sprintf(buf, ""/dev/ttyF%d"",  min); break;
  case  75:  sprintf(buf, ""/dev/ttyW%d"",  min); break;
  case  78:  sprintf(buf, ""/dev/ttyM%d"",  min); break; /* conflict */
  case 105:  sprintf(buf, ""/dev/ttyV%d"",  min); break;
  case 112:  sprintf(buf, ""/dev/ttyM%d"",  min); break; /* conflict */
",1,unused,238,unused,"  case  71:  sprintf(buf, ""/dev/ttyF%d"",  min); break;
  case  75:  sprintf(buf, ""/dev/ttyW%d"",  min); break;
  case  78:  sprintf(buf, ""/dev/ttyM%d"",  min); break; /* conflict */
  case 105:  sprintf(buf, ""/dev/ttyV%d"",  min); break;
  case 112:  sprintf(buf, ""/dev/ttyM%d"",  min); break; /* conflict */
",unused,procpss-proc2Fdevname.c
"  case  78:  sprintf(buf, ""/dev/ttyM%d"",  min); break; /* conflict */
  case 105:  sprintf(buf, ""/dev/ttyV%d"",  min); break;
  case 112:  sprintf(buf, ""/dev/ttyM%d"",  min); break; /* conflict */
  /* 136 ... 143 are /dev/pts/0, /dev/pts/1, /dev/pts/2 ... */
  case 136 ... 143:  sprintf(buf, ""/dev/pts/%d"",  min+(maj-136)*256); break;
",1,unused,240,unused,"  case  78:  sprintf(buf, ""/dev/ttyM%d"",  min); break; /* conflict */
  case 105:  sprintf(buf, ""/dev/ttyV%d"",  min); break;
  case 112:  sprintf(buf, ""/dev/ttyM%d"",  min); break; /* conflict */
  /* 136 ... 143 are /dev/pts/0, /dev/pts/1, /dev/pts/2 ... */
  case 136 ... 143:  sprintf(buf, ""/dev/pts/%d"",  min+(maj-136)*256); break;
",unused,procpss-proc2Fdevname.c
"  case 105:  sprintf(buf, ""/dev/ttyV%d"",  min); break;
  case 112:  sprintf(buf, ""/dev/ttyM%d"",  min); break; /* conflict */
  /* 136 ... 143 are /dev/pts/0, /dev/pts/1, /dev/pts/2 ... */
  case 136 ... 143:  sprintf(buf, ""/dev/pts/%d"",  min+(maj-136)*256); break;
  case 148:  sprintf(buf, ""/dev/ttyT%d"",  min); break;
",1,unused,241,unused,"  case 105:  sprintf(buf, ""/dev/ttyV%d"",  min); break;
  case 112:  sprintf(buf, ""/dev/ttyM%d"",  min); break; /* conflict */
  /* 136 ... 143 are /dev/pts/0, /dev/pts/1, /dev/pts/2 ... */
  case 136 ... 143:  sprintf(buf, ""/dev/pts/%d"",  min+(maj-136)*256); break;
  case 148:  sprintf(buf, ""/dev/ttyT%d"",  min); break;
",unused,procpss-proc2Fdevname.c
"  case 112:  sprintf(buf, ""/dev/ttyM%d"",  min); break; /* conflict */
  /* 136 ... 143 are /dev/pts/0, /dev/pts/1, /dev/pts/2 ... */
  case 136 ... 143:  sprintf(buf, ""/dev/pts/%d"",  min+(maj-136)*256); break;
  case 148:  sprintf(buf, ""/dev/ttyT%d"",  min); break;
  case 154:  sprintf(buf, ""/dev/ttySR%d"", min); break;
",1,unused,242,unused,"  case 112:  sprintf(buf, ""/dev/ttyM%d"",  min); break; /* conflict */
  /* 136 ... 143 are /dev/pts/0, /dev/pts/1, /dev/pts/2 ... */
  case 136 ... 143:  sprintf(buf, ""/dev/pts/%d"",  min+(maj-136)*256); break;
  case 148:  sprintf(buf, ""/dev/ttyT%d"",  min); break;
  case 154:  sprintf(buf, ""/dev/ttySR%d"", min); break;
",unused,procpss-proc2Fdevname.c
"  /* 136 ... 143 are /dev/pts/0, /dev/pts/1, /dev/pts/2 ... */
  case 136 ... 143:  sprintf(buf, ""/dev/pts/%d"",  min+(maj-136)*256); break;
  case 148:  sprintf(buf, ""/dev/ttyT%d"",  min); break;
  case 154:  sprintf(buf, ""/dev/ttySR%d"", min); break;
  case 156:  sprintf(buf, ""/dev/ttySR%d"", min+256); break;
",1,unused,243,unused,"  /* 136 ... 143 are /dev/pts/0, /dev/pts/1, /dev/pts/2 ... */
  case 136 ... 143:  sprintf(buf, ""/dev/pts/%d"",  min+(maj-136)*256); break;
  case 148:  sprintf(buf, ""/dev/ttyT%d"",  min); break;
  case 154:  sprintf(buf, ""/dev/ttySR%d"", min); break;
  case 156:  sprintf(buf, ""/dev/ttySR%d"", min+256); break;
",unused,procpss-proc2Fdevname.c
"  case 136 ... 143:  sprintf(buf, ""/dev/pts/%d"",  min+(maj-136)*256); break;
  case 148:  sprintf(buf, ""/dev/ttyT%d"",  min); break;
  case 154:  sprintf(buf, ""/dev/ttySR%d"", min); break;
  case 156:  sprintf(buf, ""/dev/ttySR%d"", min+256); break;
  case 164:  sprintf(buf, ""/dev/ttyCH%d"",  min); break;
",1,unused,244,unused,"  case 136 ... 143:  sprintf(buf, ""/dev/pts/%d"",  min+(maj-136)*256); break;
  case 148:  sprintf(buf, ""/dev/ttyT%d"",  min); break;
  case 154:  sprintf(buf, ""/dev/ttySR%d"", min); break;
  case 156:  sprintf(buf, ""/dev/ttySR%d"", min+256); break;
  case 164:  sprintf(buf, ""/dev/ttyCH%d"",  min); break;
",unused,procpss-proc2Fdevname.c
"  case 148:  sprintf(buf, ""/dev/ttyT%d"",  min); break;
  case 154:  sprintf(buf, ""/dev/ttySR%d"", min); break;
  case 156:  sprintf(buf, ""/dev/ttySR%d"", min+256); break;
  case 164:  sprintf(buf, ""/dev/ttyCH%d"",  min); break;
  case 166:  sprintf(buf, ""/dev/ttyACM%d"", min); break; /* bummer, 9-char */
",1,unused,245,unused,"  case 148:  sprintf(buf, ""/dev/ttyT%d"",  min); break;
  case 154:  sprintf(buf, ""/dev/ttySR%d"", min); break;
  case 156:  sprintf(buf, ""/dev/ttySR%d"", min+256); break;
  case 164:  sprintf(buf, ""/dev/ttyCH%d"",  min); break;
  case 166:  sprintf(buf, ""/dev/ttyACM%d"", min); break; /* bummer, 9-char */
",unused,procpss-proc2Fdevname.c
"  case 154:  sprintf(buf, ""/dev/ttySR%d"", min); break;
  case 156:  sprintf(buf, ""/dev/ttySR%d"", min+256); break;
  case 164:  sprintf(buf, ""/dev/ttyCH%d"",  min); break;
  case 166:  sprintf(buf, ""/dev/ttyACM%d"", min); break; /* bummer, 9-char */
  case 172:  sprintf(buf, ""/dev/ttyMX%d"",  min); break;
",1,unused,246,unused,"  case 154:  sprintf(buf, ""/dev/ttySR%d"", min); break;
  case 156:  sprintf(buf, ""/dev/ttySR%d"", min+256); break;
  case 164:  sprintf(buf, ""/dev/ttyCH%d"",  min); break;
  case 166:  sprintf(buf, ""/dev/ttyACM%d"", min); break; /* bummer, 9-char */
  case 172:  sprintf(buf, ""/dev/ttyMX%d"",  min); break;
",unused,procpss-proc2Fdevname.c
"  case 156:  sprintf(buf, ""/dev/ttySR%d"", min+256); break;
  case 164:  sprintf(buf, ""/dev/ttyCH%d"",  min); break;
  case 166:  sprintf(buf, ""/dev/ttyACM%d"", min); break; /* bummer, 9-char */
  case 172:  sprintf(buf, ""/dev/ttyMX%d"",  min); break;
  case 174:  sprintf(buf, ""/dev/ttySI%d"",  min); break;
",1,unused,247,unused,"  case 156:  sprintf(buf, ""/dev/ttySR%d"", min+256); break;
  case 164:  sprintf(buf, ""/dev/ttyCH%d"",  min); break;
  case 166:  sprintf(buf, ""/dev/ttyACM%d"", min); break; /* bummer, 9-char */
  case 172:  sprintf(buf, ""/dev/ttyMX%d"",  min); break;
  case 174:  sprintf(buf, ""/dev/ttySI%d"",  min); break;
",unused,procpss-proc2Fdevname.c
"  case 164:  sprintf(buf, ""/dev/ttyCH%d"",  min); break;
  case 166:  sprintf(buf, ""/dev/ttyACM%d"", min); break; /* bummer, 9-char */
  case 172:  sprintf(buf, ""/dev/ttyMX%d"",  min); break;
  case 174:  sprintf(buf, ""/dev/ttySI%d"",  min); break;
  case 188:  sprintf(buf, ""/dev/ttyUSB%d"", min); break; /* bummer, 9-char */
",1,unused,248,unused,"  case 164:  sprintf(buf, ""/dev/ttyCH%d"",  min); break;
  case 166:  sprintf(buf, ""/dev/ttyACM%d"", min); break; /* bummer, 9-char */
  case 172:  sprintf(buf, ""/dev/ttyMX%d"",  min); break;
  case 174:  sprintf(buf, ""/dev/ttySI%d"",  min); break;
  case 188:  sprintf(buf, ""/dev/ttyUSB%d"", min); break; /* bummer, 9-char */
",unused,procpss-proc2Fdevname.c
"    memcpy(buf+8, low_density_names[min], sizeof low_density_names[0]);
    buf[8 + sizeof low_density_names[0]] = '\0';
//    snprintf(buf, 9 + sizeof low_density_names[0], ""/dev/tty%.*s"", sizeof low_density_names[0], low_density_names[min]);
    break;
  case 208:  sprintf(buf, ""/dev/ttyU%d"",  min); break;
",1,unused,256,unused,"    memcpy(buf+8, low_density_names[min], sizeof low_density_names[0]);
    buf[8 + sizeof low_density_names[0]] = '\0';
//    snprintf(buf, 9 + sizeof low_density_names[0], ""/dev/tty%.*s"", sizeof low_density_names[0], low_density_names[min]);
    break;
  case 208:  sprintf(buf, ""/dev/ttyU%d"",  min); break;
",unused,procpss-proc2Fdevname.c
"    buf[8 + sizeof low_density_names[0]] = '\0';
//    snprintf(buf, 9 + sizeof low_density_names[0], ""/dev/tty%.*s"", sizeof low_density_names[0], low_density_names[min]);
    break;
  case 208:  sprintf(buf, ""/dev/ttyU%d"",  min); break;
  case 216:  sprintf(buf, ""/dev/ttyUB%d"",  min); break; // ""/dev/rfcomm%d"" now?
",1,unused,257,unused,"    buf[8 + sizeof low_density_names[0]] = '\0';
//    snprintf(buf, 9 + sizeof low_density_names[0], ""/dev/tty%.*s"", sizeof low_density_names[0], low_density_names[min]);
    break;
  case 208:  sprintf(buf, ""/dev/ttyU%d"",  min); break;
  case 216:  sprintf(buf, ""/dev/ttyUB%d"",  min); break; // ""/dev/rfcomm%d"" now?
",unused,procpss-proc2Fdevname.c
"//    snprintf(buf, 9 + sizeof low_density_names[0], ""/dev/tty%.*s"", sizeof low_density_names[0], low_density_names[min]);
    break;
  case 208:  sprintf(buf, ""/dev/ttyU%d"",  min); break;
  case 216:  sprintf(buf, ""/dev/ttyUB%d"",  min); break; // ""/dev/rfcomm%d"" now?
  case 224:  sprintf(buf, ""/dev/ttyY%d"",  min); break;
",1,unused,258,unused,"//    snprintf(buf, 9 + sizeof low_density_names[0], ""/dev/tty%.*s"", sizeof low_density_names[0], low_density_names[min]);
    break;
  case 208:  sprintf(buf, ""/dev/ttyU%d"",  min); break;
  case 216:  sprintf(buf, ""/dev/ttyUB%d"",  min); break; // ""/dev/rfcomm%d"" now?
  case 224:  sprintf(buf, ""/dev/ttyY%d"",  min); break;
",unused,procpss-proc2Fdevname.c
"    break;
  case 208:  sprintf(buf, ""/dev/ttyU%d"",  min); break;
  case 216:  sprintf(buf, ""/dev/ttyUB%d"",  min); break; // ""/dev/rfcomm%d"" now?
  case 224:  sprintf(buf, ""/dev/ttyY%d"",  min); break;
  case 227:  sprintf(buf, ""/dev/3270/tty%d"", min); break; /* bummer, HUGE */
",1,unused,259,unused,"    break;
  case 208:  sprintf(buf, ""/dev/ttyU%d"",  min); break;
  case 216:  sprintf(buf, ""/dev/ttyUB%d"",  min); break; // ""/dev/rfcomm%d"" now?
  case 224:  sprintf(buf, ""/dev/ttyY%d"",  min); break;
  case 227:  sprintf(buf, ""/dev/3270/tty%d"", min); break; /* bummer, HUGE */
",unused,procpss-proc2Fdevname.c
"  case 208:  sprintf(buf, ""/dev/ttyU%d"",  min); break;
  case 216:  sprintf(buf, ""/dev/ttyUB%d"",  min); break; // ""/dev/rfcomm%d"" now?
  case 224:  sprintf(buf, ""/dev/ttyY%d"",  min); break;
  case 227:  sprintf(buf, ""/dev/3270/tty%d"", min); break; /* bummer, HUGE */
  case 229:  sprintf(buf, ""/dev/iseries/vtty%d"",  min); break; /* bummer, HUGE */
",1,unused,260,unused,"  case 208:  sprintf(buf, ""/dev/ttyU%d"",  min); break;
  case 216:  sprintf(buf, ""/dev/ttyUB%d"",  min); break; // ""/dev/rfcomm%d"" now?
  case 224:  sprintf(buf, ""/dev/ttyY%d"",  min); break;
  case 227:  sprintf(buf, ""/dev/3270/tty%d"", min); break; /* bummer, HUGE */
  case 229:  sprintf(buf, ""/dev/iseries/vtty%d"",  min); break; /* bummer, HUGE */
",unused,procpss-proc2Fdevname.c
"  case 216:  sprintf(buf, ""/dev/ttyUB%d"",  min); break; // ""/dev/rfcomm%d"" now?
  case 224:  sprintf(buf, ""/dev/ttyY%d"",  min); break;
  case 227:  sprintf(buf, ""/dev/3270/tty%d"", min); break; /* bummer, HUGE */
  case 229:  sprintf(buf, ""/dev/iseries/vtty%d"",  min); break; /* bummer, HUGE */
  case 256:  sprintf(buf, ""/dev/ttyEQ%d"",  min); break;
",1,unused,261,unused,"  case 216:  sprintf(buf, ""/dev/ttyUB%d"",  min); break; // ""/dev/rfcomm%d"" now?
  case 224:  sprintf(buf, ""/dev/ttyY%d"",  min); break;
  case 227:  sprintf(buf, ""/dev/3270/tty%d"", min); break; /* bummer, HUGE */
  case 229:  sprintf(buf, ""/dev/iseries/vtty%d"",  min); break; /* bummer, HUGE */
  case 256:  sprintf(buf, ""/dev/ttyEQ%d"",  min); break;
",unused,procpss-proc2Fdevname.c
"static int link_name(char *restrict const buf, unsigned maj, unsigned min, int pid, const char *restrict name){
  struct stat sbuf;
  char path[32];
  int count;
  sprintf(path, ""/proc/%d/%s"", pid, name);  /* often permission denied */
",1,unused,278,unused,"static int link_name(char *restrict const buf, unsigned maj, unsigned min, int pid, const char *restrict name){
  struct stat sbuf;
  char path[32];
  int count;
  sprintf(path, ""/proc/%d/%s"", pid, name);  /* often permission denied */
",unused,procpss-proc2Fdevname.c
"  if( guess_name(tmp, MAJOR_OF(dev), MINOR_OF(dev)               )) goto abbrev;
  if(  link_name(tmp, MAJOR_OF(dev), MINOR_OF(dev), pid, ""fd/255"")) goto abbrev;
  // fall through if unable to find a device file
no_tty:
  strcpy(ret, ""?"");
",1,unused,302,unused,"  if( guess_name(tmp, MAJOR_OF(dev), MINOR_OF(dev)               )) goto abbrev;
  if(  link_name(tmp, MAJOR_OF(dev), MINOR_OF(dev), pid, ""fd/255"")) goto abbrev;
  // fall through if unable to find a device file
no_tty:
  strcpy(ret, ""?"");
",unused,procpss-proc2Fdevname.c
"    *p = (struct pwbuf *) xmalloc(sizeof(struct pwbuf));
    (*p)->uid = uid;
    pw = getpwuid(uid);
    if(!pw || strlen(pw->pw_name) >= P_G_SZ)
	sprintf((*p)->name, ""%u"", uid);
",1,unused,58,unused,"    *p = (struct pwbuf *) xmalloc(sizeof(struct pwbuf));
    (*p)->uid = uid;
    pw = getpwuid(uid);
    if(!pw || strlen(pw->pw_name) >= P_G_SZ)
	sprintf((*p)->name, ""%u"", uid);
",unused,procpss-proc2Fpwcache.c
"    pw = getpwuid(uid);
    if(!pw || strlen(pw->pw_name) >= P_G_SZ)
	sprintf((*p)->name, ""%u"", uid);
    else
        strcpy((*p)->name, pw->pw_name);
",1,unused,60,unused,"    pw = getpwuid(uid);
    if(!pw || strlen(pw->pw_name) >= P_G_SZ)
	sprintf((*p)->name, ""%u"", uid);
    else
        strcpy((*p)->name, pw->pw_name);
",unused,procpss-proc2Fpwcache.c
"    *g = (struct grpbuf *) xmalloc(sizeof(struct grpbuf));
    (*g)->gid = gid;
    gr = getgrgid(gid);
    if (!gr || strlen(gr->gr_name) >= P_G_SZ)
        sprintf((*g)->name, ""%u"", gid);
",1,unused,86,unused,"    *g = (struct grpbuf *) xmalloc(sizeof(struct grpbuf));
    (*g)->gid = gid;
    gr = getgrgid(gid);
    if (!gr || strlen(gr->gr_name) >= P_G_SZ)
        sprintf((*g)->name, ""%u"", gid);
",unused,procpss-proc2Fpwcache.c
"    gr = getgrgid(gid);
    if (!gr || strlen(gr->gr_name) >= P_G_SZ)
        sprintf((*g)->name, ""%u"", gid);
    else
        strcpy((*g)->name, gr->gr_name);
",1,unused,88,unused,"    gr = getgrgid(gid);
    if (!gr || strlen(gr->gr_name) >= P_G_SZ)
        sprintf((*g)->name, ""%u"", gid);
    else
        strcpy((*g)->name, gr->gr_name);
",unused,procpss-proc2Fpwcache.c
"       buffer will likely soon be used for another subdirectory anyway
       ( besides, with this xcalloc we will never need to use memcpy ) */
    if (ub->buf) ub->buf[0] = '\0';
    else ub->buf = xcalloc((ub->siz = buffGRW));
    sprintf(path, ""%s/%s"", directory, what);
",1,unused,645,unused,"       buffer will likely soon be used for another subdirectory anyway
       ( besides, with this xcalloc we will never need to use memcpy ) */
    if (ub->buf) ub->buf[0] = '\0';
    else ub->buf = xcalloc((ub->siz = buffGRW));
    sprintf(path, ""%s/%s"", directory, what);
",unused,procpss-proc2Freadproc.c
"    char *p, *rbuf = 0, *endbuf, **q, **ret;
    int fd, tot = 0, n, c, end_of_file = 0;
    int align;

    sprintf(buf, ""%s/%s"", directory, what);
",1,unused,665,unused,"    char *p, *rbuf = 0, *endbuf, **q, **ret;
    int fd, tot = 0, n, c, end_of_file = 0;
    int align;

    sprintf(buf, ""%s/%s"", directory, what);
",unused,procpss-proc2Freadproc.c
"  }
  p->tgid = strtoul(ent->d_name, NULL, 10);
  p->tid = p->tgid;
  memcpy(path, ""/proc/"", 6);
  strcpy(path+6, ent->d_name);  // trust /proc to not contain evil top-level entries
",1,unused,1179,unused,"  }
  p->tgid = strtoul(ent->d_name, NULL, 10);
  p->tid = p->tgid;
  memcpy(path, ""/proc/"", 6);
  strcpy(path+6, ent->d_name);  // trust /proc to not contain evil top-level entries
",unused,procpss-proc2Freadproc.c
"    struct utlbuf_s ub = { NULL, 0 };
    static char path[32];
    struct stat statbuf;

    sprintf(path, ""/proc/%d"", pid);
",1,unused,1590,unused,"    struct utlbuf_s ub = { NULL, 0 };
    static char path[32];
    struct stat statbuf;

    sprintf(path, ""/proc/%d"", pid);
",unused,procpss-proc2Freadproc.c
"  while(n--){
    if(sigtable[n].num==signo) return sigtable[n].name;
  }
  if(signo == SIGRTMIN) return ""RTMIN"";
  if(signo) sprintf(buf, ""RTMIN+%d"", signo-SIGRTMIN);
",1,unused,170,unused,"  while(n--){
    if(sigtable[n].num==signo) return sigtable[n].name;
  }
  if(signo == SIGRTMIN) return ""RTMIN"";
  if(signo) sprintf(buf, ""RTMIN+%d"", signo-SIGRTMIN);
",unused,procpss-proc2Fsig.c
"    if(sigtable[n].num==signo) return sigtable[n].name;
  }
  if(signo == SIGRTMIN) return ""RTMIN"";
  if(signo) sprintf(buf, ""RTMIN+%d"", signo-SIGRTMIN);
  else      strcpy(buf,""0"");  /* AIX has NULL; Solaris has EXIT */
",1,unused,171,unused,"    if(sigtable[n].num==signo) return sigtable[n].name;
  }
  if(signo == SIGRTMIN) return ""RTMIN"";
  if(signo) sprintf(buf, ""RTMIN+%d"", signo-SIGRTMIN);
  else      strcpy(buf,""0"");  /* AIX has NULL; Solaris has EXIT */
",unused,procpss-proc2Fsig.c
"        fprintf(stderr, ""Signal \""%s\"" not known.\n"", txt);
        ret = 1;
        goto end;
      }
      amt = sprintf(tmpbuf, ""%s"", signal_number_to_name(val));
",1,unused,193,unused,"        fprintf(stderr, ""Signal \""%s\"" not known.\n"", txt);
        ret = 1;
        goto end;
      }
      amt = sprintf(tmpbuf, ""%s"", signal_number_to_name(val));
",unused,procpss-proc2Fsig.c
"        fprintf(stderr, ""Signal \""%s\"" not known.\n"", txt);
        ret = 1;
        goto end;
      }
      amt = sprintf(tmpbuf, ""%d"", sno);
",1,unused,202,unused,"        fprintf(stderr, ""Signal \""%s\"" not known.\n"", txt);
        ret = 1;
        goto end;
      }
      amt = sprintf(tmpbuf, ""%d"", sno);
",unused,procpss-proc2Fsig.c
"      amt = sprintf(tmpbuf, ""%d"", sno);
    }

    if(!place){
      strcpy(buf,tmpbuf);
",1,unused,206,unused,"      amt = sprintf(tmpbuf, ""%d"", sno);
    }

    if(!place){
      strcpy(buf,tmpbuf);
",unused,procpss-proc2Fsig.c
"      goto end;
    }
    if(amt+place+1 > max_line){
      printf(""%s\n"", buf);
      strcpy(buf,tmpbuf);
",1,unused,212,unused,"      goto end;
    }
    if(amt+place+1 > max_line){
      printf(""%s\n"", buf);
      strcpy(buf,tmpbuf);
",unused,procpss-proc2Fsig.c
"      strcpy(buf,tmpbuf);
      place = amt;
      goto end;
    }
    sprintf(buf+place, "" %s"", tmpbuf);
",1,unused,216,unused,"      strcpy(buf,tmpbuf);
      place = amt;
      goto end;
    }
    sprintf(buf+place, "" %s"", tmpbuf);
",unused,procpss-proc2Fsig.c
"
  if (!human_readable) {
    time(&realseconds);
    realtime = localtime(&realseconds);
    pos = sprintf(buf, "" %02d:%02d:%02d "",
",1,unused,59,unused,"
  if (!human_readable) {
    time(&realseconds);
    realtime = localtime(&realseconds);
    pos = sprintf(buf, "" %02d:%02d:%02d "",
",unused,procpss-proc2Fwhattime.c
"  }
  else
    updays = (int) uptime_secs / (60*60*24);

  strcat (buf, ""up "");
",1,unused,78,unused,"  }
  else
    updays = (int) uptime_secs / (60*60*24);

  strcat (buf, ""up "");
",unused,procpss-proc2Fwhattime.c
"  pos += 3;

  if (!human_readable) {
    if (updays)
      pos += sprintf(buf + pos, ""%d day%s, "", updays, (updays != 1) ? ""s"" : """");
",1,unused,83,unused,"  pos += 3;

  if (!human_readable) {
    if (updays)
      pos += sprintf(buf + pos, ""%d day%s, "", updays, (updays != 1) ? ""s"" : """");
",unused,procpss-proc2Fwhattime.c
"  upminutes = upminutes % 60;

  if (!human_readable) {
    if(uphours)
      pos += sprintf(buf + pos, ""%2d:%02d, "", uphours, upminutes);
",1,unused,93,unused,"  upminutes = upminutes % 60;

  if (!human_readable) {
    if(uphours)
      pos += sprintf(buf + pos, ""%2d:%02d, "", uphours, upminutes);
",unused,procpss-proc2Fwhattime.c
"  if (!human_readable) {
    if(uphours)
      pos += sprintf(buf + pos, ""%2d:%02d, "", uphours, upminutes);
    else
      pos += sprintf(buf + pos, ""%d min, "", upminutes);
",1,unused,95,unused,"  if (!human_readable) {
    if(uphours)
      pos += sprintf(buf + pos, ""%2d:%02d, "", uphours, upminutes);
    else
      pos += sprintf(buf + pos, ""%d min, "", upminutes);
",unused,procpss-proc2Fwhattime.c
"        numuser++;
    }
    endutent();

    pos += sprintf(buf + pos, ""%2d user%s, "", numuser, numuser == 1 ? """" : ""s"");
",1,unused,108,unused,"        numuser++;
    }
    endutent();

    pos += sprintf(buf + pos, ""%2d user%s, "", numuser, numuser == 1 ? """" : ""s"");
",unused,procpss-proc2Fwhattime.c
"    pos += sprintf(buf + pos, ""%2d user%s, "", numuser, numuser == 1 ? """" : ""s"");

    loadavg(&av[0], &av[1], &av[2]);

    pos += sprintf(buf + pos, "" load average: %.2f, %.2f, %.2f"",
",1,unused,112,unused,"    pos += sprintf(buf + pos, ""%2d user%s, "", numuser, numuser == 1 ? """" : ""s"");

    loadavg(&av[0], &av[1], &av[2]);

    pos += sprintf(buf + pos, "" load average: %.2f, %.2f, %.2f"",
",unused,procpss-proc2Fwhattime.c
"  if (human_readable) {
    comma = 0;

    if (updecades) {
      pos += sprintf(buf + pos, ""%d %s"", updecades,
",1,unused,120,unused,"  if (human_readable) {
    comma = 0;

    if (updecades) {
      pos += sprintf(buf + pos, ""%d %s"", updecades,
",unused,procpss-proc2Fwhattime.c
"      comma += 1;
    }

    if (upyears) {
      pos += sprintf(buf + pos, ""%s%d %s"", comma > 0 ? "", "" : """", upyears,
",1,unused,126,unused,"      comma += 1;
    }

    if (upyears) {
      pos += sprintf(buf + pos, ""%s%d %s"", comma > 0 ? "", "" : """", upyears,
",unused,procpss-proc2Fwhattime.c
"      comma += 1;
    }

    if (upweeks) {
      pos += sprintf(buf + pos, ""%s%d %s"", comma > 0 ? "", "" : """", upweeks,
",1,unused,132,unused,"      comma += 1;
    }

    if (upweeks) {
      pos += sprintf(buf + pos, ""%s%d %s"", comma > 0 ? "", "" : """", upweeks,
",unused,procpss-proc2Fwhattime.c
"      comma += 1;
    }

    if (updays) {
      pos += sprintf(buf + pos, ""%s%d %s"", comma > 0 ? "", "" : """", updays,
",1,unused,138,unused,"      comma += 1;
    }

    if (updays) {
      pos += sprintf(buf + pos, ""%s%d %s"", comma > 0 ? "", "" : """", updays,
",unused,procpss-proc2Fwhattime.c
"      comma += 1;
    }

    if (uphours) {
      pos += sprintf(buf + pos, ""%s%d %s"", comma > 0 ? "", "" : """", uphours,
",1,unused,144,unused,"      comma += 1;
    }

    if (uphours) {
      pos += sprintf(buf + pos, ""%s%d %s"", comma > 0 ? "", "" : """", uphours,
",unused,procpss-proc2Fwhattime.c
"      comma += 1;
    }

    if (upminutes) {
      pos += sprintf(buf + pos, ""%s%d %s"", comma > 0 ? "", "" : """", upminutes,
",1,unused,150,unused,"      comma += 1;
    }

    if (upminutes) {
      pos += sprintf(buf + pos, ""%s%d %s"", comma > 0 ? "", "" : """", upminutes,
",unused,procpss-proc2Fwhattime.c
"  /* Arrrgh! somebody defined unix as 1 */
  if(forest_type == 'u') goto unixy;
  while(*p){
    switch(*p){
    case ' ': strcpy(q, ""    "");  break;
",1,unused,345,unused,"  /* Arrrgh! somebody defined unix as 1 */
  if(forest_type == 'u') goto unixy;
  while(*p){
    switch(*p){
    case ' ': strcpy(q, ""    "");  break;
",unused,procpss-ps2Foutput.c
"  if(forest_type == 'u') goto unixy;
  while(*p){
    switch(*p){
    case ' ': strcpy(q, ""    "");  break;
    case 'L': strcpy(q, "" \\_ ""); break;
",1,unused,346,unused,"  if(forest_type == 'u') goto unixy;
  while(*p){
    switch(*p){
    case ' ': strcpy(q, ""    "");  break;
    case 'L': strcpy(q, "" \\_ ""); break;
",unused,procpss-ps2Foutput.c
"  while(*p){
    switch(*p){
    case ' ': strcpy(q, ""    "");  break;
    case 'L': strcpy(q, "" \\_ ""); break;
    case '+': strcpy(q, "" \\_ ""); break;
",1,unused,347,unused,"  while(*p){
    switch(*p){
    case ' ': strcpy(q, ""    "");  break;
    case 'L': strcpy(q, "" \\_ ""); break;
    case '+': strcpy(q, "" \\_ ""); break;
",unused,procpss-ps2Foutput.c
"    switch(*p){
    case ' ': strcpy(q, ""    "");  break;
    case 'L': strcpy(q, "" \\_ ""); break;
    case '+': strcpy(q, "" \\_ ""); break;
    case '|': strcpy(q, "" |  "");  break;
",1,unused,348,unused,"    switch(*p){
    case ' ': strcpy(q, ""    "");  break;
    case 'L': strcpy(q, "" \\_ ""); break;
    case '+': strcpy(q, "" \\_ ""); break;
    case '|': strcpy(q, "" |  "");  break;
",unused,procpss-ps2Foutput.c
"  return q-outbuf;   /* gcc likes this here */
unixy:
  while(*p){
    switch(*p){
    case ' ': strcpy(q, ""  ""); break;
",1,unused,363,unused,"  return q-outbuf;   /* gcc likes this here */
unixy:
  while(*p){
    switch(*p){
    case ' ': strcpy(q, ""  ""); break;
",unused,procpss-ps2Foutput.c
"unixy:
  while(*p){
    switch(*p){
    case ' ': strcpy(q, ""  ""); break;
    case 'L': strcpy(q, ""  ""); break;
",1,unused,364,unused,"unixy:
  while(*p){
    switch(*p){
    case ' ': strcpy(q, ""  ""); break;
    case 'L': strcpy(q, ""  ""); break;
",unused,procpss-ps2Foutput.c
"  while(*p){
    switch(*p){
    case ' ': strcpy(q, ""  ""); break;
    case 'L': strcpy(q, ""  ""); break;
    case '+': strcpy(q, ""  ""); break;
",1,unused,365,unused,"  while(*p){
    switch(*p){
    case ' ': strcpy(q, ""  ""); break;
    case 'L': strcpy(q, ""  ""); break;
    case '+': strcpy(q, ""  ""); break;
",unused,procpss-ps2Foutput.c
"    switch(*p){
    case ' ': strcpy(q, ""  ""); break;
    case 'L': strcpy(q, ""  ""); break;
    case '+': strcpy(q, ""  ""); break;
    case '|': strcpy(q, ""  ""); break;
",1,unused,366,unused,"    switch(*p){
    case ' ': strcpy(q, ""  ""); break;
    case 'L': strcpy(q, ""  ""); break;
    case '+': strcpy(q, ""  ""); break;
    case '|': strcpy(q, ""  ""); break;
",unused,procpss-ps2Foutput.c
"  time_t seconds_ago;
  start = getbtime() + pp->start_time / Hertz;
  seconds_ago = seconds_since_1970 - start;
  if(seconds_ago < 0) seconds_ago=0;
  if(seconds_ago > 3600*24)  strcpy(outbuf, ctime(&start)+4);
",1,unused,879,unused,"  time_t seconds_ago;
  start = getbtime() + pp->start_time / Hertz;
  seconds_ago = seconds_since_1970 - start;
  if(seconds_ago < 0) seconds_ago=0;
  if(seconds_ago > 3600*24)  strcpy(outbuf, ctime(&start)+4);
",unused,procpss-ps2Foutput.c
"  start = getbtime() + pp->start_time / Hertz;
  seconds_ago = seconds_since_1970 - start;
  if(seconds_ago < 0) seconds_ago=0;
  if(seconds_ago > 3600*24)  strcpy(outbuf, ctime(&start)+4);
  else                       strcpy(outbuf, ctime(&start)+10);
",1,unused,880,unused,"  start = getbtime() + pp->start_time / Hertz;
  seconds_ago = seconds_since_1970 - start;
  if(seconds_ago < 0) seconds_ago=0;
  if(seconds_ago > 3600*24)  strcpy(outbuf, ctime(&start)+4);
  else                       strcpy(outbuf, ctime(&start)+10);
",unused,procpss-ps2Foutput.c
"//		    active_cols, max_rightward, max_leftward, actual, correct);

    /* prepare data and calculate leftpad */
    if(likely(p) && likely(fmt->pr)) amount = (*fmt->pr)(outbuf,p);
    else amount = strlen(strcpy(outbuf, fmt->name)); /* AIX or headers */
",1,unused,1997,unused,"//		    active_cols, max_rightward, max_leftward, actual, correct);

    /* prepare data and calculate leftpad */
    if(likely(p) && likely(fmt->pr)) amount = (*fmt->pr)(outbuf,p);
    else amount = strlen(strcpy(outbuf, fmt->name)); /* AIX or headers */
",unused,procpss-ps2Foutput.c
"	int i;
	if (pid == my_pid || pid == 0)
		return;
	/* pid (cmd) state ppid pgrp session tty */
	sprintf(buf, ""/proc/%d/stat"", pid);
",1,unused,180,unused,"	int i;
	if (pid == my_pid || pid == 0)
		return;
	/* pid (cmd) state ppid pgrp session tty */
	sprintf(buf, ""/proc/%d/stat"", pid);
",unused,procpss-skill.c
"	slashdot(outname, '/', '.');

	/* used to open the file */
	tmpname = xmalloc(strlen(name) + strlen(PROC_PATH) + 2);
	strcpy(tmpname, PROC_PATH);
",1,unused,182,unused,"	slashdot(outname, '/', '.');

	/* used to open the file */
	tmpname = xmalloc(strlen(name) + strlen(PROC_PATH) + 2);
	strcpy(tmpname, PROC_PATH);
",unused,procpss-sysctl.c
"
	/* used to open the file */
	tmpname = xmalloc(strlen(name) + strlen(PROC_PATH) + 2);
	strcpy(tmpname, PROC_PATH);
	strcat(tmpname, name);
",1,unused,183,unused,"
	/* used to open the file */
	tmpname = xmalloc(strlen(name) + strlen(PROC_PATH) + 2);
	strcpy(tmpname, PROC_PATH);
	strcat(tmpname, name);
",unused,procpss-sysctl.c
"			tmpdir =
			    (char *restrict) xmalloc(strlen(path) +
						     strlen(de->d_name) +
						     2);
			sprintf(tmpdir, ""%s%s"", path, de->d_name);
",1,unused,330,unused,"			tmpdir =
			    (char *restrict) xmalloc(strlen(path) +
						     strlen(de->d_name) +
						     2);
			sprintf(tmpdir, ""%s%s"", path, de->d_name);
",unused,procpss-sysctl.c
"			if (rc2 != 0) {
				xwarn(_(""cannot stat %s""), tmpdir);
			} else {
				if (S_ISDIR(ts.st_mode)) {
					strcat(tmpdir, ""/"");
",1,unused,336,unused,"			if (rc2 != 0) {
				xwarn(_(""cannot stat %s""), tmpdir);
			} else {
				if (S_ISDIR(ts.st_mode)) {
					strcat(tmpdir, ""/"");
",unused,procpss-sysctl.c
"	}

	/* used to open the file */
	tmpname = xmalloc(equals - name + 1 + strlen(PROC_PATH));
	strcpy(tmpname, PROC_PATH);
",1,unused,389,unused,"	}

	/* used to open the file */
	tmpname = xmalloc(equals - name + 1 + strlen(PROC_PATH));
	strcpy(tmpname, PROC_PATH);
",unused,procpss-sysctl.c
"			while ((*value == ' ' || *value == '\t') && *value != 0)
				value++;

			/* should NameOnly affect this? */
			sprintf(buffer, ""%s=%s"", name, value);
",1,unused,563,unused,"			while ((*value == ' ' || *value == '\t') && *value != 0)
				value++;

			/* should NameOnly affect this? */
			sprintf(buffer, ""%s=%s"", name, value);
",unused,procpss-sysctl.c
"					    strlen(de->d_name) * 2 + 2 +
					    strlen(dirs[di]) + 1);
				cfgs[ncfgs]->name =
				    (char *)cfgs[ncfgs] + sizeof(struct pair);
				strcpy(cfgs[ncfgs]->name, de->d_name);
",1,unused,635,unused,"					    strlen(de->d_name) * 2 + 2 +
					    strlen(dirs[di]) + 1);
				cfgs[ncfgs]->name =
				    (char *)cfgs[ncfgs] + sizeof(struct pair);
				strcpy(cfgs[ncfgs]->name, de->d_name);
",unused,procpss-sysctl.c
"				strcpy(cfgs[ncfgs]->name, de->d_name);
				cfgs[ncfgs]->value =
				    (char *)cfgs[ncfgs] + sizeof(struct pair) +
				    strlen(cfgs[ncfgs]->name) + 1;
				sprintf(cfgs[ncfgs]->value, ""%s/%s"", dirs[di],
",1,unused,639,unused,"				strcpy(cfgs[ncfgs]->name, de->d_name);
				cfgs[ncfgs]->value =
				    (char *)cfgs[ncfgs] + sizeof(struct pair) +
				    strlen(cfgs[ncfgs]->name) + 1;
				sprintf(cfgs[ncfgs]->value, ""%s/%s"", dirs[di],
",unused,procpss-sysctl.c
"
			for (row = nrows - 2; row >= 0; --row)
				*(screen + row * ncols + col) = ' ';
		}
		i = sprintf(screen, "" %.2f, %.2f, %.2f"", av[0], av[1], av[2]);
",1,unused,206,unused,"
			for (row = nrows - 2; row >= 0; --row)
				*(screen + row * ncols + col) = ' ';
		}
		i = sprintf(screen, "" %.2f, %.2f, %.2f"", av[0], av[1], av[2]);
",unused,procpss-tload.c
"   if (1 > totpflgs) totpflgs = 1;
   if (1 > begpflgs) begpflgs = 1;
   snprintf(tmp1, sizeof(tmp1)
      , N_fmt(SCROLL_coord_fmt), Curwin->begtask + 1, begpflgs, totpflgs);
   strcpy(tmp2, tmp1);
",1,unused,890,unused,"   if (1 > totpflgs) totpflgs = 1;
   if (1 > begpflgs) begpflgs = 1;
   snprintf(tmp1, sizeof(tmp1)
      , N_fmt(SCROLL_coord_fmt), Curwin->begtask + 1, begpflgs, totpflgs);
   strcpy(tmp2, tmp1);
",unused,procpss-top2Ftop.c
"

static char *alloc_s (const char *str) MALLOC;
static char *alloc_s (const char *str) {
   return strcpy(alloc_c(strlen(str) +1), str);
",1,unused,931,unused,"

static char *alloc_s (const char *str) MALLOC;
static char *alloc_s (const char *str) {
   return strcpy(alloc_c(strlen(str) +1), str);
",unused,procpss-top2Ftop.c
"   // now let's convert old top's more limited fields...
   j = strlen(q->rc.fieldscur);
   if (j > CVT_FLDMAX)
      return 1;
   strcpy(fields_dst, fields_src);
",1,unused,3397,unused,"   // now let's convert old top's more limited fields...
   j = strlen(q->rc.fieldscur);
   if (j > CVT_FLDMAX)
      return 1;
   strcpy(fields_dst, fields_src);
",unused,procpss-top2Ftop.c
"   }
   // if we turned any suse only fields off, turn 'em back on OUR way...
   if (p1) FLDon(fields_dst[p1 - q->rc.fieldscur]);
   if (p2) FLDon(fields_dst[p2 - q->rc.fieldscur]);
   strcpy(q->rc.fieldscur, fields_dst);
",1,unused,3416,unused,"   }
   // if we turned any suse only fields off, turn 'em back on OUR way...
   if (p1) FLDon(fields_dst[p1 - q->rc.fieldscur]);
   if (p2) FLDon(fields_dst[p2 - q->rc.fieldscur]);
   strcpy(q->rc.fieldscur, fields_dst);
",unused,procpss-top2Ftop.c
"
         if (!fgets(fbuf, sizeof(fbuf), fp)) break;
         lraw += strlen(fbuf) +1;
         Inspect.raw = alloc_r(Inspect.raw, lraw);
         strcat(Inspect.raw, fbuf);
",1,unused,3542,unused,"
         if (!fgets(fbuf, sizeof(fbuf), fp)) break;
         lraw += strlen(fbuf) +1;
         Inspect.raw = alloc_r(Inspect.raw, lraw);
         strcat(Inspect.raw, fbuf);
",unused,procpss-top2Ftop.c
"   Curwin->osel_1st = osel;
   Curwin->osel_tot += 1;
   if (!Curwin->osel_prt) Curwin->osel_prt = alloc_c(strlen(raw) + 3);
   else Curwin->osel_prt = alloc_r(Curwin->osel_prt, strlen(Curwin->osel_prt) + strlen(raw) + 6);
   strcat(Curwin->osel_prt, fmtmk(""%s'%s'"", (Curwin->osel_tot > 1) ? "" + "" : """", raw));
",1,unused,4305,unused,"   Curwin->osel_1st = osel;
   Curwin->osel_tot += 1;
   if (!Curwin->osel_prt) Curwin->osel_prt = alloc_c(strlen(raw) + 3);
   else Curwin->osel_prt = alloc_r(Curwin->osel_prt, strlen(Curwin->osel_prt) + strlen(raw) + 6);
   strcat(Curwin->osel_prt, fmtmk(""%s'%s'"", (Curwin->osel_tot > 1) ? "" + "" : """", raw));
",unused,procpss-top2Ftop.c
"		}
		if (ut_addr_v6[1] || ut_addr_v6[2] || ut_addr_v6[3]) {
			/* IPv6 */
			if (!inet_ntop(AF_INET6, &ut_addr_v6, buf_ipv6, sizeof(buf_ipv6))) {
				strcpy(buf, """"); /* invalid address, clean the buffer */
",1,unused,205,unused,"		}
		if (ut_addr_v6[1] || ut_addr_v6[2] || ut_addr_v6[3]) {
			/* IPv6 */
			if (!inet_ntop(AF_INET6, &ut_addr_v6, buf_ipv6, sizeof(buf_ipv6))) {
				strcpy(buf, """"); /* invalid address, clean the buffer */
",unused,procpss-w.c
"			}
		} else {
			/* IPv4 */
			if (!(ut_addr_v6[0] && inet_ntop(AF_INET, &ut_addr_v6[0], buf, sizeof(buf)))) {
				strcpy(buf, """"); /* invalid address, clean the buffer */
",1,unused,212,unused,"			}
		} else {
			/* IPv4 */
			if (!(ut_addr_v6[0] && inet_ntop(AF_INET, &ut_addr_v6[0], buf, sizeof(buf)))) {
				strcpy(buf, """"); /* invalid address, clean the buffer */
",unused,procpss-w.c
"				if (isprint(*cptr))
					pptr->command[cmdlen++] = *cptr;
				else if (cmdlen < (MAX_CMDNAME - 4))
					cmdlen +=
					    sprintf(&(pptr->command[cmdlen]),
",1,unused,422,unused,"				if (isprint(*cptr))
					pptr->command[cmdlen++] = *cptr;
				else if (cmdlen < (MAX_CMDNAME - 4))
					cmdlen +=
					    sprintf(&(pptr->command[cmdlen]),
",unused,psmiscdebian-src2Ffuser.c
"				option = option_buf;
				for (optr = options; optr->name != NULL; optr++) {
					if (strcmp(current_argv + 2, optr->name)
					    == 0) {
						sprintf(option_buf, ""-%c"",
",1,unused,988,unused,"				option = option_buf;
				for (optr = options; optr->name != NULL; optr++) {
					if (strcmp(current_argv + 2, optr->name)
					    == 0) {
						sprintf(option_buf, ""-%c"",
",unused,psmiscdebian-src2Ffuser.c
"
static void convert_bytes(char *buf, unsigned long bytes)
{
  if (bytes > (10000000))
	sprintf(buf, ""%lu MB"",bytes/1000000L);
",1,unused,105,unused,"
static void convert_bytes(char *buf, unsigned long bytes)
{
  if (bytes > (10000000))
	sprintf(buf, ""%lu MB"",bytes/1000000L);
",unused,psmiscdebian-src2Fprtstat.c
"{
  if (bytes > (10000000))
	sprintf(buf, ""%lu MB"",bytes/1000000L);
  else if (bytes > (10000))
	sprintf(buf, ""%lu kB"", bytes/1000L);
",1,unused,107,unused,"{
  if (bytes > (10000000))
	sprintf(buf, ""%lu MB"",bytes/1000000L);
  else if (bytes > (10000))
	sprintf(buf, ""%lu kB"", bytes/1000L);
",unused,psmiscdebian-src2Fprtstat.c
"	sprintf(buf, ""%lu MB"",bytes/1000000L);
  else if (bytes > (10000))
	sprintf(buf, ""%lu kB"", bytes/1000L);
  else
	sprintf(buf, ""%lu B"", bytes);
",1,unused,109,unused,"	sprintf(buf, ""%lu MB"",bytes/1000000L);
  else if (bytes > (10000))
	sprintf(buf, ""%lu kB"", bytes/1000L);
  else
	sprintf(buf, ""%lu B"", bytes);
",unused,psmiscdebian-src2Fprtstat.c
"/* minor is bits 31-20 and 7-0, major is 15-8 */
static char *convert_tty(int tty_nr)
{
  static char buf[20];
  sprintf(buf, ""%d:%d"",(tty_nr & 0xff00)>>8,(tty_nr & 0xff)|((tty_nr & 0xfff00000)>>20));
",1,unused,125,unused,"/* minor is bits 31-20 and 7-0, major is 15-8 */
static char *convert_tty(int tty_nr)
{
  static char buf[20];
  sprintf(buf, ""%d:%d"",(tty_nr & 0xff00)>>8,(tty_nr & 0xff)|((tty_nr & 0xfff00000)>>20));
",unused,psmiscdebian-src2Fprtstat.c
"    } else if (*here >= ' ' && *here <= '~') {
      out_char(*here);
      strcount++;
    } else {
      sprintf(tmpstr, ""\\%03o"", (unsigned char) *here);
",1,unused,584,unused,"    } else if (*here >= ' ' && *here <= '~') {
      out_char(*here);
      strcount++;
    } else {
      sprintf(tmpstr, ""\\%03o"", (unsigned char) *here);
",unused,psmiscdebian-src2Fpstree.c
"	    if ((thread_comm = strchr(readbuf, '('))
		    && (endcomm = strrchr(thread_comm, ')'))) {
		++thread_comm;
		*endcomm = '\0';
		sprintf(threadname, ""{%.*s}"", COMM_LEN, thread_comm);
",1,unused,814,unused,"	    if ((thread_comm = strchr(readbuf, '('))
		    && (endcomm = strrchr(thread_comm, ')'))) {
		++thread_comm;
		*endcomm = '\0';
		sprintf(threadname, ""{%.*s}"", COMM_LEN, thread_comm);
",unused,psmiscdebian-src2Fpstree.c
"	    }
	}
    }
    /* Fall back to old method */
    sprintf(threadname, ""{%.*s}"", COMM_LEN, comm);
",1,unused,821,unused,"	    }
	}
    }
    /* Fall back to old method */
    sprintf(threadname, ""{%.*s}"", COMM_LEN, comm);
",unused,psmiscdebian-src2Fpstree.c
"    pid = (pid_t) strtol(de->d_name, &endptr, 10);
    if (endptr != de->d_name && endptr[0] == '\0') {
      if (! (path = malloc(strlen(PROC_BASE) + strlen(de->d_name) + 10)))
        exit(2);
      sprintf(path, ""%s/%d/stat"", PROC_BASE, pid);
",1,unused,870,unused,"    pid = (pid_t) strtol(de->d_name, &endptr, 10);
    if (endptr != de->d_name && endptr[0] == '\0') {
      if (! (path = malloc(strlen(PROC_BASE) + strlen(de->d_name) + 10)))
        exit(2);
      sprintf(path, ""%s/%d/stat"", PROC_BASE, pid);
",unused,psmiscdebian-src2Fpstree.c
"        exit(2);
      sprintf(path, ""%s/%d/stat"", PROC_BASE, pid);
      if ((file = fopen(path, ""r"")) != NULL) {
        empty = 0;
        sprintf(path, ""%s/%d"", PROC_BASE, pid);
",1,unused,873,unused,"        exit(2);
      sprintf(path, ""%s/%d/stat"", PROC_BASE, pid);
      if ((file = fopen(path, ""r"")) != NULL) {
        empty = 0;
        sprintf(path, ""%s/%d"", PROC_BASE, pid);
",unused,psmiscdebian-src2Fpstree.c
"              int thread;

              if (! (taskpath = malloc(strlen(path) + 10)))
                exit(2);
              sprintf(taskpath, ""%s/task"", path);
",1,unused,905,unused,"              int thread;

              if (! (taskpath = malloc(strlen(path) + 10)))
                exit(2);
              sprintf(taskpath, ""%s/task"", path);
",unused,psmiscdebian-src2Fpstree.c
"              free(taskpath);
              if (!print_args)
                add_proc(comm, pid, ppid, pgid, st.st_uid, NULL, 0, 0, scontext);
              else {
                sprintf(path, ""%s/%d/cmdline"", PROC_BASE, pid);
",1,unused,930,unused,"              free(taskpath);
              if (!print_args)
                add_proc(comm, pid, ppid, pgid, st.st_uid, NULL, 0, 0, scontext);
              else {
                sprintf(path, ""%s/%d/cmdline"", PROC_BASE, pid);
",unused,psmiscdebian-src2Fpstree.c
"				if (isprint(*cptr))
					pptr->command[cmdlen++] = *cptr;
				else if (cmdlen < (MAX_CMDNAME - 4))
					cmdlen +=
					    sprintf(&(pptr->command[cmdlen]),
",1,unused,422,unused,"				if (isprint(*cptr))
					pptr->command[cmdlen++] = *cptr;
				else if (cmdlen < (MAX_CMDNAME - 4))
					cmdlen +=
					    sprintf(&(pptr->command[cmdlen]),
",unused,psmiscpatchxen-src2Ffuser.c
"				option = option_buf;
				for (optr = options; optr->name != NULL; optr++) {
					if (strcmp(current_argv + 2, optr->name)
					    == 0) {
						sprintf(option_buf, ""-%c"",
",1,unused,988,unused,"				option = option_buf;
				for (optr = options; optr->name != NULL; optr++) {
					if (strcmp(current_argv + 2, optr->name)
					    == 0) {
						sprintf(option_buf, ""-%c"",
",unused,psmiscpatchxen-src2Ffuser.c
"
static void convert_bytes(char *buf, unsigned long bytes)
{
  if (bytes > (10000000))
	sprintf(buf, ""%lu MB"",bytes/1000000L);
",1,unused,105,unused,"
static void convert_bytes(char *buf, unsigned long bytes)
{
  if (bytes > (10000000))
	sprintf(buf, ""%lu MB"",bytes/1000000L);
",unused,psmiscpatchxen-src2Fprtstat.c
"{
  if (bytes > (10000000))
	sprintf(buf, ""%lu MB"",bytes/1000000L);
  else if (bytes > (10000))
	sprintf(buf, ""%lu kB"", bytes/1000L);
",1,unused,107,unused,"{
  if (bytes > (10000000))
	sprintf(buf, ""%lu MB"",bytes/1000000L);
  else if (bytes > (10000))
	sprintf(buf, ""%lu kB"", bytes/1000L);
",unused,psmiscpatchxen-src2Fprtstat.c
"	sprintf(buf, ""%lu MB"",bytes/1000000L);
  else if (bytes > (10000))
	sprintf(buf, ""%lu kB"", bytes/1000L);
  else
	sprintf(buf, ""%lu B"", bytes);
",1,unused,109,unused,"	sprintf(buf, ""%lu MB"",bytes/1000000L);
  else if (bytes > (10000))
	sprintf(buf, ""%lu kB"", bytes/1000L);
  else
	sprintf(buf, ""%lu B"", bytes);
",unused,psmiscpatchxen-src2Fprtstat.c
"/* minor is bits 31-20 and 7-0, major is 15-8 */
static char *convert_tty(int tty_nr)
{
  static char buf[20];
  sprintf(buf, ""%d:%d"",(tty_nr & 0xff00)>>8,(tty_nr & 0xff)|((tty_nr & 0xfff00000)>>20));
",1,unused,125,unused,"/* minor is bits 31-20 and 7-0, major is 15-8 */
static char *convert_tty(int tty_nr)
{
  static char buf[20];
  sprintf(buf, ""%d:%d"",(tty_nr & 0xff00)>>8,(tty_nr & 0xff)|((tty_nr & 0xfff00000)>>20));
",unused,psmiscpatchxen-src2Fprtstat.c
"    } else if (*here >= ' ' && *here <= '~') {
      out_char(*here);
      strcount++;
    } else {
      sprintf(tmpstr, ""\\%03o"", (unsigned char) *here);
",1,unused,584,unused,"    } else if (*here >= ' ' && *here <= '~') {
      out_char(*here);
      strcount++;
    } else {
      sprintf(tmpstr, ""\\%03o"", (unsigned char) *here);
",unused,psmiscpatchxen-src2Fpstree.c
"	    if ((thread_comm = strchr(readbuf, '('))
		    && (endcomm = strrchr(thread_comm, ')'))) {
		++thread_comm;
		*endcomm = '\0';
		sprintf(threadname, ""{%.*s}"", COMM_LEN, thread_comm);
",1,unused,814,unused,"	    if ((thread_comm = strchr(readbuf, '('))
		    && (endcomm = strrchr(thread_comm, ')'))) {
		++thread_comm;
		*endcomm = '\0';
		sprintf(threadname, ""{%.*s}"", COMM_LEN, thread_comm);
",unused,psmiscpatchxen-src2Fpstree.c
"	    }
	}
    }
    /* Fall back to old method */
    sprintf(threadname, ""{%.*s}"", COMM_LEN, comm);
",1,unused,821,unused,"	    }
	}
    }
    /* Fall back to old method */
    sprintf(threadname, ""{%.*s}"", COMM_LEN, comm);
",unused,psmiscpatchxen-src2Fpstree.c
"    pid = (pid_t) strtol(de->d_name, &endptr, 10);
    if (endptr != de->d_name && endptr[0] == '\0') {
      if (! (path = malloc(strlen(PROC_BASE) + strlen(de->d_name) + 10)))
        exit(2);
      sprintf(path, ""%s/%d/stat"", PROC_BASE, pid);
",1,unused,870,unused,"    pid = (pid_t) strtol(de->d_name, &endptr, 10);
    if (endptr != de->d_name && endptr[0] == '\0') {
      if (! (path = malloc(strlen(PROC_BASE) + strlen(de->d_name) + 10)))
        exit(2);
      sprintf(path, ""%s/%d/stat"", PROC_BASE, pid);
",unused,psmiscpatchxen-src2Fpstree.c
"        exit(2);
      sprintf(path, ""%s/%d/stat"", PROC_BASE, pid);
      if ((file = fopen(path, ""r"")) != NULL) {
        empty = 0;
        sprintf(path, ""%s/%d"", PROC_BASE, pid);
",1,unused,873,unused,"        exit(2);
      sprintf(path, ""%s/%d/stat"", PROC_BASE, pid);
      if ((file = fopen(path, ""r"")) != NULL) {
        empty = 0;
        sprintf(path, ""%s/%d"", PROC_BASE, pid);
",unused,psmiscpatchxen-src2Fpstree.c
"              int thread;

              if (! (taskpath = malloc(strlen(path) + 10)))
                exit(2);
              sprintf(taskpath, ""%s/task"", path);
",1,unused,905,unused,"              int thread;

              if (! (taskpath = malloc(strlen(path) + 10)))
                exit(2);
              sprintf(taskpath, ""%s/task"", path);
",unused,psmiscpatchxen-src2Fpstree.c
"              free(taskpath);
              if (!print_args)
                add_proc(comm, pid, ppid, pgid, st.st_uid, NULL, 0, 0, scontext);
              else {
                sprintf(path, ""%s/%d/cmdline"", PROC_BASE, pid);
",1,unused,930,unused,"              free(taskpath);
              if (!print_args)
                add_proc(comm, pid, ppid, pgid, st.st_uid, NULL, 0, 0, scontext);
              else {
                sprintf(path, ""%s/%d/cmdline"", PROC_BASE, pid);
",unused,psmiscpatchxen-src2Fpstree.c
"
static void convert_bytes(char *buf, unsigned long bytes)
{
  if (bytes > (10000000))
	sprintf(buf, ""%lu MB"",bytes/1000000L);
",1,unused,105,unused,"
static void convert_bytes(char *buf, unsigned long bytes)
{
  if (bytes > (10000000))
	sprintf(buf, ""%lu MB"",bytes/1000000L);
",unused,psmisctrusty-src2Fprtstat.c
"{
  if (bytes > (10000000))
	sprintf(buf, ""%lu MB"",bytes/1000000L);
  else if (bytes > (10000))
	sprintf(buf, ""%lu kB"", bytes/1000L);
",1,unused,107,unused,"{
  if (bytes > (10000000))
	sprintf(buf, ""%lu MB"",bytes/1000000L);
  else if (bytes > (10000))
	sprintf(buf, ""%lu kB"", bytes/1000L);
",unused,psmisctrusty-src2Fprtstat.c
"	sprintf(buf, ""%lu MB"",bytes/1000000L);
  else if (bytes > (10000))
	sprintf(buf, ""%lu kB"", bytes/1000L);
  else
	sprintf(buf, ""%lu B"", bytes);
",1,unused,109,unused,"	sprintf(buf, ""%lu MB"",bytes/1000000L);
  else if (bytes > (10000))
	sprintf(buf, ""%lu kB"", bytes/1000L);
  else
	sprintf(buf, ""%lu B"", bytes);
",unused,psmisctrusty-src2Fprtstat.c
"/* minor is bits 31-20 and 7-0, major is 15-8 */
static char *convert_tty(int tty_nr)
{
  static char buf[20];
  sprintf(buf, ""%d:%d"",(tty_nr & 0xff00)>>8,(tty_nr & 0xff)|((tty_nr & 0xfff00000)>>20));
",1,unused,125,unused,"/* minor is bits 31-20 and 7-0, major is 15-8 */
static char *convert_tty(int tty_nr)
{
  static char buf[20];
  sprintf(buf, ""%d:%d"",(tty_nr & 0xff00)>>8,(tty_nr & 0xff)|((tty_nr & 0xfff00000)>>20));
",unused,psmisctrusty-src2Fprtstat.c
"    } else if (*here >= ' ' && *here <= '~') {
      out_char(*here);
      strcount++;
    } else {
      sprintf(tmpstr, ""\\%03o"", (unsigned char) *here);
",1,unused,439,unused,"    } else if (*here >= ' ' && *here <= '~') {
      out_char(*here);
      strcount++;
    } else {
      sprintf(tmpstr, ""\\%03o"", (unsigned char) *here);
",unused,psmisctrusty-src2Fpstree.c
"    pid = (pid_t) strtol(de->d_name, &endptr, 10);
    if (endptr != de->d_name && endptr[0] == '\0') {
      if (! (path = malloc(strlen(PROC_BASE) + strlen(de->d_name) + 10)))
        exit(2);
      sprintf(path, ""%s/%d/stat"", PROC_BASE, pid);
",1,unused,682,unused,"    pid = (pid_t) strtol(de->d_name, &endptr, 10);
    if (endptr != de->d_name && endptr[0] == '\0') {
      if (! (path = malloc(strlen(PROC_BASE) + strlen(de->d_name) + 10)))
        exit(2);
      sprintf(path, ""%s/%d/stat"", PROC_BASE, pid);
",unused,psmisctrusty-src2Fpstree.c
"        exit(2);
      sprintf(path, ""%s/%d/stat"", PROC_BASE, pid);
      if ((file = fopen(path, ""r"")) != NULL) {
        empty = 0;
        sprintf(path, ""%s/%d"", PROC_BASE, pid);
",1,unused,685,unused,"        exit(2);
      sprintf(path, ""%s/%d/stat"", PROC_BASE, pid);
      if ((file = fopen(path, ""r"")) != NULL) {
        empty = 0;
        sprintf(path, ""%s/%d"", PROC_BASE, pid);
",unused,psmisctrusty-src2Fpstree.c
"              int thread;

              if (! (taskpath = malloc(strlen(path) + 10)))
                exit(2);
              sprintf(taskpath, ""%s/task"", path);
",1,unused,718,unused,"              int thread;

              if (! (taskpath = malloc(strlen(path) + 10)))
                exit(2);
              sprintf(taskpath, ""%s/task"", path);
",unused,psmisctrusty-src2Fpstree.c
"                /* if we have this dir, we're on 2.6 */
                if (! (threadname = malloc(COMM_LEN + 2 + 1))) {
                    exit(2);
                }
                sprintf(threadname, ""{%.*s}"", COMM_LEN, comm);
",1,unused,725,unused,"                /* if we have this dir, we're on 2.6 */
                if (! (threadname = malloc(COMM_LEN + 2 + 1))) {
                    exit(2);
                }
                sprintf(threadname, ""{%.*s}"", COMM_LEN, comm);
",unused,psmisctrusty-src2Fpstree.c
"#else                /*WITH_SELINUX */
                add_proc(comm, pid, ppid, pgid, st.st_uid, NULL, 0, 0);
#endif                /*WITH_SELINUX */
              else {
                sprintf(path, ""%s/%d/cmdline"", PROC_BASE, pid);
",1,unused,758,unused,"#else                /*WITH_SELINUX */
                add_proc(comm, pid, ppid, pgid, st.st_uid, NULL, 0, 0);
#endif                /*WITH_SELINUX */
              else {
                sprintf(path, ""%s/%d/cmdline"", PROC_BASE, pid);
",unused,psmisctrusty-src2Fpstree.c
"				if (isprint(*cptr))
					pptr->command[cmdlen++] = *cptr;
				else if (cmdlen < (MAX_CMDNAME - 4))
					cmdlen +=
					    sprintf(&(pptr->command[cmdlen]),
",1,unused,422,unused,"				if (isprint(*cptr))
					pptr->command[cmdlen++] = *cptr;
				else if (cmdlen < (MAX_CMDNAME - 4))
					cmdlen +=
					    sprintf(&(pptr->command[cmdlen]),
",unused,psmiscxenial-src2Ffuser.c
"				option = option_buf;
				for (optr = options; optr->name != NULL; optr++) {
					if (strcmp(current_argv + 2, optr->name)
					    == 0) {
						sprintf(option_buf, ""-%c"",
",1,unused,988,unused,"				option = option_buf;
				for (optr = options; optr->name != NULL; optr++) {
					if (strcmp(current_argv + 2, optr->name)
					    == 0) {
						sprintf(option_buf, ""-%c"",
",unused,psmiscxenial-src2Ffuser.c
"
static void convert_bytes(char *buf, unsigned long bytes)
{
  if (bytes > (10000000))
	sprintf(buf, ""%lu MB"",bytes/1000000L);
",1,unused,105,unused,"
static void convert_bytes(char *buf, unsigned long bytes)
{
  if (bytes > (10000000))
	sprintf(buf, ""%lu MB"",bytes/1000000L);
",unused,psmiscxenial-src2Fprtstat.c
"{
  if (bytes > (10000000))
	sprintf(buf, ""%lu MB"",bytes/1000000L);
  else if (bytes > (10000))
	sprintf(buf, ""%lu kB"", bytes/1000L);
",1,unused,107,unused,"{
  if (bytes > (10000000))
	sprintf(buf, ""%lu MB"",bytes/1000000L);
  else if (bytes > (10000))
	sprintf(buf, ""%lu kB"", bytes/1000L);
",unused,psmiscxenial-src2Fprtstat.c
"	sprintf(buf, ""%lu MB"",bytes/1000000L);
  else if (bytes > (10000))
	sprintf(buf, ""%lu kB"", bytes/1000L);
  else
	sprintf(buf, ""%lu B"", bytes);
",1,unused,109,unused,"	sprintf(buf, ""%lu MB"",bytes/1000000L);
  else if (bytes > (10000))
	sprintf(buf, ""%lu kB"", bytes/1000L);
  else
	sprintf(buf, ""%lu B"", bytes);
",unused,psmiscxenial-src2Fprtstat.c
"/* minor is bits 31-20 and 7-0, major is 15-8 */
static char *convert_tty(int tty_nr)
{
  static char buf[20];
  sprintf(buf, ""%d:%d"",(tty_nr & 0xff00)>>8,(tty_nr & 0xff)|((tty_nr & 0xfff00000)>>20));
",1,unused,125,unused,"/* minor is bits 31-20 and 7-0, major is 15-8 */
static char *convert_tty(int tty_nr)
{
  static char buf[20];
  sprintf(buf, ""%d:%d"",(tty_nr & 0xff00)>>8,(tty_nr & 0xff)|((tty_nr & 0xfff00000)>>20));
",unused,psmiscxenial-src2Fprtstat.c
"    } else if (*here >= ' ' && *here <= '~') {
      out_char(*here);
      strcount++;
    } else {
      sprintf(tmpstr, ""\\%03o"", (unsigned char) *here);
",1,unused,584,unused,"    } else if (*here >= ' ' && *here <= '~') {
      out_char(*here);
      strcount++;
    } else {
      sprintf(tmpstr, ""\\%03o"", (unsigned char) *here);
",unused,psmiscxenial-src2Fpstree.c
"	    if ((thread_comm = strchr(readbuf, '('))
		    && (endcomm = strrchr(thread_comm, ')'))) {
		++thread_comm;
		*endcomm = '\0';
		sprintf(threadname, ""{%.*s}"", COMM_LEN, thread_comm);
",1,unused,814,unused,"	    if ((thread_comm = strchr(readbuf, '('))
		    && (endcomm = strrchr(thread_comm, ')'))) {
		++thread_comm;
		*endcomm = '\0';
		sprintf(threadname, ""{%.*s}"", COMM_LEN, thread_comm);
",unused,psmiscxenial-src2Fpstree.c
"	    }
	}
    }
    /* Fall back to old method */
    sprintf(threadname, ""{%.*s}"", COMM_LEN, comm);
",1,unused,821,unused,"	    }
	}
    }
    /* Fall back to old method */
    sprintf(threadname, ""{%.*s}"", COMM_LEN, comm);
",unused,psmiscxenial-src2Fpstree.c
"    pid = (pid_t) strtol(de->d_name, &endptr, 10);
    if (endptr != de->d_name && endptr[0] == '\0') {
      if (! (path = malloc(strlen(PROC_BASE) + strlen(de->d_name) + 10)))
        exit(2);
      sprintf(path, ""%s/%d/stat"", PROC_BASE, pid);
",1,unused,870,unused,"    pid = (pid_t) strtol(de->d_name, &endptr, 10);
    if (endptr != de->d_name && endptr[0] == '\0') {
      if (! (path = malloc(strlen(PROC_BASE) + strlen(de->d_name) + 10)))
        exit(2);
      sprintf(path, ""%s/%d/stat"", PROC_BASE, pid);
",unused,psmiscxenial-src2Fpstree.c
"        exit(2);
      sprintf(path, ""%s/%d/stat"", PROC_BASE, pid);
      if ((file = fopen(path, ""r"")) != NULL) {
        empty = 0;
        sprintf(path, ""%s/%d"", PROC_BASE, pid);
",1,unused,873,unused,"        exit(2);
      sprintf(path, ""%s/%d/stat"", PROC_BASE, pid);
      if ((file = fopen(path, ""r"")) != NULL) {
        empty = 0;
        sprintf(path, ""%s/%d"", PROC_BASE, pid);
",unused,psmiscxenial-src2Fpstree.c
"              int thread;

              if (! (taskpath = malloc(strlen(path) + 10)))
                exit(2);
              sprintf(taskpath, ""%s/task"", path);
",1,unused,905,unused,"              int thread;

              if (! (taskpath = malloc(strlen(path) + 10)))
                exit(2);
              sprintf(taskpath, ""%s/task"", path);
",unused,psmiscxenial-src2Fpstree.c
"              free(taskpath);
              if (!print_args)
                add_proc(comm, pid, ppid, pgid, st.st_uid, NULL, 0, 0, scontext);
              else {
                sprintf(path, ""%s/%d/cmdline"", PROC_BASE, pid);
",1,unused,930,unused,"              free(taskpath);
              if (!print_args)
                add_proc(comm, pid, ppid, pgid, st.st_uid, NULL, 0, 0, scontext);
              else {
                sprintf(path, ""%s/%d/cmdline"", PROC_BASE, pid);
",unused,psmiscxenial-src2Fpstree.c
"		exit(1);
	}

	saun.sun_family = AF_UNIX;
	strcpy(saun.sun_path, ctrlsock_name);
",1,unused,196,unused,"		exit(1);
	}

	saun.sun_family = AF_UNIX;
	strcpy(saun.sun_path, ctrlsock_name);
",unused,rdesktop-integration-integration-ctrl.c
"	}

	memset(&saun, 0, sizeof(struct sockaddr_un));
	saun.sun_family = AF_UNIX;
	strcpy(saun.sun_path, ctrlsock_name);
",1,unused,471,unused,"	}

	memset(&saun, 0, sizeof(struct sockaddr_un));
	saun.sun_family = AF_UNIX;
	strcpy(saun.sun_path, ctrlsock_name);
",unused,rdesktop-integration-integration-ctrl.c
"		strncpy(pdisk_data->name, optarg, sizeof(pdisk_data->name) - 1);
		strncpy(g_rdpdr_device[*id].name, optarg, sizeof(g_rdpdr_device[*id].name) - 1);

		g_rdpdr_device[*id].local_path = (char *) xmalloc(strlen(pos2) + 1);
		strcpy(g_rdpdr_device[*id].local_path, pos2);
",1,unused,334,unused,"		strncpy(pdisk_data->name, optarg, sizeof(pdisk_data->name) - 1);
		strncpy(g_rdpdr_device[*id].name, optarg, sizeof(g_rdpdr_device[*id].name) - 1);

		g_rdpdr_device[*id].local_path = (char *) xmalloc(strlen(pos2) + 1);
		strcpy(g_rdpdr_device[*id].local_path, pos2);
",unused,rdesktop-integration-integration-disk.c
"
	if (filename && *filename && filename[strlen(filename) - 1] == '/')
		filename[strlen(filename) - 1] = 0;

	sprintf(path, ""%s%s"", g_rdpdr_device[device_id].local_path, filename ? filename : """");
",1,unused,365,unused,"
	if (filename && *filename && filename[strlen(filename) - 1] == '/')
		filename[strlen(filename) - 1] = 0;

	sprintf(path, ""%s%s"", g_rdpdr_device[device_id].local_path, filename ? filename : """");
",unused,rdesktop-integration-integration-disk.c
"				return RD_STATUS_INVALID_PARAMETER;

			convert_to_unix_filename(newname);

			sprintf(fullpath, ""%s%s"", g_rdpdr_device[pfinfo->device_id].local_path,
",1,unused,839,unused,"				return RD_STATUS_INVALID_PARAMETER;

			convert_to_unix_filename(newname);

			sprintf(fullpath, ""%s%s"", g_rdpdr_device[pfinfo->device_id].local_path,
",unused,rdesktop-integration-integration-disk.c
"		if (!strcmp(dp->d_name, ""."") || !strcmp(dp->d_name, ""..""))
			continue;
		p->num_entries++;
		fullname = (char *) xmalloc(strlen(pfinfo->path) + strlen(dp->d_name) + 2);
		sprintf(fullname, ""%s/%s"", pfinfo->path, dp->d_name);
",1,unused,1030,unused,"		if (!strcmp(dp->d_name, ""."") || !strcmp(dp->d_name, ""..""))
			continue;
		p->num_entries++;
		fullname = (char *) xmalloc(strlen(pfinfo->path) + strlen(dp->d_name) + 2);
		sprintf(fullname, ""%s/%s"", pfinfo->path, dp->d_name);
",unused,rdesktop-integration-integration-disk.c
"#endif

	/* initialize */
	memset(&info, 0, sizeof(info));
	strcpy(info.label, ""RDESKTOP"");
",1,unused,1056,unused,"#endif

	/* initialize */
	memset(&info, 0, sizeof(info));
	strcpy(info.label, ""RDESKTOP"");
",unused,rdesktop-integration-integration-disk.c
"
	/* initialize */
	memset(&info, 0, sizeof(info));
	strcpy(info.label, ""RDESKTOP"");
	strcpy(info.type, ""RDPFS"");
",1,unused,1057,unused,"
	/* initialize */
	memset(&info, 0, sizeof(info));
	strcpy(info.label, ""RDESKTOP"");
	strcpy(info.type, ""RDPFS"");
",unused,rdesktop-integration-integration-disk.c
"	while ((e = getmntent(fdfs)))
	{
		if (str_startswith(e->mnt_dir, fpath))
		{
			strcpy(info.type, e->mnt_type);
",1,unused,1068,unused,"	while ((e = getmntent(fdfs)))
	{
		if (str_startswith(e->mnt_dir, fpath))
		{
			strcpy(info.type, e->mnt_type);
",unused,rdesktop-integration-integration-disk.c
"	{
		if (str_startswith(e->mnt_dir, fpath))
		{
			strcpy(info.type, e->mnt_type);
			strcpy(info.name, e->mnt_fsname);
",1,unused,1069,unused,"	{
		if (str_startswith(e->mnt_dir, fpath))
		{
			strcpy(info.type, e->mnt_type);
			strcpy(info.name, e->mnt_fsname);
",unused,rdesktop-integration-integration-disk.c
"					memset(buf, 0, sizeof(buf));
					if (strstr(e->mnt_opts, ""vfat""))
						 /*FAT*/
					{
						strcpy(info.type, ""vfat"");
",1,unused,1080,unused,"					memset(buf, 0, sizeof(buf));
					if (strstr(e->mnt_opts, ""vfat""))
						 /*FAT*/
					{
						strcpy(info.type, ""vfat"");
",unused,rdesktop-integration-integration-disk.c
"			if (pdirent == NULL)
				return RD_STATUS_NO_MORE_FILES;

			/* Get information for directory entry */
			sprintf(fullpath, ""%s/%s"", dirname, pdirent->d_name);
",1,unused,1229,unused,"			if (pdirent == NULL)
				return RD_STATUS_NO_MORE_FILES;

			/* Get information for directory entry */
			sprintf(fullpath, ""%s/%s"", dirname, pdirent->d_name);
",unused,rdesktop-integration-integration-disk.c
"	{
		ppar_info = (PARALLEL_DEVICE *) xmalloc(sizeof(PARALLEL_DEVICE));

		pos2 = next_arg(optarg, '=');
		strcpy(g_rdpdr_device[*id].name, optarg);
",1,unused,57,unused,"	{
		ppar_info = (PARALLEL_DEVICE *) xmalloc(sizeof(PARALLEL_DEVICE));

		pos2 = next_arg(optarg, '=');
		strcpy(g_rdpdr_device[*id].name, optarg);
",unused,rdesktop-integration-integration-parallel.c
"
		toupper_str(g_rdpdr_device[*id].name);

		g_rdpdr_device[*id].local_path = xmalloc(strlen(pos2) + 1);
		strcpy(g_rdpdr_device[*id].local_path, pos2);
",1,unused,62,unused,"
		toupper_str(g_rdpdr_device[*id].name);

		g_rdpdr_device[*id].local_path = xmalloc(strlen(pos2) + 1);
		strcpy(g_rdpdr_device[*id].local_path, pos2);
",unused,rdesktop-integration-integration-parallel.c
"	while ((pos = next_arg(optarg, ',')) && *id < RDPDR_MAX_DEVICES)
	{
		pprinter_data = (PRINTER *) xmalloc(sizeof(PRINTER));

		strcpy(g_rdpdr_device[*id].name, ""PRN"");
",1,unused,64,unused,"	while ((pos = next_arg(optarg, ',')) && *id < RDPDR_MAX_DEVICES)
	{
		pprinter_data = (PRINTER *) xmalloc(sizeof(PRINTER));

		strcpy(g_rdpdr_device[*id].name, ""PRN"");
",unused,rdesktop-integration-integration-printer.c
"	{
		pprinter_data = (PRINTER *) xmalloc(sizeof(PRINTER));

		strcpy(g_rdpdr_device[*id].name, ""PRN"");
		strcat(g_rdpdr_device[*id].name, l_to_a(already + count + 1, 10));
",1,unused,65,unused,"	{
		pprinter_data = (PRINTER *) xmalloc(sizeof(PRINTER));

		strcpy(g_rdpdr_device[*id].name, ""PRN"");
		strcat(g_rdpdr_device[*id].name, l_to_a(already + count + 1, 10));
",unused,rdesktop-integration-integration-printer.c
"			pprinter_data->printer = ""mydeskjet"";	/* set default */
		else
		{
			pprinter_data->printer = xmalloc(strlen(optarg) + 1);
			strcpy(pprinter_data->printer, optarg);
",1,unused,79,unused,"			pprinter_data->printer = ""mydeskjet"";	/* set default */
		else
		{
			pprinter_data->printer = xmalloc(strlen(optarg) + 1);
			strcpy(pprinter_data->printer, optarg);
",unused,rdesktop-integration-integration-printer.c
"			pprinter_data->driver = ""MS Publisher Imagesetter"";	/* no printer driver supplied set default */
		else
		{
			pprinter_data->driver = xmalloc(strlen(pos2) + 1);
			strcpy(pprinter_data->driver, pos2);
",1,unused,87,unused,"			pprinter_data->driver = ""MS Publisher Imagesetter"";	/* no printer driver supplied set default */
		else
		{
			pprinter_data->driver = xmalloc(strlen(pos2) + 1);
			strcpy(pprinter_data->driver, pos2);
",unused,rdesktop-integration-integration-printer.c
"		pprinter_data->printer_fp = popen(""lpr"", ""w"");
	}
	else
	{
		sprintf(cmd, ""lpr -P %s"", pprinter_data->printer);
",1,unused,118,unused,"		pprinter_data->printer_fp = popen(""lpr"", ""w"");
	}
	else
	{
		sprintf(cmd, ""lpr -P %s"", pprinter_data->printer);
",unused,rdesktop-integration-integration-printer.c
"	char *path;

	path = (char *) xmalloc(strlen(base) + sizeof(""/.rdesktop/rdpdr/"") + strlen(printer) + 1);

	sprintf(path, ""%s/.rdesktop"", base);
",1,unused,47,unused,"	char *path;

	path = (char *) xmalloc(strlen(base) + sizeof(""/.rdesktop/rdpdr/"") + strlen(printer) + 1);

	sprintf(path, ""%s/.rdesktop"", base);
",unused,rdesktop-integration-integration-printercache.c
"		xfree(path);
		return False;
	}

	strcat(path, ""/rdpdr"");
",1,unused,55,unused,"		xfree(path);
		return False;
	}

	strcat(path, ""/rdpdr"");
",unused,rdesktop-integration-integration-printercache.c
"		xfree(path);
		return False;
	}

	strcat(path, ""/"");
",1,unused,63,unused,"		xfree(path);
		return False;
	}

	strcat(path, ""/"");
",unused,rdesktop-integration-integration-printercache.c
"		return False;
	}

	strcat(path, ""/"");
	strcat(path, printer);
",1,unused,64,unused,"		return False;
	}

	strcat(path, ""/"");
	strcat(path, printer);
",unused,rdesktop-integration-integration-printercache.c
"
	path = (char *) xmalloc(strlen(home) + sizeof(""/.rdesktop/rdpdr/"") + strlen(printer) +
				sizeof(""/AutoPrinterCacheData"") + 1);

	sprintf(path, ""%s/.rdesktop/rdpdr/%s/AutoPrinterCacheData"", home, printer);
",1,unused,92,unused,"
	path = (char *) xmalloc(strlen(home) + sizeof(""/.rdesktop/rdpdr/"") + strlen(printer) +
				sizeof(""/AutoPrinterCacheData"") + 1);

	sprintf(path, ""%s/.rdesktop/rdpdr/%s/AutoPrinterCacheData"", home, printer);
",unused,rdesktop-integration-integration-printercache.c
"		xfree(path);
		return False;
	}

	sprintf(path, ""%s/.rdesktop/rdpdr/%s"", home, printer);
",1,unused,100,unused,"		xfree(path);
		return False;
	}

	sprintf(path, ""%s/.rdesktop/rdpdr/%s"", home, printer);
",unused,rdesktop-integration-integration-printercache.c
"
	printer_path = (char *) xmalloc(printer_maxlen);
	new_printer_path = (char *) xmalloc(printer_maxlen);

	sprintf(printer_path, ""%s/.rdesktop/rdpdr/%s"", home, printer);
",1,unused,137,unused,"
	printer_path = (char *) xmalloc(printer_maxlen);
	new_printer_path = (char *) xmalloc(printer_maxlen);

	sprintf(printer_path, ""%s/.rdesktop/rdpdr/%s"", home, printer);
",unused,rdesktop-integration-integration-printercache.c
"	printer_path = (char *) xmalloc(printer_maxlen);
	new_printer_path = (char *) xmalloc(printer_maxlen);

	sprintf(printer_path, ""%s/.rdesktop/rdpdr/%s"", home, printer);
	sprintf(new_printer_path, ""%s/.rdesktop/rdpdr/%s"", home, new_printer);
",1,unused,138,unused,"	printer_path = (char *) xmalloc(printer_maxlen);
	new_printer_path = (char *) xmalloc(printer_maxlen);

	sprintf(printer_path, ""%s/.rdesktop/rdpdr/%s"", home, printer);
	sprintf(new_printer_path, ""%s/.rdesktop/rdpdr/%s"", home, new_printer);
",unused,rdesktop-integration-integration-printercache.c
"		return 0;

	path = (char *) xmalloc(strlen(home) + sizeof(""/.rdesktop/rdpdr/"") + strlen(printer_name) +
				sizeof(""/AutoPrinterCacheData"") + 1);
	sprintf(path, ""%s/.rdesktop/rdpdr/%s/AutoPrinterCacheData"", home, printer_name);
",1,unused,175,unused,"		return 0;

	path = (char *) xmalloc(strlen(home) + sizeof(""/.rdesktop/rdpdr/"") + strlen(printer_name) +
				sizeof(""/AutoPrinterCacheData"") + 1);
	sprintf(path, ""%s/.rdesktop/rdpdr/%s/AutoPrinterCacheData"", home, printer_name);
",unused,rdesktop-integration-integration-printercache.c
"		return;

	path = (char *) xmalloc(strlen(home) + sizeof(""/.rdesktop/rdpdr/"") + strlen(printer_name) +
				sizeof(""/AutoPrinterCacheData"") + 1);
	sprintf(path, ""%s/.rdesktop/rdpdr/%s/AutoPrinterCacheData"", home, printer_name);
",1,unused,215,unused,"		return;

	path = (char *) xmalloc(strlen(home) + sizeof(""/.rdesktop/rdpdr/"") + strlen(printer_name) +
				sizeof(""/AutoPrinterCacheData"") + 1);
	sprintf(path, ""%s/.rdesktop/rdpdr/%s/AutoPrinterCacheData"", home, printer_name);
",unused,rdesktop-integration-integration-printercache.c
"		return False;
	}

	g_pstcache_Bpp = (g_server_depth + 7) / 8;
	sprintf(filename, ""cache/pstcache_%d_%d"", cache_id, g_pstcache_Bpp);
",1,unused,185,unused,"		return False;
	}

	g_pstcache_Bpp = (g_server_depth + 7) / 8;
	sprintf(filename, ""cache/pstcache_%d_%d"", cache_id, g_pstcache_Bpp);
",unused,rdesktop-integration-integration-pstcache.c
"				}
				else if (str_startswith(optarg, ""clientname""))
				{
					g_rdpdr_clientname = xmalloc(strlen(optarg + 11) + 1);
					strcpy(g_rdpdr_clientname, optarg + 11);
",1,unused,893,unused,"				}
				else if (str_startswith(optarg, ""clientname""))
				{
					g_rdpdr_clientname = xmalloc(strlen(optarg + 11) + 1);
					strcpy(g_rdpdr_clientname, optarg + 11);
",unused,rdesktop-integration-integration-rdesktop.c
"		flags |= RDP_INFO_AUTOLOGON;

	if (g_title[0] == 0)
	{
		strcpy(g_title, ""rdesktop - "");
",1,unused,1095,unused,"		flags |= RDP_INFO_AUTOLOGON;

	if (g_title[0] == 0)
	{
		strcpy(g_title, ""rdesktop - "");
",unused,rdesktop-integration-integration-rdesktop.c
"		N /= base;
	}
	while (N);

	strcpy(head, tail);
",1,unused,1656,unused,"		N /= base;
	}
	while (N);

	strcpy(head, tail);
",unused,rdesktop-integration-integration-rdesktop.c
"
	if (home == NULL)
		return False;

	sprintf(bmpcache_dir, ""%s/%s"", home, "".rdesktop"");
",1,unused,1779,unused,"
	if (home == NULL)
		return False;

	sprintf(bmpcache_dir, ""%s/%s"", home, "".rdesktop"");
",unused,rdesktop-integration-integration-rdesktop.c
"		logger(Core, Error, ""rd_pstcache_mkdir(), mkdir() failed: %s"", strerror(errno));
		return False;
	}

	sprintf(bmpcache_dir, ""%s/%s"", home, "".rdesktop/cache"");
",1,unused,1787,unused,"		logger(Core, Error, ""rd_pstcache_mkdir(), mkdir() failed: %s"", strerror(errno));
		return False;
	}

	sprintf(bmpcache_dir, ""%s/%s"", home, "".rdesktop/cache"");
",unused,rdesktop-integration-integration-rdesktop.c
"
	home = getenv(""HOME"");
	if (home == NULL)
		return -1;
	sprintf(fn, ""%s/.rdesktop/%s"", home, filename);
",1,unused,1809,unused,"
	home = getenv(""HOME"");
	if (home == NULL)
		return -1;
	sprintf(fn, ""%s/.rdesktop/%s"", home, filename);
",unused,rdesktop-integration-integration-rdesktop.c
"
	buffer[dataLength] = '\0';
	reader = getName(buffer);
	*destination = SC_xmalloc(handle, strlen(reader) + 1);
	strcpy(*destination, reader);
",1,unused,583,unused,"
	buffer[dataLength] = '\0';
	reader = getName(buffer);
	*destination = SC_xmalloc(handle, strlen(reader) + 1);
	strcpy(*destination, reader);
",unused,rdesktop-integration-integration-scard.c
"	int k;
	memset(out, 0, out_size);
	for (k = 0; k < in_size; k++, out += 2)
	{
		sprintf(out, ""%.2x"", in[k]);
",1,unused,138,unused,"	int k;
	memset(out, 0, out_size);
	for (k = 0; k < in_size; k++, out += 2)
	{
		sprintf(out, ""%.2x"", in[k]);
",unused,rdesktop-integration-integration-secure.c
"		pser_inf->pold_termios = (struct termios *) xmalloc(sizeof(struct termios));
		memset(pser_inf->pold_termios, 0, sizeof(struct termios));

		pos2 = next_arg(optarg, '=');
		strcpy(g_rdpdr_device[*id].name, optarg);
",1,unused,530,unused,"		pser_inf->pold_termios = (struct termios *) xmalloc(sizeof(struct termios));
		memset(pser_inf->pold_termios, 0, sizeof(struct termios));

		pos2 = next_arg(optarg, '=');
		strcpy(g_rdpdr_device[*id].name, optarg);
",unused,rdesktop-integration-integration-serial.c
"
		toupper_str(g_rdpdr_device[*id].name);

		g_rdpdr_device[*id].local_path = xmalloc(strlen(pos2) + 1);
		strcpy(g_rdpdr_device[*id].local_path, pos2);
",1,unused,535,unused,"
		toupper_str(g_rdpdr_device[*id].name);

		g_rdpdr_device[*id].local_path = xmalloc(strlen(pos2) + 1);
		strcpy(g_rdpdr_device[*id].local_path, pos2);
",unused,rdesktop-integration-integration-serial.c
"	}

	res = 0;
	pt[0] = bp[0] = '\0';
	strcpy(bp, path);
",1,unused,150,unused,"	}

	res = 0;
	pt[0] = bp[0] = '\0';
	strcpy(bp, path);
",unused,rdesktop-integration-integration-utils.c
"
	do
	{
		if (ptok != bp)
			strcat(pt, ""/"");
",1,unused,159,unused,"
	do
	{
		if (ptok != bp)
			strcat(pt, ""/"");
",unused,rdesktop-integration-integration-utils.c
"	{
		if (ptok != bp)
			strcat(pt, ""/"");

		strcat(pt, ptok);
",1,unused,161,unused,"	{
		if (ptok != bp)
			strcat(pt, ""/"");

		strcat(pt, ptok);
",unused,rdesktop-integration-integration-utils.c
"	}
	else
	{
		strncpy(result, a, PATH_MAX);
		strcat(result, ""/"");
",1,unused,331,unused,"	}
	else
	{
		strncpy(result, a, PATH_MAX);
		strcat(result, ""/"");
",unused,rdesktop-integration-integration-xkeymap.c
"		       with the eighth bit set to ESC-prefixed sequences, then
		       we can use \M-.  Otherwise we need to use the sequence
		       for ESC. */
		    if (_rl_convert_meta_chars_to_ascii && map[ESC].type == ISKMAP)
		      sprintf (keyname, ""\\M-"");
",1,unused,2304,unused,"		       with the eighth bit set to ESC-prefixed sequences, then
		       we can use \M-.  Otherwise we need to use the sequence
		       for ESC. */
		    if (_rl_convert_meta_chars_to_ascii && map[ESC].type == ISKMAP)
		      sprintf (keyname, ""\\M-"");
",unused,readlinedebianstretche7.0-bind.c
"		       for ESC. */
		    if (_rl_convert_meta_chars_to_ascii && map[ESC].type == ISKMAP)
		      sprintf (keyname, ""\\M-"");
		    else
		      sprintf (keyname, ""\\e"");
",1,unused,2306,unused,"		       for ESC. */
		    if (_rl_convert_meta_chars_to_ascii && map[ESC].type == ISKMAP)
		      sprintf (keyname, ""\\M-"");
		    else
		      sprintf (keyname, ""\\e"");
",unused,readlinedebianstretche7.0-bind.c
"		    else
		      sprintf (keyname, ""\\e"");
		  }
		else if (CTRL_CHAR (key))
		  sprintf (keyname, ""\\C-%c"", _rl_to_lower (UNCTRL (key)));
",1,unused,2309,unused,"		    else
		      sprintf (keyname, ""\\e"");
		  }
		else if (CTRL_CHAR (key))
		  sprintf (keyname, ""\\C-%c"", _rl_to_lower (UNCTRL (key)));
",unused,readlinedebianstretche7.0-bind.c
"		  }
		else if (CTRL_CHAR (key))
		  sprintf (keyname, ""\\C-%c"", _rl_to_lower (UNCTRL (key)));
		else if (key == RUBOUT)
		  sprintf (keyname, ""\\C-?"");
",1,unused,2311,unused,"		  }
		else if (CTRL_CHAR (key))
		  sprintf (keyname, ""\\C-%c"", _rl_to_lower (UNCTRL (key)));
		else if (key == RUBOUT)
		  sprintf (keyname, ""\\C-?"");
",unused,readlinedebianstretche7.0-bind.c
"		    keyname[0] = (char) key;
		    keyname[1] = '\0';
		  }
		
		strcat (keyname, seqs[i]);
",1,unused,2324,unused,"		    keyname[0] = (char) key;
		    keyname[1] = '\0';
		  }
		
		strcat (keyname, seqs[i]);
",unused,readlinedebianstretche7.0-bind.c
"	  if (key == ESC)
	    {
	      keyname = (char *)xmalloc (3 + prefix_len);
	      if (prefix)
		strcpy (keyname, prefix);
",1,unused,2477,unused,"	  if (key == ESC)
	    {
	      keyname = (char *)xmalloc (3 + prefix_len);
	      if (prefix)
		strcpy (keyname, prefix);
",unused,readlinedebianstretche7.0-bind.c
"	      keyname = _rl_get_keyname (key);
	      if (prefix)
		{
		  out = (char *)xmalloc (strlen (keyname) + prefix_len + 1);
		  strcpy (out, prefix);
",1,unused,2488,unused,"	      keyname = _rl_get_keyname (key);
	      if (prefix)
		{
		  out = (char *)xmalloc (strlen (keyname) + prefix_len + 1);
		  strcpy (out, prefix);
",unused,readlinedebianstretche7.0-bind.c
"	      if (prefix)
		{
		  out = (char *)xmalloc (strlen (keyname) + prefix_len + 1);
		  strcpy (out, prefix);
		  strcpy (out + prefix_len, keyname);
",1,unused,2489,unused,"	      if (prefix)
		{
		  out = (char *)xmalloc (strlen (keyname) + prefix_len + 1);
		  strcpy (out, prefix);
		  strcpy (out + prefix_len, keyname);
",unused,readlinedebianstretche7.0-bind.c
"  else if (_rl_stricmp (name, ""comment-begin"") == 0)
    return (_rl_comment_begin ? _rl_comment_begin : RL_COMMENT_BEGIN_DEFAULT);
  else if (_rl_stricmp (name, ""completion-display-width"") == 0)
    {
      sprintf (numbuf, ""%d"", _rl_completion_columns);
",1,unused,2544,unused,"  else if (_rl_stricmp (name, ""comment-begin"") == 0)
    return (_rl_comment_begin ? _rl_comment_begin : RL_COMMENT_BEGIN_DEFAULT);
  else if (_rl_stricmp (name, ""completion-display-width"") == 0)
    {
      sprintf (numbuf, ""%d"", _rl_completion_columns);
",unused,readlinedebianstretche7.0-bind.c
"      return (numbuf);
    }
  else if (_rl_stricmp (name, ""completion-prefix-display-length"") == 0)
    {
      sprintf (numbuf, ""%d"", _rl_completion_prefix_display_length);
",1,unused,2549,unused,"      return (numbuf);
    }
  else if (_rl_stricmp (name, ""completion-prefix-display-length"") == 0)
    {
      sprintf (numbuf, ""%d"", _rl_completion_prefix_display_length);
",unused,readlinedebianstretche7.0-bind.c
"      return (numbuf);
    }
  else if (_rl_stricmp (name, ""completion-query-items"") == 0)
    {
      sprintf (numbuf, ""%d"", rl_completion_query_items);
",1,unused,2554,unused,"      return (numbuf);
    }
  else if (_rl_stricmp (name, ""completion-query-items"") == 0)
    {
      sprintf (numbuf, ""%d"", rl_completion_query_items);
",unused,readlinedebianstretche7.0-bind.c
"  else if (_rl_stricmp (name, ""editing-mode"") == 0)
    return (rl_get_keymap_name_from_edit_mode ());
  else if (_rl_stricmp (name, ""history-size"") == 0)
    {
      sprintf (numbuf, ""%d"", history_is_stifled() ? history_max_entries : 0);
",1,unused,2561,unused,"  else if (_rl_stricmp (name, ""editing-mode"") == 0)
    return (rl_get_keymap_name_from_edit_mode ());
  else if (_rl_stricmp (name, ""history-size"") == 0)
    {
      sprintf (numbuf, ""%d"", history_is_stifled() ? history_max_entries : 0);
",unused,readlinedebianstretche7.0-bind.c
"      return (ret ? ret : ""none"");
    }
  else if (_rl_stricmp (name, ""keyseq-timeout"") == 0)
    {
      sprintf (numbuf, ""%d"", _rl_keyseq_timeout);    
",1,unused,2588,unused,"      return (ret ? ret : ""none"");
    }
  else if (_rl_stricmp (name, ""keyseq-timeout"") == 0)
    {
      sprintf (numbuf, ""%d"", _rl_keyseq_timeout);    
",unused,readlinedebianstretche7.0-bind.c
"
	  slen = strlen (s);
	  tlen = strlen (to_print);
	  new_full_pathname = (char *)xmalloc (slen + tlen + 2);
	  strcpy (new_full_pathname, s);
",1,unused,986,unused,"
	  slen = strlen (s);
	  tlen = strlen (to_print);
	  new_full_pathname = (char *)xmalloc (slen + tlen + 2);
	  strcpy (new_full_pathname, s);
",unused,readlinedebianstretche7.0-complete.c
"	    slen--;
	  else
	    new_full_pathname[slen] = '/';
	  new_full_pathname[slen] = '/';
	  strcpy (new_full_pathname + slen + 1, to_print);
",1,unused,992,unused,"	    slen--;
	  else
	    new_full_pathname[slen] = '/';
	  new_full_pathname[slen] = '/';
	  strcpy (new_full_pathname + slen + 1, to_print);
",unused,readlinedebianstretche7.0-complete.c
"  char *r;

  r = (char *)xmalloc (strlen (s) + 2);
  *r = *rl_completer_quote_characters;
  strcpy (r + 1, s);
",1,unused,1061,unused,"  char *r;

  r = (char *)xmalloc (strlen (s) + 2);
  *r = *rl_completer_quote_characters;
  strcpy (r + 1, s);
",unused,readlinedebianstretche7.0-complete.c
"     value of matches[0]. */
  if (low == 0 && text && *text)
    {
      match_list[0] = (char *)xmalloc (strlen (text) + 1);
      strcpy (match_list[0], text);
",1,unused,1421,unused,"     value of matches[0]. */
  if (low == 0 && text && *text)
    {
      match_list[0] = (char *)xmalloc (strlen (text) + 1);
      strcpy (match_list[0], text);
",unused,readlinedebianstretche7.0-complete.c
"      value = (char *)xmalloc (2 + strlen (entry->pw_name));

      *value = *text;

      strcpy (value + first_char_loc, entry->pw_name);
",1,unused,2327,unused,"      value = (char *)xmalloc (2 + strlen (entry->pw_name));

      *value = *text;

      strcpy (value + first_char_loc, entry->pw_name);
",unused,readlinedebianstretche7.0-complete.c
"#endif

      if (temp)
	{
	  strcpy (filename, ++temp);
",1,unused,2518,unused,"#endif

      if (temp)
	{
	  strcpy (filename, ++temp);
",unused,readlinedebianstretche7.0-complete.c
"	  if (rl_complete_with_tilde_expansion && *users_dirname == '~')
	    {
	      dirlen = strlen (dirname);
	      temp = (char *)xmalloc (2 + dirlen + D_NAMLEN (entry));
	      strcpy (temp, dirname);
",1,unused,2664,unused,"	  if (rl_complete_with_tilde_expansion && *users_dirname == '~')
	    {
	      dirlen = strlen (dirname);
	      temp = (char *)xmalloc (2 + dirlen + D_NAMLEN (entry));
	      strcpy (temp, dirname);
",unused,readlinedebianstretche7.0-complete.c
"	  else
	    {
	      dirlen = strlen (users_dirname);
	      temp = (char *)xmalloc (2 + dirlen + D_NAMLEN (entry));
	      strcpy (temp, users_dirname);
",1,unused,2677,unused,"	  else
	    {
	      dirlen = strlen (users_dirname);
	      temp = (char *)xmalloc (2 + dirlen + D_NAMLEN (entry));
	      strcpy (temp, users_dirname);
",unused,readlinedebianstretche7.0-complete.c
"	      if (users_dirname[dirlen - 1] != '/')
		temp[dirlen++] = '/';
	    }

	  strcpy (temp + dirlen, convfn);
",1,unused,2683,unused,"	      if (users_dirname[dirlen - 1] != '/')
		temp[dirlen++] = '/';
	    }

	  strcpy (temp + dirlen, convfn);
",unused,readlinedebianstretche7.0-complete.c
"    {
      l = strlen (pmt);
      nprompt = (char *)xmalloc (l + mlen + 1);
      memcpy (nprompt, ms, mlen);
      strcpy (nprompt + mlen, pmt);
",1,unused,325,unused,"    {
      l = strlen (pmt);
      nprompt = (char *)xmalloc (l + mlen + 1);
      memcpy (nprompt, ms, mlen);
      strcpy (nprompt + mlen, pmt);
",unused,readlinedebianstretche7.0-display.c
"#endif
	{
	  if (_rl_output_meta_chars == 0)
	    {
	      sprintf (line + out, ""\\%o"", c);
",1,unused,903,unused,"#endif
	{
	  if (_rl_output_meta_chars == 0)
	    {
	      sprintf (line + out, ""\\%o"", c);
",unused,readlinedebianstretche7.0-display.c
"
  /* Make sure the line structures hold the already-displayed prompt for
     redisplay. */
  lprompt = local_prompt ? local_prompt : rl_prompt;
  strcpy (visible_line, lprompt);
",1,unused,2079,unused,"
  /* Make sure the line structures hold the already-displayed prompt for
     redisplay. */
  lprompt = local_prompt ? local_prompt : rl_prompt;
  strcpy (visible_line, lprompt);
",unused,readlinedebianstretche7.0-display.c
"  /* Make sure the line structures hold the already-displayed prompt for
     redisplay. */
  lprompt = local_prompt ? local_prompt : rl_prompt;
  strcpy (visible_line, lprompt);
  strcpy (invisible_line, lprompt);
",1,unused,2080,unused,"  /* Make sure the line structures hold the already-displayed prompt for
     redisplay. */
  lprompt = local_prompt ? local_prompt : rl_prompt;
  strcpy (visible_line, lprompt);
  strcpy (invisible_line, lprompt);
",unused,readlinedebianstretche7.0-display.c
"    {
      len = (rl_prompt && *rl_prompt) ? strlen (rl_prompt) : 0;
      pmt = (char *)xmalloc (len + 2);
      if (len)
	strcpy (pmt, rl_prompt);
",1,unused,2602,unused,"    {
      len = (rl_prompt && *rl_prompt) ? strlen (rl_prompt) : 0;
      pmt = (char *)xmalloc (len + 2);
      if (len)
	strcpy (pmt, rl_prompt);
",unused,readlinedebianstretche7.0-display.c
"      p++;
      len = strlen (p);
      pmt = (char *)xmalloc (len + 2);
      if (len)
	strcpy (pmt, p);
",1,unused,2612,unused,"      p++;
      len = strlen (p);
      pmt = (char *)xmalloc (len + 2);
      if (len)
	strcpy (pmt, p);
",unused,readlinedebianstretche7.0-display.c
"  temp = (char *)xmalloc (ll + elen + 3);
  strncpy (temp, s + start, ll);
  temp[ll] = ':';
  temp[ll + 1] = ' ';
  strcpy (temp + ll + 2, emsg);
",1,unused,419,unused,"  temp = (char *)xmalloc (ll + elen + 3);
  strncpy (temp, s + start, ll);
  temp[ll] = ':';
  temp[ll + 1] = ' ';
  strcpy (temp + ll + 2, emsg);
",unused,readlinedebianstretche7.0-histexpand.c
"      if (subst_rhs[i] == '&')
	{
	  if (j + subst_lhs_len >= new_size)
	    new = (char *)xrealloc (new, (new_size = new_size * 2 + subst_lhs_len));
	  strcpy (new + j, subst_lhs);
",1,unused,505,unused,"      if (subst_rhs[i] == '&')
	{
	  if (j + subst_lhs_len >= new_size)
	    new = (char *)xrealloc (new, (new_size = new_size * 2 + subst_lhs_len));
	  strcpy (new + j, subst_lhs);
",unused,readlinedebianstretche7.0-histexpand.c
"
  n = strlen (temp);
  if (n >= result_len)
    result = (char *)xrealloc (result, n + 2);
  strcpy (result, temp);
",1,unused,864,unused,"
  n = strlen (temp);
  if (n >= result_len)
    result = (char *)xrealloc (result, n + 2);
  strcpy (result, temp);
",unused,readlinedebianstretche7.0-histexpand.c
"
      string[0] = string[1] = history_expansion_char;
      string[2] = ':';
      string[3] = 's';
      strcpy (string + 4, hstring);
",1,unused,965,unused,"
      string[0] = string[1] = history_expansion_char;
      string[2] = ':';
      string[3] = 's';
      strcpy (string + 4, hstring);
",unused,readlinedebianstretche7.0-histexpand.c
"	  if ((dquote == 0 || history_quotes_inhibit_expansion == 0) &&
	      (i == 0 || member (string[i - 1], history_word_delimiters)))
	    {
	      temp = (char *)xmalloc (l - i + 1);
	      strcpy (temp, string + i);
",1,unused,1163,unused,"	  if ((dquote == 0 || history_quotes_inhibit_expansion == 0) &&
	      (i == 0 || member (string[i - 1], history_word_delimiters)))
	    {
	      temp = (char *)xmalloc (l - i + 1);
	      strcpy (temp, string + i);
",unused,readlinedebianstretche7.0-histexpand.c
"      result[0] = '\0';

      for (i = first, offset = 0; i < last; i++)
	{
	  strcpy (result + offset, list[i]);
",1,unused,1403,unused,"      result[0] = '\0';

      for (i = first, offset = 0; i < last; i++)
	{
	  strcpy (result + offset, list[i]);
",unused,readlinedebianstretche7.0-histexpand.c
"  else
    home_len = strlen (home);

  return_val = (char *)xmalloc (2 + home_len + 8); /* strlen("".history"") == 8 */
  strcpy (return_val, home);
",1,unused,170,unused,"  else
    home_len = strlen (home);

  return_val = (char *)xmalloc (2 + home_len + 8); /* strlen("".history"") == 8 */
  strcpy (return_val, home);
",unused,readlinedebianstretche7.0-histfile.c
"  return_val[home_len] = '/';
#if defined (__MSDOS__)
  strcpy (return_val + home_len + 1, ""_history"");
#else
  strcpy (return_val + home_len + 1, "".history"");
",1,unused,175,unused,"  return_val[home_len] = '/';
#if defined (__MSDOS__)
  strcpy (return_val + home_len + 1, ""_history"");
#else
  strcpy (return_val + home_len + 1, "".history"");
",unused,readlinedebianstretche7.0-histfile.c
"#endif
      
  len = strlen (fn);
  ret = xmalloc (len + 2);
  strcpy (ret, fn);
",1,unused,204,unused,"#endif
      
  len = strlen (fn);
  ret = xmalloc (len + 2);
  strcpy (ret, fn);
",unused,readlinedebianstretche7.0-histfile.c
"#endif
      
  len = strlen (fn);
  ret = xmalloc (len + 11);
  strcpy (ret, fn);
",1,unused,234,unused,"#endif
      
  len = strlen (fn);
  ret = xmalloc (len + 11);
  strcpy (ret, fn);
",unused,readlinedebianstretche7.0-histfile.c
"  ret[len+2] = (pid / 1000 % 10) + '0';
  ret[len+3] = (pid / 100 % 10) + '0';
  ret[len+4] = (pid / 10 % 10) + '0';
  ret[len+5] = (pid % 10) + '0';
  strcpy (ret + len + 6, "".tmp"");
",1,unused,245,unused,"  ret[len+2] = (pid / 1000 % 10) + '0';
  ret[len+3] = (pid / 100 % 10) + '0';
  ret[len+4] = (pid / 10 % 10) + '0';
  ret[len+5] = (pid % 10) + '0';
  strcpy (ret + len + 6, "".tmp"");
",unused,readlinedebianstretche7.0-histfile.c
"    for (j = 0, i = history_length - nelements; i < history_length; i++)
      {
	if (history_write_timestamps && the_history[i]->timestamp && the_history[i]->timestamp[0])
	  {
	    strcpy (buffer + j, the_history[i]->timestamp);
",1,unused,722,unused,"    for (j = 0, i = history_length - nelements; i < history_length; i++)
      {
	if (history_write_timestamps && the_history[i]->timestamp && the_history[i]->timestamp[0])
	  {
	    strcpy (buffer + j, the_history[i]->timestamp);
",unused,readlinedebianstretche7.0-histfile.c
"	    strcpy (buffer + j, the_history[i]->timestamp);
	    j += strlen (the_history[i]->timestamp);
	    buffer[j++] = '\n';
	  }
	strcpy (buffer + j, the_history[i]->line);
",1,unused,726,unused,"	    strcpy (buffer + j, the_history[i]->timestamp);
	    j += strlen (the_history[i]->timestamp);
	    buffer[j++] = '\n';
	  }
	strcpy (buffer + j, the_history[i]->line);
",unused,readlinedebianstretche7.0-histfile.c
"  if (newline)
    {
      hent->line = newline;
      hent->line[curlen++] = '\n';
      strcpy (hent->line + curlen, line);
",1,unused,430,unused,"  if (newline)
    {
      hent->line = newline;
      hent->line[curlen++] = '\n';
      strcpy (hent->line + curlen, line);
",unused,readlinedebianstretche7.0-history.c
"  message[msglen++] = '(';

  if (flags & SF_FAILED)
    {
      strcpy (message + msglen, ""failed "");
",1,unused,182,unused,"  message[msglen++] = '(';

  if (flags & SF_FAILED)
    {
      strcpy (message + msglen, ""failed "");
",unused,readlinedebianstretche7.0-isearch.c
"    }

  if (flags & SF_REVERSE)
    {
      strcpy (message + msglen, ""reverse-"");
",1,unused,188,unused,"    }

  if (flags & SF_REVERSE)
    {
      strcpy (message + msglen, ""reverse-"");
",unused,readlinedebianstretche7.0-isearch.c
"      strcpy (message + msglen, ""reverse-"");
      msglen += 8;
    }

  strcpy (message + msglen, ""i-search)`"");
",1,unused,192,unused,"      strcpy (message + msglen, ""reverse-"");
      msglen += 8;
    }

  strcpy (message + msglen, ""i-search)`"");
",unused,readlinedebianstretche7.0-isearch.c
"  msglen += 10;

  if (search_string)
    {
      strcpy (message + msglen, search_string);
",1,unused,197,unused,"  msglen += 10;

  if (search_string)
    {
      strcpy (message + msglen, search_string);
",unused,readlinedebianstretche7.0-isearch.c
"      strcpy (message + msglen, search_string);
      msglen += searchlen;
    }

  strcpy (message + msglen, ""': "");
",1,unused,201,unused,"      strcpy (message + msglen, search_string);
      msglen += searchlen;
    }

  strcpy (message + msglen, ""': "");
",unused,readlinedebianstretche7.0-isearch.c
"  else
    {
      /* Keep track of this so we can free it. */
      cxt->allocated_line = (char *)xmalloc (1 + strlen (rl_line_buffer));
      strcpy (cxt->allocated_line, &rl_line_buffer[0]);
",1,unused,242,unused,"  else
    {
      /* Keep track of this so we can free it. */
      cxt->allocated_line = (char *)xmalloc (1 + strlen (rl_line_buffer));
      strcpy (cxt->allocated_line, &rl_line_buffer[0]);
",unused,readlinedebianstretche7.0-isearch.c
"_rl_isearch_fini (cxt)
     _rl_search_cxt *cxt;
{
  /* First put back the original state. */
  strcpy (rl_line_buffer, cxt->lines[cxt->save_line]);
",1,unused,274,unused,"_rl_isearch_fini (cxt)
     _rl_search_cxt *cxt;
{
  /* First put back the original state. */
  strcpy (rl_line_buffer, cxt->lines[cxt->save_line]);
",unused,readlinedebianstretche7.0-isearch.c
"	  if (last_isearch_string)
	    {
	      cxt->search_string_size = 64 + last_isearch_string_len;
	      cxt->search_string = (char *)xrealloc (cxt->search_string, cxt->search_string_size);
	      strcpy (cxt->search_string, last_isearch_string);
",1,unused,523,unused,"	  if (last_isearch_string)
	    {
	      cxt->search_string_size = 64 + last_isearch_string_len;
	      cxt->search_string = (char *)xrealloc (cxt->search_string, cxt->search_string_size);
	      strcpy (cxt->search_string, last_isearch_string);
",unused,readlinedebianstretche7.0-isearch.c
"      new = (char *)xmalloc (1 + strlen (old) + strlen (text));

      if (append)
	{
	  strcpy (new, old);
",1,unused,141,unused,"      new = (char *)xmalloc (1 + strlen (old) + strlen (text));

      if (append)
	{
	  strcpy (new, old);
",unused,readlinedebianstretche7.0-kill.c
"
      if (append)
	{
	  strcpy (new, old);
	  strcat (new, text);
",1,unused,142,unused,"
      if (append)
	{
	  strcpy (new, old);
	  strcat (new, text);
",unused,readlinedebianstretche7.0-kill.c
"	  strcat (new, text);
	}
      else
	{
	  strcpy (new, text);
",1,unused,146,unused,"	  strcat (new, text);
	}
      else
	{
	  strcpy (new, text);
",unused,readlinedebianstretche7.0-kill.c
"	}
      else
	{
	  strcpy (new, text);
	  strcat (new, old);
",1,unused,147,unused,"	}
      else
	{
	  strcpy (new, text);
	  strcat (new, old);
",unused,readlinedebianstretche7.0-kill.c
"      return;
    }

  ext = NULL;
  strcpy (label, ""??"");
",1,unused,318,unused,"      return;
    }

  ext = NULL;
  strcpy (label, ""??"");
",unused,readlinedebianstretche7.0-parse-colors.c
"      rl_revert_line (1, 0);
      entry = replace_history_entry (where_history (), the_line, (histdata_t)NULL);
      _rl_free_history_entry (entry);

      strcpy (the_line, temp);
",1,unused,472,unused,"      rl_revert_line (1, 0);
      entry = replace_history_entry (where_history (), the_line, (histdata_t)NULL);
      _rl_free_history_entry (entry);

      strcpy (the_line, temp);
",unused,readlinedebianstretche7.0-readline.c
"sh_set_lines_and_columns (lines, cols)
     int lines, cols;
{
#if defined (HAVE_SETENV)
  sprintf (setenv_buf, ""%d"", lines);
",1,unused,134,unused,"sh_set_lines_and_columns (lines, cols)
     int lines, cols;
{
#if defined (HAVE_SETENV)
  sprintf (setenv_buf, ""%d"", lines);
",unused,readlinedebianstretche7.0-shell.c
"#if defined (HAVE_SETENV)
  sprintf (setenv_buf, ""%d"", lines);
  setenv (""LINES"", setenv_buf, 1);

  sprintf (setenv_buf, ""%d"", cols);
",1,unused,137,unused,"#if defined (HAVE_SETENV)
  sprintf (setenv_buf, ""%d"", lines);
  setenv (""LINES"", setenv_buf, 1);

  sprintf (setenv_buf, ""%d"", cols);
",unused,readlinedebianstretche7.0-shell.c
"
  len = strlen (text);
  if (len >= rl_line_buffer_len)
    rl_extend_line_buffer (len);
  strcpy (rl_line_buffer, text);
",1,unused,218,unused,"
  len = strlen (text);
  if (len >= rl_line_buffer_len)
    rl_extend_line_buffer (len);
  strcpy (rl_line_buffer, text);
",unused,readlinedebianstretche7.0-text.c
"	{
	  if ((result_index + len + 1) > result_size)
	    result = (char *)xrealloc (result, 1 + (result_size += (len + 20)));

	  strcpy (result + result_index, expansion);
",1,unused,255,unused,"	{
	  if ((result_index + len + 1) > result_size)
	    result = (char *)xrealloc (result, 1 + (result_size += (len + 20)));

	  strcpy (result + result_index, expansion);
",unused,readlinedebianstretche7.0-tilde.c
"  plen = (prefix && *prefix) ? strlen (prefix) : 0;
  slen = strlen (suffix + suffind);
  ret = (char *)xmalloc (plen + slen + 1);
  if (plen)
    strcpy (ret, prefix);
",1,unused,338,unused,"  plen = (prefix && *prefix) ? strlen (prefix) : 0;
  slen = strlen (suffix + suffind);
  ret = (char *)xmalloc (plen + slen + 1);
  if (plen)
    strcpy (ret, prefix);
",unused,readlinedebianstretche7.0-tilde.c
"  slen = strlen (suffix + suffind);
  ret = (char *)xmalloc (plen + slen + 1);
  if (plen)
    strcpy (ret, prefix);
  strcpy (ret + plen, suffix + suffind);
",1,unused,339,unused,"  slen = strlen (suffix + suffind);
  ret = (char *)xmalloc (plen + slen + 1);
  if (plen)
    strcpy (ret, prefix);
  strcpy (ret + plen, suffix + suffind);
",unused,readlinedebianstretche7.0-tilde.c
"char *
_rl_savestring (s)
     const char *s;
{
  return (strcpy ((char *)xmalloc (1 + (int)strlen (s)), (s)));
",1,unused,478,unused,"char *
_rl_savestring (s)
     const char *s;
{
  return (strcpy ((char *)xmalloc (1 + (int)strlen (s)), (s)));
",unused,readlinedebianstretche7.0-util.c
"		       with the eighth bit set to ESC-prefixed sequences, then
		       we can use \M-.  Otherwise we need to use the sequence
		       for ESC. */
		    if (_rl_convert_meta_chars_to_ascii && map[ESC].type == ISKMAP)
		      sprintf (keyname, ""\\M-"");
",1,unused,2304,unused,"		       with the eighth bit set to ESC-prefixed sequences, then
		       we can use \M-.  Otherwise we need to use the sequence
		       for ESC. */
		    if (_rl_convert_meta_chars_to_ascii && map[ESC].type == ISKMAP)
		      sprintf (keyname, ""\\M-"");
",unused,readlinexenialubuntu7.0-bind.c
"		       for ESC. */
		    if (_rl_convert_meta_chars_to_ascii && map[ESC].type == ISKMAP)
		      sprintf (keyname, ""\\M-"");
		    else
		      sprintf (keyname, ""\\e"");
",1,unused,2306,unused,"		       for ESC. */
		    if (_rl_convert_meta_chars_to_ascii && map[ESC].type == ISKMAP)
		      sprintf (keyname, ""\\M-"");
		    else
		      sprintf (keyname, ""\\e"");
",unused,readlinexenialubuntu7.0-bind.c
"		    else
		      sprintf (keyname, ""\\e"");
		  }
		else if (CTRL_CHAR (key))
		  sprintf (keyname, ""\\C-%c"", _rl_to_lower (UNCTRL (key)));
",1,unused,2309,unused,"		    else
		      sprintf (keyname, ""\\e"");
		  }
		else if (CTRL_CHAR (key))
		  sprintf (keyname, ""\\C-%c"", _rl_to_lower (UNCTRL (key)));
",unused,readlinexenialubuntu7.0-bind.c
"		  }
		else if (CTRL_CHAR (key))
		  sprintf (keyname, ""\\C-%c"", _rl_to_lower (UNCTRL (key)));
		else if (key == RUBOUT)
		  sprintf (keyname, ""\\C-?"");
",1,unused,2311,unused,"		  }
		else if (CTRL_CHAR (key))
		  sprintf (keyname, ""\\C-%c"", _rl_to_lower (UNCTRL (key)));
		else if (key == RUBOUT)
		  sprintf (keyname, ""\\C-?"");
",unused,readlinexenialubuntu7.0-bind.c
"		    keyname[0] = (char) key;
		    keyname[1] = '\0';
		  }
		
		strcat (keyname, seqs[i]);
",1,unused,2324,unused,"		    keyname[0] = (char) key;
		    keyname[1] = '\0';
		  }
		
		strcat (keyname, seqs[i]);
",unused,readlinexenialubuntu7.0-bind.c
"	  if (key == ESC)
	    {
	      keyname = (char *)xmalloc (3 + prefix_len);
	      if (prefix)
		strcpy (keyname, prefix);
",1,unused,2477,unused,"	  if (key == ESC)
	    {
	      keyname = (char *)xmalloc (3 + prefix_len);
	      if (prefix)
		strcpy (keyname, prefix);
",unused,readlinexenialubuntu7.0-bind.c
"	      keyname = _rl_get_keyname (key);
	      if (prefix)
		{
		  out = (char *)xmalloc (strlen (keyname) + prefix_len + 1);
		  strcpy (out, prefix);
",1,unused,2488,unused,"	      keyname = _rl_get_keyname (key);
	      if (prefix)
		{
		  out = (char *)xmalloc (strlen (keyname) + prefix_len + 1);
		  strcpy (out, prefix);
",unused,readlinexenialubuntu7.0-bind.c
"	      if (prefix)
		{
		  out = (char *)xmalloc (strlen (keyname) + prefix_len + 1);
		  strcpy (out, prefix);
		  strcpy (out + prefix_len, keyname);
",1,unused,2489,unused,"	      if (prefix)
		{
		  out = (char *)xmalloc (strlen (keyname) + prefix_len + 1);
		  strcpy (out, prefix);
		  strcpy (out + prefix_len, keyname);
",unused,readlinexenialubuntu7.0-bind.c
"  else if (_rl_stricmp (name, ""comment-begin"") == 0)
    return (_rl_comment_begin ? _rl_comment_begin : RL_COMMENT_BEGIN_DEFAULT);
  else if (_rl_stricmp (name, ""completion-display-width"") == 0)
    {
      sprintf (numbuf, ""%d"", _rl_completion_columns);
",1,unused,2544,unused,"  else if (_rl_stricmp (name, ""comment-begin"") == 0)
    return (_rl_comment_begin ? _rl_comment_begin : RL_COMMENT_BEGIN_DEFAULT);
  else if (_rl_stricmp (name, ""completion-display-width"") == 0)
    {
      sprintf (numbuf, ""%d"", _rl_completion_columns);
",unused,readlinexenialubuntu7.0-bind.c
"      return (numbuf);
    }
  else if (_rl_stricmp (name, ""completion-prefix-display-length"") == 0)
    {
      sprintf (numbuf, ""%d"", _rl_completion_prefix_display_length);
",1,unused,2549,unused,"      return (numbuf);
    }
  else if (_rl_stricmp (name, ""completion-prefix-display-length"") == 0)
    {
      sprintf (numbuf, ""%d"", _rl_completion_prefix_display_length);
",unused,readlinexenialubuntu7.0-bind.c
"      return (numbuf);
    }
  else if (_rl_stricmp (name, ""completion-query-items"") == 0)
    {
      sprintf (numbuf, ""%d"", rl_completion_query_items);
",1,unused,2554,unused,"      return (numbuf);
    }
  else if (_rl_stricmp (name, ""completion-query-items"") == 0)
    {
      sprintf (numbuf, ""%d"", rl_completion_query_items);
",unused,readlinexenialubuntu7.0-bind.c
"  else if (_rl_stricmp (name, ""editing-mode"") == 0)
    return (rl_get_keymap_name_from_edit_mode ());
  else if (_rl_stricmp (name, ""history-size"") == 0)
    {
      sprintf (numbuf, ""%d"", history_is_stifled() ? history_max_entries : 0);
",1,unused,2561,unused,"  else if (_rl_stricmp (name, ""editing-mode"") == 0)
    return (rl_get_keymap_name_from_edit_mode ());
  else if (_rl_stricmp (name, ""history-size"") == 0)
    {
      sprintf (numbuf, ""%d"", history_is_stifled() ? history_max_entries : 0);
",unused,readlinexenialubuntu7.0-bind.c
"      return (ret ? ret : ""none"");
    }
  else if (_rl_stricmp (name, ""keyseq-timeout"") == 0)
    {
      sprintf (numbuf, ""%d"", _rl_keyseq_timeout);    
",1,unused,2588,unused,"      return (ret ? ret : ""none"");
    }
  else if (_rl_stricmp (name, ""keyseq-timeout"") == 0)
    {
      sprintf (numbuf, ""%d"", _rl_keyseq_timeout);    
",unused,readlinexenialubuntu7.0-bind.c
"    {
      l = strlen (pmt);
      nprompt = (char *)xmalloc (l + mlen + 1);
      memcpy (nprompt, ms, mlen);
      strcpy (nprompt + mlen, pmt);
",1,unused,325,unused,"    {
      l = strlen (pmt);
      nprompt = (char *)xmalloc (l + mlen + 1);
      memcpy (nprompt, ms, mlen);
      strcpy (nprompt + mlen, pmt);
",unused,readlinexenialubuntu7.0-display.c
"#endif
	{
	  if (_rl_output_meta_chars == 0)
	    {
	      sprintf (line + out, ""\\%o"", c);
",1,unused,903,unused,"#endif
	{
	  if (_rl_output_meta_chars == 0)
	    {
	      sprintf (line + out, ""\\%o"", c);
",unused,readlinexenialubuntu7.0-display.c
"
  /* Make sure the line structures hold the already-displayed prompt for
     redisplay. */
  lprompt = local_prompt ? local_prompt : rl_prompt;
  strcpy (visible_line, lprompt);
",1,unused,2079,unused,"
  /* Make sure the line structures hold the already-displayed prompt for
     redisplay. */
  lprompt = local_prompt ? local_prompt : rl_prompt;
  strcpy (visible_line, lprompt);
",unused,readlinexenialubuntu7.0-display.c
"  /* Make sure the line structures hold the already-displayed prompt for
     redisplay. */
  lprompt = local_prompt ? local_prompt : rl_prompt;
  strcpy (visible_line, lprompt);
  strcpy (invisible_line, lprompt);
",1,unused,2080,unused,"  /* Make sure the line structures hold the already-displayed prompt for
     redisplay. */
  lprompt = local_prompt ? local_prompt : rl_prompt;
  strcpy (visible_line, lprompt);
  strcpy (invisible_line, lprompt);
",unused,readlinexenialubuntu7.0-display.c
"    {
      len = (rl_prompt && *rl_prompt) ? strlen (rl_prompt) : 0;
      pmt = (char *)xmalloc (len + 2);
      if (len)
	strcpy (pmt, rl_prompt);
",1,unused,2602,unused,"    {
      len = (rl_prompt && *rl_prompt) ? strlen (rl_prompt) : 0;
      pmt = (char *)xmalloc (len + 2);
      if (len)
	strcpy (pmt, rl_prompt);
",unused,readlinexenialubuntu7.0-display.c
"      p++;
      len = strlen (p);
      pmt = (char *)xmalloc (len + 2);
      if (len)
	strcpy (pmt, p);
",1,unused,2612,unused,"      p++;
      len = strlen (p);
      pmt = (char *)xmalloc (len + 2);
      if (len)
	strcpy (pmt, p);
",unused,readlinexenialubuntu7.0-display.c
"  temp = (char *)xmalloc (ll + elen + 3);
  strncpy (temp, s + start, ll);
  temp[ll] = ':';
  temp[ll + 1] = ' ';
  strcpy (temp + ll + 2, emsg);
",1,unused,419,unused,"  temp = (char *)xmalloc (ll + elen + 3);
  strncpy (temp, s + start, ll);
  temp[ll] = ':';
  temp[ll + 1] = ' ';
  strcpy (temp + ll + 2, emsg);
",unused,readlinexenialubuntu7.0-histexpand.c
"      if (subst_rhs[i] == '&')
	{
	  if (j + subst_lhs_len >= new_size)
	    new = (char *)xrealloc (new, (new_size = new_size * 2 + subst_lhs_len));
	  strcpy (new + j, subst_lhs);
",1,unused,505,unused,"      if (subst_rhs[i] == '&')
	{
	  if (j + subst_lhs_len >= new_size)
	    new = (char *)xrealloc (new, (new_size = new_size * 2 + subst_lhs_len));
	  strcpy (new + j, subst_lhs);
",unused,readlinexenialubuntu7.0-histexpand.c
"
  n = strlen (temp);
  if (n >= result_len)
    result = (char *)xrealloc (result, n + 2);
  strcpy (result, temp);
",1,unused,864,unused,"
  n = strlen (temp);
  if (n >= result_len)
    result = (char *)xrealloc (result, n + 2);
  strcpy (result, temp);
",unused,readlinexenialubuntu7.0-histexpand.c
"
      string[0] = string[1] = history_expansion_char;
      string[2] = ':';
      string[3] = 's';
      strcpy (string + 4, hstring);
",1,unused,965,unused,"
      string[0] = string[1] = history_expansion_char;
      string[2] = ':';
      string[3] = 's';
      strcpy (string + 4, hstring);
",unused,readlinexenialubuntu7.0-histexpand.c
"	  if ((dquote == 0 || history_quotes_inhibit_expansion == 0) &&
	      (i == 0 || member (string[i - 1], history_word_delimiters)))
	    {
	      temp = (char *)xmalloc (l - i + 1);
	      strcpy (temp, string + i);
",1,unused,1163,unused,"	  if ((dquote == 0 || history_quotes_inhibit_expansion == 0) &&
	      (i == 0 || member (string[i - 1], history_word_delimiters)))
	    {
	      temp = (char *)xmalloc (l - i + 1);
	      strcpy (temp, string + i);
",unused,readlinexenialubuntu7.0-histexpand.c
"      result[0] = '\0';

      for (i = first, offset = 0; i < last; i++)
	{
	  strcpy (result + offset, list[i]);
",1,unused,1403,unused,"      result[0] = '\0';

      for (i = first, offset = 0; i < last; i++)
	{
	  strcpy (result + offset, list[i]);
",unused,readlinexenialubuntu7.0-histexpand.c
"  else
    home_len = strlen (home);

  return_val = (char *)xmalloc (2 + home_len + 8); /* strlen("".history"") == 8 */
  strcpy (return_val, home);
",1,unused,170,unused,"  else
    home_len = strlen (home);

  return_val = (char *)xmalloc (2 + home_len + 8); /* strlen("".history"") == 8 */
  strcpy (return_val, home);
",unused,readlinexenialubuntu7.0-histfile.c
"  return_val[home_len] = '/';
#if defined (__MSDOS__)
  strcpy (return_val + home_len + 1, ""_history"");
#else
  strcpy (return_val + home_len + 1, "".history"");
",1,unused,175,unused,"  return_val[home_len] = '/';
#if defined (__MSDOS__)
  strcpy (return_val + home_len + 1, ""_history"");
#else
  strcpy (return_val + home_len + 1, "".history"");
",unused,readlinexenialubuntu7.0-histfile.c
"#endif
      
  len = strlen (fn);
  ret = xmalloc (len + 2);
  strcpy (ret, fn);
",1,unused,204,unused,"#endif
      
  len = strlen (fn);
  ret = xmalloc (len + 2);
  strcpy (ret, fn);
",unused,readlinexenialubuntu7.0-histfile.c
"#endif
      
  len = strlen (fn);
  ret = xmalloc (len + 11);
  strcpy (ret, fn);
",1,unused,234,unused,"#endif
      
  len = strlen (fn);
  ret = xmalloc (len + 11);
  strcpy (ret, fn);
",unused,readlinexenialubuntu7.0-histfile.c
"  ret[len+2] = (pid / 1000 % 10) + '0';
  ret[len+3] = (pid / 100 % 10) + '0';
  ret[len+4] = (pid / 10 % 10) + '0';
  ret[len+5] = (pid % 10) + '0';
  strcpy (ret + len + 6, "".tmp"");
",1,unused,245,unused,"  ret[len+2] = (pid / 1000 % 10) + '0';
  ret[len+3] = (pid / 100 % 10) + '0';
  ret[len+4] = (pid / 10 % 10) + '0';
  ret[len+5] = (pid % 10) + '0';
  strcpy (ret + len + 6, "".tmp"");
",unused,readlinexenialubuntu7.0-histfile.c
"    for (j = 0, i = history_length - nelements; i < history_length; i++)
      {
	if (history_write_timestamps && the_history[i]->timestamp && the_history[i]->timestamp[0])
	  {
	    strcpy (buffer + j, the_history[i]->timestamp);
",1,unused,722,unused,"    for (j = 0, i = history_length - nelements; i < history_length; i++)
      {
	if (history_write_timestamps && the_history[i]->timestamp && the_history[i]->timestamp[0])
	  {
	    strcpy (buffer + j, the_history[i]->timestamp);
",unused,readlinexenialubuntu7.0-histfile.c
"	    strcpy (buffer + j, the_history[i]->timestamp);
	    j += strlen (the_history[i]->timestamp);
	    buffer[j++] = '\n';
	  }
	strcpy (buffer + j, the_history[i]->line);
",1,unused,726,unused,"	    strcpy (buffer + j, the_history[i]->timestamp);
	    j += strlen (the_history[i]->timestamp);
	    buffer[j++] = '\n';
	  }
	strcpy (buffer + j, the_history[i]->line);
",unused,readlinexenialubuntu7.0-histfile.c
"  if (newline)
    {
      hent->line = newline;
      hent->line[curlen++] = '\n';
      strcpy (hent->line + curlen, line);
",1,unused,430,unused,"  if (newline)
    {
      hent->line = newline;
      hent->line[curlen++] = '\n';
      strcpy (hent->line + curlen, line);
",unused,readlinexenialubuntu7.0-history.c
"  message[msglen++] = '(';

  if (flags & SF_FAILED)
    {
      strcpy (message + msglen, ""failed "");
",1,unused,182,unused,"  message[msglen++] = '(';

  if (flags & SF_FAILED)
    {
      strcpy (message + msglen, ""failed "");
",unused,readlinexenialubuntu7.0-isearch.c
"    }

  if (flags & SF_REVERSE)
    {
      strcpy (message + msglen, ""reverse-"");
",1,unused,188,unused,"    }

  if (flags & SF_REVERSE)
    {
      strcpy (message + msglen, ""reverse-"");
",unused,readlinexenialubuntu7.0-isearch.c
"      strcpy (message + msglen, ""reverse-"");
      msglen += 8;
    }

  strcpy (message + msglen, ""i-search)`"");
",1,unused,192,unused,"      strcpy (message + msglen, ""reverse-"");
      msglen += 8;
    }

  strcpy (message + msglen, ""i-search)`"");
",unused,readlinexenialubuntu7.0-isearch.c
"  msglen += 10;

  if (search_string)
    {
      strcpy (message + msglen, search_string);
",1,unused,197,unused,"  msglen += 10;

  if (search_string)
    {
      strcpy (message + msglen, search_string);
",unused,readlinexenialubuntu7.0-isearch.c
"      strcpy (message + msglen, search_string);
      msglen += searchlen;
    }

  strcpy (message + msglen, ""': "");
",1,unused,201,unused,"      strcpy (message + msglen, search_string);
      msglen += searchlen;
    }

  strcpy (message + msglen, ""': "");
",unused,readlinexenialubuntu7.0-isearch.c
"  else
    {
      /* Keep track of this so we can free it. */
      cxt->allocated_line = (char *)xmalloc (1 + strlen (rl_line_buffer));
      strcpy (cxt->allocated_line, &rl_line_buffer[0]);
",1,unused,242,unused,"  else
    {
      /* Keep track of this so we can free it. */
      cxt->allocated_line = (char *)xmalloc (1 + strlen (rl_line_buffer));
      strcpy (cxt->allocated_line, &rl_line_buffer[0]);
",unused,readlinexenialubuntu7.0-isearch.c
"_rl_isearch_fini (cxt)
     _rl_search_cxt *cxt;
{
  /* First put back the original state. */
  strcpy (rl_line_buffer, cxt->lines[cxt->save_line]);
",1,unused,274,unused,"_rl_isearch_fini (cxt)
     _rl_search_cxt *cxt;
{
  /* First put back the original state. */
  strcpy (rl_line_buffer, cxt->lines[cxt->save_line]);
",unused,readlinexenialubuntu7.0-isearch.c
"	  if (last_isearch_string)
	    {
	      cxt->search_string_size = 64 + last_isearch_string_len;
	      cxt->search_string = (char *)xrealloc (cxt->search_string, cxt->search_string_size);
	      strcpy (cxt->search_string, last_isearch_string);
",1,unused,523,unused,"	  if (last_isearch_string)
	    {
	      cxt->search_string_size = 64 + last_isearch_string_len;
	      cxt->search_string = (char *)xrealloc (cxt->search_string, cxt->search_string_size);
	      strcpy (cxt->search_string, last_isearch_string);
",unused,readlinexenialubuntu7.0-isearch.c
"      new = (char *)xmalloc (1 + strlen (old) + strlen (text));

      if (append)
	{
	  strcpy (new, old);
",1,unused,141,unused,"      new = (char *)xmalloc (1 + strlen (old) + strlen (text));

      if (append)
	{
	  strcpy (new, old);
",unused,readlinexenialubuntu7.0-kill.c
"
      if (append)
	{
	  strcpy (new, old);
	  strcat (new, text);
",1,unused,142,unused,"
      if (append)
	{
	  strcpy (new, old);
	  strcat (new, text);
",unused,readlinexenialubuntu7.0-kill.c
"	  strcat (new, text);
	}
      else
	{
	  strcpy (new, text);
",1,unused,146,unused,"	  strcat (new, text);
	}
      else
	{
	  strcpy (new, text);
",unused,readlinexenialubuntu7.0-kill.c
"	}
      else
	{
	  strcpy (new, text);
	  strcat (new, old);
",1,unused,147,unused,"	}
      else
	{
	  strcpy (new, text);
	  strcat (new, old);
",unused,readlinexenialubuntu7.0-kill.c
"      return;
    }

  ext = NULL;
  strcpy (label, ""??"");
",1,unused,318,unused,"      return;
    }

  ext = NULL;
  strcpy (label, ""??"");
",unused,readlinexenialubuntu7.0-parse-colors.c
"      rl_revert_line (1, 0);
      entry = replace_history_entry (where_history (), the_line, (histdata_t)NULL);
      _rl_free_history_entry (entry);

      strcpy (the_line, temp);
",1,unused,472,unused,"      rl_revert_line (1, 0);
      entry = replace_history_entry (where_history (), the_line, (histdata_t)NULL);
      _rl_free_history_entry (entry);

      strcpy (the_line, temp);
",unused,readlinexenialubuntu7.0-readline.c
"
  len = strlen (text);
  if (len >= rl_line_buffer_len)
    rl_extend_line_buffer (len);
  strcpy (rl_line_buffer, text);
",1,unused,218,unused,"
  len = strlen (text);
  if (len >= rl_line_buffer_len)
    rl_extend_line_buffer (len);
  strcpy (rl_line_buffer, text);
",unused,readlinexenialubuntu7.0-text.c
"	{
	  if ((result_index + len + 1) > result_size)
	    result = (char *)xrealloc (result, 1 + (result_size += (len + 20)));

	  strcpy (result + result_index, expansion);
",1,unused,255,unused,"	{
	  if ((result_index + len + 1) > result_size)
	    result = (char *)xrealloc (result, 1 + (result_size += (len + 20)));

	  strcpy (result + result_index, expansion);
",unused,readlinexenialubuntu7.0-tilde.c
"  plen = (prefix && *prefix) ? strlen (prefix) : 0;
  slen = strlen (suffix + suffind);
  ret = (char *)xmalloc (plen + slen + 1);
  if (plen)
    strcpy (ret, prefix);
",1,unused,338,unused,"  plen = (prefix && *prefix) ? strlen (prefix) : 0;
  slen = strlen (suffix + suffind);
  ret = (char *)xmalloc (plen + slen + 1);
  if (plen)
    strcpy (ret, prefix);
",unused,readlinexenialubuntu7.0-tilde.c
"  slen = strlen (suffix + suffind);
  ret = (char *)xmalloc (plen + slen + 1);
  if (plen)
    strcpy (ret, prefix);
  strcpy (ret + plen, suffix + suffind);
",1,unused,339,unused,"  slen = strlen (suffix + suffind);
  ret = (char *)xmalloc (plen + slen + 1);
  if (plen)
    strcpy (ret, prefix);
  strcpy (ret + plen, suffix + suffind);
",unused,readlinexenialubuntu7.0-tilde.c
"char *
_rl_savestring (s)
     const char *s;
{
  return (strcpy ((char *)xmalloc (1 + (int)strlen (s)), (s)));
",1,unused,478,unused,"char *
_rl_savestring (s)
     const char *s;
{
  return (strcpy ((char *)xmalloc (1 + (int)strlen (s)), (s)));
",unused,readlinexenialubuntu7.0-util.c
"   
   //11/14/01 added id string 

   if(njunk > strlen(id_str)+8) {
     sprintf(id_str, ""%s-%s"", PACKAGE, VERSION);
",1,unused,547,unused,"   
   //11/14/01 added id string 

   if(njunk > strlen(id_str)+8) {
     sprintf(id_str, ""%s-%s"", PACKAGE, VERSION);
",unused,rodinia_heartwall_orig-AVI2Favilib.c
"
   OUT4CC (""ISFT"");
   OUTLONG(MAX_INFO_STRLEN);

   sprintf(id_str, ""%s-%s"", PACKAGE, VERSION);
",1,unused,821,unused,"
   OUT4CC (""ISFT"");
   OUTLONG(MAX_INFO_STRLEN);

   sprintf(id_str, ""%s-%s"", PACKAGE, VERSION);
",unused,rodinia_heartwall_orig-AVI2Favilib.c
"   
   /* Add index entry */

   //set tag for current audio track
   sprintf((char *)astr, ""0%1dwb"", AVI->aptr+1);
",1,unused,907,unused,"   
   /* Add index entry */

   //set tag for current audio track
   sprintf((char *)astr, ""0%1dwb"", AVI->aptr+1);
",unused,rodinia_heartwall_orig-AVI2Favilib.c
"      AVI_errno == AVI_ERR_WRITE ||
      AVI_errno == AVI_ERR_WRITE_INDEX ||
      AVI_errno == AVI_ERR_CLOSE )
   {
      sprintf(error_string,""%s - %s"",avi_errors[aerrno],strerror(errno));
",1,unused,1823,unused,"      AVI_errno == AVI_ERR_WRITE ||
      AVI_errno == AVI_ERR_WRITE_INDEX ||
      AVI_errno == AVI_ERR_CLOSE )
   {
      sprintf(error_string,""%s - %s"",avi_errors[aerrno],strerror(errno));
",unused,rodinia_heartwall_orig-AVI2Favilib.c
"   
   //11/14/01 added id string 

   if(njunk > strlen(id_str)+8) {
     sprintf(id_str, ""%s-%s"", PACKAGE, VERSION);
",1,unused,543,unused,"   
   //11/14/01 added id string 

   if(njunk > strlen(id_str)+8) {
     sprintf(id_str, ""%s-%s"", PACKAGE, VERSION);
",unused,rodinia_leukocyte_orig-OpenMP2Favilib.c
"
   OUT4CC (""ISFT"");
   OUTLONG(MAX_INFO_STRLEN);

   sprintf(id_str, ""%s-%s"", PACKAGE, VERSION);
",1,unused,817,unused,"
   OUT4CC (""ISFT"");
   OUTLONG(MAX_INFO_STRLEN);

   sprintf(id_str, ""%s-%s"", PACKAGE, VERSION);
",unused,rodinia_leukocyte_orig-OpenMP2Favilib.c
"   
   /* Add index entry */

   //set tag for current audio track
   sprintf((char *)astr, ""0%1dwb"", AVI->aptr+1);
",1,unused,903,unused,"   
   /* Add index entry */

   //set tag for current audio track
   sprintf((char *)astr, ""0%1dwb"", AVI->aptr+1);
",unused,rodinia_leukocyte_orig-OpenMP2Favilib.c
"      AVI_errno == AVI_ERR_WRITE ||
      AVI_errno == AVI_ERR_WRITE_INDEX ||
      AVI_errno == AVI_ERR_CLOSE )
   {
      sprintf(error_string,""%s - %s"",avi_errors[aerrno],strerror(errno));
",1,unused,1826,unused,"      AVI_errno == AVI_ERR_WRITE ||
      AVI_errno == AVI_ERR_WRITE_INDEX ||
      AVI_errno == AVI_ERR_CLOSE )
   {
      sprintf(error_string,""%s - %s"",avi_errors[aerrno],strerror(errno));
",unused,rodinia_leukocyte_orig-OpenMP2Favilib.c
"		neighbors[j].dist = OPEN;
	}

	/**** main processing ****/  
	if(fscanf(flist, ""%s\n"", dbname) != 1) {
",1,unused,63,unused,"		neighbors[j].dist = OPEN;
	}

	/**** main processing ****/  
	if(fscanf(flist, ""%s\n"", dbname) != 1) {
",unused,rodinia_nn_orig-nn_openmp.c
"
				if(feof(flist))
		  			done = 1;
				else {
	 				if(fscanf(flist, ""%s\n"", dbname) != 1) {
",1,unused,87,unused,"
				if(feof(flist))
		  			done = 1;
				else {
	 				if(fscanf(flist, ""%s\n"", dbname) != 1) {
",unused,rodinia_nn_orig-nn_openmp.c
"			}
			// compare each record with max value to find the nearest neighbor
			if( z[i] < neighbors[max_idx].dist ) {
				sandbox[(i+1)*REC_LENGTH-1] = '\0';
			  	strcpy(neighbors[max_idx].entry, sandbox +i*REC_LENGTH);
",1,unused,140,unused,"			}
			// compare each record with max value to find the nearest neighbor
			if( z[i] < neighbors[max_idx].dist ) {
				sandbox[(i+1)*REC_LENGTH-1] = '\0';
			  	strcpy(neighbors[max_idx].entry, sandbox +i*REC_LENGTH);
",unused,rodinia_nn_orig-nn_openmp.c
"        return err;
      tp += strlen(tp);
      break;
    }
    tp += sprintf(tp, ""%x"", words[i]);
",1,unused,139,unused,"        return err;
      tp += strlen(tp);
      break;
    }
    tp += sprintf(tp, ""%x"", words[i]);
",unused,rrockru_b-utility2Fio2Flibuv2Fsrc2Finet.c
"   */
  if ((size_t)(tp - tmp) > size) {
    return UV_ENOSPC;
  }
  strcpy(dst, tmp);
",1,unused,152,unused,"   */
  if ((size_t)(tp - tmp) > size) {
    return UV_ENOSPC;
  }
  strcpy(dst, tmp);
",unused,rrockru_b-utility2Fio2Flibuv2Fsrc2Finet.c
"  if (w == NULL)
    return UV_ENOMEM;

  w->wd = wd;
  w->path = strcpy((char*)(w + 1), path);
",1,unused,314,unused,"  if (w == NULL)
    return UV_ENOMEM;

  w->wd = wd;
  w->path = strcpy((char*)(w + 1), path);
",unused,rrockru_b-utility2Fio2Flibuv2Fsrc2Funix2Flinux-inotify.c
"    fprintf(ctx->fp, ""static const uint8_t %s%s[] = {\n"",
	    LABEL_PREFIX_LIBINIT, modname);
    line[0] = '\0';
    for (n = 0, p = obuf; p < optr; p++) {
      n += sprintf(line+n, ""%d,"", *p);
",1,unused,63,unused,"    fprintf(ctx->fp, ""static const uint8_t %s%s[] = {\n"",
	    LABEL_PREFIX_LIBINIT, modname);
    line[0] = '\0';
    for (n = 0, p = obuf; p < optr; p++) {
      n += sprintf(line+n, ""%d,"", *p);
",unused,s4paneum_wrk-obj2FLuaJIT-2.1.0-beta32Fsrc2Fhost2Fbuildvm_lib.c
"  if (modnamelen > sizeof(modname)-1) {
    fprintf(stderr, ""Error: module name too long: '%s'\n"", p);
    exit(1);
  }
  strcpy(modname, p);
",1,unused,94,unused,"  if (modnamelen > sizeof(modname)-1) {
    fprintf(stderr, ""Error: module name too long: '%s'\n"", p);
    exit(1);
  }
  strcpy(modname, p);
",unused,s4paneum_wrk-obj2FLuaJIT-2.1.0-beta32Fsrc2Fhost2Fbuildvm_lib.c
"    if (strlen(p) > sizeof(funcname)-1) {
      fprintf(stderr, ""Error: function name too long: '%s'\n"", p);
      exit(1);
    }
    strcpy(funcname, p);
",1,unused,142,unused,"    if (strlen(p) > sizeof(funcname)-1) {
      fprintf(stderr, ""Error: function name too long: '%s'\n"", p);
      exit(1);
    }
    strcpy(funcname, p);
",unused,s4paneum_wrk-obj2FLuaJIT-2.1.0-beta32Fsrc2Fhost2Fbuildvm_lib.c
"  if (p+strlen(name)+1 >= (char *)obuf+sizeof(obuf)) {
    fprintf(stderr, ""Error: output buffer overflow\n"");
    exit(1);
  }
  strcpy(p, name);
",1,unused,225,unused,"  if (p+strlen(name)+1 >= (char *)obuf+sizeof(obuf)) {
    fprintf(stderr, ""Error: output buffer overflow\n"");
    exit(1);
  }
  strcpy(p, name);
",unused,s4paneum_wrk-obj2FLuaJIT-2.1.0-beta32Fsrc2Fhost2Fbuildvm_lib.c
"break;
}
case'p':{
char buff[4*sizeof(void*)+8];
sprintf(buff,""%p"",va_arg(argp,void*));
",1,unused,698,unused,"break;
}
case'p':{
char buff[4*sizeof(void*)+8];
sprintf(buff,""%p"",va_arg(argp,void*));
",unused,s4paneum_wrk-obj2FLuaJIT-2.1.0-beta32Fsrc2Fhost2Fminilua.c
"size_t l;
source++;
bufflen-=sizeof("" '...' "");
l=strlen(source);
strcpy(out,"""");
",1,unused,742,unused,"size_t l;
source++;
bufflen-=sizeof("" '...' "");
l=strlen(source);
strcpy(out,"""");
",unused,s4paneum_wrk-obj2FLuaJIT-2.1.0-beta32Fsrc2Fhost2Fminilua.c
"l=strlen(source);
strcpy(out,"""");
if(l>bufflen){
source+=(l-bufflen);
strcat(out,""..."");
",1,unused,745,unused,"l=strlen(source);
strcpy(out,"""");
if(l>bufflen){
source+=(l-bufflen);
strcat(out,""..."");
",unused,s4paneum_wrk-obj2FLuaJIT-2.1.0-beta32Fsrc2Fhost2Fminilua.c
"if(l>bufflen){
source+=(l-bufflen);
strcat(out,""..."");
}
strcat(out,source);
",1,unused,747,unused,"if(l>bufflen){
source+=(l-bufflen);
strcat(out,""..."");
}
strcat(out,source);
",unused,s4paneum_wrk-obj2FLuaJIT-2.1.0-beta32Fsrc2Fhost2Fminilua.c
"else{
size_t len=strcspn(source,""\n\r"");
bufflen-=sizeof("" [string \""...\""] "");
if(len>bufflen)len=bufflen;
strcpy(out,""[string \"""");
",1,unused,753,unused,"else{
size_t len=strcspn(source,""\n\r"");
bufflen-=sizeof("" [string \""...\""] "");
if(len>bufflen)len=bufflen;
strcpy(out,""[string \"""");
",unused,s4paneum_wrk-obj2FLuaJIT-2.1.0-beta32Fsrc2Fhost2Fminilua.c
"if(len>bufflen)len=bufflen;
strcpy(out,""[string \"""");
if(source[len]!='\0'){
strncat(out,source,len);
strcat(out,""..."");
",1,unused,756,unused,"if(len>bufflen)len=bufflen;
strcpy(out,""[string \"""");
if(source[len]!='\0'){
strncat(out,source,len);
strcat(out,""..."");
",unused,s4paneum_wrk-obj2FLuaJIT-2.1.0-beta32Fsrc2Fhost2Fminilua.c
"strncat(out,source,len);
strcat(out,""..."");
}
else
strcat(out,source);
",1,unused,759,unused,"strncat(out,source,len);
strcat(out,""..."");
}
else
strcat(out,source);
",unused,s4paneum_wrk-obj2FLuaJIT-2.1.0-beta32Fsrc2Fhost2Fminilua.c
"strcat(out,""..."");
}
else
strcat(out,source);
strcat(out,""\""]"");
",1,unused,760,unused,"strcat(out,""..."");
}
else
strcat(out,source);
strcat(out,""\""]"");
",unused,s4paneum_wrk-obj2FLuaJIT-2.1.0-beta32Fsrc2Fhost2Fminilua.c
"}
static void addintlen(char*form){
size_t l=strlen(form);
char spec=form[l-1];
strcpy(form+l-1,""l"");
",1,unused,7576,unused,"}
static void addintlen(char*form){
size_t l=strlen(form);
char spec=form[l-1];
strcpy(form+l-1,""l"");
",unused,s4paneum_wrk-obj2FLuaJIT-2.1.0-beta32Fsrc2Fhost2Fminilua.c
"luaL_argerror(L,arg,""no value"");
strfrmt=scanformat(L,strfrmt,form);
switch(*strfrmt++){
case'c':{
sprintf(buff,form,(int)luaL_checknumber(L,arg));
",1,unused,7601,unused,"luaL_argerror(L,arg,""no value"");
strfrmt=scanformat(L,strfrmt,form);
switch(*strfrmt++){
case'c':{
sprintf(buff,form,(int)luaL_checknumber(L,arg));
",unused,s4paneum_wrk-obj2FLuaJIT-2.1.0-beta32Fsrc2Fhost2Fminilua.c
"break;
}
case'd':case'i':{
addintlen(form);
sprintf(buff,form,(long)luaL_checknumber(L,arg));
",1,unused,7606,unused,"break;
}
case'd':case'i':{
addintlen(form);
sprintf(buff,form,(long)luaL_checknumber(L,arg));
",unused,s4paneum_wrk-obj2FLuaJIT-2.1.0-beta32Fsrc2Fhost2Fminilua.c
"break;
}
case'o':case'u':case'x':case'X':{
addintlen(form);
sprintf(buff,form,(unsigned long)luaL_checknumber(L,arg));
",1,unused,7611,unused,"break;
}
case'o':case'u':case'x':case'X':{
addintlen(form);
sprintf(buff,form,(unsigned long)luaL_checknumber(L,arg));
",unused,s4paneum_wrk-obj2FLuaJIT-2.1.0-beta32Fsrc2Fhost2Fminilua.c
"break;
}
case'e':case'E':case'f':
case'g':case'G':{
sprintf(buff,form,(double)luaL_checknumber(L,arg));
",1,unused,7616,unused,"break;
}
case'e':case'E':case'f':
case'g':case'G':{
sprintf(buff,form,(double)luaL_checknumber(L,arg));
",unused,s4paneum_wrk-obj2FLuaJIT-2.1.0-beta32Fsrc2Fhost2Fminilua.c
"luaL_addvalue(&b);
continue;
}
else{
sprintf(buff,form,s);
",1,unused,7632,unused,"luaL_addvalue(&b);
continue;
}
else{
sprintf(buff,form,s);
",unused,s4paneum_wrk-obj2FLuaJIT-2.1.0-beta32Fsrc2Fhost2Fminilua.c
"#else
#if LJ_TARGET_POSIX
  char buf[15+1];
  int fp;
  strcpy(buf, ""/tmp/lua_XXXXXX"");
",1,unused,86,unused,"#else
#if LJ_TARGET_POSIX
  char buf[15+1];
  int fp;
  strcpy(buf, ""/tmp/lua_XXXXXX"");
",unused,s4paneum_wrk-obj2FLuaJIT-2.1.0-beta32Fsrc2Flib_os.c
"    if (len >= LUA_IDSIZE) {
      src += len-(LUA_IDSIZE-4);  /* Get last part of file name. */
      *out++ = '.'; *out++ = '.'; *out++ = '.';
    }
    strcpy(out, src);
",1,unused,332,unused,"    if (len >= LUA_IDSIZE) {
      src += len-(LUA_IDSIZE-4);  /* Get last part of file name. */
      *out++ = '.'; *out++ = '.'; *out++ = '.';
    }
    strcpy(out, src);
",unused,s4paneum_wrk-obj2FLuaJIT-2.1.0-beta32Fsrc2Flj_debug.c
"  } else {  /* Output [string ""string""] or [builtin:name]. */
    size_t len;  /* Length, up to first control char. */
    for (len = 0; len < LUA_IDSIZE-12; len++)
      if (((const unsigned char *)src)[len] < ' ') break;
    strcpy(out, line == ~(BCLine)0 ? ""[builtin:"" : ""[string \""""); out += 9;
",1,unused,337,unused,"  } else {  /* Output [string ""string""] or [builtin:name]. */
    size_t len;  /* Length, up to first control char. */
    for (len = 0; len < LUA_IDSIZE-12; len++)
      if (((const unsigned char *)src)[len] < ' ') break;
    strcpy(out, line == ~(BCLine)0 ? ""[builtin:"" : ""[string \""""); out += 9;
",unused,s4paneum_wrk-obj2FLuaJIT-2.1.0-beta32Fsrc2Flj_debug.c
"    strcpy(out, line == ~(BCLine)0 ? ""[builtin:"" : ""[string \""""); out += 9;
    if (src[len] != '\0') {  /* Must truncate? */
      if (len > LUA_IDSIZE-15) len = LUA_IDSIZE-15;
      strncpy(out, src, len); out += len;
      strcpy(out, ""...""); out += 3;
",1,unused,341,unused,"    strcpy(out, line == ~(BCLine)0 ? ""[builtin:"" : ""[string \""""); out += 9;
    if (src[len] != '\0') {  /* Must truncate? */
      if (len > LUA_IDSIZE-15) len = LUA_IDSIZE-15;
      strncpy(out, src, len); out += len;
      strcpy(out, ""...""); out += 3;
",unused,s4paneum_wrk-obj2FLuaJIT-2.1.0-beta32Fsrc2Flj_debug.c
"      if (len > LUA_IDSIZE-15) len = LUA_IDSIZE-15;
      strncpy(out, src, len); out += len;
      strcpy(out, ""...""); out += 3;
    } else {
      strcpy(out, src); out += len;
",1,unused,343,unused,"      if (len > LUA_IDSIZE-15) len = LUA_IDSIZE-15;
      strncpy(out, src, len); out += len;
      strcpy(out, ""...""); out += 3;
    } else {
      strcpy(out, src); out += len;
",unused,s4paneum_wrk-obj2FLuaJIT-2.1.0-beta32Fsrc2Flj_debug.c
"      strcpy(out, ""...""); out += 3;
    } else {
      strcpy(out, src); out += len;
    }
    strcpy(out, line == ~(BCLine)0 ? ""]"" : ""\""]"");
",1,unused,345,unused,"      strcpy(out, ""...""); out += 3;
    } else {
      strcpy(out, src); out += len;
    }
    strcpy(out, line == ~(BCLine)0 ? ""]"" : ""\""]"");
",unused,s4paneum_wrk-obj2FLuaJIT-2.1.0-beta32Fsrc2Flj_debug.c
"                BIO_printf(bio_err, ""certificate file name too long\n"");
                goto end;
            }

            strcpy(buf[2], outdir);
",1,unused,999,unused,"                BIO_printf(bio_err, ""certificate file name too long\n"");
                goto end;
            }

            strcpy(buf[2], outdir);
",unused,s4paneum_wrk-obj2Fopenssl-1.1.0g2Fapps2Fca.c
"        p = start;
        *p++ = ' ';
        *p++ = '-';
        if (o->name[0])
            p += strlen(strcpy(p, o->name));
",1,unused,874,unused,"        p = start;
        *p++ = ' ';
        *p++ = '-';
        if (o->name[0])
            p += strlen(strcpy(p, o->name));
",unused,s4paneum_wrk-obj2Fopenssl-1.1.0g2Fapps2Fopt.c
"        else
            *p++ = '*';
        if (o->valtype != '-') {
            *p++ = ' ';
            p += strlen(strcpy(p, valtype2param(o)));
",1,unused,879,unused,"        else
            *p++ = '*';
        if (o->valtype != '-') {
            *p++ = ' ';
            p += strlen(strcpy(p, valtype2param(o)));
",unused,s4paneum_wrk-obj2Fopenssl-1.1.0g2Fapps2Fopt.c
"            BIOerr(BIO_F_BIO_ACCEPT, ERR_R_MALLOC_FAILURE);
            BIO_closesocket(ret);
            ret = (int)INVALID_SOCKET;
        } else {
            strcpy(*ip_port, host);
",1,unused,273,unused,"            BIOerr(BIO_F_BIO_ACCEPT, ERR_R_MALLOC_FAILURE);
            BIO_closesocket(ret);
            ret = (int)INVALID_SOCKET;
        } else {
            strcpy(*ip_port, host);
",unused,s4paneum_wrk-obj2Fopenssl-1.1.0g2Fcrypto2Fbio2Fb_sock.c
"            BIO_closesocket(ret);
            ret = (int)INVALID_SOCKET;
        } else {
            strcpy(*ip_port, host);
            strcat(*ip_port, "":"");
",1,unused,274,unused,"            BIO_closesocket(ret);
            ret = (int)INVALID_SOCKET;
        } else {
            strcpy(*ip_port, host);
            strcat(*ip_port, "":"");
",unused,s4paneum_wrk-obj2Fopenssl-1.1.0g2Fcrypto2Fbio2Fb_sock.c
"            ret = (int)INVALID_SOCKET;
        } else {
            strcpy(*ip_port, host);
            strcat(*ip_port, "":"");
            strcat(*ip_port, port);
",1,unused,275,unused,"            ret = (int)INVALID_SOCKET;
        } else {
            strcpy(*ip_port, host);
            strcat(*ip_port, "":"");
            strcat(*ip_port, port);
",unused,s4paneum_wrk-obj2Fopenssl-1.1.0g2Fcrypto2Fbio2Fb_sock.c
"        if (merged == NULL) {
            DSOerr(DSO_F_DLFCN_MERGER, ERR_R_MALLOC_FAILURE);
            return (NULL);
        }
        strcpy(merged, filespec2);
",1,unused,236,unused,"        if (merged == NULL) {
            DSOerr(DSO_F_DLFCN_MERGER, ERR_R_MALLOC_FAILURE);
            return (NULL);
        }
        strcpy(merged, filespec2);
",unused,s4paneum_wrk-obj2Fopenssl-1.1.0g2Fcrypto2Fdso2Fdso_dlfcn.c
"            return (NULL);
        }
        strcpy(merged, filespec2);
        merged[spec2len] = '/';
        strcpy(&merged[spec2len + 1], filespec1);
",1,unused,238,unused,"            return (NULL);
        }
        strcpy(merged, filespec2);
        merged[spec2len] = '/';
        strcpy(&merged[spec2len + 1], filespec1);
",unused,s4paneum_wrk-obj2Fopenssl-1.1.0g2Fcrypto2Fdso2Fdso_dlfcn.c
"        return (NULL);
    }
    if (transform) {
        if ((DSO_flags(dso) & DSO_FLAG_NAME_TRANSLATION_EXT_ONLY) == 0)
            sprintf(translated, ""lib%s"" DSO_EXTENSION, filename);
",1,unused,264,unused,"        return (NULL);
    }
    if (transform) {
        if ((DSO_flags(dso) & DSO_FLAG_NAME_TRANSLATION_EXT_ONLY) == 0)
            sprintf(translated, ""lib%s"" DSO_EXTENSION, filename);
",unused,s4paneum_wrk-obj2Fopenssl-1.1.0g2Fcrypto2Fdso2Fdso_dlfcn.c
"    if (transform) {
        if ((DSO_flags(dso) & DSO_FLAG_NAME_TRANSLATION_EXT_ONLY) == 0)
            sprintf(translated, ""lib%s"" DSO_EXTENSION, filename);
        else
            sprintf(translated, ""%s"" DSO_EXTENSION, filename);
",1,unused,266,unused,"    if (transform) {
        if ((DSO_flags(dso) & DSO_FLAG_NAME_TRANSLATION_EXT_ONLY) == 0)
            sprintf(translated, ""lib%s"" DSO_EXTENSION, filename);
        else
            sprintf(translated, ""%s"" DSO_EXTENSION, filename);
",unused,s4paneum_wrk-obj2Fopenssl-1.1.0g2Fcrypto2Fdso2Fdso_dlfcn.c
"            sprintf(translated, ""lib%s"" DSO_EXTENSION, filename);
        else
            sprintf(translated, ""%s"" DSO_EXTENSION, filename);
    } else
        sprintf(translated, ""%s"", filename);
",1,unused,268,unused,"            sprintf(translated, ""lib%s"" DSO_EXTENSION, filename);
        else
            sprintf(translated, ""%s"" DSO_EXTENSION, filename);
    } else
        sprintf(translated, ""%s"", filename);
",unused,s4paneum_wrk-obj2Fopenssl-1.1.0g2Fcrypto2Fdso2Fdso_dlfcn.c
"        for (i = 0; i < (int)OSSL_NELEM(ts_failure_info); ++i) {
            if (ASN1_BIT_STRING_get_bit(info->failure_info,
                                        ts_failure_info[i].code)) {
                if (!first)
                    strcat(failure_text, "","");
",1,unused,430,unused,"        for (i = 0; i < (int)OSSL_NELEM(ts_failure_info); ++i) {
            if (ASN1_BIT_STRING_get_bit(info->failure_info,
                                        ts_failure_info[i].code)) {
                if (!first)
                    strcat(failure_text, "","");
",unused,s4paneum_wrk-obj2Fopenssl-1.1.0g2Fcrypto2Fts2Fts_rsp_verify.c
"                if (!first)
                    strcat(failure_text, "","");
                else
                    first = 0;
                strcat(failure_text, ts_failure_info[i].text);
",1,unused,433,unused,"                if (!first)
                    strcat(failure_text, "","");
                else
                    first = 0;
                strcat(failure_text, ts_failure_info[i].text);
",unused,s4paneum_wrk-obj2Fopenssl-1.1.0g2Fcrypto2Fts2Fts_rsp_verify.c
"            }
        }
    }
    if (failure_text[0] == '\0')
        strcpy(failure_text, ""unspecified"");
",1,unused,438,unused,"            }
        }
    }
    if (failure_text[0] == '\0')
        strcpy(failure_text, ""unspecified"");
",unused,s4paneum_wrk-obj2Fopenssl-1.1.0g2Fcrypto2Fts2Fts_rsp_verify.c
"            oline[0] = 0;
            for (i = 0; i < 8; i++) {
                BIO_snprintf(htmp, sizeof htmp, ""%X"", p[0] << 8 | p[1]);
                p += 2;
                strcat(oline, htmp);
",1,unused,118,unused,"            oline[0] = 0;
            for (i = 0; i < 8; i++) {
                BIO_snprintf(htmp, sizeof htmp, ""%X"", p[0] << 8 | p[1]);
                p += 2;
                strcat(oline, htmp);
",unused,s4paneum_wrk-obj2Fopenssl-1.1.0g2Fcrypto2Fx509v32Fv3_alt.c
"                BIO_snprintf(htmp, sizeof htmp, ""%X"", p[0] << 8 | p[1]);
                p += 2;
                strcat(oline, htmp);
                if (i != 7)
                    strcat(oline, "":"");
",1,unused,120,unused,"                BIO_snprintf(htmp, sizeof htmp, ""%X"", p[0] << 8 | p[1]);
                p += 2;
                strcat(oline, htmp);
                if (i != 7)
                    strcat(oline, "":"");
",unused,s4paneum_wrk-obj2Fopenssl-1.1.0g2Fcrypto2Fx509v32Fv3_alt.c
"    aout = DH_compute_key(abuf, bpub_key, a);

    BIO_puts(out, ""key1 ="");
    for (i = 0; i < aout; i++) {
        sprintf(buf, ""%02X"", abuf[i]);
",1,unused,135,unused,"    aout = DH_compute_key(abuf, bpub_key, a);

    BIO_puts(out, ""key1 ="");
    for (i = 0; i < aout; i++) {
        sprintf(buf, ""%02X"", abuf[i]);
",unused,s4paneum_wrk-obj2Fopenssl-1.1.0g2Ftest2Fdhtest.c
"    bout = DH_compute_key(bbuf, apub_key, b);

    BIO_puts(out, ""key2 ="");
    for (i = 0; i < bout; i++) {
        sprintf(buf, ""%02X"", bbuf[i]);
",1,unused,149,unused,"    bout = DH_compute_key(bbuf, apub_key, b);

    BIO_puts(out, ""key2 ="");
    for (i = 0; i < bout; i++) {
        sprintf(buf, ""%02X"", bbuf[i]);
",unused,s4paneum_wrk-obj2Fopenssl-1.1.0g2Ftest2Fdhtest.c
"    cout = DH_compute_key(cbuf, apub_key, c);

    BIO_puts(out, ""key3 ="");
    for (i = 0; i < cout; i++) {
        sprintf(buf, ""%02X"", cbuf[i]);
",1,unused,163,unused,"    cout = DH_compute_key(cbuf, apub_key, c);

    BIO_puts(out, ""key3 ="");
    for (i = 0; i < cout; i++) {
        sprintf(buf, ""%02X"", cbuf[i]);
",unused,s4paneum_wrk-obj2Fopenssl-1.1.0g2Ftest2Fdhtest.c
"    } else
        printf(""Successfully added and removed to an empty list!\n"");
    printf(""About to beef up the engine-type list\n"");
    for (loop = 0; loop < 512; loop++) {
        sprintf(buf, ""id%i"", loop);
",1,unused,351,unused,"    } else
        printf(""Successfully added and removed to an empty list!\n"");
    printf(""About to beef up the engine-type list\n"");
    for (loop = 0; loop < 512; loop++) {
        sprintf(buf, ""id%i"", loop);
",unused,s4paneum_wrk-obj2Fopenssl-1.1.0g2Ftest2Fenginetest.c
"    printf(""About to beef up the engine-type list\n"");
    for (loop = 0; loop < 512; loop++) {
        sprintf(buf, ""id%i"", loop);
        id = OPENSSL_strdup(buf);
        sprintf(buf, ""Fake engine type %i"", loop);
",1,unused,353,unused,"    printf(""About to beef up the engine-type list\n"");
    for (loop = 0; loop < 512; loop++) {
        sprintf(buf, ""id%i"", loop);
        id = OPENSSL_strdup(buf);
        sprintf(buf, ""Fake engine type %i"", loop);
",unused,s4paneum_wrk-obj2Fopenssl-1.1.0g2Ftest2Fenginetest.c
"    unsigned int i;
    static char buf[80];

    for (i = 0; i < len; i++)
        sprintf(&(buf[i * 2]), ""%02x"", md[i]);
",1,unused,309,unused,"    unsigned int i;
    static char buf[80];

    for (i = 0; i < len; i++)
        sprintf(&(buf[i * 2]), ""%02x"", md[i]);
",unused,s4paneum_wrk-obj2Fopenssl-1.1.0g2Ftest2Fhmactest.c
"    int i;
    static char buf[80];

    for (i = 0; i < MD4_DIGEST_LENGTH; i++)
        sprintf(&(buf[i * 2]), ""%02x"", md[i]);
",1,unused,84,unused,"    int i;
    static char buf[80];

    for (i = 0; i < MD4_DIGEST_LENGTH; i++)
        sprintf(&(buf[i * 2]), ""%02x"", md[i]);
",unused,s4paneum_wrk-obj2Fopenssl-1.1.0g2Ftest2Fmd4test.c
"    int i;
    static char buf[80];

    for (i = 0; i < MD5_DIGEST_LENGTH; i++)
        sprintf(&(buf[i * 2]), ""%02x"", md[i]);
",1,unused,85,unused,"    int i;
    static char buf[80];

    for (i = 0; i < MD5_DIGEST_LENGTH; i++)
        sprintf(&(buf[i * 2]), ""%02x"", md[i]);
",unused,s4paneum_wrk-obj2Fopenssl-1.1.0g2Ftest2Fmd5test.c
"    int i;
    static char buf[80];

    for (i = 0; i < RIPEMD160_DIGEST_LENGTH; i++)
        sprintf(&(buf[i * 2]), ""%02x"", md[i]);
",1,unused,89,unused,"    int i;
    static char buf[80];

    for (i = 0; i < RIPEMD160_DIGEST_LENGTH; i++)
        sprintf(&(buf[i * 2]), ""%02x"", md[i]);
",unused,s4paneum_wrk-obj2Fopenssl-1.1.0g2Ftest2Frmdtest.c
"    int i;
    static char buf[80];

    for (i = 0; i < SHA_DIGEST_LENGTH; i++)
        sprintf(&(buf[i * 2]), ""%02x"", md[i]);
",1,unused,109,unused,"    int i;
    static char buf[80];

    for (i = 0; i < SHA_DIGEST_LENGTH; i++)
        sprintf(&(buf[i * 2]), ""%02x"", md[i]);
",unused,s4paneum_wrk-obj2Fopenssl-1.1.0g2Ftest2Fsha1test.c
"                strcat( lDialogString , ""-e 'end repeat' "" );
                strcat( lDialogString , ""-e 'mystring' "");
                strcat(lDialogString, ""-e 'on error number -128' "" ) ;
                strcat(lDialogString, ""-e 'end try'"") ;
                if ( ! osx9orBetter() ) strcat( lDialogString, "" -e 'end tell'"") ;
",1,unused,6951,unused,"                strcat( lDialogString , ""-e 'end repeat' "" );
                strcat( lDialogString , ""-e 'mystring' "");
                strcat(lDialogString, ""-e 'on error number -128' "" ) ;
                strcat(lDialogString, ""-e 'end try'"") ;
                if ( ! osx9orBetter() ) strcat( lDialogString, "" -e 'end tell'"") ;
",unused,samhocevar_fork-tinyfiledialogs-tinyfiledialogs.c
"                                strcat( lDialogString , ""information"" ) ;
                        }
                }

                if (tinyfd_silent) strcat( lDialogString , "" 2>/dev/null "");
",1,unused,4332,unused,"                                strcat( lDialogString , ""information"" ) ;
                        }
                }

                if (tinyfd_silent) strcat( lDialogString , "" 2>/dev/null "");
",unused,samhocevar_fork-tinyfiledialogs-tinyfiledialogs.c
"                else
                {
                        strcat(lDialogString, "" --hide-text"") ;
                }
                if (tinyfd_silent) strcat( lDialogString , "" 2>/dev/null "");
",1,unused,5350,unused,"                else
                {
                        strcat(lDialogString, "" --hide-text"") ;
                }
                if (tinyfd_silent) strcat( lDialogString , "" 2>/dev/null "");
",unused,samhocevar_fork-tinyfiledialogs-tinyfiledialogs.c
"                                strcat( lDialogString , "" "" ) ;
                        }
                        strcat( lDialogString , ""' --file-filter='All files | *'"" ) ;
                }
                if (tinyfd_silent) strcat( lDialogString , "" 2>/dev/null "");
",1,unused,5901,unused,"                                strcat( lDialogString , "" "" ) ;
                        }
                        strcat( lDialogString , ""' --file-filter='All files | *'"" ) ;
                }
                if (tinyfd_silent) strcat( lDialogString , "" 2>/dev/null "");
",unused,samhocevar_fork-tinyfiledialogs-tinyfiledialogs.c
"                                strcat( lDialogString , "" "" ) ;
                        }
                        strcat( lDialogString , ""' --file-filter='All files | *'"" ) ;
                }
                if (tinyfd_silent) strcat( lDialogString , "" 2>/dev/null "");
",1,unused,6343,unused,"                                strcat( lDialogString , "" "" ) ;
                        }
                        strcat( lDialogString , ""' --file-filter='All files | *'"" ) ;
                }
                if (tinyfd_silent) strcat( lDialogString , "" 2>/dev/null "");
",unused,samhocevar_fork-tinyfiledialogs-tinyfiledialogs.c
"                        strcat(lDialogString, "" --filename=\"""") ;
                        strcat(lDialogString, aDefaultPath) ;
                        strcat(lDialogString, ""\"""") ;
                }
                if (tinyfd_silent) strcat( lDialogString , "" 2>/dev/null "");
",1,unused,6717,unused,"                        strcat(lDialogString, "" --filename=\"""") ;
                        strcat(lDialogString, aDefaultPath) ;
                        strcat(lDialogString, ""\"""") ;
                }
                if (tinyfd_silent) strcat( lDialogString , "" 2>/dev/null "");
",unused,samhocevar_fork-tinyfiledialogs-tinyfiledialogs.c
"                        strcat(lDialogString, "" --title=\"""") ;
                        strcat(lDialogString, aTitle) ;
                        strcat(lDialogString, ""\"""") ;
                }
                if (tinyfd_silent) strcat( lDialogString , "" 2>/dev/null "");
",1,unused,7010,unused,"                        strcat(lDialogString, "" --title=\"""") ;
                        strcat(lDialogString, aTitle) ;
                        strcat(lDialogString, ""\"""") ;
                }
                if (tinyfd_silent) strcat( lDialogString , "" 2>/dev/null "");
",unused,samhocevar_fork-tinyfiledialogs-tinyfiledialogs.c
"                {
                        strcat(lTerminalName , "" -e "" ) ;
                        strcat(lTerminalName , lShellName ) ;
                }
                else if ( strcpy(lTerminalName,""gnome-terminal"")
",1,unused,3479,unused,"                {
                        strcat(lTerminalName , "" -e "" ) ;
                        strcat(lTerminalName , lShellName ) ;
                }
                else if ( strcpy(lTerminalName,""gnome-terminal"")
",unused,samhocevar_fork-tinyfiledialogs-tinyfiledialogs.c
"static void
make_clone(xen_interface_t* xen, domid_t* cloneID, uint16_t vlan, char** clone_name)
{
    char* command = g_malloc0(snprintf(NULL, 0, CLONE_CMD, clone_script, domain_name, vlan, domain_config) + 1);
    sprintf(command, CLONE_CMD, clone_script, domain_name, vlan, domain_config);
",1,unused,168,unused,"static void
make_clone(xen_interface_t* xen, domid_t* cloneID, uint16_t vlan, char** clone_name)
{
    char* command = g_malloc0(snprintf(NULL, 0, CLONE_CMD, clone_script, domain_name, vlan, domain_config) + 1);
    sprintf(command, CLONE_CMD, clone_script, domain_name, vlan, domain_config);
",unused,skvl-drakvuf-src2Fdirwatch2Fdirwatch.c
"gpointer tcpdump(gpointer data)
{
    struct start_drakvuf* start = (struct start_drakvuf*)data;
    char* command = g_malloc0(snprintf(NULL, 0, TCPDUMP_CMD, tcpdump_script, start->threadid+1, run_folder, start->input, out_folder, start->utime) + 1);
    sprintf(command, TCPDUMP_CMD, tcpdump_script, start->threadid+1, run_folder, start->input, out_folder, start->utime);
",1,unused,183,unused,"gpointer tcpdump(gpointer data)
{
    struct start_drakvuf* start = (struct start_drakvuf*)data;
    char* command = g_malloc0(snprintf(NULL, 0, TCPDUMP_CMD, tcpdump_script, start->threadid+1, run_folder, start->input, out_folder, start->utime) + 1);
    sprintf(command, TCPDUMP_CMD, tcpdump_script, start->threadid+1, run_folder, start->input, out_folder, start->utime);
",unused,skvl-drakvuf-src2Fdirwatch2Fdirwatch.c
"
static inline void cleanup(domid_t cloneID, int vlan)
{
    char* command = g_malloc0(snprintf(NULL, 0, CLEANUP_CMD, cleanup_script, cloneID, vlan) + 1);
    sprintf(command, CLEANUP_CMD, cleanup_script, cloneID, vlan);
",1,unused,204,unused,"
static inline void cleanup(domid_t cloneID, int vlan)
{
    char* command = g_malloc0(snprintf(NULL, 0, CLEANUP_CMD, cleanup_script, cloneID, vlan) + 1);
    sprintf(command, CLEANUP_CMD, cleanup_script, cloneID, vlan);
",unused,skvl-drakvuf-src2Fdirwatch2Fdirwatch.c
"    g_mutex_lock(&start->timer_lock);
    timer = g_thread_new(""timer"", timer_thread, start);

    command = g_malloc0(snprintf(NULL, 0, CONFIG_CMD, config_script, rekall_profile, start->cloneID, injection_pid, start->threadid+1, run_folder, start->input, out_folder, start->utime) + 1);
    sprintf(command, CONFIG_CMD, config_script, rekall_profile, start->cloneID, injection_pid, start->threadid+1, run_folder, start->input, out_folder, start->utime);
",1,unused,308,unused,"    g_mutex_lock(&start->timer_lock);
    timer = g_thread_new(""timer"", timer_thread, start);

    command = g_malloc0(snprintf(NULL, 0, CONFIG_CMD, config_script, rekall_profile, start->cloneID, injection_pid, start->threadid+1, run_folder, start->input, out_folder, start->utime) + 1);
    sprintf(command, CONFIG_CMD, config_script, rekall_profile, start->cloneID, injection_pid, start->threadid+1, run_folder, start->input, out_folder, start->utime);
",unused,skvl-drakvuf-src2Fdirwatch2Fdirwatch.c
"    g_mutex_lock(&start->timer_lock);
    timer = g_thread_new(""timer"", timer_thread, start);

    command = g_malloc0(snprintf(NULL, 0, DRAKVUF_CMD, drakvuf_script, rekall_profile, start->cloneID, injection_pid, start->threadid+1, run_folder, start->input, out_folder, start->utime) + 1);
    sprintf(command, DRAKVUF_CMD, drakvuf_script, rekall_profile, start->cloneID, injection_pid, start->threadid+1, run_folder, start->input, out_folder, start->utime);
",1,unused,328,unused,"    g_mutex_lock(&start->timer_lock);
    timer = g_thread_new(""timer"", timer_thread, start);

    command = g_malloc0(snprintf(NULL, 0, DRAKVUF_CMD, drakvuf_script, rekall_profile, start->cloneID, injection_pid, start->threadid+1, run_folder, start->input, out_folder, start->utime) + 1);
    sprintf(command, DRAKVUF_CMD, drakvuf_script, rekall_profile, start->cloneID, injection_pid, start->threadid+1, run_folder, start->input, out_folder, start->utime);
",unused,skvl-drakvuf-src2Fdirwatch2Fdirwatch.c
"                if (!strcmp(ent->d_name, ""."") || !strcmp(ent->d_name, ""..""))
                    continue;

                char* command = g_malloc0(snprintf(NULL, 0, ""mv %s/%s %s/%s"", in_folder, ent->d_name, run_folder, ent->d_name) + 1);
                sprintf(command, ""mv %s/%s %s/%s"", in_folder, ent->d_name, run_folder, ent->d_name);
",1,unused,445,unused,"                if (!strcmp(ent->d_name, ""."") || !strcmp(ent->d_name, ""..""))
                    continue;

                char* command = g_malloc0(snprintf(NULL, 0, ""mv %s/%s %s/%s"", in_folder, ent->d_name, run_folder, ent->d_name) + 1);
                sprintf(command, ""mv %s/%s %s/%s"", in_folder, ent->d_name, run_folder, ent->d_name);
",unused,skvl-drakvuf-src2Fdirwatch2Fdirwatch.c
"                        DIR* q;
                        struct dirent* qent;

                        char* folder = g_malloc0(snprintf(NULL, 0, ""%s/%s"", queue_folder, qdent->d_name) + 1);
                        sprintf(folder, ""%s/%s"", queue_folder, qdent->d_name);
",1,unused,189,unused,"                        DIR* q;
                        struct dirent* qent;

                        char* folder = g_malloc0(snprintf(NULL, 0, ""%s/%s"", queue_folder, qdent->d_name) + 1);
                        sprintf(folder, ""%s/%s"", queue_folder, qdent->d_name);
",unused,skvl-drakvuf-src2Fdirwatch2Fdistributor.c
"
                        if ( count >= 0 && qsize >= 0 && qsize > count )
                        {
                            char* command = g_malloc0(snprintf(NULL, 0, ""mv %s/%s %s/%s/%s"", in_folder, inent->d_name, queue_folder, qdent->d_name, inent->d_name) + 1);
                            sprintf(command, ""mv %s/%s %s/%s/%s"", in_folder, inent->d_name, queue_folder, qdent->d_name, inent->d_name);
",1,unused,205,unused,"
                        if ( count >= 0 && qsize >= 0 && qsize > count )
                        {
                            char* command = g_malloc0(snprintf(NULL, 0, ""mv %s/%s %s/%s/%s"", in_folder, inent->d_name, queue_folder, qdent->d_name, inent->d_name) + 1);
                            sprintf(command, ""mv %s/%s %s/%s/%s"", in_folder, inent->d_name, queue_folder, qdent->d_name, inent->d_name);
",unused,skvl-drakvuf-src2Fdirwatch2Fdistributor.c
"                *buf_ret = 0 ;

                for ( iterator = key_path_list; iterator ; iterator = iterator->next )
                {
                    strcat( buf_ret, ""\\"" );
",1,unused,228,unused,"                *buf_ret = 0 ;

                for ( iterator = key_path_list; iterator ; iterator = iterator->next )
                {
                    strcat( buf_ret, ""\\"" );
",unused,skvl-drakvuf-src2Flibdrakvuf2Fwin-registry.c
"
                for ( iterator = key_path_list; iterator ; iterator = iterator->next )
                {
                    strcat( buf_ret, ""\\"" );
                    strcat( buf_ret, (char*)iterator->data );
",1,unused,229,unused,"
                for ( iterator = key_path_list; iterator ; iterator = iterator->next )
                {
                    strcat( buf_ret, ""\\"" );
                    strcat( buf_ret, (char*)iterator->data );
",unused,skvl-drakvuf-src2Flibdrakvuf2Fwin-registry.c
"        break;
      }
      case 'p': {
        char buff[4*sizeof(void *) + 8]; /* should be enough space for a `%p' */
        sprintf(buff, ""%p"", va_arg(argp, void *));
",1,unused,145,unused,"        break;
      }
      case 'p': {
        char buff[4*sizeof(void *) + 8]; /* should be enough space for a `%p' */
        sprintf(buff, ""%p"", va_arg(argp, void *));
",unused,spring-AI2FSkirmish2FShard2Flib2Flua2Flobject.c
"      size_t l;
      source++;  /* skip the `@' */
      bufflen -= sizeof("" '...' "");
      l = strlen(source);
      strcpy(out, """");
",1,unused,193,unused,"      size_t l;
      source++;  /* skip the `@' */
      bufflen -= sizeof("" '...' "");
      l = strlen(source);
      strcpy(out, """");
",unused,spring-AI2FSkirmish2FShard2Flib2Flua2Flobject.c
"      l = strlen(source);
      strcpy(out, """");
      if (l > bufflen) {
        source += (l-bufflen);  /* get last part of file name */
        strcat(out, ""..."");
",1,unused,196,unused,"      l = strlen(source);
      strcpy(out, """");
      if (l > bufflen) {
        source += (l-bufflen);  /* get last part of file name */
        strcat(out, ""..."");
",unused,spring-AI2FSkirmish2FShard2Flib2Flua2Flobject.c
"      if (l > bufflen) {
        source += (l-bufflen);  /* get last part of file name */
        strcat(out, ""..."");
      }
      strcat(out, source);
",1,unused,198,unused,"      if (l > bufflen) {
        source += (l-bufflen);  /* get last part of file name */
        strcat(out, ""..."");
      }
      strcat(out, source);
",unused,spring-AI2FSkirmish2FShard2Flib2Flua2Flobject.c
"    else {  /* out = [string ""string""] */
      size_t len = strcspn(source, ""\n\r"");  /* stop at first newline */
      bufflen -= sizeof("" [string \""...\""] "");
      if (len > bufflen) len = bufflen;
      strcpy(out, ""[string \"""");
",1,unused,204,unused,"    else {  /* out = [string ""string""] */
      size_t len = strcspn(source, ""\n\r"");  /* stop at first newline */
      bufflen -= sizeof("" [string \""...\""] "");
      if (len > bufflen) len = bufflen;
      strcpy(out, ""[string \"""");
",unused,spring-AI2FSkirmish2FShard2Flib2Flua2Flobject.c
"      if (len > bufflen) len = bufflen;
      strcpy(out, ""[string \"""");
      if (source[len] != '\0') {  /* must truncate? */
        strncat(out, source, len);
        strcat(out, ""..."");
",1,unused,207,unused,"      if (len > bufflen) len = bufflen;
      strcpy(out, ""[string \"""");
      if (source[len] != '\0') {  /* must truncate? */
        strncat(out, source, len);
        strcat(out, ""..."");
",unused,spring-AI2FSkirmish2FShard2Flib2Flua2Flobject.c
"        strncat(out, source, len);
        strcat(out, ""..."");
      }
      else
        strcat(out, source);
",1,unused,210,unused,"        strncat(out, source, len);
        strcat(out, ""..."");
      }
      else
        strcat(out, source);
",unused,spring-AI2FSkirmish2FShard2Flib2Flua2Flobject.c
"        strcat(out, ""..."");
      }
      else
        strcat(out, source);
      strcat(out, ""\""]"");
",1,unused,211,unused,"        strcat(out, ""..."");
      }
      else
        strcat(out, source);
      strcat(out, ""\""]"");
",unused,spring-AI2FSkirmish2FShard2Flib2Flua2Flobject.c
"
static void addintlen (char *form) {
  size_t l = strlen(form);
  char spec = form[l - 1];
  strcpy(form + l - 1, LUA_INTFRMLEN);
",1,unused,750,unused,"
static void addintlen (char *form) {
  size_t l = strlen(form);
  char spec = form[l - 1];
  strcpy(form + l - 1, LUA_INTFRMLEN);
",unused,spring-AI2FSkirmish2FShard2Flib2Flua2Flstrlib.c
"        luaL_argerror(L, arg, ""no value"");
      strfrmt = scanformat(L, strfrmt, form);
      switch (*strfrmt++) {
        case 'c': {
          sprintf(buff, form, (int)luaL_checknumber(L, arg));
",1,unused,777,unused,"        luaL_argerror(L, arg, ""no value"");
      strfrmt = scanformat(L, strfrmt, form);
      switch (*strfrmt++) {
        case 'c': {
          sprintf(buff, form, (int)luaL_checknumber(L, arg));
",unused,spring-AI2FSkirmish2FShard2Flib2Flua2Flstrlib.c
"          break;
        }
        case 'd':  case 'i': {
          addintlen(form);
          sprintf(buff, form, (LUA_INTFRM_T)luaL_checknumber(L, arg));
",1,unused,782,unused,"          break;
        }
        case 'd':  case 'i': {
          addintlen(form);
          sprintf(buff, form, (LUA_INTFRM_T)luaL_checknumber(L, arg));
",unused,spring-AI2FSkirmish2FShard2Flib2Flua2Flstrlib.c
"          break;
        }
        case 'o':  case 'u':  case 'x':  case 'X': {
          addintlen(form);
          sprintf(buff, form, (unsigned LUA_INTFRM_T)luaL_checknumber(L, arg));
",1,unused,787,unused,"          break;
        }
        case 'o':  case 'u':  case 'x':  case 'X': {
          addintlen(form);
          sprintf(buff, form, (unsigned LUA_INTFRM_T)luaL_checknumber(L, arg));
",unused,spring-AI2FSkirmish2FShard2Flib2Flua2Flstrlib.c
"          break;
        }
        case 'e':  case 'E': case 'f':
        case 'g': case 'G': {
          sprintf(buff, form, (double)luaL_checknumber(L, arg));
",1,unused,792,unused,"          break;
        }
        case 'e':  case 'E': case 'f':
        case 'g': case 'G': {
          sprintf(buff, form, (double)luaL_checknumber(L, arg));
",unused,spring-AI2FSkirmish2FShard2Flib2Flua2Flstrlib.c
"            luaL_addvalue(&b);
            continue;  /* skip the `addsize' at the end */
          }
          else {
            sprintf(buff, form, s);
",1,unused,810,unused,"            luaL_addvalue(&b);
            continue;  /* skip the `addsize' at the end */
          }
          else {
            sprintf(buff, form, s);
",unused,spring-AI2FSkirmish2FShard2Flib2Flua2Flstrlib.c
"  if( *paz==0 ){
    fprintf(stderr,""out of memory\n"");
    exit(1);
  }
  strcpy(*paz, z);
",1,unused,1370,unused,"  if( *paz==0 ){
    fprintf(stderr,""out of memory\n"");
    exit(1);
  }
  strcpy(*paz, z);
",unused,sqlite-3.8.2-tool2Flemon.c
"  user_templatename = (char *) malloc( lemonStrlen(z)+1 );
  if( user_templatename==0 ){
    memory_error();
  }
  strcpy(user_templatename, z);
",1,unused,1381,unused,"  user_templatename = (char *) malloc( lemonStrlen(z)+1 );
  if( user_templatename==0 ){
    memory_error();
  }
  strcpy(user_templatename, z);
",unused,sqlite-3.8.2-tool2Flemon.c
"        if( addLineMacro ){
          for(z=psp->filename, nBack=0; *z; z++){
            if( *z=='\\' ) nBack++;
          }
          sprintf(zLine, ""#line %d "", psp->tokenlineno);
",1,unused,2350,unused,"        if( addLineMacro ){
          for(z=psp->filename, nBack=0; *z; z++){
            if( *z=='\\' ) nBack++;
          }
          sprintf(zLine, ""#line %d "", psp->tokenlineno);
",unused,sqlite-3.8.2-tool2Flemon.c
"  if( name==0 ){
    fprintf(stderr,""Can't allocate space for a filename.\n"");
    exit(1);
  }
  strcpy(name,lemp->filename);
",1,unused,2719,unused,"  if( name==0 ){
    fprintf(stderr,""Can't allocate space for a filename.\n"");
    exit(1);
  }
  strcpy(name,lemp->filename);
",unused,sqlite-3.8.2-tool2Flemon.c
"  }
  strcpy(name,lemp->filename);
  cp = strrchr(name,'.');
  if( cp ) *cp = 0;
  strcat(name,suffix);
",1,unused,2722,unused,"  }
  strcpy(name,lemp->filename);
  cp = strrchr(name,'.');
  if( cp ) *cp = 0;
  strcat(name,suffix);
",unused,sqlite-3.8.2-tool2Flemon.c
"    else                  cfp=stp->cfp;
    while( cfp ){
      char buf[20];
      if( cfp->dot==cfp->rp->nrhs ){
        sprintf(buf,""(%d)"",cfp->rp->index);
",1,unused,2919,unused,"    else                  cfp=stp->cfp;
    while( cfp ){
      char buf[20];
      if( cfp->dot==cfp->rp->nrhs ){
        sprintf(buf,""(%d)"",cfp->rp->index);
",unused,sqlite-3.8.2-tool2Flemon.c
"  if( cp ){
    c = *cp;
    *cp = 0;
    path = (char *)malloc( lemonStrlen(argv0) + lemonStrlen(name) + 2 );
    if( path ) sprintf(path,""%s/%s"",argv0,name);
",1,unused,2984,unused,"  if( cp ){
    c = *cp;
    *cp = 0;
    path = (char *)malloc( lemonStrlen(argv0) + lemonStrlen(name) + 2 );
    if( path ) sprintf(path,""%s/%s"",argv0,name);
",unused,sqlite-3.8.2-tool2Flemon.c
"    pathbuf = (char *) malloc( lemonStrlen(pathlist) + 1 );
    path = (char *)malloc( lemonStrlen(pathlist)+lemonStrlen(name)+2 );
    if( (pathbuf != 0) && (path!=0) ){
      pathbufptr = pathbuf;
      strcpy(pathbuf, pathlist);
",1,unused,2993,unused,"    pathbuf = (char *) malloc( lemonStrlen(pathlist) + 1 );
    path = (char *)malloc( lemonStrlen(pathlist)+lemonStrlen(name)+2 );
    if( (pathbuf != 0) && (path!=0) ){
      pathbufptr = pathbuf;
      strcpy(pathbuf, pathlist);
",unused,sqlite-3.8.2-tool2Flemon.c
"        cp = strchr(pathbuf,':');
        if( cp==0 ) cp = &pathbuf[lemonStrlen(pathbuf)];
        c = *cp;
        *cp = 0;
        sprintf(path,""%s/%s"",pathbuf,name);
",1,unused,2999,unused,"        cp = strchr(pathbuf,':');
        if( cp==0 ) cp = &pathbuf[lemonStrlen(pathbuf)];
        c = *cp;
        *cp = 0;
        sprintf(path,""%s/%s"",pathbuf,name);
",unused,sqlite-3.8.2-tool2Flemon.c
"  }

  cp = strrchr(lemp->filename,'.');
  if( cp ){
    sprintf(buf,""%.*s.lt"",(int)(cp-lemp->filename),lemp->filename);
",1,unused,3090,unused,"  }

  cp = strrchr(lemp->filename,'.');
  if( cp ){
    sprintf(buf,""%.*s.lt"",(int)(cp-lemp->filename),lemp->filename);
",unused,sqlite-3.8.2-tool2Flemon.c
"  cp = strrchr(lemp->filename,'.');
  if( cp ){
    sprintf(buf,""%.*s.lt"",(int)(cp-lemp->filename),lemp->filename);
  }else{
    sprintf(buf,""%s.lt"",lemp->filename);
",1,unused,3092,unused,"  cp = strrchr(lemp->filename,'.');
  if( cp ){
    sprintf(buf,""%.*s.lt"",(int)(cp-lemp->filename),lemp->filename);
  }else{
    sprintf(buf,""%s.lt"",lemp->filename);
",unused,sqlite-3.8.2-tool2Flemon.c
"  if( z==0 ) return empty;
  while( n-- > 0 ){
    c = *(zText++);
    if( c=='%' && n>0 && zText[0]=='d' ){
      sprintf(zInt, ""%d"", p1);
",1,unused,3243,unused,"  if( z==0 ) return empty;
  while( n-- > 0 ){
    c = *(zText++);
    if( c=='%' && n>0 && zText[0]=='d' ){
      sprintf(zInt, ""%d"", p1);
",unused,sqlite-3.8.2-tool2Flemon.c
"    c = *(zText++);
    if( c=='%' && n>0 && zText[0]=='d' ){
      sprintf(zInt, ""%d"", p1);
      p1 = p2;
      strcpy(&z[used], zInt);
",1,unused,3245,unused,"    c = *(zText++);
    if( c=='%' && n>0 && zText[0]=='d' ){
      sprintf(zInt, ""%d"", p1);
      p1 = p2;
      strcpy(&z[used], zInt);
",unused,sqlite-3.8.2-tool2Flemon.c
"      if( types[hash]==0 ){
        fprintf(stderr,""Out of memory.\n"");
        exit(1);
      }
      strcpy(types[hash],stddt);
",1,unused,3470,unused,"      if( types[hash]==0 ){
        fprintf(stderr,""Out of memory.\n"");
        exit(1);
      }
      strcpy(types[hash],stddt);
",unused,sqlite-3.8.2-tool2Flemon.c
"
  /* Generate a table containing the symbolic name of every symbol
  */
  for(i=0; i<lemp->nsymbol; i++){
    sprintf(line,""\""%s\"","",lemp->symbols[i]->name);
",1,unused,3859,unused,"
  /* Generate a table containing the symbolic name of every symbol
  */
  for(i=0; i<lemp->nsymbol; i++){
    sprintf(line,""\""%s\"","",lemp->symbols[i]->name);
",unused,sqlite-3.8.2-tool2Flemon.c
"  in = file_open(lemp,"".h"",""rb"");
  if( in ){
    int nextChar;
    for(i=1; i<lemp->nterminal && fgets(line,LINESIZE,in); i++){
      sprintf(pattern,""#define %s%-30s %2d\n"",prefix,lemp->symbols[i]->name,i);
",1,unused,4026,unused,"  in = file_open(lemp,"".h"",""rb"");
  if( in ){
    int nextChar;
    for(i=1; i<lemp->nterminal && fgets(line,LINESIZE,in); i++){
      sprintf(pattern,""#define %s%-30s %2d\n"",prefix,lemp->symbols[i]->name,i);
",unused,sqlite-3.8.2-tool2Flemon.c
"
  if( y==0 ) return 0;
  z = Strsafe_find(y);
  if( z==0 && (cpy=(char *)malloc( lemonStrlen(y)+1 ))!=0 ){
    strcpy(cpy,y);
",1,unused,4256,unused,"
  if( y==0 ) return 0;
  z = Strsafe_find(y);
  if( z==0 && (cpy=(char *)malloc( lemonStrlen(y)+1 ))!=0 ){
    strcpy(cpy,y);
",unused,sqlite-3.8.2-tool2Flemon.c
"  for(i=0; i<nKeyword; i++){
    Keyword *p = &aKeywordTable[i];
    p->len = (int)strlen(p->zName);
    assert( p->len<sizeof(p->zOrigName) );
    strcpy(p->zOrigName, p->zName);
",1,unused,366,unused,"  for(i=0; i<nKeyword; i++){
    Keyword *p = &aKeywordTable[i];
    p->len = (int)strlen(p->zName);
    assert( p->len<sizeof(p->zOrigName) );
    strcpy(p->zOrigName, p->zName);
",unused,sqlite-3.8.2-tool2Fmkkeywordhash.c
"		fatal_CL(error, __LINE__);

  char clOptions[150];
//  sprintf(clOptions,""-I../../src"");                                                    
  sprintf(clOptions,""-I."");
",1,unused,195,unused,"		fatal_CL(error, __LINE__);

  char clOptions[150];
//  sprintf(clOptions,""-I../../src"");                                                    
  sprintf(clOptions,""-I."");
",unused,srad_opencl-kernel2Fkernel_gpu_opencl_wrapper.c
"main(int argc, char **argv)
{	int i, g;
	char *a, *s;
	fmsg = stderr;
	strcpy(filename, ""<stdin>"");
",1,unused,103,unused,"main(int argc, char **argv)
{	int i, g;
	char *a, *s;
	fmsg = stderr;
	strcpy(filename, ""<stdin>"");
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsoapcpp2.c
"					case 'd':
						a++;
						g = 0;
						if (*a)
							strcpy(dirpath, a);
",1,unused,126,unused,"					case 'd':
						a++;
						g = 0;
						if (*a)
							strcpy(dirpath, a);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsoapcpp2.c
"						g = 0;
						if (*a)
							strcpy(dirpath, a);
						else if (i < argc && argv[++i])
							strcpy(dirpath, argv[i]);
",1,unused,128,unused,"						g = 0;
						if (*a)
							strcpy(dirpath, a);
						else if (i < argc && argv[++i])
							strcpy(dirpath, argv[i]);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsoapcpp2.c
"							strcpy(dirpath, argv[i]);
						else
							execerror(""Option -d requires a directory path"");
						if (*dirpath && dirpath[strlen(dirpath)-1] != '/' && dirpath[strlen(dirpath)-1] != '\\')
							strcat(dirpath, SOAP_PATHCAT);
",1,unused,132,unused,"							strcpy(dirpath, argv[i]);
						else
							execerror(""Option -d requires a directory path"");
						if (*dirpath && dirpath[strlen(dirpath)-1] != '/' && dirpath[strlen(dirpath)-1] != '\\')
							strcat(dirpath, SOAP_PATHCAT);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsoapcpp2.c
"						else
							execerror(""Option -I requires an import path"");
						if (importpath && s)
						{	char *t	= emalloc(strlen(importpath) + strlen(s) + 2);
							strcpy(t, importpath);
",1,unused,186,unused,"						else
							execerror(""Option -I requires an import path"");
						if (importpath && s)
						{	char *t	= emalloc(strlen(importpath) + strlen(s) + 2);
							strcpy(t, importpath);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsoapcpp2.c
"							execerror(""Option -I requires an import path"");
						if (importpath && s)
						{	char *t	= emalloc(strlen(importpath) + strlen(s) + 2);
							strcpy(t, importpath);
							strcat(t, SOAP_PATHSEP);
",1,unused,187,unused,"							execerror(""Option -I requires an import path"");
						if (importpath && s)
						{	char *t	= emalloc(strlen(importpath) + strlen(s) + 2);
							strcpy(t, importpath);
							strcat(t, SOAP_PATHSEP);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsoapcpp2.c
"						if (importpath && s)
						{	char *t	= emalloc(strlen(importpath) + strlen(s) + 2);
							strcpy(t, importpath);
							strcat(t, SOAP_PATHSEP);
							strcat(t, s);
",1,unused,188,unused,"						if (importpath && s)
						{	char *t	= emalloc(strlen(importpath) + strlen(s) + 2);
							strcpy(t, importpath);
							strcat(t, SOAP_PATHSEP);
							strcat(t, s);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsoapcpp2.c
"            					exit(1);
				}
		}
		else if (!(yyin = fopen(argv[i], ""r"")))
		{	sprintf(errbuf, ""Cannot open file \""%s\"" for reading"", argv[i]);
",1,unused,269,unused,"            					exit(1);
				}
		}
		else if (!(yyin = fopen(argv[i], ""r"")))
		{	sprintf(errbuf, ""Cannot open file \""%s\"" for reading"", argv[i]);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsoapcpp2.c
"		{	sprintf(errbuf, ""Cannot open file \""%s\"" for reading"", argv[i]);
			execerror(errbuf);
		}
		else
			strcpy(filename, argv[i]);
",1,unused,273,unused,"		{	sprintf(errbuf, ""Cannot open file \""%s\"" for reading"", argv[i]);
			execerror(errbuf);
		}
		else
			strcpy(filename, argv[i]);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsoapcpp2.c
"			  s = strchr(yytext, '""');
			  if (!s)
			    t = yytext+7;
			  else
			  { strcpy(buf, s+1);
",1,unused,1241,unused,"			  s = strchr(yytext, '""');
			  if (!s)
			    t = yytext+7;
			  else
			  { strcpy(buf, s+1);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsoapcpp2_lex.c
"#line 164 ""soapcpp2_lex.l""
{ char *s, buf[1024];
			  s = strchr(yytext, '""');
			  if (s)
			  { strcpy(buf, s+1);
",1,unused,1262,unused,"#line 164 ""soapcpp2_lex.l""
{ char *s, buf[1024];
			  s = strchr(yytext, '""');
			  if (s)
			  { strcpy(buf, s+1);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsoapcpp2_lex.c
"			    yyterminate();
			  else
			  { yy_delete_buffer(YY_CURRENT_BUFFER);
			    yy_switch_to_buffer(instk[imports]);
			    strcpy(filename, fnstk[imports]);
",1,unused,1303,unused,"			    yyterminate();
			  else
			  { yy_delete_buffer(YY_CURRENT_BUFFER);
			    yy_switch_to_buffer(instk[imports]);
			    strcpy(filename, fnstk[imports]);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsoapcpp2_lex.c
"		s++;
	if ((s[0] == 'x' || s[0] == 'X')
	 && (s[1] == 'm' || s[1] == 'M')
	 && (s[2] == 'l' || s[2] == 'L'))
	{	sprintf(errbuf, ""identifier '%s' starts with or embeds '%3.3s' character sequence exclusively reserved for the XML standard (for enum constants: please ignore this warning)"", yytext, s);
",1,unused,2336,unused,"		s++;
	if ((s[0] == 'x' || s[0] == 'X')
	 && (s[1] == 'm' || s[1] == 'M')
	 && (s[2] == 'l' || s[2] == 'L'))
	{	sprintf(errbuf, ""identifier '%s' starts with or embeds '%3.3s' character sequence exclusively reserved for the XML standard (for enum constants: please ignore this warning)"", yytext, s);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsoapcpp2_lex.c
"			sp->transport = s;
		else if (!strncmp(yytext+i, ""location:"", 9) || !strncmp(yytext+i, ""port:"", 5))
		{	if (sp->URL)
			{	char *t = (char*)emalloc(strlen(sp->URL) + strlen(s) + 2);
				strcpy(t, sp->URL);
",1,unused,2530,unused,"			sp->transport = s;
		else if (!strncmp(yytext+i, ""location:"", 9) || !strncmp(yytext+i, ""port:"", 5))
		{	if (sp->URL)
			{	char *t = (char*)emalloc(strlen(sp->URL) + strlen(s) + 2);
				strcpy(t, sp->URL);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsoapcpp2_lex.c
"		else if (!strncmp(yytext+i, ""location:"", 9) || !strncmp(yytext+i, ""port:"", 5))
		{	if (sp->URL)
			{	char *t = (char*)emalloc(strlen(sp->URL) + strlen(s) + 2);
				strcpy(t, sp->URL);
				strcat(t, "" "");
",1,unused,2531,unused,"		else if (!strncmp(yytext+i, ""location:"", 9) || !strncmp(yytext+i, ""port:"", 5))
		{	if (sp->URL)
			{	char *t = (char*)emalloc(strlen(sp->URL) + strlen(s) + 2);
				strcpy(t, sp->URL);
				strcat(t, "" "");
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsoapcpp2_lex.c
"		{	if (sp->URL)
			{	char *t = (char*)emalloc(strlen(sp->URL) + strlen(s) + 2);
				strcpy(t, sp->URL);
				strcat(t, "" "");
				strcat(t, s);
",1,unused,2532,unused,"		{	if (sp->URL)
			{	char *t = (char*)emalloc(strlen(sp->URL) + strlen(s) + 2);
				strcpy(t, sp->URL);
				strcat(t, "" "");
				strcat(t, s);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsoapcpp2_lex.c
"			s[k-j] = '\0';
			d->part = s;
		}
		else
                {	sprintf(errbuf, ""unrecognized gsoap directive: %s"", yytext+i);
",1,unused,2875,unused,"			s[k-j] = '\0';
			d->part = s;
		}
		else
                {	sprintf(errbuf, ""unrecognized gsoap directive: %s"", yytext+i);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsoapcpp2_lex.c
"			semwarn(errbuf);
		}
	}
	else
        {	sprintf(errbuf, ""unrecognized gsoap directive: %s"", yytext);
",1,unused,2880,unused,"			semwarn(errbuf);
		}
	}
	else
        {	sprintf(errbuf, ""unrecognized gsoap directive: %s"", yytext);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsoapcpp2_lex.c
"
static void option()
{	int i;
	if (imports)
        {	sprintf(errbuf, ""options directive: %s ignored in imported file(s)"", yytext);
",1,unused,2888,unused,"
static void option()
{	int i;
	if (imports)
        {	sprintf(errbuf, ""options directive: %s ignored in imported file(s)"", yytext);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsoapcpp2_lex.c
"    fullname = name;
  if (imports)
  { Pragma **pp;
    char *s = emalloc(strlen(fullname)+15);
    sprintf(s, ""#include \""%sH.h\"""", fullname);
",1,unused,2999,unused,"    fullname = name;
  if (imports)
  { Pragma **pp;
    char *s = emalloc(strlen(fullname)+15);
    sprintf(s, ""#include \""%sH.h\"""", fullname);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsoapcpp2_lex.c
"      (*pp)->pragma = s;
      (*pp)->next = NULL;
    }
    imported = (char*)emalloc(strlen(fullname)+1);
    strcpy(imported, fullname);
",1,unused,3009,unused,"      (*pp)->pragma = s;
      (*pp)->next = NULL;
    }
    imported = (char*)emalloc(strlen(fullname)+1);
    strcpy(imported, fullname);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsoapcpp2_lex.c
"  else
  { lflag = 1;
    typeNO = magic(name);
    prefix = (char*)emalloc(strlen(fullname)+1);
    strcpy(prefix, fullname);
",1,unused,3016,unused,"  else
  { lflag = 1;
    typeNO = magic(name);
    prefix = (char*)emalloc(strlen(fullname)+1);
    strcpy(prefix, fullname);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsoapcpp2_lex.c
"      return;
  if (imports >= MAX_IMPORT_DEPTH)
    execerror(""Imports nested too deep"");
  instk[imports] = YY_CURRENT_BUFFER;
  strcpy(fnstk[imports], filename);
",1,unused,3051,unused,"      return;
  if (imports >= MAX_IMPORT_DEPTH)
    execerror(""Imports nested too deep"");
  instk[imports] = YY_CURRENT_BUFFER;
  strcpy(fnstk[imports], filename);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsoapcpp2_lex.c
"	  buf[t - s] = '\0';
	  s = t + sizeof(SOAP_PATHSEP) - 1;
	}
	else
        { strcpy(buf, s);
",1,unused,3071,unused,"	  buf[t - s] = '\0';
	  s = t + sizeof(SOAP_PATHSEP) - 1;
	}
	else
        { strcpy(buf, s);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsoapcpp2_lex.c
"	else
        { strcpy(buf, s);
          s = NULL;
	}
        strcat(buf, ""/"");
",1,unused,3074,unused,"	else
        { strcpy(buf, s);
          s = NULL;
	}
        strcat(buf, ""/"");
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsoapcpp2_lex.c
"        { strcpy(buf, s);
          s = NULL;
	}
        strcat(buf, ""/"");
        strcat(buf, file);
",1,unused,3075,unused,"        { strcpy(buf, s);
          s = NULL;
	}
        strcat(buf, ""/"");
        strcat(buf, file);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsoapcpp2_lex.c
"      }
      while (s && !yyin);
    }
    if (!yyin)
    { sprintf(errbuf, ""#import: Cannot open file \""%s\"" for reading.\nHint: use option -I<path> (you can define multiple paths separated with '""SOAP_PATHSEP""')"", file);
",1,unused,3081,unused,"      }
      while (s && !yyin);
    }
    if (!yyin)
    { sprintf(errbuf, ""#import: Cannot open file \""%s\"" for reading.\nHint: use option -I<path> (you can define multiple paths separated with '""SOAP_PATHSEP""')"", file);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsoapcpp2_lex.c
"      execerror(errbuf);
    }
  }
  p = (struct importlist*)malloc(sizeof(struct importlist) + strlen(file)); /* has already + 1 byte size */
  strcpy(p->name, file);
",1,unused,3086,unused,"      execerror(errbuf);
    }
  }
  p = (struct importlist*)malloc(sizeof(struct importlist) + strlen(file)); /* has already + 1 byte size */
  strcpy(p->name, file);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsoapcpp2_lex.c
"  p = (struct importlist*)malloc(sizeof(struct importlist) + strlen(file)); /* has already + 1 byte size */
  strcpy(p->name, file);
  p->next = importlist;
  importlist = p;
  strcpy(filename, file);
",1,unused,3089,unused,"  p = (struct importlist*)malloc(sizeof(struct importlist) + strlen(file)); /* has already + 1 byte size */
  strcpy(p->name, file);
  p->next = importlist;
  importlist = p;
  strcpy(filename, file);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsoapcpp2_lex.c
"			  {	for (pp = &pragmas; *pp; pp = &(*pp)->next)
			          ;
				*pp = (Pragma*)emalloc(sizeof(Pragma));
				(*pp)->pragma = (char*)emalloc(strlen((yyvsp[0].s))+1);
				strcpy((*pp)->pragma, (yyvsp[0].s));
",1,unused,2015,unused,"			  {	for (pp = &pragmas; *pp; pp = &(*pp)->next)
			          ;
				*pp = (Pragma*)emalloc(sizeof(Pragma));
				(*pp)->pragma = (char*)emalloc(strlen((yyvsp[0].s))+1);
				strcpy((*pp)->pragma, (yyvsp[0].s));
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsoapcpp2_yacc.c
"			  }
			  else if ((i = atoi((yyvsp[0].s)+2)) > 0)
				yylineno = i;
			  else
			  {	sprintf(errbuf, ""directive '%s' ignored (use #import to import files and/or use option -i)"", (yyvsp[0].s));
",1,unused,2021,unused,"			  }
			  else if ((i = atoi((yyvsp[0].s)+2)) > 0)
				yylineno = i;
			  else
			  {	sprintf(errbuf, ""directive '%s' ignored (use #import to import files and/or use option -i)"", (yyvsp[0].s));
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsoapcpp2_yacc.c
"
  case 34:
#line 449 ""soapcpp2_yacc.y"" /* yacc.c:1646  */
    { if ((yyvsp[-1].rec).sto & Stypedef)
			  {	sprintf(errbuf, ""invalid typedef qualifier for '%s'"", (yyvsp[0].sym)->name);
",1,unused,2275,unused,"
  case 34:
#line 449 ""soapcpp2_yacc.y"" /* yacc.c:1646  */
    { if ((yyvsp[-1].rec).sto & Stypedef)
			  {	sprintf(errbuf, ""invalid typedef qualifier for '%s'"", (yyvsp[0].sym)->name);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsoapcpp2_yacc.c
"#line 505 ""soapcpp2_yacc.y"" /* yacc.c:1646  */
    { s1 = c_storage((yyvsp[0].rec).sto);
			  s2 = c_type((yyvsp[0].rec).typ);
			  s = (char*)emalloc(strlen(s1) + strlen(s2) + 10);
			  strcpy(s, ""operator "");
",1,unused,2531,unused,"#line 505 ""soapcpp2_yacc.y"" /* yacc.c:1646  */
    { s1 = c_storage((yyvsp[0].rec).sto);
			  s2 = c_type((yyvsp[0].rec).typ);
			  s = (char*)emalloc(strlen(s1) + strlen(s2) + 10);
			  strcpy(s, ""operator "");
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsoapcpp2_yacc.c
"    { s1 = c_storage((yyvsp[0].rec).sto);
			  s2 = c_type((yyvsp[0].rec).typ);
			  s = (char*)emalloc(strlen(s1) + strlen(s2) + 10);
			  strcpy(s, ""operator "");
			  strcat(s, s1);
",1,unused,2532,unused,"    { s1 = c_storage((yyvsp[0].rec).sto);
			  s2 = c_type((yyvsp[0].rec).typ);
			  s = (char*)emalloc(strlen(s1) + strlen(s2) + 10);
			  strcpy(s, ""operator "");
			  strcat(s, s1);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsoapcpp2_yacc.c
"			  s2 = c_type((yyvsp[0].rec).typ);
			  s = (char*)emalloc(strlen(s1) + strlen(s2) + 10);
			  strcpy(s, ""operator "");
			  strcat(s, s1);
			  strcat(s, s2);
",1,unused,2533,unused,"			  s2 = c_type((yyvsp[0].rec).typ);
			  s = (char*)emalloc(strlen(s1) + strlen(s2) + 10);
			  strcpy(s, ""operator "");
			  strcat(s, s1);
			  strcat(s, s2);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsoapcpp2_yacc.c
"#line 527 ""soapcpp2_yacc.y"" /* yacc.c:1646  */
    { if (!(p = entry(classtable, (yyvsp[0].sym))))
			  	semerror(""invalid destructor"");
			  s = (char*)emalloc(strlen((yyvsp[0].sym)->name) + 2);
			  strcpy(s, ""~"");
",1,unused,2560,unused,"#line 527 ""soapcpp2_yacc.y"" /* yacc.c:1646  */
    { if (!(p = entry(classtable, (yyvsp[0].sym))))
			  	semerror(""invalid destructor"");
			  s = (char*)emalloc(strlen((yyvsp[0].sym)->name) + 2);
			  strcpy(s, ""~"");
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsoapcpp2_yacc.c
"    { if (!(p = entry(classtable, (yyvsp[0].sym))))
			  	semerror(""invalid destructor"");
			  s = (char*)emalloc(strlen((yyvsp[0].sym)->name) + 2);
			  strcpy(s, ""~"");
			  strcat(s, (yyvsp[0].sym)->name);
",1,unused,2561,unused,"    { if (!(p = entry(classtable, (yyvsp[0].sym))))
			  	semerror(""invalid destructor"");
			  s = (char*)emalloc(strlen((yyvsp[0].sym)->name) + 2);
			  strcpy(s, ""~"");
			  strcat(s, (yyvsp[0].sym)->name);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsoapcpp2_yacc.c
"  case 77:
#line 544 ""soapcpp2_yacc.y"" /* yacc.c:1646  */
    { if ((yyvsp[-6].e)->level == GLOBAL)
			  {	if (!((yyvsp[-6].e)->info.sto & Sextern) && sp->entry && sp->entry->info.typ->type == Tpointer && ((Tnode*)sp->entry->info.typ->ref)->type == Tchar)
			  	{	sprintf(errbuf, ""last output parameter of remote method function prototype '%s' is a pointer to a char which will only return one byte: use char** instead to return a string"", (yyvsp[-6].e)->sym->name);
",1,unused,2579,unused,"  case 77:
#line 544 ""soapcpp2_yacc.y"" /* yacc.c:1646  */
    { if ((yyvsp[-6].e)->level == GLOBAL)
			  {	if (!((yyvsp[-6].e)->info.sto & Sextern) && sp->entry && sp->entry->info.typ->type == Tpointer && ((Tnode*)sp->entry->info.typ->ref)->type == Tchar)
			  	{	sprintf(errbuf, ""last output parameter of remote method function prototype '%s' is a pointer to a char which will only return one byte: use char** instead to return a string"", (yyvsp[-6].e)->sym->name);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsoapcpp2_yacc.c
"								add_result(sp->entry->info.typ);
						}
					}
					else
					{	sprintf(errbuf, ""return type of remote method function prototype '%s' must be integer"", (yyvsp[-6].e)->sym->name);
",1,unused,2599,unused,"								add_result(sp->entry->info.typ);
						}
					}
					else
					{	sprintf(errbuf, ""return type of remote method function prototype '%s' must be integer"", (yyvsp[-6].e)->sym->name);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsoapcpp2_yacc.c
"						semerror(errbuf);
					}
				}
			  	else
			  	{	sprintf(errbuf, ""last output parameter of remote method function prototype '%s' is a return parameter and must be a pointer or reference, or use %s(void) for no return parameter"", (yyvsp[-6].e)->sym->name, (yyvsp[-6].e)->sym->name);
",1,unused,2604,unused,"						semerror(errbuf);
					}
				}
			  	else
			  	{	sprintf(errbuf, ""last output parameter of remote method function prototype '%s' is a return parameter and must be a pointer or reference, or use %s(void) for no return parameter"", (yyvsp[-6].e)->sym->name, (yyvsp[-6].e)->sym->name);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsoapcpp2_yacc.c
"				if (!((yyvsp[-6].e)->info.sto & Sextern))
			  	{	unlinklast(sp->table);
			  		if ((p = entry(classtable, (yyvsp[-6].e)->sym)))
					{	if (p->info.typ->ref)
						{	sprintf(errbuf, ""remote method name clash: struct/class '%s' already declared at line %d"", (yyvsp[-6].e)->sym->name, p->lineno);
",1,unused,2611,unused,"				if (!((yyvsp[-6].e)->info.sto & Sextern))
			  	{	unlinklast(sp->table);
			  		if ((p = entry(classtable, (yyvsp[-6].e)->sym)))
					{	if (p->info.typ->ref)
						{	sprintf(errbuf, ""remote method name clash: struct/class '%s' already declared at line %d"", (yyvsp[-6].e)->sym->name, p->lineno);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsoapcpp2_yacc.c
"
  case 85:
#line 695 ""soapcpp2_yacc.y"" /* yacc.c:1646  */
    { if (vflag != 1 && *(yyvsp[0].sym)->name == '_' && sp->table->level == GLOBAL)
			  { sprintf(errbuf, ""SOAP 1.2 does not support anonymous parameters '%s'"", (yyvsp[0].sym)->name);
",1,unused,2763,unused,"
  case 85:
#line 695 ""soapcpp2_yacc.y"" /* yacc.c:1646  */
    { if (vflag != 1 && *(yyvsp[0].sym)->name == '_' && sp->table->level == GLOBAL)
			  { sprintf(errbuf, ""SOAP 1.2 does not support anonymous parameters '%s'"", (yyvsp[0].sym)->name);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsoapcpp2_yacc.c
"
  case 115:
#line 871 ""soapcpp2_yacc.y"" /* yacc.c:1646  */
    { sym = gensym(""_Struct"");
			  sprintf(errbuf, ""anonymous class will be named '%s'"", sym->name);
",1,unused,3073,unused,"
  case 115:
#line 871 ""soapcpp2_yacc.y"" /* yacc.c:1646  */
    { sym = gensym(""_Struct"");
			  sprintf(errbuf, ""anonymous class will be named '%s'"", sym->name);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsoapcpp2_yacc.c
"			  sprintf(errbuf, ""anonymous class will be named '%s'"", sym->name);
			  semwarn(errbuf);
			  if ((p = entry(classtable, sym)))
			  {	if (p->info.typ->ref || p->info.typ->type != Tclass)
				{	sprintf(errbuf, ""class '%s' already declared at line %d"", sym->name, p->lineno);
",1,unused,3077,unused,"			  sprintf(errbuf, ""anonymous class will be named '%s'"", sym->name);
			  semwarn(errbuf);
			  if ((p = entry(classtable, sym)))
			  {	if (p->info.typ->ref || p->info.typ->type != Tclass)
				{	sprintf(errbuf, ""class '%s' already declared at line %d"", sym->name, p->lineno);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsoapcpp2_yacc.c
"				semerror(""invalid base class"");
			  else
			  {	sp->table->prev = (Table*)(yyvsp[-4].e)->info.typ->ref;
				if (!sp->table->prev && !(yyvsp[-4].e)->info.typ->transient)
				{	sprintf(errbuf, ""class '%s' has incomplete type"", (yyvsp[-4].e)->sym->name);
",1,unused,3120,unused,"				semerror(""invalid base class"");
			  else
			  {	sp->table->prev = (Table*)(yyvsp[-4].e)->info.typ->ref;
				if (!sp->table->prev && !(yyvsp[-4].e)->info.typ->transient)
				{	sprintf(errbuf, ""class '%s' has incomplete type"", (yyvsp[-4].e)->sym->name);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsoapcpp2_yacc.c
"    { if (!(yyvsp[0].e))
				semerror(""invalid base class"");
			  else
			  {	if (!(yyvsp[0].e)->info.typ->ref && !(yyvsp[0].e)->info.typ->transient)
				{	sprintf(errbuf, ""class '%s' has incomplete type"", (yyvsp[0].e)->sym->name);
",1,unused,3148,unused,"    { if (!(yyvsp[0].e))
				semerror(""invalid base class"");
			  else
			  {	if (!(yyvsp[0].e)->info.typ->ref && !(yyvsp[0].e)->info.typ->transient)
				{	sprintf(errbuf, ""class '%s' has incomplete type"", (yyvsp[0].e)->sym->name);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsoapcpp2_yacc.c
"
  case 120:
#line 939 ""soapcpp2_yacc.y"" /* yacc.c:1646  */
    { sym = gensym(""_Struct"");
			  sprintf(errbuf, ""anonymous struct will be named '%s'"", sym->name);
",1,unused,3162,unused,"
  case 120:
#line 939 ""soapcpp2_yacc.y"" /* yacc.c:1646  */
    { sym = gensym(""_Struct"");
			  sprintf(errbuf, ""anonymous struct will be named '%s'"", sym->name);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsoapcpp2_yacc.c
"			  sprintf(errbuf, ""anonymous struct will be named '%s'"", sym->name);
			  semwarn(errbuf);
			  if ((p = entry(classtable, sym)))
			  {	if (p->info.typ->ref || p->info.typ->type != Tstruct)
				{	sprintf(errbuf, ""struct '%s' already declared at line %d"", sym->name, p->lineno);
",1,unused,3166,unused,"			  sprintf(errbuf, ""anonymous struct will be named '%s'"", sym->name);
			  semwarn(errbuf);
			  if ((p = entry(classtable, sym)))
			  {	if (p->info.typ->ref || p->info.typ->type != Tstruct)
				{	sprintf(errbuf, ""struct '%s' already declared at line %d"", sym->name, p->lineno);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsoapcpp2_yacc.c
"#line 961 ""soapcpp2_yacc.y"" /* yacc.c:1646  */
    { if ((p = entry(classtable, (yyvsp[-4].e)->sym)) && p->info.typ->ref)
			  {	if (is_mutable(p->info.typ))
			  	{	if (merge((Table*)p->info.typ->ref, sp->table))
					{	sprintf(errbuf, ""member name clash in struct '%s' declared at line %d"", (yyvsp[-4].e)->sym->name, p->lineno);
",1,unused,3190,unused,"#line 961 ""soapcpp2_yacc.y"" /* yacc.c:1646  */
    { if ((p = entry(classtable, (yyvsp[-4].e)->sym)) && p->info.typ->ref)
			  {	if (is_mutable(p->info.typ))
			  	{	if (merge((Table*)p->info.typ->ref, sp->table))
					{	sprintf(errbuf, ""member name clash in struct '%s' declared at line %d"", (yyvsp[-4].e)->sym->name, p->lineno);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsoapcpp2_yacc.c
"    { if ((p = entry(classtable, (yyvsp[0].sym))))
			  {	if (p->info.typ->type == Tstruct)
			  		(yyval.typ) = p->info.typ;
			  	else
				{	sprintf(errbuf, ""'struct %s' redeclaration (line %d)"", (yyvsp[0].sym)->name, p->lineno);
",1,unused,3214,unused,"    { if ((p = entry(classtable, (yyvsp[0].sym))))
			  {	if (p->info.typ->type == Tstruct)
			  		(yyval.typ) = p->info.typ;
			  	else
				{	sprintf(errbuf, ""'struct %s' redeclaration (line %d)"", (yyvsp[0].sym)->name, p->lineno);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsoapcpp2_yacc.c
"    { if ((p = entry(classtable, (yyvsp[0].sym))))
			  {	if (p->info.typ->type == Tstruct)
					(yyval.typ) = p->info.typ;
			  	else
				{	sprintf(errbuf, ""'struct %s' redeclaration (line %d)"", (yyvsp[0].sym)->name, p->lineno);
",1,unused,3234,unused,"    { if ((p = entry(classtable, (yyvsp[0].sym))))
			  {	if (p->info.typ->type == Tstruct)
					(yyval.typ) = p->info.typ;
			  	else
				{	sprintf(errbuf, ""'struct %s' redeclaration (line %d)"", (yyvsp[0].sym)->name, p->lineno);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsoapcpp2_yacc.c
"
  case 124:
#line 1010 ""soapcpp2_yacc.y"" /* yacc.c:1646  */
    { sym = gensym(""_Union"");
			  sprintf(errbuf, ""anonymous union will be named '%s'"", sym->name);
",1,unused,3251,unused,"
  case 124:
#line 1010 ""soapcpp2_yacc.y"" /* yacc.c:1646  */
    { sym = gensym(""_Union"");
			  sprintf(errbuf, ""anonymous union will be named '%s'"", sym->name);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsoapcpp2_yacc.c
"			  semwarn(errbuf);
			  (yyval.typ) = mkunion(sp->table, sp->offset);
			  if ((p = entry(classtable, sym)))
			  {	if (p->info.typ->ref)
				{	sprintf(errbuf, ""union or struct '%s' already declared at line %d"", sym->name, p->lineno);
",1,unused,3256,unused,"			  semwarn(errbuf);
			  (yyval.typ) = mkunion(sp->table, sp->offset);
			  if ((p = entry(classtable, sym)))
			  {	if (p->info.typ->ref)
				{	sprintf(errbuf, ""union or struct '%s' already declared at line %d"", sym->name, p->lineno);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsoapcpp2_yacc.c
"  case 125:
#line 1033 ""soapcpp2_yacc.y"" /* yacc.c:1646  */
    { if ((p = entry(classtable, (yyvsp[-4].sym))))
			  {	if (p->info.typ->ref || p->info.typ->type != Tunion)
			  	{	sprintf(errbuf, ""union '%s' already declared at line %d"", (yyvsp[-4].sym)->name, p->lineno);
",1,unused,3279,unused,"  case 125:
#line 1033 ""soapcpp2_yacc.y"" /* yacc.c:1646  */
    { if ((p = entry(classtable, (yyvsp[-4].sym))))
			  {	if (p->info.typ->ref || p->info.typ->type != Tunion)
			  	{	sprintf(errbuf, ""union '%s' already declared at line %d"", (yyvsp[-4].sym)->name, p->lineno);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsoapcpp2_yacc.c
"    { if ((p = entry(classtable, (yyvsp[0].sym))))
			  {	if (p->info.typ->type == Tunion)
					(yyval.typ) = p->info.typ;
			  	else
				{	sprintf(errbuf, ""'union %s' redeclaration (line %d)"", (yyvsp[0].sym)->name, p->lineno);
",1,unused,3305,unused,"    { if ((p = entry(classtable, (yyvsp[0].sym))))
			  {	if (p->info.typ->type == Tunion)
					(yyval.typ) = p->info.typ;
			  	else
				{	sprintf(errbuf, ""'union %s' redeclaration (line %d)"", (yyvsp[0].sym)->name, p->lineno);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsoapcpp2_yacc.c
"    { if ((p = entry(classtable, (yyvsp[0].sym))))
			  {	if (p->info.typ->type == Tunion)
					(yyval.typ) = p->info.typ;
			  	else
				{	sprintf(errbuf, ""'union %s' redeclaration (line %d)"", (yyvsp[0].sym)->name, p->lineno);
",1,unused,3325,unused,"    { if ((p = entry(classtable, (yyvsp[0].sym))))
			  {	if (p->info.typ->type == Tunion)
					(yyval.typ) = p->info.typ;
			  	else
				{	sprintf(errbuf, ""'union %s' redeclaration (line %d)"", (yyvsp[0].sym)->name, p->lineno);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsoapcpp2_yacc.c
"
  case 128:
#line 1083 ""soapcpp2_yacc.y"" /* yacc.c:1646  */
    { sym = gensym(""_Enum"");
			  sprintf(errbuf, ""anonymous enum will be named '%s'"", sym->name);
",1,unused,3342,unused,"
  case 128:
#line 1083 ""soapcpp2_yacc.y"" /* yacc.c:1646  */
    { sym = gensym(""_Enum"");
			  sprintf(errbuf, ""anonymous enum will be named '%s'"", sym->name);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsoapcpp2_yacc.c
"			  sprintf(errbuf, ""anonymous enum will be named '%s'"", sym->name);
			  semwarn(errbuf);
			  if ((p = entry(enumtable, sym)))
			  {	if (p->info.typ->ref)
				{	sprintf(errbuf, ""enum '%s' already declared at line %d"", sym->name, p->lineno);
",1,unused,3346,unused,"			  sprintf(errbuf, ""anonymous enum will be named '%s'"", sym->name);
			  semwarn(errbuf);
			  if ((p = entry(enumtable, sym)))
			  {	if (p->info.typ->ref)
				{	sprintf(errbuf, ""enum '%s' already declared at line %d"", sym->name, p->lineno);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsoapcpp2_yacc.c
"  case 129:
#line 1105 ""soapcpp2_yacc.y"" /* yacc.c:1646  */
    { if ((p = entry(enumtable, (yyvsp[-5].e)->sym)))
			  {	if (p->info.typ->ref)
				{	sprintf(errbuf, ""enum '%s' already declared at line %d"", (yyvsp[-5].e)->sym->name, p->lineno);
",1,unused,3369,unused,"  case 129:
#line 1105 ""soapcpp2_yacc.y"" /* yacc.c:1646  */
    { if ((p = entry(enumtable, (yyvsp[-5].e)->sym)))
			  {	if (p->info.typ->ref)
				{	sprintf(errbuf, ""enum '%s' already declared at line %d"", (yyvsp[-5].e)->sym->name, p->lineno);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsoapcpp2_yacc.c
"  case 130:
#line 1124 ""soapcpp2_yacc.y"" /* yacc.c:1646  */
    { if ((p = entry(enumtable, (yyvsp[-5].sym))))
			  {	if (p->info.typ->ref)
				{	sprintf(errbuf, ""enum '%s' already declared at line %d"", (yyvsp[-5].sym)->name, p->lineno);
",1,unused,3392,unused,"  case 130:
#line 1124 ""soapcpp2_yacc.y"" /* yacc.c:1646  */
    { if ((p = entry(enumtable, (yyvsp[-5].sym))))
			  {	if (p->info.typ->ref)
				{	sprintf(errbuf, ""enum '%s' already declared at line %d"", (yyvsp[-5].sym)->name, p->lineno);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsoapcpp2_yacc.c
"			  	p->info.typ->id = (yyvsp[0].sym);
			  	p->info.typ->transient = -2;
			  }
			  else
			  {	sprintf(errbuf, ""unknown type '%s'"", (yyvsp[0].sym)->name);
",1,unused,3452,unused,"			  	p->info.typ->id = (yyvsp[0].sym);
			  	p->info.typ->transient = -2;
			  }
			  else
			  {	sprintf(errbuf, ""unknown type '%s'"", (yyvsp[0].sym)->name);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsoapcpp2_yacc.c
"#line 1177 ""soapcpp2_yacc.y"" /* yacc.c:1646  */
    { if ((p = entry(templatetable, (yyvsp[-3].sym))))
				(yyval.typ) = mktemplate((yyvsp[-1].rec).typ, (yyvsp[-3].sym));
			  else
			  {	sprintf(errbuf, ""invalid template '%s'"", (yyvsp[-3].sym)->name);
",1,unused,3465,unused,"#line 1177 ""soapcpp2_yacc.y"" /* yacc.c:1646  */
    { if ((p = entry(templatetable, (yyvsp[-3].sym))))
				(yyval.typ) = mktemplate((yyvsp[-1].rec).typ, (yyvsp[-3].sym));
			  else
			  {	sprintf(errbuf, ""invalid template '%s'"", (yyvsp[-3].sym)->name);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsoapcpp2_yacc.c
"#line 1206 ""soapcpp2_yacc.y"" /* yacc.c:1646  */
    { if ((p = entry(classtable, (yyvsp[0].sym))))
			  {	if (p->info.typ->ref)
			   	{	if (!is_mutable(p->info.typ))
					{	sprintf(errbuf, ""struct '%s' already declared at line %d"", (yyvsp[0].sym)->name, p->lineno);
",1,unused,3514,unused,"#line 1206 ""soapcpp2_yacc.y"" /* yacc.c:1646  */
    { if ((p = entry(classtable, (yyvsp[0].sym))))
			  {	if (p->info.typ->ref)
			   	{	if (!is_mutable(p->info.typ))
					{	sprintf(errbuf, ""struct '%s' already declared at line %d"", (yyvsp[0].sym)->name, p->lineno);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsoapcpp2_yacc.c
"#line 1223 ""soapcpp2_yacc.y"" /* yacc.c:1646  */
    { if ((p = entry(classtable, (yyvsp[0].sym))))
			  {	if (p->info.typ->ref)
			   	{	if (!is_mutable(p->info.typ))
					{	sprintf(errbuf, ""class '%s' already declared at line %d"", (yyvsp[0].sym)->name, p->lineno);
",1,unused,3535,unused,"#line 1223 ""soapcpp2_yacc.y"" /* yacc.c:1646  */
    { if ((p = entry(classtable, (yyvsp[0].sym))))
			  {	if (p->info.typ->ref)
			   	{	if (!is_mutable(p->info.typ))
					{	sprintf(errbuf, ""class '%s' already declared at line %d"", (yyvsp[0].sym)->name, p->lineno);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsoapcpp2_yacc.c
"  case 141:
#line 1242 ""soapcpp2_yacc.y"" /* yacc.c:1646  */
    { if ((p = entry(enumtable, (yyvsp[0].sym))))
			  {	if (p->info.typ->ref)
				{	sprintf(errbuf, ""enum '%s' already declared at line %d"", (yyvsp[0].sym)->name, p->lineno);
",1,unused,3557,unused,"  case 141:
#line 1242 ""soapcpp2_yacc.y"" /* yacc.c:1646  */
    { if ((p = entry(enumtable, (yyvsp[0].sym))))
			  {	if (p->info.typ->ref)
				{	sprintf(errbuf, ""enum '%s' already declared at line %d"", (yyvsp[0].sym)->name, p->lineno);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsoapcpp2_yacc.c
"
  case 180:
#line 1350 ""soapcpp2_yacc.y"" /* yacc.c:1646  */
    { if (!bflag && (yyvsp[0].rec).typ->type == Tchar)
			  {	sprintf(errbuf, ""char[""SOAP_LONG_FORMAT""] will be serialized as an array of ""SOAP_LONG_FORMAT"" bytes: use soapcpp2 option -b to enable char[] string serialization or use char* for strings"", (yyvsp[-2].rec).val.i, (yyvsp[-2].rec).val.i);
",1,unused,3845,unused,"
  case 180:
#line 1350 ""soapcpp2_yacc.y"" /* yacc.c:1646  */
    { if (!bflag && (yyvsp[0].rec).typ->type == Tchar)
			  {	sprintf(errbuf, ""char[""SOAP_LONG_FORMAT""] will be serialized as an array of ""SOAP_LONG_FORMAT"" bytes: use soapcpp2 option -b to enable char[] string serialization or use char* for strings"", (yyvsp[-2].rec).val.i, (yyvsp[-2].rec).val.i);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsoapcpp2_yacc.c
"  case 182:
#line 1366 ""soapcpp2_yacc.y"" /* yacc.c:1646  */
    { if ((yyvsp[0].rec).typ->type == Tstruct || (yyvsp[0].rec).typ->type == Tclass)
				if (!(yyvsp[0].rec).typ->ref && !(yyvsp[0].rec).typ->transient && !((yyvsp[0].rec).sto & Stypedef))
			   	{	sprintf(errbuf, ""struct/class '%s' has incomplete type"", (yyvsp[0].rec).typ->id->name);
",1,unused,3871,unused,"  case 182:
#line 1366 ""soapcpp2_yacc.y"" /* yacc.c:1646  */
    { if ((yyvsp[0].rec).typ->type == Tstruct || (yyvsp[0].rec).typ->type == Tclass)
				if (!(yyvsp[0].rec).typ->ref && !(yyvsp[0].rec).typ->transient && !((yyvsp[0].rec).sto & Stypedef))
			   	{	sprintf(errbuf, ""struct/class '%s' has incomplete type"", (yyvsp[0].rec).typ->id->name);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsoapcpp2_yacc.c
"
static Entry*
undefined(Symbol *sym)
{	Entry	*p;
	sprintf(errbuf, ""undefined identifier '%s'"", sym->name);
",1,unused,4664,unused,"
static Entry*
undefined(Symbol *sym)
{	Entry	*p;
	sprintf(errbuf, ""undefined identifier '%s'"", sym->name);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsoapcpp2_yacc.c
"  Entry *p, *q;
  Symbol *s;
  size_t n = strlen(fun->sym->name);
  char *r = (char*)emalloc(n+9);
  strcpy(r, fun->sym->name);
",1,unused,4871,unused,"  Entry *p, *q;
  Symbol *s;
  size_t n = strlen(fun->sym->name);
  char *r = (char*)emalloc(n+9);
  strcpy(r, fun->sym->name);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsoapcpp2_yacc.c
"  Symbol *s;
  size_t n = strlen(fun->sym->name);
  char *r = (char*)emalloc(n+9);
  strcpy(r, fun->sym->name);
  strcat(r, ""Response"");
",1,unused,4872,unused,"  Symbol *s;
  size_t n = strlen(fun->sym->name);
  char *r = (char*)emalloc(n+9);
  strcpy(r, fun->sym->name);
  strcat(r, ""Response"");
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsoapcpp2_yacc.c
"install(const char *name, Token token)
{ Symbol *p;
  p = (Symbol*)emalloc(sizeof(Symbol));
  p->name = emalloc(strlen(name)+1);
  strcpy(p->name, name);
",1,unused,119,unused,"install(const char *name, Token token)
{ Symbol *p;
  p = (Symbol*)emalloc(sizeof(Symbol));
  p->name = emalloc(strlen(name)+1);
  strcpy(p->name, name);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"Symbol *
gensymidx(const char *base, int idx)
{ char buf[1024];
  Symbol *s;
  sprintf(buf, ""%s_%d"", base, idx);
",1,unused,145,unused,"Symbol *
gensymidx(const char *base, int idx)
{ char buf[1024];
  Symbol *s;
  sprintf(buf, ""%s_%d"", base, idx);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"again:
  for (p = table->list; p; q = p, p = p->next)
  { if (p->sym == sym && p->info.typ->type != Tfun)
    { char *s;
      sprintf(errbuf, ""Duplicate declaration of '%s' (already declared at line %d), changing conflicting identifier name to new name '%s_'. Note: this problem may be caused by importing invalid XML schemas"", sym->name, p->lineno, sym->name);
",1,unused,228,unused,"again:
  for (p = table->list; p; q = p, p = p->next)
  { if (p->sym == sym && p->info.typ->type != Tfun)
    { char *s;
      sprintf(errbuf, ""Duplicate declaration of '%s' (already declared at line %d), changing conflicting identifier name to new name '%s_'. Note: this problem may be caused by importing invalid XML schemas"", sym->name, p->lineno, sym->name);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"    { char *s;
      sprintf(errbuf, ""Duplicate declaration of '%s' (already declared at line %d), changing conflicting identifier name to new name '%s_'. Note: this problem may be caused by importing invalid XML schemas"", sym->name, p->lineno, sym->name);
      semwarn(errbuf);
      s = (char*)emalloc(strlen(sym->name) + 2);
      strcpy(s, sym->name);
",1,unused,231,unused,"    { char *s;
      sprintf(errbuf, ""Duplicate declaration of '%s' (already declared at line %d), changing conflicting identifier name to new name '%s_'. Note: this problem may be caused by importing invalid XML schemas"", sym->name, p->lineno, sym->name);
      semwarn(errbuf);
      s = (char*)emalloc(strlen(sym->name) + 2);
      strcpy(s, sym->name);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"      sprintf(errbuf, ""Duplicate declaration of '%s' (already declared at line %d), changing conflicting identifier name to new name '%s_'. Note: this problem may be caused by importing invalid XML schemas"", sym->name, p->lineno, sym->name);
      semwarn(errbuf);
      s = (char*)emalloc(strlen(sym->name) + 2);
      strcpy(s, sym->name);
      strcat(s, ""_"");
",1,unused,232,unused,"      sprintf(errbuf, ""Duplicate declaration of '%s' (already declared at line %d), changing conflicting identifier name to new name '%s_'. Note: this problem may be caused by importing invalid XML schemas"", sym->name, p->lineno, sym->name);
      semwarn(errbuf);
      s = (char*)emalloc(strlen(sym->name) + 2);
      strcpy(s, sym->name);
      strcat(s, ""_"");
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"	if (namespaceid)
	{ prefix = namespaceid;
	  fprintf(fmsg, ""Using code namespace: %s\n"", namespaceid);
	}
	strcpy(base, prefix);
",1,unused,633,unused,"	if (namespaceid)
	{ prefix = namespaceid;
	  fprintf(fmsg, ""Using code namespace: %s\n"", namespaceid);
	}
	strcpy(base, prefix);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"		s = "".c"";
	else
		s = "".cpp"";

  	strcpy(soapMatlab, base);
",1,unused,639,unused,"		s = "".c"";
	else
		s = "".cpp"";

  	strcpy(soapMatlab, base);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"	else
		s = "".cpp"";

  	strcpy(soapMatlab, base);
  	strcat(soapMatlab, ""Matlab.c"");
",1,unused,640,unused,"	else
		s = "".cpp"";

  	strcpy(soapMatlab, base);
  	strcat(soapMatlab, ""Matlab.c"");
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"		s = "".cpp"";

  	strcpy(soapMatlab, base);
  	strcat(soapMatlab, ""Matlab.c"");
  	strcpy(pathsoapMatlab, dirpath);
",1,unused,641,unused,"		s = "".cpp"";

  	strcpy(soapMatlab, base);
  	strcat(soapMatlab, ""Matlab.c"");
  	strcpy(pathsoapMatlab, dirpath);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"
  	strcpy(soapMatlab, base);
  	strcat(soapMatlab, ""Matlab.c"");
  	strcpy(pathsoapMatlab, dirpath);
  	strcat(pathsoapMatlab, soapMatlab );
",1,unused,642,unused,"
  	strcpy(soapMatlab, base);
  	strcat(soapMatlab, ""Matlab.c"");
  	strcpy(pathsoapMatlab, dirpath);
  	strcat(pathsoapMatlab, soapMatlab );
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"  	strcat(soapMatlab, ""Matlab.c"");
  	strcpy(pathsoapMatlab, dirpath);
  	strcat(pathsoapMatlab, soapMatlab );
  
  	strcpy(soapMatlabHdr, base);
",1,unused,644,unused,"  	strcat(soapMatlab, ""Matlab.c"");
  	strcpy(pathsoapMatlab, dirpath);
  	strcat(pathsoapMatlab, soapMatlab );
  
  	strcpy(soapMatlabHdr, base);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"  	strcpy(pathsoapMatlab, dirpath);
  	strcat(pathsoapMatlab, soapMatlab );
  
  	strcpy(soapMatlabHdr, base);
  	strcat(soapMatlabHdr, ""Matlab.h"");
",1,unused,645,unused,"  	strcpy(pathsoapMatlab, dirpath);
  	strcat(pathsoapMatlab, soapMatlab );
  
  	strcpy(soapMatlabHdr, base);
  	strcat(soapMatlabHdr, ""Matlab.h"");
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"  	strcat(pathsoapMatlab, soapMatlab );
  
  	strcpy(soapMatlabHdr, base);
  	strcat(soapMatlabHdr, ""Matlab.h"");
  	strcpy(pathsoapMatlabHdr, dirpath);
",1,unused,646,unused,"  	strcat(pathsoapMatlab, soapMatlab );
  
  	strcpy(soapMatlabHdr, base);
  	strcat(soapMatlabHdr, ""Matlab.h"");
  	strcpy(pathsoapMatlabHdr, dirpath);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"  
  	strcpy(soapMatlabHdr, base);
  	strcat(soapMatlabHdr, ""Matlab.h"");
  	strcpy(pathsoapMatlabHdr, dirpath);
  	strcat(pathsoapMatlabHdr, soapMatlabHdr);
",1,unused,647,unused,"  
  	strcpy(soapMatlabHdr, base);
  	strcat(soapMatlabHdr, ""Matlab.h"");
  	strcpy(pathsoapMatlabHdr, dirpath);
  	strcat(pathsoapMatlabHdr, soapMatlabHdr);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"  	strcat(soapMatlabHdr, ""Matlab.h"");
  	strcpy(pathsoapMatlabHdr, dirpath);
  	strcat(pathsoapMatlabHdr, soapMatlabHdr);

	strcpy(soapStub, base);
",1,unused,649,unused,"  	strcat(soapMatlabHdr, ""Matlab.h"");
  	strcpy(pathsoapMatlabHdr, dirpath);
  	strcat(pathsoapMatlabHdr, soapMatlabHdr);

	strcpy(soapStub, base);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"  	strcpy(pathsoapMatlabHdr, dirpath);
  	strcat(pathsoapMatlabHdr, soapMatlabHdr);

	strcpy(soapStub, base);
	strcat(soapStub, ""Stub.h"");
",1,unused,650,unused,"  	strcpy(pathsoapMatlabHdr, dirpath);
  	strcat(pathsoapMatlabHdr, soapMatlabHdr);

	strcpy(soapStub, base);
	strcat(soapStub, ""Stub.h"");
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"  	strcat(pathsoapMatlabHdr, soapMatlabHdr);

	strcpy(soapStub, base);
	strcat(soapStub, ""Stub.h"");
	strcpy(pathsoapStub, dirpath);
",1,unused,651,unused,"  	strcat(pathsoapMatlabHdr, soapMatlabHdr);

	strcpy(soapStub, base);
	strcat(soapStub, ""Stub.h"");
	strcpy(pathsoapStub, dirpath);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"
	strcpy(soapStub, base);
	strcat(soapStub, ""Stub.h"");
	strcpy(pathsoapStub, dirpath);
	strcat(pathsoapStub, soapStub);
",1,unused,652,unused,"
	strcpy(soapStub, base);
	strcat(soapStub, ""Stub.h"");
	strcpy(pathsoapStub, dirpath);
	strcat(pathsoapStub, soapStub);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"	strcpy(soapStub, base);
	strcat(soapStub, ""Stub.h"");
	strcpy(pathsoapStub, dirpath);
	strcat(pathsoapStub, soapStub);
	strcpy(soapH, base);
",1,unused,653,unused,"	strcpy(soapStub, base);
	strcat(soapStub, ""Stub.h"");
	strcpy(pathsoapStub, dirpath);
	strcat(pathsoapStub, soapStub);
	strcpy(soapH, base);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"	strcat(soapStub, ""Stub.h"");
	strcpy(pathsoapStub, dirpath);
	strcat(pathsoapStub, soapStub);
	strcpy(soapH, base);
	strcat(soapH, ""H.h"");
",1,unused,654,unused,"	strcat(soapStub, ""Stub.h"");
	strcpy(pathsoapStub, dirpath);
	strcat(pathsoapStub, soapStub);
	strcpy(soapH, base);
	strcat(soapH, ""H.h"");
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"	strcpy(pathsoapStub, dirpath);
	strcat(pathsoapStub, soapStub);
	strcpy(soapH, base);
	strcat(soapH, ""H.h"");
	strcpy(pathsoapH, dirpath);
",1,unused,655,unused,"	strcpy(pathsoapStub, dirpath);
	strcat(pathsoapStub, soapStub);
	strcpy(soapH, base);
	strcat(soapH, ""H.h"");
	strcpy(pathsoapH, dirpath);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"	strcat(pathsoapStub, soapStub);
	strcpy(soapH, base);
	strcat(soapH, ""H.h"");
	strcpy(pathsoapH, dirpath);
	strcat(pathsoapH, soapH);
",1,unused,656,unused,"	strcat(pathsoapStub, soapStub);
	strcpy(soapH, base);
	strcat(soapH, ""H.h"");
	strcpy(pathsoapH, dirpath);
	strcat(pathsoapH, soapH);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"	strcpy(soapH, base);
	strcat(soapH, ""H.h"");
	strcpy(pathsoapH, dirpath);
	strcat(pathsoapH, soapH);
	strcpy(soapC, base);
",1,unused,657,unused,"	strcpy(soapH, base);
	strcat(soapH, ""H.h"");
	strcpy(pathsoapH, dirpath);
	strcat(pathsoapH, soapH);
	strcpy(soapC, base);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"	strcat(soapH, ""H.h"");
	strcpy(pathsoapH, dirpath);
	strcat(pathsoapH, soapH);
	strcpy(soapC, base);
	strcat(soapC, ""C"");
",1,unused,658,unused,"	strcat(soapH, ""H.h"");
	strcpy(pathsoapH, dirpath);
	strcat(pathsoapH, soapH);
	strcpy(soapC, base);
	strcat(soapC, ""C"");
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"	strcpy(pathsoapH, dirpath);
	strcat(pathsoapH, soapH);
	strcpy(soapC, base);
	strcat(soapC, ""C"");
	strcat(soapC, s);
",1,unused,659,unused,"	strcpy(pathsoapH, dirpath);
	strcat(pathsoapH, soapH);
	strcpy(soapC, base);
	strcat(soapC, ""C"");
	strcat(soapC, s);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"	strcat(pathsoapH, soapH);
	strcpy(soapC, base);
	strcat(soapC, ""C"");
	strcat(soapC, s);
	strcpy(pathsoapC, dirpath);
",1,unused,660,unused,"	strcat(pathsoapH, soapH);
	strcpy(soapC, base);
	strcat(soapC, ""C"");
	strcat(soapC, s);
	strcpy(pathsoapC, dirpath);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"	strcpy(soapC, base);
	strcat(soapC, ""C"");
	strcat(soapC, s);
	strcpy(pathsoapC, dirpath);
	strcat(pathsoapC, soapC);
",1,unused,661,unused,"	strcpy(soapC, base);
	strcat(soapC, ""C"");
	strcat(soapC, s);
	strcpy(pathsoapC, dirpath);
	strcat(pathsoapC, soapC);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"	strcat(soapC, ""C"");
	strcat(soapC, s);
	strcpy(pathsoapC, dirpath);
	strcat(pathsoapC, soapC);
	strcpy(soapClient, base);
",1,unused,662,unused,"	strcat(soapC, ""C"");
	strcat(soapC, s);
	strcpy(pathsoapC, dirpath);
	strcat(pathsoapC, soapC);
	strcpy(soapClient, base);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"	strcat(soapC, s);
	strcpy(pathsoapC, dirpath);
	strcat(pathsoapC, soapC);
	strcpy(soapClient, base);
	strcat(soapClient, ""Client"");
",1,unused,663,unused,"	strcat(soapC, s);
	strcpy(pathsoapC, dirpath);
	strcat(pathsoapC, soapC);
	strcpy(soapClient, base);
	strcat(soapClient, ""Client"");
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"	strcpy(pathsoapC, dirpath);
	strcat(pathsoapC, soapC);
	strcpy(soapClient, base);
	strcat(soapClient, ""Client"");
	strcat(soapClient, s);
",1,unused,664,unused,"	strcpy(pathsoapC, dirpath);
	strcat(pathsoapC, soapC);
	strcpy(soapClient, base);
	strcat(soapClient, ""Client"");
	strcat(soapClient, s);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"	strcat(pathsoapC, soapC);
	strcpy(soapClient, base);
	strcat(soapClient, ""Client"");
	strcat(soapClient, s);
	strcpy(pathsoapClient, dirpath);
",1,unused,665,unused,"	strcat(pathsoapC, soapC);
	strcpy(soapClient, base);
	strcat(soapClient, ""Client"");
	strcat(soapClient, s);
	strcpy(pathsoapClient, dirpath);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"	strcpy(soapClient, base);
	strcat(soapClient, ""Client"");
	strcat(soapClient, s);
	strcpy(pathsoapClient, dirpath);
	strcat(pathsoapClient, soapClient);
",1,unused,666,unused,"	strcpy(soapClient, base);
	strcat(soapClient, ""Client"");
	strcat(soapClient, s);
	strcpy(pathsoapClient, dirpath);
	strcat(pathsoapClient, soapClient);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"	strcat(soapClient, ""Client"");
	strcat(soapClient, s);
	strcpy(pathsoapClient, dirpath);
	strcat(pathsoapClient, soapClient);
	strcpy(soapServer, base);
",1,unused,667,unused,"	strcat(soapClient, ""Client"");
	strcat(soapClient, s);
	strcpy(pathsoapClient, dirpath);
	strcat(pathsoapClient, soapClient);
	strcpy(soapServer, base);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"	strcat(soapClient, s);
	strcpy(pathsoapClient, dirpath);
	strcat(pathsoapClient, soapClient);
	strcpy(soapServer, base);
	strcat(soapServer, ""Server"");
",1,unused,668,unused,"	strcat(soapClient, s);
	strcpy(pathsoapClient, dirpath);
	strcat(pathsoapClient, soapClient);
	strcpy(soapServer, base);
	strcat(soapServer, ""Server"");
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"	strcpy(pathsoapClient, dirpath);
	strcat(pathsoapClient, soapClient);
	strcpy(soapServer, base);
	strcat(soapServer, ""Server"");
	strcat(soapServer, s);
",1,unused,669,unused,"	strcpy(pathsoapClient, dirpath);
	strcat(pathsoapClient, soapClient);
	strcpy(soapServer, base);
	strcat(soapServer, ""Server"");
	strcat(soapServer, s);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"	strcat(pathsoapClient, soapClient);
	strcpy(soapServer, base);
	strcat(soapServer, ""Server"");
	strcat(soapServer, s);
	strcpy(pathsoapServer, dirpath);
",1,unused,670,unused,"	strcat(pathsoapClient, soapClient);
	strcpy(soapServer, base);
	strcat(soapServer, ""Server"");
	strcat(soapServer, s);
	strcpy(pathsoapServer, dirpath);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"	strcpy(soapServer, base);
	strcat(soapServer, ""Server"");
	strcat(soapServer, s);
	strcpy(pathsoapServer, dirpath);
	strcat(pathsoapServer, soapServer);
",1,unused,671,unused,"	strcpy(soapServer, base);
	strcat(soapServer, ""Server"");
	strcat(soapServer, s);
	strcpy(pathsoapServer, dirpath);
	strcat(pathsoapServer, soapServer);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"	strcat(soapServer, ""Server"");
	strcat(soapServer, s);
	strcpy(pathsoapServer, dirpath);
	strcat(pathsoapServer, soapServer);
	strcpy(soapClientLib, base);
",1,unused,672,unused,"	strcat(soapServer, ""Server"");
	strcat(soapServer, s);
	strcpy(pathsoapServer, dirpath);
	strcat(pathsoapServer, soapServer);
	strcpy(soapClientLib, base);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"	strcat(soapServer, s);
	strcpy(pathsoapServer, dirpath);
	strcat(pathsoapServer, soapServer);
	strcpy(soapClientLib, base);
	strcat(soapClientLib, ""ClientLib"");
",1,unused,673,unused,"	strcat(soapServer, s);
	strcpy(pathsoapServer, dirpath);
	strcat(pathsoapServer, soapServer);
	strcpy(soapClientLib, base);
	strcat(soapClientLib, ""ClientLib"");
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"	strcpy(pathsoapServer, dirpath);
	strcat(pathsoapServer, soapServer);
	strcpy(soapClientLib, base);
	strcat(soapClientLib, ""ClientLib"");
	strcat(soapClientLib, s);
",1,unused,674,unused,"	strcpy(pathsoapServer, dirpath);
	strcat(pathsoapServer, soapServer);
	strcpy(soapClientLib, base);
	strcat(soapClientLib, ""ClientLib"");
	strcat(soapClientLib, s);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"	strcat(pathsoapServer, soapServer);
	strcpy(soapClientLib, base);
	strcat(soapClientLib, ""ClientLib"");
	strcat(soapClientLib, s);
	strcpy(pathsoapClientLib, dirpath);
",1,unused,675,unused,"	strcat(pathsoapServer, soapServer);
	strcpy(soapClientLib, base);
	strcat(soapClientLib, ""ClientLib"");
	strcat(soapClientLib, s);
	strcpy(pathsoapClientLib, dirpath);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"	strcpy(soapClientLib, base);
	strcat(soapClientLib, ""ClientLib"");
	strcat(soapClientLib, s);
	strcpy(pathsoapClientLib, dirpath);
	strcat(pathsoapClientLib, soapClientLib);
",1,unused,676,unused,"	strcpy(soapClientLib, base);
	strcat(soapClientLib, ""ClientLib"");
	strcat(soapClientLib, s);
	strcpy(pathsoapClientLib, dirpath);
	strcat(pathsoapClientLib, soapClientLib);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"	strcat(soapClientLib, ""ClientLib"");
	strcat(soapClientLib, s);
	strcpy(pathsoapClientLib, dirpath);
	strcat(pathsoapClientLib, soapClientLib);
	strcpy(soapServerLib, base);
",1,unused,677,unused,"	strcat(soapClientLib, ""ClientLib"");
	strcat(soapClientLib, s);
	strcpy(pathsoapClientLib, dirpath);
	strcat(pathsoapClientLib, soapClientLib);
	strcpy(soapServerLib, base);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"	strcat(soapClientLib, s);
	strcpy(pathsoapClientLib, dirpath);
	strcat(pathsoapClientLib, soapClientLib);
	strcpy(soapServerLib, base);
	strcat(soapServerLib, ""ServerLib"");
",1,unused,678,unused,"	strcat(soapClientLib, s);
	strcpy(pathsoapClientLib, dirpath);
	strcat(pathsoapClientLib, soapClientLib);
	strcpy(soapServerLib, base);
	strcat(soapServerLib, ""ServerLib"");
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"	strcpy(pathsoapClientLib, dirpath);
	strcat(pathsoapClientLib, soapClientLib);
	strcpy(soapServerLib, base);
	strcat(soapServerLib, ""ServerLib"");
	strcat(soapServerLib, s);
",1,unused,679,unused,"	strcpy(pathsoapClientLib, dirpath);
	strcat(pathsoapClientLib, soapClientLib);
	strcpy(soapServerLib, base);
	strcat(soapServerLib, ""ServerLib"");
	strcat(soapServerLib, s);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"	strcat(pathsoapClientLib, soapClientLib);
	strcpy(soapServerLib, base);
	strcat(soapServerLib, ""ServerLib"");
	strcat(soapServerLib, s);
	strcpy(pathsoapServerLib, dirpath);
",1,unused,680,unused,"	strcat(pathsoapClientLib, soapClientLib);
	strcpy(soapServerLib, base);
	strcat(soapServerLib, ""ServerLib"");
	strcat(soapServerLib, s);
	strcpy(pathsoapServerLib, dirpath);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"	strcpy(soapServerLib, base);
	strcat(soapServerLib, ""ServerLib"");
	strcat(soapServerLib, s);
	strcpy(pathsoapServerLib, dirpath);
	strcat(pathsoapServerLib, soapServerLib);
",1,unused,681,unused,"	strcpy(soapServerLib, base);
	strcat(soapServerLib, ""ServerLib"");
	strcat(soapServerLib, s);
	strcpy(pathsoapServerLib, dirpath);
	strcat(pathsoapServerLib, soapServerLib);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"    if (has_ns(typ) || is_untyped(typ))
      fprintf(fd, ""/* Sequence of %s schema type: */\n"", x);
    else
    { if (!eflag)
      { sprintf(errbuf, ""array '%s' is not compliant with WS-I Basic Profile 1.0a, reason: SOAP encoded array"", c_type(typ));
",1,unused,1188,unused,"    if (has_ns(typ) || is_untyped(typ))
      fprintf(fd, ""/* Sequence of %s schema type: */\n"", x);
    else
    { if (!eflag)
      { sprintf(errbuf, ""array '%s' is not compliant with WS-I Basic Profile 1.0a, reason: SOAP encoded array"", c_type(typ));
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"	  }
	  if (!is_dynamic_array(typ) && !is_primclass(typ))
	  { if (!strncmp(Eptr->sym->name, ""__size"", 6))
	    { if (!Eptr->next || Eptr->next->info.typ->type != Tpointer)
              { sprintf(errbuf, ""Member field '%s' is not followed by a pointer member field in struct '%s'"", Eptr->sym->name, typ->id->name);
",1,unused,1276,unused,"	  }
	  if (!is_dynamic_array(typ) && !is_primclass(typ))
	  { if (!strncmp(Eptr->sym->name, ""__size"", 6))
	    { if (!Eptr->next || Eptr->next->info.typ->type != Tpointer)
              { sprintf(errbuf, ""Member field '%s' is not followed by a pointer member field in struct '%s'"", Eptr->sym->name, typ->id->name);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"	      }
	    }
	    else if (!strncmp(Eptr->sym->name, ""__type"", 6))
	    { if (!Eptr->next || ((Eptr->next->info.typ->type != Tpointer || ((Tnode*)Eptr->next->info.typ->ref)->type != Tvoid)))
              { sprintf(errbuf, ""Member field '%s' is not followed by a void pointer or union member field in struct '%s'"", Eptr->sym->name, typ->id->name);
",1,unused,1282,unused,"	      }
	    }
	    else if (!strncmp(Eptr->sym->name, ""__type"", 6))
	    { if (!Eptr->next || ((Eptr->next->info.typ->type != Tpointer || ((Tnode*)Eptr->next->info.typ->ref)->type != Tvoid)))
              { sprintf(errbuf, ""Member field '%s' is not followed by a void pointer or union member field in struct '%s'"", Eptr->sym->name, typ->id->name);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"	}
        fprintf(fd, ""\n};"");
      }
      else if (!is_transient(typ) && !is_external(typ) && !is_volatile(typ))
      { sprintf(errbuf, ""struct '%s' is empty"", typ->id->name);
",1,unused,1297,unused,"	}
        fprintf(fd, ""\n};"");
      }
      else if (!is_transient(typ) && !is_external(typ) && !is_volatile(typ))
      { sprintf(errbuf, ""struct '%s' is empty"", typ->id->name);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"	 }
	 if (!is_dynamic_array(typ) && !is_primclass(typ))
	 { if (!strncmp(Eptr->sym->name, ""__size"", 6))
	   { if (!Eptr->next || Eptr->next->info.typ->type != Tpointer)
             { sprintf(errbuf, ""Member field '%s' is not followed by a pointer member field in struct '%s'"", Eptr->sym->name, typ->id->name);
",1,unused,1371,unused,"	 }
	 if (!is_dynamic_array(typ) && !is_primclass(typ))
	 { if (!strncmp(Eptr->sym->name, ""__size"", 6))
	   { if (!Eptr->next || Eptr->next->info.typ->type != Tpointer)
             { sprintf(errbuf, ""Member field '%s' is not followed by a pointer member field in struct '%s'"", Eptr->sym->name, typ->id->name);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"	     }
	   }
	   else if (!strncmp(Eptr->sym->name, ""__type"", 6))
	   { if (!Eptr->next || ((Eptr->next->info.typ->type != Tpointer || ((Tnode*)Eptr->next->info.typ->ref)->type != Tvoid)))
             { sprintf(errbuf, ""Member field '%s' is not followed by a void pointer or union member field in struct '%s'"", Eptr->sym->name, typ->id->name);
",1,unused,1377,unused,"	     }
	   }
	   else if (!strncmp(Eptr->sym->name, ""__type"", 6))
	   { if (!Eptr->next || ((Eptr->next->info.typ->type != Tpointer || ((Tnode*)Eptr->next->info.typ->ref)->type != Tvoid)))
             { sprintf(errbuf, ""Member field '%s' is not followed by a void pointer or union member field in struct '%s'"", Eptr->sym->name, typ->id->name);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"        fprintf(fd, ""\n#ifdef WITH_NOEMPTYSTRUCT\nprivate:\n\tchar dummy;\t/* dummy member to enable compilation */\n#endif"");
      fprintf(fd,""\n};"");
    }
    else if (!is_transient(typ) && !is_external(typ) && !is_volatile(typ))
    { sprintf(errbuf, ""class '%s' is empty"", typ->id->name);
",1,unused,1438,unused,"        fprintf(fd, ""\n#ifdef WITH_NOEMPTYSTRUCT\nprivate:\n\tchar dummy;\t/* dummy member to enable compilation */\n#endif"");
      fprintf(fd,""\n};"");
    }
    else if (!is_transient(typ) && !is_external(typ) && !is_volatile(typ))
    { sprintf(errbuf, ""class '%s' is empty"", typ->id->name);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"	  if (is_transient(Eptr->info.typ))
	    fprintf(fd, ""\t/* transient */"");
	  if (Eptr->info.sto & Sattribute)
	  { fprintf(fd, ""\t/* attribute not allowed in union */"");
            sprintf(errbuf, ""union '%s' contains attribute declarations"", typ->id->name);
",1,unused,1459,unused,"	  if (is_transient(Eptr->info.typ))
	    fprintf(fd, ""\t/* transient */"");
	  if (Eptr->info.sto & Sattribute)
	  { fprintf(fd, ""\t/* attribute not allowed in union */"");
            sprintf(errbuf, ""union '%s' contains attribute declarations"", typ->id->name);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"	}
        fprintf(fd, ""\n};"");
      }
      else if (!is_transient(typ) && !is_external(typ) && !is_volatile(typ))
      { sprintf(errbuf, ""union '%s' is empty"", typ->id->name);
",1,unused,1468,unused,"	}
        fprintf(fd, ""\n};"");
      }
      else if (!is_transient(typ) && !is_external(typ) && !is_volatile(typ))
      { sprintf(errbuf, ""union '%s' is empty"", typ->id->name);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"  fflush(fheader);
  if (typetable)
    for (p = typetable->list; p; p = p->next)
    { if (!is_primitive_or_string(p->info.typ) && !is_external(p->info.typ) && !is_XML(p->info.typ) && !is_transient(p->info.typ) && !has_ns_t(p->info.typ) && !is_imported(p->info.typ) && !is_template(p->info.typ))
      { sprintf(errbuf, ""typedef '%s' is not namespace qualified: schema definition for '%s' in WSDL file output may be invalid"", p->sym->name, p->sym->name);
",1,unused,1550,unused,"  fflush(fheader);
  if (typetable)
    for (p = typetable->list; p; p = p->next)
    { if (!is_primitive_or_string(p->info.typ) && !is_external(p->info.typ) && !is_XML(p->info.typ) && !is_transient(p->info.typ) && !has_ns_t(p->info.typ) && !is_imported(p->info.typ) && !is_template(p->info.typ))
      { sprintf(errbuf, ""typedef '%s' is not namespace qualified: schema definition for '%s' in WSDL file output may be invalid"", p->sym->name, p->sym->name);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"            if (!strcmp(q->name, buf))
              goto nsnext;
          q = (Symbol*)emalloc(sizeof(Symbol));
          q->name = (char*)emalloc(i+1);
	  strcpy(q->name, buf);
",1,unused,1605,unused,"            if (!strcmp(q->name, buf))
              goto nsnext;
          q = (Symbol*)emalloc(sizeof(Symbol));
          q->name = (char*)emalloc(i+1);
	  strcpy(q->name, buf);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"  	}
    }
    if (!URI)
    { URI = emalloc(strlen(tmpURI) + strlen(ns->name) + 6);
      sprintf(URI, ""%s/%s.xsd"", tmpURI, ns_convert(ns->name));
",1,unused,1674,unused,"  	}
    }
    if (!URI)
    { URI = emalloc(strlen(tmpURI) + strlen(ns->name) + 6);
      sprintf(URI, ""%s/%s.xsd"", tmpURI, ns_convert(ns->name));
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"	    fprintf(fmsg, ""Using %s schema import: %s\n"", ns->name, import);
	  else if (URI)
	    fprintf(fmsg, ""Using %s schema namespace: %s\n"", ns->name, URI);
          if (sp && sp->name)
	    sprintf(buf, ""%s%s.wsdl"", dirpath, ns_cname(name, NULL));
",1,unused,1710,unused,"	    fprintf(fmsg, ""Using %s schema import: %s\n"", ns->name, import);
	  else if (URI)
	    fprintf(fmsg, ""Using %s schema namespace: %s\n"", ns->name, URI);
          if (sp && sp->name)
	    sprintf(buf, ""%s%s.wsdl"", dirpath, ns_cname(name, NULL));
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"	    fprintf(fmsg, ""Using %s schema namespace: %s\n"", ns->name, URI);
          if (sp && sp->name)
	    sprintf(buf, ""%s%s.wsdl"", dirpath, ns_cname(name, NULL));
	  else
	    sprintf(buf, ""%s%s.wsdl"", dirpath, ns_cname(ns->name, NULL));
",1,unused,1712,unused,"	    fprintf(fmsg, ""Using %s schema namespace: %s\n"", ns->name, URI);
          if (sp && sp->name)
	    sprintf(buf, ""%s%s.wsdl"", dirpath, ns_cname(name, NULL));
	  else
	    sprintf(buf, ""%s%s.wsdl"", dirpath, ns_cname(ns->name, NULL));
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"              else
	        sname = """";
	      if (!Sflag)
              { char *name1 = ns_cname(sname, ""Proxy"");
	        sprintf(buf, ""%s%s%s.h"", dirpath, prefix, name1);
",1,unused,1730,unused,"              else
	        sname = """";
	      if (!Sflag)
              { char *name1 = ns_cname(sname, ""Proxy"");
	        sprintf(buf, ""%s%s%s.h"", dirpath, prefix, name1);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"	        fprintf(fmsg, ""Saving %s client proxy class\n"", buf);
                fd = fopen(buf, ""w"");
	        if (!fd)
	          execerror(""Cannot write proxy class file"");
	        sprintf(buf, ""%s%s.h"", prefix, name1);
",1,unused,1735,unused,"	        fprintf(fmsg, ""Saving %s client proxy class\n"", buf);
                fd = fopen(buf, ""w"");
	        if (!fd)
	          execerror(""Cannot write proxy class file"");
	        sprintf(buf, ""%s%s.h"", prefix, name1);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"	        sprintf(buf, ""%s%s.h"", prefix, name1);
	        copyrightnote(fd, buf);
                gen_proxy_header(fd, t, ns, name1, URL, executable, URI, encoding);
                fclose(fd);
	        sprintf(buf, ""%s%s%s.cpp"", dirpath, prefix, name1);
",1,unused,1739,unused,"	        sprintf(buf, ""%s%s.h"", prefix, name1);
	        copyrightnote(fd, buf);
                gen_proxy_header(fd, t, ns, name1, URL, executable, URI, encoding);
                fclose(fd);
	        sprintf(buf, ""%s%s%s.cpp"", dirpath, prefix, name1);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"	        fprintf(fmsg, ""Saving %s client proxy class\n"", buf);
                fd = fopen(buf, ""w"");
	        if (!fd)
	          execerror(""Cannot write proxy class file"");
	        sprintf(buf, ""%s%s.cpp"", prefix, name1);
",1,unused,1744,unused,"	        fprintf(fmsg, ""Saving %s client proxy class\n"", buf);
                fd = fopen(buf, ""w"");
	        if (!fd)
	          execerror(""Cannot write proxy class file"");
	        sprintf(buf, ""%s%s.cpp"", prefix, name1);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"                fclose(fd);
	      }
              if (!Cflag)
              { char *name1 = ns_cname(sname, ""Service"");
	        sprintf(buf, ""%s%s%s.h"", dirpath, prefix, name1);
",1,unused,1751,unused,"                fclose(fd);
	      }
              if (!Cflag)
              { char *name1 = ns_cname(sname, ""Service"");
	        sprintf(buf, ""%s%s%s.h"", dirpath, prefix, name1);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"	        fprintf(fmsg, ""Saving %s service class\n"", buf);
                fd = fopen(buf, ""w"");
	        if (!fd)
	          execerror(""Cannot write service class file"");
	        sprintf(buf, ""%s%s.h"", prefix, name1);
",1,unused,1756,unused,"	        fprintf(fmsg, ""Saving %s service class\n"", buf);
                fd = fopen(buf, ""w"");
	        if (!fd)
	          execerror(""Cannot write service class file"");
	        sprintf(buf, ""%s%s.h"", prefix, name1);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"	        sprintf(buf, ""%s%s.h"", prefix, name1);
	        copyrightnote(fd, buf);
                gen_object_header(fd, t, ns, name1, URL, executable, URI, encoding);
                fclose(fd);
	        sprintf(buf, ""%s%s%s.cpp"", dirpath, prefix, name1);
",1,unused,1760,unused,"	        sprintf(buf, ""%s%s.h"", prefix, name1);
	        copyrightnote(fd, buf);
                gen_object_header(fd, t, ns, name1, URL, executable, URI, encoding);
                fclose(fd);
	        sprintf(buf, ""%s%s%s.cpp"", dirpath, prefix, name1);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"	        fprintf(fmsg, ""Saving %s service class\n"", buf);
                fd = fopen(buf, ""w"");
	        if (!fd)
	          execerror(""Cannot write service class file"");
	        sprintf(buf, ""%s%s.cpp"", prefix, name1);
",1,unused,1765,unused,"	        fprintf(fmsg, ""Saving %s service class\n"", buf);
                fd = fopen(buf, ""w"");
	        if (!fd)
	          execerror(""Cannot write service class file"");
	        sprintf(buf, ""%s%s.cpp"", prefix, name1);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"	      }
	    }
	    else
	    { if (!Sflag && sp && sp->name)
	      { sprintf(buf, ""%s%s%s.h"", dirpath, prefix, ns_cname(name, ""Proxy""));
",1,unused,1773,unused,"	      }
	    }
	    else
	    { if (!Sflag && sp && sp->name)
	      { sprintf(buf, ""%s%s%s.h"", dirpath, prefix, ns_cname(name, ""Proxy""));
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"	        fprintf(fmsg, ""Saving %s client proxy\n"", buf);
                fd = fopen(buf, ""w"");
	        if (!fd)
	          execerror(""Cannot write proxy file"");
	        sprintf(buf, ""%s%s.h"", prefix, ns_cname(name, ""Proxy""));
",1,unused,1778,unused,"	        fprintf(fmsg, ""Saving %s client proxy\n"", buf);
                fd = fopen(buf, ""w"");
	        if (!fd)
	          execerror(""Cannot write proxy file"");
	        sprintf(buf, ""%s%s.h"", prefix, ns_cname(name, ""Proxy""));
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"                gen_proxy(fd, t, ns, name, URL, executable, URI, encoding);
                fclose(fd);
	      }
	      else if (!Sflag)
	      { sprintf(buf, ""%s%s.h"", dirpath, ns_cname(prefix, ""Proxy""));
",1,unused,1784,unused,"                gen_proxy(fd, t, ns, name, URL, executable, URI, encoding);
                fclose(fd);
	      }
	      else if (!Sflag)
	      { sprintf(buf, ""%s%s.h"", dirpath, ns_cname(prefix, ""Proxy""));
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"	        fprintf(fmsg, ""Saving %s client proxy\n"", buf);
                fd = fopen(buf, ""w"");
	        if (!fd)
	          execerror(""Cannot write proxy file"");
	        sprintf(buf, ""%s.h"", ns_cname(prefix, ""Proxy""));
",1,unused,1789,unused,"	        fprintf(fmsg, ""Saving %s client proxy\n"", buf);
                fd = fopen(buf, ""w"");
	        if (!fd)
	          execerror(""Cannot write proxy file"");
	        sprintf(buf, ""%s.h"", ns_cname(prefix, ""Proxy""));
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"                gen_proxy(fd, t, ns, ""Service"", URL, executable, URI, encoding);
                fclose(fd);
	      }
              if (!Cflag && sp && sp->name)
	      { sprintf(buf, ""%s%s%s.h"", dirpath, prefix, ns_cname(name, ""Object""));
",1,unused,1795,unused,"                gen_proxy(fd, t, ns, ""Service"", URL, executable, URI, encoding);
                fclose(fd);
	      }
              if (!Cflag && sp && sp->name)
	      { sprintf(buf, ""%s%s%s.h"", dirpath, prefix, ns_cname(name, ""Object""));
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"	        fprintf(fmsg, ""Saving %s server object\n"", buf);
                fd = fopen(buf, ""w"");
	        if (!fd)
	          execerror(""Cannot write server object file"");
	        sprintf(buf, ""%s%s.h"", prefix, ns_cname(name, ""Object""));
",1,unused,1800,unused,"	        fprintf(fmsg, ""Saving %s server object\n"", buf);
                fd = fopen(buf, ""w"");
	        if (!fd)
	          execerror(""Cannot write server object file"");
	        sprintf(buf, ""%s%s.h"", prefix, ns_cname(name, ""Object""));
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"                gen_object(fd, t, ns, name, URL, executable, URI, encoding);
                fclose(fd);
	      }
	      else if (!Cflag)
	      { sprintf(buf, ""%s%s.h"", dirpath, ns_cname(prefix, ""Object""));
",1,unused,1806,unused,"                gen_object(fd, t, ns, name, URL, executable, URI, encoding);
                fclose(fd);
	      }
	      else if (!Cflag)
	      { sprintf(buf, ""%s%s.h"", dirpath, ns_cname(prefix, ""Object""));
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"	        fprintf(fmsg, ""Saving %s server object\n"", buf);
                fd = fopen(buf, ""w"");
	        if (!fd)
	          execerror(""Cannot write server object file"");
	        sprintf(buf, ""%s.h"", ns_cname(prefix, ""Object""));
",1,unused,1811,unused,"	        fprintf(fmsg, ""Saving %s server object\n"", buf);
                fd = fopen(buf, ""w"");
	        if (!fd)
	          execerror(""Cannot write server object file"");
	        sprintf(buf, ""%s.h"", ns_cname(prefix, ""Object""));
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"	      }
	    }
	  }
	  if (!xflag)
	  { strcpy(buf, dirpath);
",1,unused,1819,unused,"	      }
	    }
	  }
	  if (!xflag)
	  { strcpy(buf, dirpath);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"	  }
	  if (!xflag)
	  { strcpy(buf, dirpath);
            if (sp && sp->name)
	      strcat(buf, ns_fname(name));
",1,unused,1821,unused,"	  }
	  if (!xflag)
	  { strcpy(buf, dirpath);
            if (sp && sp->name)
	      strcat(buf, ns_fname(name));
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"	  { strcpy(buf, dirpath);
            if (sp && sp->name)
	      strcat(buf, ns_fname(name));
	    else
	      strcat(buf, ns_fname(ns->name));
",1,unused,1823,unused,"	  { strcpy(buf, dirpath);
            if (sp && sp->name)
	      strcat(buf, ns_fname(name));
	    else
	      strcat(buf, ns_fname(ns->name));
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"            if (sp && sp->name)
	      strcat(buf, ns_fname(name));
	    else
	      strcat(buf, ns_fname(ns->name));
	    strcat(buf, ""."");
",1,unused,1824,unused,"            if (sp && sp->name)
	      strcat(buf, ns_fname(name));
	    else
	      strcat(buf, ns_fname(ns->name));
	    strcat(buf, ""."");
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"      }
      if (sp && sp->name)
      { has_nsmap = 1;
        if (nflag)
	  sprintf(buf, ""%s%s.nsmap"", dirpath, prefix);
",1,unused,1833,unused,"      }
      if (sp && sp->name)
      { has_nsmap = 1;
        if (nflag)
	  sprintf(buf, ""%s%s.nsmap"", dirpath, prefix);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"      { has_nsmap = 1;
        if (nflag)
	  sprintf(buf, ""%s%s.nsmap"", dirpath, prefix);
        else
	  sprintf(buf, ""%s%s.nsmap"", dirpath, ns_cname(name, NULL));
",1,unused,1835,unused,"      { has_nsmap = 1;
        if (nflag)
	  sprintf(buf, ""%s%s.nsmap"", dirpath, prefix);
        else
	  sprintf(buf, ""%s%s.nsmap"", dirpath, ns_cname(name, NULL));
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"	  char soapTester[1024];
	  char pathsoapTester[1024];
	  char *name1 = NULL;
	  Tflag = 0;
	  strcpy(soapTester, prefix);
",1,unused,1854,unused,"	  char soapTester[1024];
	  char pathsoapTester[1024];
	  char *name1 = NULL;
	  Tflag = 0;
	  strcpy(soapTester, prefix);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"	  char pathsoapTester[1024];
	  char *name1 = NULL;
	  Tflag = 0;
	  strcpy(soapTester, prefix);
	  strcat(soapTester, ""Tester"");
",1,unused,1855,unused,"	  char pathsoapTester[1024];
	  char *name1 = NULL;
	  Tflag = 0;
	  strcpy(soapTester, prefix);
	  strcat(soapTester, ""Tester"");
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"	  Tflag = 0;
	  strcpy(soapTester, prefix);
	  strcat(soapTester, ""Tester"");
	  if (cflag)
	    strcat(soapTester, "".c"");
",1,unused,1857,unused,"	  Tflag = 0;
	  strcpy(soapTester, prefix);
	  strcat(soapTester, ""Tester"");
	  if (cflag)
	    strcat(soapTester, "".c"");
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"	  strcat(soapTester, ""Tester"");
	  if (cflag)
	    strcat(soapTester, "".c"");
	  else
	    strcat(soapTester, "".cpp"");
",1,unused,1859,unused,"	  strcat(soapTester, ""Tester"");
	  if (cflag)
	    strcat(soapTester, "".c"");
	  else
	    strcat(soapTester, "".cpp"");
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"	  if (cflag)
	    strcat(soapTester, "".c"");
	  else
	    strcat(soapTester, "".cpp"");
	  strcpy(pathsoapTester, dirpath);
",1,unused,1860,unused,"	  if (cflag)
	    strcat(soapTester, "".c"");
	  else
	    strcat(soapTester, "".cpp"");
	  strcpy(pathsoapTester, dirpath);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"	    strcat(soapTester, "".c"");
	  else
	    strcat(soapTester, "".cpp"");
	  strcpy(pathsoapTester, dirpath);
	  strcat(pathsoapTester, soapTester);
",1,unused,1861,unused,"	    strcat(soapTester, "".c"");
	  else
	    strcat(soapTester, "".cpp"");
	  strcpy(pathsoapTester, dirpath);
	  strcat(pathsoapTester, soapTester);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"        }
      }
    }
    if (!wflag && !import)
    { sprintf(buf, ""%s%s.xsd"", dirpath, ns_cname(ns->name, NULL));
",1,unused,1937,unused,"        }
      }
    }
    if (!wflag && !import)
    { sprintf(buf, ""%s%s.xsd"", dirpath, ns_cname(ns->name, NULL));
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"    for (ns = nslist; ns; ns = ns->next)
      if (strcmp(ns->name, ""SOAP-ENV"") && strcmp(ns->name, ""SOAP-ENC"") && strcmp(ns->name, ""xsi"") && strcmp(ns->name, ""xsd""))
        break;
    if (nflag)
      sprintf(buf, ""%s%s.nsmap"", dirpath, prefix);
",1,unused,1961,unused,"    for (ns = nslist; ns; ns = ns->next)
      if (strcmp(ns->name, ""SOAP-ENV"") && strcmp(ns->name, ""SOAP-ENC"") && strcmp(ns->name, ""xsi"") && strcmp(ns->name, ""xsd""))
        break;
    if (nflag)
      sprintf(buf, ""%s%s.nsmap"", dirpath, prefix);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"        break;
    if (nflag)
      sprintf(buf, ""%s%s.nsmap"", dirpath, prefix);
    else if (ns && ns->name)
      sprintf(buf, ""%s%s.nsmap"", dirpath, ns_cname(ns->name, NULL));
",1,unused,1963,unused,"        break;
    if (nflag)
      sprintf(buf, ""%s%s.nsmap"", dirpath, prefix);
    else if (ns && ns->name)
      sprintf(buf, ""%s%s.nsmap"", dirpath, ns_cname(ns->name, NULL));
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"      sprintf(buf, ""%s%s.nsmap"", dirpath, prefix);
    else if (ns && ns->name)
      sprintf(buf, ""%s%s.nsmap"", dirpath, ns_cname(ns->name, NULL));
    else
      sprintf(buf, ""%ssoap.nsmap"", dirpath);
",1,unused,1965,unused,"      sprintf(buf, ""%s%s.nsmap"", dirpath, prefix);
    else if (ns && ns->name)
      sprintf(buf, ""%s%s.nsmap"", dirpath, ns_cname(ns->name, NULL));
    else
      sprintf(buf, ""%ssoap.nsmap"", dirpath);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"  if (p)
    for (p = ((Table*)p->info.typ->ref)->list; p; p = p->next)
      if (has_ns_eq(NULL, p->sym->name) && (!strcmp(part, p->sym->name) || is_eq_nons(part, p->sym->name)))
        return 1;
  sprintf(errbuf, ""Cannot define method-header-part in WSDL: SOAP_ENV__Header \""%s\"" member field is not qualified"", part);
",1,unused,1988,unused,"  if (p)
    for (p = ((Table*)p->info.typ->ref)->list; p; p = p->next)
      if (has_ns_eq(NULL, p->sym->name) && (!strcmp(part, p->sym->name) || is_eq_nons(part, p->sym->name)))
        return 1;
  sprintf(errbuf, ""Cannot define method-header-part in WSDL: SOAP_ENV__Header \""%s\"" member field is not qualified"", part);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"		      break;
	            }
	      }
	      if (!flag)
	      { sprintf(errbuf, ""//gsoap %s method-fault %s %s directive does not refer to a member of struct SOAP_ENV__Detail: suggest to define struct SOAP_ENV__Detail with member %s"", sp->ns, m->name, m->part, m->part);
",1,unused,2237,unused,"		      break;
	            }
	      }
	      if (!flag)
	      { sprintf(errbuf, ""//gsoap %s method-fault %s %s directive does not refer to a member of struct SOAP_ENV__Detail: suggest to define struct SOAP_ENV__Detail with member %s"", sp->ns, m->name, m->part, m->part);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"                semwarn(errbuf);
	      }
	    }
	    else
            { sprintf(errbuf, ""//gsoap %s method-fault %s %s directive does not refer to struct/class or typedef: should globablly define fault %s as type (typedef or struct/class)"", sp->ns, m->name, m->part, m->part);
",1,unused,2242,unused,"                semwarn(errbuf);
	      }
	    }
	    else
            { sprintf(errbuf, ""//gsoap %s method-fault %s %s directive does not refer to struct/class or typedef: should globablly define fault %s as type (typedef or struct/class)"", sp->ns, m->name, m->part, m->part);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"	    fprintf(fd, ""     <SOAP:body use=\""encoded\"" namespace=\""%s\"" encodingStyle=\""%s\""/>\n"", URI, method_encoding);
          else
	    fprintf(fd, ""     <SOAP:body use=\""encoded\"" namespace=\""%s\"" encodingStyle=\""%s\""/>\n"", URI, encURI);
          if (!eflag)
          { sprintf(errbuf, ""operation '%s' is not compliant with WS-I Basic Profile 1.0a, reason: uses SOAP encoding"", p->sym->name);
",1,unused,2380,unused,"	    fprintf(fd, ""     <SOAP:body use=\""encoded\"" namespace=\""%s\"" encodingStyle=\""%s\""/>\n"", URI, method_encoding);
          else
	    fprintf(fd, ""     <SOAP:body use=\""encoded\"" namespace=\""%s\"" encodingStyle=\""%s\""/>\n"", URI, encURI);
          if (!eflag)
          { sprintf(errbuf, ""operation '%s' is not compliant with WS-I Basic Profile 1.0a, reason: uses SOAP encoding"", p->sym->name);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"      case Tlong:
      case Tllong:
      case Tulong:
      case Tullong:
        sprintf(buf, "" %s=\""""SOAP_LONG_FORMAT""\"""", a, e->info.val.i);
",1,unused,2494,unused,"      case Tlong:
      case Tllong:
      case Tulong:
      case Tullong:
        sprintf(buf, "" %s=\""""SOAP_LONG_FORMAT""\"""", a, e->info.val.i);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"	break;
      case Tfloat:
      case Tdouble:
      case Tldouble:
        sprintf(buf, "" %s=\""%f\"""", a, e->info.val.r);
",1,unused,2499,unused,"	break;
      case Tfloat:
      case Tdouble:
      case Tldouble:
        sprintf(buf, "" %s=\""%f\"""", a, e->info.val.r);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"        break; /* should get value? */
      case Tenum:
	for (q = ((Table*)e->info.typ->ref)->list; q; q = q->next)
	  if (q->info.val.i == e->info.val.i)
	  { sprintf(buf, "" %s=\""%s\"""", a, ns_convert(q->sym->name));
",1,unused,2506,unused,"        break; /* should get value? */
      case Tenum:
	for (q = ((Table*)e->info.typ->ref)->list; q; q = q->next)
	  if (q->info.val.i == e->info.val.i)
	  { sprintf(buf, "" %s=\""%s\"""", a, ns_convert(q->sym->name));
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"	  }
        break;
      default:
	if (e->info.val.s && strlen(e->info.val.s) < sizeof(buf)-12)
          sprintf(buf, "" %s=\""%s\"""", a, xstring(e->info.val.s));
",1,unused,2512,unused,"	  }
        break;
      default:
	if (e->info.val.s && strlen(e->info.val.s) < sizeof(buf)-12)
          sprintf(buf, "" %s=\""%s\"""", a, xstring(e->info.val.s));
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"	  continue; /* already generated element for fault */
        e = entry(r, q->sym);
        if (e)
	{ if ((e->info.sto & Sattribute) != (q->info.sto & Sattribute) || reftype(e->info.typ) != reftype(q->info.typ))
          { sprintf(errbuf, ""Field '%s' of type '%s' at line %d has a type that does not correspond to the required unique type '%s' defined for elements '<%s>' in the WSDL namespace based on literal encoding: use SOAP RPC encoding or rename or use a namespace qualifier"", q->sym->name, c_type(q->info.typ), q->lineno, c_type(e->info.typ), ns_convert(q->sym->name));
",1,unused,3065,unused,"	  continue; /* already generated element for fault */
        e = entry(r, q->sym);
        if (e)
	{ if ((e->info.sto & Sattribute) != (q->info.sto & Sattribute) || reftype(e->info.typ) != reftype(q->info.typ))
          { sprintf(errbuf, ""Field '%s' of type '%s' at line %d has a type that does not correspond to the required unique type '%s' defined for elements '<%s>' in the WSDL namespace based on literal encoding: use SOAP RPC encoding or rename or use a namespace qualifier"", q->sym->name, c_type(q->info.typ), q->lineno, c_type(e->info.typ), ns_convert(q->sym->name));
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"              { if (!is_repetition(q) && !is_anytype(q) && !has_ns_eq(NULL, q->sym->name) && !is_transient(q->info.typ) && q->info.typ->type != Tfun && !(q->info.sto & Sattribute))
                { e = entry(r, q->sym);
                  if (e)
	          { if ((e->info.sto & Sattribute) != (q->info.sto & Sattribute)|| reftype(e->info.typ) != reftype(q->info.typ))
                    { sprintf(errbuf, ""Parameter '%s' of type '%s' at line %d has a type that does not correspond to the required unique type '%s' defined for elements '<%s>' in the WSDL namespace based on literal encoding: use SOAP RPC encoding or rename or use a namespace qualifier"", q->sym->name, c_type(q->info.typ), q->lineno, c_type(e->info.typ), ns_convert(q->sym->name));
",1,unused,3119,unused,"              { if (!is_repetition(q) && !is_anytype(q) && !has_ns_eq(NULL, q->sym->name) && !is_transient(q->info.typ) && q->info.typ->type != Tfun && !(q->info.sto & Sattribute))
                { e = entry(r, q->sym);
                  if (e)
	          { if ((e->info.sto & Sattribute) != (q->info.sto & Sattribute)|| reftype(e->info.typ) != reftype(q->info.typ))
                    { sprintf(errbuf, ""Parameter '%s' of type '%s' at line %d has a type that does not correspond to the required unique type '%s' defined for elements '<%s>' in the WSDL namespace based on literal encoding: use SOAP RPC encoding or rename or use a namespace qualifier"", q->sym->name, c_type(q->info.typ), q->lineno, c_type(e->info.typ), ns_convert(q->sym->name));
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"  	        else if (is_literal(method_response_encoding))
                { e = entry(r, q->sym);
                  if (e)
	          { if ((e->info.sto & Sattribute) != (q->info.sto & Sattribute)|| reftype(e->info.typ) != reftype(q->info.typ))
                    { sprintf(errbuf, ""Qualified member field '%s' has a type that does not correspond to the unique type '%s' defined for elements '<%s>'"", q->sym->name, c_type(q->info.typ), ns_convert(q->sym->name));
",1,unused,3149,unused,"  	        else if (is_literal(method_response_encoding))
                { e = entry(r, q->sym);
                  if (e)
	          { if ((e->info.sto & Sattribute) != (q->info.sto & Sattribute)|| reftype(e->info.typ) != reftype(q->info.typ))
                    { sprintf(errbuf, ""Qualified member field '%s' has a type that does not correspond to the unique type '%s' defined for elements '<%s>'"", q->sym->name, c_type(q->info.typ), ns_convert(q->sym->name));
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"  	          { if (!is_repetition(q) && !is_anytype(q) && !has_ns_eq(NULL, q->sym->name) && !is_transient(q->info.typ) && q->info.typ->type != Tfun && !(q->info.sto & Sattribute))
                    { e = entry(r, q->sym);
                      if (e)
	              { if ((e->info.sto & Sattribute) != (q->info.sto & Sattribute)|| reftype(e->info.typ) != reftype(q->info.typ))
                        { sprintf(errbuf, ""Qualified member field '%s' has a type that does not correspond to the unique type '%s' defined for elements '<%s>'"", q->sym->name, c_type(q->info.typ), ns_convert(q->sym->name));
",1,unused,3183,unused,"  	          { if (!is_repetition(q) && !is_anytype(q) && !has_ns_eq(NULL, q->sym->name) && !is_transient(q->info.typ) && q->info.typ->type != Tfun && !(q->info.sto & Sattribute))
                    { e = entry(r, q->sym);
                      if (e)
	              { if ((e->info.sto & Sattribute) != (q->info.sto & Sattribute)|| reftype(e->info.typ) != reftype(q->info.typ))
                        { sprintf(errbuf, ""Qualified member field '%s' has a type that does not correspond to the unique type '%s' defined for elements '<%s>'"", q->sym->name, c_type(q->info.typ), ns_convert(q->sym->name));
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"{ Symbol *s;
  Service *sp = NULL;
  char tmp[1024];
  FILE *fd;
  strcpy(tmp, buf);
",1,unused,4934,unused,"{ Symbol *s;
  Service *sp = NULL;
  char tmp[1024];
  FILE *fd;
  strcpy(tmp, buf);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"  { sprintf(strrchr(tmp, '.'), ""_%s_res.xml"", method);
    fprintf(fmsg, ""Saving %s sample SOAP/XML response\n"", tmp);
  }
#else
  strcpy(strrchr(tmp, '.')+1, method);
",1,unused,4945,unused,"  { sprintf(strrchr(tmp, '.'), ""_%s_res.xml"", method);
    fprintf(fmsg, ""Saving %s sample SOAP/XML response\n"", tmp);
  }
#else
  strcpy(strrchr(tmp, '.')+1, method);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"  }
#else
  strcpy(strrchr(tmp, '.')+1, method);
  if (!response)
  { strcat(tmp, "".req.xml"");
",1,unused,4947,unused,"  }
#else
  strcpy(strrchr(tmp, '.')+1, method);
  if (!response)
  { strcat(tmp, "".req.xml"");
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"  { strcat(tmp, "".req.xml"");
    fprintf(fmsg, ""Saving %s sample SOAP/XML request\n"", tmp);
  }
  else
  { strcat(tmp, "".res.xml"");
",1,unused,4951,unused,"  { strcat(tmp, "".req.xml"");
    fprintf(fmsg, ""Saving %s sample SOAP/XML request\n"", tmp);
  }
  else
  { strcat(tmp, "".res.xml"");
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"soap_type(Tnode *typ)
{ char *s, *t = c_ident(typ);
  if (namespaceid)
  { s = (char*)emalloc(strlen(t) + strlen(namespaceid) + 12);
    strcpy(s, ""SOAP_TYPE_"");
",1,unused,5621,unused,"soap_type(Tnode *typ)
{ char *s, *t = c_ident(typ);
  if (namespaceid)
  { s = (char*)emalloc(strlen(t) + strlen(namespaceid) + 12);
    strcpy(s, ""SOAP_TYPE_"");
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"{ char *s, *t = c_ident(typ);
  if (namespaceid)
  { s = (char*)emalloc(strlen(t) + strlen(namespaceid) + 12);
    strcpy(s, ""SOAP_TYPE_"");
    strcat(s, namespaceid);
",1,unused,5622,unused,"{ char *s, *t = c_ident(typ);
  if (namespaceid)
  { s = (char*)emalloc(strlen(t) + strlen(namespaceid) + 12);
    strcpy(s, ""SOAP_TYPE_"");
    strcat(s, namespaceid);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"  if (namespaceid)
  { s = (char*)emalloc(strlen(t) + strlen(namespaceid) + 12);
    strcpy(s, ""SOAP_TYPE_"");
    strcat(s, namespaceid);
    strcat(s, ""_"");
",1,unused,5623,unused,"  if (namespaceid)
  { s = (char*)emalloc(strlen(t) + strlen(namespaceid) + 12);
    strcpy(s, ""SOAP_TYPE_"");
    strcat(s, namespaceid);
    strcat(s, ""_"");
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"    strcat(s, ""_"");
  }
  else
  { s = (char*)emalloc(strlen(t) + 11);
    strcpy(s, ""SOAP_TYPE_"");
",1,unused,5627,unused,"    strcat(s, ""_"");
  }
  else
  { s = (char*)emalloc(strlen(t) + 11);
    strcpy(s, ""SOAP_TYPE_"");
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"  else
  { s = (char*)emalloc(strlen(t) + 11);
    strcpy(s, ""SOAP_TYPE_"");
  }
  strcat(s, t);
",1,unused,5629,unused,"  else
  { s = (char*)emalloc(strlen(t) + 11);
    strcpy(s, ""SOAP_TYPE_"");
  }
  strcat(s, t);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"	return ""string"";
    if (is_wstring(typ))
	return ""wstring"";
    p=(char*) emalloc((10+strlen(q = c_ident((Tnode*)typ->ref)))*sizeof(char));
    strcpy(p,""PointerTo"");
",1,unused,5696,unused,"	return ""string"";
    if (is_wstring(typ))
	return ""wstring"";
    p=(char*) emalloc((10+strlen(q = c_ident((Tnode*)typ->ref)))*sizeof(char));
    strcpy(p,""PointerTo"");
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"    if (is_wstring(typ))
	return ""wstring"";
    p=(char*) emalloc((10+strlen(q = c_ident((Tnode*)typ->ref)))*sizeof(char));
    strcpy(p,""PointerTo"");
    strcat(p,q);
",1,unused,5697,unused,"    if (is_wstring(typ))
	return ""wstring"";
    p=(char*) emalloc((10+strlen(q = c_ident((Tnode*)typ->ref)))*sizeof(char));
    strcpy(p,""PointerTo"");
    strcat(p,q);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"    return p;
  case Tarray:
    p=(char*) emalloc((16+strlen(c_ident((Tnode*)typ->ref)))*sizeof(char));
    if (((Tnode*)typ->ref)->width)
      sprintf(p, ""Array%dOf%s"",typ->width / ((Tnode*) typ->ref)->width,c_ident(typ->ref));
",1,unused,5702,unused,"    return p;
  case Tarray:
    p=(char*) emalloc((16+strlen(c_ident((Tnode*)typ->ref)))*sizeof(char));
    if (((Tnode*)typ->ref)->width)
      sprintf(p, ""Array%dOf%s"",typ->width / ((Tnode*) typ->ref)->width,c_ident(typ->ref));
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"    p=(char*) emalloc((16+strlen(c_ident((Tnode*)typ->ref)))*sizeof(char));
    if (((Tnode*)typ->ref)->width)
      sprintf(p, ""Array%dOf%s"",typ->width / ((Tnode*) typ->ref)->width,c_ident(typ->ref));
    else
      sprintf(p, ""ArrayOf%s"", c_ident((Tnode*)typ->ref));
",1,unused,5704,unused,"    p=(char*) emalloc((16+strlen(c_ident((Tnode*)typ->ref)))*sizeof(char));
    if (((Tnode*)typ->ref)->width)
      sprintf(p, ""Array%dOf%s"",typ->width / ((Tnode*) typ->ref)->width,c_ident(typ->ref));
    else
      sprintf(p, ""ArrayOf%s"", c_ident((Tnode*)typ->ref));
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"    return p;
  case Ttemplate:
    if (typ->ref)
    { p=(char*) emalloc((11+strlen(res_remove(typ->id->name))+strlen(q = c_ident((Tnode*)typ->ref)))*sizeof(char));
      strcpy(p, res_remove(typ->id->name));
",1,unused,5709,unused,"    return p;
  case Ttemplate:
    if (typ->ref)
    { p=(char*) emalloc((11+strlen(res_remove(typ->id->name))+strlen(q = c_ident((Tnode*)typ->ref)))*sizeof(char));
      strcpy(p, res_remove(typ->id->name));
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"  case Ttemplate:
    if (typ->ref)
    { p=(char*) emalloc((11+strlen(res_remove(typ->id->name))+strlen(q = c_ident((Tnode*)typ->ref)))*sizeof(char));
      strcpy(p, res_remove(typ->id->name));
      strcat(p, ""TemplateOf"");
",1,unused,5710,unused,"  case Ttemplate:
    if (typ->ref)
    { p=(char*) emalloc((11+strlen(res_remove(typ->id->name))+strlen(q = c_ident((Tnode*)typ->ref)))*sizeof(char));
      strcpy(p, res_remove(typ->id->name));
      strcat(p, ""TemplateOf"");
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"    if (typ->ref)
    { p=(char*) emalloc((11+strlen(res_remove(typ->id->name))+strlen(q = c_ident((Tnode*)typ->ref)))*sizeof(char));
      strcpy(p, res_remove(typ->id->name));
      strcat(p, ""TemplateOf"");
      strcat(p, q);
",1,unused,5711,unused,"    if (typ->ref)
    { p=(char*) emalloc((11+strlen(res_remove(typ->id->name))+strlen(q = c_ident((Tnode*)typ->ref)))*sizeof(char));
      strcpy(p, res_remove(typ->id->name));
      strcat(p, ""TemplateOf"");
      strcat(p, q);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"{ char *s, *t;
  if (!(s = strchr(tag, ':')))
    return tag;
  s = emalloc(strlen(tag) + 1);
  strcpy(s, tag);
",1,unused,5835,unused,"{ char *s, *t;
  if (!(s = strchr(tag, ':')))
    return tag;
  s = emalloc(strlen(tag) + 1);
  strcpy(s, tag);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"  if (!ns || *s == '-' || (t = strchr(s, ':')))
    return s;
  n = ns_convert(ns);
  t = emalloc(strlen(n) + strlen(s) + 2);
  strcpy(t, n);
",1,unused,5894,unused,"  if (!ns || *s == '-' || (t = strchr(s, ':')))
    return s;
  n = ns_convert(ns);
  t = emalloc(strlen(n) + strlen(s) + 2);
  strcpy(t, n);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"    return s;
  n = ns_convert(ns);
  t = emalloc(strlen(n) + strlen(s) + 2);
  strcpy(t, n);
  strcat(t, "":"");
",1,unused,5895,unused,"    return s;
  n = ns_convert(ns);
  t = emalloc(strlen(n) + strlen(s) + 2);
  strcpy(t, n);
  strcat(t, "":"");
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"  n = ns_convert(ns);
  t = emalloc(strlen(n) + strlen(s) + 2);
  strcpy(t, n);
  strcat(t, "":"");
  strcat(t, s);
",1,unused,5896,unused,"  n = ns_convert(ns);
  t = emalloc(strlen(n) + strlen(s) + 2);
  strcpy(t, n);
  strcat(t, "":"");
  strcat(t, s);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"      s[i] = t[i];
  }
  s[i] = '\0';
  if (suffix)
    strcat(s, suffix);
",1,unused,5941,unused,"      s[i] = t[i];
  }
  s[i] = '\0';
  if (suffix)
    strcat(s, suffix);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"  s[i] = '\0';
  if (suffix)
    strcat(s, suffix);
  if (is_keyword(t))
    strcat(s, ""_"");
",1,unused,5943,unused,"  s[i] = '\0';
  if (suffix)
    strcat(s, suffix);
  if (is_keyword(t))
    strcat(s, ""_"");
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"ns_fname(char *tag)
{ char *s;
  size_t i;
  s = emalloc(strlen(tag) + 1);
  strcpy(s, tag);
",1,unused,5952,unused,"ns_fname(char *tag)
{ char *s;
  size_t i;
  s = emalloc(strlen(tag) + 1);
  strcpy(s, tag);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"  if (is_dynamic_array(typ) && !is_binary(typ) && !has_ns(typ) && !is_untyped(typ))
  { s = ns_remove(wsdl_type(((Table*)typ->ref)->list->info.typ, NULL));
    if (ns && *ns)
    { t = (char*)emalloc(strlen(s)+strlen(ns_convert(ns))+13);
      strcpy(t, ns_convert(ns));
",1,unused,6122,unused,"  if (is_dynamic_array(typ) && !is_binary(typ) && !has_ns(typ) && !is_untyped(typ))
  { s = ns_remove(wsdl_type(((Table*)typ->ref)->list->info.typ, NULL));
    if (ns && *ns)
    { t = (char*)emalloc(strlen(s)+strlen(ns_convert(ns))+13);
      strcpy(t, ns_convert(ns));
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"  { s = ns_remove(wsdl_type(((Table*)typ->ref)->list->info.typ, NULL));
    if (ns && *ns)
    { t = (char*)emalloc(strlen(s)+strlen(ns_convert(ns))+13);
      strcpy(t, ns_convert(ns));
      strcat(t, "":"");
",1,unused,6123,unused,"  { s = ns_remove(wsdl_type(((Table*)typ->ref)->list->info.typ, NULL));
    if (ns && *ns)
    { t = (char*)emalloc(strlen(s)+strlen(ns_convert(ns))+13);
      strcpy(t, ns_convert(ns));
      strcat(t, "":"");
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"    if (ns && *ns)
    { t = (char*)emalloc(strlen(s)+strlen(ns_convert(ns))+13);
      strcpy(t, ns_convert(ns));
      strcat(t, "":"");
      strcat(t, ""ArrayOf"");
",1,unused,6124,unused,"    if (ns && *ns)
    { t = (char*)emalloc(strlen(s)+strlen(ns_convert(ns))+13);
      strcpy(t, ns_convert(ns));
      strcat(t, "":"");
      strcat(t, ""ArrayOf"");
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"      strcat(t, ""ArrayOf"");
    }
    else
    { t = (char*)emalloc(strlen(s)+12);
      strcpy(t, ""ArrayOf"");
",1,unused,6128,unused,"      strcat(t, ""ArrayOf"");
    }
    else
    { t = (char*)emalloc(strlen(s)+12);
      strcpy(t, ""ArrayOf"");
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"    else
    { t = (char*)emalloc(strlen(s)+12);
      strcpy(t, ""ArrayOf"");
    }
    strcat(t, s);
",1,unused,6130,unused,"    else
    { t = (char*)emalloc(strlen(s)+12);
      strcpy(t, ""ArrayOf"");
    }
    strcat(t, s);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"    }
    strcat(t, s);
    d = get_Darraydims(typ);
    if (d)
      sprintf(t+strlen(t), ""%dD"", d);
",1,unused,6133,unused,"    }
    strcat(t, s);
    d = get_Darraydims(typ);
    if (d)
      sprintf(t+strlen(t), ""%dD"", d);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"      return ""string"";
    }
    if (ns && *ns)
    { s = (char*)emalloc((strlen(ns_convert(ns))+strlen(c_ident(typ))+2)*sizeof(char));
      strcpy(s, ns_convert(ns));
",1,unused,6207,unused,"      return ""string"";
    }
    if (ns && *ns)
    { s = (char*)emalloc((strlen(ns_convert(ns))+strlen(c_ident(typ))+2)*sizeof(char));
      strcpy(s, ns_convert(ns));
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"    }
    if (ns && *ns)
    { s = (char*)emalloc((strlen(ns_convert(ns))+strlen(c_ident(typ))+2)*sizeof(char));
      strcpy(s, ns_convert(ns));
      strcat(s, "":"");
",1,unused,6208,unused,"    }
    if (ns && *ns)
    { s = (char*)emalloc((strlen(ns_convert(ns))+strlen(c_ident(typ))+2)*sizeof(char));
      strcpy(s, ns_convert(ns));
      strcat(s, "":"");
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"    if (ns && *ns)
    { s = (char*)emalloc((strlen(ns_convert(ns))+strlen(c_ident(typ))+2)*sizeof(char));
      strcpy(s, ns_convert(ns));
      strcat(s, "":"");
      strcat(s, c_ident(typ));
",1,unused,6209,unused,"    if (ns && *ns)
    { s = (char*)emalloc((strlen(ns_convert(ns))+strlen(c_ident(typ))+2)*sizeof(char));
      strcpy(s, ns_convert(ns));
      strcat(s, "":"");
      strcat(s, c_ident(typ));
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"  case Tstruct:
  case Tclass:
    if (!has_ns(typ) && ns && *ns)
    { s = (char*)emalloc((strlen(ns_convert(ns))+strlen(typ->id->name)+2)*sizeof(char));
      strcpy(s, ns_convert(ns));
",1,unused,6224,unused,"  case Tstruct:
  case Tclass:
    if (!has_ns(typ) && ns && *ns)
    { s = (char*)emalloc((strlen(ns_convert(ns))+strlen(typ->id->name)+2)*sizeof(char));
      strcpy(s, ns_convert(ns));
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"  case Tclass:
    if (!has_ns(typ) && ns && *ns)
    { s = (char*)emalloc((strlen(ns_convert(ns))+strlen(typ->id->name)+2)*sizeof(char));
      strcpy(s, ns_convert(ns));
      strcat(s, "":"");
",1,unused,6225,unused,"  case Tclass:
    if (!has_ns(typ) && ns && *ns)
    { s = (char*)emalloc((strlen(ns_convert(ns))+strlen(typ->id->name)+2)*sizeof(char));
      strcpy(s, ns_convert(ns));
      strcat(s, "":"");
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"    if (!has_ns(typ) && ns && *ns)
    { s = (char*)emalloc((strlen(ns_convert(ns))+strlen(typ->id->name)+2)*sizeof(char));
      strcpy(s, ns_convert(ns));
      strcat(s, "":"");
      strcat(s, ns_convert(typ->id->name));
",1,unused,6226,unused,"    if (!has_ns(typ) && ns && *ns)
    { s = (char*)emalloc((strlen(ns_convert(ns))+strlen(typ->id->name)+2)*sizeof(char));
      strcpy(s, ns_convert(ns));
      strcat(s, "":"");
      strcat(s, ns_convert(typ->id->name));
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"    return ""ULONG64"";
  case Ttime:
    return ""time_t"";
  case Tstruct:p=(char*) emalloc((8+strlen(ident(typ->id->name))) *sizeof(char));
    strcpy(p, ""struct "");
",1,unused,6346,unused,"    return ""ULONG64"";
  case Ttime:
    return ""time_t"";
  case Tstruct:p=(char*) emalloc((8+strlen(ident(typ->id->name))) *sizeof(char));
    strcpy(p, ""struct "");
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"  case Ttime:
    return ""time_t"";
  case Tstruct:p=(char*) emalloc((8+strlen(ident(typ->id->name))) *sizeof(char));
    strcpy(p, ""struct "");
    strcat(p, ident(typ->id->name));
",1,unused,6347,unused,"  case Ttime:
    return ""time_t"";
  case Tstruct:p=(char*) emalloc((8+strlen(ident(typ->id->name))) *sizeof(char));
    strcpy(p, ""struct "");
    strcat(p, ident(typ->id->name));
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"  case Tclass:
   p = ident(typ->id->name);
   break;
  case Tunion: p=(char*) emalloc((7+strlen(ident(typ->id->name))) *sizeof(char));
    strcpy(p, ""union "");
",1,unused,6353,unused,"  case Tclass:
   p = ident(typ->id->name);
   break;
  case Tunion: p=(char*) emalloc((7+strlen(ident(typ->id->name))) *sizeof(char));
    strcpy(p, ""union "");
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"   p = ident(typ->id->name);
   break;
  case Tunion: p=(char*) emalloc((7+strlen(ident(typ->id->name))) *sizeof(char));
    strcpy(p, ""union "");
    strcat(p, ident(typ->id->name));
",1,unused,6354,unused,"   p = ident(typ->id->name);
   break;
  case Tunion: p=(char*) emalloc((7+strlen(ident(typ->id->name))) *sizeof(char));
    strcpy(p, ""union "");
    strcat(p, ident(typ->id->name));
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"  case Tenum:
    if ((Table*)typ->ref == booltable)
      return ""bool"";
    p=(char*) emalloc((6+strlen(ident(typ->id->name))) *sizeof(char));
    strcpy(p, ""enum "");
",1,unused,6360,unused,"  case Tenum:
    if ((Table*)typ->ref == booltable)
      return ""bool"";
    p=(char*) emalloc((6+strlen(ident(typ->id->name))) *sizeof(char));
    strcpy(p, ""enum "");
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"    if ((Table*)typ->ref == booltable)
      return ""bool"";
    p=(char*) emalloc((6+strlen(ident(typ->id->name))) *sizeof(char));
    strcpy(p, ""enum "");
    strcat(p, ident(typ->id->name));
",1,unused,6361,unused,"    if ((Table*)typ->ref == booltable)
      return ""bool"";
    p=(char*) emalloc((6+strlen(ident(typ->id->name))) *sizeof(char));
    strcpy(p, ""enum "");
    strcat(p, ident(typ->id->name));
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"      typ = (Tnode*)typ->ref;
    }
    p=(char*) emalloc((12+strlen(q = c_type((Tnode*)typ->ref))) *sizeof(char));
    if (((Tnode*)typ->ref)->type == Tpointer)
      sprintf(p,""%s"",c_type((Tnode*)typ->ref));
",1,unused,6376,unused,"      typ = (Tnode*)typ->ref;
    }
    p=(char*) emalloc((12+strlen(q = c_type((Tnode*)typ->ref))) *sizeof(char));
    if (((Tnode*)typ->ref)->type == Tpointer)
      sprintf(p,""%s"",c_type((Tnode*)typ->ref));
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"    p=(char*) emalloc((12+strlen(q = c_type((Tnode*)typ->ref))) *sizeof(char));
    if (((Tnode*)typ->ref)->type == Tpointer)
      sprintf(p,""%s"",c_type((Tnode*)typ->ref));
    else
      strcpy(p, q);
",1,unused,6378,unused,"    p=(char*) emalloc((12+strlen(q = c_type((Tnode*)typ->ref))) *sizeof(char));
    if (((Tnode*)typ->ref)->type == Tpointer)
      sprintf(p,""%s"",c_type((Tnode*)typ->ref));
    else
      strcpy(p, q);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"      strcpy(p, q);
    typ = temp;
    while(typ->type==Tarray){
      if (((Tnode*) typ->ref)->width)
      { sprintf(tempBuf,""[%d]"",(typ->width / ((Tnode*) typ->ref)->width));
",1,unused,6382,unused,"      strcpy(p, q);
    typ = temp;
    while(typ->type==Tarray){
      if (((Tnode*) typ->ref)->width)
      { sprintf(tempBuf,""[%d]"",(typ->width / ((Tnode*) typ->ref)->width));
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"    typ = temp;
    while(typ->type==Tarray){
      if (((Tnode*) typ->ref)->width)
      { sprintf(tempBuf,""[%d]"",(typ->width / ((Tnode*) typ->ref)->width));
        strcat(p,tempBuf);
",1,unused,6383,unused,"    typ = temp;
    while(typ->type==Tarray){
      if (((Tnode*) typ->ref)->width)
      { sprintf(tempBuf,""[%d]"",(typ->width / ((Tnode*) typ->ref)->width));
        strcat(p,tempBuf);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"    break;
  case Ttemplate:
    if (typ->ref)
    { p=(char*)emalloc((strlen(q = c_type((Tnode*)typ->ref))+strlen(ident(typ->id->name))+4) *sizeof(char));
      strcpy(p, ident(typ->id->name));
",1,unused,6391,unused,"    break;
  case Ttemplate:
    if (typ->ref)
    { p=(char*)emalloc((strlen(q = c_type((Tnode*)typ->ref))+strlen(ident(typ->id->name))+4) *sizeof(char));
      strcpy(p, ident(typ->id->name));
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"  case Ttemplate:
    if (typ->ref)
    { p=(char*)emalloc((strlen(q = c_type((Tnode*)typ->ref))+strlen(ident(typ->id->name))+4) *sizeof(char));
      strcpy(p, ident(typ->id->name));
      strcat(p, ""<"");
",1,unused,6392,unused,"  case Ttemplate:
    if (typ->ref)
    { p=(char*)emalloc((strlen(q = c_type((Tnode*)typ->ref))+strlen(ident(typ->id->name))+4) *sizeof(char));
      strcpy(p, ident(typ->id->name));
      strcat(p, ""<"");
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"    if (typ->ref)
    { p=(char*)emalloc((strlen(q = c_type((Tnode*)typ->ref))+strlen(ident(typ->id->name))+4) *sizeof(char));
      strcpy(p, ident(typ->id->name));
      strcat(p, ""<"");
      strcat(p, q);
",1,unused,6393,unused,"    if (typ->ref)
    { p=(char*)emalloc((strlen(q = c_type((Tnode*)typ->ref))+strlen(ident(typ->id->name))+4) *sizeof(char));
      strcpy(p, ident(typ->id->name));
      strcat(p, ""<"");
      strcat(p, q);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"    { p=(char*)emalloc((strlen(q = c_type((Tnode*)typ->ref))+strlen(ident(typ->id->name))+4) *sizeof(char));
      strcpy(p, ident(typ->id->name));
      strcat(p, ""<"");
      strcat(p, q);
      strcat(p, "" >"");
",1,unused,6394,unused,"    { p=(char*)emalloc((strlen(q = c_type((Tnode*)typ->ref))+strlen(ident(typ->id->name))+4) *sizeof(char));
      strcpy(p, ident(typ->id->name));
      strcat(p, ""<"");
      strcat(p, q);
      strcat(p, "" >"");
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"{ char *p;
  static char buf[256];
  if (sto & Sconst)
  { p = c_storage(sto & ~Sconst);
    strcat(p, ""const "");
",1,unused,6409,unused,"{ char *p;
  static char buf[256];
  if (sto & Sconst)
  { p = c_storage(sto & ~Sconst);
    strcat(p, ""const "");
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"    return p;
  }
  if (sto & Sconstptr)
  { p = c_storage(sto & ~Sconstptr);
    strcat(p, ""const "");
",1,unused,6414,unused,"    return p;
  }
  if (sto & Sconstptr)
  { p = c_storage(sto & ~Sconstptr);
    strcat(p, ""const "");
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"    return p;
  }
  if (sto & Sauto)
  { p = c_storage(sto & ~Sauto);
    strcat(p, ""auto "");
",1,unused,6419,unused,"    return p;
  }
  if (sto & Sauto)
  { p = c_storage(sto & ~Sauto);
    strcat(p, ""auto "");
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"    return p;
  }
  if (sto & Sregister)
  { p = c_storage(sto & ~Sregister);
    strcat(p, ""register "");
",1,unused,6424,unused,"    return p;
  }
  if (sto & Sregister)
  { p = c_storage(sto & ~Sregister);
    strcat(p, ""register "");
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"    return p;
  }
  if (sto & Sstatic)
  { p = c_storage(sto & ~Sstatic);
    strcat(p, ""static "");
",1,unused,6429,unused,"    return p;
  }
  if (sto & Sstatic)
  { p = c_storage(sto & ~Sstatic);
    strcat(p, ""static "");
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"    return p;
  }
  if (sto & Sexplicit)
  { p = c_storage(sto & ~Sexplicit);
    strcat(p, ""explicit "");
",1,unused,6434,unused,"    return p;
  }
  if (sto & Sexplicit)
  { p = c_storage(sto & ~Sexplicit);
    strcat(p, ""explicit "");
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"    return p;
  }
  if (sto & Stypedef)
  { p = c_storage(sto & ~Stypedef);
    strcat(p, ""typedef "");
",1,unused,6443,unused,"    return p;
  }
  if (sto & Stypedef)
  { p = c_storage(sto & ~Stypedef);
    strcat(p, ""typedef "");
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"    return p;
  }
  if (sto & Svirtual)
  { p = c_storage(sto & ~Svirtual);
    strcat(p, ""virtual "");
",1,unused,6448,unused,"    return p;
  }
  if (sto & Svirtual)
  { p = c_storage(sto & ~Svirtual);
    strcat(p, ""virtual "");
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"    return p;
  }
  if (sto & Sfriend)
  { p = c_storage(sto & ~Sfriend);
    strcat(p, ""friend "");
",1,unused,6453,unused,"    return p;
  }
  if (sto & Sfriend)
  { p = c_storage(sto & ~Sfriend);
    strcat(p, ""friend "");
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"    return p;
  }
  if (sto & Sinline)
  { p = c_storage(sto & ~Sinline);
    strcat(p, ""inline "");
",1,unused,6458,unused,"    return p;
  }
  if (sto & Sinline)
  { p = c_storage(sto & ~Sinline);
    strcat(p, ""inline "");
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"      case Tllong:
      case Tulong:
      case Tullong:
      case Ttime:
        sprintf(buf, "" = ""SOAP_LONG_FORMAT, e->info.val.i);
",1,unused,6483,unused,"      case Tllong:
      case Tulong:
      case Tullong:
      case Ttime:
        sprintf(buf, "" = ""SOAP_LONG_FORMAT, e->info.val.i);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"	break;
      case Tfloat:
      case Tdouble:
      case Tldouble:
        sprintf(buf, "" = %f"", e->info.val.r);
",1,unused,6488,unused,"	break;
      case Tfloat:
      case Tdouble:
      case Tldouble:
        sprintf(buf, "" = %f"", e->info.val.r);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"      case Tldouble:
        sprintf(buf, "" = %f"", e->info.val.r);
	break;
      case Tenum:
        sprintf(buf, "" = (%s)""SOAP_LONG_FORMAT, c_type(e->info.typ), e->info.val.i);
",1,unused,6491,unused,"      case Tldouble:
        sprintf(buf, "" = %f"", e->info.val.r);
	break;
      case Tenum:
        sprintf(buf, "" = (%s)""SOAP_LONG_FORMAT, c_type(e->info.typ), e->info.val.i);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"        sprintf(buf, "" = (%s)""SOAP_LONG_FORMAT, c_type(e->info.typ), e->info.val.i);
	break;
      default:
	if (e->info.val.s && strlen(e->info.val.s) < sizeof(buf)-6)
          sprintf(buf, "" = (char*)\""%s\"""", cstring(e->info.val.s));
",1,unused,6495,unused,"        sprintf(buf, "" = (%s)""SOAP_LONG_FORMAT, c_type(e->info.typ), e->info.val.i);
	break;
      default:
	if (e->info.val.s && strlen(e->info.val.s) < sizeof(buf)-6)
          sprintf(buf, "" = (char*)\""%s\"""", cstring(e->info.val.s));
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"      default:
	if (e->info.val.s && strlen(e->info.val.s) < sizeof(buf)-6)
          sprintf(buf, "" = (char*)\""%s\"""", cstring(e->info.val.s));
	else if (e->info.typ->type == Tpointer)
          sprintf(buf, "" = NULL"");
",1,unused,6497,unused,"      default:
	if (e->info.val.s && strlen(e->info.val.s) < sizeof(buf)-6)
          sprintf(buf, "" = (char*)\""%s\"""", cstring(e->info.val.s));
	else if (e->info.typ->type == Tpointer)
          sprintf(buf, "" = NULL"");
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"    p = id;
    break;
  case Tvoid:
    p = (char*)emalloc(6+strlen(id));
    strcpy(p, ""void "");
",1,unused,6523,unused,"    p = id;
    break;
  case Tvoid:
    p = (char*)emalloc(6+strlen(id));
    strcpy(p, ""void "");
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"    break;
  case Tvoid:
    p = (char*)emalloc(6+strlen(id));
    strcpy(p, ""void "");
    strcat(p, id);
",1,unused,6524,unused,"    break;
  case Tvoid:
    p = (char*)emalloc(6+strlen(id));
    strcpy(p, ""void "");
    strcat(p, id);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"    strcat(p, id);
    break;
  case Tchar:
    p = (char*)emalloc(6+strlen(id));
    strcpy(p, ""char "");
",1,unused,6528,unused,"    strcat(p, id);
    break;
  case Tchar:
    p = (char*)emalloc(6+strlen(id));
    strcpy(p, ""char "");
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"    break;
  case Tchar:
    p = (char*)emalloc(6+strlen(id));
    strcpy(p, ""char "");
    strcat(p, id);
",1,unused,6529,unused,"    break;
  case Tchar:
    p = (char*)emalloc(6+strlen(id));
    strcpy(p, ""char "");
    strcat(p, id);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"    strcat(p, id);
    break;
  case Twchar:
    p = (char*)emalloc(9+strlen(id));
    strcpy(p, ""wchar_t "");
",1,unused,6533,unused,"    strcat(p, id);
    break;
  case Twchar:
    p = (char*)emalloc(9+strlen(id));
    strcpy(p, ""wchar_t "");
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"    break;
  case Twchar:
    p = (char*)emalloc(9+strlen(id));
    strcpy(p, ""wchar_t "");
    strcat(p, id);
",1,unused,6534,unused,"    break;
  case Twchar:
    p = (char*)emalloc(9+strlen(id));
    strcpy(p, ""wchar_t "");
    strcat(p, id);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"    strcat(p, id);
    break;
  case Tshort:
    p = (char*)emalloc(7+strlen(id));
    strcpy(p, ""short "");
",1,unused,6538,unused,"    strcat(p, id);
    break;
  case Tshort:
    p = (char*)emalloc(7+strlen(id));
    strcpy(p, ""short "");
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"    break;
  case Tshort:
    p = (char*)emalloc(7+strlen(id));
    strcpy(p, ""short "");
    strcat(p, id);
",1,unused,6539,unused,"    break;
  case Tshort:
    p = (char*)emalloc(7+strlen(id));
    strcpy(p, ""short "");
    strcat(p, id);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"    strcat(p, id);
    break;
  case Tint  :
    p = (char*)emalloc(5+strlen(id));
    strcpy(p, ""int "");
",1,unused,6543,unused,"    strcat(p, id);
    break;
  case Tint  :
    p = (char*)emalloc(5+strlen(id));
    strcpy(p, ""int "");
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"    break;
  case Tint  :
    p = (char*)emalloc(5+strlen(id));
    strcpy(p, ""int "");
    strcat(p, id);
",1,unused,6544,unused,"    break;
  case Tint  :
    p = (char*)emalloc(5+strlen(id));
    strcpy(p, ""int "");
    strcat(p, id);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"    strcat(p, id);
    break;
  case Tlong  :
    p = (char*)emalloc(6+strlen(id));
    strcpy(p, ""long "");
",1,unused,6548,unused,"    strcat(p, id);
    break;
  case Tlong  :
    p = (char*)emalloc(6+strlen(id));
    strcpy(p, ""long "");
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"    break;
  case Tlong  :
    p = (char*)emalloc(6+strlen(id));
    strcpy(p, ""long "");
    strcat(p, id);
",1,unused,6549,unused,"    break;
  case Tlong  :
    p = (char*)emalloc(6+strlen(id));
    strcpy(p, ""long "");
    strcat(p, id);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"    strcat(p, id);
    break;
  case Tllong  :
    p = (char*)emalloc(8+strlen(id));
    strcpy(p, ""LONG64 "");
",1,unused,6553,unused,"    strcat(p, id);
    break;
  case Tllong  :
    p = (char*)emalloc(8+strlen(id));
    strcpy(p, ""LONG64 "");
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"    break;
  case Tllong  :
    p = (char*)emalloc(8+strlen(id));
    strcpy(p, ""LONG64 "");
    strcat(p, id);
",1,unused,6554,unused,"    break;
  case Tllong  :
    p = (char*)emalloc(8+strlen(id));
    strcpy(p, ""LONG64 "");
    strcat(p, id);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"    strcat(p, id);
    break;
  case Tfloat:
    p = (char*)emalloc(7+strlen(id));
    strcpy(p, ""float "");
",1,unused,6558,unused,"    strcat(p, id);
    break;
  case Tfloat:
    p = (char*)emalloc(7+strlen(id));
    strcpy(p, ""float "");
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"    break;
  case Tfloat:
    p = (char*)emalloc(7+strlen(id));
    strcpy(p, ""float "");
    strcat(p, id);
",1,unused,6559,unused,"    break;
  case Tfloat:
    p = (char*)emalloc(7+strlen(id));
    strcpy(p, ""float "");
    strcat(p, id);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"    strcat(p, id);
    break;
  case Tdouble:
    p = (char*)emalloc(8+strlen(id));
    strcpy(p, ""double "");
",1,unused,6563,unused,"    strcat(p, id);
    break;
  case Tdouble:
    p = (char*)emalloc(8+strlen(id));
    strcpy(p, ""double "");
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"    break;
  case Tdouble:
    p = (char*)emalloc(8+strlen(id));
    strcpy(p, ""double "");
    strcat(p, id);
",1,unused,6564,unused,"    break;
  case Tdouble:
    p = (char*)emalloc(8+strlen(id));
    strcpy(p, ""double "");
    strcat(p, id);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"    strcat(p, id);
    break;
  case Tldouble:
    p = (char*)emalloc(13+strlen(id));
    strcpy(p, ""long double "");
",1,unused,6568,unused,"    strcat(p, id);
    break;
  case Tldouble:
    p = (char*)emalloc(13+strlen(id));
    strcpy(p, ""long double "");
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"    break;
  case Tldouble:
    p = (char*)emalloc(13+strlen(id));
    strcpy(p, ""long double "");
    strcat(p, id);
",1,unused,6569,unused,"    break;
  case Tldouble:
    p = (char*)emalloc(13+strlen(id));
    strcpy(p, ""long double "");
    strcat(p, id);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"    strcat(p, id);
    break;
  case Tuchar:
    p = (char*)emalloc(15+strlen(id));
    strcpy(p, ""unsigned char "");
",1,unused,6573,unused,"    strcat(p, id);
    break;
  case Tuchar:
    p = (char*)emalloc(15+strlen(id));
    strcpy(p, ""unsigned char "");
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"    break;
  case Tuchar:
    p = (char*)emalloc(15+strlen(id));
    strcpy(p, ""unsigned char "");
    strcat(p, id);
",1,unused,6574,unused,"    break;
  case Tuchar:
    p = (char*)emalloc(15+strlen(id));
    strcpy(p, ""unsigned char "");
    strcat(p, id);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"    strcat(p, id);
    break;
  case Tushort:
    p = (char*)emalloc(16+strlen(id));
    strcpy(p, ""unsigned short "");
",1,unused,6578,unused,"    strcat(p, id);
    break;
  case Tushort:
    p = (char*)emalloc(16+strlen(id));
    strcpy(p, ""unsigned short "");
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"    break;
  case Tushort:
    p = (char*)emalloc(16+strlen(id));
    strcpy(p, ""unsigned short "");
    strcat(p, id);
",1,unused,6579,unused,"    break;
  case Tushort:
    p = (char*)emalloc(16+strlen(id));
    strcpy(p, ""unsigned short "");
    strcat(p, id);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"    strcat(p, id);
    break;
  case Tuint:
    p = (char*)emalloc(14+strlen(id));
    strcpy(p, ""unsigned int "");
",1,unused,6583,unused,"    strcat(p, id);
    break;
  case Tuint:
    p = (char*)emalloc(14+strlen(id));
    strcpy(p, ""unsigned int "");
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"    break;
  case Tuint:
    p = (char*)emalloc(14+strlen(id));
    strcpy(p, ""unsigned int "");
    strcat(p, id);
",1,unused,6584,unused,"    break;
  case Tuint:
    p = (char*)emalloc(14+strlen(id));
    strcpy(p, ""unsigned int "");
    strcat(p, id);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"    strcat(p, id);
    break;
  case Tulong:
    p = (char*)emalloc(15+strlen(id));
    strcpy(p, ""unsigned long "");
",1,unused,6588,unused,"    strcat(p, id);
    break;
  case Tulong:
    p = (char*)emalloc(15+strlen(id));
    strcpy(p, ""unsigned long "");
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"    break;
  case Tulong:
    p = (char*)emalloc(15+strlen(id));
    strcpy(p, ""unsigned long "");
    strcat(p, id);
",1,unused,6589,unused,"    break;
  case Tulong:
    p = (char*)emalloc(15+strlen(id));
    strcpy(p, ""unsigned long "");
    strcat(p, id);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"    strcat(p, id);
    break;
  case Tullong:
    p = (char*)emalloc(9+strlen(id));
    strcpy(p, ""ULONG64 "");
",1,unused,6593,unused,"    strcat(p, id);
    break;
  case Tullong:
    p = (char*)emalloc(9+strlen(id));
    strcpy(p, ""ULONG64 "");
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"    break;
  case Tullong:
    p = (char*)emalloc(9+strlen(id));
    strcpy(p, ""ULONG64 "");
    strcat(p, id);
",1,unused,6594,unused,"    break;
  case Tullong:
    p = (char*)emalloc(9+strlen(id));
    strcpy(p, ""ULONG64 "");
    strcat(p, id);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"    strcat(p, id);
    break;
  case Ttime:
    p = (char*)emalloc(8+strlen(id));
    strcpy(p, ""time_t "");
",1,unused,6598,unused,"    strcat(p, id);
    break;
  case Ttime:
    p = (char*)emalloc(8+strlen(id));
    strcpy(p, ""time_t "");
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"    break;
  case Ttime:
    p = (char*)emalloc(8+strlen(id));
    strcpy(p, ""time_t "");
    strcat(p, id);
",1,unused,6599,unused,"    break;
  case Ttime:
    p = (char*)emalloc(8+strlen(id));
    strcpy(p, ""time_t "");
    strcat(p, id);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"    strcat(p, id);
    break;
  case Tstruct:
    p=(char*) emalloc((9+strlen(ident(typ->id->name))+strlen(id)) *sizeof(char));
    strcpy(p, ""struct "");
",1,unused,6603,unused,"    strcat(p, id);
    break;
  case Tstruct:
    p=(char*) emalloc((9+strlen(ident(typ->id->name))+strlen(id)) *sizeof(char));
    strcpy(p, ""struct "");
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"    break;
  case Tstruct:
    p=(char*) emalloc((9+strlen(ident(typ->id->name))+strlen(id)) *sizeof(char));
    strcpy(p, ""struct "");
    strcat(p, ident(typ->id->name));
",1,unused,6604,unused,"    break;
  case Tstruct:
    p=(char*) emalloc((9+strlen(ident(typ->id->name))+strlen(id)) *sizeof(char));
    strcpy(p, ""struct "");
    strcat(p, ident(typ->id->name));
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"  case Tstruct:
    p=(char*) emalloc((9+strlen(ident(typ->id->name))+strlen(id)) *sizeof(char));
    strcpy(p, ""struct "");
    strcat(p, ident(typ->id->name));
    strcat(p, "" "");
",1,unused,6605,unused,"  case Tstruct:
    p=(char*) emalloc((9+strlen(ident(typ->id->name))+strlen(id)) *sizeof(char));
    strcpy(p, ""struct "");
    strcat(p, ident(typ->id->name));
    strcat(p, "" "");
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"    p=(char*) emalloc((9+strlen(ident(typ->id->name))+strlen(id)) *sizeof(char));
    strcpy(p, ""struct "");
    strcat(p, ident(typ->id->name));
    strcat(p, "" "");
    strcat(p, id);
",1,unused,6606,unused,"    p=(char*) emalloc((9+strlen(ident(typ->id->name))+strlen(id)) *sizeof(char));
    strcpy(p, ""struct "");
    strcat(p, ident(typ->id->name));
    strcat(p, "" "");
    strcat(p, id);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"    break;
  case Tclass:
    if (!typ->generated && !is_imported(typ))
    { p=(char*) emalloc((8+strlen(ident(typ->id->name))+strlen(id)) *sizeof(char));
      strcpy(p, ""class "");
",1,unused,6611,unused,"    break;
  case Tclass:
    if (!typ->generated && !is_imported(typ))
    { p=(char*) emalloc((8+strlen(ident(typ->id->name))+strlen(id)) *sizeof(char));
      strcpy(p, ""class "");
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"  case Tclass:
    if (!typ->generated && !is_imported(typ))
    { p=(char*) emalloc((8+strlen(ident(typ->id->name))+strlen(id)) *sizeof(char));
      strcpy(p, ""class "");
      strcat(p, ident(typ->id->name));
",1,unused,6612,unused,"  case Tclass:
    if (!typ->generated && !is_imported(typ))
    { p=(char*) emalloc((8+strlen(ident(typ->id->name))+strlen(id)) *sizeof(char));
      strcpy(p, ""class "");
      strcat(p, ident(typ->id->name));
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"      typ->generated = True;
    }
    else
    { p=(char*) emalloc((2+strlen(ident(typ->id->name))+strlen(id)) *sizeof(char));
      strcpy(p, ident(typ->id->name));
",1,unused,6617,unused,"      typ->generated = True;
    }
    else
    { p=(char*) emalloc((2+strlen(ident(typ->id->name))+strlen(id)) *sizeof(char));
      strcpy(p, ident(typ->id->name));
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"    else
    { p=(char*) emalloc((2+strlen(ident(typ->id->name))+strlen(id)) *sizeof(char));
      strcpy(p, ident(typ->id->name));
    }
    strcat(p, "" "");
",1,unused,6619,unused,"    else
    { p=(char*) emalloc((2+strlen(ident(typ->id->name))+strlen(id)) *sizeof(char));
      strcpy(p, ident(typ->id->name));
    }
    strcat(p, "" "");
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"    { p=(char*) emalloc((2+strlen(ident(typ->id->name))+strlen(id)) *sizeof(char));
      strcpy(p, ident(typ->id->name));
    }
    strcat(p, "" "");
    strcat(p, id);
",1,unused,6620,unused,"    { p=(char*) emalloc((2+strlen(ident(typ->id->name))+strlen(id)) *sizeof(char));
      strcpy(p, ident(typ->id->name));
    }
    strcat(p, "" "");
    strcat(p, id);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"    strcat(p, id);
    break;
  case Tunion:
    p=(char*) emalloc((8+strlen(ident(typ->id->name))+strlen(id)) *sizeof(char));
    strcpy(p, ""union "");
",1,unused,6624,unused,"    strcat(p, id);
    break;
  case Tunion:
    p=(char*) emalloc((8+strlen(ident(typ->id->name))+strlen(id)) *sizeof(char));
    strcpy(p, ""union "");
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"    break;
  case Tunion:
    p=(char*) emalloc((8+strlen(ident(typ->id->name))+strlen(id)) *sizeof(char));
    strcpy(p, ""union "");
    strcat(p, ident(typ->id->name));
",1,unused,6625,unused,"    break;
  case Tunion:
    p=(char*) emalloc((8+strlen(ident(typ->id->name))+strlen(id)) *sizeof(char));
    strcpy(p, ""union "");
    strcat(p, ident(typ->id->name));
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"  case Tunion:
    p=(char*) emalloc((8+strlen(ident(typ->id->name))+strlen(id)) *sizeof(char));
    strcpy(p, ""union "");
    strcat(p, ident(typ->id->name));
    strcat(p, "" "");
",1,unused,6626,unused,"  case Tunion:
    p=(char*) emalloc((8+strlen(ident(typ->id->name))+strlen(id)) *sizeof(char));
    strcpy(p, ""union "");
    strcat(p, ident(typ->id->name));
    strcat(p, "" "");
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"    p=(char*) emalloc((8+strlen(ident(typ->id->name))+strlen(id)) *sizeof(char));
    strcpy(p, ""union "");
    strcat(p, ident(typ->id->name));
    strcat(p, "" "");
    strcat(p, id);
",1,unused,6627,unused,"    p=(char*) emalloc((8+strlen(ident(typ->id->name))+strlen(id)) *sizeof(char));
    strcpy(p, ""union "");
    strcat(p, ident(typ->id->name));
    strcat(p, "" "");
    strcat(p, id);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"    break;
  case Tenum:
    if ((Table*)typ->ref == booltable)
    { p = (char*)emalloc((strlen(id)+6)*sizeof(char));
      strcpy(p, ""bool "");
",1,unused,6632,unused,"    break;
  case Tenum:
    if ((Table*)typ->ref == booltable)
    { p = (char*)emalloc((strlen(id)+6)*sizeof(char));
      strcpy(p, ""bool "");
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"  case Tenum:
    if ((Table*)typ->ref == booltable)
    { p = (char*)emalloc((strlen(id)+6)*sizeof(char));
      strcpy(p, ""bool "");
      strcat(p, id);
",1,unused,6633,unused,"  case Tenum:
    if ((Table*)typ->ref == booltable)
    { p = (char*)emalloc((strlen(id)+6)*sizeof(char));
      strcpy(p, ""bool "");
      strcat(p, id);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"      strcat(p, id);
      return p;
    }
    p=(char*) emalloc((7+strlen(ident(typ->id->name))+strlen(id)) *sizeof(char));
    strcpy(p, ""enum "");
",1,unused,6637,unused,"      strcat(p, id);
      return p;
    }
    p=(char*) emalloc((7+strlen(ident(typ->id->name))+strlen(id)) *sizeof(char));
    strcpy(p, ""enum "");
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"      return p;
    }
    p=(char*) emalloc((7+strlen(ident(typ->id->name))+strlen(id)) *sizeof(char));
    strcpy(p, ""enum "");
    strcat(p, ident(typ->id->name));
",1,unused,6638,unused,"      return p;
    }
    p=(char*) emalloc((7+strlen(ident(typ->id->name))+strlen(id)) *sizeof(char));
    strcpy(p, ""enum "");
    strcat(p, ident(typ->id->name));
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"    }
    p=(char*) emalloc((7+strlen(ident(typ->id->name))+strlen(id)) *sizeof(char));
    strcpy(p, ""enum "");
    strcat(p, ident(typ->id->name));
    strcat(p, "" "");
",1,unused,6639,unused,"    }
    p=(char*) emalloc((7+strlen(ident(typ->id->name))+strlen(id)) *sizeof(char));
    strcpy(p, ""enum "");
    strcat(p, ident(typ->id->name));
    strcat(p, "" "");
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"    p=(char*) emalloc((7+strlen(ident(typ->id->name))+strlen(id)) *sizeof(char));
    strcpy(p, ""enum "");
    strcat(p, ident(typ->id->name));
    strcat(p, "" "");
    strcat(p, id);
",1,unused,6640,unused,"    p=(char*) emalloc((7+strlen(ident(typ->id->name))+strlen(id)) *sizeof(char));
    strcpy(p, ""enum "");
    strcat(p, ident(typ->id->name));
    strcat(p, "" "");
    strcat(p, id);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"    strcat(p, id);
    break;
  case Tpointer:
    p = (char*)emalloc(strlen(id)+2);
    strcpy(p+1, id);
",1,unused,6644,unused,"    strcat(p, id);
    break;
  case Tpointer:
    p = (char*)emalloc(strlen(id)+2);
    strcpy(p+1, id);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"    p = c_type_id((Tnode*)typ->ref, p);
    break;
  case Treference:
    p = (char*)emalloc(strlen(id)+2);
    strcpy(p+1, id);
",1,unused,6650,unused,"    p = c_type_id((Tnode*)typ->ref, p);
    break;
  case Treference:
    p = (char*)emalloc(strlen(id)+2);
    strcpy(p+1, id);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"    while(((Tnode*) (typ->ref))->type==Tarray){
      typ = (Tnode*)typ->ref;
    }
    p=(char*) emalloc((12+strlen(q = c_type_id((Tnode*)typ->ref, id))) *sizeof(char));
    strcpy(p, q);
",1,unused,6660,unused,"    while(((Tnode*) (typ->ref))->type==Tarray){
      typ = (Tnode*)typ->ref;
    }
    p=(char*) emalloc((12+strlen(q = c_type_id((Tnode*)typ->ref, id))) *sizeof(char));
    strcpy(p, q);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"    strcpy(p, q);
    typ = temp;
    while(typ->type==Tarray){
      if (((Tnode*) typ->ref)->width)
      { sprintf(tempBuf,""[%d]"",(typ->width / ((Tnode*) typ->ref)->width));
",1,unused,6664,unused,"    strcpy(p, q);
    typ = temp;
    while(typ->type==Tarray){
      if (((Tnode*) typ->ref)->width)
      { sprintf(tempBuf,""[%d]"",(typ->width / ((Tnode*) typ->ref)->width));
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"    typ = temp;
    while(typ->type==Tarray){
      if (((Tnode*) typ->ref)->width)
      { sprintf(tempBuf,""[%d]"",(typ->width / ((Tnode*) typ->ref)->width));
        strcat(p,tempBuf);
",1,unused,6665,unused,"    typ = temp;
    while(typ->type==Tarray){
      if (((Tnode*) typ->ref)->width)
      { sprintf(tempBuf,""[%d]"",(typ->width / ((Tnode*) typ->ref)->width));
        strcat(p,tempBuf);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"      q = c_type_id(((FNinfo*)typ->ref)->ret, id);
    else
      q = id;
    p = (char*)emalloc(1024);
    strcpy(p, q);
",1,unused,6680,unused,"      q = c_type_id(((FNinfo*)typ->ref)->ret, id);
    else
      q = id;
    p = (char*)emalloc(1024);
    strcpy(p, q);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"    else
      q = id;
    p = (char*)emalloc(1024);
    strcpy(p, q);
    strcat(p, ""("");
",1,unused,6681,unused,"    else
      q = id;
    p = (char*)emalloc(1024);
    strcpy(p, q);
    strcat(p, ""("");
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"    p = (char*)emalloc(1024);
    strcpy(p, q);
    strcat(p, ""("");
    for (e = ((FNinfo*)typ->ref)->args->list; e; e = e->next)
    { strcat(p, c_storage(e->info.sto));
",1,unused,6683,unused,"    p = (char*)emalloc(1024);
    strcpy(p, q);
    strcat(p, ""("");
    for (e = ((FNinfo*)typ->ref)->args->list; e; e = e->next)
    { strcat(p, c_storage(e->info.sto));
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"    strcat(p, ""("");
    for (e = ((FNinfo*)typ->ref)->args->list; e; e = e->next)
    { strcat(p, c_storage(e->info.sto));
      if (e->info.typ->type != Tvoid)
      { strcat(p, c_type_id(e->info.typ, e->sym->name));
",1,unused,6685,unused,"    strcat(p, ""("");
    for (e = ((FNinfo*)typ->ref)->args->list; e; e = e->next)
    { strcat(p, c_storage(e->info.sto));
      if (e->info.typ->type != Tvoid)
      { strcat(p, c_type_id(e->info.typ, e->sym->name));
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"    for (e = ((FNinfo*)typ->ref)->args->list; e; e = e->next)
    { strcat(p, c_storage(e->info.sto));
      if (e->info.typ->type != Tvoid)
      { strcat(p, c_type_id(e->info.typ, e->sym->name));
        strcat(p, c_init(e));
",1,unused,6686,unused,"    for (e = ((FNinfo*)typ->ref)->args->list; e; e = e->next)
    { strcat(p, c_storage(e->info.sto));
      if (e->info.typ->type != Tvoid)
      { strcat(p, c_type_id(e->info.typ, e->sym->name));
        strcat(p, c_init(e));
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"      { strcat(p, c_type_id(e->info.typ, e->sym->name));
        strcat(p, c_init(e));
      }
      else
        strcat(p, ""void"");
",1,unused,6689,unused,"      { strcat(p, c_type_id(e->info.typ, e->sym->name));
        strcat(p, c_init(e));
      }
      else
        strcat(p, ""void"");
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"      }
      else
        strcat(p, ""void"");
      if (e->next)
        strcat(p, "", "");
",1,unused,6691,unused,"      }
      else
        strcat(p, ""void"");
      if (e->next)
        strcat(p, "", "");
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"        strcat(p, ""void"");
      if (e->next)
        strcat(p, "", "");
    }
    strcat(p, "")"");
",1,unused,6693,unused,"        strcat(p, ""void"");
      if (e->next)
        strcat(p, "", "");
    }
    strcat(p, "")"");
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"    break;
  case Ttemplate:
    if (typ->ref)
    { p=(char*)emalloc((strlen(q = c_type((Tnode*)typ->ref))+strlen(ident(typ->id->name))+strlen(id)+4) *sizeof(char));
      strcpy(p, ident(typ->id->name));
",1,unused,6698,unused,"    break;
  case Ttemplate:
    if (typ->ref)
    { p=(char*)emalloc((strlen(q = c_type((Tnode*)typ->ref))+strlen(ident(typ->id->name))+strlen(id)+4) *sizeof(char));
      strcpy(p, ident(typ->id->name));
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"  case Ttemplate:
    if (typ->ref)
    { p=(char*)emalloc((strlen(q = c_type((Tnode*)typ->ref))+strlen(ident(typ->id->name))+strlen(id)+4) *sizeof(char));
      strcpy(p, ident(typ->id->name));
      strcat(p, ""<"");
",1,unused,6699,unused,"  case Ttemplate:
    if (typ->ref)
    { p=(char*)emalloc((strlen(q = c_type((Tnode*)typ->ref))+strlen(ident(typ->id->name))+strlen(id)+4) *sizeof(char));
      strcpy(p, ident(typ->id->name));
      strcat(p, ""<"");
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"    if (typ->ref)
    { p=(char*)emalloc((strlen(q = c_type((Tnode*)typ->ref))+strlen(ident(typ->id->name))+strlen(id)+4) *sizeof(char));
      strcpy(p, ident(typ->id->name));
      strcat(p, ""<"");
      strcat(p, q);
",1,unused,6700,unused,"    if (typ->ref)
    { p=(char*)emalloc((strlen(q = c_type((Tnode*)typ->ref))+strlen(ident(typ->id->name))+strlen(id)+4) *sizeof(char));
      strcpy(p, ident(typ->id->name));
      strcat(p, ""<"");
      strcat(p, q);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"    { p=(char*)emalloc((strlen(q = c_type((Tnode*)typ->ref))+strlen(ident(typ->id->name))+strlen(id)+4) *sizeof(char));
      strcpy(p, ident(typ->id->name));
      strcat(p, ""<"");
      strcat(p, q);
      strcat(p, "" >"");
",1,unused,6701,unused,"    { p=(char*)emalloc((strlen(q = c_type((Tnode*)typ->ref))+strlen(ident(typ->id->name))+strlen(id)+4) *sizeof(char));
      strcpy(p, ident(typ->id->name));
      strcat(p, ""<"");
      strcat(p, q);
      strcat(p, "" >"");
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"      strcpy(p, ident(typ->id->name));
      strcat(p, ""<"");
      strcat(p, q);
      strcat(p, "" >"");
      strcat(p, id);
",1,unused,6702,unused,"      strcpy(p, ident(typ->id->name));
      strcat(p, ""<"");
      strcat(p, q);
      strcat(p, "" >"");
      strcat(p, id);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"  s = xsi_type(t);
  if (!*s)
    s = wsdl_type(t, """");
  p = (char*)emalloc(strlen(s)+cardinality+3);
  strcpy(p, s);
",1,unused,6734,unused,"  s = xsi_type(t);
  if (!*s)
    s = wsdl_type(t, """");
  p = (char*)emalloc(strlen(s)+cardinality+3);
  strcpy(p, s);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"    s = wsdl_type(t, """");
  p = (char*)emalloc(strlen(s)+cardinality+3);
  strcpy(p, s);
  if (cardinality > 1)
  { strcat(p, ""["");
",1,unused,6736,unused,"    s = wsdl_type(t, """");
  p = (char*)emalloc(strlen(s)+cardinality+3);
  strcpy(p, s);
  if (cardinality > 1)
  { strcat(p, ""["");
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"  strcpy(p, s);
  if (cardinality > 1)
  { strcat(p, ""["");
    for (; cardinality > 2; cardinality--)
      strcat(p, "","");
",1,unused,6738,unused,"  strcpy(p, s);
  if (cardinality > 1)
  { strcat(p, ""["");
    for (; cardinality > 2; cardinality--)
      strcat(p, "","");
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"  if (cardinality > 1)
  { strcat(p, ""["");
    for (; cardinality > 2; cardinality--)
      strcat(p, "","");
    strcat(p, ""]"");
",1,unused,6739,unused,"  if (cardinality > 1)
  { strcat(p, ""["");
    for (; cardinality > 2; cardinality--)
      strcat(p, "","");
    strcat(p, ""]"");
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"  s = xsi_type(t);
  if (!*s)
    s = wsdl_type(t, """");
  p = (char*)emalloc(strlen(s)+cardinality*2+1);
  strcpy(p, s);
",1,unused,6781,unused,"  s = xsi_type(t);
  if (!*s)
    s = wsdl_type(t, """");
  p = (char*)emalloc(strlen(s)+cardinality*2+1);
  strcpy(p, s);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"    s = wsdl_type(t, """");
  p = (char*)emalloc(strlen(s)+cardinality*2+1);
  strcpy(p, s);
  if (cardinality > 1)
  { strcat(p, ""["");
",1,unused,6783,unused,"    s = wsdl_type(t, """");
  p = (char*)emalloc(strlen(s)+cardinality*2+1);
  strcpy(p, s);
  if (cardinality > 1)
  { strcat(p, ""["");
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"  strcpy(p, s);
  if (cardinality > 1)
  { strcat(p, ""["");
    for (; cardinality > 2; cardinality--)
      strcat(p, "","");
",1,unused,6785,unused,"  strcpy(p, s);
  if (cardinality > 1)
  { strcat(p, ""["");
    for (; cardinality > 2; cardinality--)
      strcat(p, "","");
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"  if (cardinality > 1)
  { strcat(p, ""["");
    for (; cardinality > 2; cardinality--)
      strcat(p, "","");
    strcat(p, ""]"");
",1,unused,6786,unused,"  if (cardinality > 1)
  { strcat(p, ""["");
    for (; cardinality > 2; cardinality--)
      strcat(p, "","");
    strcat(p, ""]"");
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"      fprintf(fout, ""\n\t\tif (soap_out_%s(soap, \""%s\"", -1, %s->%s, \""%s\""))\n\t\t\treturn soap->error;"", c_ident(ptr), tag, obj, name, xsi_type_u(ptr));
    else if (is_external(ptr))
      fprintf(fout, ""\n\t\tsoap_set_attr(soap, \""%s\"", soap_%s2s(soap, *%s->%s), 1);"", tag, c_ident(ptr), obj, name);
    else
    { sprintf(errbuf, ""Field '%s' cannot be serialized as an XML attribute"", name);
",1,unused,8916,unused,"      fprintf(fout, ""\n\t\tif (soap_out_%s(soap, \""%s\"", -1, %s->%s, \""%s\""))\n\t\t\treturn soap->error;"", c_ident(ptr), tag, obj, name, xsi_type_u(ptr));
    else if (is_external(ptr))
      fprintf(fout, ""\n\t\tsoap_set_attr(soap, \""%s\"", soap_%s2s(soap, *%s->%s), 1);"", tag, c_ident(ptr), obj, name);
    else
    { sprintf(errbuf, ""Field '%s' cannot be serialized as an XML attribute"", name);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"    fprintf(fout, ""\n\tif (soap_out_%s(soap, \""%s\"", -1, &%s->%s, \""%s\""))\n\t\treturn soap->error;"", c_ident(typ), tag, obj, name, xsi_type_u(typ));
  else if (is_external(typ))
    fprintf(fout, ""\n\tsoap_set_attr(soap, \""%s\"", soap_%s2s(soap, %s->%s), 1);"", tag, c_ident(typ), obj, name);
  else
  { sprintf(errbuf, ""Field '%s' cannot be serialized as an XML attribute"", name);
",1,unused,8931,unused,"    fprintf(fout, ""\n\tif (soap_out_%s(soap, \""%s\"", -1, &%s->%s, \""%s\""))\n\t\treturn soap->error;"", c_ident(typ), tag, obj, name, xsi_type_u(typ));
  else if (is_external(typ))
    fprintf(fout, ""\n\tsoap_set_attr(soap, \""%s\"", soap_%s2s(soap, %s->%s), 1);"", tag, c_ident(typ), obj, name);
  else
  { sprintf(errbuf, ""Field '%s' cannot be serialized as an XML attribute"", name);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"
char *
ptr_cast(Table *t, char *name)
{ char *s = emalloc(strlen(t->sym->name) + strlen(name) + 6);
  sprintf(s, ""((%s*)%s)"", t->sym->name, name);
",1,unused,9008,unused,"
char *
ptr_cast(Table *t, char *name)
{ char *s = emalloc(strlen(t->sym->name) + strlen(name) + 6);
  sprintf(s, ""((%s*)%s)"", t->sym->name, name);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"    { *t++ = '\\';
      *t++ = *s;
    }
    else if (*s < 32)
    { sprintf(t, ""\\%03o"", (unsigned int)(unsigned char)*s);
",1,unused,11388,unused,"    { *t++ = '\\';
      *t++ = *s;
    }
    else if (*s < 32)
    { sprintf(t, ""\\%03o"", (unsigned int)(unsigned char)*s);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"  }
  r = t = (char*)emalloc(n + 1);
  for (; *s; s++)
  { if (*s < 32 || *s >= 127)
    { sprintf(t, ""&#%.2x;"", (unsigned char)*s);
",1,unused,11418,unused,"  }
  r = t = (char*)emalloc(n + 1);
  for (; *s; s++)
  { if (*s < 32 || *s >= 127)
    { sprintf(t, ""&#%.2x;"", (unsigned char)*s);
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"    { sprintf(t, ""&#%.2x;"", (unsigned char)*s);
      t += 5;
    }
    else if (*s == '<')
    { strcpy(t, ""&lt;"");
",1,unused,11422,unused,"    { sprintf(t, ""&#%.2x;"", (unsigned char)*s);
      t += 5;
    }
    else if (*s == '<')
    { strcpy(t, ""&lt;"");
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"    { strcpy(t, ""&lt;"");
      t += 4;
    }
    else if (*s == '>')
    { strcpy(t, ""&gt;"");
",1,unused,11426,unused,"    { strcpy(t, ""&lt;"");
      t += 4;
    }
    else if (*s == '>')
    { strcpy(t, ""&gt;"");
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"    { strcpy(t, ""&gt;"");
      t += 4;
    }
    else if (*s == '&')
    { strcpy(t, ""&amp;"");
",1,unused,11430,unused,"    { strcpy(t, ""&gt;"");
      t += 4;
    }
    else if (*s == '&')
    { strcpy(t, ""&amp;"");
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"    { strcpy(t, ""&amp;"");
      t += 5;
    }
    else if (*s == '""')
    { strcpy(t, ""&quot;"");
",1,unused,11434,unused,"    { strcpy(t, ""&amp;"");
      t += 5;
    }
    else if (*s == '""')
    { strcpy(t, ""&quot;"");
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"    { strcpy(t, ""&quot;"");
      t += 6;
    }
    else if (*s == '\\')
    { strcpy(t, ""\\\\"");
",1,unused,11438,unused,"    { strcpy(t, ""&quot;"");
      t += 6;
    }
    else if (*s == '\\')
    { strcpy(t, ""\\\\"");
",unused,ssocopsacc_gsoap-gsoap2Fsrc2Fsymbol2.c
"  }
#ifndef WITH_LEANER
  if ((soap->mode & SOAP_IO) == SOAP_IO_CHUNK)
  { char t[16];
    sprintf(t, ""\r\n%lX\r\n"" + (soap->chunksize ? 0 : 2), (unsigned long)n);
",1,unused,764,unused,"  }
#ifndef WITH_LEANER
  if ((soap->mode & SOAP_IO) == SOAP_IO_CHUNK)
  { char t[16];
    sprintf(t, ""\r\n%lX\r\n"" + (soap->chunksize ? 0 : 2), (unsigned long)n);
",unused,ssocopsacc_gsoap-gsoap2Fstdsoap2.c
"SOAP_FMAC2
soap_strdup(struct soap *soap, const char *s)
{ char *t = NULL;
  if (s && (t = (char*)soap_malloc(soap, strlen(s) + 1)))
    strcpy(t, s);
",1,unused,2018,unused,"SOAP_FMAC2
soap_strdup(struct soap *soap, const char *s)
{ char *t = NULL;
  if (s && (t = (char*)soap_malloc(soap, strlen(s) + 1)))
    strcpy(t, s);
",unused,ssocopsacc_gsoap-gsoap2Fstdsoap2.c
"        }
      }
      else if (*ip->id == '#')
      { DBGLOG(TEST, SOAP_MESSAGE(fdebug, ""Missing data for id='%s'\n"", ip->id));
        strcpy(soap->id, ip->id + 1);
",1,unused,2210,unused,"        }
      }
      else if (*ip->id == '#')
      { DBGLOG(TEST, SOAP_MESSAGE(fdebug, ""Missing data for id='%s'\n"", ip->id));
        strcpy(soap->id, ip->id + 1);
",unused,ssocopsacc_gsoap-gsoap2Fstdsoap2.c
"{ int i;
  if (!type)
    return NULL;
  if (soap->version == 2)
  { sprintf(soap->type, ""%s[%d"", type, size[0]);
",1,unused,2443,unused,"{ int i;
  if (!type)
    return NULL;
  if (soap->version == 2)
  { sprintf(soap->type, ""%s[%d"", type, size[0]);
",unused,ssocopsacc_gsoap-gsoap2Fstdsoap2.c
"    return NULL;
  if (soap->version == 2)
  { sprintf(soap->type, ""%s[%d"", type, size[0]);
    for (i = 1; i < dim; i++)
      sprintf(soap->type + strlen(soap->type), "" %d"", size[i]);
",1,unused,2445,unused,"    return NULL;
  if (soap->version == 2)
  { sprintf(soap->type, ""%s[%d"", type, size[0]);
    for (i = 1; i < dim; i++)
      sprintf(soap->type + strlen(soap->type), "" %d"", size[i]);
",unused,ssocopsacc_gsoap-gsoap2Fstdsoap2.c
"      sprintf(soap->type + strlen(soap->type), "" %d"", size[i]);
  }
  else
  { if (offset)
    { sprintf(soap->type, ""%s[%d"", type, size[0] + offset[0]);
",1,unused,2449,unused,"      sprintf(soap->type + strlen(soap->type), "" %d"", size[i]);
  }
  else
  { if (offset)
    { sprintf(soap->type, ""%s[%d"", type, size[0] + offset[0]);
",unused,ssocopsacc_gsoap-gsoap2Fstdsoap2.c
"  else
  { if (offset)
    { sprintf(soap->type, ""%s[%d"", type, size[0] + offset[0]);
      for (i = 1; i < dim; i++)
        sprintf(soap->type + strlen(soap->type), "",%d"", size[i] + offset[i]);
",1,unused,2451,unused,"  else
  { if (offset)
    { sprintf(soap->type, ""%s[%d"", type, size[0] + offset[0]);
      for (i = 1; i < dim; i++)
        sprintf(soap->type + strlen(soap->type), "",%d"", size[i] + offset[i]);
",unused,ssocopsacc_gsoap-gsoap2Fstdsoap2.c
"      for (i = 1; i < dim; i++)
        sprintf(soap->type + strlen(soap->type), "",%d"", size[i] + offset[i]);
    }
    else
    { sprintf(soap->type, ""%s[%d"", type, size[0]);
",1,unused,2454,unused,"      for (i = 1; i < dim; i++)
        sprintf(soap->type + strlen(soap->type), "",%d"", size[i] + offset[i]);
    }
    else
    { sprintf(soap->type, ""%s[%d"", type, size[0]);
",unused,ssocopsacc_gsoap-gsoap2Fstdsoap2.c
"    }
    else
    { sprintf(soap->type, ""%s[%d"", type, size[0]);
      for (i = 1; i < dim; i++)
        sprintf(soap->type + strlen(soap->type), "",%d"", size[i]);
",1,unused,2456,unused,"    }
    else
    { sprintf(soap->type, ""%s[%d"", type, size[0]);
      for (i = 1; i < dim; i++)
        sprintf(soap->type + strlen(soap->type), "",%d"", size[i]);
",unused,ssocopsacc_gsoap-gsoap2Fstdsoap2.c
"    { sprintf(soap->type, ""%s[%d"", type, size[0]);
      for (i = 1; i < dim; i++)
        sprintf(soap->type + strlen(soap->type), "",%d"", size[i]);
    }
    strcat(soap->type, ""]"");
",1,unused,2458,unused,"    { sprintf(soap->type, ""%s[%d"", type, size[0]);
      for (i = 1; i < dim; i++)
        sprintf(soap->type + strlen(soap->type), "",%d"", size[i]);
    }
    strcat(soap->type, ""]"");
",unused,ssocopsacc_gsoap-gsoap2Fstdsoap2.c
"char *
SOAP_FMAC2
soap_putoffsets(struct soap *soap, const int *offset, int dim)
{ register int i;
  sprintf(soap->arrayOffset, ""[%d"", offset[0]);
",1,unused,2481,unused,"char *
SOAP_FMAC2
soap_putoffsets(struct soap *soap, const int *offset, int dim)
{ register int i;
  sprintf(soap->arrayOffset, ""[%d"", offset[0]);
",unused,ssocopsacc_gsoap-gsoap2Fstdsoap2.c
"soap_putoffsets(struct soap *soap, const int *offset, int dim)
{ register int i;
  sprintf(soap->arrayOffset, ""[%d"", offset[0]);
  for (i = 1; i < dim; i++)
    sprintf(soap->arrayOffset + strlen(soap->arrayOffset), "",%d"", offset[i]);
",1,unused,2483,unused,"soap_putoffsets(struct soap *soap, const int *offset, int dim)
{ register int i;
  sprintf(soap->arrayOffset, ""[%d"", offset[0]);
  for (i = 1; i < dim; i++)
    sprintf(soap->arrayOffset + strlen(soap->arrayOffset), "",%d"", offset[i]);
",unused,ssocopsacc_gsoap-gsoap2Fstdsoap2.c
"{ register int i;
  sprintf(soap->arrayOffset, ""[%d"", offset[0]);
  for (i = 1; i < dim; i++)
    sprintf(soap->arrayOffset + strlen(soap->arrayOffset), "",%d"", offset[i]);
  strcat(soap->arrayOffset, ""]"");
",1,unused,2484,unused,"{ register int i;
  sprintf(soap->arrayOffset, ""[%d"", offset[0]);
  for (i = 1; i < dim; i++)
    sprintf(soap->arrayOffset + strlen(soap->arrayOffset), "",%d"", offset[i]);
  strcat(soap->arrayOffset, ""]"");
",unused,ssocopsacc_gsoap-gsoap2Fstdsoap2.c
"      }
      else if (p->in)
      { if (!soap_tag_cmp(ns, p->in))
        { if ((p->out = (char*)SOAP_MALLOC(soap, k)))
            strcpy(p->out, ns);
",1,unused,2641,unused,"      }
      else if (p->in)
      { if (!soap_tag_cmp(ns, p->in))
        { if ((p->out = (char*)SOAP_MALLOC(soap, k)))
            strcpy(p->out, ns);
",unused,ssocopsacc_gsoap-gsoap2Fstdsoap2.c
"  np->next = soap->nlist;
  soap->nlist = np;
  np->level = soap->level;
  np->index = i;
  strcpy(np->id, id);
",1,unused,2660,unused,"  np->next = soap->nlist;
  soap->nlist = np;
  np->level = soap->level;
  np->index = i;
  strcpy(np->id, id);
",unused,ssocopsacc_gsoap-gsoap2Fstdsoap2.c
"  np->index = i;
  strcpy(np->id, id);
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, ""Push namespace binding (level=%u) '%s' '%s'\n"", soap->level, id, ns));
  if (i < 0)
  { np->ns = strcpy(np->id + n + 1, ns);
",1,unused,2663,unused,"  np->index = i;
  strcpy(np->id, id);
  DBGLOG(TEST, SOAP_MESSAGE(fdebug, ""Push namespace binding (level=%u) '%s' '%s'\n"", soap->level, id, ns));
  if (i < 0)
  { np->ns = strcpy(np->id + n + 1, ns);
",unused,ssocopsacc_gsoap-gsoap2Fstdsoap2.c
"#ifndef WITH_LEAN
      msg = soap_code_str(h_error_codes, soap->errnum);
      if (!msg)
#endif
      { sprintf(soap->msgbuf, ""TCP/UDP IP error %d"", soap->errnum);
",1,unused,3278,unused,"#ifndef WITH_LEAN
      msg = soap_code_str(h_error_codes, soap->errnum);
      if (!msg)
#endif
      { sprintf(soap->msgbuf, ""TCP/UDP IP error %d"", soap->errnum);
",unused,ssocopsacc_gsoap-gsoap2Fstdsoap2.c
"      if (n >= sizeof(soap->endpoint))
        n = sizeof(soap->endpoint) - 1;
      strncpy(soap->path, soap->msgbuf + l, n - m);
      soap->path[n - m] = '\0';
      strcat(soap->endpoint, soap->path);
",1,unused,4816,unused,"      if (n >= sizeof(soap->endpoint))
        n = sizeof(soap->endpoint) - 1;
      strncpy(soap->path, soap->msgbuf + l, n - m);
      soap->path[n - m] = '\0';
      strcat(soap->endpoint, soap->path);
",unused,ssocopsacc_gsoap-gsoap2Fstdsoap2.c
"    if (soap->imode & SOAP_ENC_SSL)
      strcpy(soap->endpoint, ""https://"");
    else
#endif
      strcpy(soap->endpoint, ""http://"");
",1,unused,4875,unused,"    if (soap->imode & SOAP_ENC_SSL)
      strcpy(soap->endpoint, ""https://"");
    else
#endif
      strcpy(soap->endpoint, ""http://"");
",unused,ssocopsacc_gsoap-gsoap2Fstdsoap2.c
"    return SOAP_OK;
  if (strlen(endpoint) + strlen(soap->http_version) > sizeof(soap->tmpbuf) - 80)
    return soap->error = SOAP_EOM;
  if (soap->proxy_host && soap_tag_cmp(endpoint, ""https:*""))
    sprintf(soap->tmpbuf, ""%s %s HTTP/%s"", s, endpoint, soap->http_version);
",1,unused,5138,unused,"    return SOAP_OK;
  if (strlen(endpoint) + strlen(soap->http_version) > sizeof(soap->tmpbuf) - 80)
    return soap->error = SOAP_EOM;
  if (soap->proxy_host && soap_tag_cmp(endpoint, ""https:*""))
    sprintf(soap->tmpbuf, ""%s %s HTTP/%s"", s, endpoint, soap->http_version);
",unused,ssocopsacc_gsoap-gsoap2Fstdsoap2.c
"    return soap->error = SOAP_EOM;
  if (soap->proxy_host && soap_tag_cmp(endpoint, ""https:*""))
    sprintf(soap->tmpbuf, ""%s %s HTTP/%s"", s, endpoint, soap->http_version);
  else
    sprintf(soap->tmpbuf, ""%s /%s HTTP/%s"", s, (*path == '/' ? path + 1 : path), soap->http_version);
",1,unused,5140,unused,"    return soap->error = SOAP_EOM;
  if (soap->proxy_host && soap_tag_cmp(endpoint, ""https:*""))
    sprintf(soap->tmpbuf, ""%s %s HTTP/%s"", s, endpoint, soap->http_version);
  else
    sprintf(soap->tmpbuf, ""%s /%s HTTP/%s"", s, (*path == '/' ? path + 1 : path), soap->http_version);
",unused,ssocopsacc_gsoap-gsoap2Fstdsoap2.c
"  else
    strcpy(soap->tmpbuf, host); 
#else
  if (port != 80)
    sprintf(soap->tmpbuf, ""%s:%d"", host, port);
",1,unused,5150,unused,"  else
    strcpy(soap->tmpbuf, host); 
#else
  if (port != 80)
    sprintf(soap->tmpbuf, ""%s:%d"", host, port);
",unused,ssocopsacc_gsoap-gsoap2Fstdsoap2.c
"#else
  if (port != 80)
    sprintf(soap->tmpbuf, ""%s:%d"", host, port);
  else
    strcpy(soap->tmpbuf, host); 
",1,unused,5152,unused,"#else
  if (port != 80)
    sprintf(soap->tmpbuf, ""%s:%d"", host, port);
  else
    strcpy(soap->tmpbuf, host); 
",unused,ssocopsacc_gsoap-gsoap2Fstdsoap2.c
"    return err;
#endif
#ifndef WITH_LEAN
  if (soap->userid && soap->passwd && strlen(soap->userid) + strlen(soap->passwd) < 761)
  { sprintf(soap->tmpbuf + 262, ""%s:%s"", soap->userid, soap->passwd);
",1,unused,5168,unused,"    return err;
#endif
#ifndef WITH_LEAN
  if (soap->userid && soap->passwd && strlen(soap->userid) + strlen(soap->passwd) < 761)
  { sprintf(soap->tmpbuf + 262, ""%s:%s"", soap->userid, soap->passwd);
",unused,ssocopsacc_gsoap-gsoap2Fstdsoap2.c
"#endif
#ifndef WITH_LEAN
  if (soap->userid && soap->passwd && strlen(soap->userid) + strlen(soap->passwd) < 761)
  { sprintf(soap->tmpbuf + 262, ""%s:%s"", soap->userid, soap->passwd);
    strcpy(soap->tmpbuf, ""Basic "");
",1,unused,5169,unused,"#endif
#ifndef WITH_LEAN
  if (soap->userid && soap->passwd && strlen(soap->userid) + strlen(soap->passwd) < 761)
  { sprintf(soap->tmpbuf + 262, ""%s:%s"", soap->userid, soap->passwd);
    strcpy(soap->tmpbuf, ""Basic "");
",unused,ssocopsacc_gsoap-gsoap2Fstdsoap2.c
"    if ((err = soap->fposthdr(soap, ""Authorization"", soap->tmpbuf)))
      return err;
  }
  if (soap->proxy_userid && soap->proxy_passwd && strlen(soap->proxy_userid) + strlen(soap->proxy_passwd) < 761)
  { sprintf(soap->tmpbuf + 262, ""%s:%s"", soap->proxy_userid, soap->proxy_passwd);
",1,unused,5175,unused,"    if ((err = soap->fposthdr(soap, ""Authorization"", soap->tmpbuf)))
      return err;
  }
  if (soap->proxy_userid && soap->proxy_passwd && strlen(soap->proxy_userid) + strlen(soap->proxy_passwd) < 761)
  { sprintf(soap->tmpbuf + 262, ""%s:%s"", soap->proxy_userid, soap->proxy_passwd);
",unused,ssocopsacc_gsoap-gsoap2Fstdsoap2.c
"      return err;
  }
  if (soap->proxy_userid && soap->proxy_passwd && strlen(soap->proxy_userid) + strlen(soap->proxy_passwd) < 761)
  { sprintf(soap->tmpbuf + 262, ""%s:%s"", soap->proxy_userid, soap->proxy_passwd);
    strcpy(soap->tmpbuf, ""Basic "");
",1,unused,5176,unused,"      return err;
  }
  if (soap->proxy_userid && soap->proxy_passwd && strlen(soap->proxy_userid) + strlen(soap->proxy_passwd) < 761)
  { sprintf(soap->tmpbuf + 262, ""%s:%s"", soap->proxy_userid, soap->proxy_passwd);
    strcpy(soap->tmpbuf, ""Basic "");
",unused,ssocopsacc_gsoap-gsoap2Fstdsoap2.c
"    return soap->error;
#endif
#endif
  if (soap->status != SOAP_GET && (soap->version == 1 || (action && *action)))
  { sprintf(soap->tmpbuf, ""\""%s\"""", action && strlen(action) < sizeof(soap->tmpbuf) - 3 ? action : SOAP_STR_EOS);
",1,unused,5192,unused,"    return soap->error;
#endif
#endif
  if (soap->status != SOAP_GET && (soap->version == 1 || (action && *action)))
  { sprintf(soap->tmpbuf, ""\""%s\"""", action && strlen(action) < sizeof(soap->tmpbuf) - 3 ? action : SOAP_STR_EOS);
",unused,ssocopsacc_gsoap-gsoap2Fstdsoap2.c
"    if (soap->rpmreqid || soap_valid_socket(soap->master) || soap_valid_socket(soap->socket)) /* RPM behaves as if standalone */
#else
    if (soap_valid_socket(soap->master) || soap_valid_socket(soap->socket)) /* standalone application (socket) or CGI (stdin/out)? */
#endif
    { sprintf(soap->tmpbuf, ""HTTP/%s %s"", soap->http_version, s);
",1,unused,5260,unused,"    if (soap->rpmreqid || soap_valid_socket(soap->master) || soap_valid_socket(soap->socket)) /* RPM behaves as if standalone */
#else
    if (soap_valid_socket(soap->master) || soap_valid_socket(soap->socket)) /* standalone application (socket) or CGI (stdin/out)? */
#endif
    { sprintf(soap->tmpbuf, ""HTTP/%s %s"", soap->http_version, s);
",unused,ssocopsacc_gsoap-gsoap2Fstdsoap2.c
"    else if ((err = soap->fposthdr(soap, ""Status"", s))) /* CGI header */
      return err;
  }
  else if (status >= 200 && status < 600)
  { sprintf(soap->tmpbuf, ""HTTP/%s %d %s"", soap->http_version, status, http_error(soap, status));
",1,unused,5268,unused,"    else if ((err = soap->fposthdr(soap, ""Status"", s))) /* CGI header */
      return err;
  }
  else if (status >= 200 && status < 600)
  { sprintf(soap->tmpbuf, ""HTTP/%s %d %s"", soap->http_version, status, http_error(soap, status));
",unused,ssocopsacc_gsoap-gsoap2Fstdsoap2.c
"    if ((err = soap->fposthdr(soap, soap->tmpbuf, NULL)))
      return err;
#ifndef WITH_LEAN 
    if (status == 401)
    { sprintf(soap->tmpbuf, ""Basic realm=\""%s\"""", (soap->authrealm && strlen(soap->authrealm) < sizeof(soap->tmpbuf) - 14) ? soap->authrealm : ""gSOAP Web Service"");
",1,unused,5273,unused,"    if ((err = soap->fposthdr(soap, soap->tmpbuf, NULL)))
      return err;
#ifndef WITH_LEAN 
    if (status == 401)
    { sprintf(soap->tmpbuf, ""Basic realm=\""%s\"""", (soap->authrealm && strlen(soap->authrealm) < sizeof(soap->tmpbuf) - 14) ? soap->authrealm : ""gSOAP Web Service"");
",unused,ssocopsacc_gsoap-gsoap2Fstdsoap2.c
"    if (soap->rpmreqid || soap_valid_socket(soap->master) || soap_valid_socket(soap->socket)) /* RPM behaves as if standalone */
#else
    if (soap_valid_socket(soap->master) || soap_valid_socket(soap->socket)) /* standalone application */
#endif
    { sprintf(soap->tmpbuf, ""HTTP/%s %s"", soap->http_version, s);
",1,unused,5297,unused,"    if (soap->rpmreqid || soap_valid_socket(soap->master) || soap_valid_socket(soap->socket)) /* RPM behaves as if standalone */
#else
    if (soap_valid_socket(soap->master) || soap_valid_socket(soap->socket)) /* standalone application */
#endif
    { sprintf(soap->tmpbuf, ""HTTP/%s %s"", soap->http_version, s);
",unused,ssocopsacc_gsoap-gsoap2Fstdsoap2.c
"  }
  if (id <= 0)
    id = i;
  if (!aid)
  { sprintf(soap->tmpbuf, soap->dime_id_format, id);
",1,unused,6647,unused,"  }
  if (id <= 0)
    id = i;
  if (!aid)
  { sprintf(soap->tmpbuf, soap->dime_id_format, id);
",unused,ssocopsacc_gsoap-gsoap2Fstdsoap2.c
"      { if (soap->mode & SOAP_ENC_MTOM)
        { char *s = (char*)soap_malloc(soap, strlen(aid) - 1);
          if (s)
          { *s = '<';
            strcpy(s + 1, aid + 4);
",1,unused,6676,unused,"      { if (soap->mode & SOAP_ENC_MTOM)
        { char *s = (char*)soap_malloc(soap, strlen(aid) - 1);
          if (s)
          { *s = '<';
            strcpy(s + 1, aid + 4);
",unused,ssocopsacc_gsoap-gsoap2Fstdsoap2.c
"        { char *s = (char*)soap_malloc(soap, strlen(aid) - 1);
          if (s)
          { *s = '<';
            strcpy(s + 1, aid + 4);
            strcat(s, "">"");
",1,unused,6677,unused,"        { char *s = (char*)soap_malloc(soap, strlen(aid) - 1);
          if (s)
          { *s = '<';
            strcpy(s + 1, aid + 4);
            strcat(s, "">"");
",unused,ssocopsacc_gsoap-gsoap2Fstdsoap2.c
"  register struct soap_ilist *ip;
  ip = (struct soap_ilist*)SOAP_MALLOC(soap, sizeof(struct soap_ilist) + strlen(id));
  if (ip)
  { h = soap_hash(id);
    strcpy(ip->id, id);
",1,unused,6764,unused,"  register struct soap_ilist *ip;
  ip = (struct soap_ilist*)SOAP_MALLOC(soap, sizeof(struct soap_ilist) + strlen(id));
  if (ip)
  { h = soap_hash(id);
    strcpy(ip->id, id);
",unused,ssocopsacc_gsoap-gsoap2Fstdsoap2.c
"  }
  else if (ip->ptr)
  { DBGLOG(TEST, SOAP_MESSAGE(fdebug, ""Resolved href='%s' type=%d location=%p (%u bytes)\n"", id, t, ip->ptr, (unsigned int)n));
    if (ip->type != t)
    { strcpy(soap->id, id);
",1,unused,7164,unused,"  }
  else if (ip->ptr)
  { DBGLOG(TEST, SOAP_MESSAGE(fdebug, ""Resolved href='%s' type=%d location=%p (%u bytes)\n"", id, t, ip->ptr, (unsigned int)n));
    if (ip->type != t)
    { strcpy(soap->id, id);
",unused,ssocopsacc_gsoap-gsoap2Fstdsoap2.c
"    DBGLOG(TEST,SOAP_MESSAGE(fdebug, ""New entry href='%s' type=%d size=%lu level=%d location=%p\n"", href, st, (unsigned long)n, k, p));
  }
  else if (ip->type != st || (ip->level == k && ip->size != n))
  { DBGLOG(TEST, SOAP_MESSAGE(fdebug, ""Type incompatibility id='%s' expect type=%d size=%lu level=%u got type=%d size=%lu\n"", href, ip->type, (unsigned long)ip->size, k, st, (unsigned long)n));
    strcpy(soap->id, href);
",1,unused,7249,unused,"    DBGLOG(TEST,SOAP_MESSAGE(fdebug, ""New entry href='%s' type=%d size=%lu level=%d location=%p\n"", href, st, (unsigned long)n, k, p));
  }
  else if (ip->type != st || (ip->level == k && ip->size != n))
  { DBGLOG(TEST, SOAP_MESSAGE(fdebug, ""Type incompatibility id='%s' expect type=%d size=%lu level=%u got type=%d size=%lu\n"", href, ip->type, (unsigned long)ip->size, k, st, (unsigned long)n));
    strcpy(soap->id, href);
",unused,ssocopsacc_gsoap-gsoap2Fstdsoap2.c
"    DBGLOG(TEST,SOAP_MESSAGE(fdebug, ""New entry id='%s' type=%d size=%lu level=%u location=%p\n"", id, t, (unsigned long)n, k, p));
  }
  else if ((ip->type != t || (ip->level == k && ip->size != n)) && (ip->copy || ip->flist))
  { DBGLOG(TEST, SOAP_MESSAGE(fdebug, ""Type incompatibility id='%s' expect type=%d size=%lu level=%u got type=%d size=%lu\n"", id, ip->type, (unsigned long)ip->size, k, t, (unsigned long)n));
    strcpy(soap->id, id);
",1,unused,7322,unused,"    DBGLOG(TEST,SOAP_MESSAGE(fdebug, ""New entry id='%s' type=%d size=%lu level=%u location=%p\n"", id, t, (unsigned long)n, k, p));
  }
  else if ((ip->type != t || (ip->level == k && ip->size != n)) && (ip->copy || ip->flist))
  { DBGLOG(TEST, SOAP_MESSAGE(fdebug, ""Type incompatibility id='%s' expect type=%d size=%lu level=%u got type=%d size=%lu\n"", id, ip->type, (unsigned long)ip->size, k, t, (unsigned long)n));
    strcpy(soap->id, id);
",unused,ssocopsacc_gsoap-gsoap2Fstdsoap2.c
"    return NULL;
  }
  else if (ip->ptr)
  { DBGLOG(TEST, SOAP_MESSAGE(fdebug, ""Multiply defined id='%s'\n"", id));
    strcpy(soap->id, id);
",1,unused,7328,unused,"    return NULL;
  }
  else if (ip->ptr)
  { DBGLOG(TEST, SOAP_MESSAGE(fdebug, ""Multiply defined id='%s'\n"", id));
    strcpy(soap->id, id);
",unused,ssocopsacc_gsoap-gsoap2Fstdsoap2.c
"    return NULL;
  }
  np->next = soap->nlist;
  soap->nlist = np;
  strcpy(np->id, id);
",1,unused,8425,unused,"    return NULL;
  }
  np->next = soap->nlist;
  soap->nlist = np;
  strcpy(np->id, id);
",unused,ssocopsacc_gsoap-gsoap2Fstdsoap2.c
"  np->next = soap->nlist;
  soap->nlist = np;
  strcpy(np->id, id);
  if (ns)
    np->ns = strcpy(np->id + n + 1, ns);
",1,unused,8427,unused,"  np->next = soap->nlist;
  soap->nlist = np;
  strcpy(np->id, id);
  if (ns)
    np->ns = strcpy(np->id + n + 1, ns);
",unused,ssocopsacc_gsoap-gsoap2Fstdsoap2.c
"      k = 4; /* only produce the first four required entries */
#endif
    for (ns = soap->local_namespaces; ns && ns->id && k; ns++, k--)
    { if (*ns->id && (ns->out || ns->ns))
      { sprintf(soap->tmpbuf, ""xmlns:%s"", ns->id);
",1,unused,8562,unused,"      k = 4; /* only produce the first four required entries */
#endif
    for (ns = soap->local_namespaces; ns && ns->id && k; ns++, k--)
    { if (*ns->id && (ns->out || ns->ns))
      { sprintf(soap->tmpbuf, ""xmlns:%s"", ns->id);
",unused,ssocopsacc_gsoap-gsoap2Fstdsoap2.c
"      soap_utilize_ns(soap, tag, t - tag);
  }
#endif
  if (id > 0)
  { sprintf(soap->tmpbuf, ""_%d"", id);
",1,unused,8577,unused,"      soap_utilize_ns(soap, tag, t - tag);
  }
#endif
  if (id > 0)
  { sprintf(soap->tmpbuf, ""_%d"", id);
",unused,ssocopsacc_gsoap-gsoap2Fstdsoap2.c
"#endif
  }
  if (soap->null && soap->position > 0)
  { register int i;
    sprintf(soap->tmpbuf, ""[%d"", soap->positions[0]);
",1,unused,8594,unused,"#endif
  }
  if (soap->null && soap->position > 0)
  { register int i;
    sprintf(soap->tmpbuf, ""[%d"", soap->positions[0]);
",unused,ssocopsacc_gsoap-gsoap2Fstdsoap2.c
"  if (soap->null && soap->position > 0)
  { register int i;
    sprintf(soap->tmpbuf, ""[%d"", soap->positions[0]);
    for (i = 1; i < soap->position; i++)
      sprintf(soap->tmpbuf + strlen(soap->tmpbuf), "",%d"", soap->positions[i]);
",1,unused,8596,unused,"  if (soap->null && soap->position > 0)
  { register int i;
    sprintf(soap->tmpbuf, ""[%d"", soap->positions[0]);
    for (i = 1; i < soap->position; i++)
      sprintf(soap->tmpbuf + strlen(soap->tmpbuf), "",%d"", soap->positions[i]);
",unused,ssocopsacc_gsoap-gsoap2Fstdsoap2.c
"  { register int i;
    sprintf(soap->tmpbuf, ""[%d"", soap->positions[0]);
    for (i = 1; i < soap->position; i++)
      sprintf(soap->tmpbuf + strlen(soap->tmpbuf), "",%d"", soap->positions[i]);
    strcat(soap->tmpbuf, ""]"");
",1,unused,8597,unused,"  { register int i;
    sprintf(soap->tmpbuf, ""[%d"", soap->positions[0]);
    for (i = 1; i < soap->position; i++)
      sprintf(soap->tmpbuf + strlen(soap->tmpbuf), "",%d"", soap->positions[i]);
    strcat(soap->tmpbuf, ""]"");
",unused,ssocopsacc_gsoap-gsoap2Fstdsoap2.c
"      }
    }
    for (np = soap->nlist; np; np = np->next)
    { if (np->index == 1 && np->ns)
      { sprintf(soap->tmpbuf, ""xmlns:%s"", np->id);
",1,unused,8814,unused,"      }
    }
    for (np = soap->nlist; np; np = np->next)
    { if (np->index == 1 && np->ns)
      { sprintf(soap->tmpbuf, ""xmlns:%s"", np->id);
",unused,ssocopsacc_gsoap-gsoap2Fstdsoap2.c
"  if (soap->version == 2)
  { s = ""SOAP-ENC:ref"";
    n = 1;
  }
  sprintf(soap->href, ""#_%d"", href);
",1,unused,8944,unused,"  if (soap->version == 2)
  { s = ""SOAP-ENC:ref"";
    n = 1;
  }
  sprintf(soap->href, ""#_%d"", href);
",unused,ssocopsacc_gsoap-gsoap2Fstdsoap2.c
"#endif
    { tp->next = soap->attributes;
      soap->attributes = tp;
    }
    strcpy(tp->name, name);
",1,unused,9287,unused,"#endif
    { tp->next = soap->attributes;
      soap->attributes = tp;
    }
    strcpy(tp->name, name);
",unused,ssocopsacc_gsoap-gsoap2Fstdsoap2.c
"      if (!(tp->value = (char*)SOAP_MALLOC(soap, tp->size)))
        return soap->error = SOAP_EOM;
      DBGLOG(TEST, SOAP_MESSAGE(fdebug, ""Allocate attribute value for %s (%p)\n"", tp->name, tp->value));
    }
    strcpy(tp->value, value);
",1,unused,9306,unused,"      if (!(tp->value = (char*)SOAP_MALLOC(soap, tp->size)))
        return soap->error = SOAP_EOM;
      DBGLOG(TEST, SOAP_MESSAGE(fdebug, ""Allocate attribute value for %s (%p)\n"", tp->name, tp->value));
    }
    strcpy(tp->value, value);
",unused,ssocopsacc_gsoap-gsoap2Fstdsoap2.c
"    if (!tp)
    { tp = (struct soap_attribute*)SOAP_MALLOC(soap, sizeof(struct soap_attribute) + strlen(soap->tmpbuf));
      if (!tp)
        return soap->error = SOAP_EOM;
      strcpy(tp->name, soap->tmpbuf);
",1,unused,9622,unused,"    if (!tp)
    { tp = (struct soap_attribute*)SOAP_MALLOC(soap, sizeof(struct soap_attribute) + strlen(soap->tmpbuf));
      if (!tp)
        return soap->error = SOAP_EOM;
      strcpy(tp->name, soap->tmpbuf);
",unused,ssocopsacc_gsoap-gsoap2Fstdsoap2.c
"            tp->size = SOAP_LABLEN;
        }
        if (!(tp->value = (char*)SOAP_MALLOC(soap, tp->size)))
          return soap->error = SOAP_EOM;
        strcpy(tp->value, soap->labbuf);
",1,unused,9675,unused,"            tp->size = SOAP_LABLEN;
        }
        if (!(tp->value = (char*)SOAP_MALLOC(soap, tp->size)))
          return soap->error = SOAP_EOM;
        strcpy(tp->value, soap->labbuf);
",unused,ssocopsacc_gsoap-gsoap2Fstdsoap2.c
"    { if (tp->visible)
      { if (t >= soap->tmpbuf + sizeof(soap->tmpbuf) - 2)
          break;
        *t++ = ' ';
        strcpy(t, tp->name);
",1,unused,9989,unused,"    { if (tp->visible)
      { if (t >= soap->tmpbuf + sizeof(soap->tmpbuf) - 2)
          break;
        *t++ = ' ';
        strcpy(t, tp->name);
",unused,ssocopsacc_gsoap-gsoap2Fstdsoap2.c
"          break; /* too many or large attribute values */
        if (tp->value)
        { *t++ = '=';
          *t++ = '""';
          strcpy(t, tp->value);
",1,unused,9996,unused,"          break; /* too many or large attribute values */
        if (tp->value)
        { *t++ = '=';
          *t++ = '""';
          strcpy(t, tp->value);
",unused,ssocopsacc_gsoap-gsoap2Fstdsoap2.c
"      { if (tp->visible)
        { if (t >= soap->tmpbuf + sizeof(soap->tmpbuf) - 2)
            break;
          *t++ = ' ';
          strcpy(t, tp->name);
",1,unused,10545,unused,"      { if (tp->visible)
        { if (t >= soap->tmpbuf + sizeof(soap->tmpbuf) - 2)
            break;
          *t++ = ' ';
          strcpy(t, tp->name);
",unused,ssocopsacc_gsoap-gsoap2Fstdsoap2.c
"            break;
          if (tp->value)
          { *t++ = '=';
            *t++ = '""';
            strcpy(t, tp->value);
",1,unused,10552,unused,"            break;
          if (tp->value)
          { *t++ = '=';
            *t++ = '""';
            strcpy(t, tp->value);
",unused,ssocopsacc_gsoap-gsoap2Fstdsoap2.c
"SOAP_FMAC1
const char*
SOAP_FMAC2
soap_long2s(struct soap *soap, long n)
{ sprintf(soap->tmpbuf, ""%ld"", n);
",1,unused,10760,unused,"SOAP_FMAC1
const char*
SOAP_FMAC2
soap_long2s(struct soap *soap, long n)
{ sprintf(soap->tmpbuf, ""%ld"", n);
",unused,ssocopsacc_gsoap-gsoap2Fstdsoap2.c
"SOAP_FMAC1
const char*
SOAP_FMAC2
soap_LONG642s(struct soap *soap, LONG64 n)
{ sprintf(soap->tmpbuf, SOAP_LONG_FORMAT, n);
",1,unused,10843,unused,"SOAP_FMAC1
const char*
SOAP_FMAC2
soap_LONG642s(struct soap *soap, LONG64 n)
{ sprintf(soap->tmpbuf, SOAP_LONG_FORMAT, n);
",unused,ssocopsacc_gsoap-gsoap2Fstdsoap2.c
"  s = soap->tmpbuf;
#if defined(HAVE_SPRINTF_L)
  sprintf_l(s, soap->c_locale, soap->float_format, n);
#else
  sprintf(s, soap->float_format, n);
",1,unused,11093,unused,"  s = soap->tmpbuf;
#if defined(HAVE_SPRINTF_L)
  sprintf_l(s, soap->c_locale, soap->float_format, n);
#else
  sprintf(s, soap->float_format, n);
",unused,ssocopsacc_gsoap-gsoap2Fstdsoap2.c
"  s = soap->tmpbuf;
#if defined(HAVE_SPRINTF_L)
  sprintf_l(s, soap->c_locale, soap->double_format, n);
#else
  sprintf(s, soap->double_format, n);
",1,unused,11239,unused,"  s = soap->tmpbuf;
#if defined(HAVE_SPRINTF_L)
  sprintf_l(s, soap->c_locale, soap->double_format, n);
#else
  sprintf(s, soap->double_format, n);
",unused,ssocopsacc_gsoap-gsoap2Fstdsoap2.c
"SOAP_FMAC1
const char*
SOAP_FMAC2
soap_unsignedLong2s(struct soap *soap, unsigned long n)
{ sprintf(soap->tmpbuf, ""%lu"", n);
",1,unused,11562,unused,"SOAP_FMAC1
const char*
SOAP_FMAC2
soap_unsignedLong2s(struct soap *soap, unsigned long n)
{ sprintf(soap->tmpbuf, ""%lu"", n);
",unused,ssocopsacc_gsoap-gsoap2Fstdsoap2.c
"SOAP_FMAC1
const char*
SOAP_FMAC2
soap_ULONG642s(struct soap *soap, ULONG64 n)
{ sprintf(soap->tmpbuf, SOAP_ULONG_FORMAT, n);
",1,unused,11645,unused,"SOAP_FMAC1
const char*
SOAP_FMAC2
soap_ULONG642s(struct soap *soap, ULONG64 n)
{ sprintf(soap->tmpbuf, SOAP_ULONG_FORMAT, n);
",unused,ssocopsacc_gsoap-gsoap2Fstdsoap2.c
"          }
          else /* not in namespace table: create xmlns binding */
          { char *r = soap_strdup(soap, s);
            r[q-s] = '\0';
            sprintf(soap->tmpbuf, ""xmlns:_%d"", soap->idnum++);
",1,unused,11894,unused,"          }
          else /* not in namespace table: create xmlns binding */
          { char *r = soap_strdup(soap, s);
            r[q-s] = '\0';
            sprintf(soap->tmpbuf, ""xmlns:_%d"", soap->idnum++);
",unused,ssocopsacc_gsoap-gsoap2Fstdsoap2.c
"  if ((pT = localtime(&n)))
    strftime(soap->tmpbuf, sizeof(soap->tmpbuf), ""%Y-%m-%dT%H:%M:%S"", pT);
#endif
  else
    strcpy(soap->tmpbuf, ""1969-12-31T23:59:59Z"");
",1,unused,12243,unused,"  if ((pT = localtime(&n)))
    strftime(soap->tmpbuf, sizeof(soap->tmpbuf), ""%Y-%m-%dT%H:%M:%S"", pT);
#endif
  else
    strcpy(soap->tmpbuf, ""1969-12-31T23:59:59Z"");
",unused,ssocopsacc_gsoap-gsoap2Fstdsoap2.c
"    { s[0] = (char)(optype >> 8);
      s[1] = (char)(optype & 0xFF);
      s[2] = (char)(n >> 8);
      s[3] = (char)(n & 0xFF);
      strcpy(s + 4, option);
",1,unused,12688,unused,"    { s[0] = (char)(optype >> 8);
      s[1] = (char)(optype & 0xFF);
      s[2] = (char)(n >> 8);
      s[3] = (char)(n & 0xFF);
      strcpy(s + 4, option);
",unused,ssocopsacc_gsoap-gsoap2Fstdsoap2.c
"        }
        if (flag || c == '\r')
        { t = soap->msgbuf;
          memset(t, 0, sizeof(soap->msgbuf));
          strcpy(t, ""\n--"");
",1,unused,13182,unused,"        }
        if (flag || c == '\r')
        { t = soap->msgbuf;
          memset(t, 0, sizeof(soap->msgbuf));
          strcpy(t, ""\n--"");
",unused,ssocopsacc_gsoap-gsoap2Fstdsoap2.c
"      s = soap->mime.boundary = (char*)soap_malloc(soap, n + 1);
      if (!s)
        return;
    }
    strcpy(s, ""=="");
",1,unused,13550,unused,"      s = soap->mime.boundary = (char*)soap_malloc(soap, n + 1);
      if (!s)
        return;
    }
    strcpy(s, ""=="");
",unused,ssocopsacc_gsoap-gsoap2Fstdsoap2.c
"    while (n)
    { *s++ = soap_base64o[soap_random & 0x3F];
      n--;
    }
    strcpy(s, ""=="");
",1,unused,13557,unused,"    while (n)
    { *s++ = soap_base64o[soap_random & 0x3F];
      n--;
    }
    strcpy(s, ""=="");
",unused,ssocopsacc_gsoap-gsoap2Fstdsoap2.c
"    else if (soap->mode & SOAP_ENC_MTOM)
      s = ""application/xop+xml; charset=utf-8; type=\""text/xml\"""";
    else
      s = ""text/xml; charset=utf-8"";
    sprintf(soap->tmpbuf, ""--%s\r\nContent-Type: %s\r\nContent-Transfer-Encoding: binary\r\nContent-ID: %s\r\n\r\n"", soap->mime.boundary, s, soap->mime.start);
",1,unused,13907,unused,"    else if (soap->mode & SOAP_ENC_MTOM)
      s = ""application/xop+xml; charset=utf-8; type=\""text/xml\"""";
    else
      s = ""text/xml; charset=utf-8"";
    sprintf(soap->tmpbuf, ""--%s\r\nContent-Type: %s\r\nContent-Transfer-Encoding: binary\r\nContent-ID: %s\r\n\r\n"", soap->mime.boundary, s, soap->mime.start);
",unused,ssocopsacc_gsoap-gsoap2Fstdsoap2.c
"    return soap->error;
#ifndef WITH_LEANER
  if ((soap->mode & SOAP_IO_LENGTH) && (soap->mode & SOAP_ENC_DIME) && !(soap->mode & SOAP_ENC_MTOM))
  { soap->dime.size = soap->count - soap->dime.size;	/* DIME in MIME correction */
    sprintf(soap->id, soap->dime_id_format, 0);
",1,unused,13935,unused,"    return soap->error;
#ifndef WITH_LEANER
  if ((soap->mode & SOAP_IO_LENGTH) && (soap->mode & SOAP_ENC_DIME) && !(soap->mode & SOAP_ENC_MTOM))
  { soap->dime.size = soap->count - soap->dime.size;	/* DIME in MIME correction */
    sprintf(soap->id, soap->dime_id_format, 0);
",unused,ssocopsacc_gsoap-gsoap2Fstdsoap2.c
"    { soap->version = 1; /* make sure we use SOAP 1.1 */
      if (p[1].out)
        SOAP_FREE(soap, p[1].out);
      if ((p[1].out = (char*)SOAP_MALLOC(soap, sizeof(soap_enc1))))
        strcpy(p[1].out, soap_enc1);
",1,unused,14042,unused,"    { soap->version = 1; /* make sure we use SOAP 1.1 */
      if (p[1].out)
        SOAP_FREE(soap, p[1].out);
      if ((p[1].out = (char*)SOAP_MALLOC(soap, sizeof(soap_enc1))))
        strcpy(p[1].out, soap_enc1);
",unused,ssocopsacc_gsoap-gsoap2Fstdsoap2.c
"    { soap->version = 2; /* make sure we use SOAP 1.2 */
      if (p[1].out)
        SOAP_FREE(soap, p[1].out);
      if ((p[1].out = (char*)SOAP_MALLOC(soap, sizeof(soap_enc2))))
        strcpy(p[1].out, soap_enc2);
",1,unused,14049,unused,"    { soap->version = 2; /* make sure we use SOAP 1.2 */
      if (p[1].out)
        SOAP_FREE(soap, p[1].out);
      if ((p[1].out = (char*)SOAP_MALLOC(soap, sizeof(soap_enc2))))
        strcpy(p[1].out, soap_enc2);
",unused,ssocopsacc_gsoap-gsoap2Fstdsoap2.c
"{ char host[sizeof(soap->host)];
  int port;
  size_t count;
  soap->error = SOAP_OK;
  strcpy(host, soap->host); /* save previous host name: if != then reconnect */
",1,unused,14261,unused,"{ char host[sizeof(soap->host)];
  int port;
  size_t count;
  soap->error = SOAP_OK;
  strcpy(host, soap->host); /* save previous host name: if != then reconnect */
",unused,ssocopsacc_gsoap-gsoap2Fstdsoap2.c
"        s = ""application/dime"";
    }
    if ((soap->mode & SOAP_ENC_MIME) && soap->mime.boundary && strlen(soap->mime.boundary) + strlen(soap->mime.start ? soap->mime.start : SOAP_STR_EOS) < sizeof(soap->tmpbuf) - 80)
    { register const char *t = strchr(s, ';');
      sprintf(soap->tmpbuf, ""multipart/related; charset=utf-8; boundary=\""%s\""; type=\"""", soap->mime.boundary);
",1,unused,14538,unused,"        s = ""application/dime"";
    }
    if ((soap->mode & SOAP_ENC_MIME) && soap->mime.boundary && strlen(soap->mime.boundary) + strlen(soap->mime.start ? soap->mime.start : SOAP_STR_EOS) < sizeof(soap->tmpbuf) - 80)
    { register const char *t = strchr(s, ';');
      sprintf(soap->tmpbuf, ""multipart/related; charset=utf-8; boundary=\""%s\""; type=\"""", soap->mime.boundary);
",unused,ssocopsacc_gsoap-gsoap2Fstdsoap2.c
"      { strncat(soap->tmpbuf, s, t - s);
        soap->tmpbuf[sizeof(soap->tmpbuf)-1] = '\0';
      }
      else
        strcat(soap->tmpbuf, s);
",1,unused,14544,unused,"      { strncat(soap->tmpbuf, s, t - s);
        soap->tmpbuf[sizeof(soap->tmpbuf)-1] = '\0';
      }
      else
        strcat(soap->tmpbuf, s);
",unused,ssocopsacc_gsoap-gsoap2Fstdsoap2.c
"      }
      else
        strcat(soap->tmpbuf, s);
      if (soap->mime.start)
      { strcat(soap->tmpbuf, ""\""; start=\"""");
",1,unused,14546,unused,"      }
      else
        strcat(soap->tmpbuf, s);
      if (soap->mime.start)
      { strcat(soap->tmpbuf, ""\""; start=\"""");
",unused,ssocopsacc_gsoap-gsoap2Fstdsoap2.c
"      else
        strcat(soap->tmpbuf, s);
      if (soap->mime.start)
      { strcat(soap->tmpbuf, ""\""; start=\"""");
        strcat(soap->tmpbuf, soap->mime.start);
",1,unused,14547,unused,"      else
        strcat(soap->tmpbuf, s);
      if (soap->mime.start)
      { strcat(soap->tmpbuf, ""\""; start=\"""");
        strcat(soap->tmpbuf, soap->mime.start);
",unused,ssocopsacc_gsoap-gsoap2Fstdsoap2.c
"      if (soap->mime.start)
      { strcat(soap->tmpbuf, ""\""; start=\"""");
        strcat(soap->tmpbuf, soap->mime.start);
      }
      strcat(soap->tmpbuf, ""\"""");
",1,unused,14549,unused,"      if (soap->mime.start)
      { strcat(soap->tmpbuf, ""\""; start=\"""");
        strcat(soap->tmpbuf, soap->mime.start);
      }
      strcat(soap->tmpbuf, ""\"""");
",unused,ssocopsacc_gsoap-gsoap2Fstdsoap2.c
"        strcat(soap->tmpbuf, soap->mime.start);
      }
      strcat(soap->tmpbuf, ""\"""");
      if (r)
      { strcat(soap->tmpbuf, ""; start-info=\"""");
",1,unused,14551,unused,"        strcat(soap->tmpbuf, soap->mime.start);
      }
      strcat(soap->tmpbuf, ""\"""");
      if (r)
      { strcat(soap->tmpbuf, ""; start-info=\"""");
",unused,ssocopsacc_gsoap-gsoap2Fstdsoap2.c
"      }
      strcat(soap->tmpbuf, ""\"""");
      if (r)
      { strcat(soap->tmpbuf, ""; start-info=\"""");
        strcat(soap->tmpbuf, r);
",1,unused,14552,unused,"      }
      strcat(soap->tmpbuf, ""\"""");
      if (r)
      { strcat(soap->tmpbuf, ""; start-info=\"""");
        strcat(soap->tmpbuf, r);
",unused,ssocopsacc_gsoap-gsoap2Fstdsoap2.c
"      strcat(soap->tmpbuf, ""\"""");
      if (r)
      { strcat(soap->tmpbuf, ""; start-info=\"""");
        strcat(soap->tmpbuf, r);
        strcat(soap->tmpbuf, ""\"""");
",1,unused,14553,unused,"      strcat(soap->tmpbuf, ""\"""");
      if (r)
      { strcat(soap->tmpbuf, ""; start-info=\"""");
        strcat(soap->tmpbuf, r);
        strcat(soap->tmpbuf, ""\"""");
",unused,ssocopsacc_gsoap-gsoap2Fstdsoap2.c
"      err = soap->fposthdr(soap, ""Transfer-Encoding"", ""chunked"");
    else
#endif
    if (s)
    { sprintf(soap->tmpbuf, ""%lu"", (unsigned long)count);
",1,unused,14578,unused,"      err = soap->fposthdr(soap, ""Transfer-Encoding"", ""chunked"");
    else
#endif
    if (s)
    { sprintf(soap->tmpbuf, ""%lu"", (unsigned long)count);
",unused,ssocopsacc_gsoap-gsoap2Fstdsoap2.c
"#ifndef WITH_LEAN
static const char*
soap_set_validation_fault(struct soap *soap, const char *s, const char *t)
{ if (*soap->tag)
    sprintf(soap->msgbuf, ""Validation constraint violation: %s%s in element '%s'"", s, t?t:SOAP_STR_EOS, soap->tag);
",1,unused,14594,unused,"#ifndef WITH_LEAN
static const char*
soap_set_validation_fault(struct soap *soap, const char *s, const char *t)
{ if (*soap->tag)
    sprintf(soap->msgbuf, ""Validation constraint violation: %s%s in element '%s'"", s, t?t:SOAP_STR_EOS, soap->tag);
",unused,ssocopsacc_gsoap-gsoap2Fstdsoap2.c
"soap_set_validation_fault(struct soap *soap, const char *s, const char *t)
{ if (*soap->tag)
    sprintf(soap->msgbuf, ""Validation constraint violation: %s%s in element '%s'"", s, t?t:SOAP_STR_EOS, soap->tag);
  else
    sprintf(soap->msgbuf, ""Validation constraint violation: %s%s"", s, t?t:SOAP_STR_EOS);
",1,unused,14596,unused,"soap_set_validation_fault(struct soap *soap, const char *s, const char *t)
{ if (*soap->tag)
    sprintf(soap->msgbuf, ""Validation constraint violation: %s%s in element '%s'"", s, t?t:SOAP_STR_EOS, soap->tag);
  else
    sprintf(soap->msgbuf, ""Validation constraint violation: %s%s"", s, t?t:SOAP_STR_EOS);
",unused,ssocopsacc_gsoap-gsoap2Fstdsoap2.c
"      *s = ""No XML root element"";
      break;
    case SOAP_MUSTUNDERSTAND:
      *c = ""SOAP-ENV:MustUnderstand"";
      sprintf(soap->msgbuf, ""The data in element '%s' must be understood but cannot be handled"", soap->tag);
",1,unused,14642,unused,"      *s = ""No XML root element"";
      break;
    case SOAP_MUSTUNDERSTAND:
      *c = ""SOAP-ENV:MustUnderstand"";
      sprintf(soap->msgbuf, ""The data in element '%s' must be understood but cannot be handled"", soap->tag);
",unused,ssocopsacc_gsoap-gsoap2Fstdsoap2.c
"    case SOAP_FATAL_ERROR:
      *s = ""Fatal error"";
      break;
    case SOAP_NO_METHOD:
      sprintf(soap->msgbuf, ""Method '%s' not implemented: method name or namespace not recognized"", soap->tag);
",1,unused,14663,unused,"    case SOAP_FATAL_ERROR:
      *s = ""Fatal error"";
      break;
    case SOAP_NO_METHOD:
      sprintf(soap->msgbuf, ""Method '%s' not implemented: method name or namespace not recognized"", soap->tag);
",unused,ssocopsacc_gsoap-gsoap2Fstdsoap2.c
"      break;
#endif
    case SOAP_EOF:
#ifndef WITH_NOIO
      strcpy(soap->msgbuf, soap_strerror(soap));
",1,unused,14782,unused,"      break;
#endif
    case SOAP_EOF:
#ifndef WITH_NOIO
      strcpy(soap->msgbuf, soap_strerror(soap));
",unused,ssocopsacc_gsoap-gsoap2Fstdsoap2.c
"    default:
#ifndef WITH_NOHTTP
#ifndef WITH_LEAN
      if (soap->error > 200 && soap->error < 600)
      { sprintf(soap->msgbuf, ""HTTP Error: %d %s"", soap->error, http_error(soap, soap->error));
",1,unused,14799,unused,"    default:
#ifndef WITH_NOHTTP
#ifndef WITH_LEAN
      if (soap->error > 200 && soap->error < 600)
      { sprintf(soap->msgbuf, ""HTTP Error: %d %s"", soap->error, http_error(soap, soap->error));
",unused,ssocopsacc_gsoap-gsoap2Fstdsoap2.c
"      }
      else
#endif
#endif
      { sprintf(soap->msgbuf, ""Error %d"", soap->error);
",1,unused,14805,unused,"      }
      else
#endif
#endif
      { sprintf(soap->msgbuf, ""Error %d"", soap->error);
",unused,ssocopsacc_gsoap-gsoap2Fstdsoap2.c
"#ifndef WITH_LEAN
    int rt = soap->recv_timeout, st = soap->send_timeout;
    int ru = ' ', su = ' ';
#endif
    strcpy(s, ""Operation interrupted or timed out"");
",1,unused,14991,unused,"#ifndef WITH_LEAN
    int rt = soap->recv_timeout, st = soap->send_timeout;
    int ru = ' ', su = ' ';
#endif
    strcpy(s, ""Operation interrupted or timed out"");
",unused,ssocopsacc_gsoap-gsoap2Fstdsoap2.c
"    { st = -st;
      su = 'u';
    }
    if (rt)
      sprintf(s + strlen(s), "" (%d%cs receive delay)"", rt, ru);
",1,unused,15002,unused,"    { st = -st;
      su = 'u';
    }
    if (rt)
      sprintf(s + strlen(s), "" (%d%cs receive delay)"", rt, ru);
",unused,ssocopsacc_gsoap-gsoap2Fstdsoap2.c
"    }
    if (rt)
      sprintf(s + strlen(s), "" (%d%cs receive delay)"", rt, ru);
    if (st)
      sprintf(s + strlen(s), "" (%d%cs send delay)"", st, su);
",1,unused,15004,unused,"    }
    if (rt)
      sprintf(s + strlen(s), "" (%d%cs receive delay)"", rt, ru);
    if (st)
      sprintf(s + strlen(s), "" (%d%cs send delay)"", st, su);
",unused,ssocopsacc_gsoap-gsoap2Fstdsoap2.c
"		perror( ""malloc"" );
		return EXIT_FAILURE;
	}

	sprintf( def_urlpre, ""file:///%s/"",
",1,unused,812,unused,"		perror( ""malloc"" );
		return EXIT_FAILURE;
	}

	sprintf( def_urlpre, ""file:///%s/"",
",unused,ssocopsacc_openldap-clients2Ftools2Fldapsearch.c
"			perror( ""malloc"" );
			return EXIT_FAILURE;
		}

		sprintf( urlpre, ""file:///%s/"",
",1,unused,882,unused,"			perror( ""malloc"" );
			return EXIT_FAILURE;
		}

		sprintf( urlpre, ""file:///%s/"",
",unused,ssocopsacc_openldap-clients2Ftools2Fldapsearch.c
"	} else {
		len = ber_pvt_ber_write(ber);
	}

	sprintf( buf, ""ber_dump: buf=%p ptr=%p end=%p len=%ld\n"",
",1,unused,268,unused,"	} else {
		len = ber_pvt_ber_write(ber);
	}

	sprintf( buf, ""ber_dump: buf=%p ptr=%p end=%p len=%ld\n"",
",unused,ssocopsacc_openldap-libraries2Fliblber2Fbprint.c
"	}
#endif

	if (debug_lastc == '\n') {
		sprintf(buffer, ""%08x "", (unsigned) time(0L));
",1,unused,68,unused,"	}
#endif

	if (debug_lastc == '\n') {
		sprintf(buffer, ""%08x "", (unsigned) time(0L));
",unused,ssocopsacc_openldap-libraries2Fliblber2Fdebug.c
"				/* Initial ""x.y"": val=x*40+y, x<=2, y<40 if x<2 */
				ptr = out->bv_val;
				val1 = (val < 80 ? val/40 : 2);
				val -= val1*40;
				ptr += sprintf( ptr, ""%u"", val1 );
",1,unused,71,unused,"				/* Initial ""x.y"": val=x*40+y, x<=2, y<40 if x<2 */
				ptr = out->bv_val;
				val1 = (val < 80 ? val/40 : 2);
				val -= val1*40;
				ptr += sprintf( ptr, ""%u"", val1 );
",unused,ssocopsacc_openldap-libraries2Fliblber2Fdecode.c
"				val1 = (val < 80 ? val/40 : 2);
				val -= val1*40;
				ptr += sprintf( ptr, ""%u"", val1 );
			}
			ptr += sprintf( ptr, "".%lu"", val );
",1,unused,73,unused,"				val1 = (val < 80 ? val/40 : 2);
				val -= val1*40;
				ptr += sprintf( ptr, ""%u"", val1 );
			}
			ptr += sprintf( ptr, "".%lu"", val );
",unused,ssocopsacc_openldap-libraries2Fliblber2Fdecode.c
"
	sbiod->sbiod_pvt = LBER_MALLOC( strlen( arg ) + 1 );
	if ( sbiod->sbiod_pvt == NULL ) return -1;

	strcpy( (char *)sbiod->sbiod_pvt, (char *)arg );
",1,unused,802,unused,"
	sbiod->sbiod_pvt = LBER_MALLOC( strlen( arg ) + 1 );
	if ( sbiod->sbiod_pvt == NULL ) return -1;

	strcpy( (char *)sbiod->sbiod_pvt, (char *)arg );
",unused,ssocopsacc_openldap-libraries2Fliblber2Fsockbuf.c
"		dn = dntmp;

		if (loc > 0) {
		    /* not first time. */
		    strcpy(dn + loc, "","");
",1,unused,162,unused,"		dn = dntmp;

		if (loc > 0) {
		    /* not first time. */
		    strcpy(dn + loc, "","");
",unused,ssocopsacc_openldap-libraries2Flibldap_r2Fdnssrv.c
"		    /* not first time. */
		    strcpy(dn + loc, "","");
		    loc++;
		}
		strcpy(dn + loc, ""dc="");
",1,unused,165,unused,"		    /* not first time. */
		    strcpy(dn + loc, "","");
		    loc++;
		}
		strcpy(dn + loc, ""dc="");
",unused,ssocopsacc_openldap-libraries2Flibldap_r2Fdnssrv.c
"		}
		strcpy(dn + loc, ""dc="");
		loc += sizeof(""dc="")-1;

		strcpy(dn + loc, s);
",1,unused,168,unused,"		}
		strcpy(dn + loc, ""dc="");
		loc += sizeof(""dc="")-1;

		strcpy(dn + loc, s);
",unused,ssocopsacc_openldap-libraries2Flibldap_r2Fdnssrv.c
"    request = LDAP_MALLOC(strlen(domain) + sizeof(""_ldap._tcp.""));
    if (request == NULL) {
		return LDAP_NO_MEMORY;
    }
    sprintf(request, ""_ldap._tcp.%s"", domain);
",1,unused,280,unused,"    request = LDAP_MALLOC(strlen(domain) + sizeof(""_ldap._tcp.""));
    if (request == NULL) {
		return LDAP_NO_MEMORY;
    }
    sprintf(request, ""_ldap._tcp.%s"", domain);
",unused,ssocopsacc_openldap-libraries2Flibldap_r2Fdnssrv.c
"        }
        if(cur>0){
            hostlist[cur++]=' ';
        }
        cur += sprintf(&hostlist[cur], ""%s:%hu"", hostent_head[i].hostname, hostent_head[i].port);
",1,unused,402,unused,"        }
        if(cur>0){
            hostlist[cur++]=' ';
        }
        cur += sprintf(&hostlist[cur], ""%s:%hu"", hostent_head[i].hostname, hostent_head[i].port);
",unused,ssocopsacc_openldap-libraries2Flibldap_r2Fdnssrv.c
"	if(home != NULL && path != NULL) {
		/* we assume UNIX path syntax is used... */

		/* try ~/file */
		sprintf(path, ""%s"" LDAP_DIRSEP ""%s"", home, file);
",1,unused,344,unused,"	if(home != NULL && path != NULL) {
		/* we assume UNIX path syntax is used... */

		/* try ~/file */
		sprintf(path, ""%s"" LDAP_DIRSEP ""%s"", home, file);
",unused,ssocopsacc_openldap-libraries2Flibldap_r2Finit.c
"		sprintf(path, ""%s"" LDAP_DIRSEP ""%s"", home, file);
		openldap_ldap_init_w_conf(path, 1);

		/* try ~/.file */
		sprintf(path, ""%s"" LDAP_DIRSEP "".%s"", home, file);
",1,unused,348,unused,"		sprintf(path, ""%s"" LDAP_DIRSEP ""%s"", home, file);
		openldap_ldap_init_w_conf(path, 1);

		/* try ~/.file */
		sprintf(path, ""%s"" LDAP_DIRSEP "".%s"", home, file);
",unused,ssocopsacc_openldap-libraries2Flibldap_r2Finit.c
"	buf[MAX_LDAP_ENV_PREFIX_LEN] = '\0';
	len = strlen(buf);

	for(i=0; attrs[i].type != ATTR_NONE; i++) {
		strcpy(&buf[len], attrs[i].name);
",1,unused,379,unused,"	buf[MAX_LDAP_ENV_PREFIX_LEN] = '\0';
	len = strlen(buf);

	for(i=0; attrs[i].type != ATTR_NONE; i++) {
		strcpy(&buf[len], attrs[i].name);
",unused,ssocopsacc_openldap-libraries2Flibldap_r2Finit.c
"	/* name (attribute type) */
	if( name != NULL ) {
		/* put the name + "":"" */
		namelen = strlen(name);
		strcpy(*out, name);
",1,unused,549,unused,"	/* name (attribute type) */
	if( name != NULL ) {
		/* put the name + "":"" */
		namelen = strlen(name);
		strcpy(*out, name);
",unused,ssocopsacc_openldap-libraries2Flibldap_r2Fldif.c
"				return 0;
			}
			*bufp = nbufp;
		}
		strcpy( *bufp + lcur, line );
",1,unused,939,unused,"				return 0;
			}
			*bufp = nbufp;
		}
		strcpy( *bufp + lcur, line );
",unused,ssocopsacc_openldap-libraries2Flibldap_r2Fldif.c
"	oslocal_debug(ld, ""ldap_connect_to_path: Trying %s\n"", path, 0, 0);

	memset( &server, '\0', sizeof(server) );
	server.sun_family = AF_LOCAL;
	strcpy( server.sun_path, path );
",1,unused,349,unused,"	oslocal_debug(ld, ""ldap_connect_to_path: Trying %s\n"", path, 0, 0);

	memset( &server, '\0', sizeof(server) );
	server.sun_family = AF_LOCAL;
	strcpy( server.sun_path, path );
",unused,ssocopsacc_openldap-libraries2Flibldap_r2Fos-local.c
"		return( -1 );
	}

	if ( first ) {
		strcpy( *referralsp, LDAP_REF_STR );
",1,unused,1504,unused,"		return( -1 );
	}

	if ( first ) {
		strcpy( *referralsp, LDAP_REF_STR );
",unused,ssocopsacc_openldap-libraries2Flibldap_r2Frequest.c
"
	if ( first ) {
		strcpy( *referralsp, LDAP_REF_STR );
	} else {
		strcat( *referralsp, ""\n"" );
",1,unused,1506,unused,"
	if ( first ) {
		strcpy( *referralsp, LDAP_REF_STR );
	} else {
		strcat( *referralsp, ""\n"" );
",unused,ssocopsacc_openldap-libraries2Flibldap_r2Frequest.c
"		strcpy( *referralsp, LDAP_REF_STR );
	} else {
		strcat( *referralsp, ""\n"" );
	}
	strcat( *referralsp, s );
",1,unused,1508,unused,"		strcpy( *referralsp, LDAP_REF_STR );
	} else {
		strcat( *referralsp, ""\n"" );
	}
	strcat( *referralsp, s );
",unused,ssocopsacc_openldap-libraries2Flibldap_r2Frequest.c
"
	authmethod = LDAP_AUTH_SIMPLE;

		get_line( dn, sizeof(dn), stdin, ""re-bind dn? "" );
		strcat( dn, dnsuffix );
",1,unused,258,unused,"
	authmethod = LDAP_AUTH_SIMPLE;

		get_line( dn, sizeof(dn), stdin, ""re-bind dn? "" );
		strcat( dn, dnsuffix );
",unused,ssocopsacc_openldap-libraries2Flibldap_r2Ftest.c
"		case 'a':	/* add or abandon */
			switch ( command2 ) {
			case 'd':	/* add */
				get_line( dn, sizeof(dn), stdin, ""dn? "" );
				strcat( dn, dnsuffix );
",1,unused,381,unused,"		case 'a':	/* add or abandon */
			switch ( command2 ) {
			case 'd':	/* add */
				get_line( dn, sizeof(dn), stdin, ""dn? "" );
				strcat( dn, dnsuffix );
",unused,ssocopsacc_openldap-libraries2Flibldap_r2Ftest.c
"
		case 'b':	/* asynch bind */
			method = LDAP_AUTH_SIMPLE;
			get_line( dn, sizeof(dn), stdin, ""dn? "" );
			strcat( dn, dnsuffix );
",1,unused,408,unused,"
		case 'b':	/* asynch bind */
			method = LDAP_AUTH_SIMPLE;
			get_line( dn, sizeof(dn), stdin, ""dn? "" );
			strcat( dn, dnsuffix );
",unused,ssocopsacc_openldap-libraries2Flibldap_r2Ftest.c
"
		case 'B':	/* synch bind */
			method = LDAP_AUTH_SIMPLE;
			get_line( dn, sizeof(dn), stdin, ""dn? "" );
			strcat( dn, dnsuffix );
",1,unused,428,unused,"
		case 'B':	/* synch bind */
			method = LDAP_AUTH_SIMPLE;
			get_line( dn, sizeof(dn), stdin, ""dn? "" );
			strcat( dn, dnsuffix );
",unused,ssocopsacc_openldap-libraries2Flibldap_r2Ftest.c
"			break;

		case 'c':	/* compare */
			get_line( dn, sizeof(dn), stdin, ""dn? "" );
			strcat( dn, dnsuffix );
",1,unused,448,unused,"			break;

		case 'c':	/* compare */
			get_line( dn, sizeof(dn), stdin, ""dn? "" );
			strcat( dn, dnsuffix );
",unused,ssocopsacc_openldap-libraries2Flibldap_r2Ftest.c
"
		case 'm':	/* modify or modifyrdn */
			if ( strncmp( line, ""modify"", 4 ) == 0 ) {
				get_line( dn, sizeof(dn), stdin, ""dn? "" );
				strcat( dn, dnsuffix );
",1,unused,493,unused,"
		case 'm':	/* modify or modifyrdn */
			if ( strncmp( line, ""modify"", 4 ) == 0 ) {
				get_line( dn, sizeof(dn), stdin, ""dn? "" );
				strcat( dn, dnsuffix );
",unused,ssocopsacc_openldap-libraries2Flibldap_r2Ftest.c
"					printf( ""Modify initiated with id %d\n"",
					    id );
			} else if ( strncmp( line, ""modrdn"", 4 ) == 0 ) {
				get_line( dn, sizeof(dn), stdin, ""dn? "" );
				strcat( dn, dnsuffix );
",1,unused,506,unused,"					printf( ""Modify initiated with id %d\n"",
					    id );
			} else if ( strncmp( line, ""modrdn"", 4 ) == 0 ) {
				get_line( dn, sizeof(dn), stdin, ""dn? "" );
				strcat( dn, dnsuffix );
",unused,ssocopsacc_openldap-libraries2Flibldap_r2Ftest.c
"				break;

			case 'm':	/* remove */
				get_line( dn, sizeof(dn), stdin, ""dn? "" );
				strcat( dn, dnsuffix );
",1,unused,551,unused,"				break;

			case 'm':	/* remove */
				get_line( dn, sizeof(dn), stdin, ""dn? "" );
				strcat( dn, dnsuffix );
",unused,ssocopsacc_openldap-libraries2Flibldap_r2Ftest.c
"			break;

		case 's':	/* search */
			get_line( dn, sizeof(dn), stdin, ""searchbase? "" );
			strcat( dn, dnsuffix );
",1,unused,567,unused,"			break;

		case 's':	/* search */
			get_line( dn, sizeof(dn), stdin, ""searchbase? "" );
			strcat( dn, dnsuffix );
",unused,ssocopsacc_openldap-libraries2Flibldap_r2Ftest.c
"			    break;

		case 'n':	/* set dn suffix, for convenience */
			get_line( line, sizeof(line), stdin, ""DN suffix? "" );
			strcpy( dnsuffix, line );
",1,unused,633,unused,"			    break;

		case 'n':	/* set dn suffix, for convenience */
			get_line( line, sizeof(line), stdin, ""DN suffix? "" );
			strcpy( dnsuffix, line );
",unused,ssocopsacc_openldap-libraries2Flibldap_r2Ftest.c
"			is_v6 = 1;
	}

	if ( u->lud_port ) {
		sofar = sprintf( s, ""%s://%s%s%s:%d"", u->lud_scheme,
",1,unused,649,unused,"			is_v6 = 1;
	}

	if ( u->lud_port ) {
		sofar = sprintf( s, ""%s://%s%s%s:%d"", u->lud_scheme,
",unused,ssocopsacc_openldap-libraries2Flibldap_r2Furl.c
"				u->lud_port );
		len -= sofar;

	} else {
		sofar = sprintf( s, ""%s://"", u->lud_scheme );
",1,unused,657,unused,"				u->lud_port );
		len -= sofar;

	} else {
		sofar = sprintf( s, ""%s://"", u->lud_scheme );
",unused,ssocopsacc_openldap-libraries2Flibldap_r2Furl.c
"
	assert( len >= 0 );

	if ( !BER_BVISNULL( &scope ) ) {
		strcpy( &s[sofar], scope.bv_val );
",1,unused,716,unused,"
	assert( len >= 0 );

	if ( !BER_BVISNULL( &scope ) ) {
		strcpy( &s[sofar], scope.bv_val );
",unused,ssocopsacc_openldap-libraries2Flibldap_r2Furl.c
"		size += strlen(ludp->lud_host) + 1;		/* host and space */
		if (strchr(ludp->lud_host, ':'))        /* will add [ ] below */
			size += 2;
		if (ludp->lud_port != 0)
			size += sprintf(buf, "":%d"", ludp->lud_port);
",1,unused,1433,unused,"		size += strlen(ludp->lud_host) + 1;		/* host and space */
		if (strchr(ludp->lud_host, ':'))        /* will add [ ] below */
			size += 2;
		if (ludp->lud_port != 0)
			size += sprintf(buf, "":%d"", ludp->lud_port);
",unused,ssocopsacc_openldap-libraries2Flibldap_r2Furl.c
"	p = s;
	for (ludp = ludlist; ludp != NULL; ludp = ludp->lud_next) {
		if ( ludp->lud_host == NULL ) continue;
		if (strchr(ludp->lud_host, ':')) {
			p += sprintf(p, ""[%s]"", ludp->lud_host);
",1,unused,1443,unused,"	p = s;
	for (ludp = ludlist; ludp != NULL; ludp = ludp->lud_next) {
		if ( ludp->lud_host == NULL ) continue;
		if (strchr(ludp->lud_host, ':')) {
			p += sprintf(p, ""[%s]"", ludp->lud_host);
",unused,ssocopsacc_openldap-libraries2Flibldap_r2Furl.c
"		if ( ludp->lud_host == NULL ) continue;
		if (strchr(ludp->lud_host, ':')) {
			p += sprintf(p, ""[%s]"", ludp->lud_host);
		} else {
			strcpy(p, ludp->lud_host);
",1,unused,1445,unused,"		if ( ludp->lud_host == NULL ) continue;
		if (strchr(ludp->lud_host, ':')) {
			p += sprintf(p, ""[%s]"", ludp->lud_host);
		} else {
			strcpy(p, ludp->lud_host);
",unused,ssocopsacc_openldap-libraries2Flibldap_r2Furl.c
"			strcpy(p, ludp->lud_host);
			p += strlen(ludp->lud_host);
		}
		if (ludp->lud_port != 0)
			p += sprintf(p, "":%d"", ludp->lud_port);
",1,unused,1449,unused,"			strcpy(p, ludp->lud_host);
			p += strlen(ludp->lud_host);
		}
		if (ludp->lud_port != 0)
			p += sprintf(p, "":%d"", ludp->lud_port);
",unused,ssocopsacc_openldap-libraries2Flibldap_r2Furl.c
"		*dest = '\0';
		return 1;
	}
	if ( duration == 0 ) {
		strcpy( dest, ""none"" );
",1,unused,54,unused,"		*dest = '\0';
		return 1;
	}
	if ( duration == 0 ) {
		strcpy( dest, ""none"" );
",unused,ssocopsacc_openldap-libraries2Fliblutil2Fmeter.c
"	if ( i > endargv - s - 2 ) {
		i = endargv - s - 2;
		buf[ i ] = '\0';
	}
	strcpy( s, buf );
",1,unused,74,unused,"	if ( i > endargv - s - 2 ) {
		i = endargv - s - 2;
		buf[ i ] = '\0';
	}
	strcpy( s, buf );
",unused,ssocopsacc_openldap-libraries2Fliblutil2Fsetproctitle.c
"		perror( ""malloc"" );
		return EXIT_FAILURE;
	}

	sprintf( def_urlpre, ""file:///%s/"",
",1,unused,812,unused,"		perror( ""malloc"" );
		return EXIT_FAILURE;
	}

	sprintf( def_urlpre, ""file:///%s/"",
",unused,ssocopsacc_openldap-serveradm-clients2Ftools2Fldapsearch.c
"			perror( ""malloc"" );
			return EXIT_FAILURE;
		}

		sprintf( urlpre, ""file:///%s/"",
",1,unused,882,unused,"			perror( ""malloc"" );
			return EXIT_FAILURE;
		}

		sprintf( urlpre, ""file:///%s/"",
",unused,ssocopsacc_openldap-serveradm-clients2Ftools2Fldapsearch.c
"	} else {
		len = ber_pvt_ber_write(ber);
	}

	sprintf( buf, ""ber_dump: buf=%p ptr=%p end=%p len=%ld\n"",
",1,unused,268,unused,"	} else {
		len = ber_pvt_ber_write(ber);
	}

	sprintf( buf, ""ber_dump: buf=%p ptr=%p end=%p len=%ld\n"",
",unused,ssocopsacc_openldap-serveradm-libraries2Fliblber2Fbprint.c
"	}
#endif

	if (debug_lastc == '\n') {
		sprintf(buffer, ""%08x "", (unsigned) time(0L));
",1,unused,68,unused,"	}
#endif

	if (debug_lastc == '\n') {
		sprintf(buffer, ""%08x "", (unsigned) time(0L));
",unused,ssocopsacc_openldap-serveradm-libraries2Fliblber2Fdebug.c
"				/* Initial ""x.y"": val=x*40+y, x<=2, y<40 if x<2 */
				ptr = out->bv_val;
				val1 = (val < 80 ? val/40 : 2);
				val -= val1*40;
				ptr += sprintf( ptr, ""%u"", val1 );
",1,unused,71,unused,"				/* Initial ""x.y"": val=x*40+y, x<=2, y<40 if x<2 */
				ptr = out->bv_val;
				val1 = (val < 80 ? val/40 : 2);
				val -= val1*40;
				ptr += sprintf( ptr, ""%u"", val1 );
",unused,ssocopsacc_openldap-serveradm-libraries2Fliblber2Fdecode.c
"				val1 = (val < 80 ? val/40 : 2);
				val -= val1*40;
				ptr += sprintf( ptr, ""%u"", val1 );
			}
			ptr += sprintf( ptr, "".%lu"", val );
",1,unused,73,unused,"				val1 = (val < 80 ? val/40 : 2);
				val -= val1*40;
				ptr += sprintf( ptr, ""%u"", val1 );
			}
			ptr += sprintf( ptr, "".%lu"", val );
",unused,ssocopsacc_openldap-serveradm-libraries2Fliblber2Fdecode.c
"
	sbiod->sbiod_pvt = LBER_MALLOC( strlen( arg ) + 1 );
	if ( sbiod->sbiod_pvt == NULL ) return -1;

	strcpy( (char *)sbiod->sbiod_pvt, (char *)arg );
",1,unused,802,unused,"
	sbiod->sbiod_pvt = LBER_MALLOC( strlen( arg ) + 1 );
	if ( sbiod->sbiod_pvt == NULL ) return -1;

	strcpy( (char *)sbiod->sbiod_pvt, (char *)arg );
",unused,ssocopsacc_openldap-serveradm-libraries2Fliblber2Fsockbuf.c
"	sasl_version( NULL, &rc );
	if ( ((rc >> 16) != ((SASL_VERSION_MAJOR << 8)|SASL_VERSION_MINOR)) ||
		(rc & 0xffff) < SASL_VERSION_STEP) {
		char version[sizeof(""xxx.xxx.xxxxx"")];
		sprintf( version, ""%u.%d.%d"", (unsigned)rc >> 24, (rc >> 16) & 0xff,
",1,unused,88,unused,"	sasl_version( NULL, &rc );
	if ( ((rc >> 16) != ((SASL_VERSION_MAJOR << 8)|SASL_VERSION_MINOR)) ||
		(rc & 0xffff) < SASL_VERSION_STEP) {
		char version[sizeof(""xxx.xxx.xxxxx"")];
		sprintf( version, ""%u.%d.%d"", (unsigned)rc >> 24, (rc >> 16) & 0xff,
",unused,ssocopsacc_openldap-serveradm-libraries2Flibldap_r2Fcyrus.c
"			ld->ld_defconn->lconn_server->lud_scheme ) == LDAP_PROTO_IPC )
		{
			char authid[sizeof(""gidNumber=4294967295+uidNumber=4294967295,""
				""cn=peercred,cn=external,cn=auth"")];
			sprintf( authid, ""gidNumber=%u+uidNumber=%u,""
",1,unused,495,unused,"			ld->ld_defconn->lconn_server->lud_scheme ) == LDAP_PROTO_IPC )
		{
			char authid[sizeof(""gidNumber=4294967295+uidNumber=4294967295,""
				""cn=peercred,cn=external,cn=auth"")];
			sprintf( authid, ""gidNumber=%u+uidNumber=%u,""
",unused,ssocopsacc_openldap-serveradm-libraries2Flibldap_r2Fcyrus.c
"			/* It is the default, ignore it */
			if ( v == sprops[i].idef ) continue;

			if ( comma ) *ptr++ = ',';
			ptr += sprintf(ptr, ""%s%d"", sprops[i].key.bv_val, v );
",1,unused,804,unused,"			/* It is the default, ignore it */
			if ( v == sprops[i].idef ) continue;

			if ( comma ) *ptr++ = ',';
			ptr += sprintf(ptr, ""%s%d"", sprops[i].key.bv_val, v );
",unused,ssocopsacc_openldap-serveradm-libraries2Flibldap_r2Fcyrus.c
"			comma = 1;
		} else if ( sprops[i].sflag ) {
			if ( sprops[i].sflag & secprops->security_flags ) {
				if ( comma ) *ptr++ = ',';
				ptr += sprintf(ptr, ""%s"", sprops[i].key.bv_val );
",1,unused,809,unused,"			comma = 1;
		} else if ( sprops[i].sflag ) {
			if ( sprops[i].sflag & secprops->security_flags ) {
				if ( comma ) *ptr++ = ',';
				ptr += sprintf(ptr, ""%s"", sprops[i].key.bv_val );
",unused,ssocopsacc_openldap-serveradm-libraries2Flibldap_r2Fcyrus.c
"				comma = 1;
			}
		} else if ( secprops->security_flags == 0 ) {
			if ( comma ) *ptr++ = ',';
			ptr += sprintf(ptr, ""%s"", sprops[i].key.bv_val );
",1,unused,814,unused,"				comma = 1;
			}
		} else if ( secprops->security_flags == 0 ) {
			if ( comma ) *ptr++ = ',';
			ptr += sprintf(ptr, ""%s"", sprops[i].key.bv_val );
",unused,ssocopsacc_openldap-serveradm-libraries2Flibldap_r2Fcyrus.c
"		dn = dntmp;

		if (loc > 0) {
		    /* not first time. */
		    strcpy(dn + loc, "","");
",1,unused,162,unused,"		dn = dntmp;

		if (loc > 0) {
		    /* not first time. */
		    strcpy(dn + loc, "","");
",unused,ssocopsacc_openldap-serveradm-libraries2Flibldap_r2Fdnssrv.c
"		    /* not first time. */
		    strcpy(dn + loc, "","");
		    loc++;
		}
		strcpy(dn + loc, ""dc="");
",1,unused,165,unused,"		    /* not first time. */
		    strcpy(dn + loc, "","");
		    loc++;
		}
		strcpy(dn + loc, ""dc="");
",unused,ssocopsacc_openldap-serveradm-libraries2Flibldap_r2Fdnssrv.c
"		}
		strcpy(dn + loc, ""dc="");
		loc += sizeof(""dc="")-1;

		strcpy(dn + loc, s);
",1,unused,168,unused,"		}
		strcpy(dn + loc, ""dc="");
		loc += sizeof(""dc="")-1;

		strcpy(dn + loc, s);
",unused,ssocopsacc_openldap-serveradm-libraries2Flibldap_r2Fdnssrv.c
"    request = LDAP_MALLOC(strlen(domain) + sizeof(""_ldap._tcp.""));
    if (request == NULL) {
		return LDAP_NO_MEMORY;
    }
    sprintf(request, ""_ldap._tcp.%s"", domain);
",1,unused,280,unused,"    request = LDAP_MALLOC(strlen(domain) + sizeof(""_ldap._tcp.""));
    if (request == NULL) {
		return LDAP_NO_MEMORY;
    }
    sprintf(request, ""_ldap._tcp.%s"", domain);
",unused,ssocopsacc_openldap-serveradm-libraries2Flibldap_r2Fdnssrv.c
"        }
        if(cur>0){
            hostlist[cur++]=' ';
        }
        cur += sprintf(&hostlist[cur], ""%s:%hu"", hostent_head[i].hostname, hostent_head[i].port);
",1,unused,402,unused,"        }
        if(cur>0){
            hostlist[cur++]=' ';
        }
        cur += sprintf(&hostlist[cur], ""%s:%hu"", hostent_head[i].hostname, hostent_head[i].port);
",unused,ssocopsacc_openldap-serveradm-libraries2Flibldap_r2Fdnssrv.c
"	if(home != NULL && path != NULL) {
		/* we assume UNIX path syntax is used... */

		/* try ~/file */
		sprintf(path, ""%s"" LDAP_DIRSEP ""%s"", home, file);
",1,unused,344,unused,"	if(home != NULL && path != NULL) {
		/* we assume UNIX path syntax is used... */

		/* try ~/file */
		sprintf(path, ""%s"" LDAP_DIRSEP ""%s"", home, file);
",unused,ssocopsacc_openldap-serveradm-libraries2Flibldap_r2Finit.c
"		sprintf(path, ""%s"" LDAP_DIRSEP ""%s"", home, file);
		openldap_ldap_init_w_conf(path, 1);

		/* try ~/.file */
		sprintf(path, ""%s"" LDAP_DIRSEP "".%s"", home, file);
",1,unused,348,unused,"		sprintf(path, ""%s"" LDAP_DIRSEP ""%s"", home, file);
		openldap_ldap_init_w_conf(path, 1);

		/* try ~/.file */
		sprintf(path, ""%s"" LDAP_DIRSEP "".%s"", home, file);
",unused,ssocopsacc_openldap-serveradm-libraries2Flibldap_r2Finit.c
"	buf[MAX_LDAP_ENV_PREFIX_LEN] = '\0';
	len = strlen(buf);

	for(i=0; attrs[i].type != ATTR_NONE; i++) {
		strcpy(&buf[len], attrs[i].name);
",1,unused,379,unused,"	buf[MAX_LDAP_ENV_PREFIX_LEN] = '\0';
	len = strlen(buf);

	for(i=0; attrs[i].type != ATTR_NONE; i++) {
		strcpy(&buf[len], attrs[i].name);
",unused,ssocopsacc_openldap-serveradm-libraries2Flibldap_r2Finit.c
"	/* name (attribute type) */
	if( name != NULL ) {
		/* put the name + "":"" */
		namelen = strlen(name);
		strcpy(*out, name);
",1,unused,549,unused,"	/* name (attribute type) */
	if( name != NULL ) {
		/* put the name + "":"" */
		namelen = strlen(name);
		strcpy(*out, name);
",unused,ssocopsacc_openldap-serveradm-libraries2Flibldap_r2Fldif.c
"				return 0;
			}
			*bufp = nbufp;
		}
		strcpy( *bufp + lcur, line );
",1,unused,939,unused,"				return 0;
			}
			*bufp = nbufp;
		}
		strcpy( *bufp + lcur, line );
",unused,ssocopsacc_openldap-serveradm-libraries2Flibldap_r2Fldif.c
"	oslocal_debug(ld, ""ldap_connect_to_path: Trying %s\n"", path, 0, 0);

	memset( &server, '\0', sizeof(server) );
	server.sun_family = AF_LOCAL;
	strcpy( server.sun_path, path );
",1,unused,349,unused,"	oslocal_debug(ld, ""ldap_connect_to_path: Trying %s\n"", path, 0, 0);

	memset( &server, '\0', sizeof(server) );
	server.sun_family = AF_LOCAL;
	strcpy( server.sun_path, path );
",unused,ssocopsacc_openldap-serveradm-libraries2Flibldap_r2Fos-local.c
"		return( -1 );
	}

	if ( first ) {
		strcpy( *referralsp, LDAP_REF_STR );
",1,unused,1504,unused,"		return( -1 );
	}

	if ( first ) {
		strcpy( *referralsp, LDAP_REF_STR );
",unused,ssocopsacc_openldap-serveradm-libraries2Flibldap_r2Frequest.c
"
	if ( first ) {
		strcpy( *referralsp, LDAP_REF_STR );
	} else {
		strcat( *referralsp, ""\n"" );
",1,unused,1506,unused,"
	if ( first ) {
		strcpy( *referralsp, LDAP_REF_STR );
	} else {
		strcat( *referralsp, ""\n"" );
",unused,ssocopsacc_openldap-serveradm-libraries2Flibldap_r2Frequest.c
"		strcpy( *referralsp, LDAP_REF_STR );
	} else {
		strcat( *referralsp, ""\n"" );
	}
	strcat( *referralsp, s );
",1,unused,1508,unused,"		strcpy( *referralsp, LDAP_REF_STR );
	} else {
		strcat( *referralsp, ""\n"" );
	}
	strcat( *referralsp, s );
",unused,ssocopsacc_openldap-serveradm-libraries2Flibldap_r2Frequest.c
"
	authmethod = LDAP_AUTH_SIMPLE;

		get_line( dn, sizeof(dn), stdin, ""re-bind dn? "" );
		strcat( dn, dnsuffix );
",1,unused,258,unused,"
	authmethod = LDAP_AUTH_SIMPLE;

		get_line( dn, sizeof(dn), stdin, ""re-bind dn? "" );
		strcat( dn, dnsuffix );
",unused,ssocopsacc_openldap-serveradm-libraries2Flibldap_r2Ftest.c
"		case 'a':	/* add or abandon */
			switch ( command2 ) {
			case 'd':	/* add */
				get_line( dn, sizeof(dn), stdin, ""dn? "" );
				strcat( dn, dnsuffix );
",1,unused,381,unused,"		case 'a':	/* add or abandon */
			switch ( command2 ) {
			case 'd':	/* add */
				get_line( dn, sizeof(dn), stdin, ""dn? "" );
				strcat( dn, dnsuffix );
",unused,ssocopsacc_openldap-serveradm-libraries2Flibldap_r2Ftest.c
"
		case 'b':	/* asynch bind */
			method = LDAP_AUTH_SIMPLE;
			get_line( dn, sizeof(dn), stdin, ""dn? "" );
			strcat( dn, dnsuffix );
",1,unused,408,unused,"
		case 'b':	/* asynch bind */
			method = LDAP_AUTH_SIMPLE;
			get_line( dn, sizeof(dn), stdin, ""dn? "" );
			strcat( dn, dnsuffix );
",unused,ssocopsacc_openldap-serveradm-libraries2Flibldap_r2Ftest.c
"
		case 'B':	/* synch bind */
			method = LDAP_AUTH_SIMPLE;
			get_line( dn, sizeof(dn), stdin, ""dn? "" );
			strcat( dn, dnsuffix );
",1,unused,428,unused,"
		case 'B':	/* synch bind */
			method = LDAP_AUTH_SIMPLE;
			get_line( dn, sizeof(dn), stdin, ""dn? "" );
			strcat( dn, dnsuffix );
",unused,ssocopsacc_openldap-serveradm-libraries2Flibldap_r2Ftest.c
"			break;

		case 'c':	/* compare */
			get_line( dn, sizeof(dn), stdin, ""dn? "" );
			strcat( dn, dnsuffix );
",1,unused,448,unused,"			break;

		case 'c':	/* compare */
			get_line( dn, sizeof(dn), stdin, ""dn? "" );
			strcat( dn, dnsuffix );
",unused,ssocopsacc_openldap-serveradm-libraries2Flibldap_r2Ftest.c
"
		case 'm':	/* modify or modifyrdn */
			if ( strncmp( line, ""modify"", 4 ) == 0 ) {
				get_line( dn, sizeof(dn), stdin, ""dn? "" );
				strcat( dn, dnsuffix );
",1,unused,493,unused,"
		case 'm':	/* modify or modifyrdn */
			if ( strncmp( line, ""modify"", 4 ) == 0 ) {
				get_line( dn, sizeof(dn), stdin, ""dn? "" );
				strcat( dn, dnsuffix );
",unused,ssocopsacc_openldap-serveradm-libraries2Flibldap_r2Ftest.c
"					printf( ""Modify initiated with id %d\n"",
					    id );
			} else if ( strncmp( line, ""modrdn"", 4 ) == 0 ) {
				get_line( dn, sizeof(dn), stdin, ""dn? "" );
				strcat( dn, dnsuffix );
",1,unused,506,unused,"					printf( ""Modify initiated with id %d\n"",
					    id );
			} else if ( strncmp( line, ""modrdn"", 4 ) == 0 ) {
				get_line( dn, sizeof(dn), stdin, ""dn? "" );
				strcat( dn, dnsuffix );
",unused,ssocopsacc_openldap-serveradm-libraries2Flibldap_r2Ftest.c
"				break;

			case 'm':	/* remove */
				get_line( dn, sizeof(dn), stdin, ""dn? "" );
				strcat( dn, dnsuffix );
",1,unused,551,unused,"				break;

			case 'm':	/* remove */
				get_line( dn, sizeof(dn), stdin, ""dn? "" );
				strcat( dn, dnsuffix );
",unused,ssocopsacc_openldap-serveradm-libraries2Flibldap_r2Ftest.c
"			break;

		case 's':	/* search */
			get_line( dn, sizeof(dn), stdin, ""searchbase? "" );
			strcat( dn, dnsuffix );
",1,unused,567,unused,"			break;

		case 's':	/* search */
			get_line( dn, sizeof(dn), stdin, ""searchbase? "" );
			strcat( dn, dnsuffix );
",unused,ssocopsacc_openldap-serveradm-libraries2Flibldap_r2Ftest.c
"			    break;

		case 'n':	/* set dn suffix, for convenience */
			get_line( line, sizeof(line), stdin, ""DN suffix? "" );
			strcpy( dnsuffix, line );
",1,unused,633,unused,"			    break;

		case 'n':	/* set dn suffix, for convenience */
			get_line( line, sizeof(line), stdin, ""DN suffix? "" );
			strcpy( dnsuffix, line );
",unused,ssocopsacc_openldap-serveradm-libraries2Flibldap_r2Ftest.c
"			is_v6 = 1;
	}

	if ( u->lud_port ) {
		sofar = sprintf( s, ""%s://%s%s%s:%d"", u->lud_scheme,
",1,unused,649,unused,"			is_v6 = 1;
	}

	if ( u->lud_port ) {
		sofar = sprintf( s, ""%s://%s%s%s:%d"", u->lud_scheme,
",unused,ssocopsacc_openldap-serveradm-libraries2Flibldap_r2Furl.c
"				u->lud_port );
		len -= sofar;

	} else {
		sofar = sprintf( s, ""%s://"", u->lud_scheme );
",1,unused,657,unused,"				u->lud_port );
		len -= sofar;

	} else {
		sofar = sprintf( s, ""%s://"", u->lud_scheme );
",unused,ssocopsacc_openldap-serveradm-libraries2Flibldap_r2Furl.c
"
	assert( len >= 0 );

	if ( !BER_BVISNULL( &scope ) ) {
		strcpy( &s[sofar], scope.bv_val );
",1,unused,716,unused,"
	assert( len >= 0 );

	if ( !BER_BVISNULL( &scope ) ) {
		strcpy( &s[sofar], scope.bv_val );
",unused,ssocopsacc_openldap-serveradm-libraries2Flibldap_r2Furl.c
"		size += strlen(ludp->lud_host) + 1;		/* host and space */
		if (strchr(ludp->lud_host, ':'))        /* will add [ ] below */
			size += 2;
		if (ludp->lud_port != 0)
			size += sprintf(buf, "":%d"", ludp->lud_port);
",1,unused,1433,unused,"		size += strlen(ludp->lud_host) + 1;		/* host and space */
		if (strchr(ludp->lud_host, ':'))        /* will add [ ] below */
			size += 2;
		if (ludp->lud_port != 0)
			size += sprintf(buf, "":%d"", ludp->lud_port);
",unused,ssocopsacc_openldap-serveradm-libraries2Flibldap_r2Furl.c
"	p = s;
	for (ludp = ludlist; ludp != NULL; ludp = ludp->lud_next) {
		if ( ludp->lud_host == NULL ) continue;
		if (strchr(ludp->lud_host, ':')) {
			p += sprintf(p, ""[%s]"", ludp->lud_host);
",1,unused,1443,unused,"	p = s;
	for (ludp = ludlist; ludp != NULL; ludp = ludp->lud_next) {
		if ( ludp->lud_host == NULL ) continue;
		if (strchr(ludp->lud_host, ':')) {
			p += sprintf(p, ""[%s]"", ludp->lud_host);
",unused,ssocopsacc_openldap-serveradm-libraries2Flibldap_r2Furl.c
"		if ( ludp->lud_host == NULL ) continue;
		if (strchr(ludp->lud_host, ':')) {
			p += sprintf(p, ""[%s]"", ludp->lud_host);
		} else {
			strcpy(p, ludp->lud_host);
",1,unused,1445,unused,"		if ( ludp->lud_host == NULL ) continue;
		if (strchr(ludp->lud_host, ':')) {
			p += sprintf(p, ""[%s]"", ludp->lud_host);
		} else {
			strcpy(p, ludp->lud_host);
",unused,ssocopsacc_openldap-serveradm-libraries2Flibldap_r2Furl.c
"			strcpy(p, ludp->lud_host);
			p += strlen(ludp->lud_host);
		}
		if (ludp->lud_port != 0)
			p += sprintf(p, "":%d"", ludp->lud_port);
",1,unused,1449,unused,"			strcpy(p, ludp->lud_host);
			p += strlen(ludp->lud_host);
		}
		if (ludp->lud_port != 0)
			p += sprintf(p, "":%d"", ludp->lud_port);
",unused,ssocopsacc_openldap-serveradm-libraries2Flibldap_r2Furl.c
"		*dest = '\0';
		return 1;
	}
	if ( duration == 0 ) {
		strcpy( dest, ""none"" );
",1,unused,54,unused,"		*dest = '\0';
		return 1;
	}
	if ( duration == 0 ) {
		strcpy( dest, ""none"" );
",unused,ssocopsacc_openldap-serveradm-libraries2Fliblutil2Fmeter.c
"	if ( i > endargv - s - 2 ) {
		i = endargv - s - 2;
		buf[ i ] = '\0';
	}
	strcpy( s, buf );
",1,unused,74,unused,"	if ( i > endargv - s - 2 ) {
		i = endargv - s - 2;
		buf[ i ] = '\0';
	}
	strcpy( s, buf );
",unused,ssocopsacc_openldap-serveradm-libraries2Fliblutil2Fsetproctitle.c
"		} else {
			char *cp, *op, *lp;
			int j;
			d2->ad_cname.bv_val = (char *)(d2+1);
			strcpy(d2->ad_cname.bv_val, d2->ad_type->sat_cname.bv_val);
",1,unused,399,unused,"		} else {
			char *cp, *op, *lp;
			int j;
			d2->ad_cname.bv_val = (char *)(d2+1);
			strcpy(d2->ad_cname.bv_val, d2->ad_type->sat_cname.bv_val);
",unused,ssocopsacc_openldap-serveradm-servers2Fslapd2Fad.c
"				lp = d2->ad_cname.bv_val + d2->ad_cname.bv_len + j;
				if ( j == 0 )
					*lp++ = ';';
				d2->ad_tags.bv_val = lp;
				strcpy(lp, desc.ad_tags.bv_val);
",1,unused,434,unused,"				lp = d2->ad_cname.bv_val + d2->ad_cname.bv_len + j;
				if ( j == 0 )
					*lp++ = ';';
				d2->ad_tags.bv_val = lp;
				strcpy(lp, desc.ad_tags.bv_val);
",unused,ssocopsacc_openldap-serveradm-servers2Fslapd2Fad.c
"	/*
	 * overwrites input string
	 * on error!
	 */
	strcpy( in, s );
",1,unused,1004,unused,"	/*
	 * overwrites input string
	 * on error!
	 */
	strcpy( in, s );
",unused,ssocopsacc_openldap-serveradm-servers2Fslapd2Fad.c
"		if ( ldap_attributetype2bv( latp, &bv ) == NULL ) {
			ber_bvarray_free( bva );
		}
		if ( !sys ) {
			idx.bv_len = sprintf(idx.bv_val, ""{%d}"", i);
",1,unused,1027,unused,"		if ( ldap_attributetype2bv( latp, &bv ) == NULL ) {
			ber_bvarray_free( bva );
		}
		if ( !sys ) {
			idx.bv_len = sprintf(idx.bv_val, ""{%d}"", i);
",unused,ssocopsacc_openldap-serveradm-servers2Fslapd2Fat.c
"			idx.bv_len = sprintf(idx.bv_val, ""{%d}"", i);
		}
		bva[i].bv_len = idx.bv_len + bv.bv_len;
		bva[i].bv_val = ch_malloc( bva[i].bv_len + 1 );
		strcpy( bva[i].bv_val, ibuf );
",1,unused,1031,unused,"			idx.bv_len = sprintf(idx.bv_val, ""{%d}"", i);
		}
		bva[i].bv_len = idx.bv_len + bv.bv_len;
		bva[i].bv_val = ch_malloc( bva[i].bv_len + 1 );
		strcpy( bva[i].bv_val, ibuf );
",unused,ssocopsacc_openldap-serveradm-servers2Fslapd2Fat.c
"		}
		bva[i].bv_len = idx.bv_len + bv.bv_len;
		bva[i].bv_val = ch_malloc( bva[i].bv_len + 1 );
		strcpy( bva[i].bv_val, ibuf );
		strcpy( bva[i].bv_val + idx.bv_len, bv.bv_val );
",1,unused,1032,unused,"		}
		bva[i].bv_len = idx.bv_len + bv.bv_len;
		bva[i].bv_val = ch_malloc( bva[i].bv_len + 1 );
		strcpy( bva[i].bv_val, ibuf );
		strcpy( bva[i].bv_val + idx.bv_len, bv.bv_val );
",unused,ssocopsacc_openldap-serveradm-servers2Fslapd2Fat.c
"				struct berval bv;

				bv.bv_val = c->log;
				for (i=0; !BER_BVISNULL(&bdb->bi_db_config[i]); i++) {
					bv.bv_len = sprintf( bv.bv_val, ""{%d}%s"", i,
",1,unused,470,unused,"				struct berval bv;

				bv.bv_val = c->log;
				for (i=0; !BER_BVISNULL(&bdb->bi_db_config[i]); i++) {
					bv.bv_len = sprintf( bv.bv_val, ""{%d}%s"", i,
",unused,ssocopsacc_openldap-serveradm-servers2Fslapd2Fback-hdb2Fconfig.c
"				int rc = 1;

				bv.bv_val = buf;
				for ( ps = bdb->bi_pagesizes; ps; ps = ps->bdp_next ) {
					bv.bv_len = sprintf( buf, ""%s %d"", ps->bdp_name.bv_val,
",1,unused,519,unused,"				int rc = 1;

				bv.bv_val = buf;
				for ( ps = bdb->bi_pagesizes; ps; ps = ps->bdp_next ) {
					bv.bv_len = sprintf( buf, ""%s %d"", ps->bdp_name.bv_val,
",unused,ssocopsacc_openldap-serveradm-servers2Fslapd2Fback-hdb2Fconfig.c
"		len = strlen( c->value_string );
		testpath = ch_malloc( len + STRLENOF(LDAP_DIRSEP) + STRLENOF(""DUMMY"") + 1 );
		ptr = lutil_strcopy( testpath, c->value_string );
		*ptr++ = LDAP_DIRSEP[0];
		strcpy( ptr, ""DUMMY"" );
",1,unused,817,unused,"		len = strlen( c->value_string );
		testpath = ch_malloc( len + STRLENOF(LDAP_DIRSEP) + STRLENOF(""DUMMY"") + 1 );
		ptr = lutil_strcopy( testpath, c->value_string );
		*ptr++ = LDAP_DIRSEP[0];
		strcpy( ptr, ""DUMMY"" );
",unused,ssocopsacc_openldap-serveradm-servers2Fslapd2Fback-hdb2Fconfig.c
"		bdb->bi_db_config_path = ch_malloc( len +
			STRLENOF(LDAP_DIRSEP) + STRLENOF(""DB_CONFIG"") + 1 );
		ptr = lutil_strcopy( bdb->bi_db_config_path, bdb->bi_dbenv_home );
		*ptr++ = LDAP_DIRSEP[0];
		strcpy( ptr, ""DB_CONFIG"" );
",1,unused,842,unused,"		bdb->bi_db_config_path = ch_malloc( len +
			STRLENOF(LDAP_DIRSEP) + STRLENOF(""DB_CONFIG"") + 1 );
		ptr = lutil_strcopy( bdb->bi_db_config_path, bdb->bi_dbenv_home );
		*ptr++ = LDAP_DIRSEP[0];
		strcpy( ptr, ""DB_CONFIG"" );
",unused,ssocopsacc_openldap-serveradm-servers2Fslapd2Fback-hdb2Fconfig.c
"		ps = ch_malloc( sizeof(struct bdb_db_pgsize) + i + 1 );
		ps->bdp_next = NULL;
		ps->bdp_name.bv_len = i;
		ps->bdp_name.bv_val = (char *)(ps+1);
		strcpy( ps->bdp_name.bv_val, c->argv[1] );
",1,unused,931,unused,"		ps = ch_malloc( sizeof(struct bdb_db_pgsize) + i + 1 );
		ps->bdp_next = NULL;
		ps->bdp_name.bv_len = i;
		ps->bdp_name.bv_val = (char *)(ps+1);
		strcpy( ps->bdp_name.bv_val, c->argv[1] );
",unused,ssocopsacc_openldap-serveradm-servers2Fslapd2Fback-hdb2Fconfig.c
"#endif
	rc = db->bdi_db->set_flags( db->bdi_db, DB_DUP | DB_DUPSORT );

	file = ch_malloc( db->bdi_name.bv_len + sizeof(BDB_SUFFIX) );
	strcpy( file, db->bdi_name.bv_val );
",1,unused,171,unused,"#endif
	rc = db->bdi_db->set_flags( db->bdi_db, DB_DUP | DB_DUPSORT );

	file = ch_malloc( db->bdi_name.bv_len + sizeof(BDB_SUFFIX) );
	strcpy( file, db->bdi_name.bv_val );
",unused,ssocopsacc_openldap-serveradm-servers2Fslapd2Fback-hdb2Fdbcache.c
"	rc = db->bdi_db->set_flags( db->bdi_db, DB_DUP | DB_DUPSORT );

	file = ch_malloc( db->bdi_name.bv_len + sizeof(BDB_SUFFIX) );
	strcpy( file, db->bdi_name.bv_val );
	strcpy( file+db->bdi_name.bv_len, BDB_SUFFIX );
",1,unused,172,unused,"	rc = db->bdi_db->set_flags( db->bdi_db, DB_DUP | DB_DUPSORT );

	file = ch_malloc( db->bdi_name.bv_len + sizeof(BDB_SUFFIX) );
	strcpy( file, db->bdi_name.bv_val );
	strcpy( file+db->bdi_name.bv_len, BDB_SUFFIX );
",unused,ssocopsacc_openldap-serveradm-servers2Fslapd2Fback-hdb2Fdbcache.c
"	char		*buf )
{
	if ( key->size == 4 /* LUTIL_HASH_BYTES */ ) {
		unsigned char *c = key->data;
		sprintf( buf, ""[%02x%02x%02x%02x]"", c[0], c[1], c[2], c[3] );
",1,unused,284,unused,"	char		*buf )
{
	if ( key->size == 4 /* LUTIL_HASH_BYTES */ ) {
		unsigned char *c = key->data;
		sprintf( buf, ""[%02x%02x%02x%02x]"", c[0], c[1], c[2], c[3] );
",unused,ssocopsacc_openldap-serveradm-servers2Fslapd2Fback-hdb2Fidl.c
"	if( stat( bdb->bi_db_config_path, &stat1 ) == 0 ) {
		if ( !do_recover ) {
			char *ptr = lutil_strcopy(path, bdb->bi_dbenv_home);
			*ptr++ = LDAP_DIRSEP[0];
			strcpy( ptr, ""__db.001"" );
",1,unused,184,unused,"	if( stat( bdb->bi_db_config_path, &stat1 ) == 0 ) {
		if ( !do_recover ) {
			char *ptr = lutil_strcopy(path, bdb->bi_dbenv_home);
			*ptr++ = LDAP_DIRSEP[0];
			strcpy( ptr, ""__db.001"" );
",unused,ssocopsacc_openldap-serveradm-servers2Fslapd2Fback-hdb2Finit.c
"			return LDAP_OTHER;
		AC_MEMCPY( res->bv_val, dnpath->bv_val, i );
	}
	res->bv_len = i;
	strcpy( res->bv_val + i, LDIF );
",1,unused,310,unused,"			return LDAP_OTHER;
		AC_MEMCPY( res->bv_val, dnpath->bv_val, i );
	}
	res->bv_len = i;
	strcpy( res->bv_val + i, LDIF );
",unused,ssocopsacc_openldap-serveradm-servers2Fslapd2Fback-ldif2Fldif.c
"	char *name = SLAP_MALLOC( len + sizeof( suffix ) );

	if ( name != NULL ) {
		AC_MEMCPY( name, dnpath->bv_val, len );
		strcpy( name + len, suffix );
",1,unused,325,unused,"	char *name = SLAP_MALLOC( len + sizeof( suffix ) );

	if ( name != NULL ) {
		AC_MEMCPY( name, dnpath->bv_val, len );
		strcpy( name + len, suffix );
",unused,ssocopsacc_openldap-serveradm-servers2Fslapd2Fback-ldif2Fldif.c
"	int writeres;
#define HEADER	""# AUTO-GENERATED FILE - DO NOT EDIT!! Use ldapmodify.\n""
	char header[sizeof(HEADER ""# CRC32 12345678\n"")];

	sprintf(header, HEADER ""# CRC32 %08x\n"", crc32(spew, len));
",1,unused,511,unused,"	int writeres;
#define HEADER	""# AUTO-GENERATED FILE - DO NOT EDIT!! Use ldapmodify.\n""
	char header[sizeof(HEADER ""# CRC32 12345678\n"")];

	sprintf(header, HEADER ""# CRC32 %08x\n"", crc32(spew, len));
",unused,ssocopsacc_openldap-serveradm-servers2Fslapd2Fback-ldif2Fldif.c
"				rc = LDAP_OTHER;
				save_errno = errno;
				break;
			}
			strcpy( BVL_NAME( bvl ), dir->d_name );
",1,unused,857,unused,"				rc = LDAP_OTHER;
				save_errno = errno;
				break;
			}
			strcpy( BVL_NAME( bvl ), dir->d_name );
",unused,ssocopsacc_openldap-serveradm-servers2Fslapd2Fback-ldif2Fldif.c
"		len = strlen( c->value_string );
		testpath = ch_malloc( len + STRLENOF(LDAP_DIRSEP) + STRLENOF(""DUMMY"") + 1 );
		ptr = lutil_strcopy( testpath, c->value_string );
		*ptr++ = LDAP_DIRSEP[0];
		strcpy( ptr, ""DUMMY"" );
",1,unused,570,unused,"		len = strlen( c->value_string );
		testpath = ch_malloc( len + STRLENOF(LDAP_DIRSEP) + STRLENOF(""DUMMY"") + 1 );
		ptr = lutil_strcopy( testpath, c->value_string );
		*ptr++ = LDAP_DIRSEP[0];
		strcpy( ptr, ""DUMMY"" );
",unused,ssocopsacc_openldap-serveradm-servers2Fslapd2Fback-mdb2Fconfig.c
"done:
	if ( matched ) {
		if ( matched->bv_len ) {
			ptr = op->o_tmpalloc( matched->bv_len+1, op->o_tmpmemctx );
			strcpy( ptr, matched->bv_val );
",1,unused,411,unused,"done:
	if ( matched ) {
		if ( matched->bv_len ) {
			ptr = op->o_tmpalloc( matched->bv_len+1, op->o_tmpmemctx );
			strcpy( ptr, matched->bv_val );
",unused,ssocopsacc_openldap-serveradm-servers2Fslapd2Fback-mdb2Fdn2id.c
"	size_t		len )
{
	if ( len == 4 /* LUTIL_HASH_BYTES */ ) {
		unsigned char *c = val;
		sprintf( buf, ""[%02x%02x%02x%02x]"", c[0], c[1], c[2], c[3] );
",1,unused,254,unused,"	size_t		len )
{
	if ( len == 4 /* LUTIL_HASH_BYTES */ ) {
		unsigned char *c = val;
		sprintf( buf, ""[%02x%02x%02x%02x]"", c[0], c[1], c[2], c[3] );
",unused,ssocopsacc_openldap-serveradm-servers2Fslapd2Fback-mdb2Fidl.c
"		int		rc;

		dn.bv_len = len + sizeof( ""cn="" ) - 1;
		dn.bv_val = ch_calloc( sizeof( char ), dn.bv_len + 1 );
		strcpy( dn.bv_val, ""cn="" );
",1,unused,2358,unused,"		int		rc;

		dn.bv_len = len + sizeof( ""cn="" ) - 1;
		dn.bv_val = ch_calloc( sizeof( char ), dn.bv_len + 1 );
		strcpy( dn.bv_val, ""cn="" );
",unused,ssocopsacc_openldap-serveradm-servers2Fslapd2Fback-monitor2Finit.c
"
		dn.bv_len = len + sizeof( ""cn="" ) - 1;
		dn.bv_val = ch_calloc( sizeof( char ), dn.bv_len + 1 );
		strcpy( dn.bv_val, ""cn="" );
		strcat( dn.bv_val, monitor_subsys[ i ]->mss_name );
",1,unused,2359,unused,"
		dn.bv_len = len + sizeof( ""cn="" ) - 1;
		dn.bv_val = ch_calloc( sizeof( char ), dn.bv_len + 1 );
		strcpy( dn.bv_val, ""cn="" );
		strcat( dn.bv_val, monitor_subsys[ i ]->mss_name );
",unused,ssocopsacc_openldap-serveradm-servers2Fslapd2Fback-monitor2Finit.c
"		g->ga_oc = group_oc;
		g->ga_at = group_at;
		g->ga_res = rc;
		g->ga_len = gr_ndn->bv_len;
		strcpy( g->ga_ndn, gr_ndn->bv_val );
",1,unused,1584,unused,"		g->ga_oc = group_oc;
		g->ga_at = group_at;
		g->ga_res = rc;
		g->ga_len = gr_ndn->bv_len;
		strcpy( g->ga_ndn, gr_ndn->bv_val );
",unused,ssocopsacc_openldap-serveradm-servers2Fslapd2Fbackend.c
"					assert( si->si_num >= 0 && si->si_num <= SLAP_SYNC_SID_MAX );
					if ( !BER_BVISEMPTY( &si->si_url )) {
						bv.bv_len = si->si_url.bv_len + 6;
						bv.bv_val = ch_malloc( bv.bv_len );
						bv.bv_len = sprintf( bv.bv_val, ""%d %s"", si->si_num,
",1,unused,1099,unused,"					assert( si->si_num >= 0 && si->si_num <= SLAP_SYNC_SID_MAX );
					if ( !BER_BVISEMPTY( &si->si_url )) {
						bv.bv_len = si->si_url.bv_len + 6;
						bv.bv_val = ch_malloc( bv.bv_len );
						bv.bv_len = sprintf( bv.bv_val, ""%d %s"", si->si_num,
",unused,ssocopsacc_openldap-serveradm-servers2Fslapd2Fbconfig.c
"						ber_bvarray_add( &c->rvalue_vals, &bv );
					} else {
						char buf[5];
						bv.bv_val = buf;
						bv.bv_len = sprintf( buf, ""%d"", si->si_num );
",1,unused,1105,unused,"						ber_bvarray_add( &c->rvalue_vals, &bv );
					} else {
						char buf[5];
						bv.bv_val = buf;
						bv.bv_len = sprintf( buf, ""%d"", si->si_num );
",unused,ssocopsacc_openldap-serveradm-servers2Fslapd2Fbconfig.c
"					len = strlen( c->argv[2] );
					si = ch_malloc( sizeof(ServerID) + len + 1 );
					si->si_url.bv_val = (char *)(si+1);
					si->si_url.bv_len = len;
					strcpy( si->si_url.bv_val, c->argv[2] );
",1,unused,1894,unused,"					len = strlen( c->argv[2] );
					si = ch_malloc( sizeof(ServerID) + len + 1 );
					si->si_url.bv_val = (char *)(si+1);
					si->si_url.bv_len = len;
					strcpy( si->si_url.bv_val, c->argv[2] );
",unused,ssocopsacc_openldap-serveradm-servers2Fslapd2Fbconfig.c
"				}
				bv.bv_len += sec_keys[i].key.bv_len;
				bv.bv_val = ch_malloc( bv.bv_len + 1);
				next = lutil_strcopy( bv.bv_val, sec_keys[i].key.bv_val );
				strcpy( next, numbuf );
",1,unused,3583,unused,"				}
				bv.bv_len += sec_keys[i].key.bv_len;
				bv.bv_val = ch_malloc( bv.bv_len + 1);
				next = lutil_strcopy( bv.bv_val, sec_keys[i].key.bv_val );
				strcpy( next, numbuf );
",unused,ssocopsacc_openldap-serveradm-servers2Fslapd2Fbconfig.c
"	free( a->a_vals[0].bv_val );
	ptr1 = strchr( newrdn->bv_val, '=' ) + 1;
	a->a_vals[0].bv_len = newrdn->bv_len - (ptr1 - newrdn->bv_val);
	a->a_vals[0].bv_val = ch_malloc( a->a_vals[0].bv_len + 1 );
	strcpy( a->a_vals[0].bv_val, ptr1 );
",1,unused,4489,unused,"	free( a->a_vals[0].bv_val );
	ptr1 = strchr( newrdn->bv_val, '=' ) + 1;
	a->a_vals[0].bv_len = newrdn->bv_len - (ptr1 - newrdn->bv_val);
	a->a_vals[0].bv_val = ch_malloc( a->a_vals[0].bv_len + 1 );
	strcpy( a->a_vals[0].bv_val, ptr1 );
",unused,ssocopsacc_openldap-serveradm-servers2Fslapd2Fbconfig.c
"		free( a->a_nvals[0].bv_val );
		ptr1 = strchr( nnewrdn->bv_val, '=' ) + 1;
		a->a_nvals[0].bv_len = nnewrdn->bv_len - (ptr1 - nnewrdn->bv_val);
		a->a_nvals[0].bv_val = ch_malloc( a->a_nvals[0].bv_len + 1 );
		strcpy( a->a_nvals[0].bv_val, ptr1 );
",1,unused,4496,unused,"		free( a->a_nvals[0].bv_val );
		ptr1 = strchr( nnewrdn->bv_val, '=' ) + 1;
		a->a_nvals[0].bv_len = nnewrdn->bv_len - (ptr1 - nnewrdn->bv_val);
		a->a_nvals[0].bv_val = ch_malloc( a->a_nvals[0].bv_len + 1 );
		strcpy( a->a_nvals[0].bv_val, ptr1 );
",unused,ssocopsacc_openldap-serveradm-servers2Fslapd2Fbconfig.c
"	ca->ca_private = ce->ce_private;
	ca->ca_entry = e;
	ca->fname = ""slapd"";
	ca->ca_op = op;
	strcpy( ca->log, ""back-config"" );
",1,unused,5549,unused,"	ca->ca_private = ce->ce_private;
	ca->ca_entry = e;
	ca->fname = ""slapd"";
	ca->ca_op = op;
	strcpy( ca->log, ""back-config"" );
",unused,ssocopsacc_openldap-serveradm-servers2Fslapd2Fbconfig.c
"		if ( ldap_contentrule2bv( lcrp, &bv ) == NULL ) {
			ber_bvarray_free( bva );
		}
		if ( !sys ) {
			idx.bv_len = sprintf(idx.bv_val, ""{%d}"", i);
",1,unused,454,unused,"		if ( ldap_contentrule2bv( lcrp, &bv ) == NULL ) {
			ber_bvarray_free( bva );
		}
		if ( !sys ) {
			idx.bv_len = sprintf(idx.bv_val, ""{%d}"", i);
",unused,ssocopsacc_openldap-serveradm-servers2Fslapd2Fcr.c
"			idx.bv_len = sprintf(idx.bv_val, ""{%d}"", i);
		}
		bva[i].bv_len = idx.bv_len + bv.bv_len;
		bva[i].bv_val = ch_malloc( bva[i].bv_len + 1 );
		strcpy( bva[i].bv_val, ibuf );
",1,unused,458,unused,"			idx.bv_len = sprintf(idx.bv_val, ""{%d}"", i);
		}
		bva[i].bv_len = idx.bv_len + bv.bv_len;
		bva[i].bv_val = ch_malloc( bva[i].bv_len + 1 );
		strcpy( bva[i].bv_val, ibuf );
",unused,ssocopsacc_openldap-serveradm-servers2Fslapd2Fcr.c
"		}
		bva[i].bv_len = idx.bv_len + bv.bv_len;
		bva[i].bv_val = ch_malloc( bva[i].bv_len + 1 );
		strcpy( bva[i].bv_val, ibuf );
		strcpy( bva[i].bv_val + idx.bv_len, bv.bv_val );
",1,unused,459,unused,"		}
		bva[i].bv_len = idx.bv_len + bv.bv_len;
		bva[i].bv_val = ch_malloc( bva[i].bv_len + 1 );
		strcpy( bva[i].bv_val, ibuf );
		strcpy( bva[i].bv_val + idx.bv_len, bv.bv_val );
",unused,ssocopsacc_openldap-serveradm-servers2Fslapd2Fcr.c
"		}

		(void)memset( (void *)*sap, '\0', sizeof(struct sockaddr_un) );
		(*sap)->sa_family = AF_LOCAL;
		strcpy( ((struct sockaddr_un *)*sap)->sun_path, host );
",1,unused,1164,unused,"		}

		(void)memset( (void *)*sap, '\0', sizeof(struct sockaddr_un) );
		(*sap)->sa_family = AF_LOCAL;
		strcpy( ((struct sockaddr_un *)*sap)->sun_path, host );
",unused,ssocopsacc_openldap-serveradm-servers2Fslapd2Fdaemon.c
"					sl->sl_sa.sa_un_addr.sun_path,
					sizeof( from.sa_un_addr.sun_path ) );
		}

		sprintf( peername, ""PATH=%s"", from.sa_un_addr.sun_path );
",1,unused,1953,unused,"					sl->sl_sa.sa_un_addr.sun_path,
					sizeof( from.sa_un_addr.sun_path ) );
		}

		sprintf( peername, ""PATH=%s"", from.sa_un_addr.sun_path );
",unused,ssocopsacc_openldap-serveradm-servers2Fslapd2Fdaemon.c
"			if( LUTIL_GETPEEREID( s, &uid, &gid, &peerbv ) == 0 ) {
				authid.bv_val = ch_malloc(
					STRLENOF( ""gidNumber=4294967295+uidNumber=4294967295,""
					""cn=peercred,cn=external,cn=auth"" ) + 1 );
				authid.bv_len = sprintf( authid.bv_val,
",1,unused,1967,unused,"			if( LUTIL_GETPEEREID( s, &uid, &gid, &peerbv ) == 0 ) {
				authid.bv_val = ch_malloc(
					STRLENOF( ""gidNumber=4294967295+uidNumber=4294967295,""
					""cn=peercred,cn=external,cn=auth"" ) + 1 );
				authid.bv_len = sprintf( authid.bv_val,
",unused,ssocopsacc_openldap-serveradm-servers2Fslapd2Fdaemon.c
"		peeraddr = inet_ntoa( *((struct in_addr *)
					&from.sa_in6_addr.sin6_addr.s6_addr[12]) );
#endif /* ! HAVE_GETADDRINFO || ! HAVE_INET_NTOP */
		if ( !peeraddr ) peeraddr = SLAP_STRING_UNKNOWN;
		sprintf( peername, ""IP=%s:%d"", peeraddr,
",1,unused,1992,unused,"		peeraddr = inet_ntoa( *((struct in_addr *)
					&from.sa_in6_addr.sin6_addr.s6_addr[12]) );
#endif /* ! HAVE_GETADDRINFO || ! HAVE_INET_NTOP */
		if ( !peeraddr ) peeraddr = SLAP_STRING_UNKNOWN;
		sprintf( peername, ""IP=%s:%d"", peeraddr,
",unused,ssocopsacc_openldap-serveradm-servers2Fslapd2Fdaemon.c
"		peeraddr = inet_ntop( AF_INET6,
				      &from.sa_in6_addr.sin6_addr,
				      addr, sizeof addr );
		if ( !peeraddr ) peeraddr = SLAP_STRING_UNKNOWN;
		sprintf( peername, ""IP=[%s]:%d"", peeraddr,
",1,unused,1999,unused,"		peeraddr = inet_ntop( AF_INET6,
				      &from.sa_in6_addr.sin6_addr,
				      addr, sizeof addr );
		if ( !peeraddr ) peeraddr = SLAP_STRING_UNKNOWN;
		sprintf( peername, ""IP=[%s]:%d"", peeraddr,
",unused,ssocopsacc_openldap-serveradm-servers2Fslapd2Fdaemon.c
"#else /* ! HAVE_GETADDRINFO || ! HAVE_INET_NTOP */
		peeraddr = inet_ntoa( from.sa_in_addr.sin_addr );
#endif /* ! HAVE_GETADDRINFO || ! HAVE_INET_NTOP */
		if ( !peeraddr ) peeraddr = SLAP_STRING_UNKNOWN;
		sprintf( peername, ""IP=%s:%d"", peeraddr,
",1,unused,2013,unused,"#else /* ! HAVE_GETADDRINFO || ! HAVE_INET_NTOP */
		peeraddr = inet_ntoa( from.sa_in_addr.sin_addr );
#endif /* ! HAVE_GETADDRINFO || ! HAVE_INET_NTOP */
		if ( !peeraddr ) peeraddr = SLAP_STRING_UNKNOWN;
		sprintf( peername, ""IP=%s:%d"", peeraddr,
",unused,ssocopsacc_openldap-serveradm-servers2Fslapd2Fdaemon.c
"	new_dn->bv_val = (char *) slap_sl_malloc( new_dn->bv_len + 1, memctx );

	ptr = lutil_strncopy( new_dn->bv_val, newrdn->bv_val, newrdn->bv_len );
	*ptr++ = ',';
	strcpy( ptr, parent_dn->bv_val );
",1,unused,1158,unused,"	new_dn->bv_val = (char *) slap_sl_malloc( new_dn->bv_len + 1, memctx );

	ptr = lutil_strncopy( new_dn->bv_val, newrdn->bv_val, newrdn->bv_len );
	*ptr++ = ',';
	strcpy( ptr, parent_dn->bv_val );
",unused,ssocopsacc_openldap-serveradm-servers2Fslapd2Fdn.c
"		} else {
			len = snprintf( cookiestr, sizeof( cookiestr ),
					""rid=%03d"", rid );
			if ( sid >= 0 ) {
				len += sprintf( cookiestr+len, "",sid=%03x"", sid );
",1,unused,56,unused,"		} else {
			len = snprintf( cookiestr, sizeof( cookiestr ),
					""rid=%03d"", rid );
			if ( sid >= 0 ) {
				len += sprintf( cookiestr+len, "",sid=%03x"", sid );
",unused,ssocopsacc_openldap-serveradm-servers2Fslapd2Fldapsync.c
"			len += STRLENOF(""sid=xxx,"");

		cookie->bv_val = slap_sl_malloc( len, op ? op->o_tmpmemctx : NULL );

		len = sprintf( cookie->bv_val, ""rid=%03d,"", rid );
",1,unused,75,unused,"			len += STRLENOF(""sid=xxx,"");

		cookie->bv_val = slap_sl_malloc( len, op ? op->o_tmpmemctx : NULL );

		len = sprintf( cookie->bv_val, ""rid=%03d,"", rid );
",unused,ssocopsacc_openldap-serveradm-servers2Fslapd2Fldapsync.c
"
		len = sprintf( cookie->bv_val, ""rid=%03d,"", rid );
		ptr = cookie->bv_val + len;
		if ( sid >= 0 ) {
			ptr += sprintf( ptr, ""sid=%03x,"", sid );
",1,unused,78,unused,"
		len = sprintf( cookie->bv_val, ""rid=%03d,"", rid );
		ptr = cookie->bv_val + len;
		if ( sid >= 0 ) {
			ptr += sprintf( ptr, ""sid=%03x,"", sid );
",unused,ssocopsacc_openldap-serveradm-servers2Fslapd2Fldapsync.c
"		if ( ldap_objectclass2bv( locp, &bv ) == NULL ) {
			ber_bvarray_free( bva );
		}
		if ( !sys ) {
			idx.bv_len = sprintf(idx.bv_val, ""{%d}"", i);
",1,unused,866,unused,"		if ( ldap_objectclass2bv( locp, &bv ) == NULL ) {
			ber_bvarray_free( bva );
		}
		if ( !sys ) {
			idx.bv_len = sprintf(idx.bv_val, ""{%d}"", i);
",unused,ssocopsacc_openldap-serveradm-servers2Fslapd2Foc.c
"			idx.bv_len = sprintf(idx.bv_val, ""{%d}"", i);
		}
		bva[i].bv_len = idx.bv_len + bv.bv_len;
		bva[i].bv_val = ch_malloc( bva[i].bv_len + 1 );
		strcpy( bva[i].bv_val, ibuf );
",1,unused,870,unused,"			idx.bv_len = sprintf(idx.bv_val, ""{%d}"", i);
		}
		bva[i].bv_len = idx.bv_len + bv.bv_len;
		bva[i].bv_val = ch_malloc( bva[i].bv_len + 1 );
		strcpy( bva[i].bv_val, ibuf );
",unused,ssocopsacc_openldap-serveradm-servers2Fslapd2Foc.c
"		}
		bva[i].bv_len = idx.bv_len + bv.bv_len;
		bva[i].bv_val = ch_malloc( bva[i].bv_len + 1 );
		strcpy( bva[i].bv_val, ibuf );
		strcpy( bva[i].bv_val + idx.bv_len, bv.bv_val );
",1,unused,871,unused,"		}
		bva[i].bv_len = idx.bv_len + bv.bv_len;
		bva[i].bv_val = ch_malloc( bva[i].bv_len + 1 );
		strcpy( bva[i].bv_val, ibuf );
		strcpy( bva[i].bv_val + idx.bv_len, bv.bv_val );
",unused,ssocopsacc_openldap-serveradm-servers2Fslapd2Foc.c
"					Debug( LDAP_DEBUG_ANY,
						""oidm_find: SLAP_MALLOC failed"", 0, 0, 0 );
					return NULL;
				}
				strcpy(tmp, om->som_oid.bv_val);
",1,unused,67,unused,"					Debug( LDAP_DEBUG_ANY,
						""oidm_find: SLAP_MALLOC failed"", 0, 0, 0 );
					return NULL;
				}
				strcpy(tmp, om->som_oid.bv_val);
",unused,ssocopsacc_openldap-serveradm-servers2Fslapd2Foidm.c
"				strcpy(tmp, om->som_oid.bv_val);
				if( suflen ) {
					suflen = om->som_oid.bv_len;
					tmp[suflen++] = '.';
					strcpy(tmp+suflen, oid+pos+1);
",1,unused,71,unused,"				strcpy(tmp, om->som_oid.bv_val);
				if( suflen ) {
					suflen = om->som_oid.bv_len;
					tmp[suflen++] = '.';
					strcpy(tmp+suflen, oid+pos+1);
",unused,ssocopsacc_openldap-serveradm-servers2Fslapd2Foidm.c
"	for ( i=0,om=start; om; om=LDAP_STAILQ_NEXT(om, som_next)) {
		if ( sys && !(om->som_flags & SLAP_OM_HARDCODE)) break;
		for ( j=0; !BER_BVISNULL(&om->som_names[j]); i++,j++ ) {
			if ( !sys ) {
				idx.bv_len = sprintf(idx.bv_val, ""{%d}"", i );
",1,unused,203,unused,"	for ( i=0,om=start; om; om=LDAP_STAILQ_NEXT(om, som_next)) {
		if ( sys && !(om->som_flags & SLAP_OM_HARDCODE)) break;
		for ( j=0; !BER_BVISNULL(&om->som_names[j]); i++,j++ ) {
			if ( !sys ) {
				idx.bv_len = sprintf(idx.bv_val, ""{%d}"", i );
",unused,ssocopsacc_openldap-serveradm-servers2Fslapd2Foidm.c
"			bva[i].bv_val = ch_malloc( bva[i].bv_len + 1 );
			ptr = lutil_strcopy( bva[i].bv_val, ibuf );
			ptr = lutil_strcopy( ptr, om->som_names[j].bv_val );
			*ptr++ = ' ';
			strcpy( ptr, om->som_subs[j].bv_val );
",1,unused,211,unused,"			bva[i].bv_val = ch_malloc( bva[i].bv_len + 1 );
			ptr = lutil_strcopy( bva[i].bv_val, ibuf );
			ptr = lutil_strcopy( ptr, om->som_names[j].bv_val );
			*ptr++ = ' ';
			strcpy( ptr, om->som_subs[j].bv_val );
",unused,ssocopsacc_openldap-serveradm-servers2Fslapd2Foidm.c
"
		if ( a && ber_bvcmp( &a->a_vals[0], maxcsn ) > 0 &&
			slap_parse_csn_sid( &a->a_vals[0] ) == slap_serverID ) {
			maxcsn->bv_len = a->a_vals[0].bv_len;
			strcpy( maxcsn->bv_val, a->a_vals[0].bv_val );
",1,unused,541,unused,"
		if ( a && ber_bvcmp( &a->a_vals[0], maxcsn ) > 0 &&
			slap_parse_csn_sid( &a->a_vals[0] ) == slap_serverID ) {
			maxcsn->bv_len = a->a_vals[0].bv_len;
			strcpy( maxcsn->bv_val, a->a_vals[0].bv_val );
",unused,ssocopsacc_openldap-serveradm-servers2Fslapd2Foverlays2Fsyncprov.c
"		fop.ors_attrs = csn_anlist;
		fop.ors_slimit = SLAP_NO_LIMIT;
		cb.sc_private = &maxcsn;
		cb.sc_response = findmax_cb;
		strcpy( cbuf, cf.f_av_value.bv_val );
",1,unused,679,unused,"		fop.ors_attrs = csn_anlist;
		fop.ors_slimit = SLAP_NO_LIMIT;
		cb.sc_private = &maxcsn;
		cb.sc_response = findmax_cb;
		strcpy( cbuf, cf.f_av_value.bv_val );
",unused,ssocopsacc_openldap-serveradm-servers2Fslapd2Foverlays2Fsyncprov.c
"	op2->o_req_ndn.bv_len = op->o_req_ndn.bv_len;
	op2->o_req_ndn.bv_val = ptr;
	ptr = lutil_strcopy(ptr, op->o_req_ndn.bv_val) + 1;
	op2->ors_filterstr.bv_val = ptr;
	strcpy( ptr, so->s_filterstr.bv_val );
",1,unused,2293,unused,"	op2->o_req_ndn.bv_len = op->o_req_ndn.bv_len;
	op2->o_req_ndn.bv_val = ptr;
	ptr = lutil_strcopy(ptr, op->o_req_ndn.bv_val) + 1;
	op2->ors_filterstr.bv_val = ptr;
	strcpy( ptr, so->s_filterstr.bv_val );
",unused,ssocopsacc_openldap-serveradm-servers2Fslapd2Foverlays2Fsyncprov.c
"	op2->o_groups = NULL;
	for ( g1=op->o_groups; g1; g1=g1->ga_next ) {
		g2 = ch_malloc( sizeof(GroupAssertion) + g1->ga_len );
		*g2 = *g1;
		strcpy( g2->ga_ndn, g1->ga_ndn );
",1,unused,2311,unused,"	op2->o_groups = NULL;
	for ( g1=op->o_groups; g1; g1=g1->ga_next ) {
		g2 = ch_malloc( sizeof(GroupAssertion) + g1->ga_len );
		*g2 = *g1;
		strcpy( g2->ga_ndn, g1->ga_ndn );
",unused,ssocopsacc_openldap-serveradm-servers2Fslapd2Foverlays2Fsyncprov.c
"			muck.bv_val = ch_malloc( muck.bv_len + 1 );

			strncpy( muck.bv_val, ntargetDN.bv_val,
				ntargetDN.bv_len-nbaseDN.bv_len );
			strcpy( &muck.bv_val[ntargetDN.bv_len-nbaseDN.bv_len],
",1,unused,115,unused,"			muck.bv_val = ch_malloc( muck.bv_len + 1 );

			strncpy( muck.bv_val, ntargetDN.bv_val,
				ntargetDN.bv_len-nbaseDN.bv_len );
			strcpy( &muck.bv_val[ntargetDN.bv_len-nbaseDN.bv_len],
",unused,ssocopsacc_openldap-serveradm-servers2Fslapd2Freferral.c
"
	v2 = ch_malloc( len+i+sizeof(""Referral:"") );

	if( text != NULL ) {
		strcpy(v2, text);
",1,unused,80,unused,"
	v2 = ch_malloc( len+i+sizeof(""Referral:"") );

	if( text != NULL ) {
		strcpy(v2, text);
",unused,ssocopsacc_openldap-serveradm-servers2Fslapd2Fresult.c
"		if( i ) {
			v2[len++] = '\n';
		}
	}
	strcpy( v2+len, ""Referral:"" );
",1,unused,85,unused,"		if( i ) {
			v2[len++] = '\n';
		}
	}
	strcpy( v2+len, ""Referral:"" );
",unused,ssocopsacc_openldap-serveradm-servers2Fslapd2Fresult.c
"	ret->base = ndn;
	if ( flen ) {
		ret->filter.bv_val = (char *)(ret+1);
		ret->filter.bv_len = flen - 1;
		strcpy( ret->filter.bv_val, lud->lud_filter );
",1,unused,975,unused,"	ret->base = ndn;
	if ( flen ) {
		ret->filter.bv_val = (char *)(ret+1);
		ret->filter.bv_len = flen - 1;
		strcpy( ret->filter.bv_val, lud->lud_filter );
",unused,ssocopsacc_openldap-serveradm-servers2Fslapd2Fsasl.c
"	} else {
		*ptr = '\0';
	}
	if ( filter ) {
		strcpy( ptr, filter );
",1,unused,1066,unused,"	} else {
		*ptr = '\0';
	}
	if ( filter ) {
		strcpy( ptr, filter );
",unused,ssocopsacc_openldap-serveradm-servers2Fslapd2Fsasl.c
"	if ( ((rc >> 16) != ((SASL_VERSION_MAJOR << 8)|SASL_VERSION_MINOR)) ||
		(rc & 0xffff) < SASL_VERSION_STEP)
	{
		char version[sizeof(""xxx.xxx.xxxxx"")];
		sprintf( version, ""%u.%d.%d"", (unsigned)rc >> 24, (rc >> 16) & 0xff,
",1,unused,1147,unused,"	if ( ((rc >> 16) != ((SASL_VERSION_MAJOR << 8)|SASL_VERSION_MINOR)) ||
		(rc & 0xffff) < SASL_VERSION_STEP)
	{
		char version[sizeof(""xxx.xxx.xxxxx"")];
		sprintf( version, ""%u.%d.%d"", (unsigned)rc >> 24, (rc >> 16) & 0xff,
",unused,ssocopsacc_openldap-serveradm-servers2Fslapd2Fsasl.c
"	idx.bv_val = ibuf;
	bva = ch_malloc( (nSaslRegexp+1) * sizeof(struct berval) );
	BER_BVZERO(bva+nSaslRegexp);
	for ( i=0; i<nSaslRegexp; i++ ) {
		idx.bv_len = sprintf( idx.bv_val, ""{%d}"", i);
",1,unused,1435,unused,"	idx.bv_val = ibuf;
	bva = ch_malloc( (nSaslRegexp+1) * sizeof(struct berval) );
	BER_BVZERO(bva+nSaslRegexp);
	for ( i=0; i<nSaslRegexp; i++ ) {
		idx.bv_len = sprintf( idx.bv_val, ""{%d}"", i);
",unused,ssocopsacc_openldap-serveradm-servers2Fslapd2Fsaslauthz.c
"	sptr = out->bv_val;
	*sptr++ = '\'';
	i = 0;
	if ( first ) {
		sprintf( sptr, ""%01X"", ( ptr[0] & 0x0fU ) );
",1,unused,3506,unused,"	sptr = out->bv_val;
	*sptr++ = '\'';
	i = 0;
	if ( first ) {
		sprintf( sptr, ""%01X"", ( ptr[0] & 0x0fU ) );
",unused,ssocopsacc_openldap-serveradm-servers2Fslapd2Fschema_init.c
"		sptr++;
		i = 1;
	}
	for ( ; i < len; i++ ) {
		sprintf( sptr, ""%02X"", ptr[i] );
",1,unused,3511,unused,"		sptr++;
		i = 1;
	}
	for ( ; i < len; i++ ) {
		sprintf( sptr, ""%02X"", ptr[i] );
",unused,ssocopsacc_openldap-serveradm-servers2Fslapd2Fschema_init.c
"	if ( BER_BVISNULL( normalized ) ) {
		return LBER_ERROR_MEMORY;
	}

	sprintf( normalized->bv_val, ""%02d%02d%02d%02d%02d%02d%02d"",
",1,unused,5686,unused,"	if ( BER_BVISNULL( normalized ) ) {
		return LBER_ERROR_MEMORY;
	}

	sprintf( normalized->bv_val, ""%02d%02d%02d%02d%02d%02d%02d"",
",unused,ssocopsacc_openldap-serveradm-servers2Fslapd2Fschema_init.c
"		memcpy( normalized->bv_val + STRLENOF(""YYYYmmddHHMMSSZ"")-1,
			fraction.bv_val, fraction.bv_len );
		normalized->bv_val[STRLENOF(""YYYYmmddHHMMSSZ"")-1] = '.';
	}
	strcpy( normalized->bv_val + len-1, ""Z"" );
",1,unused,5694,unused,"		memcpy( normalized->bv_val + STRLENOF(""YYYYmmddHHMMSSZ"")-1,
			fraction.bv_val, fraction.bv_len );
		normalized->bv_val[STRLENOF(""YYYYmmddHHMMSSZ"")-1] = '.';
	}
	strcpy( normalized->bv_val + len-1, ""Z"" );
",unused,ssocopsacc_openldap-serveradm-servers2Fslapd2Fschema_init.c
"	if ( StatslogTest( LDAP_DEBUG_STATS ) ) {
		char abuf[BUFSIZ/2], *ptr = abuf;
		unsigned len = 0, alen;

		sprintf(abuf, ""scope=%d deref=%d"", op->ors_scope, op->ors_deref);
",1,unused,215,unused,"	if ( StatslogTest( LDAP_DEBUG_STATS ) ) {
		char abuf[BUFSIZ/2], *ptr = abuf;
		unsigned len = 0, alen;

		sprintf(abuf, ""scope=%d deref=%d"", op->ors_scope, op->ors_deref);
",unused,ssocopsacc_openldap-serveradm-servers2Fslapd2Fsearch.c
"			} else {
				match = -1;
			}
			if ( match < 0 ) {
				strcpy( maxcsn[ sid ].bv_val, attr->a_nvals[0].bv_val );
",1,unused,1143,unused,"			} else {
				match = -1;
			}
			if ( match < 0 ) {
				strcpy( maxcsn[ sid ].bv_val, attr->a_nvals[0].bv_val );
",unused,ssocopsacc_openldap-serveradm-servers2Fslapd2Fslapcommon.c
"
		size = sizeof(""(&(entryCSN>=)(reqDN=))"");
		size += bv.bv_len + op->o_req_ndn.bv_len + si->si_logfilterstr.bv_len;
		op2.ors_filterstr.bv_val = op->o_tmpalloc( size, op->o_tmpmemctx );
		op2.ors_filterstr.bv_len = sprintf(op2.ors_filterstr.bv_val,
",1,unused,2152,unused,"
		size = sizeof(""(&(entryCSN>=)(reqDN=))"");
		size += bv.bv_len + op->o_req_ndn.bv_len + si->si_logfilterstr.bv_len;
		op2.ors_filterstr.bv_val = op->o_tmpalloc( size, op->o_tmpmemctx );
		op2.ors_filterstr.bv_len = sprintf(op2.ors_filterstr.bv_val,
",unused,ssocopsacc_openldap-serveradm-servers2Fslapd2Fsyncrepl.c
"	if ( rc != LDAP_SUCCESS )
		return rc;

	vnc = ch_malloc( si->si_base.bv_len + 6 );
	strcpy( vnc, ""(.*)"" );
",1,unused,4655,unused,"	if ( rc != LDAP_SUCCESS )
		return rc;

	vnc = ch_malloc( si->si_base.bv_len + 6 );
	strcpy( vnc, ""(.*)"" );
",unused,ssocopsacc_openldap-serveradm-servers2Fslapd2Fsyncrepl.c
"	lutil_strcopy( lutil_strcopy( vnc+4, si->si_base.bv_val ), ""$"" );
	argvRule[1] = vnc;

	rnc = ch_malloc( si->si_suffixm.bv_len + 3 );
	strcpy( rnc, ""%1"" );
",1,unused,4660,unused,"	lutil_strcopy( lutil_strcopy( vnc+4, si->si_base.bv_val ), ""$"" );
	argvRule[1] = vnc;

	rnc = ch_malloc( si->si_suffixm.bv_len + 3 );
	strcpy( rnc, ""%1"" );
",unused,ssocopsacc_openldap-serveradm-servers2Fslapd2Fsyncrepl.c
"	argvRule[1] = vnc;

	rnc = ch_malloc( si->si_suffixm.bv_len + 3 );
	strcpy( rnc, ""%1"" );
	strcpy( rnc+2, si->si_suffixm.bv_val );
",1,unused,4661,unused,"	argvRule[1] = vnc;

	rnc = ch_malloc( si->si_suffixm.bv_len + 3 );
	strcpy( rnc, ""%1"" );
	strcpy( rnc+2, si->si_suffixm.bv_val );
",unused,ssocopsacc_openldap-serveradm-servers2Fslapd2Fsyncrepl.c
"				Debug( LDAP_DEBUG_ANY, ""%s: %s.\n"", c->log, c->cr_msg, 0 );
				return -1;
			}
			si->si_rid = tmp;
			sprintf( si->si_ridtxt, IDSTR ""=%03d"", si->si_rid );
",1,unused,4855,unused,"				Debug( LDAP_DEBUG_ANY, ""%s: %s.\n"", c->log, c->cr_msg, 0 );
				return -1;
			}
			si->si_rid = tmp;
			sprintf( si->si_ridtxt, IDSTR ""=%03d"", si->si_rid );
",unused,ssocopsacc_openldap-serveradm-servers2Fslapd2Fsyncrepl.c
"		Debug( LDAP_DEBUG_ANY, ""%s: %s\n"", c->log, c->cr_msg, 0 );
		return 1;
	}
	if ( BER_BVISEMPTY( &c->be->be_rootdn ) ) {
		strcpy( c->cr_msg, ""rootDN must be defined before syncrepl may be used"" );
",1,unused,5270,unused,"		Debug( LDAP_DEBUG_ANY, ""%s: %s\n"", c->log, c->cr_msg, 0 );
		return 1;
	}
	if ( BER_BVISEMPTY( &c->be->be_rootdn ) ) {
		strcpy( c->cr_msg, ""rootDN must be defined before syncrepl may be used"" );
",unused,ssocopsacc_openldap-serveradm-servers2Fslapd2Fsyncrepl.c
"		if ( ldap_syntax2bv( &syn->ssyn_syn, &bv ) == NULL ) {
			ber_bvarray_free( bva );
		}
		if ( !sys ) {
			idx.bv_len = sprintf(idx.bv_val, ""{%d}"", i);
",1,unused,444,unused,"		if ( ldap_syntax2bv( &syn->ssyn_syn, &bv ) == NULL ) {
			ber_bvarray_free( bva );
		}
		if ( !sys ) {
			idx.bv_len = sprintf(idx.bv_val, ""{%d}"", i);
",unused,ssocopsacc_openldap-serveradm-servers2Fslapd2Fsyntax.c
"			idx.bv_len = sprintf(idx.bv_val, ""{%d}"", i);
		}
		bva[i].bv_len = idx.bv_len + bv.bv_len;
		bva[i].bv_val = ch_malloc( bva[i].bv_len + 1 );
		strcpy( bva[i].bv_val, ibuf );
",1,unused,448,unused,"			idx.bv_len = sprintf(idx.bv_val, ""{%d}"", i);
		}
		bva[i].bv_len = idx.bv_len + bv.bv_len;
		bva[i].bv_val = ch_malloc( bva[i].bv_len + 1 );
		strcpy( bva[i].bv_val, ibuf );
",unused,ssocopsacc_openldap-serveradm-servers2Fslapd2Fsyntax.c
"		}
		bva[i].bv_len = idx.bv_len + bv.bv_len;
		bva[i].bv_val = ch_malloc( bva[i].bv_len + 1 );
		strcpy( bva[i].bv_val, ibuf );
		strcpy( bva[i].bv_val + idx.bv_len, bv.bv_val );
",1,unused,449,unused,"		}
		bva[i].bv_len = idx.bv_len + bv.bv_len;
		bva[i].bv_val = ch_malloc( bva[i].bv_len + 1 );
		strcpy( bva[i].bv_val, ibuf );
		strcpy( bva[i].bv_val + idx.bv_len, bv.bv_val );
",unused,ssocopsacc_openldap-serveradm-servers2Fslapd2Fsyntax.c
"
	ibv.bv_val = ibuf;

	for (i=0; i<a->a_numvals; i++) {
		ibv.bv_len = sprintf(ibv.bv_val, ""{%u}"", i);
",1,unused,275,unused,"
	ibv.bv_val = ibuf;

	for (i=0; i<a->a_numvals; i++) {
		ibv.bv_len = sprintf(ibv.bv_val, ""{%u}"", i);
",unused,ssocopsacc_openldap-serveradm-servers2Fslapd2Fvalue.c
"			vtmp.bv_val = ptr;
		}
		tmp.bv_len = ibv.bv_len + vtmp.bv_len;
		tmp.bv_val = ch_malloc( tmp.bv_len + 1 );
		strcpy( tmp.bv_val, ibv.bv_val );
",1,unused,286,unused,"			vtmp.bv_val = ptr;
		}
		tmp.bv_len = ibv.bv_len + vtmp.bv_len;
		tmp.bv_val = ch_malloc( tmp.bv_len + 1 );
		strcpy( tmp.bv_val, ibv.bv_val );
",unused,ssocopsacc_openldap-serveradm-servers2Fslapd2Fvalue.c
"				vtmp.bv_val = ptr;
			}
			tmp.bv_len = ibv.bv_len + vtmp.bv_len;
			tmp.bv_val = ch_malloc( tmp.bv_len + 1 );
			strcpy( tmp.bv_val, ibv.bv_val );
",1,unused,303,unused,"				vtmp.bv_val = ptr;
			}
			tmp.bv_len = ibv.bv_len + vtmp.bv_len;
			tmp.bv_val = ch_malloc( tmp.bv_len + 1 );
			strcpy( tmp.bv_val, ibv.bv_val );
",unused,ssocopsacc_openldap-serveradm-servers2Fslapd2Fvalue.c
"	ftail++;

	for ( i = 0; i < innerloop; i++ ) {
		int	r = ((double)range)*rand()/(RAND_MAX + 1.0);
		sprintf(fbuf, ""%.*s%d%s"", flen, filter, r, ftail);
",1,unused,740,unused,"	ftail++;

	for ( i = 0; i < innerloop; i++ ) {
		int	r = ((double)range)*rand()/(RAND_MAX + 1.0);
		sprintf(fbuf, ""%.*s%d%s"", flen, filter, r, ftail);
",unused,ssocopsacc_openldap-serveradm-tests2Fprogs2Fslapd-mtread.c
"	ptr = e->val + e->len;
	e->len = new_len;
	ss->len = ++n;
	for ( ; n < end; free( vals[n++].val )) {
		ptr = strcpy( ptr, vals[n].val ) + vals[n].len;
",1,unused,133,unused,"	ptr = e->val + e->len;
	e->len = new_len;
	ss->len = ++n;
	for ( ; n < end; free( vals[n++].val )) {
		ptr = strcpy( ptr, vals[n].val ) + vals[n].len;
",unused,ssocopsacc_openldap-tests2Fprogs2Fldif-filter.c
"
	/* LDIF = Entries ss[..entries-1] + sep + attrs ss[entries..] + line */
	for ( ; !eof || ss.len || *sep; prev_eol = eol ) {
		if ( eof || (eof = !fgets( line, sizeof(line), stdin ))) {
			strcpy( line, prev_eol ? """" : *sep ? sep : ""\n"" );
",1,unused,171,unused,"
	/* LDIF = Entries ss[..entries-1] + sep + attrs ss[entries..] + line */
	for ( ; !eof || ss.len || *sep; prev_eol = eol ) {
		if ( eof || (eof = !fgets( line, sizeof(line), stdin ))) {
			strcpy( line, prev_eol ? """" : *sep ? sep : ""\n"" );
",unused,ssocopsacc_openldap-tests2Fprogs2Fldif-filter.c
"	ftail++;

	for ( i = 0; i < innerloop; i++ ) {
		int	r = ((double)range)*rand()/(RAND_MAX + 1.0);
		sprintf(fbuf, ""%.*s%d%s"", flen, filter, r, ftail);
",1,unused,740,unused,"	ftail++;

	for ( i = 0; i < innerloop; i++ ) {
		int	r = ((double)range)*rand()/(RAND_MAX + 1.0);
		sprintf(fbuf, ""%.*s%d%s"", flen, filter, r, ftail);
",unused,ssocopsacc_openldap-tests2Fprogs2Fslapd-mtread.c
"	}

	/* turn command line into argv[] pieces */

	sprintf (virtAddress, ""%s"", inet_ntoa (FOserver->virtualAddress));
",1,unused,204,unused,"	}

	/* turn command line into argv[] pieces */

	sprintf (virtAddress, ""%s"", inet_ntoa (FOserver->virtualAddress));
",unused,ssocopsacc_piranha-fos.c
"
	/* turn command line into argv[] pieces */

	sprintf (virtAddress, ""%s"", inet_ntoa (FOserver->virtualAddress));
	sprintf (port, ""%d"", FOserver->port);
",1,unused,205,unused,"
	/* turn command line into argv[] pieces */

	sprintf (virtAddress, ""%s"", inet_ntoa (FOserver->virtualAddress));
	sprintf (port, ""%d"", FOserver->port);
",unused,ssocopsacc_piranha-fos.c
"	if (!FOserver->isActive)
		return 0;

	virtAddress = strdup (inet_ntoa (FOserver->virtualAddress));
	sprintf (portNum, ""%d"", FOserver->port);
",1,unused,237,unused,"	if (!FOserver->isActive)
		return 0;

	virtAddress = strdup (inet_ntoa (FOserver->virtualAddress));
	sprintf (portNum, ""%d"", FOserver->port);
",unused,ssocopsacc_piranha-fos.c
"		return 0;

	virtAddress = strdup (inet_ntoa (FOserver->virtualAddress));
	realAddress = strdup (inet_ntoa (partnerAddress));
	sprintf (portNum, ""%d"", FOserver->port);
",1,unused,279,unused,"		return 0;

	virtAddress = strdup (inet_ntoa (FOserver->virtualAddress));
	realAddress = strdup (inet_ntoa (partnerAddress));
	sprintf (portNum, ""%d"", FOserver->port);
",unused,ssocopsacc_piranha-fos.c
"
	virtAddress = strdup (inet_ntoa (FOserver->virtualAddress));
	realAddress = strdup (inet_ntoa (partnerAddress));
	sprintf (portNum, ""%d"", FOserver->port);
	sprintf (timeoutNum, ""%d"", FOserver->timeout);
",1,unused,280,unused,"
	virtAddress = strdup (inet_ntoa (FOserver->virtualAddress));
	realAddress = strdup (inet_ntoa (partnerAddress));
	sprintf (portNum, ""%d"", FOserver->port);
	sprintf (timeoutNum, ""%d"", FOserver->timeout);
",unused,ssocopsacc_piranha-fos.c
"		parseCommandStr (cmd_string, arg);
	}
	/* turn command line into argv[] pieces */

	sprintf (virtAddress, ""%s"", inet_ntoa (FOserver->virtualAddress));
",1,unused,389,unused,"		parseCommandStr (cmd_string, arg);
	}
	/* turn command line into argv[] pieces */

	sprintf (virtAddress, ""%s"", inet_ntoa (FOserver->virtualAddress));
",unused,ssocopsacc_piranha-fos.c
"	}
	/* turn command line into argv[] pieces */

	sprintf (virtAddress, ""%s"", inet_ntoa (FOserver->virtualAddress));
	sprintf (port, ""%d"", FOserver->port);
",1,unused,390,unused,"	}
	/* turn command line into argv[] pieces */

	sprintf (virtAddress, ""%s"", inet_ntoa (FOserver->virtualAddress));
	sprintf (port, ""%d"", FOserver->port);
",unused,ssocopsacc_piranha-fos.c
"{
	struct ifreq req;
	struct sockaddr_in *addrp;

	strcpy (req.ifr_name, device);
",1,unused,415,unused,"{
	struct ifreq req;
	struct sockaddr_in *addrp;

	strcpy (req.ifr_name, device);
",unused,ssocopsacc_piranha-fos.c
"					break;
			}

			if (i < config->numFailoverServices) {
				sprintf (virtAddress, ""%s"",
",1,unused,590,unused,"					break;
			}

			if (i < config->numFailoverServices) {
				sprintf (virtAddress, ""%s"",
",unused,ssocopsacc_piranha-fos.c
"			if (i < config->numFailoverServices) {
				sprintf (virtAddress, ""%s"",
					 inet_ntoa (config->failoverServices[i].
						    virtualAddress));
				sprintf (port, ""%d"",
",1,unused,593,unused,"			if (i < config->numFailoverServices) {
				sprintf (virtAddress, ""%s"",
					 inet_ntoa (config->failoverServices[i].
						    virtualAddress));
				sprintf (port, ""%d"",
",unused,ssocopsacc_piranha-fos.c
"	char command[5012] = {0};

	debug_print(INFOAGENT_LOG_FILE,8,""Updating FileSync Configuration File."");

	strcpy(fileStr,""FILES="");
",1,unused,609,unused,"	char command[5012] = {0};

	debug_print(INFOAGENT_LOG_FILE,8,""Updating FileSync Configuration File."");

	strcpy(fileStr,""FILES="");
",unused,ssocopsacc_piranha-infoAgent.c
"		for(i=0; i < NUM_FILES_LIST; i++)
		{
			if(filestosync[i] && (strlen(filestosync[i]) > 0))
			{
				strcat(fileStr,filestosync[i]);
",1,unused,617,unused,"		for(i=0; i < NUM_FILES_LIST; i++)
		{
			if(filestosync[i] && (strlen(filestosync[i]) > 0))
			{
				strcat(fileStr,filestosync[i]);
",unused,ssocopsacc_piranha-infoAgent.c
"			if(filestosync[i] && (strlen(filestosync[i]) > 0))
			{
				strcat(fileStr,filestosync[i]);
				if(i != NUM_FILES_LIST-1)
					strcat(fileStr,"","");
",1,unused,619,unused,"			if(filestosync[i] && (strlen(filestosync[i]) > 0))
			{
				strcat(fileStr,filestosync[i]);
				if(i != NUM_FILES_LIST-1)
					strcat(fileStr,"","");
",unused,ssocopsacc_piranha-infoAgent.c
"			""/home/fes/fescommon/auth.xml""
		};


		sprintf(fileStr,""FILES=%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s"",&files[0][0],&files[1][0],&files[2][0],&files[3][0],&files[4][0],&files[5][0],&files[6][0],&files[7][0],&files[8][0],&files[9][0],&files[10][0],&files[11][0],&files[12][0],&files[13][0],&files[14][0],&files[15][0],&files[16][0],&files[17][0],&files[18][0],&files[19][0],&files[20][0],&files[21][0],&files[22][0],&files[23][0],&files[24][0],&files[25][0],&files[26][0],&files[27][0],&files[28][0],&files[29][0],&files[30][0],&files[31][0],&files[32][0],&files[33][0],&files[34][0],&files[35][0],&files[36][0],&files[37][0], &files[38][0], &files[39][0], &files[40][0]);
",1,unused,670,unused,"			""/home/fes/fescommon/auth.xml""
		};


		sprintf(fileStr,""FILES=%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s,%s"",&files[0][0],&files[1][0],&files[2][0],&files[3][0],&files[4][0],&files[5][0],&files[6][0],&files[7][0],&files[8][0],&files[9][0],&files[10][0],&files[11][0],&files[12][0],&files[13][0],&files[14][0],&files[15][0],&files[16][0],&files[17][0],&files[18][0],&files[19][0],&files[20][0],&files[21][0],&files[22][0],&files[23][0],&files[24][0],&files[25][0],&files[26][0],&files[27][0],&files[28][0],&files[29][0],&files[30][0],&files[31][0],&files[32][0],&files[33][0],&files[34][0],&files[35][0],&files[36][0],&files[37][0], &files[38][0], &files[39][0], &files[40][0]);
",unused,ssocopsacc_piranha-infoAgent.c
"	}

	debug_print(INFOAGENT_LOG_FILE,8,""Files Added For Sync %s"",fileStr);
	
	sprintf(command,""echo \""%s\"" > /home/fes/filesync.conf"",fileStr);
",1,unused,676,unused,"	}

	debug_print(INFOAGENT_LOG_FILE,8,""Files Added For Sync %s"",fileStr);
	
	sprintf(command,""echo \""%s\"" > /home/fes/filesync.conf"",fileStr);
",unused,ssocopsacc_piranha-infoAgent.c
"	system(command);

	debug_print(INFOAGENT_LOG_FILE,8,""Real Servers Added For Sync %s"",serverList);

	sprintf(command,""echo \""%s\"" >> /home/fes/filesync.conf"",serverList);
",1,unused,681,unused,"	system(command);

	debug_print(INFOAGENT_LOG_FILE,8,""Real Servers Added For Sync %s"",serverList);

	sprintf(command,""echo \""%s\"" >> /home/fes/filesync.conf"",serverList);
",unused,ssocopsacc_piranha-infoAgent.c
"				struct serversList* tmpptr = (struct serversList*)malloc(sizeof( struct serversList));
				if(tmpptr != NULL)
				{
					memset(tmpptr, 0, sizeof(struct serversList));
					sprintf(tmpptr->IpAddress,""%s"",tmptok);
",1,unused,717,unused,"				struct serversList* tmpptr = (struct serversList*)malloc(sizeof( struct serversList));
				if(tmpptr != NULL)
				{
					memset(tmpptr, 0, sizeof(struct serversList));
					sprintf(tmpptr->IpAddress,""%s"",tmptok);
",unused,ssocopsacc_piranha-infoAgent.c
"
	if(serverListptr != NULL)
	{
		memset(serverListptr,0,sizeof(clusterConf->RealServer));
		sprintf(serverListptr,""%s"",clusterConf->RealServer);
",1,unused,895,unused,"
	if(serverListptr != NULL)
	{
		memset(serverListptr,0,sizeof(clusterConf->RealServer));
		sprintf(serverListptr,""%s"",clusterConf->RealServer);
",unused,ssocopsacc_piranha-infoAgent.c
"		TAILQ_INIT(&LocalList);

		if((tmpptr1 != NULL) && (tmpptr2 != NULL))
		{
			strcpy(tmpptr1->IpAddress,clusterConf->ActivePrivateIP);
",1,unused,910,unused,"		TAILQ_INIT(&LocalList);

		if((tmpptr1 != NULL) && (tmpptr2 != NULL))
		{
			strcpy(tmpptr1->IpAddress,clusterConf->ActivePrivateIP);
",unused,ssocopsacc_piranha-infoAgent.c
"
		if((tmpptr1 != NULL) && (tmpptr2 != NULL))
		{
			strcpy(tmpptr1->IpAddress,clusterConf->ActivePrivateIP);
			strcpy(tmpptr2->IpAddress,clusterConf->BackupPrivateIP);
",1,unused,911,unused,"
		if((tmpptr1 != NULL) && (tmpptr2 != NULL))
		{
			strcpy(tmpptr1->IpAddress,clusterConf->ActivePrivateIP);
			strcpy(tmpptr2->IpAddress,clusterConf->BackupPrivateIP);
",unused,ssocopsacc_piranha-infoAgent.c
"			TAILQ_INSERT_TAIL(&RemoteList,tmpptr2,entries);
		}
	}
	
	sprintf(realServersList,""SERVERS=%s,%s"",clusterConf->ActivePrivateIP,clusterConf->BackupPrivateIP);	
",1,unused,919,unused,"			TAILQ_INSERT_TAIL(&RemoteList,tmpptr2,entries);
		}
	}
	
	sprintf(realServersList,""SERVERS=%s,%s"",clusterConf->ActivePrivateIP,clusterConf->BackupPrivateIP);	
",unused,ssocopsacc_piranha-infoAgent.c
"				/*Fill Remote List for comparision.*/
				if(tmpptr)
				{
					memset(tmpptr,0,sizeof(struct serversList));
					sprintf(tmpptr->IpAddress,""%s"",tmptok);
",1,unused,935,unused,"				/*Fill Remote List for comparision.*/
				if(tmpptr)
				{
					memset(tmpptr,0,sizeof(struct serversList));
					sprintf(tmpptr->IpAddress,""%s"",tmptok);
",unused,ssocopsacc_piranha-infoAgent.c
"					TAILQ_INSERT_TAIL(&RemoteList, tmpptr, entries);
				}
			}	
			
			strcat(realServersList,"","");
",1,unused,948,unused,"					TAILQ_INSERT_TAIL(&RemoteList, tmpptr, entries);
				}
			}	
			
			strcat(realServersList,"","");
",unused,ssocopsacc_piranha-infoAgent.c
"				}
			}	
			
			strcat(realServersList,"","");
			strcat(realServersList,tmptok);
",1,unused,949,unused,"				}
			}	
			
			strcat(realServersList,"","");
			strcat(realServersList,tmptok);
",unused,ssocopsacc_piranha-infoAgent.c
"	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if(sockfd != -1)
	{
		ifr.ifr_addr.sa_family = AF_INET;
		strcpy(ifr.ifr_name,interfaceName);
",1,unused,1016,unused,"	sockfd = socket(AF_INET, SOCK_DGRAM, 0);
	if(sockfd != -1)
	{
		ifr.ifr_addr.sa_family = AF_INET;
		strcpy(ifr.ifr_name,interfaceName);
",unused,ssocopsacc_piranha-infoAgent.c
"		}

		close(sockfd);
		//debug_print(INFOAGENT_LOG_FILE,8,""GetInterfaceInfo returned, interface [%s], ipaddress [%s]"",interfaceName,inet_ntoa(((struct sockaddr_in *)&ifr.ifr_addr)->sin_addr));
		strcpy(MyInterfaceip,inet_ntoa(((struct sockaddr_in *)&ifr.ifr_addr)->sin_addr));
",1,unused,1028,unused,"		}

		close(sockfd);
		//debug_print(INFOAGENT_LOG_FILE,8,""GetInterfaceInfo returned, interface [%s], ipaddress [%s]"",interfaceName,inet_ntoa(((struct sockaddr_in *)&ifr.ifr_addr)->sin_addr));
		strcpy(MyInterfaceip,inet_ntoa(((struct sockaddr_in *)&ifr.ifr_addr)->sin_addr));
",unused,ssocopsacc_piranha-infoAgent.c
"		{
			if(strstr(bigResult,""min"") || strstr(bigResult,""hrs"") || strstr(bigResult,""days""))
			{
				bigResult[sizeof(selfStat->sysUpTime) - 1] = '\0';
				sprintf(selfStat->sysUpTime, ""%s"", bigResult);
",1,unused,1466,unused,"		{
			if(strstr(bigResult,""min"") || strstr(bigResult,""hrs"") || strstr(bigResult,""days""))
			{
				bigResult[sizeof(selfStat->sysUpTime) - 1] = '\0';
				sprintf(selfStat->sysUpTime, ""%s"", bigResult);
",unused,ssocopsacc_piranha-infoAgent.c
"				{
					float idlet = atof(bigResult);
					float percentage = 100.0;
					percentage = percentage - idlet;
					sprintf(selfStat->cpu,""%f"",percentage);
",1,unused,1521,unused,"				{
					float idlet = atof(bigResult);
					float percentage = 100.0;
					percentage = percentage - idlet;
					sprintf(selfStat->cpu,""%f"",percentage);
",unused,ssocopsacc_piranha-infoAgent.c
"					selfStat->cpu[strlen(bigResult)] = '\0';
				}
			}
			else
				sprintf(selfStat->cpu,""%s"",""NA"");
",1,unused,1526,unused,"					selfStat->cpu[strlen(bigResult)] = '\0';
				}
			}
			else
				sprintf(selfStat->cpu,""%s"",""NA"");
",unused,ssocopsacc_piranha-infoAgent.c
"			else
				sprintf(selfStat->cpu,""%s"",""NA"");
		}
		else
			sprintf(selfStat->cpu,""%s"",""00"");
",1,unused,1529,unused,"			else
				sprintf(selfStat->cpu,""%s"",""NA"");
		}
		else
			sprintf(selfStat->cpu,""%s"",""00"");
",unused,ssocopsacc_piranha-infoAgent.c
"	}
	else
	{
		debug_print(INFOAGENT_LOG_FILE,8,""GetNodeStatus: failed to read CPU status."");	
		sprintf(selfStat->cpu,""%s"",""00"");
",1,unused,1534,unused,"	}
	else
	{
		debug_print(INFOAGENT_LOG_FILE,8,""GetNodeStatus: failed to read CPU status."");	
		sprintf(selfStat->cpu,""%s"",""00"");
",unused,ssocopsacc_piranha-infoAgent.c
"				i++;
			}

			if(founddigit)
				sprintf(selfStat->secMem, ""%s"", bigResult);
",1,unused,1567,unused,"				i++;
			}

			if(founddigit)
				sprintf(selfStat->secMem, ""%s"", bigResult);
",unused,ssocopsacc_piranha-infoAgent.c
"
			if(founddigit)
				sprintf(selfStat->secMem, ""%s"", bigResult);
			else
				sprintf(selfStat->secMem, ""%s"", ""NA"");
",1,unused,1569,unused,"
			if(founddigit)
				sprintf(selfStat->secMem, ""%s"", bigResult);
			else
				sprintf(selfStat->secMem, ""%s"", ""NA"");
",unused,ssocopsacc_piranha-infoAgent.c
"			else
				sprintf(selfStat->secMem, ""%s"", ""NA"");
		}
		else
			sprintf(selfStat->secMem,""%s"",""00"");
",1,unused,1572,unused,"			else
				sprintf(selfStat->secMem, ""%s"", ""NA"");
		}
		else
			sprintf(selfStat->secMem,""%s"",""00"");
",unused,ssocopsacc_piranha-infoAgent.c
"	}
	else
	{
		debug_print(INFOAGENT_LOG_FILE,8,""GetNodeStatus: Failed To Read Disk Status."");
		sprintf(selfStat->secMem, ""%s"", ""00"");
",1,unused,1577,unused,"	}
	else
	{
		debug_print(INFOAGENT_LOG_FILE,8,""GetNodeStatus: Failed To Read Disk Status."");
		sprintf(selfStat->secMem, ""%s"", ""00"");
",unused,ssocopsacc_piranha-infoAgent.c
"			i++;
		}

		if(founddigit)
			sprintf(selfStat->mem, ""%s"", bigResult);
",1,unused,1607,unused,"			i++;
		}

		if(founddigit)
			sprintf(selfStat->mem, ""%s"", bigResult);
",unused,ssocopsacc_piranha-infoAgent.c
"
		if(founddigit)
			sprintf(selfStat->mem, ""%s"", bigResult);
		else
			sprintf(selfStat->mem, ""%s"", ""NA"");
",1,unused,1609,unused,"
		if(founddigit)
			sprintf(selfStat->mem, ""%s"", bigResult);
		else
			sprintf(selfStat->mem, ""%s"", ""NA"");
",unused,ssocopsacc_piranha-infoAgent.c
"	}
	else
	{
		debug_print(INFOAGENT_LOG_FILE,8,""GetNodeStatus: Failed To Read Mem Status."");
		sprintf(selfStat->mem,""%s"",""00"");
",1,unused,1614,unused,"	}
	else
	{
		debug_print(INFOAGENT_LOG_FILE,8,""GetNodeStatus: Failed To Read Mem Status."");
		sprintf(selfStat->mem,""%s"",""00"");
",unused,ssocopsacc_piranha-infoAgent.c
"		{	
			debug_print(INFOAGENT_LOG_FILE,8,""PassiveInfo: WARNING Running with a time difference more than ONE minute!!!"");	
			/*SYNC TIME WITH ACTIVE SERVER.*/
			char cmd[512] = {0};
			sprintf(cmd,""echo \""date -s \\\""$(date -d @%d)\\\""\"" > /tmp/timeset.sh"",(int)activeMachineTime+1);
",1,unused,1735,unused,"		{	
			debug_print(INFOAGENT_LOG_FILE,8,""PassiveInfo: WARNING Running with a time difference more than ONE minute!!!"");	
			/*SYNC TIME WITH ACTIVE SERVER.*/
			char cmd[512] = {0};
			sprintf(cmd,""echo \""date -s \\\""$(date -d @%d)\\\""\"" > /tmp/timeset.sh"",(int)activeMachineTime+1);
",unused,ssocopsacc_piranha-infoAgent.c
"	debug_print(INFOAGENT_LOG_FILE,8,""Calling IP Tables PreRouting Commands To Accept traffic with IP as VIP."");

	system(""iptables -t nat -F"");

	sprintf(IptableCommand,""iptables -t nat -A PREROUTING -i %s -d %s -p tcp --dport %d -j DNAT --to %s "",selfintface,VirtualIP,80,selfIPaddress);
",1,unused,1780,unused,"	debug_print(INFOAGENT_LOG_FILE,8,""Calling IP Tables PreRouting Commands To Accept traffic with IP as VIP."");

	system(""iptables -t nat -F"");

	sprintf(IptableCommand,""iptables -t nat -A PREROUTING -i %s -d %s -p tcp --dport %d -j DNAT --to %s "",selfintface,VirtualIP,80,selfIPaddress);
",unused,ssocopsacc_piranha-infoAgent.c
"
	sprintf(IptableCommand,""iptables -t nat -A PREROUTING -i %s -d %s -p tcp --dport %d -j DNAT --to %s "",selfintface,VirtualIP,80,selfIPaddress);
	system(IptableCommand);

	sprintf(IptableCommand,""iptables -t nat -A PREROUTING -i %s -d %s -p tcp --dport %d -j DNAT --to %s "",selfintface,VirtualIP,443,selfIPaddress);
",1,unused,1783,unused,"
	sprintf(IptableCommand,""iptables -t nat -A PREROUTING -i %s -d %s -p tcp --dport %d -j DNAT --to %s "",selfintface,VirtualIP,80,selfIPaddress);
	system(IptableCommand);

	sprintf(IptableCommand,""iptables -t nat -A PREROUTING -i %s -d %s -p tcp --dport %d -j DNAT --to %s "",selfintface,VirtualIP,443,selfIPaddress);
",unused,ssocopsacc_piranha-infoAgent.c
"		debug_print(INFOAGENT_LOG_FILE,8,""PassiveInfo: I am a Load balancer + VPN server."");
		type = STANDBY_LOAD_BALANCER;
	}

	sprintf(serverlist,""%s"",confbuffer->RealServer);
",1,unused,1800,unused,"		debug_print(INFOAGENT_LOG_FILE,8,""PassiveInfo: I am a Load balancer + VPN server."");
		type = STANDBY_LOAD_BALANCER;
	}

	sprintf(serverlist,""%s"",confbuffer->RealServer);
",unused,ssocopsacc_piranha-infoAgent.c
"	
	confbuffer = (CONFIG_DATA*)(readData + sizeof(CONFCOMMAND));  
	if(confbuffer)
	{
		sprintf(selfIP,""%s"",GetInterfaceInfo(confbuffer->IntfName));//inet_ntoa(GetInterfaceInfo(confbuffer->IntfName)));
",1,unused,1851,unused,"	
	confbuffer = (CONFIG_DATA*)(readData + sizeof(CONFCOMMAND));  
	if(confbuffer)
	{
		sprintf(selfIP,""%s"",GetInterfaceInfo(confbuffer->IntfName));//inet_ntoa(GetInterfaceInfo(confbuffer->IntfName)));
",unused,ssocopsacc_piranha-infoAgent.c
"	confbuffer = (CONFIG_DATA*)(readData + sizeof(CONFCOMMAND));  
	if(confbuffer)
	{
		sprintf(selfIP,""%s"",GetInterfaceInfo(confbuffer->IntfName));//inet_ntoa(GetInterfaceInfo(confbuffer->IntfName)));
		sprintf(SelfSharedInfo.IPaddress,""%s"",selfIP);
",1,unused,1852,unused,"	confbuffer = (CONFIG_DATA*)(readData + sizeof(CONFCOMMAND));  
	if(confbuffer)
	{
		sprintf(selfIP,""%s"",GetInterfaceInfo(confbuffer->IntfName));//inet_ntoa(GetInterfaceInfo(confbuffer->IntfName)));
		sprintf(SelfSharedInfo.IPaddress,""%s"",selfIP);
",unused,ssocopsacc_piranha-infoAgent.c
"	if(confbuffer)
	{
		sprintf(selfIP,""%s"",GetInterfaceInfo(confbuffer->IntfName));//inet_ntoa(GetInterfaceInfo(confbuffer->IntfName)));
		sprintf(SelfSharedInfo.IPaddress,""%s"",selfIP);
		sprintf(SelfSharedInfo.IntfName,""%s"",confbuffer->IntfName);
",1,unused,1853,unused,"	if(confbuffer)
	{
		sprintf(selfIP,""%s"",GetInterfaceInfo(confbuffer->IntfName));//inet_ntoa(GetInterfaceInfo(confbuffer->IntfName)));
		sprintf(SelfSharedInfo.IPaddress,""%s"",selfIP);
		sprintf(SelfSharedInfo.IntfName,""%s"",confbuffer->IntfName);
",unused,ssocopsacc_piranha-infoAgent.c
"	{
		sprintf(selfIP,""%s"",GetInterfaceInfo(confbuffer->IntfName));//inet_ntoa(GetInterfaceInfo(confbuffer->IntfName)));
		sprintf(SelfSharedInfo.IPaddress,""%s"",selfIP);
		sprintf(SelfSharedInfo.IntfName,""%s"",confbuffer->IntfName);
		sprintf(SelfSharedInfo.ActiveIPAddress,""%s"",confbuffer->ActivePrivateIP);
",1,unused,1854,unused,"	{
		sprintf(selfIP,""%s"",GetInterfaceInfo(confbuffer->IntfName));//inet_ntoa(GetInterfaceInfo(confbuffer->IntfName)));
		sprintf(SelfSharedInfo.IPaddress,""%s"",selfIP);
		sprintf(SelfSharedInfo.IntfName,""%s"",confbuffer->IntfName);
		sprintf(SelfSharedInfo.ActiveIPAddress,""%s"",confbuffer->ActivePrivateIP);
",unused,ssocopsacc_piranha-infoAgent.c
"		sprintf(selfIP,""%s"",GetInterfaceInfo(confbuffer->IntfName));//inet_ntoa(GetInterfaceInfo(confbuffer->IntfName)));
		sprintf(SelfSharedInfo.IPaddress,""%s"",selfIP);
		sprintf(SelfSharedInfo.IntfName,""%s"",confbuffer->IntfName);
		sprintf(SelfSharedInfo.ActiveIPAddress,""%s"",confbuffer->ActivePrivateIP);
		sprintf(SelfSharedInfo.BackupIPAddress,""%s"",confbuffer->BackupPrivateIP);
",1,unused,1855,unused,"		sprintf(selfIP,""%s"",GetInterfaceInfo(confbuffer->IntfName));//inet_ntoa(GetInterfaceInfo(confbuffer->IntfName)));
		sprintf(SelfSharedInfo.IPaddress,""%s"",selfIP);
		sprintf(SelfSharedInfo.IntfName,""%s"",confbuffer->IntfName);
		sprintf(SelfSharedInfo.ActiveIPAddress,""%s"",confbuffer->ActivePrivateIP);
		sprintf(SelfSharedInfo.BackupIPAddress,""%s"",confbuffer->BackupPrivateIP);
",unused,ssocopsacc_piranha-infoAgent.c
"		sprintf(SelfSharedInfo.IPaddress,""%s"",selfIP);
		sprintf(SelfSharedInfo.IntfName,""%s"",confbuffer->IntfName);
		sprintf(SelfSharedInfo.ActiveIPAddress,""%s"",confbuffer->ActivePrivateIP);
		sprintf(SelfSharedInfo.BackupIPAddress,""%s"",confbuffer->BackupPrivateIP);
		sprintf(SelfSharedInfo.VirtualIPAddress,""%s"",confbuffer->ClusterVirtualIP);
",1,unused,1856,unused,"		sprintf(SelfSharedInfo.IPaddress,""%s"",selfIP);
		sprintf(SelfSharedInfo.IntfName,""%s"",confbuffer->IntfName);
		sprintf(SelfSharedInfo.ActiveIPAddress,""%s"",confbuffer->ActivePrivateIP);
		sprintf(SelfSharedInfo.BackupIPAddress,""%s"",confbuffer->BackupPrivateIP);
		sprintf(SelfSharedInfo.VirtualIPAddress,""%s"",confbuffer->ClusterVirtualIP);
",unused,ssocopsacc_piranha-infoAgent.c
"		sprintf(SelfSharedInfo.IntfName,""%s"",confbuffer->IntfName);
		sprintf(SelfSharedInfo.ActiveIPAddress,""%s"",confbuffer->ActivePrivateIP);
		sprintf(SelfSharedInfo.BackupIPAddress,""%s"",confbuffer->BackupPrivateIP);
		sprintf(SelfSharedInfo.VirtualIPAddress,""%s"",confbuffer->ClusterVirtualIP);
		sprintf(SelfSharedInfo.RealServer,""%s"",confbuffer->RealServer);
",1,unused,1857,unused,"		sprintf(SelfSharedInfo.IntfName,""%s"",confbuffer->IntfName);
		sprintf(SelfSharedInfo.ActiveIPAddress,""%s"",confbuffer->ActivePrivateIP);
		sprintf(SelfSharedInfo.BackupIPAddress,""%s"",confbuffer->BackupPrivateIP);
		sprintf(SelfSharedInfo.VirtualIPAddress,""%s"",confbuffer->ClusterVirtualIP);
		sprintf(SelfSharedInfo.RealServer,""%s"",confbuffer->RealServer);
",unused,ssocopsacc_piranha-infoAgent.c
"	FILE* fp = NULL;
	char strfp[4] = {0};
	int st;

	sprintf(cmd,""/usr/sbin/ntpdate %s > /dev/null 2>&1; echo $?"",ntp);
",1,unused,1933,unused,"	FILE* fp = NULL;
	char strfp[4] = {0};
	int st;

	sprintf(cmd,""/usr/sbin/ntpdate %s > /dev/null 2>&1; echo $?"",ntp);
",unused,ssocopsacc_piranha-infoAgent.c
"					while(token)
					{
						if(strstr(token,""NTPSYNCINTERVAL=""))
						{
							strcpy(intval,token + strlen(""NTPSYNCINTERVAL=""));
",1,unused,2002,unused,"					while(token)
					{
						if(strstr(token,""NTPSYNCINTERVAL=""))
						{
							strcpy(intval,token + strlen(""NTPSYNCINTERVAL=""));
",unused,ssocopsacc_piranha-infoAgent.c
"						}

						if(strstr(token,""NTP1=""))
						{
							strcpy(ntp1,token + strlen(""NTP1=""));
",1,unused,2008,unused,"						}

						if(strstr(token,""NTP1=""))
						{
							strcpy(ntp1,token + strlen(""NTP1=""));
",unused,ssocopsacc_piranha-infoAgent.c
"						}

						if(strstr(token,""NTP2=""))
						{
							strcpy(ntp2,token + strlen(""NTP2=""));
",1,unused,2029,unused,"						}

						if(strstr(token,""NTP2=""))
						{
							strcpy(ntp2,token + strlen(""NTP2=""));
",unused,ssocopsacc_piranha-infoAgent.c
"
	CONFIG_DATA* confbuffer = (CONFIG_DATA*)(readData + sizeof(CONFCOMMAND));
	if(confbuffer)
	{
		sprintf(device, ""%s:1"", confbuffer->IntfName);
",1,unused,2102,unused,"
	CONFIG_DATA* confbuffer = (CONFIG_DATA*)(readData + sizeof(CONFCOMMAND));
	if(confbuffer)
	{
		sprintf(device, ""%s:1"", confbuffer->IntfName);
",unused,ssocopsacc_piranha-infoAgent.c
"		{	
			virtInterface = (char *)malloc(strlen(lserv->virtualDevice));
			if(virtInterface)
			{
				strcpy(virtInterface,lserv->virtualDevice);
",1,unused,2427,unused,"		{	
			virtInterface = (char *)malloc(strlen(lserv->virtualDevice));
			if(virtInterface)
			{
				strcpy(virtInterface,lserv->virtualDevice);
",unused,ssocopsacc_piranha-infoAgent.c
"	}

	ClusterInfo->num_realservers = lserv->numServers;

	sprintf(SelfInfo->IPaddress,""%s"",ClusterInfo->ActivePrivateIP);
",1,unused,2514,unused,"	}

	ClusterInfo->num_realservers = lserv->numServers;

	sprintf(SelfInfo->IPaddress,""%s"",ClusterInfo->ActivePrivateIP);
",unused,ssocopsacc_piranha-infoAgent.c
"
	ClusterInfo->num_realservers = lserv->numServers;

	sprintf(SelfInfo->IPaddress,""%s"",ClusterInfo->ActivePrivateIP);
	sprintf(SelfInfo->IntfName,""%s"",infName);
",1,unused,2515,unused,"
	ClusterInfo->num_realservers = lserv->numServers;

	sprintf(SelfInfo->IPaddress,""%s"",ClusterInfo->ActivePrivateIP);
	sprintf(SelfInfo->IntfName,""%s"",infName);
",unused,ssocopsacc_piranha-infoAgent.c
"	SelfInfo->type = ACTIVE_LOAD_BALANCER;
	actual_nodecount = lserv->numServers;
	debug_print(INFOAGENT_LOG_FILE,DEBUG_INFO,""Node count set as %d"",lserv->numServers);
	SelfInfo->num_realservers = lserv->numServers;
	strcpy(SelfInfo->ActiveIPAddress,ClusterInfo->ActivePrivateIP);  	
",1,unused,2520,unused,"	SelfInfo->type = ACTIVE_LOAD_BALANCER;
	actual_nodecount = lserv->numServers;
	debug_print(INFOAGENT_LOG_FILE,DEBUG_INFO,""Node count set as %d"",lserv->numServers);
	SelfInfo->num_realservers = lserv->numServers;
	strcpy(SelfInfo->ActiveIPAddress,ClusterInfo->ActivePrivateIP);  	
",unused,ssocopsacc_piranha-infoAgent.c
"	actual_nodecount = lserv->numServers;
	debug_print(INFOAGENT_LOG_FILE,DEBUG_INFO,""Node count set as %d"",lserv->numServers);
	SelfInfo->num_realservers = lserv->numServers;
	strcpy(SelfInfo->ActiveIPAddress,ClusterInfo->ActivePrivateIP);  	
	strcpy(SelfInfo->VirtualIPAddress,ClusterInfo->ClusterVirtualIP);
",1,unused,2521,unused,"	actual_nodecount = lserv->numServers;
	debug_print(INFOAGENT_LOG_FILE,DEBUG_INFO,""Node count set as %d"",lserv->numServers);
	SelfInfo->num_realservers = lserv->numServers;
	strcpy(SelfInfo->ActiveIPAddress,ClusterInfo->ActivePrivateIP);  	
	strcpy(SelfInfo->VirtualIPAddress,ClusterInfo->ClusterVirtualIP);
",unused,ssocopsacc_piranha-infoAgent.c
"	debug_print(INFOAGENT_LOG_FILE,DEBUG_INFO,""Node count set as %d"",lserv->numServers);
	SelfInfo->num_realservers = lserv->numServers;
	strcpy(SelfInfo->ActiveIPAddress,ClusterInfo->ActivePrivateIP);  	
	strcpy(SelfInfo->VirtualIPAddress,ClusterInfo->ClusterVirtualIP);
	strcpy(SelfInfo->BackupIPAddress,ClusterInfo->BackupPrivateIP);
",1,unused,2522,unused,"	debug_print(INFOAGENT_LOG_FILE,DEBUG_INFO,""Node count set as %d"",lserv->numServers);
	SelfInfo->num_realservers = lserv->numServers;
	strcpy(SelfInfo->ActiveIPAddress,ClusterInfo->ActivePrivateIP);  	
	strcpy(SelfInfo->VirtualIPAddress,ClusterInfo->ClusterVirtualIP);
	strcpy(SelfInfo->BackupIPAddress,ClusterInfo->BackupPrivateIP);
",unused,ssocopsacc_piranha-infoAgent.c
"	{
		ServerList = lserv->servers + j;
		tmpRealServerList[j].name = (char*)malloc(strlen(ServerList->name));
		if(tmpRealServerList[j].name)
			strcpy(tmpRealServerList[j].name, ServerList->name);
",1,unused,2542,unused,"	{
		ServerList = lserv->servers + j;
		tmpRealServerList[j].name = (char*)malloc(strlen(ServerList->name));
		if(tmpRealServerList[j].name)
			strcpy(tmpRealServerList[j].name, ServerList->name);
",unused,ssocopsacc_piranha-infoAgent.c
"		tmpRealServerList[j].port = ServerList->port;
		tmpRealServerList[j].weight = ServerList->weight;	
		debug_print(INFOAGENT_LOG_FILE,8,""ActiveLB: Real Server %d Details \n======================= \nName %s ,ISActive %d Port %d\n======================"",j,tmpRealServerList[j].name,tmpRealServerList[j].isActive,tmpRealServerList[j].port);

		strcat(messageBuffer,inet_ntoa(ServerList->address));
",1,unused,2550,unused,"		tmpRealServerList[j].port = ServerList->port;
		tmpRealServerList[j].weight = ServerList->weight;	
		debug_print(INFOAGENT_LOG_FILE,8,""ActiveLB: Real Server %d Details \n======================= \nName %s ,ISActive %d Port %d\n======================"",j,tmpRealServerList[j].name,tmpRealServerList[j].isActive,tmpRealServerList[j].port);

		strcat(messageBuffer,inet_ntoa(ServerList->address));
",unused,ssocopsacc_piranha-infoAgent.c
"		debug_print(INFOAGENT_LOG_FILE,8,""ActiveLB: Real Server %d Details \n======================= \nName %s ,ISActive %d Port %d\n======================"",j,tmpRealServerList[j].name,tmpRealServerList[j].isActive,tmpRealServerList[j].port);

		strcat(messageBuffer,inet_ntoa(ServerList->address));
		if(j != (lserv->numServers -1))
			strcat(messageBuffer,"","");
",1,unused,2552,unused,"		debug_print(INFOAGENT_LOG_FILE,8,""ActiveLB: Real Server %d Details \n======================= \nName %s ,ISActive %d Port %d\n======================"",j,tmpRealServerList[j].name,tmpRealServerList[j].isActive,tmpRealServerList[j].port);

		strcat(messageBuffer,inet_ntoa(ServerList->address));
		if(j != (lserv->numServers -1))
			strcat(messageBuffer,"","");
",unused,ssocopsacc_piranha-infoAgent.c
"					SetbackupNodeStatus(BACKUP_ACTIVE);
                                        backuplaststate = BACKUP_ACTIVE;
				}

				sprintf(tptr->current_time,""%u"",(unsigned)time(NULL));
",1,unused,3041,unused,"					SetbackupNodeStatus(BACKUP_ACTIVE);
                                        backuplaststate = BACKUP_ACTIVE;
				}

				sprintf(tptr->current_time,""%u"",(unsigned)time(NULL));
",unused,ssocopsacc_piranha-infoAgent.c
"                {
                        selfInformation = (REALSERVER*)pttr;
			if(selfInformation)
			{		
				strcpy(selfInformation->ActiveIPAddress, ClusterInfo->ActivePrivateIP);
",1,unused,3288,unused,"                {
                        selfInformation = (REALSERVER*)pttr;
			if(selfInformation)
			{		
				strcpy(selfInformation->ActiveIPAddress, ClusterInfo->ActivePrivateIP);
",unused,ssocopsacc_piranha-infoAgent.c
"                        selfInformation = (REALSERVER*)pttr;
			if(selfInformation)
			{		
				strcpy(selfInformation->ActiveIPAddress, ClusterInfo->ActivePrivateIP);
				strcpy(selfInformation->BackupIPAddress, ClusterInfo->BackupPrivateIP);
",1,unused,3289,unused,"                        selfInformation = (REALSERVER*)pttr;
			if(selfInformation)
			{		
				strcpy(selfInformation->ActiveIPAddress, ClusterInfo->ActivePrivateIP);
				strcpy(selfInformation->BackupIPAddress, ClusterInfo->BackupPrivateIP);
",unused,ssocopsacc_piranha-infoAgent.c
"			if(selfInformation)
			{		
				strcpy(selfInformation->ActiveIPAddress, ClusterInfo->ActivePrivateIP);
				strcpy(selfInformation->BackupIPAddress, ClusterInfo->BackupPrivateIP);
				strcpy(selfInformation->VirtualIPAddress, ClusterInfo->ClusterVirtualIP);
",1,unused,3290,unused,"			if(selfInformation)
			{		
				strcpy(selfInformation->ActiveIPAddress, ClusterInfo->ActivePrivateIP);
				strcpy(selfInformation->BackupIPAddress, ClusterInfo->BackupPrivateIP);
				strcpy(selfInformation->VirtualIPAddress, ClusterInfo->ClusterVirtualIP);
",unused,ssocopsacc_piranha-infoAgent.c
"		{
			selfInformation = (REALSERVER*)pttr;
			memset(selfInformation,'\0',sizeof(REALSERVER));
			
			strcpy(selfInformation->IntfName,SelfSharedInfo->IntfName);
",1,unused,3333,unused,"		{
			selfInformation = (REALSERVER*)pttr;
			memset(selfInformation,'\0',sizeof(REALSERVER));
			
			strcpy(selfInformation->IntfName,SelfSharedInfo->IntfName);
",unused,ssocopsacc_piranha-infoAgent.c
"			selfInformation = (REALSERVER*)pttr;
			memset(selfInformation,'\0',sizeof(REALSERVER));
			
			strcpy(selfInformation->IntfName,SelfSharedInfo->IntfName);
			strcpy(selfInformation->IPaddress,SelfSharedInfo->IPaddress);
",1,unused,3334,unused,"			selfInformation = (REALSERVER*)pttr;
			memset(selfInformation,'\0',sizeof(REALSERVER));
			
			strcpy(selfInformation->IntfName,SelfSharedInfo->IntfName);
			strcpy(selfInformation->IPaddress,SelfSharedInfo->IPaddress);
",unused,ssocopsacc_piranha-infoAgent.c
"			memset(selfInformation,'\0',sizeof(REALSERVER));
			
			strcpy(selfInformation->IntfName,SelfSharedInfo->IntfName);
			strcpy(selfInformation->IPaddress,SelfSharedInfo->IPaddress);
			strcpy(selfInformation->ActiveIPAddress,SelfSharedInfo->ActiveIPAddress);
",1,unused,3335,unused,"			memset(selfInformation,'\0',sizeof(REALSERVER));
			
			strcpy(selfInformation->IntfName,SelfSharedInfo->IntfName);
			strcpy(selfInformation->IPaddress,SelfSharedInfo->IPaddress);
			strcpy(selfInformation->ActiveIPAddress,SelfSharedInfo->ActiveIPAddress);
",unused,ssocopsacc_piranha-infoAgent.c
"			
			strcpy(selfInformation->IntfName,SelfSharedInfo->IntfName);
			strcpy(selfInformation->IPaddress,SelfSharedInfo->IPaddress);
			strcpy(selfInformation->ActiveIPAddress,SelfSharedInfo->ActiveIPAddress);
			strcpy(selfInformation->BackupIPAddress,SelfSharedInfo->BackupIPAddress);
",1,unused,3336,unused,"			
			strcpy(selfInformation->IntfName,SelfSharedInfo->IntfName);
			strcpy(selfInformation->IPaddress,SelfSharedInfo->IPaddress);
			strcpy(selfInformation->ActiveIPAddress,SelfSharedInfo->ActiveIPAddress);
			strcpy(selfInformation->BackupIPAddress,SelfSharedInfo->BackupIPAddress);
",unused,ssocopsacc_piranha-infoAgent.c
"			strcpy(selfInformation->IntfName,SelfSharedInfo->IntfName);
			strcpy(selfInformation->IPaddress,SelfSharedInfo->IPaddress);
			strcpy(selfInformation->ActiveIPAddress,SelfSharedInfo->ActiveIPAddress);
			strcpy(selfInformation->BackupIPAddress,SelfSharedInfo->BackupIPAddress);
			strcpy(selfInformation->VirtualIPAddress,SelfSharedInfo->VirtualIPAddress);
",1,unused,3337,unused,"			strcpy(selfInformation->IntfName,SelfSharedInfo->IntfName);
			strcpy(selfInformation->IPaddress,SelfSharedInfo->IPaddress);
			strcpy(selfInformation->ActiveIPAddress,SelfSharedInfo->ActiveIPAddress);
			strcpy(selfInformation->BackupIPAddress,SelfSharedInfo->BackupIPAddress);
			strcpy(selfInformation->VirtualIPAddress,SelfSharedInfo->VirtualIPAddress);
",unused,ssocopsacc_piranha-infoAgent.c
"	int ppid = getppid();
	int pid = getpid();
	/*syntax is PARENT_ID=&CHILD_ID=*/
	debug_print(INFOAGENT_LOG_FILE,8,""Parent PID %d Child PID %d"",ppid,pid);
	sprintf(command,""echo \""PARENT_ID=%d&CHILD_ID=%d\"" > %s"",ppid,pid,INFOAGENT_PID_FILE);
",1,unused,3552,unused,"	int ppid = getppid();
	int pid = getpid();
	/*syntax is PARENT_ID=&CHILD_ID=*/
	debug_print(INFOAGENT_LOG_FILE,8,""Parent PID %d Child PID %d"",ppid,pid);
	sprintf(command,""echo \""PARENT_ID=%d&CHILD_ID=%d\"" > %s"",ppid,pid,INFOAGENT_PID_FILE);
",unused,ssocopsacc_piranha-infoAgent.c
"			filename[nSize] = 0;
			debug_print(INFOAGENT_LOG_FILE,8,""filename read as %s"",filename);
			char *ptr = strstr(filename,""zoneinfo"");
                        if(ptr)
                                strcpy(zonename,ptr + strlen(""zoneinfo/""));
",1,unused,3588,unused,"			filename[nSize] = 0;
			debug_print(INFOAGENT_LOG_FILE,8,""filename read as %s"",filename);
			char *ptr = strstr(filename,""zoneinfo"");
                        if(ptr)
                                strcpy(zonename,ptr + strlen(""zoneinfo/""));
",unused,ssocopsacc_piranha-infoAgent.c
"			char *ptr = strstr(filename,""zoneinfo"");
                        if(ptr)
                                strcpy(zonename,ptr + strlen(""zoneinfo/""));
                        else
				strcpy(zonename,filename+strlen(""../usr/share/zoneinfo/""));
",1,unused,3590,unused,"			char *ptr = strstr(filename,""zoneinfo"");
                        if(ptr)
                                strcpy(zonename,ptr + strlen(""zoneinfo/""));
                        else
				strcpy(zonename,filename+strlen(""../usr/share/zoneinfo/""));
",unused,ssocopsacc_piranha-infoAgent.c
"		time_t t = time(NULL);
		struct tm lt = {0};

		localtime_r(&t, &lt);	
		strcpy(zonename,lt.tm_zone);		
",1,unused,3600,unused,"		time_t t = time(NULL);
		struct tm lt = {0};

		localtime_r(&t, &lt);	
		strcpy(zonename,lt.tm_zone);		
",unused,ssocopsacc_piranha-infoAgent.c
" *  *          * If an error occurs, abort with exit status.. say, 125. */
        if(redirect(STDIN_FILENO,  ""/dev/null"", O_RDONLY))
        {
                char msg[256] = {0};
                sprintf(msg,""redirect of STDIN to /dev/null failed with error %s."",strerror(errno));
",1,unused,3699,unused," *  *          * If an error occurs, abort with exit status.. say, 125. */
        if(redirect(STDIN_FILENO,  ""/dev/null"", O_RDONLY))
        {
                char msg[256] = {0};
                sprintf(msg,""redirect of STDIN to /dev/null failed with error %s."",strerror(errno));
",unused,ssocopsacc_piranha-infoAgent.c
"
        if(redirect(STDOUT_FILENO, ""/dev/null"", O_WRONLY))
        {
                char msg[256] = {0};
                sprintf(msg,""redirect of STDIN to /dev/null failed with error %s."",strerror(errno));
",1,unused,3707,unused,"
        if(redirect(STDOUT_FILENO, ""/dev/null"", O_WRONLY))
        {
                char msg[256] = {0};
                sprintf(msg,""redirect of STDIN to /dev/null failed with error %s."",strerror(errno));
",unused,ssocopsacc_piranha-infoAgent.c
"
        if(redirect(STDERR_FILENO, ""/dev/null"", O_WRONLY))
        {
                char msg[256] = {0};
                sprintf(msg,""redirect of STDIN to /dev/null failed with error %s."",strerror(errno));
",1,unused,3715,unused,"
        if(redirect(STDERR_FILENO, ""/dev/null"", O_WRONLY))
        {
                char msg[256] = {0};
                sprintf(msg,""redirect of STDIN to /dev/null failed with error %s."",strerror(errno));
",unused,ssocopsacc_piranha-infoAgent.c
"		*argp++ = ipvsadm;
		*argp++ = (char *) ""-d"";

		if (fwmark) {
			sprintf (fwmStr, ""%d"", fwmark);
",1,unused,100,unused,"		*argp++ = ipvsadm;
		*argp++ = (char *) ""-d"";

		if (fwmark) {
			sprintf (fwmStr, ""%d"", fwmark);
",unused,ssocopsacc_piranha-ipvs_exec.c
"			sprintf (fwmStr, ""%d"", fwmark);
			*argp++ = (char *) ""-f"";
			*argp++ = fwmStr;
		} else {
			sprintf (virtName, ""%s:%d"", virtualAddress, port);
",1,unused,104,unused,"			sprintf (fwmStr, ""%d"", fwmark);
			*argp++ = (char *) ""-f"";
			*argp++ = fwmStr;
		} else {
			sprintf (virtName, ""%s:%d"", virtualAddress, port);
",unused,ssocopsacc_piranha-ipvs_exec.c
"			*argp++ = virtName;
		}

		*argp++ = (char *) ""-r"";
		sprintf (remoteName, ""%s:%d"", inet_ntoa (*remoteAddr), rport);
",1,unused,113,unused,"			*argp++ = virtName;
		}

		*argp++ = (char *) ""-r"";
		sprintf (remoteName, ""%s:%d"", inet_ntoa (*remoteAddr), rport);
",unused,ssocopsacc_piranha-ipvs_exec.c
"	char remoteName[80];
	char weightStr[20];
	char fwmStr[20];

	sprintf (weightStr, ""%d"", weight);
",1,unused,136,unused,"	char remoteName[80];
	char weightStr[20];
	char fwmStr[20];

	sprintf (weightStr, ""%d"", weight);
",unused,ssocopsacc_piranha-ipvs_exec.c
"	*argp++ = ipvsadm;
	*argp++ = (char *) ""-e"";

	if (fwmark) {
		sprintf (fwmStr, ""%d"", fwmark);
",1,unused,142,unused,"	*argp++ = ipvsadm;
	*argp++ = (char *) ""-e"";

	if (fwmark) {
		sprintf (fwmStr, ""%d"", fwmark);
",unused,ssocopsacc_piranha-ipvs_exec.c
"		sprintf (fwmStr, ""%d"", fwmark);
		*argp++ = (char *) ""-f"";
		*argp++ = fwmStr;
	} else {
		sprintf (virtName, ""%s:%d"", virtualAddress, port);
",1,unused,146,unused,"		sprintf (fwmStr, ""%d"", fwmark);
		*argp++ = (char *) ""-f"";
		*argp++ = fwmStr;
	} else {
		sprintf (virtName, ""%s:%d"", virtualAddress, port);
",unused,ssocopsacc_piranha-ipvs_exec.c
"		*argp++ = virtName;
	}

	*argp++ = (char *) ""-r"";
	sprintf (remoteName, ""%s:%d"", inet_ntoa (*remoteAddr), rport);
",1,unused,155,unused,"		*argp++ = virtName;
	}

	*argp++ = (char *) ""-r"";
	sprintf (remoteName, ""%s:%d"", inet_ntoa (*remoteAddr), rport);
",unused,ssocopsacc_piranha-ipvs_exec.c
"
	if (service_type == SERV_LVS) {
		/* Virtual Server */

		sprintf (weightStr, ""%d"", weight);
",1,unused,182,unused,"
	if (service_type == SERV_LVS) {
		/* Virtual Server */

		sprintf (weightStr, ""%d"", weight);
",unused,ssocopsacc_piranha-ipvs_exec.c
"		*argp++ = ipvsadm;
		*argp++ = (char *) ""-a"";

		if (fwmark) {
			sprintf (fwmStr, ""%d"", fwmark);
",1,unused,188,unused,"		*argp++ = ipvsadm;
		*argp++ = (char *) ""-a"";

		if (fwmark) {
			sprintf (fwmStr, ""%d"", fwmark);
",unused,ssocopsacc_piranha-ipvs_exec.c
"			sprintf (fwmStr, ""%d"", fwmark);
			*argp++ = (char *) ""-f"";
			*argp++ = fwmStr;
		} else {
			sprintf (virtName, ""%s:%d"", virtualAddress, port);
",1,unused,192,unused,"			sprintf (fwmStr, ""%d"", fwmark);
			*argp++ = (char *) ""-f"";
			*argp++ = fwmStr;
		} else {
			sprintf (virtName, ""%s:%d"", virtualAddress, port);
",unused,ssocopsacc_piranha-ipvs_exec.c
"			*argp++ = virtName;
		}

		*argp++ = (char *) ""-r"";
		sprintf (remoteName, ""%s:%d"", inet_ntoa (*remoteAddr), rport);
",1,unused,201,unused,"			*argp++ = virtName;
		}

		*argp++ = (char *) ""-r"";
		sprintf (remoteName, ""%s:%d"", inet_ntoa (*remoteAddr), rport);
",unused,ssocopsacc_piranha-ipvs_exec.c
"		/*
		 * Ignore channel-bonded slave interfaces.
		 */
		memset(&flags, 0, sizeof (flags));
		strcpy(flags.ifr_name, ifr->ifr_name);
",1,unused,116,unused,"		/*
		 * Ignore channel-bonded slave interfaces.
		 */
		memset(&flags, 0, sizeof (flags));
		strcpy(flags.ifr_name, ifr->ifr_name);
",unused,ssocopsacc_piranha-linkstate.c
"{

	char val[50];

	sprintf (val, ""%d"", newValue);
",1,unused,723,unused,"{

	char val[50];

	sprintf (val, ""%d"", newValue);
",unused,ssocopsacc_piranha-lvsconfig.c
"			CHECK_ARGS (1) free (vserver->send_program);
			if (toks.quoteType[2])
			{
				vserver->send_program = malloc (strlen (toks.argv[2]) + 3);
				(void) sprintf (vserver->send_program, ""%c%s%c"",
",1,unused,1225,unused,"			CHECK_ARGS (1) free (vserver->send_program);
			if (toks.quoteType[2])
			{
				vserver->send_program = malloc (strlen (toks.argv[2]) + 3);
				(void) sprintf (vserver->send_program, ""%c%s%c"",
",unused,ssocopsacc_piranha-lvsconfig.c
"			CHECK_ARGS (1) free (vserver->send_str);
			if (toks.quoteType[2])
			{
				vserver->send_str = malloc (strlen (toks.argv[2]) + 3);
				(void) sprintf (vserver->send_str, ""%c%s%c"",
",1,unused,1240,unused,"			CHECK_ARGS (1) free (vserver->send_str);
			if (toks.quoteType[2])
			{
				vserver->send_str = malloc (strlen (toks.argv[2]) + 3);
				(void) sprintf (vserver->send_str, ""%c%s%c"",
",unused,ssocopsacc_piranha-lvsconfig.c
"			CHECK_ARGS (1) free (vserver->expect_str);
			if (toks.quoteType[2])
			{
				vserver->expect_str = malloc (strlen (toks.argv[2]) + 3);
				(void) sprintf (vserver->expect_str, ""%c%s%c"",
",1,unused,1255,unused,"			CHECK_ARGS (1) free (vserver->expect_str);
			if (toks.quoteType[2])
			{
				vserver->expect_str = malloc (strlen (toks.argv[2]) + 3);
				(void) sprintf (vserver->expect_str, ""%c%s%c"",
",unused,ssocopsacc_piranha-lvsconfig.c
"			CHECK_ARGS (1) free (vserver->start_cmd);
			if (toks.quoteType[2])
			{
				vserver->start_cmd = malloc (strlen (toks.argv[2]) + 3);
				(void) sprintf (vserver->start_cmd, ""%c%s%c"",
",1,unused,1305,unused,"			CHECK_ARGS (1) free (vserver->start_cmd);
			if (toks.quoteType[2])
			{
				vserver->start_cmd = malloc (strlen (toks.argv[2]) + 3);
				(void) sprintf (vserver->start_cmd, ""%c%s%c"",
",unused,ssocopsacc_piranha-lvsconfig.c
"			CHECK_ARGS (1) free (vserver->stop_cmd);
			if (toks.quoteType[2])
			{
				vserver->stop_cmd = malloc (strlen (toks.argv[2]) + 3);
				(void) sprintf (vserver->stop_cmd, ""%c%s%c"",
",1,unused,1320,unused,"			CHECK_ARGS (1) free (vserver->stop_cmd);
			if (toks.quoteType[2])
			{
				vserver->stop_cmd = malloc (strlen (toks.argv[2]) + 3);
				(void) sprintf (vserver->stop_cmd, ""%c%s%c"",
",unused,ssocopsacc_piranha-lvsconfig.c
"
  virtAddress = strdup (inet_ntoa (vserver->virtualAddress));
  realAddress = strdup (inet_ntoa (service->address));

  sprintf (portNum, ""%d"", vserver->port);
",1,unused,382,unused,"
  virtAddress = strdup (inet_ntoa (vserver->virtualAddress));
  realAddress = strdup (inet_ntoa (service->address));

  sprintf (portNum, ""%d"", vserver->port);
",unused,ssocopsacc_piranha-lvsd.c
"  virtAddress = strdup (inet_ntoa (vserver->virtualAddress));
  realAddress = strdup (inet_ntoa (service->address));

  sprintf (portNum, ""%d"", vserver->port);
  sprintf (rportNum, ""%d"", service->port);
",1,unused,383,unused,"  virtAddress = strdup (inet_ntoa (vserver->virtualAddress));
  realAddress = strdup (inet_ntoa (service->address));

  sprintf (portNum, ""%d"", vserver->port);
  sprintf (rportNum, ""%d"", service->port);
",unused,ssocopsacc_piranha-lvsd.c
"  realAddress = strdup (inet_ntoa (service->address));

  sprintf (portNum, ""%d"", vserver->port);
  sprintf (rportNum, ""%d"", service->port);
  sprintf (timeoutNum, ""%d"", vserver->timeout);
",1,unused,384,unused,"  realAddress = strdup (inet_ntoa (service->address));

  sprintf (portNum, ""%d"", vserver->port);
  sprintf (rportNum, ""%d"", service->port);
  sprintf (timeoutNum, ""%d"", vserver->timeout);
",unused,ssocopsacc_piranha-lvsd.c
"
  sprintf (portNum, ""%d"", vserver->port);
  sprintf (rportNum, ""%d"", service->port);
  sprintf (timeoutNum, ""%d"", vserver->timeout);
  sprintf (weightNum, ""%d"", service->weight);
",1,unused,385,unused,"
  sprintf (portNum, ""%d"", vserver->port);
  sprintf (rportNum, ""%d"", service->port);
  sprintf (timeoutNum, ""%d"", vserver->timeout);
  sprintf (weightNum, ""%d"", service->weight);
",unused,ssocopsacc_piranha-lvsd.c
"  sprintf (portNum, ""%d"", vserver->port);
  sprintf (rportNum, ""%d"", service->port);
  sprintf (timeoutNum, ""%d"", vserver->timeout);
  sprintf (weightNum, ""%d"", service->weight);
  sprintf (reentryNum, ""%d"", vserver->reentryTime);
",1,unused,386,unused,"  sprintf (portNum, ""%d"", vserver->port);
  sprintf (rportNum, ""%d"", service->port);
  sprintf (timeoutNum, ""%d"", vserver->timeout);
  sprintf (weightNum, ""%d"", service->weight);
  sprintf (reentryNum, ""%d"", vserver->reentryTime);
",unused,ssocopsacc_piranha-lvsd.c
"  *arg++ = rportNum;

  if (vserver->fwmark)
    {
      sprintf (fwmNum, ""%d"", vserver->fwmark);
",1,unused,399,unused,"  *arg++ = rportNum;

  if (vserver->fwmark)
    {
      sprintf (fwmNum, ""%d"", vserver->fwmark);
",unused,ssocopsacc_piranha-lvsd.c
"
  if (vserver->fwmark)
    {
      *arg++ = (char *) ""-f"";
      (void) sprintf (fwmNum, ""%d"", vserver->fwmark);
",1,unused,629,unused,"
  if (vserver->fwmark)
    {
      *arg++ = (char *) ""-f"";
      (void) sprintf (fwmNum, ""%d"", vserver->fwmark);
",unused,ssocopsacc_piranha-lvsd.c
"	default:
	  *arg++ = (char *) ""-t"";
	  break;
	}
      sprintf (virtAddress, ""%s:%d"", inet_ntoa (vserver->virtualAddress),
",1,unused,645,unused,"	default:
	  *arg++ = (char *) ""-t"";
	  break;
	}
      sprintf (virtAddress, ""%s:%d"", inet_ntoa (vserver->virtualAddress),
",unused,ssocopsacc_piranha-lvsd.c
"
  if (vserver->fwmark)
    {
      *arg++ = (char *) ""-f"";
      (void) sprintf (fwmNum, ""%d"", vserver->fwmark);
",1,unused,699,unused,"
  if (vserver->fwmark)
    {
      *arg++ = (char *) ""-f"";
      (void) sprintf (fwmNum, ""%d"", vserver->fwmark);
",unused,ssocopsacc_piranha-lvsd.c
"	default:
	  *arg++ = (char *) ""-t"";
	  break;
	}
      sprintf (virtAddress, ""%s:%d"", inet_ntoa (vserver->virtualAddress),
",1,unused,715,unused,"	default:
	  *arg++ = (char *) ""-t"";
	  break;
	}
      sprintf (virtAddress, ""%s:%d"", inet_ntoa (vserver->virtualAddress),
",unused,ssocopsacc_piranha-lvsd.c
"
  if (vserver->persistent > 0)
    {
      *arg++ = (char *) ""-p"";
      (void) sprintf (wrkBuf, ""%d"", vserver->persistent);
",1,unused,764,unused,"
  if (vserver->persistent > 0)
    {
      *arg++ = (char *) ""-p"";
      (void) sprintf (wrkBuf, ""%d"", vserver->persistent);
",unused,ssocopsacc_piranha-lvsd.c
"  char tcpTimeout[20];
  char tcpfinTimeout[20];
  char udpTimeout[20];

  sprintf (tcpTimeout, ""%d"", config->tcpTimeout);
",1,unused,924,unused,"  char tcpTimeout[20];
  char tcpfinTimeout[20];
  char udpTimeout[20];

  sprintf (tcpTimeout, ""%d"", config->tcpTimeout);
",unused,ssocopsacc_piranha-lvsd.c
"  char tcpfinTimeout[20];
  char udpTimeout[20];

  sprintf (tcpTimeout, ""%d"", config->tcpTimeout);
  sprintf (tcpfinTimeout, ""%d"", config->tcpfinTimeout);
",1,unused,925,unused,"  char tcpfinTimeout[20];
  char udpTimeout[20];

  sprintf (tcpTimeout, ""%d"", config->tcpTimeout);
  sprintf (tcpfinTimeout, ""%d"", config->tcpfinTimeout);
",unused,ssocopsacc_piranha-lvsd.c
"  char udpTimeout[20];

  sprintf (tcpTimeout, ""%d"", config->tcpTimeout);
  sprintf (tcpfinTimeout, ""%d"", config->tcpfinTimeout);
  sprintf (udpTimeout, ""%d"", config->udpTimeout);
",1,unused,926,unused,"  char udpTimeout[20];

  sprintf (tcpTimeout, ""%d"", config->tcpTimeout);
  sprintf (tcpfinTimeout, ""%d"", config->tcpfinTimeout);
  sprintf (udpTimeout, ""%d"", config->udpTimeout);
",unused,ssocopsacc_piranha-lvsd.c
"	char **argp = argv;
	int i = 0, res;

	if (send_program != NULL)
		strcpy (temp, send_program);
",1,unused,830,unused,"	char **argp = argv;
	int i = 0, res;

	if (send_program != NULL)
		strcpy (temp, send_program);
",unused,ssocopsacc_piranha-nanny.c
"		i++;
		if (strcmp (token, ""%h"") == 0)
			token = inet_ntoa (*remoteAddr);
		else if (strcmp (token, ""%p"") == 0) {
			sprintf (tokenTemp, ""%d"", rport);
",1,unused,844,unused,"		i++;
		if (strcmp (token, ""%h"") == 0)
			token = inet_ntoa (*remoteAddr);
		else if (strcmp (token, ""%p"") == 0) {
			sprintf (tokenTemp, ""%d"", rport);
",unused,ssocopsacc_piranha-nanny.c
"			}
			if (do_copy) {
				if (*cur_ptr) {
					dup_string = strdup (cur_ptr);
					strcpy (cur_ptr, (dup_string + 1));
",1,unused,1474,unused,"			}
			if (do_copy) {
				if (*cur_ptr) {
					dup_string = strdup (cur_ptr);
					strcpy (cur_ptr, (dup_string + 1));
",unused,ssocopsacc_piranha-nanny.c
"{
	struct ifreq req;
	struct sockaddr_in *addrp;

	strcpy (req.ifr_name, device);
",1,unused,300,unused,"{
	struct ifreq req;
	struct sockaddr_in *addrp;

	strcpy (req.ifr_name, device);
",unused,ssocopsacc_piranha-pulse.c
"
	struct ifreq req;
	struct sockaddr_in *addrp;

	strcpy(req.ifr_name, device);
",1,unused,333,unused,"
	struct ifreq req;
	struct sockaddr_in *addrp;

	strcpy(req.ifr_name, device);
",unused,ssocopsacc_piranha-pulse.c
"			piranha_log (flags, (char *)
					""DEBUG -- Executing '/sbin/ifconfig %s %s netmask %s up'"",
					device, floatAddr, netmask);
					
		sprintf(command,""/sbin/ifconfig %s %s netmask %s broadcast %s up"",device, floatAddr, netmask, inet_ntoa (bcast));
",1,unused,499,unused,"			piranha_log (flags, (char *)
					""DEBUG -- Executing '/sbin/ifconfig %s %s netmask %s up'"",
					device, floatAddr, netmask);
					
		sprintf(command,""/sbin/ifconfig %s %s netmask %s broadcast %s up"",device, floatAddr, netmask, inet_ntoa (bcast));
",unused,ssocopsacc_piranha-pulse.c
"		logArgv(flags, ifconfigArgs);

		if(pulse_debug)
			piranha_log (flags, (char *)""DEBUG -- Executing '/sbin/ifconfig %s %s up'"",device, floatAddr);
		sprintf(command,""/sbin/ifconfig %s %s up"",device, floatAddr);
",1,unused,512,unused,"		logArgv(flags, ifconfigArgs);

		if(pulse_debug)
			piranha_log (flags, (char *)""DEBUG -- Executing '/sbin/ifconfig %s %s up'"",device, floatAddr);
		sprintf(command,""/sbin/ifconfig %s %s up"",device, floatAddr);
",unused,ssocopsacc_piranha-pulse.c
"	close(s);

	for(i = 0; i < 6; i++)
	{
		sprintf(hwname + (i * 2), ""%02X"", ((unsigned int) hwaddr[i]) & 0xFF);
",1,unused,542,unused,"	close(s);

	for(i = 0; i < 6; i++)
	{
		sprintf(hwname + (i * 2), ""%02X"", ((unsigned int) hwaddr[i]) & 0xFF);
",unused,ssocopsacc_piranha-pulse.c
"	}

	waitpid (child, NULL, 0);

	sprintf (id, ""%d"", (config->syncdID & 0xff));
",1,unused,624,unused,"	}

	waitpid (child, NULL, 0);

	sprintf (id, ""%d"", (config->syncdID & 0xff));
",unused,ssocopsacc_piranha-pulse.c
"	if(*flags & PULSE_FLAG_AMMASTER)
	{
		debug_print(PULSE_LOG_FILE,8,""[%s] Checking link status in case of master node for addresses [%s] and [%s]."",
			(*flags & PULSE_FLAG_AMACTIVE)?""Active"":""Inactive"",inet_ntoa(config->primaryServer),inet_ntoa(config->primaryPrivate));
		strcpy(addrtomatch,inet_ntoa(config->primaryServer));
",1,unused,1051,unused,"	if(*flags & PULSE_FLAG_AMMASTER)
	{
		debug_print(PULSE_LOG_FILE,8,""[%s] Checking link status in case of master node for addresses [%s] and [%s]."",
			(*flags & PULSE_FLAG_AMACTIVE)?""Active"":""Inactive"",inet_ntoa(config->primaryServer),inet_ntoa(config->primaryPrivate));
		strcpy(addrtomatch,inet_ntoa(config->primaryServer));
",unused,ssocopsacc_piranha-pulse.c
"	{
		debug_print(PULSE_LOG_FILE,8,""[%s] Checking link status in case of backup node for addresses [%s] and [%s]."",
			(*flags & PULSE_FLAG_AMACTIVE)?""Active"":""Inactive"",inet_ntoa(config->backupServer),inet_ntoa(config->backupPrivate));

		strcpy(addrtomatch,inet_ntoa(config->backupServer));
",1,unused,1058,unused,"	{
		debug_print(PULSE_LOG_FILE,8,""[%s] Checking link status in case of backup node for addresses [%s] and [%s]."",
			(*flags & PULSE_FLAG_AMACTIVE)?""Active"":""Inactive"",inet_ntoa(config->backupServer),inet_ntoa(config->backupPrivate));

		strcpy(addrtomatch,inet_ntoa(config->backupServer));
",unused,ssocopsacc_piranha-pulse.c
"					  }*/

					if(strstr(token,""NTPSYNCINTERVAL=""))
					{
						strcpy(intval,token + strlen(""NTPSYNCINTERVAL=""));
",1,unused,1562,unused,"					  }*/

					if(strstr(token,""NTPSYNCINTERVAL=""))
					{
						strcpy(intval,token + strlen(""NTPSYNCINTERVAL=""));
",unused,ssocopsacc_piranha-pulse.c
"					}

					if(strstr(token,""NTP1=""))
					{	
						strcpy(ntp1,token + strlen(""NTP1=""));
",1,unused,1568,unused,"					}

					if(strstr(token,""NTP1=""))
					{	
						strcpy(ntp1,token + strlen(""NTP1=""));
",unused,ssocopsacc_piranha-pulse.c
"					}

					if(strstr(token,""NTP2=""))
					{
						strcpy(ntp2,token + strlen(""NTP2=""));
",1,unused,1586,unused,"					}

					if(strstr(token,""NTP2=""))
					{
						strcpy(ntp2,token + strlen(""NTP2=""));
",unused,ssocopsacc_piranha-pulse.c
"
			if(fds_to_process < 0)
			{
				char msg[1024] = {0};
				sprintf(msg,""Pulse is exiting on select failure, error is %s"",strerror(errno));
",1,unused,1912,unused,"
			if(fds_to_process < 0)
			{
				char msg[1024] = {0};
				sprintf(msg,""Pulse is exiting on select failure, error is %s"",strerror(errno));
",unused,ssocopsacc_piranha-pulse.c
"int get_process_name(const pid_t pid, char* name) 
{
	char procfile[1024] = {0};
	
	sprintf(procfile, ""/proc/%d/cmdline"", pid);
",1,unused,2232,unused,"int get_process_name(const pid_t pid, char* name) 
{
	char procfile[1024] = {0};
	
	sprintf(procfile, ""/proc/%d/cmdline"", pid);
",unused,ssocopsacc_piranha-pulse.c
"	{
		if(get_process_name(myppid, parentname))
		{
			char log[512] = {0};
			sprintf(log, ""pulse parent process name %s"", parentname);
",1,unused,2263,unused,"	{
		if(get_process_name(myppid, parentname))
		{
			char log[512] = {0};
			sprintf(log, ""pulse parent process name %s"", parentname);
",unused,ssocopsacc_piranha-pulse.c
"  memcpy (pkt.rcpt_ip_addr, &targ_in_addr, IP_ADDR_LEN);

  bzero (pkt.padding, 18);

  strcpy (sa.sa_data, device);
",1,unused,133,unused,"  memcpy (pkt.rcpt_ip_addr, &targ_in_addr, IP_ADDR_LEN);

  bzero (pkt.padding, 18);

  strcpy (sa.sa_data, device);
",unused,ssocopsacc_piranha-send_arp.c
"    }

  if (!(flags & LVS_FLAG_NOPIDFILE))
    {
      sprintf (pidFile, ""/var/run/%s.pid"", name);
",1,unused,125,unused,"    }

  if (!(flags & LVS_FLAG_NOPIDFILE))
    {
      sprintf (pidFile, ""/var/run/%s.pid"", name);
",unused,ssocopsacc_piranha-util.c
"  *argList = '\0';

  for (i = 0; argv[i]; i++)
    {
      strcat (argList, "" \"""");
",1,unused,168,unused,"  *argList = '\0';

  for (i = 0; argv[i]; i++)
    {
      strcat (argList, "" \"""");
",unused,ssocopsacc_piranha-util.c
"
  for (i = 0; argv[i]; i++)
    {
      strcat (argList, "" \"""");
      strcat (argList, argv[i]);
",1,unused,169,unused,"
  for (i = 0; argv[i]; i++)
    {
      strcat (argList, "" \"""");
      strcat (argList, argv[i]);
",unused,ssocopsacc_piranha-util.c
"  for (i = 0; argv[i]; i++)
    {
      strcat (argList, "" \"""");
      strcat (argList, argv[i]);
      strcat (argList, ""\"""");
",1,unused,170,unused,"  for (i = 0; argv[i]; i++)
    {
      strcat (argList, "" \"""");
      strcat (argList, argv[i]);
      strcat (argList, ""\"""");
",unused,ssocopsacc_piranha-util.c
"			for (x_ptr = ptr, x_len = attrlen ;
				x_len > 0 ;
				x_len--, x_ptr++)
			{
				sprintf (hex, ""%2.2X"", *x_ptr);
",1,unused,190,unused,"			for (x_ptr = ptr, x_len = attrlen ;
				x_len > 0 ;
				x_len--, x_ptr++)
			{
				sprintf (hex, ""%2.2X"", *x_ptr);
",unused,ssocopsacc_radiusclient-lib2Favpair.c
"				x_len > 0 ;
				x_len--, x_ptr++)
			{
				sprintf (hex, ""%2.2X"", *x_ptr);
				strcat (buffer, hex);
",1,unused,191,unused,"				x_len > 0 ;
				x_len--, x_ptr++)
			{
				sprintf (hex, ""%2.2X"", *x_ptr);
				strcat (buffer, hex);
",unused,ssocopsacc_radiusclient-lib2Favpair.c
"				rc_log(LOG_CRIT, ""rc_avpair_gen: out of memory"");
				rc_avpair_free(vp);
				return NULL;
			}
			strcpy (pair->name, attr->name);
",1,unused,206,unused,"				rc_log(LOG_CRIT, ""rc_avpair_gen: out of memory"");
				rc_avpair_free(vp);
				return NULL;
			}
			strcpy (pair->name, attr->name);
",unused,ssocopsacc_radiusclient-lib2Favpair.c
"					*first_pair = (VALUE_PAIR *) NULL;
				}
				return (-1);
			}
			strcpy (pair->name, attr->name);
",1,unused,460,unused,"					*first_pair = (VALUE_PAIR *) NULL;
				}
				return (-1);
			}
			strcpy (pair->name, attr->name);
",unused,ssocopsacc_radiusclient-lib2Favpair.c
"			switch (pair->type)
			{

			    case PW_TYPE_STRING:
				strcpy (pair->strvalue, valstr);
",1,unused,468,unused,"			switch (pair->type)
			{

			    case PW_TYPE_STRING:
				strcpy (pair->strvalue, valstr);
",unused,ssocopsacc_radiusclient-lib2Favpair.c
"		while (*ptr != '\0')
		{
			if (!(isprint (*ptr)))
			{
				sprintf (buffer, ""\\%03o"", *ptr);
",1,unused,585,unused,"		while (*ptr != '\0')
		{
			if (!(isprint (*ptr)))
			{
				sprintf (buffer, ""\\%03o"", *ptr);
",unused,ssocopsacc_radiusclient-lib2Favpair.c
"			strncpy(value, dval->name, (size_t) lv-1);
		}
		else
		{
			sprintf (buffer, ""%ld"", pair->lvalue);
",1,unused,608,unused,"			strncpy(value, dval->name, (size_t) lv-1);
		}
		else
		{
			sprintf (buffer, ""%ld"", pair->lvalue);
",unused,ssocopsacc_radiusclient-lib2Favpair.c
"	char ttyname[PATH_MAX];

	*ttyname = '\0';
	if (*name != '/')
		strcpy(ttyname, ""/dev/"");
",1,unused,112,unused,"	char ttyname[PATH_MAX];

	*ttyname = '\0';
	if (*name != '/')
		strcpy(ttyname, ""/dev/"");
",unused,ssocopsacc_radiusclient-lib2Fclientid.c
"			{
				rc_log(LOG_CRIT, ""rc_read_dictionary: out of memory"");
				return (-1);
			}
			strcpy (attr->name, namestr);
",1,unused,129,unused,"			{
				rc_log(LOG_CRIT, ""rc_read_dictionary: out of memory"");
				return (-1);
			}
			strcpy (attr->name, namestr);
",unused,ssocopsacc_radiusclient-lib2Fdict.c
"			{
				rc_log(LOG_CRIT, ""rc_read_dictionary: out of memory"");
				return (-1);
			}
			strcpy (dval->attrname, attrstr);
",1,unused,185,unused,"			{
				rc_log(LOG_CRIT, ""rc_read_dictionary: out of memory"");
				return (-1);
			}
			strcpy (dval->attrname, attrstr);
",unused,ssocopsacc_radiusclient-lib2Fdict.c
"				rc_log(LOG_CRIT, ""rc_read_dictionary: out of memory"");
				return (-1);
			}
			strcpy (dval->attrname, attrstr);
			strcpy (dval->name, namestr);
",1,unused,186,unused,"				rc_log(LOG_CRIT, ""rc_read_dictionary: out of memory"");
				return (-1);
			}
			strcpy (dval->attrname, attrstr);
			strcpy (dval->name, namestr);
",unused,ssocopsacc_radiusclient-lib2Fdict.c
"			return (-1);

		env->env[i] = new_env;

		sprintf(env->env[i],""%s=%s"", name, value);
",1,unused,86,unused,"			return (-1);

		env->env[i] = new_env;

		sprintf(env->env[i],""%s=%s"", name, value);
",unused,ssocopsacc_radiusclient-lib2Fenv.c
"			rc_log(LOG_CRIT, ""rc_add_env: out of memory"");
			return (-1);
		}
	
		sprintf(env->env[env->size],""%s=%s"", name, value);
",1,unused,98,unused,"			rc_log(LOG_CRIT, ""rc_add_env: out of memory"");
			return (-1);
		}
	
		sprintf(env->env[env->size],""%s=%s"", name, value);
",unused,ssocopsacc_radiusclient-lib2Fenv.c
"		  vector = (char *)auth->vector;
		  for(i = 0; i < padded_length; i += AUTH_VECTOR_LEN)
		  {
		  	/* Calculate the MD5 digest*/
		  	strcpy ((char *) md5buf, secret);
",1,unused,75,unused,"		  vector = (char *)auth->vector;
		  for(i = 0; i < padded_length; i += AUTH_VECTOR_LEN)
		  {
		  	/* Calculate the MD5 digest*/
		  	strcpy ((char *) md5buf, secret);
",unused,ssocopsacc_radiusclient-lib2Fsendserver.c
"
	if ((vp = rc_avpair_get(data->send_pairs, PW_SERVICE_TYPE)) && \
	    (vp->lvalue == PW_ADMINISTRATIVE)) 
	{
		strcpy(secret, MGMT_POLL_SECRET);
",1,unused,191,unused,"
	if ((vp = rc_avpair_get(data->send_pairs, PW_SERVICE_TYPE)) && \
	    (vp->lvalue == PW_ADMINISTRATIVE)) 
	{
		strcpy(secret, MGMT_POLL_SECRET);
",unused,ssocopsacc_radiusclient-lib2Fsendserver.c
"	while (vp)
	{
		if ((vp = rc_avpair_get(vp, PW_REPLY_MESSAGE)))
		{
			strcat(msg, vp->strvalue);
",1,unused,328,unused,"	while (vp)
	{
		if ((vp = rc_avpair_get(vp, PW_REPLY_MESSAGE)))
		{
			strcat(msg, vp->strvalue);
",unused,ssocopsacc_radiusclient-lib2Fsendserver.c
"	{
		if ((vp = rc_avpair_get(vp, PW_REPLY_MESSAGE)))
		{
			strcat(msg, vp->strvalue);
			strcat(msg, ""\n"");
",1,unused,329,unused,"	{
		if ((vp = rc_avpair_get(vp, PW_REPLY_MESSAGE)))
		{
			strcat(msg, vp->strvalue);
			strcat(msg, ""\n"");
",unused,ssocopsacc_radiusclient-lib2Fsendserver.c
"char *
rc_mksid (void)
{
  static char buf[14];
  sprintf (buf, ""%08lX%04X"", (unsigned long int) time (NULL), (unsigned int) getpid ());
",1,unused,235,unused,"char *
rc_mksid (void)
{
  static char buf[14];
  sprintf (buf, ""%08lX%04X"", (unsigned long int) time (NULL), (unsigned int) getpid ());
",unused,ssocopsacc_radiusclient-lib2Futil.c
"		   handle attributes < 256, which is the standard anyway. */
		
		while (vp)
		{
			strcpy(name, ""RADIUS_"");
",1,unused,139,unused,"		   handle attributes < 256, which is the standard anyway. */
		
		while (vp)
		{
			strcpy(name, ""RADIUS_"");
",unused,ssocopsacc_radiusclient-src2Fradius.c
"			{
				int count;
				if ((count = acount[attr]++) > 0) {
					char buf[10];
					sprintf(buf, ""_%d"", count);
",1,unused,159,unused,"			{
				int count;
				if ((count = acount[attr]++) > 0) {
					char buf[10];
					sprintf(buf, ""_%d"", count);
",unused,ssocopsacc_radiusclient-src2Fradius.c
"				int count;
				if ((count = acount[attr]++) > 0) {
					char buf[10];
					sprintf(buf, ""_%d"", count);
					strcat(name,buf);
",1,unused,160,unused,"				int count;
				if ((count = acount[attr]++) > 0) {
					char buf[10];
					sprintf(buf, ""_%d"", count);
					strcat(name,buf);
",unused,ssocopsacc_radiusclient-src2Fradius.c
"	FILE *fp;
	char fname[PATH_MAX];
	int c;

	strcpy(fname, rc_conf_str(""nologin""));
",1,unused,40,unused,"	FILE *fp;
	char fname[PATH_MAX];
	int c;

	strcpy(fname, rc_conf_str(""nologin""));
",unused,ssocopsacc_radiusclient-src2Fradlogin.c
"
	strcpy(fname, rc_conf_str(""nologin""));
	if (access(fname, F_OK) < 0) {
		if (tty) {
			sprintf(fname, ""%s.%s"", rc_conf_str(""nologin""), tty);
",1,unused,43,unused,"
	strcpy(fname, rc_conf_str(""nologin""));
	if (access(fname, F_OK) < 0) {
		if (tty) {
			sprintf(fname, ""%s.%s"", rc_conf_str(""nologin""), tty);
",unused,ssocopsacc_radiusclient-src2Fradlogin.c
"					break;
				p++;
				switch (*p) {
					case 'I':
						strcpy(q, rcsid);
",1,unused,94,unused,"					break;
				p++;
				switch (*p) {
					case 'I':
						strcpy(q, rcsid);
",unused,ssocopsacc_radiusclient-src2Fradlogin.c
"						q += strlen(rcsid);
						break;
					case 'L':
					case 'P':
						strcpy(q, tty);
",1,unused,99,unused,"						q += strlen(rcsid);
						break;
					case 'L':
					case 'P':
						strcpy(q, tty);
",unused,ssocopsacc_radiusclient-src2Fradlogin.c
"						q += strlen(tty);
						break;
#if defined(HAVE_UNAME)
					case 'S':
						strcpy(q, uts.sysname);
",1,unused,104,unused,"						q += strlen(tty);
						break;
#if defined(HAVE_UNAME)
					case 'S':
						strcpy(q, uts.sysname);
",unused,ssocopsacc_radiusclient-src2Fradlogin.c
"						strcpy(q, uts.sysname);
						q += strlen(uts.sysname);
						break;
					case 'N':
						strcpy(q, uts.nodename);
",1,unused,108,unused,"						strcpy(q, uts.sysname);
						q += strlen(uts.sysname);
						break;
					case 'N':
						strcpy(q, uts.nodename);
",unused,ssocopsacc_radiusclient-src2Fradlogin.c
"						strcpy(q, uts.nodename);
						q += strlen(uts.nodename);
						break;
					case 'R':
						strcpy(q, uts.release);
",1,unused,112,unused,"						strcpy(q, uts.nodename);
						q += strlen(uts.nodename);
						break;
					case 'R':
						strcpy(q, uts.release);
",unused,ssocopsacc_radiusclient-src2Fradlogin.c
"						strcpy(q, uts.release);
						q += strlen(uts.release);
						break;
					case 'V':
						strcpy(q, uts.version);
",1,unused,116,unused,"						strcpy(q, uts.release);
						q += strlen(uts.release);
						break;
					case 'V':
						strcpy(q, uts.version);
",unused,ssocopsacc_radiusclient-src2Fradlogin.c
"						strcpy(q, uts.version);
						q += strlen(uts.version);
						break;
					case 'M':
						strcpy(q, uts.machine);
",1,unused,120,unused,"						strcpy(q, uts.version);
						q += strlen(uts.version);
						break;
					case 'M':
						strcpy(q, uts.machine);
",unused,ssocopsacc_radiusclient-src2Fradlogin.c
"						strcpy(q, uts.domainname);
						q += strlen(uts.domainname);
#elif defined(HAVE_GETDOMAINNAME)
						getdomainname(domainname, sizeof(domainname));
						strcpy(q, domainname);
",1,unused,130,unused,"						strcpy(q, uts.domainname);
						q += strlen(uts.domainname);
#elif defined(HAVE_GETDOMAINNAME)
						getdomainname(domainname, sizeof(domainname));
						strcpy(q, domainname);
",unused,ssocopsacc_radiusclient-src2Fradlogin.c
"				}
				break;
#if defined(HAVE_UNAME)
			case '@':
				strcpy(q, uts.nodename);
",1,unused,142,unused,"				}
				break;
#if defined(HAVE_UNAME)
			case '@':
				strcpy(q, uts.nodename);
",unused,ssocopsacc_radiusclient-src2Fradlogin.c
"				q += strlen(uts.nodename);
				break;
#endif
			case '\n':
				strcpy(q,""\r\n"");
",1,unused,147,unused,"				q += strlen(uts.nodename);
				break;
#endif
			case '\n':
				strcpy(q,""\r\n"");
",unused,ssocopsacc_radiusclient-src2Fradlogin.c
"
	for (i = 'p'; i <= 'z'; i++) {
		for (j = '0'; j <= 'f'; j++) {
			if (j == '9' + 1) j = 'a';
			sprintf(pty, ""/dev/pty%c%c"", i, j);
",1,unused,189,unused,"
	for (i = 'p'; i <= 'z'; i++) {
		for (j = '0'; j <= 'f'; j++) {
			if (j == '9' + 1) j = 'a';
			sprintf(pty, ""/dev/pty%c%c"", i, j);
",unused,sysvinitartful-src2Fbootlogd.c
"	for (i = 'p'; i <= 'z'; i++) {
		for (j = '0'; j <= 'f'; j++) {
			if (j == '9' + 1) j = 'a';
			sprintf(pty, ""/dev/pty%c%c"", i, j);
			sprintf(tty, ""/dev/tty%c%c"", i, j);
",1,unused,190,unused,"	for (i = 'p'; i <= 'z'; i++) {
		for (j = '0'; j <= 'f'; j++) {
			if (j == '9' + 1) j = 'a';
			sprintf(pty, ""/dev/pty%c%c"", i, j);
			sprintf(tty, ""/dev/tty%c%c"", i, j);
",unused,sysvinitartful-src2Fbootlogd.c
"		if (found) break;
	}
	if (!found) return -1;

	if (name) strcpy(name, tty);
",1,unused,203,unused,"		if (found) break;
	}
	if (!found) return -1;

	if (name) strcpy(name, tty);
",unused,sysvinitartful-src2Fbootlogd.c
"			didnl = 0;
		}
		switch (*ptr) {
			case 27: /* ESC */
				strcpy(tmp, ""^["");
",1,unused,371,unused,"			didnl = 0;
		}
		switch (*ptr) {
			case 27: /* ESC */
				strcpy(tmp, ""^["");
",unused,sysvinitartful-src2Fbootlogd.c
"				tmp[0] = *ptr;
				tmp[1] = 0;
				break;
			default:
				sprintf(tmp, ""\\%03o"", *ptr);
",1,unused,394,unused,"				tmp[0] = *ptr;
				tmp[1] = 0;
				break;
			default:
				sprintf(tmp, ""\\%03o"", *ptr);
",unused,sysvinitartful-src2Fbootlogd.c
"	if (consolename(realcons, sizeof(realcons)) < 0)
		return 1;

	if (strcmp(realcons, ""/dev/tty0"") == 0)
		strcpy(realcons, ""/dev/tty1"");
",1,unused,535,unused,"	if (consolename(realcons, sizeof(realcons)) < 0)
		return 1;

	if (strcmp(realcons, ""/dev/tty0"") == 0)
		strcpy(realcons, ""/dev/tty1"");
",unused,sysvinitartful-src2Fbootlogd.c
"
	if (strcmp(realcons, ""/dev/tty0"") == 0)
		strcpy(realcons, ""/dev/tty1"");
	if (strcmp(realcons, ""/dev/vc/0"") == 0)
		strcpy(realcons, ""/dev/vc/1"");
",1,unused,537,unused,"
	if (strcmp(realcons, ""/dev/tty0"") == 0)
		strcpy(realcons, ""/dev/tty1"");
	if (strcmp(realcons, ""/dev/vc/0"") == 0)
		strcpy(realcons, ""/dev/vc/1"");
",unused,sysvinitartful-src2Fbootlogd.c
"		if ((pwd = getpwuid(uid)) != NULL) {
			uidbuf[0] = 0;
			strncat(uidbuf, pwd->pw_name, sizeof(uidbuf) - 1);
		} else {
			sprintf(uidbuf, uid ? ""uid %d"" : ""root"", (int)uid);
",1,unused,99,unused,"		if ((pwd = getpwuid(uid)) != NULL) {
			uidbuf[0] = 0;
			strncat(uidbuf, pwd->pw_name, sizeof(uidbuf) - 1);
		} else {
			sprintf(uidbuf, uid ? ""uid %d"" : ""root"", (int)uid);
",unused,sysvinitartful-src2Fdowall.c
"  /* See if we need to fire off a shell for this command */
  	/* Give command line to shell */
  	args[1] = SHELL;
  	args[2] = ""-c"";
  	strcpy(buf, ""exec "");
",1,unused,999,unused,"  /* See if we need to fire off a shell for this command */
  	/* Give command line to shell */
  	args[1] = SHELL;
  	args[2] = ""-c"";
  	strcpy(buf, ""exec "");
",unused,sysvinitartful-src2Finit.c
"  		execvp(args[1], args + 1);
		if (errno == ENOEXEC) {
  			args[1] = SHELL;
  			args[2] = ""-c"";
  			strcpy(buf, ""exec "");
",1,unused,1168,unused,"  		execvp(args[1], args + 1);
		if (errno == ENOEXEC) {
  			args[1] = SHELL;
  			args[2] = ""-c"";
  			strcpy(buf, ""exec "");
",unused,sysvinitartful-src2Finit.c
"	 *	Check if syntax is OK. Be very verbose here, to
	 *	avoid newbie postings on comp.os.linux.setup :)
	 */
	err[0] = 0;
	if (!id || !*id) strcpy(err, ""missing id field"");
",1,unused,1306,unused,"	 *	Check if syntax is OK. Be very verbose here, to
	 *	avoid newbie postings on comp.os.linux.setup :)
	 */
	err[0] = 0;
	if (!id || !*id) strcpy(err, ""missing id field"");
",unused,sysvinitartful-src2Finit.c
"	 *	avoid newbie postings on comp.os.linux.setup :)
	 */
	err[0] = 0;
	if (!id || !*id) strcpy(err, ""missing id field"");
	if (!rlevel)     strcpy(err, ""missing runlevel field"");
",1,unused,1307,unused,"	 *	avoid newbie postings on comp.os.linux.setup :)
	 */
	err[0] = 0;
	if (!id || !*id) strcpy(err, ""missing id field"");
	if (!rlevel)     strcpy(err, ""missing runlevel field"");
",unused,sysvinitartful-src2Finit.c
"	 */
	err[0] = 0;
	if (!id || !*id) strcpy(err, ""missing id field"");
	if (!rlevel)     strcpy(err, ""missing runlevel field"");
	if (!process)    strcpy(err, ""missing process field"");
",1,unused,1308,unused,"	 */
	err[0] = 0;
	if (!id || !*id) strcpy(err, ""missing id field"");
	if (!rlevel)     strcpy(err, ""missing runlevel field"");
	if (!process)    strcpy(err, ""missing process field"");
",unused,sysvinitartful-src2Finit.c
"	if (!id || !*id) strcpy(err, ""missing id field"");
	if (!rlevel)     strcpy(err, ""missing runlevel field"");
	if (!process)    strcpy(err, ""missing process field"");
	if (!action || !*action)
			strcpy(err, ""missing action field"");
",1,unused,1310,unused,"	if (!id || !*id) strcpy(err, ""missing id field"");
	if (!rlevel)     strcpy(err, ""missing runlevel field"");
	if (!process)    strcpy(err, ""missing process field"");
	if (!action || !*action)
			strcpy(err, ""missing action field"");
",unused,sysvinitartful-src2Finit.c
"	if (!process)    strcpy(err, ""missing process field"");
	if (!action || !*action)
			strcpy(err, ""missing action field"");
	if (id && strlen(id) > sizeof(utproto.ut_id))
		sprintf(err, ""id field too long (max %d characters)"",
",1,unused,1312,unused,"	if (!process)    strcpy(err, ""missing process field"");
	if (!action || !*action)
			strcpy(err, ""missing action field"");
	if (id && strlen(id) > sizeof(utproto.ut_id))
		sprintf(err, ""id field too long (max %d characters)"",
",unused,sysvinitartful-src2Finit.c
"	if (id && strlen(id) > sizeof(utproto.ut_id))
		sprintf(err, ""id field too long (max %d characters)"",
			(int)sizeof(utproto.ut_id));
	if (rlevel && strlen(rlevel) > 11)
		strcpy(err, ""rlevel field too long (max 11 characters)"");
",1,unused,1315,unused,"	if (id && strlen(id) > sizeof(utproto.ut_id))
		sprintf(err, ""id field too long (max %d characters)"",
			(int)sizeof(utproto.ut_id));
	if (rlevel && strlen(rlevel) > 11)
		strcpy(err, ""rlevel field too long (max 11 characters)"");
",unused,sysvinitartful-src2Finit.c
"			(int)sizeof(utproto.ut_id));
	if (rlevel && strlen(rlevel) > 11)
		strcpy(err, ""rlevel field too long (max 11 characters)"");
	if (process && strlen(process) > 127)
		strcpy(err, ""process field too long"");
",1,unused,1317,unused,"			(int)sizeof(utproto.ut_id));
	if (rlevel && strlen(rlevel) > 11)
		strcpy(err, ""rlevel field too long (max 11 characters)"");
	if (process && strlen(process) > 127)
		strcpy(err, ""process field too long"");
",unused,sysvinitartful-src2Finit.c
"		strcpy(err, ""rlevel field too long (max 11 characters)"");
	if (process && strlen(process) > 127)
		strcpy(err, ""process field too long"");
	if (action && strlen(action) > 32)
		strcpy(err, ""action field too long"");
",1,unused,1319,unused,"		strcpy(err, ""rlevel field too long (max 11 characters)"");
	if (process && strlen(process) > 127)
		strcpy(err, ""process field too long"");
	if (action && strlen(action) > 32)
		strcpy(err, ""action field too long"");
",unused,sysvinitartful-src2Finit.c
"			if (ch->rlevel[f] == 's') ch->rlevel[f] = 'S';
		}
		strncpy(ch->rlevel, rlevel, sizeof(ch->rlevel) - 1);
	} else {
		strcpy(ch->rlevel, ""0123456789"");
",1,unused,1371,unused,"			if (ch->rlevel[f] == 's') ch->rlevel[f] = 'S';
		}
		strncpy(ch->rlevel, rlevel, sizeof(ch->rlevel) - 1);
	} else {
		strcpy(ch->rlevel, ""0123456789"");
",unused,sysvinitartful-src2Finit.c
"		strncpy(ch->rlevel, rlevel, sizeof(ch->rlevel) - 1);
	} else {
		strcpy(ch->rlevel, ""0123456789"");
		if (ISPOWER(ch->action))
			strcpy(ch->rlevel, ""S0123456789"");
",1,unused,1373,unused,"		strncpy(ch->rlevel, rlevel, sizeof(ch->rlevel) - 1);
	} else {
		strcpy(ch->rlevel, ""0123456789"");
		if (ISPOWER(ch->action))
			strcpy(ch->rlevel, ""S0123456789"");
",unused,sysvinitartful-src2Finit.c
"	/*
	 *	We have the fake runlevel '#' for SYSINIT  and
	 *	'*' for BOOT and BOOTWAIT.
	 */
	if (ch->action == SYSINIT) strcpy(ch->rlevel, ""#"");
",1,unused,1379,unused,"	/*
	 *	We have the fake runlevel '#' for SYSINIT  and
	 *	'*' for BOOT and BOOTWAIT.
	 */
	if (ch->action == SYSINIT) strcpy(ch->rlevel, ""#"");
",unused,sysvinitartful-src2Finit.c
"	 *	'*' for BOOT and BOOTWAIT.
	 */
	if (ch->action == SYSINIT) strcpy(ch->rlevel, ""#"");
	if (ch->action == BOOT || ch->action == BOOTWAIT)
		strcpy(ch->rlevel, ""*"");
",1,unused,1381,unused,"	 *	'*' for BOOT and BOOTWAIT.
	 */
	if (ch->action == SYSINIT) strcpy(ch->rlevel, ""#"");
	if (ch->action == BOOT || ch->action == BOOTWAIT)
		strcpy(ch->rlevel, ""*"");
",unused,sysvinitartful-src2Finit.c
"{
	static char btmp[128];
	char *p;

	strcpy(btmp, WTMP_FILE);
",1,unused,259,unused,"{
	static char btmp[128];
	char *p;

	strcpy(btmp, WTMP_FILE);
",unused,sysvinitartful-src2Flast.c
"		p = btmp;
	else
		p++;
	*p = 0;
	strcat(btmp, ""btmp"");
",1,unused,265,unused,"		p = btmp;
	else
		p++;
	*p = 0;
	strcat(btmp, ""btmp"");
",unused,sysvinitartful-src2Flast.c
"	/*
	 *	Calculate times
	 */
	tmp = (time_t)p->ut_time;
	strcpy(logintime, ctime(&tmp));
",1,unused,407,unused,"	/*
	 *	Calculate times
	 */
	tmp = (time_t)p->ut_time;
	strcpy(logintime, ctime(&tmp));
",unused,sysvinitartful-src2Flast.c
"	 */
	tmp = (time_t)p->ut_time;
	strcpy(logintime, ctime(&tmp));
	if (fulltime)
		sprintf(logouttime, ""- %s"", ctime(&t));
",1,unused,409,unused,"	 */
	tmp = (time_t)p->ut_time;
	strcpy(logintime, ctime(&tmp));
	if (fulltime)
		sprintf(logouttime, ""- %s"", ctime(&t));
",unused,sysvinitartful-src2Flast.c
"	if (fulltime)
		sprintf(logouttime, ""- %s"", ctime(&t));
	else {
		logintime[16] = 0;
		sprintf(logouttime, ""- %s"", ctime(&t) + 11);
",1,unused,412,unused,"	if (fulltime)
		sprintf(logouttime, ""- %s"", ctime(&t));
	else {
		logintime[16] = 0;
		sprintf(logouttime, ""- %s"", ctime(&t) + 11);
",unused,sysvinitartful-src2Flast.c
"	mins  = (secs / 60) % 60;
	hours = (secs / 3600) % 24;
	days  = secs / 86400;
	if (days)
		sprintf(length, ""(%d+%02d:%02d)"", days, hours, mins);
",1,unused,420,unused,"	mins  = (secs / 60) % 60;
	hours = (secs / 3600) % 24;
	days  = secs / 86400;
	if (days)
		sprintf(length, ""(%d+%02d:%02d)"", days, hours, mins);
",unused,sysvinitartful-src2Flast.c
"	days  = secs / 86400;
	if (days)
		sprintf(length, ""(%d+%02d:%02d)"", days, hours, mins);
	else
		sprintf(length, "" (%02d:%02d)"", hours, mins);
",1,unused,422,unused,"	days  = secs / 86400;
	if (days)
		sprintf(length, ""(%d+%02d:%02d)"", days, hours, mins);
	else
		sprintf(length, "" (%02d:%02d)"", hours, mins);
",unused,sysvinitartful-src2Flast.c
"		sprintf(length, "" (%02d:%02d)"", hours, mins);

	switch(what) {
		case R_CRASH:
			sprintf(logouttime, ""- crash"");
",1,unused,426,unused,"		sprintf(length, "" (%02d:%02d)"", hours, mins);

	switch(what) {
		case R_CRASH:
			sprintf(logouttime, ""- crash"");
",unused,sysvinitartful-src2Flast.c
"		case R_CRASH:
			sprintf(logouttime, ""- crash"");
			break;
		case R_DOWN:
			sprintf(logouttime, ""- down "");
",1,unused,429,unused,"		case R_CRASH:
			sprintf(logouttime, ""- crash"");
			break;
		case R_DOWN:
			sprintf(logouttime, ""- down "");
",unused,sysvinitartful-src2Flast.c
"			break;
		case R_NOW:
			length[0] = 0;
			if (fulltime)
				sprintf(logouttime, ""  still logged in"");
",1,unused,434,unused,"			break;
		case R_NOW:
			length[0] = 0;
			if (fulltime)
				sprintf(logouttime, ""  still logged in"");
",unused,sysvinitartful-src2Flast.c
"			length[0] = 0;
			if (fulltime)
				sprintf(logouttime, ""  still logged in"");
			else {
				sprintf(logouttime, ""  still"");
",1,unused,436,unused,"			length[0] = 0;
			if (fulltime)
				sprintf(logouttime, ""  still logged in"");
			else {
				sprintf(logouttime, ""  still"");
",unused,sysvinitartful-src2Flast.c
"			if (fulltime)
				sprintf(logouttime, ""  still logged in"");
			else {
				sprintf(logouttime, ""  still"");
				sprintf(length, ""logged in"");
",1,unused,437,unused,"			if (fulltime)
				sprintf(logouttime, ""  still logged in"");
			else {
				sprintf(logouttime, ""  still"");
				sprintf(length, ""logged in"");
",unused,sysvinitartful-src2Flast.c
"			break;
		case R_PHANTOM:
			length[0] = 0;
			if (fulltime)
				sprintf(logouttime, ""  gone - no logout"");
",1,unused,443,unused,"			break;
		case R_PHANTOM:
			length[0] = 0;
			if (fulltime)
				sprintf(logouttime, ""  gone - no logout"");
",unused,sysvinitartful-src2Flast.c
"			length[0] = 0;
			if (fulltime)
				sprintf(logouttime, ""  gone - no logout"");
			else {
				sprintf(logouttime, ""   gone"");
",1,unused,445,unused,"			length[0] = 0;
			if (fulltime)
				sprintf(logouttime, ""  gone - no logout"");
			else {
				sprintf(logouttime, ""   gone"");
",unused,sysvinitartful-src2Flast.c
"			if (fulltime)
				sprintf(logouttime, ""  gone - no logout"");
			else {
				sprintf(logouttime, ""   gone"");
				sprintf(length, ""- no logout"");
",1,unused,446,unused,"			if (fulltime)
				sprintf(logouttime, ""  gone - no logout"");
			else {
				sprintf(logouttime, ""   gone"");
				sprintf(length, ""- no logout"");
",unused,sysvinitartful-src2Flast.c
"			fprintf(stderr, ""%s: out of memory\n"",
				progname);
			exit(1);
		}
		strcpy(altufile, optarg);
",1,unused,628,unused,"			fprintf(stderr, ""%s: out of memory\n"",
				progname);
			exit(1);
		}
		strcpy(altufile, optarg);
",unused,sysvinitartful-src2Flast.c
"
	switch (ut.ut_type) {
		case SHUTDOWN_TIME:
			if (extended) {
				strcpy(ut.ut_line, ""system down"");
",1,unused,807,unused,"
	switch (ut.ut_type) {
		case SHUTDOWN_TIME:
			if (extended) {
				strcpy(ut.ut_line, ""system down"");
",unused,sysvinitartful-src2Flast.c
"			break;
		case OLD_TIME:
		case NEW_TIME:
			if (extended) {
				strcpy(ut.ut_line,
",1,unused,816,unused,"			break;
		case OLD_TIME:
		case NEW_TIME:
			if (extended) {
				strcpy(ut.ut_line,
",unused,sysvinitartful-src2Flast.c
"				quit = list(&ut, lastdown, R_TIMECHANGE);
			}
			break;
		case BOOT_TIME:
			strcpy(ut.ut_line, ""system boot"");
",1,unused,823,unused,"				quit = list(&ut, lastdown, R_TIMECHANGE);
			}
			break;
		case BOOT_TIME:
			strcpy(ut.ut_line, ""system boot"");
",unused,sysvinitartful-src2Flast.c
"			break;
		case RUN_LVL:
			x = ut.ut_pid & 255;
			if (extended) {
				sprintf(ut.ut_line, ""(to lvl %c)"", x);
",1,unused,831,unused,"			break;
		case RUN_LVL:
			x = ut.ut_pid & 255;
			if (extended) {
				sprintf(ut.ut_line, ""(to lvl %c)"", x);
",unused,sysvinitartful-src2Flast.c
"	}

	memset(buf, 0, sizeof(buf));
	strncpy(buf, path, sizeof(buf) - 4);
	strcat(buf, ""/.."");
",1,unused,115,unused,"	}

	memset(buf, 0, sizeof(buf));
	strncpy(buf, path, sizeof(buf) - 4);
	strcat(buf, ""/.."");
",unused,sysvinitartful-src2Fmountpoint.c
"  		fprintf(stderr, ""shutdown: you must be root to do that!\n"");
		usage();
  		exit(1);
	}
	strcpy(down_level, ""1"");
",1,unused,509,unused,"  		fprintf(stderr, ""shutdown: you must be root to do that!\n"");
		usage();
  		exit(1);
	}
	strcpy(down_level, ""1"");
",unused,sysvinitartful-src2Fshutdown.c
"		while(!user_ok && (ut = getutent()) != NULL) {

			/* See if this is a user process on a VC. */
			if (ut->ut_type != USER_PROCESS) continue;
			sprintf(term, ""/dev/%.*s"", UT_LINESIZE, ut->ut_line);
",1,unused,593,unused,"		while(!user_ok && (ut = getutent()) != NULL) {

			/* See if this is a user process on a VC. */
			if (ut->ut_type != USER_PROCESS) continue;
			sprintf(term, ""/dev/%.*s"", UT_LINESIZE, ut->ut_line);
",unused,sysvinitartful-src2Fshutdown.c
"	message[0] = 0;
	for(c = optind + (!cancel && !when); c < argc; c++) {
		if (strlen(message) + strlen(argv[c]) + 4 > MESSAGELEN)
			break;
  		strcat(message, argv[c]);
",1,unused,639,unused,"	message[0] = 0;
	for(c = optind + (!cancel && !when); c < argc; c++) {
		if (strlen(message) + strlen(argv[c]) + 4 > MESSAGELEN)
			break;
  		strcat(message, argv[c]);
",unused,sysvinitartful-src2Fshutdown.c
"	for(c = optind + (!cancel && !when); c < argc; c++) {
		if (strlen(message) + strlen(argv[c]) + 4 > MESSAGELEN)
			break;
  		strcat(message, argv[c]);
  		strcat(message, "" "");
",1,unused,640,unused,"	for(c = optind + (!cancel && !when); c < argc; c++) {
		if (strlen(message) + strlen(argv[c]) + 4 > MESSAGELEN)
			break;
  		strcat(message, argv[c]);
  		strcat(message, "" "");
",unused,sysvinitartful-src2Fshutdown.c
"			break;
  		strcat(message, argv[c]);
  		strcat(message, "" "");
	}
	if (message[0]) strcat(message, ""\r\n"");
",1,unused,642,unused,"			break;
  		strcat(message, argv[c]);
  		strcat(message, "" "");
	}
	if (message[0]) strcat(message, ""\r\n"");
",unused,sysvinitartful-src2Fshutdown.c
"
	/* Tell users what we're gonna do. */
	switch(down_level[0]) {
		case '0':
			strcpy(newstate, ""for system halt"");
",1,unused,682,unused,"
	/* Tell users what we're gonna do. */
	switch(down_level[0]) {
		case '0':
			strcpy(newstate, ""for system halt"");
",unused,sysvinitartful-src2Fshutdown.c
"		case '0':
			strcpy(newstate, ""for system halt"");
			break;
		case '6':
			strcpy(newstate, ""for reboot"");
",1,unused,685,unused,"		case '0':
			strcpy(newstate, ""for system halt"");
			break;
		case '6':
			strcpy(newstate, ""for reboot"");
",unused,sysvinitartful-src2Fshutdown.c
"		case '6':
			strcpy(newstate, ""for reboot"");
			break;
		case '1':
			strcpy(newstate, ""to maintenance mode"");
",1,unused,688,unused,"		case '6':
			strcpy(newstate, ""for reboot"");
			break;
		case '1':
			strcpy(newstate, ""to maintenance mode"");
",unused,sysvinitartful-src2Fshutdown.c
"		case '1':
			strcpy(newstate, ""to maintenance mode"");
			break;
		default:
			sprintf(newstate, ""to runlevel %s"", down_level);
",1,unused,691,unused,"		case '1':
			strcpy(newstate, ""to maintenance mode"");
			break;
		default:
			sprintf(newstate, ""to runlevel %s"", down_level);
",unused,sysvinitartful-src2Fshutdown.c
"	if (fastboot)  close(open(FASTBOOT,  O_CREAT | O_RDWR, 0644));
	if (forcefsck) close(open(FORCEFSCK, O_CREAT | O_RDWR, 0644));

	/* Alias now and take care of old '+mins' notation. */
	if (!strcmp(when, ""now"")) strcpy(when, ""0"");
",1,unused,724,unused,"	if (fastboot)  close(open(FASTBOOT,  O_CREAT | O_RDWR, 0644));
	if (forcefsck) close(open(FORCEFSCK, O_CREAT | O_RDWR, 0644));

	/* Alias now and take care of old '+mins' notation. */
	if (!strcmp(when, ""now"")) strcpy(when, ""0"");
",unused,sysvinitartful-src2Fshutdown.c
"	/*
	 *	The password is invalid. If there is a
	 *	shadow password, try it.
	 */
	strcpy(pwd.pw_passwd, """");
",1,unused,310,unused,"	/*
	 *	The password is invalid. If there is a
	 *	shadow password, try it.
	 */
	strcpy(pwd.pw_passwd, """");
",unused,sysvinitartful-src2Fsulogin.c
"	 *	NULL it, and return.
	 */
	if (p == NULL) {
		fprintf(stderr, ""%s: no entry for root\n"", F_SHADOW);
		strcpy(pwd.pw_passwd, """");
",1,unused,330,unused,"	 *	NULL it, and return.
	 */
	if (p == NULL) {
		fprintf(stderr, ""%s: no entry for root\n"", F_SHADOW);
		strcpy(pwd.pw_passwd, """");
",unused,sysvinitartful-src2Fsulogin.c
"		strcpy(pwd.pw_passwd, """");
	}
	if (!valid(pwd.pw_passwd)) {
		fprintf(stderr, ""%s: root password garbled\n"", F_SHADOW);
		strcpy(pwd.pw_passwd, """"); }
",1,unused,334,unused,"		strcpy(pwd.pw_passwd, """");
	}
	if (!valid(pwd.pw_passwd)) {
		fprintf(stderr, ""%s: root password garbled\n"", F_SHADOW);
		strcpy(pwd.pw_passwd, """"); }
",unused,sysvinitartful-src2Fsulogin.c
"  if ((argc - optind) > 0) {
	for(f = optind; f < argc; f++) {
		len += strlen(argv[f]) + 1;
		if (len >= MAXLEN-2) break;
		strcat(buf, argv[f]);
",1,unused,85,unused,"  if ((argc - optind) > 0) {
	for(f = optind; f < argc; f++) {
		len += strlen(argv[f]) + 1;
		if (len >= MAXLEN-2) break;
		strcat(buf, argv[f]);
",unused,sysvinitartful-src2Fwall.c
"	for(f = optind; f < argc; f++) {
		len += strlen(argv[f]) + 1;
		if (len >= MAXLEN-2) break;
		strcat(buf, argv[f]);
		if (f < argc-1) strcat(buf, "" "");
",1,unused,86,unused,"	for(f = optind; f < argc; f++) {
		len += strlen(argv[f]) + 1;
		if (len >= MAXLEN-2) break;
		strcat(buf, argv[f]);
		if (f < argc-1) strcat(buf, "" "");
",unused,sysvinitartful-src2Fwall.c
"		if (len >= MAXLEN-2) break;
		strcat(buf, argv[f]);
		if (f < argc-1) strcat(buf, "" "");
	}
	strcat(buf, ""\r\n"");
",1,unused,88,unused,"		if (len >= MAXLEN-2) break;
		strcat(buf, argv[f]);
		if (f < argc-1) strcat(buf, "" "");
	}
	strcat(buf, ""\r\n"");
",unused,sysvinitartful-src2Fwall.c
"		 *	Make sure that line ends in \r\n
		 */
		for(p = line; *p && *p != '\r' && *p != '\n'; p++)
			;
		strcpy(p, ""\r\n"");
",1,unused,96,unused,"		 *	Make sure that line ends in \r\n
		 */
		for(p = line; *p && *p != '\r' && *p != '\n'; p++)
			;
		strcpy(p, ""\r\n"");
",unused,sysvinitartful-src2Fwall.c
"			;
		strcpy(p, ""\r\n"");
		len += strlen(line);
		if (len >= MAXLEN) break;
		strcat(buf, line);
",1,unused,99,unused,"			;
		strcpy(p, ""\r\n"");
		len += strlen(line);
		if (len >= MAXLEN) break;
		strcat(buf, line);
",unused,sysvinitartful-src2Fwall.c
"
	for (i = 'p'; i <= 'z'; i++) {
		for (j = '0'; j <= 'f'; j++) {
			if (j == '9' + 1) j = 'a';
			sprintf(pty, ""/dev/pty%c%c"", i, j);
",1,unused,189,unused,"
	for (i = 'p'; i <= 'z'; i++) {
		for (j = '0'; j <= 'f'; j++) {
			if (j == '9' + 1) j = 'a';
			sprintf(pty, ""/dev/pty%c%c"", i, j);
",unused,sysvinitdebstretche-src2Fbootlogd.c
"	for (i = 'p'; i <= 'z'; i++) {
		for (j = '0'; j <= 'f'; j++) {
			if (j == '9' + 1) j = 'a';
			sprintf(pty, ""/dev/pty%c%c"", i, j);
			sprintf(tty, ""/dev/tty%c%c"", i, j);
",1,unused,190,unused,"	for (i = 'p'; i <= 'z'; i++) {
		for (j = '0'; j <= 'f'; j++) {
			if (j == '9' + 1) j = 'a';
			sprintf(pty, ""/dev/pty%c%c"", i, j);
			sprintf(tty, ""/dev/tty%c%c"", i, j);
",unused,sysvinitdebstretche-src2Fbootlogd.c
"		if (found) break;
	}
	if (!found) return -1;

	if (name) strcpy(name, tty);
",1,unused,203,unused,"		if (found) break;
	}
	if (!found) return -1;

	if (name) strcpy(name, tty);
",unused,sysvinitdebstretche-src2Fbootlogd.c
"			didnl = 0;
		}
		switch (*ptr) {
			case 27: /* ESC */
				strcpy(tmp, ""^["");
",1,unused,371,unused,"			didnl = 0;
		}
		switch (*ptr) {
			case 27: /* ESC */
				strcpy(tmp, ""^["");
",unused,sysvinitdebstretche-src2Fbootlogd.c
"				tmp[0] = *ptr;
				tmp[1] = 0;
				break;
			default:
				sprintf(tmp, ""\\%03o"", *ptr);
",1,unused,394,unused,"				tmp[0] = *ptr;
				tmp[1] = 0;
				break;
			default:
				sprintf(tmp, ""\\%03o"", *ptr);
",unused,sysvinitdebstretche-src2Fbootlogd.c
"	if (consolename(realcons, sizeof(realcons)) < 0)
		return 1;

	if (strcmp(realcons, ""/dev/tty0"") == 0)
		strcpy(realcons, ""/dev/tty1"");
",1,unused,535,unused,"	if (consolename(realcons, sizeof(realcons)) < 0)
		return 1;

	if (strcmp(realcons, ""/dev/tty0"") == 0)
		strcpy(realcons, ""/dev/tty1"");
",unused,sysvinitdebstretche-src2Fbootlogd.c
"
	if (strcmp(realcons, ""/dev/tty0"") == 0)
		strcpy(realcons, ""/dev/tty1"");
	if (strcmp(realcons, ""/dev/vc/0"") == 0)
		strcpy(realcons, ""/dev/vc/1"");
",1,unused,537,unused,"
	if (strcmp(realcons, ""/dev/tty0"") == 0)
		strcpy(realcons, ""/dev/tty1"");
	if (strcmp(realcons, ""/dev/vc/0"") == 0)
		strcpy(realcons, ""/dev/vc/1"");
",unused,sysvinitdebstretche-src2Fbootlogd.c
"		if ((pwd = getpwuid(uid)) != NULL) {
			uidbuf[0] = 0;
			strncat(uidbuf, pwd->pw_name, sizeof(uidbuf) - 1);
		} else {
			sprintf(uidbuf, uid ? ""uid %d"" : ""root"", (int)uid);
",1,unused,99,unused,"		if ((pwd = getpwuid(uid)) != NULL) {
			uidbuf[0] = 0;
			strncat(uidbuf, pwd->pw_name, sizeof(uidbuf) - 1);
		} else {
			sprintf(uidbuf, uid ? ""uid %d"" : ""root"", (int)uid);
",unused,sysvinitdebstretche-src2Fdowall.c
"  /* See if we need to fire off a shell for this command */
  	/* Give command line to shell */
  	args[1] = SHELL;
  	args[2] = ""-c"";
  	strcpy(buf, ""exec "");
",1,unused,999,unused,"  /* See if we need to fire off a shell for this command */
  	/* Give command line to shell */
  	args[1] = SHELL;
  	args[2] = ""-c"";
  	strcpy(buf, ""exec "");
",unused,sysvinitdebstretche-src2Finit.c
"  		execvp(args[1], args + 1);
		if (errno == ENOEXEC) {
  			args[1] = SHELL;
  			args[2] = ""-c"";
  			strcpy(buf, ""exec "");
",1,unused,1168,unused,"  		execvp(args[1], args + 1);
		if (errno == ENOEXEC) {
  			args[1] = SHELL;
  			args[2] = ""-c"";
  			strcpy(buf, ""exec "");
",unused,sysvinitdebstretche-src2Finit.c
"	 *	Check if syntax is OK. Be very verbose here, to
	 *	avoid newbie postings on comp.os.linux.setup :)
	 */
	err[0] = 0;
	if (!id || !*id) strcpy(err, ""missing id field"");
",1,unused,1306,unused,"	 *	Check if syntax is OK. Be very verbose here, to
	 *	avoid newbie postings on comp.os.linux.setup :)
	 */
	err[0] = 0;
	if (!id || !*id) strcpy(err, ""missing id field"");
",unused,sysvinitdebstretche-src2Finit.c
"	 *	avoid newbie postings on comp.os.linux.setup :)
	 */
	err[0] = 0;
	if (!id || !*id) strcpy(err, ""missing id field"");
	if (!rlevel)     strcpy(err, ""missing runlevel field"");
",1,unused,1307,unused,"	 *	avoid newbie postings on comp.os.linux.setup :)
	 */
	err[0] = 0;
	if (!id || !*id) strcpy(err, ""missing id field"");
	if (!rlevel)     strcpy(err, ""missing runlevel field"");
",unused,sysvinitdebstretche-src2Finit.c
"	 */
	err[0] = 0;
	if (!id || !*id) strcpy(err, ""missing id field"");
	if (!rlevel)     strcpy(err, ""missing runlevel field"");
	if (!process)    strcpy(err, ""missing process field"");
",1,unused,1308,unused,"	 */
	err[0] = 0;
	if (!id || !*id) strcpy(err, ""missing id field"");
	if (!rlevel)     strcpy(err, ""missing runlevel field"");
	if (!process)    strcpy(err, ""missing process field"");
",unused,sysvinitdebstretche-src2Finit.c
"	if (!id || !*id) strcpy(err, ""missing id field"");
	if (!rlevel)     strcpy(err, ""missing runlevel field"");
	if (!process)    strcpy(err, ""missing process field"");
	if (!action || !*action)
			strcpy(err, ""missing action field"");
",1,unused,1310,unused,"	if (!id || !*id) strcpy(err, ""missing id field"");
	if (!rlevel)     strcpy(err, ""missing runlevel field"");
	if (!process)    strcpy(err, ""missing process field"");
	if (!action || !*action)
			strcpy(err, ""missing action field"");
",unused,sysvinitdebstretche-src2Finit.c
"	if (!process)    strcpy(err, ""missing process field"");
	if (!action || !*action)
			strcpy(err, ""missing action field"");
	if (id && strlen(id) > sizeof(utproto.ut_id))
		sprintf(err, ""id field too long (max %d characters)"",
",1,unused,1312,unused,"	if (!process)    strcpy(err, ""missing process field"");
	if (!action || !*action)
			strcpy(err, ""missing action field"");
	if (id && strlen(id) > sizeof(utproto.ut_id))
		sprintf(err, ""id field too long (max %d characters)"",
",unused,sysvinitdebstretche-src2Finit.c
"	if (id && strlen(id) > sizeof(utproto.ut_id))
		sprintf(err, ""id field too long (max %d characters)"",
			(int)sizeof(utproto.ut_id));
	if (rlevel && strlen(rlevel) > 11)
		strcpy(err, ""rlevel field too long (max 11 characters)"");
",1,unused,1315,unused,"	if (id && strlen(id) > sizeof(utproto.ut_id))
		sprintf(err, ""id field too long (max %d characters)"",
			(int)sizeof(utproto.ut_id));
	if (rlevel && strlen(rlevel) > 11)
		strcpy(err, ""rlevel field too long (max 11 characters)"");
",unused,sysvinitdebstretche-src2Finit.c
"			(int)sizeof(utproto.ut_id));
	if (rlevel && strlen(rlevel) > 11)
		strcpy(err, ""rlevel field too long (max 11 characters)"");
	if (process && strlen(process) > 127)
		strcpy(err, ""process field too long"");
",1,unused,1317,unused,"			(int)sizeof(utproto.ut_id));
	if (rlevel && strlen(rlevel) > 11)
		strcpy(err, ""rlevel field too long (max 11 characters)"");
	if (process && strlen(process) > 127)
		strcpy(err, ""process field too long"");
",unused,sysvinitdebstretche-src2Finit.c
"		strcpy(err, ""rlevel field too long (max 11 characters)"");
	if (process && strlen(process) > 127)
		strcpy(err, ""process field too long"");
	if (action && strlen(action) > 32)
		strcpy(err, ""action field too long"");
",1,unused,1319,unused,"		strcpy(err, ""rlevel field too long (max 11 characters)"");
	if (process && strlen(process) > 127)
		strcpy(err, ""process field too long"");
	if (action && strlen(action) > 32)
		strcpy(err, ""action field too long"");
",unused,sysvinitdebstretche-src2Finit.c
"			if (ch->rlevel[f] == 's') ch->rlevel[f] = 'S';
		}
		strncpy(ch->rlevel, rlevel, sizeof(ch->rlevel) - 1);
	} else {
		strcpy(ch->rlevel, ""0123456789"");
",1,unused,1371,unused,"			if (ch->rlevel[f] == 's') ch->rlevel[f] = 'S';
		}
		strncpy(ch->rlevel, rlevel, sizeof(ch->rlevel) - 1);
	} else {
		strcpy(ch->rlevel, ""0123456789"");
",unused,sysvinitdebstretche-src2Finit.c
"		strncpy(ch->rlevel, rlevel, sizeof(ch->rlevel) - 1);
	} else {
		strcpy(ch->rlevel, ""0123456789"");
		if (ISPOWER(ch->action))
			strcpy(ch->rlevel, ""S0123456789"");
",1,unused,1373,unused,"		strncpy(ch->rlevel, rlevel, sizeof(ch->rlevel) - 1);
	} else {
		strcpy(ch->rlevel, ""0123456789"");
		if (ISPOWER(ch->action))
			strcpy(ch->rlevel, ""S0123456789"");
",unused,sysvinitdebstretche-src2Finit.c
"	/*
	 *	We have the fake runlevel '#' for SYSINIT  and
	 *	'*' for BOOT and BOOTWAIT.
	 */
	if (ch->action == SYSINIT) strcpy(ch->rlevel, ""#"");
",1,unused,1379,unused,"	/*
	 *	We have the fake runlevel '#' for SYSINIT  and
	 *	'*' for BOOT and BOOTWAIT.
	 */
	if (ch->action == SYSINIT) strcpy(ch->rlevel, ""#"");
",unused,sysvinitdebstretche-src2Finit.c
"	 *	'*' for BOOT and BOOTWAIT.
	 */
	if (ch->action == SYSINIT) strcpy(ch->rlevel, ""#"");
	if (ch->action == BOOT || ch->action == BOOTWAIT)
		strcpy(ch->rlevel, ""*"");
",1,unused,1381,unused,"	 *	'*' for BOOT and BOOTWAIT.
	 */
	if (ch->action == SYSINIT) strcpy(ch->rlevel, ""#"");
	if (ch->action == BOOT || ch->action == BOOTWAIT)
		strcpy(ch->rlevel, ""*"");
",unused,sysvinitdebstretche-src2Finit.c
"{
	static char btmp[128];
	char *p;

	strcpy(btmp, WTMP_FILE);
",1,unused,259,unused,"{
	static char btmp[128];
	char *p;

	strcpy(btmp, WTMP_FILE);
",unused,sysvinitdebstretche-src2Flast.c
"		p = btmp;
	else
		p++;
	*p = 0;
	strcat(btmp, ""btmp"");
",1,unused,265,unused,"		p = btmp;
	else
		p++;
	*p = 0;
	strcat(btmp, ""btmp"");
",unused,sysvinitdebstretche-src2Flast.c
"	/*
	 *	Calculate times
	 */
	tmp = (time_t)p->ut_time;
	strcpy(logintime, ctime(&tmp));
",1,unused,407,unused,"	/*
	 *	Calculate times
	 */
	tmp = (time_t)p->ut_time;
	strcpy(logintime, ctime(&tmp));
",unused,sysvinitdebstretche-src2Flast.c
"	 */
	tmp = (time_t)p->ut_time;
	strcpy(logintime, ctime(&tmp));
	if (fulltime)
		sprintf(logouttime, ""- %s"", ctime(&t));
",1,unused,409,unused,"	 */
	tmp = (time_t)p->ut_time;
	strcpy(logintime, ctime(&tmp));
	if (fulltime)
		sprintf(logouttime, ""- %s"", ctime(&t));
",unused,sysvinitdebstretche-src2Flast.c
"	if (fulltime)
		sprintf(logouttime, ""- %s"", ctime(&t));
	else {
		logintime[16] = 0;
		sprintf(logouttime, ""- %s"", ctime(&t) + 11);
",1,unused,412,unused,"	if (fulltime)
		sprintf(logouttime, ""- %s"", ctime(&t));
	else {
		logintime[16] = 0;
		sprintf(logouttime, ""- %s"", ctime(&t) + 11);
",unused,sysvinitdebstretche-src2Flast.c
"	mins  = (secs / 60) % 60;
	hours = (secs / 3600) % 24;
	days  = secs / 86400;
	if (days)
		sprintf(length, ""(%d+%02d:%02d)"", days, hours, mins);
",1,unused,420,unused,"	mins  = (secs / 60) % 60;
	hours = (secs / 3600) % 24;
	days  = secs / 86400;
	if (days)
		sprintf(length, ""(%d+%02d:%02d)"", days, hours, mins);
",unused,sysvinitdebstretche-src2Flast.c
"	days  = secs / 86400;
	if (days)
		sprintf(length, ""(%d+%02d:%02d)"", days, hours, mins);
	else
		sprintf(length, "" (%02d:%02d)"", hours, mins);
",1,unused,422,unused,"	days  = secs / 86400;
	if (days)
		sprintf(length, ""(%d+%02d:%02d)"", days, hours, mins);
	else
		sprintf(length, "" (%02d:%02d)"", hours, mins);
",unused,sysvinitdebstretche-src2Flast.c
"		sprintf(length, "" (%02d:%02d)"", hours, mins);

	switch(what) {
		case R_CRASH:
			sprintf(logouttime, ""- crash"");
",1,unused,426,unused,"		sprintf(length, "" (%02d:%02d)"", hours, mins);

	switch(what) {
		case R_CRASH:
			sprintf(logouttime, ""- crash"");
",unused,sysvinitdebstretche-src2Flast.c
"		case R_CRASH:
			sprintf(logouttime, ""- crash"");
			break;
		case R_DOWN:
			sprintf(logouttime, ""- down "");
",1,unused,429,unused,"		case R_CRASH:
			sprintf(logouttime, ""- crash"");
			break;
		case R_DOWN:
			sprintf(logouttime, ""- down "");
",unused,sysvinitdebstretche-src2Flast.c
"			break;
		case R_NOW:
			length[0] = 0;
			if (fulltime)
				sprintf(logouttime, ""  still logged in"");
",1,unused,434,unused,"			break;
		case R_NOW:
			length[0] = 0;
			if (fulltime)
				sprintf(logouttime, ""  still logged in"");
",unused,sysvinitdebstretche-src2Flast.c
"			length[0] = 0;
			if (fulltime)
				sprintf(logouttime, ""  still logged in"");
			else {
				sprintf(logouttime, ""  still"");
",1,unused,436,unused,"			length[0] = 0;
			if (fulltime)
				sprintf(logouttime, ""  still logged in"");
			else {
				sprintf(logouttime, ""  still"");
",unused,sysvinitdebstretche-src2Flast.c
"			if (fulltime)
				sprintf(logouttime, ""  still logged in"");
			else {
				sprintf(logouttime, ""  still"");
				sprintf(length, ""logged in"");
",1,unused,437,unused,"			if (fulltime)
				sprintf(logouttime, ""  still logged in"");
			else {
				sprintf(logouttime, ""  still"");
				sprintf(length, ""logged in"");
",unused,sysvinitdebstretche-src2Flast.c
"			break;
		case R_PHANTOM:
			length[0] = 0;
			if (fulltime)
				sprintf(logouttime, ""  gone - no logout"");
",1,unused,443,unused,"			break;
		case R_PHANTOM:
			length[0] = 0;
			if (fulltime)
				sprintf(logouttime, ""  gone - no logout"");
",unused,sysvinitdebstretche-src2Flast.c
"			length[0] = 0;
			if (fulltime)
				sprintf(logouttime, ""  gone - no logout"");
			else {
				sprintf(logouttime, ""   gone"");
",1,unused,445,unused,"			length[0] = 0;
			if (fulltime)
				sprintf(logouttime, ""  gone - no logout"");
			else {
				sprintf(logouttime, ""   gone"");
",unused,sysvinitdebstretche-src2Flast.c
"			if (fulltime)
				sprintf(logouttime, ""  gone - no logout"");
			else {
				sprintf(logouttime, ""   gone"");
				sprintf(length, ""- no logout"");
",1,unused,446,unused,"			if (fulltime)
				sprintf(logouttime, ""  gone - no logout"");
			else {
				sprintf(logouttime, ""   gone"");
				sprintf(length, ""- no logout"");
",unused,sysvinitdebstretche-src2Flast.c
"			fprintf(stderr, ""%s: out of memory\n"",
				progname);
			exit(1);
		}
		strcpy(altufile, optarg);
",1,unused,628,unused,"			fprintf(stderr, ""%s: out of memory\n"",
				progname);
			exit(1);
		}
		strcpy(altufile, optarg);
",unused,sysvinitdebstretche-src2Flast.c
"
	switch (ut.ut_type) {
		case SHUTDOWN_TIME:
			if (extended) {
				strcpy(ut.ut_line, ""system down"");
",1,unused,807,unused,"
	switch (ut.ut_type) {
		case SHUTDOWN_TIME:
			if (extended) {
				strcpy(ut.ut_line, ""system down"");
",unused,sysvinitdebstretche-src2Flast.c
"			break;
		case OLD_TIME:
		case NEW_TIME:
			if (extended) {
				strcpy(ut.ut_line,
",1,unused,816,unused,"			break;
		case OLD_TIME:
		case NEW_TIME:
			if (extended) {
				strcpy(ut.ut_line,
",unused,sysvinitdebstretche-src2Flast.c
"				quit = list(&ut, lastdown, R_TIMECHANGE);
			}
			break;
		case BOOT_TIME:
			strcpy(ut.ut_line, ""system boot"");
",1,unused,823,unused,"				quit = list(&ut, lastdown, R_TIMECHANGE);
			}
			break;
		case BOOT_TIME:
			strcpy(ut.ut_line, ""system boot"");
",unused,sysvinitdebstretche-src2Flast.c
"			break;
		case RUN_LVL:
			x = ut.ut_pid & 255;
			if (extended) {
				sprintf(ut.ut_line, ""(to lvl %c)"", x);
",1,unused,831,unused,"			break;
		case RUN_LVL:
			x = ut.ut_pid & 255;
			if (extended) {
				sprintf(ut.ut_line, ""(to lvl %c)"", x);
",unused,sysvinitdebstretche-src2Flast.c
"	}

	memset(buf, 0, sizeof(buf));
	strncpy(buf, path, sizeof(buf) - 4);
	strcat(buf, ""/.."");
",1,unused,115,unused,"	}

	memset(buf, 0, sizeof(buf));
	strncpy(buf, path, sizeof(buf) - 4);
	strcat(buf, ""/.."");
",unused,sysvinitdebstretche-src2Fmountpoint.c
"  		fprintf(stderr, ""shutdown: you must be root to do that!\n"");
		usage();
  		exit(1);
	}
	strcpy(down_level, ""1"");
",1,unused,509,unused,"  		fprintf(stderr, ""shutdown: you must be root to do that!\n"");
		usage();
  		exit(1);
	}
	strcpy(down_level, ""1"");
",unused,sysvinitdebstretche-src2Fshutdown.c
"		while(!user_ok && (ut = getutent()) != NULL) {

			/* See if this is a user process on a VC. */
			if (ut->ut_type != USER_PROCESS) continue;
			sprintf(term, ""/dev/%.*s"", UT_LINESIZE, ut->ut_line);
",1,unused,593,unused,"		while(!user_ok && (ut = getutent()) != NULL) {

			/* See if this is a user process on a VC. */
			if (ut->ut_type != USER_PROCESS) continue;
			sprintf(term, ""/dev/%.*s"", UT_LINESIZE, ut->ut_line);
",unused,sysvinitdebstretche-src2Fshutdown.c
"	message[0] = 0;
	for(c = optind + (!cancel && !when); c < argc; c++) {
		if (strlen(message) + strlen(argv[c]) + 4 > MESSAGELEN)
			break;
  		strcat(message, argv[c]);
",1,unused,639,unused,"	message[0] = 0;
	for(c = optind + (!cancel && !when); c < argc; c++) {
		if (strlen(message) + strlen(argv[c]) + 4 > MESSAGELEN)
			break;
  		strcat(message, argv[c]);
",unused,sysvinitdebstretche-src2Fshutdown.c
"	for(c = optind + (!cancel && !when); c < argc; c++) {
		if (strlen(message) + strlen(argv[c]) + 4 > MESSAGELEN)
			break;
  		strcat(message, argv[c]);
  		strcat(message, "" "");
",1,unused,640,unused,"	for(c = optind + (!cancel && !when); c < argc; c++) {
		if (strlen(message) + strlen(argv[c]) + 4 > MESSAGELEN)
			break;
  		strcat(message, argv[c]);
  		strcat(message, "" "");
",unused,sysvinitdebstretche-src2Fshutdown.c
"			break;
  		strcat(message, argv[c]);
  		strcat(message, "" "");
	}
	if (message[0]) strcat(message, ""\r\n"");
",1,unused,642,unused,"			break;
  		strcat(message, argv[c]);
  		strcat(message, "" "");
	}
	if (message[0]) strcat(message, ""\r\n"");
",unused,sysvinitdebstretche-src2Fshutdown.c
"
	/* Tell users what we're gonna do. */
	switch(down_level[0]) {
		case '0':
			strcpy(newstate, ""for system halt"");
",1,unused,682,unused,"
	/* Tell users what we're gonna do. */
	switch(down_level[0]) {
		case '0':
			strcpy(newstate, ""for system halt"");
",unused,sysvinitdebstretche-src2Fshutdown.c
"		case '0':
			strcpy(newstate, ""for system halt"");
			break;
		case '6':
			strcpy(newstate, ""for reboot"");
",1,unused,685,unused,"		case '0':
			strcpy(newstate, ""for system halt"");
			break;
		case '6':
			strcpy(newstate, ""for reboot"");
",unused,sysvinitdebstretche-src2Fshutdown.c
"		case '6':
			strcpy(newstate, ""for reboot"");
			break;
		case '1':
			strcpy(newstate, ""to maintenance mode"");
",1,unused,688,unused,"		case '6':
			strcpy(newstate, ""for reboot"");
			break;
		case '1':
			strcpy(newstate, ""to maintenance mode"");
",unused,sysvinitdebstretche-src2Fshutdown.c
"		case '1':
			strcpy(newstate, ""to maintenance mode"");
			break;
		default:
			sprintf(newstate, ""to runlevel %s"", down_level);
",1,unused,691,unused,"		case '1':
			strcpy(newstate, ""to maintenance mode"");
			break;
		default:
			sprintf(newstate, ""to runlevel %s"", down_level);
",unused,sysvinitdebstretche-src2Fshutdown.c
"	if (fastboot)  close(open(FASTBOOT,  O_CREAT | O_RDWR, 0644));
	if (forcefsck) close(open(FORCEFSCK, O_CREAT | O_RDWR, 0644));

	/* Alias now and take care of old '+mins' notation. */
	if (!strcmp(when, ""now"")) strcpy(when, ""0"");
",1,unused,724,unused,"	if (fastboot)  close(open(FASTBOOT,  O_CREAT | O_RDWR, 0644));
	if (forcefsck) close(open(FORCEFSCK, O_CREAT | O_RDWR, 0644));

	/* Alias now and take care of old '+mins' notation. */
	if (!strcmp(when, ""now"")) strcpy(when, ""0"");
",unused,sysvinitdebstretche-src2Fshutdown.c
"	/*
	 *	The password is invalid. If there is a
	 *	shadow password, try it.
	 */
	strcpy(pwd.pw_passwd, """");
",1,unused,310,unused,"	/*
	 *	The password is invalid. If there is a
	 *	shadow password, try it.
	 */
	strcpy(pwd.pw_passwd, """");
",unused,sysvinitdebstretche-src2Fsulogin.c
"	 *	NULL it, and return.
	 */
	if (p == NULL) {
		fprintf(stderr, ""%s: no entry for root\n"", F_SHADOW);
		strcpy(pwd.pw_passwd, """");
",1,unused,330,unused,"	 *	NULL it, and return.
	 */
	if (p == NULL) {
		fprintf(stderr, ""%s: no entry for root\n"", F_SHADOW);
		strcpy(pwd.pw_passwd, """");
",unused,sysvinitdebstretche-src2Fsulogin.c
"		strcpy(pwd.pw_passwd, """");
	}
	if (!valid(pwd.pw_passwd)) {
		fprintf(stderr, ""%s: root password garbled\n"", F_SHADOW);
		strcpy(pwd.pw_passwd, """"); }
",1,unused,334,unused,"		strcpy(pwd.pw_passwd, """");
	}
	if (!valid(pwd.pw_passwd)) {
		fprintf(stderr, ""%s: root password garbled\n"", F_SHADOW);
		strcpy(pwd.pw_passwd, """"); }
",unused,sysvinitdebstretche-src2Fsulogin.c
"  if ((argc - optind) > 0) {
	for(f = optind; f < argc; f++) {
		len += strlen(argv[f]) + 1;
		if (len >= MAXLEN-2) break;
		strcat(buf, argv[f]);
",1,unused,85,unused,"  if ((argc - optind) > 0) {
	for(f = optind; f < argc; f++) {
		len += strlen(argv[f]) + 1;
		if (len >= MAXLEN-2) break;
		strcat(buf, argv[f]);
",unused,sysvinitdebstretche-src2Fwall.c
"	for(f = optind; f < argc; f++) {
		len += strlen(argv[f]) + 1;
		if (len >= MAXLEN-2) break;
		strcat(buf, argv[f]);
		if (f < argc-1) strcat(buf, "" "");
",1,unused,86,unused,"	for(f = optind; f < argc; f++) {
		len += strlen(argv[f]) + 1;
		if (len >= MAXLEN-2) break;
		strcat(buf, argv[f]);
		if (f < argc-1) strcat(buf, "" "");
",unused,sysvinitdebstretche-src2Fwall.c
"		if (len >= MAXLEN-2) break;
		strcat(buf, argv[f]);
		if (f < argc-1) strcat(buf, "" "");
	}
	strcat(buf, ""\r\n"");
",1,unused,88,unused,"		if (len >= MAXLEN-2) break;
		strcat(buf, argv[f]);
		if (f < argc-1) strcat(buf, "" "");
	}
	strcat(buf, ""\r\n"");
",unused,sysvinitdebstretche-src2Fwall.c
"		 *	Make sure that line ends in \r\n
		 */
		for(p = line; *p && *p != '\r' && *p != '\n'; p++)
			;
		strcpy(p, ""\r\n"");
",1,unused,96,unused,"		 *	Make sure that line ends in \r\n
		 */
		for(p = line; *p && *p != '\r' && *p != '\n'; p++)
			;
		strcpy(p, ""\r\n"");
",unused,sysvinitdebstretche-src2Fwall.c
"			;
		strcpy(p, ""\r\n"");
		len += strlen(line);
		if (len >= MAXLEN) break;
		strcat(buf, line);
",1,unused,99,unused,"			;
		strcpy(p, ""\r\n"");
		len += strlen(line);
		if (len >= MAXLEN) break;
		strcat(buf, line);
",unused,sysvinitdebstretche-src2Fwall.c
"
	for (i = 'p'; i <= 'z'; i++) {
		for (j = '0'; j <= 'f'; j++) {
			if (j == '9' + 1) j = 'a';
			sprintf(pty, ""/dev/pty%c%c"", i, j);
",1,unused,195,unused,"
	for (i = 'p'; i <= 'z'; i++) {
		for (j = '0'; j <= 'f'; j++) {
			if (j == '9' + 1) j = 'a';
			sprintf(pty, ""/dev/pty%c%c"", i, j);
",unused,sysvinitpatchxen-src2Fbootlogd.c
"	for (i = 'p'; i <= 'z'; i++) {
		for (j = '0'; j <= 'f'; j++) {
			if (j == '9' + 1) j = 'a';
			sprintf(pty, ""/dev/pty%c%c"", i, j);
			sprintf(tty, ""/dev/tty%c%c"", i, j);
",1,unused,196,unused,"	for (i = 'p'; i <= 'z'; i++) {
		for (j = '0'; j <= 'f'; j++) {
			if (j == '9' + 1) j = 'a';
			sprintf(pty, ""/dev/pty%c%c"", i, j);
			sprintf(tty, ""/dev/tty%c%c"", i, j);
",unused,sysvinitpatchxen-src2Fbootlogd.c
"		if (found) break;
	}
	if (!found) return -1;

	if (name) strcpy(name, tty);
",1,unused,209,unused,"		if (found) break;
	}
	if (!found) return -1;

	if (name) strcpy(name, tty);
",unused,sysvinitpatchxen-src2Fbootlogd.c
"			didnl = 0;
		}
		switch (*ptr) {
			case 27: /* ESC */
				strcpy(tmp, ""^["");
",1,unused,363,unused,"			didnl = 0;
		}
		switch (*ptr) {
			case 27: /* ESC */
				strcpy(tmp, ""^["");
",unused,sysvinitpatchxen-src2Fbootlogd.c
"				tmp[0] = *ptr;
				tmp[1] = 0;
				break;
			default:
				sprintf(tmp, ""\\%03o"", *ptr);
",1,unused,386,unused,"				tmp[0] = *ptr;
				tmp[1] = 0;
				break;
			default:
				sprintf(tmp, ""\\%03o"", *ptr);
",unused,sysvinitpatchxen-src2Fbootlogd.c
"		return 1;
	consoles_left = num_consoles;
	for (considx = 0; considx < num_consoles; considx++) {
		if (strcmp(cons[considx].name, ""/dev/tty0"") == 0)
			strcpy(cons[considx].name, ""/dev/tty1"");
",1,unused,533,unused,"		return 1;
	consoles_left = num_consoles;
	for (considx = 0; considx < num_consoles; considx++) {
		if (strcmp(cons[considx].name, ""/dev/tty0"") == 0)
			strcpy(cons[considx].name, ""/dev/tty1"");
",unused,sysvinitpatchxen-src2Fbootlogd.c
"	for (considx = 0; considx < num_consoles; considx++) {
		if (strcmp(cons[considx].name, ""/dev/tty0"") == 0)
			strcpy(cons[considx].name, ""/dev/tty1"");
		if (strcmp(cons[considx].name, ""/dev/vc/0"") == 0)
			strcpy(cons[considx].name, ""/dev/vc/1"");
",1,unused,535,unused,"	for (considx = 0; considx < num_consoles; considx++) {
		if (strcmp(cons[considx].name, ""/dev/tty0"") == 0)
			strcpy(cons[considx].name, ""/dev/tty1"");
		if (strcmp(cons[considx].name, ""/dev/vc/0"") == 0)
			strcpy(cons[considx].name, ""/dev/vc/1"");
",unused,sysvinitpatchxen-src2Fbootlogd.c
"		if ((pwd = getpwuid(uid)) != NULL) {
			uidbuf[0] = 0;
			strncat(uidbuf, pwd->pw_name, sizeof(uidbuf) - 1);
		} else {
			sprintf(uidbuf, uid ? ""uid %d"" : ""root"", (int)uid);
",1,unused,99,unused,"		if ((pwd = getpwuid(uid)) != NULL) {
			uidbuf[0] = 0;
			strncat(uidbuf, pwd->pw_name, sizeof(uidbuf) - 1);
		} else {
			sprintf(uidbuf, uid ? ""uid %d"" : ""root"", (int)uid);
",unused,sysvinitpatchxen-src2Fdowall.c
"  /* See if we need to fire off a shell for this command */
  	/* Give command line to shell */
  	args[1] = SHELL;
  	args[2] = ""-c"";
  	strcpy(buf, ""exec "");
",1,unused,998,unused,"  /* See if we need to fire off a shell for this command */
  	/* Give command line to shell */
  	args[1] = SHELL;
  	args[2] = ""-c"";
  	strcpy(buf, ""exec "");
",unused,sysvinitpatchxen-src2Finit.c
"  		execvp(args[1], args + 1);
		if (errno == ENOEXEC) {
  			args[1] = SHELL;
  			args[2] = ""-c"";
  			strcpy(buf, ""exec "");
",1,unused,1167,unused,"  		execvp(args[1], args + 1);
		if (errno == ENOEXEC) {
  			args[1] = SHELL;
  			args[2] = ""-c"";
  			strcpy(buf, ""exec "");
",unused,sysvinitpatchxen-src2Finit.c
"	 *	Check if syntax is OK. Be very verbose here, to
	 *	avoid newbie postings on comp.os.linux.setup :)
	 */
	err[0] = 0;
	if (!id || !*id) strcpy(err, ""missing id field"");
",1,unused,1305,unused,"	 *	Check if syntax is OK. Be very verbose here, to
	 *	avoid newbie postings on comp.os.linux.setup :)
	 */
	err[0] = 0;
	if (!id || !*id) strcpy(err, ""missing id field"");
",unused,sysvinitpatchxen-src2Finit.c
"	 *	avoid newbie postings on comp.os.linux.setup :)
	 */
	err[0] = 0;
	if (!id || !*id) strcpy(err, ""missing id field"");
	if (!rlevel)     strcpy(err, ""missing runlevel field"");
",1,unused,1306,unused,"	 *	avoid newbie postings on comp.os.linux.setup :)
	 */
	err[0] = 0;
	if (!id || !*id) strcpy(err, ""missing id field"");
	if (!rlevel)     strcpy(err, ""missing runlevel field"");
",unused,sysvinitpatchxen-src2Finit.c
"	 */
	err[0] = 0;
	if (!id || !*id) strcpy(err, ""missing id field"");
	if (!rlevel)     strcpy(err, ""missing runlevel field"");
	if (!process)    strcpy(err, ""missing process field"");
",1,unused,1307,unused,"	 */
	err[0] = 0;
	if (!id || !*id) strcpy(err, ""missing id field"");
	if (!rlevel)     strcpy(err, ""missing runlevel field"");
	if (!process)    strcpy(err, ""missing process field"");
",unused,sysvinitpatchxen-src2Finit.c
"	if (!id || !*id) strcpy(err, ""missing id field"");
	if (!rlevel)     strcpy(err, ""missing runlevel field"");
	if (!process)    strcpy(err, ""missing process field"");
	if (!action || !*action)
			strcpy(err, ""missing action field"");
",1,unused,1309,unused,"	if (!id || !*id) strcpy(err, ""missing id field"");
	if (!rlevel)     strcpy(err, ""missing runlevel field"");
	if (!process)    strcpy(err, ""missing process field"");
	if (!action || !*action)
			strcpy(err, ""missing action field"");
",unused,sysvinitpatchxen-src2Finit.c
"	if (!process)    strcpy(err, ""missing process field"");
	if (!action || !*action)
			strcpy(err, ""missing action field"");
	if (id && strlen(id) > sizeof(utproto.ut_id))
		sprintf(err, ""id field too long (max %d characters)"",
",1,unused,1311,unused,"	if (!process)    strcpy(err, ""missing process field"");
	if (!action || !*action)
			strcpy(err, ""missing action field"");
	if (id && strlen(id) > sizeof(utproto.ut_id))
		sprintf(err, ""id field too long (max %d characters)"",
",unused,sysvinitpatchxen-src2Finit.c
"	if (id && strlen(id) > sizeof(utproto.ut_id))
		sprintf(err, ""id field too long (max %d characters)"",
			(int)sizeof(utproto.ut_id));
	if (rlevel && strlen(rlevel) > 11)
		strcpy(err, ""rlevel field too long (max 11 characters)"");
",1,unused,1314,unused,"	if (id && strlen(id) > sizeof(utproto.ut_id))
		sprintf(err, ""id field too long (max %d characters)"",
			(int)sizeof(utproto.ut_id));
	if (rlevel && strlen(rlevel) > 11)
		strcpy(err, ""rlevel field too long (max 11 characters)"");
",unused,sysvinitpatchxen-src2Finit.c
"			(int)sizeof(utproto.ut_id));
	if (rlevel && strlen(rlevel) > 11)
		strcpy(err, ""rlevel field too long (max 11 characters)"");
	if (process && strlen(process) > 127)
		strcpy(err, ""process field too long (max 127 characters)"");
",1,unused,1316,unused,"			(int)sizeof(utproto.ut_id));
	if (rlevel && strlen(rlevel) > 11)
		strcpy(err, ""rlevel field too long (max 11 characters)"");
	if (process && strlen(process) > 127)
		strcpy(err, ""process field too long (max 127 characters)"");
",unused,sysvinitpatchxen-src2Finit.c
"		strcpy(err, ""rlevel field too long (max 11 characters)"");
	if (process && strlen(process) > 127)
		strcpy(err, ""process field too long (max 127 characters)"");
	if (action && strlen(action) > 32)
		strcpy(err, ""action field too long"");
",1,unused,1318,unused,"		strcpy(err, ""rlevel field too long (max 11 characters)"");
	if (process && strlen(process) > 127)
		strcpy(err, ""process field too long (max 127 characters)"");
	if (action && strlen(action) > 32)
		strcpy(err, ""action field too long"");
",unused,sysvinitpatchxen-src2Finit.c
"			if (ch->rlevel[f] == 's') ch->rlevel[f] = 'S';
		}
		strncpy(ch->rlevel, rlevel, sizeof(ch->rlevel) - 1);
	} else {
		strcpy(ch->rlevel, ""0123456789"");
",1,unused,1370,unused,"			if (ch->rlevel[f] == 's') ch->rlevel[f] = 'S';
		}
		strncpy(ch->rlevel, rlevel, sizeof(ch->rlevel) - 1);
	} else {
		strcpy(ch->rlevel, ""0123456789"");
",unused,sysvinitpatchxen-src2Finit.c
"		strncpy(ch->rlevel, rlevel, sizeof(ch->rlevel) - 1);
	} else {
		strcpy(ch->rlevel, ""0123456789"");
		if (ISPOWER(ch->action))
			strcpy(ch->rlevel, ""S0123456789"");
",1,unused,1372,unused,"		strncpy(ch->rlevel, rlevel, sizeof(ch->rlevel) - 1);
	} else {
		strcpy(ch->rlevel, ""0123456789"");
		if (ISPOWER(ch->action))
			strcpy(ch->rlevel, ""S0123456789"");
",unused,sysvinitpatchxen-src2Finit.c
"	/*
	 *	We have the fake runlevel '#' for SYSINIT  and
	 *	'*' for BOOT and BOOTWAIT.
	 */
	if (ch->action == SYSINIT) strcpy(ch->rlevel, ""#"");
",1,unused,1378,unused,"	/*
	 *	We have the fake runlevel '#' for SYSINIT  and
	 *	'*' for BOOT and BOOTWAIT.
	 */
	if (ch->action == SYSINIT) strcpy(ch->rlevel, ""#"");
",unused,sysvinitpatchxen-src2Finit.c
"	 *	'*' for BOOT and BOOTWAIT.
	 */
	if (ch->action == SYSINIT) strcpy(ch->rlevel, ""#"");
	if (ch->action == BOOT || ch->action == BOOTWAIT)
		strcpy(ch->rlevel, ""*"");
",1,unused,1380,unused,"	 *	'*' for BOOT and BOOTWAIT.
	 */
	if (ch->action == SYSINIT) strcpy(ch->rlevel, ""#"");
	if (ch->action == BOOT || ch->action == BOOTWAIT)
		strcpy(ch->rlevel, ""*"");
",unused,sysvinitpatchxen-src2Finit.c
"{
	static char btmp[128];
	char *p;

	strcpy(btmp, WTMP_FILE);
",1,unused,259,unused,"{
	static char btmp[128];
	char *p;

	strcpy(btmp, WTMP_FILE);
",unused,sysvinitpatchxen-src2Flast.c
"		p = btmp;
	else
		p++;
	*p = 0;
	strcat(btmp, ""btmp"");
",1,unused,265,unused,"		p = btmp;
	else
		p++;
	*p = 0;
	strcat(btmp, ""btmp"");
",unused,sysvinitpatchxen-src2Flast.c
"	/*
	 *	Calculate times
	 */
	tmp = (time_t)p->ut_time;
	strcpy(logintime, ctime(&tmp));
",1,unused,407,unused,"	/*
	 *	Calculate times
	 */
	tmp = (time_t)p->ut_time;
	strcpy(logintime, ctime(&tmp));
",unused,sysvinitpatchxen-src2Flast.c
"	 */
	tmp = (time_t)p->ut_time;
	strcpy(logintime, ctime(&tmp));
	if (fulltime)
		sprintf(logouttime, ""- %s"", ctime(&t));
",1,unused,409,unused,"	 */
	tmp = (time_t)p->ut_time;
	strcpy(logintime, ctime(&tmp));
	if (fulltime)
		sprintf(logouttime, ""- %s"", ctime(&t));
",unused,sysvinitpatchxen-src2Flast.c
"	if (fulltime)
		sprintf(logouttime, ""- %s"", ctime(&t));
	else {
		logintime[16] = 0;
		sprintf(logouttime, ""- %s"", ctime(&t) + 11);
",1,unused,412,unused,"	if (fulltime)
		sprintf(logouttime, ""- %s"", ctime(&t));
	else {
		logintime[16] = 0;
		sprintf(logouttime, ""- %s"", ctime(&t) + 11);
",unused,sysvinitpatchxen-src2Flast.c
"	mins  = (secs / 60) % 60;
	hours = (secs / 3600) % 24;
	days  = secs / 86400;
	if (days)
		sprintf(length, ""(%d+%02d:%02d)"", days, hours, mins);
",1,unused,420,unused,"	mins  = (secs / 60) % 60;
	hours = (secs / 3600) % 24;
	days  = secs / 86400;
	if (days)
		sprintf(length, ""(%d+%02d:%02d)"", days, hours, mins);
",unused,sysvinitpatchxen-src2Flast.c
"	days  = secs / 86400;
	if (days)
		sprintf(length, ""(%d+%02d:%02d)"", days, hours, mins);
	else
		sprintf(length, "" (%02d:%02d)"", hours, mins);
",1,unused,422,unused,"	days  = secs / 86400;
	if (days)
		sprintf(length, ""(%d+%02d:%02d)"", days, hours, mins);
	else
		sprintf(length, "" (%02d:%02d)"", hours, mins);
",unused,sysvinitpatchxen-src2Flast.c
"		sprintf(length, "" (%02d:%02d)"", hours, mins);

	switch(what) {
		case R_CRASH:
			sprintf(logouttime, ""- crash"");
",1,unused,426,unused,"		sprintf(length, "" (%02d:%02d)"", hours, mins);

	switch(what) {
		case R_CRASH:
			sprintf(logouttime, ""- crash"");
",unused,sysvinitpatchxen-src2Flast.c
"		case R_CRASH:
			sprintf(logouttime, ""- crash"");
			break;
		case R_DOWN:
			sprintf(logouttime, ""- down "");
",1,unused,429,unused,"		case R_CRASH:
			sprintf(logouttime, ""- crash"");
			break;
		case R_DOWN:
			sprintf(logouttime, ""- down "");
",unused,sysvinitpatchxen-src2Flast.c
"			break;
		case R_NOW:
			length[0] = 0;
			if (fulltime)
				sprintf(logouttime, ""  still logged in"");
",1,unused,434,unused,"			break;
		case R_NOW:
			length[0] = 0;
			if (fulltime)
				sprintf(logouttime, ""  still logged in"");
",unused,sysvinitpatchxen-src2Flast.c
"			length[0] = 0;
			if (fulltime)
				sprintf(logouttime, ""  still logged in"");
			else {
				sprintf(logouttime, ""  still"");
",1,unused,436,unused,"			length[0] = 0;
			if (fulltime)
				sprintf(logouttime, ""  still logged in"");
			else {
				sprintf(logouttime, ""  still"");
",unused,sysvinitpatchxen-src2Flast.c
"			if (fulltime)
				sprintf(logouttime, ""  still logged in"");
			else {
				sprintf(logouttime, ""  still"");
				sprintf(length, ""logged in"");
",1,unused,437,unused,"			if (fulltime)
				sprintf(logouttime, ""  still logged in"");
			else {
				sprintf(logouttime, ""  still"");
				sprintf(length, ""logged in"");
",unused,sysvinitpatchxen-src2Flast.c
"			break;
		case R_PHANTOM:
			length[0] = 0;
			if (fulltime)
				sprintf(logouttime, ""  gone - no logout"");
",1,unused,443,unused,"			break;
		case R_PHANTOM:
			length[0] = 0;
			if (fulltime)
				sprintf(logouttime, ""  gone - no logout"");
",unused,sysvinitpatchxen-src2Flast.c
"			length[0] = 0;
			if (fulltime)
				sprintf(logouttime, ""  gone - no logout"");
			else {
				sprintf(logouttime, ""   gone"");
",1,unused,445,unused,"			length[0] = 0;
			if (fulltime)
				sprintf(logouttime, ""  gone - no logout"");
			else {
				sprintf(logouttime, ""   gone"");
",unused,sysvinitpatchxen-src2Flast.c
"			if (fulltime)
				sprintf(logouttime, ""  gone - no logout"");
			else {
				sprintf(logouttime, ""   gone"");
				sprintf(length, ""- no logout"");
",1,unused,446,unused,"			if (fulltime)
				sprintf(logouttime, ""  gone - no logout"");
			else {
				sprintf(logouttime, ""   gone"");
				sprintf(length, ""- no logout"");
",unused,sysvinitpatchxen-src2Flast.c
"			fprintf(stderr, ""%s: out of memory\n"",
				progname);
			exit(1);
		}
		strcpy(altufile, optarg);
",1,unused,628,unused,"			fprintf(stderr, ""%s: out of memory\n"",
				progname);
			exit(1);
		}
		strcpy(altufile, optarg);
",unused,sysvinitpatchxen-src2Flast.c
"
	switch (ut.ut_type) {
		case SHUTDOWN_TIME:
			if (extended) {
				strcpy(ut.ut_line, ""system down"");
",1,unused,807,unused,"
	switch (ut.ut_type) {
		case SHUTDOWN_TIME:
			if (extended) {
				strcpy(ut.ut_line, ""system down"");
",unused,sysvinitpatchxen-src2Flast.c
"			break;
		case OLD_TIME:
		case NEW_TIME:
			if (extended) {
				strcpy(ut.ut_line,
",1,unused,816,unused,"			break;
		case OLD_TIME:
		case NEW_TIME:
			if (extended) {
				strcpy(ut.ut_line,
",unused,sysvinitpatchxen-src2Flast.c
"				quit = list(&ut, lastdown, R_TIMECHANGE);
			}
			break;
		case BOOT_TIME:
			strcpy(ut.ut_line, ""system boot"");
",1,unused,823,unused,"				quit = list(&ut, lastdown, R_TIMECHANGE);
			}
			break;
		case BOOT_TIME:
			strcpy(ut.ut_line, ""system boot"");
",unused,sysvinitpatchxen-src2Flast.c
"			break;
		case RUN_LVL:
			x = ut.ut_pid & 255;
			if (extended) {
				sprintf(ut.ut_line, ""(to lvl %c)"", x);
",1,unused,831,unused,"			break;
		case RUN_LVL:
			x = ut.ut_pid & 255;
			if (extended) {
				sprintf(ut.ut_line, ""(to lvl %c)"", x);
",unused,sysvinitpatchxen-src2Flast.c
"  		fprintf(stderr, ""shutdown: you must be root to do that!\n"");
		usage();
  		exit(1);
	}
	strcpy(down_level, ""1"");
",1,unused,509,unused,"  		fprintf(stderr, ""shutdown: you must be root to do that!\n"");
		usage();
  		exit(1);
	}
	strcpy(down_level, ""1"");
",unused,sysvinitpatchxen-src2Fshutdown.c
"		while(!user_ok && (ut = getutent()) != NULL) {

			/* See if this is a user process on a VC. */
			if (ut->ut_type != USER_PROCESS) continue;
			sprintf(term, ""/dev/%.*s"", UT_LINESIZE, ut->ut_line);
",1,unused,593,unused,"		while(!user_ok && (ut = getutent()) != NULL) {

			/* See if this is a user process on a VC. */
			if (ut->ut_type != USER_PROCESS) continue;
			sprintf(term, ""/dev/%.*s"", UT_LINESIZE, ut->ut_line);
",unused,sysvinitpatchxen-src2Fshutdown.c
"	message[0] = 0;
	for(c = optind + (!cancel && !when); c < argc; c++) {
		if (strlen(message) + strlen(argv[c]) + 4 > MESSAGELEN)
			break;
  		strcat(message, argv[c]);
",1,unused,639,unused,"	message[0] = 0;
	for(c = optind + (!cancel && !when); c < argc; c++) {
		if (strlen(message) + strlen(argv[c]) + 4 > MESSAGELEN)
			break;
  		strcat(message, argv[c]);
",unused,sysvinitpatchxen-src2Fshutdown.c
"	for(c = optind + (!cancel && !when); c < argc; c++) {
		if (strlen(message) + strlen(argv[c]) + 4 > MESSAGELEN)
			break;
  		strcat(message, argv[c]);
  		strcat(message, "" "");
",1,unused,640,unused,"	for(c = optind + (!cancel && !when); c < argc; c++) {
		if (strlen(message) + strlen(argv[c]) + 4 > MESSAGELEN)
			break;
  		strcat(message, argv[c]);
  		strcat(message, "" "");
",unused,sysvinitpatchxen-src2Fshutdown.c
"			break;
  		strcat(message, argv[c]);
  		strcat(message, "" "");
	}
	if (message[0]) strcat(message, ""\r\n"");
",1,unused,642,unused,"			break;
  		strcat(message, argv[c]);
  		strcat(message, "" "");
	}
	if (message[0]) strcat(message, ""\r\n"");
",unused,sysvinitpatchxen-src2Fshutdown.c
"
	/* Tell users what we're gonna do. */
	switch(down_level[0]) {
		case '0':
			strcpy(newstate, ""for system halt"");
",1,unused,682,unused,"
	/* Tell users what we're gonna do. */
	switch(down_level[0]) {
		case '0':
			strcpy(newstate, ""for system halt"");
",unused,sysvinitpatchxen-src2Fshutdown.c
"		case '0':
			strcpy(newstate, ""for system halt"");
			break;
		case '6':
			strcpy(newstate, ""for reboot"");
",1,unused,685,unused,"		case '0':
			strcpy(newstate, ""for system halt"");
			break;
		case '6':
			strcpy(newstate, ""for reboot"");
",unused,sysvinitpatchxen-src2Fshutdown.c
"		case '6':
			strcpy(newstate, ""for reboot"");
			break;
		case '1':
			strcpy(newstate, ""to maintenance mode"");
",1,unused,688,unused,"		case '6':
			strcpy(newstate, ""for reboot"");
			break;
		case '1':
			strcpy(newstate, ""to maintenance mode"");
",unused,sysvinitpatchxen-src2Fshutdown.c
"		case '1':
			strcpy(newstate, ""to maintenance mode"");
			break;
		default:
			sprintf(newstate, ""to runlevel %s"", down_level);
",1,unused,691,unused,"		case '1':
			strcpy(newstate, ""to maintenance mode"");
			break;
		default:
			sprintf(newstate, ""to runlevel %s"", down_level);
",unused,sysvinitpatchxen-src2Fshutdown.c
"	if (fastboot)  close(open(FASTBOOT,  O_CREAT | O_RDWR, 0644));
	if (forcefsck) close(open(FORCEFSCK, O_CREAT | O_RDWR, 0644));

	/* Alias now and take care of old '+mins' notation. */
	if (!strcmp(when, ""now"")) strcpy(when, ""0"");
",1,unused,724,unused,"	if (fastboot)  close(open(FASTBOOT,  O_CREAT | O_RDWR, 0644));
	if (forcefsck) close(open(FORCEFSCK, O_CREAT | O_RDWR, 0644));

	/* Alias now and take care of old '+mins' notation. */
	if (!strcmp(when, ""now"")) strcpy(when, ""0"");
",unused,sysvinitpatchxen-src2Fshutdown.c
"	/*
	 *	The password is invalid. If there is a
	 *	shadow password, try it.
	 */
	strcpy(pwd.pw_passwd, """");
",1,unused,310,unused,"	/*
	 *	The password is invalid. If there is a
	 *	shadow password, try it.
	 */
	strcpy(pwd.pw_passwd, """");
",unused,sysvinitpatchxen-src2Fsulogin.c
"	 *	NULL it, and return.
	 */
	if (p == NULL) {
		fprintf(stderr, ""%s: no entry for root\n"", F_SHADOW);
		strcpy(pwd.pw_passwd, """");
",1,unused,330,unused,"	 *	NULL it, and return.
	 */
	if (p == NULL) {
		fprintf(stderr, ""%s: no entry for root\n"", F_SHADOW);
		strcpy(pwd.pw_passwd, """");
",unused,sysvinitpatchxen-src2Fsulogin.c
"		strcpy(pwd.pw_passwd, """");
	}
	if (!valid(pwd.pw_passwd)) {
		fprintf(stderr, ""%s: root password garbled\n"", F_SHADOW);
		strcpy(pwd.pw_passwd, """"); }
",1,unused,334,unused,"		strcpy(pwd.pw_passwd, """");
	}
	if (!valid(pwd.pw_passwd)) {
		fprintf(stderr, ""%s: root password garbled\n"", F_SHADOW);
		strcpy(pwd.pw_passwd, """"); }
",unused,sysvinitpatchxen-src2Fsulogin.c
"  if ((argc - optind) > 0) {
	for(f = optind; f < argc; f++) {
		len += strlen(argv[f]) + 1;
		if (len >= MAXLEN-2) break;
		strcat(buf, argv[f]);
",1,unused,85,unused,"  if ((argc - optind) > 0) {
	for(f = optind; f < argc; f++) {
		len += strlen(argv[f]) + 1;
		if (len >= MAXLEN-2) break;
		strcat(buf, argv[f]);
",unused,sysvinitpatchxen-src2Fwall.c
"	for(f = optind; f < argc; f++) {
		len += strlen(argv[f]) + 1;
		if (len >= MAXLEN-2) break;
		strcat(buf, argv[f]);
		if (f < argc-1) strcat(buf, "" "");
",1,unused,86,unused,"	for(f = optind; f < argc; f++) {
		len += strlen(argv[f]) + 1;
		if (len >= MAXLEN-2) break;
		strcat(buf, argv[f]);
		if (f < argc-1) strcat(buf, "" "");
",unused,sysvinitpatchxen-src2Fwall.c
"		if (len >= MAXLEN-2) break;
		strcat(buf, argv[f]);
		if (f < argc-1) strcat(buf, "" "");
	}
	strcat(buf, ""\r\n"");
",1,unused,88,unused,"		if (len >= MAXLEN-2) break;
		strcat(buf, argv[f]);
		if (f < argc-1) strcat(buf, "" "");
	}
	strcat(buf, ""\r\n"");
",unused,sysvinitpatchxen-src2Fwall.c
"		 *	Make sure that line ends in \r\n
		 */
		for(p = line; *p && *p != '\r' && *p != '\n'; p++)
			;
		strcpy(p, ""\r\n"");
",1,unused,96,unused,"		 *	Make sure that line ends in \r\n
		 */
		for(p = line; *p && *p != '\r' && *p != '\n'; p++)
			;
		strcpy(p, ""\r\n"");
",unused,sysvinitpatchxen-src2Fwall.c
"			;
		strcpy(p, ""\r\n"");
		len += strlen(line);
		if (len >= MAXLEN) break;
		strcat(buf, line);
",1,unused,99,unused,"			;
		strcpy(p, ""\r\n"");
		len += strlen(line);
		if (len >= MAXLEN) break;
		strcat(buf, line);
",unused,sysvinitpatchxen-src2Fwall.c
"
	for (i = 'p'; i <= 'z'; i++) {
		for (j = '0'; j <= 'f'; j++) {
			if (j == '9' + 1) j = 'a';
			sprintf(pty, ""/dev/pty%c%c"", i, j);
",1,unused,189,unused,"
	for (i = 'p'; i <= 'z'; i++) {
		for (j = '0'; j <= 'f'; j++) {
			if (j == '9' + 1) j = 'a';
			sprintf(pty, ""/dev/pty%c%c"", i, j);
",unused,sysvinitsources-src2Fbootlogd.c
"	for (i = 'p'; i <= 'z'; i++) {
		for (j = '0'; j <= 'f'; j++) {
			if (j == '9' + 1) j = 'a';
			sprintf(pty, ""/dev/pty%c%c"", i, j);
			sprintf(tty, ""/dev/tty%c%c"", i, j);
",1,unused,190,unused,"	for (i = 'p'; i <= 'z'; i++) {
		for (j = '0'; j <= 'f'; j++) {
			if (j == '9' + 1) j = 'a';
			sprintf(pty, ""/dev/pty%c%c"", i, j);
			sprintf(tty, ""/dev/tty%c%c"", i, j);
",unused,sysvinitsources-src2Fbootlogd.c
"		if (found) break;
	}
	if (!found) return -1;

	if (name) strcpy(name, tty);
",1,unused,203,unused,"		if (found) break;
	}
	if (!found) return -1;

	if (name) strcpy(name, tty);
",unused,sysvinitsources-src2Fbootlogd.c
"			didnl = 0;
		}
		switch (*ptr) {
			case 27: /* ESC */
				strcpy(tmp, ""^["");
",1,unused,371,unused,"			didnl = 0;
		}
		switch (*ptr) {
			case 27: /* ESC */
				strcpy(tmp, ""^["");
",unused,sysvinitsources-src2Fbootlogd.c
"				tmp[0] = *ptr;
				tmp[1] = 0;
				break;
			default:
				sprintf(tmp, ""\\%03o"", *ptr);
",1,unused,394,unused,"				tmp[0] = *ptr;
				tmp[1] = 0;
				break;
			default:
				sprintf(tmp, ""\\%03o"", *ptr);
",unused,sysvinitsources-src2Fbootlogd.c
"	if (consolename(realcons, sizeof(realcons)) < 0)
		return 1;

	if (strcmp(realcons, ""/dev/tty0"") == 0)
		strcpy(realcons, ""/dev/tty1"");
",1,unused,535,unused,"	if (consolename(realcons, sizeof(realcons)) < 0)
		return 1;

	if (strcmp(realcons, ""/dev/tty0"") == 0)
		strcpy(realcons, ""/dev/tty1"");
",unused,sysvinitsources-src2Fbootlogd.c
"
	if (strcmp(realcons, ""/dev/tty0"") == 0)
		strcpy(realcons, ""/dev/tty1"");
	if (strcmp(realcons, ""/dev/vc/0"") == 0)
		strcpy(realcons, ""/dev/vc/1"");
",1,unused,537,unused,"
	if (strcmp(realcons, ""/dev/tty0"") == 0)
		strcpy(realcons, ""/dev/tty1"");
	if (strcmp(realcons, ""/dev/vc/0"") == 0)
		strcpy(realcons, ""/dev/vc/1"");
",unused,sysvinitsources-src2Fbootlogd.c
"		if ((pwd = getpwuid(uid)) != NULL) {
			uidbuf[0] = 0;
			strncat(uidbuf, pwd->pw_name, sizeof(uidbuf) - 1);
		} else {
			sprintf(uidbuf, uid ? ""uid %d"" : ""root"", (int)uid);
",1,unused,99,unused,"		if ((pwd = getpwuid(uid)) != NULL) {
			uidbuf[0] = 0;
			strncat(uidbuf, pwd->pw_name, sizeof(uidbuf) - 1);
		} else {
			sprintf(uidbuf, uid ? ""uid %d"" : ""root"", (int)uid);
",unused,sysvinitsources-src2Fdowall.c
"  /* See if we need to fire off a shell for this command */
  	/* Give command line to shell */
  	args[1] = SHELL;
  	args[2] = ""-c"";
  	strcpy(buf, ""exec "");
",1,unused,999,unused,"  /* See if we need to fire off a shell for this command */
  	/* Give command line to shell */
  	args[1] = SHELL;
  	args[2] = ""-c"";
  	strcpy(buf, ""exec "");
",unused,sysvinitsources-src2Finit.c
"  		execvp(args[1], args + 1);
		if (errno == ENOEXEC) {
  			args[1] = SHELL;
  			args[2] = ""-c"";
  			strcpy(buf, ""exec "");
",1,unused,1168,unused,"  		execvp(args[1], args + 1);
		if (errno == ENOEXEC) {
  			args[1] = SHELL;
  			args[2] = ""-c"";
  			strcpy(buf, ""exec "");
",unused,sysvinitsources-src2Finit.c
"	 *	Check if syntax is OK. Be very verbose here, to
	 *	avoid newbie postings on comp.os.linux.setup :)
	 */
	err[0] = 0;
	if (!id || !*id) strcpy(err, ""missing id field"");
",1,unused,1306,unused,"	 *	Check if syntax is OK. Be very verbose here, to
	 *	avoid newbie postings on comp.os.linux.setup :)
	 */
	err[0] = 0;
	if (!id || !*id) strcpy(err, ""missing id field"");
",unused,sysvinitsources-src2Finit.c
"	 *	avoid newbie postings on comp.os.linux.setup :)
	 */
	err[0] = 0;
	if (!id || !*id) strcpy(err, ""missing id field"");
	if (!rlevel)     strcpy(err, ""missing runlevel field"");
",1,unused,1307,unused,"	 *	avoid newbie postings on comp.os.linux.setup :)
	 */
	err[0] = 0;
	if (!id || !*id) strcpy(err, ""missing id field"");
	if (!rlevel)     strcpy(err, ""missing runlevel field"");
",unused,sysvinitsources-src2Finit.c
"	 */
	err[0] = 0;
	if (!id || !*id) strcpy(err, ""missing id field"");
	if (!rlevel)     strcpy(err, ""missing runlevel field"");
	if (!process)    strcpy(err, ""missing process field"");
",1,unused,1308,unused,"	 */
	err[0] = 0;
	if (!id || !*id) strcpy(err, ""missing id field"");
	if (!rlevel)     strcpy(err, ""missing runlevel field"");
	if (!process)    strcpy(err, ""missing process field"");
",unused,sysvinitsources-src2Finit.c
"	if (!id || !*id) strcpy(err, ""missing id field"");
	if (!rlevel)     strcpy(err, ""missing runlevel field"");
	if (!process)    strcpy(err, ""missing process field"");
	if (!action || !*action)
			strcpy(err, ""missing action field"");
",1,unused,1310,unused,"	if (!id || !*id) strcpy(err, ""missing id field"");
	if (!rlevel)     strcpy(err, ""missing runlevel field"");
	if (!process)    strcpy(err, ""missing process field"");
	if (!action || !*action)
			strcpy(err, ""missing action field"");
",unused,sysvinitsources-src2Finit.c
"	if (!process)    strcpy(err, ""missing process field"");
	if (!action || !*action)
			strcpy(err, ""missing action field"");
	if (id && strlen(id) > sizeof(utproto.ut_id))
		sprintf(err, ""id field too long (max %d characters)"",
",1,unused,1312,unused,"	if (!process)    strcpy(err, ""missing process field"");
	if (!action || !*action)
			strcpy(err, ""missing action field"");
	if (id && strlen(id) > sizeof(utproto.ut_id))
		sprintf(err, ""id field too long (max %d characters)"",
",unused,sysvinitsources-src2Finit.c
"	if (id && strlen(id) > sizeof(utproto.ut_id))
		sprintf(err, ""id field too long (max %d characters)"",
			(int)sizeof(utproto.ut_id));
	if (rlevel && strlen(rlevel) > 11)
		strcpy(err, ""rlevel field too long (max 11 characters)"");
",1,unused,1315,unused,"	if (id && strlen(id) > sizeof(utproto.ut_id))
		sprintf(err, ""id field too long (max %d characters)"",
			(int)sizeof(utproto.ut_id));
	if (rlevel && strlen(rlevel) > 11)
		strcpy(err, ""rlevel field too long (max 11 characters)"");
",unused,sysvinitsources-src2Finit.c
"			(int)sizeof(utproto.ut_id));
	if (rlevel && strlen(rlevel) > 11)
		strcpy(err, ""rlevel field too long (max 11 characters)"");
	if (process && strlen(process) > 127)
		strcpy(err, ""process field too long"");
",1,unused,1317,unused,"			(int)sizeof(utproto.ut_id));
	if (rlevel && strlen(rlevel) > 11)
		strcpy(err, ""rlevel field too long (max 11 characters)"");
	if (process && strlen(process) > 127)
		strcpy(err, ""process field too long"");
",unused,sysvinitsources-src2Finit.c
"		strcpy(err, ""rlevel field too long (max 11 characters)"");
	if (process && strlen(process) > 127)
		strcpy(err, ""process field too long"");
	if (action && strlen(action) > 32)
		strcpy(err, ""action field too long"");
",1,unused,1319,unused,"		strcpy(err, ""rlevel field too long (max 11 characters)"");
	if (process && strlen(process) > 127)
		strcpy(err, ""process field too long"");
	if (action && strlen(action) > 32)
		strcpy(err, ""action field too long"");
",unused,sysvinitsources-src2Finit.c
"			if (ch->rlevel[f] == 's') ch->rlevel[f] = 'S';
		}
		strncpy(ch->rlevel, rlevel, sizeof(ch->rlevel) - 1);
	} else {
		strcpy(ch->rlevel, ""0123456789"");
",1,unused,1371,unused,"			if (ch->rlevel[f] == 's') ch->rlevel[f] = 'S';
		}
		strncpy(ch->rlevel, rlevel, sizeof(ch->rlevel) - 1);
	} else {
		strcpy(ch->rlevel, ""0123456789"");
",unused,sysvinitsources-src2Finit.c
"		strncpy(ch->rlevel, rlevel, sizeof(ch->rlevel) - 1);
	} else {
		strcpy(ch->rlevel, ""0123456789"");
		if (ISPOWER(ch->action))
			strcpy(ch->rlevel, ""S0123456789"");
",1,unused,1373,unused,"		strncpy(ch->rlevel, rlevel, sizeof(ch->rlevel) - 1);
	} else {
		strcpy(ch->rlevel, ""0123456789"");
		if (ISPOWER(ch->action))
			strcpy(ch->rlevel, ""S0123456789"");
",unused,sysvinitsources-src2Finit.c
"	/*
	 *	We have the fake runlevel '#' for SYSINIT  and
	 *	'*' for BOOT and BOOTWAIT.
	 */
	if (ch->action == SYSINIT) strcpy(ch->rlevel, ""#"");
",1,unused,1379,unused,"	/*
	 *	We have the fake runlevel '#' for SYSINIT  and
	 *	'*' for BOOT and BOOTWAIT.
	 */
	if (ch->action == SYSINIT) strcpy(ch->rlevel, ""#"");
",unused,sysvinitsources-src2Finit.c
"	 *	'*' for BOOT and BOOTWAIT.
	 */
	if (ch->action == SYSINIT) strcpy(ch->rlevel, ""#"");
	if (ch->action == BOOT || ch->action == BOOTWAIT)
		strcpy(ch->rlevel, ""*"");
",1,unused,1381,unused,"	 *	'*' for BOOT and BOOTWAIT.
	 */
	if (ch->action == SYSINIT) strcpy(ch->rlevel, ""#"");
	if (ch->action == BOOT || ch->action == BOOTWAIT)
		strcpy(ch->rlevel, ""*"");
",unused,sysvinitsources-src2Finit.c
"			p->name = ((char*)p)+alignof(NFS);
			p->nlen = nlen;
			p->shadow = (SHADOW*)0;

			strcpy(p->name, ent->mnt_dir);
",1,unused,265,unused,"			p->name = ((char*)p)+alignof(NFS);
			p->nlen = nlen;
			p->shadow = (SHADOW*)0;

			strcpy(p->name, ent->mnt_dir);
",unused,sysvinitsources-src2Fkillall5.c
"			xmemalign((void*)&s, sizeof(void*), alignof(SHADOW)+(nlen+1));
			s->name = ((char*)s)+alignof(SHADOW);
			s->nlen = nlen;

			strcpy(s->name, ent->mnt_dir);
",1,unused,295,unused,"			xmemalign((void*)&s, sizeof(void*), alignof(SHADOW)+(nlen+1));
			s->name = ((char*)s)+alignof(SHADOW);
			s->nlen = nlen;

			strcpy(s->name, ent->mnt_dir);
",unused,sysvinitsources-src2Fkillall5.c
"		if (deep-- <= 0) return 0;

	} while (1);

	if (real) strcpy(real, curr);
",1,unused,414,unused,"		if (deep-- <= 0) return 0;

	} while (1);

	if (real) strcpy(real, curr);
",unused,sysvinitsources-src2Fkillall5.c
"			}
			*q++ = 0;
			while (*q == ' ') q++;
			p->statname = (char *)xmalloc(strlen(s)+1);
			strcpy(p->statname, s);
",1,unused,528,unused,"			}
			*q++ = 0;
			while (*q == ' ') q++;
			p->statname = (char *)xmalloc(strlen(s)+1);
			strcpy(p->statname, s);
",unused,sysvinitsources-src2Fkillall5.c
"
			if (buf[0]) {
				/* Store the name into malloced memory. */
				p->argv0 = (char *)xmalloc(f + 1);
				strcpy(p->argv0, buf);
",1,unused,567,unused,"
			if (buf[0]) {
				/* Store the name into malloced memory. */
				p->argv0 = (char *)xmalloc(f + 1);
				strcpy(p->argv0, buf);
",unused,sysvinitsources-src2Fkillall5.c
"
			if (buf[0]) {
				/* Store the name into malloced memory. */
				p->argv1 = (char *)xmalloc(f + 1);
				strcpy(p->argv1, buf);
",1,unused,584,unused,"
			if (buf[0]) {
				/* Store the name into malloced memory. */
				p->argv1 = (char *)xmalloc(f + 1);
				strcpy(p->argv1, buf);
",unused,sysvinitsources-src2Fkillall5.c
"{
	static char btmp[128];
	char *p;

	strcpy(btmp, WTMP_FILE);
",1,unused,259,unused,"{
	static char btmp[128];
	char *p;

	strcpy(btmp, WTMP_FILE);
",unused,sysvinitsources-src2Flast.c
"		p = btmp;
	else
		p++;
	*p = 0;
	strcat(btmp, ""btmp"");
",1,unused,265,unused,"		p = btmp;
	else
		p++;
	*p = 0;
	strcat(btmp, ""btmp"");
",unused,sysvinitsources-src2Flast.c
"	/*
	 *	Calculate times
	 */
	tmp = (time_t)p->ut_time;
	strcpy(logintime, ctime(&tmp));
",1,unused,407,unused,"	/*
	 *	Calculate times
	 */
	tmp = (time_t)p->ut_time;
	strcpy(logintime, ctime(&tmp));
",unused,sysvinitsources-src2Flast.c
"	 */
	tmp = (time_t)p->ut_time;
	strcpy(logintime, ctime(&tmp));
	if (fulltime)
		sprintf(logouttime, ""- %s"", ctime(&t));
",1,unused,409,unused,"	 */
	tmp = (time_t)p->ut_time;
	strcpy(logintime, ctime(&tmp));
	if (fulltime)
		sprintf(logouttime, ""- %s"", ctime(&t));
",unused,sysvinitsources-src2Flast.c
"	if (fulltime)
		sprintf(logouttime, ""- %s"", ctime(&t));
	else {
		logintime[16] = 0;
		sprintf(logouttime, ""- %s"", ctime(&t) + 11);
",1,unused,412,unused,"	if (fulltime)
		sprintf(logouttime, ""- %s"", ctime(&t));
	else {
		logintime[16] = 0;
		sprintf(logouttime, ""- %s"", ctime(&t) + 11);
",unused,sysvinitsources-src2Flast.c
"	mins  = (secs / 60) % 60;
	hours = (secs / 3600) % 24;
	days  = secs / 86400;
	if (days)
		sprintf(length, ""(%d+%02d:%02d)"", days, hours, mins);
",1,unused,420,unused,"	mins  = (secs / 60) % 60;
	hours = (secs / 3600) % 24;
	days  = secs / 86400;
	if (days)
		sprintf(length, ""(%d+%02d:%02d)"", days, hours, mins);
",unused,sysvinitsources-src2Flast.c
"	days  = secs / 86400;
	if (days)
		sprintf(length, ""(%d+%02d:%02d)"", days, hours, mins);
	else
		sprintf(length, "" (%02d:%02d)"", hours, mins);
",1,unused,422,unused,"	days  = secs / 86400;
	if (days)
		sprintf(length, ""(%d+%02d:%02d)"", days, hours, mins);
	else
		sprintf(length, "" (%02d:%02d)"", hours, mins);
",unused,sysvinitsources-src2Flast.c
"		sprintf(length, "" (%02d:%02d)"", hours, mins);

	switch(what) {
		case R_CRASH:
			sprintf(logouttime, ""- crash"");
",1,unused,426,unused,"		sprintf(length, "" (%02d:%02d)"", hours, mins);

	switch(what) {
		case R_CRASH:
			sprintf(logouttime, ""- crash"");
",unused,sysvinitsources-src2Flast.c
"		case R_CRASH:
			sprintf(logouttime, ""- crash"");
			break;
		case R_DOWN:
			sprintf(logouttime, ""- down "");
",1,unused,429,unused,"		case R_CRASH:
			sprintf(logouttime, ""- crash"");
			break;
		case R_DOWN:
			sprintf(logouttime, ""- down "");
",unused,sysvinitsources-src2Flast.c
"			break;
		case R_NOW:
			length[0] = 0;
			if (fulltime)
				sprintf(logouttime, ""  still logged in"");
",1,unused,434,unused,"			break;
		case R_NOW:
			length[0] = 0;
			if (fulltime)
				sprintf(logouttime, ""  still logged in"");
",unused,sysvinitsources-src2Flast.c
"			length[0] = 0;
			if (fulltime)
				sprintf(logouttime, ""  still logged in"");
			else {
				sprintf(logouttime, ""  still"");
",1,unused,436,unused,"			length[0] = 0;
			if (fulltime)
				sprintf(logouttime, ""  still logged in"");
			else {
				sprintf(logouttime, ""  still"");
",unused,sysvinitsources-src2Flast.c
"			if (fulltime)
				sprintf(logouttime, ""  still logged in"");
			else {
				sprintf(logouttime, ""  still"");
				sprintf(length, ""logged in"");
",1,unused,437,unused,"			if (fulltime)
				sprintf(logouttime, ""  still logged in"");
			else {
				sprintf(logouttime, ""  still"");
				sprintf(length, ""logged in"");
",unused,sysvinitsources-src2Flast.c
"			break;
		case R_PHANTOM:
			length[0] = 0;
			if (fulltime)
				sprintf(logouttime, ""  gone - no logout"");
",1,unused,443,unused,"			break;
		case R_PHANTOM:
			length[0] = 0;
			if (fulltime)
				sprintf(logouttime, ""  gone - no logout"");
",unused,sysvinitsources-src2Flast.c
"			length[0] = 0;
			if (fulltime)
				sprintf(logouttime, ""  gone - no logout"");
			else {
				sprintf(logouttime, ""   gone"");
",1,unused,445,unused,"			length[0] = 0;
			if (fulltime)
				sprintf(logouttime, ""  gone - no logout"");
			else {
				sprintf(logouttime, ""   gone"");
",unused,sysvinitsources-src2Flast.c
"			if (fulltime)
				sprintf(logouttime, ""  gone - no logout"");
			else {
				sprintf(logouttime, ""   gone"");
				sprintf(length, ""- no logout"");
",1,unused,446,unused,"			if (fulltime)
				sprintf(logouttime, ""  gone - no logout"");
			else {
				sprintf(logouttime, ""   gone"");
				sprintf(length, ""- no logout"");
",unused,sysvinitsources-src2Flast.c
"			fprintf(stderr, ""%s: out of memory\n"",
				progname);
			exit(1);
		}
		strcpy(altufile, optarg);
",1,unused,628,unused,"			fprintf(stderr, ""%s: out of memory\n"",
				progname);
			exit(1);
		}
		strcpy(altufile, optarg);
",unused,sysvinitsources-src2Flast.c
"
	switch (ut.ut_type) {
		case SHUTDOWN_TIME:
			if (extended) {
				strcpy(ut.ut_line, ""system down"");
",1,unused,807,unused,"
	switch (ut.ut_type) {
		case SHUTDOWN_TIME:
			if (extended) {
				strcpy(ut.ut_line, ""system down"");
",unused,sysvinitsources-src2Flast.c
"			break;
		case OLD_TIME:
		case NEW_TIME:
			if (extended) {
				strcpy(ut.ut_line,
",1,unused,816,unused,"			break;
		case OLD_TIME:
		case NEW_TIME:
			if (extended) {
				strcpy(ut.ut_line,
",unused,sysvinitsources-src2Flast.c
"				quit = list(&ut, lastdown, R_TIMECHANGE);
			}
			break;
		case BOOT_TIME:
			strcpy(ut.ut_line, ""system boot"");
",1,unused,823,unused,"				quit = list(&ut, lastdown, R_TIMECHANGE);
			}
			break;
		case BOOT_TIME:
			strcpy(ut.ut_line, ""system boot"");
",unused,sysvinitsources-src2Flast.c
"			break;
		case RUN_LVL:
			x = ut.ut_pid & 255;
			if (extended) {
				sprintf(ut.ut_line, ""(to lvl %c)"", x);
",1,unused,831,unused,"			break;
		case RUN_LVL:
			x = ut.ut_pid & 255;
			if (extended) {
				sprintf(ut.ut_line, ""(to lvl %c)"", x);
",unused,sysvinitsources-src2Flast.c
"	}

	memset(buf, 0, sizeof(buf));
	strncpy(buf, path, sizeof(buf) - 4);
	strcat(buf, ""/.."");
",1,unused,115,unused,"	}

	memset(buf, 0, sizeof(buf));
	strncpy(buf, path, sizeof(buf) - 4);
	strcat(buf, ""/.."");
",unused,sysvinitsources-src2Fmountpoint.c
"  		fprintf(stderr, ""shutdown: you must be root to do that!\n"");
		usage();
  		exit(1);
	}
	strcpy(down_level, ""1"");
",1,unused,509,unused,"  		fprintf(stderr, ""shutdown: you must be root to do that!\n"");
		usage();
  		exit(1);
	}
	strcpy(down_level, ""1"");
",unused,sysvinitsources-src2Fshutdown.c
"		while(!user_ok && (ut = getutent()) != NULL) {

			/* See if this is a user process on a VC. */
			if (ut->ut_type != USER_PROCESS) continue;
			sprintf(term, ""/dev/%.*s"", UT_LINESIZE, ut->ut_line);
",1,unused,593,unused,"		while(!user_ok && (ut = getutent()) != NULL) {

			/* See if this is a user process on a VC. */
			if (ut->ut_type != USER_PROCESS) continue;
			sprintf(term, ""/dev/%.*s"", UT_LINESIZE, ut->ut_line);
",unused,sysvinitsources-src2Fshutdown.c
"	message[0] = 0;
	for(c = optind + (!cancel && !when); c < argc; c++) {
		if (strlen(message) + strlen(argv[c]) + 4 > MESSAGELEN)
			break;
  		strcat(message, argv[c]);
",1,unused,639,unused,"	message[0] = 0;
	for(c = optind + (!cancel && !when); c < argc; c++) {
		if (strlen(message) + strlen(argv[c]) + 4 > MESSAGELEN)
			break;
  		strcat(message, argv[c]);
",unused,sysvinitsources-src2Fshutdown.c
"	for(c = optind + (!cancel && !when); c < argc; c++) {
		if (strlen(message) + strlen(argv[c]) + 4 > MESSAGELEN)
			break;
  		strcat(message, argv[c]);
  		strcat(message, "" "");
",1,unused,640,unused,"	for(c = optind + (!cancel && !when); c < argc; c++) {
		if (strlen(message) + strlen(argv[c]) + 4 > MESSAGELEN)
			break;
  		strcat(message, argv[c]);
  		strcat(message, "" "");
",unused,sysvinitsources-src2Fshutdown.c
"			break;
  		strcat(message, argv[c]);
  		strcat(message, "" "");
	}
	if (message[0]) strcat(message, ""\r\n"");
",1,unused,642,unused,"			break;
  		strcat(message, argv[c]);
  		strcat(message, "" "");
	}
	if (message[0]) strcat(message, ""\r\n"");
",unused,sysvinitsources-src2Fshutdown.c
"
	/* Tell users what we're gonna do. */
	switch(down_level[0]) {
		case '0':
			strcpy(newstate, ""for system halt"");
",1,unused,682,unused,"
	/* Tell users what we're gonna do. */
	switch(down_level[0]) {
		case '0':
			strcpy(newstate, ""for system halt"");
",unused,sysvinitsources-src2Fshutdown.c
"		case '0':
			strcpy(newstate, ""for system halt"");
			break;
		case '6':
			strcpy(newstate, ""for reboot"");
",1,unused,685,unused,"		case '0':
			strcpy(newstate, ""for system halt"");
			break;
		case '6':
			strcpy(newstate, ""for reboot"");
",unused,sysvinitsources-src2Fshutdown.c
"		case '6':
			strcpy(newstate, ""for reboot"");
			break;
		case '1':
			strcpy(newstate, ""to maintenance mode"");
",1,unused,688,unused,"		case '6':
			strcpy(newstate, ""for reboot"");
			break;
		case '1':
			strcpy(newstate, ""to maintenance mode"");
",unused,sysvinitsources-src2Fshutdown.c
"		case '1':
			strcpy(newstate, ""to maintenance mode"");
			break;
		default:
			sprintf(newstate, ""to runlevel %s"", down_level);
",1,unused,691,unused,"		case '1':
			strcpy(newstate, ""to maintenance mode"");
			break;
		default:
			sprintf(newstate, ""to runlevel %s"", down_level);
",unused,sysvinitsources-src2Fshutdown.c
"	if (fastboot)  close(open(FASTBOOT,  O_CREAT | O_RDWR, 0644));
	if (forcefsck) close(open(FORCEFSCK, O_CREAT | O_RDWR, 0644));

	/* Alias now and take care of old '+mins' notation. */
	if (!strcmp(when, ""now"")) strcpy(when, ""0"");
",1,unused,724,unused,"	if (fastboot)  close(open(FASTBOOT,  O_CREAT | O_RDWR, 0644));
	if (forcefsck) close(open(FORCEFSCK, O_CREAT | O_RDWR, 0644));

	/* Alias now and take care of old '+mins' notation. */
	if (!strcmp(when, ""now"")) strcpy(when, ""0"");
",unused,sysvinitsources-src2Fshutdown.c
"	/*
	 *	The password is invalid. If there is a
	 *	shadow password, try it.
	 */
	strcpy(pwd.pw_passwd, """");
",1,unused,310,unused,"	/*
	 *	The password is invalid. If there is a
	 *	shadow password, try it.
	 */
	strcpy(pwd.pw_passwd, """");
",unused,sysvinitsources-src2Fsulogin.c
"	 *	NULL it, and return.
	 */
	if (p == NULL) {
		fprintf(stderr, ""%s: no entry for root\n"", F_SHADOW);
		strcpy(pwd.pw_passwd, """");
",1,unused,330,unused,"	 *	NULL it, and return.
	 */
	if (p == NULL) {
		fprintf(stderr, ""%s: no entry for root\n"", F_SHADOW);
		strcpy(pwd.pw_passwd, """");
",unused,sysvinitsources-src2Fsulogin.c
"		strcpy(pwd.pw_passwd, """");
	}
	if (!valid(pwd.pw_passwd)) {
		fprintf(stderr, ""%s: root password garbled\n"", F_SHADOW);
		strcpy(pwd.pw_passwd, """"); }
",1,unused,334,unused,"		strcpy(pwd.pw_passwd, """");
	}
	if (!valid(pwd.pw_passwd)) {
		fprintf(stderr, ""%s: root password garbled\n"", F_SHADOW);
		strcpy(pwd.pw_passwd, """"); }
",unused,sysvinitsources-src2Fsulogin.c
"  if ((argc - optind) > 0) {
	for(f = optind; f < argc; f++) {
		len += strlen(argv[f]) + 1;
		if (len >= MAXLEN-2) break;
		strcat(buf, argv[f]);
",1,unused,85,unused,"  if ((argc - optind) > 0) {
	for(f = optind; f < argc; f++) {
		len += strlen(argv[f]) + 1;
		if (len >= MAXLEN-2) break;
		strcat(buf, argv[f]);
",unused,sysvinitsources-src2Fwall.c
"	for(f = optind; f < argc; f++) {
		len += strlen(argv[f]) + 1;
		if (len >= MAXLEN-2) break;
		strcat(buf, argv[f]);
		if (f < argc-1) strcat(buf, "" "");
",1,unused,86,unused,"	for(f = optind; f < argc; f++) {
		len += strlen(argv[f]) + 1;
		if (len >= MAXLEN-2) break;
		strcat(buf, argv[f]);
		if (f < argc-1) strcat(buf, "" "");
",unused,sysvinitsources-src2Fwall.c
"		if (len >= MAXLEN-2) break;
		strcat(buf, argv[f]);
		if (f < argc-1) strcat(buf, "" "");
	}
	strcat(buf, ""\r\n"");
",1,unused,88,unused,"		if (len >= MAXLEN-2) break;
		strcat(buf, argv[f]);
		if (f < argc-1) strcat(buf, "" "");
	}
	strcat(buf, ""\r\n"");
",unused,sysvinitsources-src2Fwall.c
"		 *	Make sure that line ends in \r\n
		 */
		for(p = line; *p && *p != '\r' && *p != '\n'; p++)
			;
		strcpy(p, ""\r\n"");
",1,unused,96,unused,"		 *	Make sure that line ends in \r\n
		 */
		for(p = line; *p && *p != '\r' && *p != '\n'; p++)
			;
		strcpy(p, ""\r\n"");
",unused,sysvinitsources-src2Fwall.c
"			;
		strcpy(p, ""\r\n"");
		len += strlen(line);
		if (len >= MAXLEN) break;
		strcat(buf, line);
",1,unused,99,unused,"			;
		strcpy(p, ""\r\n"");
		len += strlen(line);
		if (len >= MAXLEN) break;
		strcat(buf, line);
",unused,sysvinitsources-src2Fwall.c
"
	for (i = 'p'; i <= 'z'; i++) {
		for (j = '0'; j <= 'f'; j++) {
			if (j == '9' + 1) j = 'a';
			sprintf(pty, ""/dev/pty%c%c"", i, j);
",1,unused,189,unused,"
	for (i = 'p'; i <= 'z'; i++) {
		for (j = '0'; j <= 'f'; j++) {
			if (j == '9' + 1) j = 'a';
			sprintf(pty, ""/dev/pty%c%c"", i, j);
",unused,sysvinittrusty-src2Fbootlogd.c
"	for (i = 'p'; i <= 'z'; i++) {
		for (j = '0'; j <= 'f'; j++) {
			if (j == '9' + 1) j = 'a';
			sprintf(pty, ""/dev/pty%c%c"", i, j);
			sprintf(tty, ""/dev/tty%c%c"", i, j);
",1,unused,190,unused,"	for (i = 'p'; i <= 'z'; i++) {
		for (j = '0'; j <= 'f'; j++) {
			if (j == '9' + 1) j = 'a';
			sprintf(pty, ""/dev/pty%c%c"", i, j);
			sprintf(tty, ""/dev/tty%c%c"", i, j);
",unused,sysvinittrusty-src2Fbootlogd.c
"		if (found) break;
	}
	if (!found) return -1;

	if (name) strcpy(name, tty);
",1,unused,203,unused,"		if (found) break;
	}
	if (!found) return -1;

	if (name) strcpy(name, tty);
",unused,sysvinittrusty-src2Fbootlogd.c
"			didnl = 0;
		}
		switch (*ptr) {
			case 27: /* ESC */
				strcpy(tmp, ""^["");
",1,unused,371,unused,"			didnl = 0;
		}
		switch (*ptr) {
			case 27: /* ESC */
				strcpy(tmp, ""^["");
",unused,sysvinittrusty-src2Fbootlogd.c
"				tmp[0] = *ptr;
				tmp[1] = 0;
				break;
			default:
				sprintf(tmp, ""\\%03o"", *ptr);
",1,unused,394,unused,"				tmp[0] = *ptr;
				tmp[1] = 0;
				break;
			default:
				sprintf(tmp, ""\\%03o"", *ptr);
",unused,sysvinittrusty-src2Fbootlogd.c
"	if (consolename(realcons, sizeof(realcons)) < 0)
		return 1;

	if (strcmp(realcons, ""/dev/tty0"") == 0)
		strcpy(realcons, ""/dev/tty1"");
",1,unused,535,unused,"	if (consolename(realcons, sizeof(realcons)) < 0)
		return 1;

	if (strcmp(realcons, ""/dev/tty0"") == 0)
		strcpy(realcons, ""/dev/tty1"");
",unused,sysvinittrusty-src2Fbootlogd.c
"
	if (strcmp(realcons, ""/dev/tty0"") == 0)
		strcpy(realcons, ""/dev/tty1"");
	if (strcmp(realcons, ""/dev/vc/0"") == 0)
		strcpy(realcons, ""/dev/vc/1"");
",1,unused,537,unused,"
	if (strcmp(realcons, ""/dev/tty0"") == 0)
		strcpy(realcons, ""/dev/tty1"");
	if (strcmp(realcons, ""/dev/vc/0"") == 0)
		strcpy(realcons, ""/dev/vc/1"");
",unused,sysvinittrusty-src2Fbootlogd.c
"		if ((pwd = getpwuid(uid)) != NULL) {
			uidbuf[0] = 0;
			strncat(uidbuf, pwd->pw_name, sizeof(uidbuf) - 1);
		} else {
			sprintf(uidbuf, uid ? ""uid %d"" : ""root"", (int)uid);
",1,unused,99,unused,"		if ((pwd = getpwuid(uid)) != NULL) {
			uidbuf[0] = 0;
			strncat(uidbuf, pwd->pw_name, sizeof(uidbuf) - 1);
		} else {
			sprintf(uidbuf, uid ? ""uid %d"" : ""root"", (int)uid);
",unused,sysvinittrusty-src2Fdowall.c
"  /* See if we need to fire off a shell for this command */
  	/* Give command line to shell */
  	args[1] = SHELL;
  	args[2] = ""-c"";
  	strcpy(buf, ""exec "");
",1,unused,999,unused,"  /* See if we need to fire off a shell for this command */
  	/* Give command line to shell */
  	args[1] = SHELL;
  	args[2] = ""-c"";
  	strcpy(buf, ""exec "");
",unused,sysvinittrusty-src2Finit.c
"  		execvp(args[1], args + 1);
		if (errno == ENOEXEC) {
  			args[1] = SHELL;
  			args[2] = ""-c"";
  			strcpy(buf, ""exec "");
",1,unused,1168,unused,"  		execvp(args[1], args + 1);
		if (errno == ENOEXEC) {
  			args[1] = SHELL;
  			args[2] = ""-c"";
  			strcpy(buf, ""exec "");
",unused,sysvinittrusty-src2Finit.c
"	 *	Check if syntax is OK. Be very verbose here, to
	 *	avoid newbie postings on comp.os.linux.setup :)
	 */
	err[0] = 0;
	if (!id || !*id) strcpy(err, ""missing id field"");
",1,unused,1306,unused,"	 *	Check if syntax is OK. Be very verbose here, to
	 *	avoid newbie postings on comp.os.linux.setup :)
	 */
	err[0] = 0;
	if (!id || !*id) strcpy(err, ""missing id field"");
",unused,sysvinittrusty-src2Finit.c
"	 *	avoid newbie postings on comp.os.linux.setup :)
	 */
	err[0] = 0;
	if (!id || !*id) strcpy(err, ""missing id field"");
	if (!rlevel)     strcpy(err, ""missing runlevel field"");
",1,unused,1307,unused,"	 *	avoid newbie postings on comp.os.linux.setup :)
	 */
	err[0] = 0;
	if (!id || !*id) strcpy(err, ""missing id field"");
	if (!rlevel)     strcpy(err, ""missing runlevel field"");
",unused,sysvinittrusty-src2Finit.c
"	 */
	err[0] = 0;
	if (!id || !*id) strcpy(err, ""missing id field"");
	if (!rlevel)     strcpy(err, ""missing runlevel field"");
	if (!process)    strcpy(err, ""missing process field"");
",1,unused,1308,unused,"	 */
	err[0] = 0;
	if (!id || !*id) strcpy(err, ""missing id field"");
	if (!rlevel)     strcpy(err, ""missing runlevel field"");
	if (!process)    strcpy(err, ""missing process field"");
",unused,sysvinittrusty-src2Finit.c
"	if (!id || !*id) strcpy(err, ""missing id field"");
	if (!rlevel)     strcpy(err, ""missing runlevel field"");
	if (!process)    strcpy(err, ""missing process field"");
	if (!action || !*action)
			strcpy(err, ""missing action field"");
",1,unused,1310,unused,"	if (!id || !*id) strcpy(err, ""missing id field"");
	if (!rlevel)     strcpy(err, ""missing runlevel field"");
	if (!process)    strcpy(err, ""missing process field"");
	if (!action || !*action)
			strcpy(err, ""missing action field"");
",unused,sysvinittrusty-src2Finit.c
"	if (!process)    strcpy(err, ""missing process field"");
	if (!action || !*action)
			strcpy(err, ""missing action field"");
	if (id && strlen(id) > sizeof(utproto.ut_id))
		sprintf(err, ""id field too long (max %d characters)"",
",1,unused,1312,unused,"	if (!process)    strcpy(err, ""missing process field"");
	if (!action || !*action)
			strcpy(err, ""missing action field"");
	if (id && strlen(id) > sizeof(utproto.ut_id))
		sprintf(err, ""id field too long (max %d characters)"",
",unused,sysvinittrusty-src2Finit.c
"	if (id && strlen(id) > sizeof(utproto.ut_id))
		sprintf(err, ""id field too long (max %d characters)"",
			(int)sizeof(utproto.ut_id));
	if (rlevel && strlen(rlevel) > 11)
		strcpy(err, ""rlevel field too long (max 11 characters)"");
",1,unused,1315,unused,"	if (id && strlen(id) > sizeof(utproto.ut_id))
		sprintf(err, ""id field too long (max %d characters)"",
			(int)sizeof(utproto.ut_id));
	if (rlevel && strlen(rlevel) > 11)
		strcpy(err, ""rlevel field too long (max 11 characters)"");
",unused,sysvinittrusty-src2Finit.c
"			(int)sizeof(utproto.ut_id));
	if (rlevel && strlen(rlevel) > 11)
		strcpy(err, ""rlevel field too long (max 11 characters)"");
	if (process && strlen(process) > 127)
		strcpy(err, ""process field too long"");
",1,unused,1317,unused,"			(int)sizeof(utproto.ut_id));
	if (rlevel && strlen(rlevel) > 11)
		strcpy(err, ""rlevel field too long (max 11 characters)"");
	if (process && strlen(process) > 127)
		strcpy(err, ""process field too long"");
",unused,sysvinittrusty-src2Finit.c
"		strcpy(err, ""rlevel field too long (max 11 characters)"");
	if (process && strlen(process) > 127)
		strcpy(err, ""process field too long"");
	if (action && strlen(action) > 32)
		strcpy(err, ""action field too long"");
",1,unused,1319,unused,"		strcpy(err, ""rlevel field too long (max 11 characters)"");
	if (process && strlen(process) > 127)
		strcpy(err, ""process field too long"");
	if (action && strlen(action) > 32)
		strcpy(err, ""action field too long"");
",unused,sysvinittrusty-src2Finit.c
"			if (ch->rlevel[f] == 's') ch->rlevel[f] = 'S';
		}
		strncpy(ch->rlevel, rlevel, sizeof(ch->rlevel) - 1);
	} else {
		strcpy(ch->rlevel, ""0123456789"");
",1,unused,1371,unused,"			if (ch->rlevel[f] == 's') ch->rlevel[f] = 'S';
		}
		strncpy(ch->rlevel, rlevel, sizeof(ch->rlevel) - 1);
	} else {
		strcpy(ch->rlevel, ""0123456789"");
",unused,sysvinittrusty-src2Finit.c
"		strncpy(ch->rlevel, rlevel, sizeof(ch->rlevel) - 1);
	} else {
		strcpy(ch->rlevel, ""0123456789"");
		if (ISPOWER(ch->action))
			strcpy(ch->rlevel, ""S0123456789"");
",1,unused,1373,unused,"		strncpy(ch->rlevel, rlevel, sizeof(ch->rlevel) - 1);
	} else {
		strcpy(ch->rlevel, ""0123456789"");
		if (ISPOWER(ch->action))
			strcpy(ch->rlevel, ""S0123456789"");
",unused,sysvinittrusty-src2Finit.c
"	/*
	 *	We have the fake runlevel '#' for SYSINIT  and
	 *	'*' for BOOT and BOOTWAIT.
	 */
	if (ch->action == SYSINIT) strcpy(ch->rlevel, ""#"");
",1,unused,1379,unused,"	/*
	 *	We have the fake runlevel '#' for SYSINIT  and
	 *	'*' for BOOT and BOOTWAIT.
	 */
	if (ch->action == SYSINIT) strcpy(ch->rlevel, ""#"");
",unused,sysvinittrusty-src2Finit.c
"	 *	'*' for BOOT and BOOTWAIT.
	 */
	if (ch->action == SYSINIT) strcpy(ch->rlevel, ""#"");
	if (ch->action == BOOT || ch->action == BOOTWAIT)
		strcpy(ch->rlevel, ""*"");
",1,unused,1381,unused,"	 *	'*' for BOOT and BOOTWAIT.
	 */
	if (ch->action == SYSINIT) strcpy(ch->rlevel, ""#"");
	if (ch->action == BOOT || ch->action == BOOTWAIT)
		strcpy(ch->rlevel, ""*"");
",unused,sysvinittrusty-src2Finit.c
"			p->name = ((char*)p)+alignof(NFS);
			p->nlen = nlen;
			p->shadow = (SHADOW*)0;

			strcpy(p->name, ent->mnt_dir);
",1,unused,265,unused,"			p->name = ((char*)p)+alignof(NFS);
			p->nlen = nlen;
			p->shadow = (SHADOW*)0;

			strcpy(p->name, ent->mnt_dir);
",unused,sysvinittrusty-src2Fkillall5.c
"			xmemalign((void*)&s, sizeof(void*), alignof(SHADOW)+(nlen+1));
			s->name = ((char*)s)+alignof(SHADOW);
			s->nlen = nlen;

			strcpy(s->name, ent->mnt_dir);
",1,unused,295,unused,"			xmemalign((void*)&s, sizeof(void*), alignof(SHADOW)+(nlen+1));
			s->name = ((char*)s)+alignof(SHADOW);
			s->nlen = nlen;

			strcpy(s->name, ent->mnt_dir);
",unused,sysvinittrusty-src2Fkillall5.c
"		if (deep-- <= 0) return 0;

	} while (1);

	if (real) strcpy(real, curr);
",1,unused,414,unused,"		if (deep-- <= 0) return 0;

	} while (1);

	if (real) strcpy(real, curr);
",unused,sysvinittrusty-src2Fkillall5.c
"			}
			*q++ = 0;
			while (*q == ' ') q++;
			p->statname = (char *)xmalloc(strlen(s)+1);
			strcpy(p->statname, s);
",1,unused,528,unused,"			}
			*q++ = 0;
			while (*q == ' ') q++;
			p->statname = (char *)xmalloc(strlen(s)+1);
			strcpy(p->statname, s);
",unused,sysvinittrusty-src2Fkillall5.c
"
			if (buf[0]) {
				/* Store the name into malloced memory. */
				p->argv0 = (char *)xmalloc(f + 1);
				strcpy(p->argv0, buf);
",1,unused,567,unused,"
			if (buf[0]) {
				/* Store the name into malloced memory. */
				p->argv0 = (char *)xmalloc(f + 1);
				strcpy(p->argv0, buf);
",unused,sysvinittrusty-src2Fkillall5.c
"
			if (buf[0]) {
				/* Store the name into malloced memory. */
				p->argv1 = (char *)xmalloc(f + 1);
				strcpy(p->argv1, buf);
",1,unused,584,unused,"
			if (buf[0]) {
				/* Store the name into malloced memory. */
				p->argv1 = (char *)xmalloc(f + 1);
				strcpy(p->argv1, buf);
",unused,sysvinittrusty-src2Fkillall5.c
"{
	static char btmp[128];
	char *p;

	strcpy(btmp, WTMP_FILE);
",1,unused,259,unused,"{
	static char btmp[128];
	char *p;

	strcpy(btmp, WTMP_FILE);
",unused,sysvinittrusty-src2Flast.c
"		p = btmp;
	else
		p++;
	*p = 0;
	strcat(btmp, ""btmp"");
",1,unused,265,unused,"		p = btmp;
	else
		p++;
	*p = 0;
	strcat(btmp, ""btmp"");
",unused,sysvinittrusty-src2Flast.c
"	/*
	 *	Calculate times
	 */
	tmp = (time_t)p->ut_time;
	strcpy(logintime, ctime(&tmp));
",1,unused,407,unused,"	/*
	 *	Calculate times
	 */
	tmp = (time_t)p->ut_time;
	strcpy(logintime, ctime(&tmp));
",unused,sysvinittrusty-src2Flast.c
"	 */
	tmp = (time_t)p->ut_time;
	strcpy(logintime, ctime(&tmp));
	if (fulltime)
		sprintf(logouttime, ""- %s"", ctime(&t));
",1,unused,409,unused,"	 */
	tmp = (time_t)p->ut_time;
	strcpy(logintime, ctime(&tmp));
	if (fulltime)
		sprintf(logouttime, ""- %s"", ctime(&t));
",unused,sysvinittrusty-src2Flast.c
"	if (fulltime)
		sprintf(logouttime, ""- %s"", ctime(&t));
	else {
		logintime[16] = 0;
		sprintf(logouttime, ""- %s"", ctime(&t) + 11);
",1,unused,412,unused,"	if (fulltime)
		sprintf(logouttime, ""- %s"", ctime(&t));
	else {
		logintime[16] = 0;
		sprintf(logouttime, ""- %s"", ctime(&t) + 11);
",unused,sysvinittrusty-src2Flast.c
"	mins  = (secs / 60) % 60;
	hours = (secs / 3600) % 24;
	days  = secs / 86400;
	if (days)
		sprintf(length, ""(%d+%02d:%02d)"", days, hours, mins);
",1,unused,420,unused,"	mins  = (secs / 60) % 60;
	hours = (secs / 3600) % 24;
	days  = secs / 86400;
	if (days)
		sprintf(length, ""(%d+%02d:%02d)"", days, hours, mins);
",unused,sysvinittrusty-src2Flast.c
"	days  = secs / 86400;
	if (days)
		sprintf(length, ""(%d+%02d:%02d)"", days, hours, mins);
	else
		sprintf(length, "" (%02d:%02d)"", hours, mins);
",1,unused,422,unused,"	days  = secs / 86400;
	if (days)
		sprintf(length, ""(%d+%02d:%02d)"", days, hours, mins);
	else
		sprintf(length, "" (%02d:%02d)"", hours, mins);
",unused,sysvinittrusty-src2Flast.c
"		sprintf(length, "" (%02d:%02d)"", hours, mins);

	switch(what) {
		case R_CRASH:
			sprintf(logouttime, ""- crash"");
",1,unused,426,unused,"		sprintf(length, "" (%02d:%02d)"", hours, mins);

	switch(what) {
		case R_CRASH:
			sprintf(logouttime, ""- crash"");
",unused,sysvinittrusty-src2Flast.c
"		case R_CRASH:
			sprintf(logouttime, ""- crash"");
			break;
		case R_DOWN:
			sprintf(logouttime, ""- down "");
",1,unused,429,unused,"		case R_CRASH:
			sprintf(logouttime, ""- crash"");
			break;
		case R_DOWN:
			sprintf(logouttime, ""- down "");
",unused,sysvinittrusty-src2Flast.c
"			break;
		case R_NOW:
			length[0] = 0;
			if (fulltime)
				sprintf(logouttime, ""  still logged in"");
",1,unused,434,unused,"			break;
		case R_NOW:
			length[0] = 0;
			if (fulltime)
				sprintf(logouttime, ""  still logged in"");
",unused,sysvinittrusty-src2Flast.c
"			length[0] = 0;
			if (fulltime)
				sprintf(logouttime, ""  still logged in"");
			else {
				sprintf(logouttime, ""  still"");
",1,unused,436,unused,"			length[0] = 0;
			if (fulltime)
				sprintf(logouttime, ""  still logged in"");
			else {
				sprintf(logouttime, ""  still"");
",unused,sysvinittrusty-src2Flast.c
"			if (fulltime)
				sprintf(logouttime, ""  still logged in"");
			else {
				sprintf(logouttime, ""  still"");
				sprintf(length, ""logged in"");
",1,unused,437,unused,"			if (fulltime)
				sprintf(logouttime, ""  still logged in"");
			else {
				sprintf(logouttime, ""  still"");
				sprintf(length, ""logged in"");
",unused,sysvinittrusty-src2Flast.c
"			break;
		case R_PHANTOM:
			length[0] = 0;
			if (fulltime)
				sprintf(logouttime, ""  gone - no logout"");
",1,unused,443,unused,"			break;
		case R_PHANTOM:
			length[0] = 0;
			if (fulltime)
				sprintf(logouttime, ""  gone - no logout"");
",unused,sysvinittrusty-src2Flast.c
"			length[0] = 0;
			if (fulltime)
				sprintf(logouttime, ""  gone - no logout"");
			else {
				sprintf(logouttime, ""   gone"");
",1,unused,445,unused,"			length[0] = 0;
			if (fulltime)
				sprintf(logouttime, ""  gone - no logout"");
			else {
				sprintf(logouttime, ""   gone"");
",unused,sysvinittrusty-src2Flast.c
"			if (fulltime)
				sprintf(logouttime, ""  gone - no logout"");
			else {
				sprintf(logouttime, ""   gone"");
				sprintf(length, ""- no logout"");
",1,unused,446,unused,"			if (fulltime)
				sprintf(logouttime, ""  gone - no logout"");
			else {
				sprintf(logouttime, ""   gone"");
				sprintf(length, ""- no logout"");
",unused,sysvinittrusty-src2Flast.c
"			fprintf(stderr, ""%s: out of memory\n"",
				progname);
			exit(1);
		}
		strcpy(altufile, optarg);
",1,unused,628,unused,"			fprintf(stderr, ""%s: out of memory\n"",
				progname);
			exit(1);
		}
		strcpy(altufile, optarg);
",unused,sysvinittrusty-src2Flast.c
"
	switch (ut.ut_type) {
		case SHUTDOWN_TIME:
			if (extended) {
				strcpy(ut.ut_line, ""system down"");
",1,unused,807,unused,"
	switch (ut.ut_type) {
		case SHUTDOWN_TIME:
			if (extended) {
				strcpy(ut.ut_line, ""system down"");
",unused,sysvinittrusty-src2Flast.c
"			break;
		case OLD_TIME:
		case NEW_TIME:
			if (extended) {
				strcpy(ut.ut_line,
",1,unused,816,unused,"			break;
		case OLD_TIME:
		case NEW_TIME:
			if (extended) {
				strcpy(ut.ut_line,
",unused,sysvinittrusty-src2Flast.c
"				quit = list(&ut, lastdown, R_TIMECHANGE);
			}
			break;
		case BOOT_TIME:
			strcpy(ut.ut_line, ""system boot"");
",1,unused,823,unused,"				quit = list(&ut, lastdown, R_TIMECHANGE);
			}
			break;
		case BOOT_TIME:
			strcpy(ut.ut_line, ""system boot"");
",unused,sysvinittrusty-src2Flast.c
"			break;
		case RUN_LVL:
			x = ut.ut_pid & 255;
			if (extended) {
				sprintf(ut.ut_line, ""(to lvl %c)"", x);
",1,unused,831,unused,"			break;
		case RUN_LVL:
			x = ut.ut_pid & 255;
			if (extended) {
				sprintf(ut.ut_line, ""(to lvl %c)"", x);
",unused,sysvinittrusty-src2Flast.c
"	}

	memset(buf, 0, sizeof(buf));
	strncpy(buf, path, sizeof(buf) - 4);
	strcat(buf, ""/.."");
",1,unused,115,unused,"	}

	memset(buf, 0, sizeof(buf));
	strncpy(buf, path, sizeof(buf) - 4);
	strcat(buf, ""/.."");
",unused,sysvinittrusty-src2Fmountpoint.c
"  		fprintf(stderr, ""shutdown: you must be root to do that!\n"");
		usage();
  		exit(1);
	}
	strcpy(down_level, ""1"");
",1,unused,509,unused,"  		fprintf(stderr, ""shutdown: you must be root to do that!\n"");
		usage();
  		exit(1);
	}
	strcpy(down_level, ""1"");
",unused,sysvinittrusty-src2Fshutdown.c
"		while(!user_ok && (ut = getutent()) != NULL) {

			/* See if this is a user process on a VC. */
			if (ut->ut_type != USER_PROCESS) continue;
			sprintf(term, ""/dev/%.*s"", UT_LINESIZE, ut->ut_line);
",1,unused,593,unused,"		while(!user_ok && (ut = getutent()) != NULL) {

			/* See if this is a user process on a VC. */
			if (ut->ut_type != USER_PROCESS) continue;
			sprintf(term, ""/dev/%.*s"", UT_LINESIZE, ut->ut_line);
",unused,sysvinittrusty-src2Fshutdown.c
"	message[0] = 0;
	for(c = optind + (!cancel && !when); c < argc; c++) {
		if (strlen(message) + strlen(argv[c]) + 4 > MESSAGELEN)
			break;
  		strcat(message, argv[c]);
",1,unused,639,unused,"	message[0] = 0;
	for(c = optind + (!cancel && !when); c < argc; c++) {
		if (strlen(message) + strlen(argv[c]) + 4 > MESSAGELEN)
			break;
  		strcat(message, argv[c]);
",unused,sysvinittrusty-src2Fshutdown.c
"	for(c = optind + (!cancel && !when); c < argc; c++) {
		if (strlen(message) + strlen(argv[c]) + 4 > MESSAGELEN)
			break;
  		strcat(message, argv[c]);
  		strcat(message, "" "");
",1,unused,640,unused,"	for(c = optind + (!cancel && !when); c < argc; c++) {
		if (strlen(message) + strlen(argv[c]) + 4 > MESSAGELEN)
			break;
  		strcat(message, argv[c]);
  		strcat(message, "" "");
",unused,sysvinittrusty-src2Fshutdown.c
"			break;
  		strcat(message, argv[c]);
  		strcat(message, "" "");
	}
	if (message[0]) strcat(message, ""\r\n"");
",1,unused,642,unused,"			break;
  		strcat(message, argv[c]);
  		strcat(message, "" "");
	}
	if (message[0]) strcat(message, ""\r\n"");
",unused,sysvinittrusty-src2Fshutdown.c
"
	/* Tell users what we're gonna do. */
	switch(down_level[0]) {
		case '0':
			strcpy(newstate, ""for system halt"");
",1,unused,682,unused,"
	/* Tell users what we're gonna do. */
	switch(down_level[0]) {
		case '0':
			strcpy(newstate, ""for system halt"");
",unused,sysvinittrusty-src2Fshutdown.c
"		case '0':
			strcpy(newstate, ""for system halt"");
			break;
		case '6':
			strcpy(newstate, ""for reboot"");
",1,unused,685,unused,"		case '0':
			strcpy(newstate, ""for system halt"");
			break;
		case '6':
			strcpy(newstate, ""for reboot"");
",unused,sysvinittrusty-src2Fshutdown.c
"		case '6':
			strcpy(newstate, ""for reboot"");
			break;
		case '1':
			strcpy(newstate, ""to maintenance mode"");
",1,unused,688,unused,"		case '6':
			strcpy(newstate, ""for reboot"");
			break;
		case '1':
			strcpy(newstate, ""to maintenance mode"");
",unused,sysvinittrusty-src2Fshutdown.c
"		case '1':
			strcpy(newstate, ""to maintenance mode"");
			break;
		default:
			sprintf(newstate, ""to runlevel %s"", down_level);
",1,unused,691,unused,"		case '1':
			strcpy(newstate, ""to maintenance mode"");
			break;
		default:
			sprintf(newstate, ""to runlevel %s"", down_level);
",unused,sysvinittrusty-src2Fshutdown.c
"	if (fastboot)  close(open(FASTBOOT,  O_CREAT | O_RDWR, 0644));
	if (forcefsck) close(open(FORCEFSCK, O_CREAT | O_RDWR, 0644));

	/* Alias now and take care of old '+mins' notation. */
	if (!strcmp(when, ""now"")) strcpy(when, ""0"");
",1,unused,724,unused,"	if (fastboot)  close(open(FASTBOOT,  O_CREAT | O_RDWR, 0644));
	if (forcefsck) close(open(FORCEFSCK, O_CREAT | O_RDWR, 0644));

	/* Alias now and take care of old '+mins' notation. */
	if (!strcmp(when, ""now"")) strcpy(when, ""0"");
",unused,sysvinittrusty-src2Fshutdown.c
"	/*
	 *	The password is invalid. If there is a
	 *	shadow password, try it.
	 */
	strcpy(pwd.pw_passwd, """");
",1,unused,310,unused,"	/*
	 *	The password is invalid. If there is a
	 *	shadow password, try it.
	 */
	strcpy(pwd.pw_passwd, """");
",unused,sysvinittrusty-src2Fsulogin.c
"	 *	NULL it, and return.
	 */
	if (p == NULL) {
		fprintf(stderr, ""%s: no entry for root\n"", F_SHADOW);
		strcpy(pwd.pw_passwd, """");
",1,unused,330,unused,"	 *	NULL it, and return.
	 */
	if (p == NULL) {
		fprintf(stderr, ""%s: no entry for root\n"", F_SHADOW);
		strcpy(pwd.pw_passwd, """");
",unused,sysvinittrusty-src2Fsulogin.c
"		strcpy(pwd.pw_passwd, """");
	}
	if (!valid(pwd.pw_passwd)) {
		fprintf(stderr, ""%s: root password garbled\n"", F_SHADOW);
		strcpy(pwd.pw_passwd, """"); }
",1,unused,334,unused,"		strcpy(pwd.pw_passwd, """");
	}
	if (!valid(pwd.pw_passwd)) {
		fprintf(stderr, ""%s: root password garbled\n"", F_SHADOW);
		strcpy(pwd.pw_passwd, """"); }
",unused,sysvinittrusty-src2Fsulogin.c
"  if ((argc - optind) > 0) {
	for(f = optind; f < argc; f++) {
		len += strlen(argv[f]) + 1;
		if (len >= MAXLEN-2) break;
		strcat(buf, argv[f]);
",1,unused,85,unused,"  if ((argc - optind) > 0) {
	for(f = optind; f < argc; f++) {
		len += strlen(argv[f]) + 1;
		if (len >= MAXLEN-2) break;
		strcat(buf, argv[f]);
",unused,sysvinittrusty-src2Fwall.c
"	for(f = optind; f < argc; f++) {
		len += strlen(argv[f]) + 1;
		if (len >= MAXLEN-2) break;
		strcat(buf, argv[f]);
		if (f < argc-1) strcat(buf, "" "");
",1,unused,86,unused,"	for(f = optind; f < argc; f++) {
		len += strlen(argv[f]) + 1;
		if (len >= MAXLEN-2) break;
		strcat(buf, argv[f]);
		if (f < argc-1) strcat(buf, "" "");
",unused,sysvinittrusty-src2Fwall.c
"		if (len >= MAXLEN-2) break;
		strcat(buf, argv[f]);
		if (f < argc-1) strcat(buf, "" "");
	}
	strcat(buf, ""\r\n"");
",1,unused,88,unused,"		if (len >= MAXLEN-2) break;
		strcat(buf, argv[f]);
		if (f < argc-1) strcat(buf, "" "");
	}
	strcat(buf, ""\r\n"");
",unused,sysvinittrusty-src2Fwall.c
"		 *	Make sure that line ends in \r\n
		 */
		for(p = line; *p && *p != '\r' && *p != '\n'; p++)
			;
		strcpy(p, ""\r\n"");
",1,unused,96,unused,"		 *	Make sure that line ends in \r\n
		 */
		for(p = line; *p && *p != '\r' && *p != '\n'; p++)
			;
		strcpy(p, ""\r\n"");
",unused,sysvinittrusty-src2Fwall.c
"			;
		strcpy(p, ""\r\n"");
		len += strlen(line);
		if (len >= MAXLEN) break;
		strcat(buf, line);
",1,unused,99,unused,"			;
		strcpy(p, ""\r\n"");
		len += strlen(line);
		if (len >= MAXLEN) break;
		strcat(buf, line);
",unused,sysvinittrusty-src2Fwall.c
"
			/* Get the name of the chromosome */
			len = strlen( primLeft->chromosome_name);
			newEl->chromosome_name = ( char *) getMem( sizeof ( char) * len + 1);
			strcpy( newEl->chromosome_name, primLeft->chromosome_name);
",1,unused,114,unused,"
			/* Get the name of the chromosome */
			len = strlen( primLeft->chromosome_name);
			newEl->chromosome_name = ( char *) getMem( sizeof ( char) * len + 1);
			strcpy( newEl->chromosome_name, primLeft->chromosome_name);
",unused,tardis1-mappings.c
"
			/* Get the name of the chromosome */
			int len = strlen( altLeft->chromosome_name);
			newEl->chromosome_name = ( char *) getMem( sizeof ( char) * len + 1);
			strcpy( newEl->chromosome_name, altLeft->chromosome_name);
",1,unused,191,unused,"
			/* Get the name of the chromosome */
			int len = strlen( altLeft->chromosome_name);
			newEl->chromosome_name = ( char *) getMem( sizeof ( char) * len + 1);
			strcpy( newEl->chromosome_name, altLeft->chromosome_name);
",unused,tardis1-mappings.c
"	chrID_ref = sonic_refind_chromosome_index( params->this_sonic, in_bam->bam_header->target_name[chrID_bam]);

	len = strlen( params->this_sonic->chromosome_names[chrID_ref]);
	newEl->chromosome_name = ( char *) getMem( sizeof ( char) * len + 1);
	strcpy( newEl->chromosome_name, params->this_sonic->chromosome_names[chrID_ref]);
",1,unused,313,unused,"	chrID_ref = sonic_refind_chromosome_index( params->this_sonic, in_bam->bam_header->target_name[chrID_bam]);

	len = strlen( params->this_sonic->chromosome_names[chrID_ref]);
	newEl->chromosome_name = ( char *) getMem( sizeof ( char) * len + 1);
	strcpy( newEl->chromosome_name, params->this_sonic->chromosome_names[chrID_ref]);
",unused,tardis1-mappings.c
"
    err = compress(compr, &comprLen, (const Bytef*)hello, len);
    CHECK_ERR(err, ""compress"");

    strcpy((char*)uncompr, ""garbage"");
",1,unused,98,unused,"
    err = compress(compr, &comprLen, (const Bytef*)hello, len);
    CHECK_ERR(err, ""compress"");

    strcpy((char*)uncompr, ""garbage"");
",unused,test_lib2-test2Fexample.c
"    if (file == NULL) {
        fprintf(stderr, ""gzopen error\n"");
        exit(1);
    }
    strcpy((char*)uncompr, ""garbage"");
",1,unused,149,unused,"    if (file == NULL) {
        fprintf(stderr, ""gzopen error\n"");
        exit(1);
    }
    strcpy((char*)uncompr, ""garbage"");
",unused,test_lib2-test2Fexample.c
"{
    int err;
    z_stream d_stream; /* decompression stream */

    strcpy((char*)uncompr, ""garbage"");
",1,unused,245,unused,"{
    int err;
    z_stream d_stream; /* decompression stream */

    strcpy((char*)uncompr, ""garbage"");
",unused,test_lib2-test2Fexample.c
"{
    int err;
    z_stream d_stream; /* decompression stream */

    strcpy((char*)uncompr, ""garbage"");
",1,unused,341,unused,"{
    int err;
    z_stream d_stream; /* decompression stream */

    strcpy((char*)uncompr, ""garbage"");
",unused,test_lib2-test2Fexample.c
"{
    int err;
    z_stream d_stream; /* decompression stream */

    strcpy((char*)uncompr, ""garbage"");
",1,unused,420,unused,"{
    int err;
    z_stream d_stream; /* decompression stream */

    strcpy((char*)uncompr, ""garbage"");
",unused,test_lib2-test2Fexample.c
"{
    int err;
    z_stream d_stream; /* decompression stream */

    strcpy((char*)uncompr, ""garbage"");
",1,unused,501,unused,"{
    int err;
    z_stream d_stream; /* decompression stream */

    strcpy((char*)uncompr, ""garbage"");
",unused,test_lib2-test2Fexample.c
"            *p++ = ' ';
        }
    }

    strcpy(p, s);
",1,unused,83,unused,"            *p++ = ' ';
        }
    }

    strcpy(p, s);
",unused,test_openssl-apps2Fengine.c
"
    t = X509_get_default_cert_area();
    len = strlen(t) + 1 + strlen(OPENSSL_CONF) + 1;
    p = app_malloc(len, ""config filename buffer"");
    strcpy(p, t);
",1,unused,111,unused,"
    t = X509_get_default_cert_area();
    len = strlen(t) + 1 + strlen(OPENSSL_CONF) + 1;
    p = app_malloc(len, ""config filename buffer"");
    strcpy(p, t);
",unused,test_openssl-apps2Fopenssl.c
"    len = strlen(t) + 1 + strlen(OPENSSL_CONF) + 1;
    p = app_malloc(len, ""config filename buffer"");
    strcpy(p, t);
#ifndef OPENSSL_SYS_VMS
    strcat(p, ""/"");
",1,unused,113,unused,"    len = strlen(t) + 1 + strlen(OPENSSL_CONF) + 1;
    p = app_malloc(len, ""config filename buffer"");
    strcpy(p, t);
#ifndef OPENSSL_SYS_VMS
    strcat(p, ""/"");
",unused,test_openssl-apps2Fopenssl.c
"    strcpy(p, t);
#ifndef OPENSSL_SYS_VMS
    strcat(p, ""/"");
#endif
    strcat(p, OPENSSL_CONF);
",1,unused,115,unused,"    strcpy(p, t);
#ifndef OPENSSL_SYS_VMS
    strcat(p, ""/"");
#endif
    strcat(p, OPENSSL_CONF);
",unused,test_openssl-apps2Fopenssl.c
"        p = start;
        *p++ = ' ';
        *p++ = '-';
        if (o->name[0])
            p += strlen(strcpy(p, o->name));
",1,unused,924,unused,"        p = start;
        *p++ = ' ';
        *p++ = '-';
        if (o->name[0])
            p += strlen(strcpy(p, o->name));
",unused,test_openssl-apps2Fopt.c
"        else
            *p++ = '*';
        if (o->valtype != '-') {
            *p++ = ' ';
            p += strlen(strcpy(p, valtype2param(o)));
",1,unused,929,unused,"        else
            *p++ = '*';
        if (o->valtype != '-') {
            *p++ = ' ';
            p += strlen(strcpy(p, valtype2param(o)));
",unused,test_openssl-apps2Fopt.c
"    OPENSSL_strlcat(out_buf, ascii_magic, sizeof(out_buf));
    OPENSSL_strlcat(out_buf, ascii_dollar, sizeof(out_buf));
    if (rounds_custom) {
        char tmp_buf[80]; /* ""rounds=999999999"" */
        sprintf(tmp_buf, ""rounds=%u"", rounds);
",1,unused,589,unused,"    OPENSSL_strlcat(out_buf, ascii_magic, sizeof(out_buf));
    OPENSSL_strlcat(out_buf, ascii_dollar, sizeof(out_buf));
    if (rounds_custom) {
        char tmp_buf[80]; /* ""rounds=999999999"" */
        sprintf(tmp_buf, ""rounds=%u"", rounds);
",unused,test_openssl-apps2Fpasswd.c
"                         i * dump_width);
        for (j = 0; j < dump_width; j++) {
            if (SPACE(buf, n, 3)) {
                if (((i * dump_width) + j) >= len) {
                    strcpy(buf + n, ""   "");
",1,unused,52,unused,"                         i * dump_width);
        for (j = 0; j < dump_width; j++) {
            if (SPACE(buf, n, 3)) {
                if (((i * dump_width) + j) >= len) {
                    strcpy(buf + n, ""   "");
",unused,test_openssl-crypto2Fbio2Fb_dump.c
"                n += 3;
            }
        }
        if (SPACE(buf, n, 2)) {
            strcpy(buf + n, ""  "");
",1,unused,62,unused,"                n += 3;
            }
        }
        if (SPACE(buf, n, 2)) {
            strcpy(buf + n, ""  "");
",unused,test_openssl-crypto2Fbio2Fb_dump.c
"            BIOerr(BIO_F_BIO_ACCEPT, ERR_R_MALLOC_FAILURE);
            BIO_closesocket(ret);
            ret = (int)INVALID_SOCKET;
        } else {
            strcpy(*ip_port, host);
",1,unused,264,unused,"            BIOerr(BIO_F_BIO_ACCEPT, ERR_R_MALLOC_FAILURE);
            BIO_closesocket(ret);
            ret = (int)INVALID_SOCKET;
        } else {
            strcpy(*ip_port, host);
",unused,test_openssl-crypto2Fbio2Fb_sock.c
"            BIO_closesocket(ret);
            ret = (int)INVALID_SOCKET;
        } else {
            strcpy(*ip_port, host);
            strcat(*ip_port, "":"");
",1,unused,265,unused,"            BIO_closesocket(ret);
            ret = (int)INVALID_SOCKET;
        } else {
            strcpy(*ip_port, host);
            strcat(*ip_port, "":"");
",unused,test_openssl-crypto2Fbio2Fb_sock.c
"            ret = (int)INVALID_SOCKET;
        } else {
            strcpy(*ip_port, host);
            strcat(*ip_port, "":"");
            strcat(*ip_port, port);
",1,unused,266,unused,"            ret = (int)INVALID_SOCKET;
        } else {
            strcpy(*ip_port, host);
            strcat(*ip_port, "":"");
            strcat(*ip_port, port);
",unused,test_openssl-crypto2Fbio2Fb_sock.c
"        if (merged == NULL) {
            DSOerr(DSO_F_DLFCN_MERGER, ERR_R_MALLOC_FAILURE);
            return NULL;
        }
        strcpy(merged, filespec2);
",1,unused,236,unused,"        if (merged == NULL) {
            DSOerr(DSO_F_DLFCN_MERGER, ERR_R_MALLOC_FAILURE);
            return NULL;
        }
        strcpy(merged, filespec2);
",unused,test_openssl-crypto2Fdso2Fdso_dlfcn.c
"            return NULL;
        }
        strcpy(merged, filespec2);
        merged[spec2len] = '/';
        strcpy(&merged[spec2len + 1], filespec1);
",1,unused,238,unused,"            return NULL;
        }
        strcpy(merged, filespec2);
        merged[spec2len] = '/';
        strcpy(&merged[spec2len + 1], filespec1);
",unused,test_openssl-crypto2Fdso2Fdso_dlfcn.c
"        return NULL;
    }
    if (transform) {
        if ((DSO_flags(dso) & DSO_FLAG_NAME_TRANSLATION_EXT_ONLY) == 0)
            sprintf(translated, ""lib%s"" DSO_EXTENSION, filename);
",1,unused,264,unused,"        return NULL;
    }
    if (transform) {
        if ((DSO_flags(dso) & DSO_FLAG_NAME_TRANSLATION_EXT_ONLY) == 0)
            sprintf(translated, ""lib%s"" DSO_EXTENSION, filename);
",unused,test_openssl-crypto2Fdso2Fdso_dlfcn.c
"    if (transform) {
        if ((DSO_flags(dso) & DSO_FLAG_NAME_TRANSLATION_EXT_ONLY) == 0)
            sprintf(translated, ""lib%s"" DSO_EXTENSION, filename);
        else
            sprintf(translated, ""%s"" DSO_EXTENSION, filename);
",1,unused,266,unused,"    if (transform) {
        if ((DSO_flags(dso) & DSO_FLAG_NAME_TRANSLATION_EXT_ONLY) == 0)
            sprintf(translated, ""lib%s"" DSO_EXTENSION, filename);
        else
            sprintf(translated, ""%s"" DSO_EXTENSION, filename);
",unused,test_openssl-crypto2Fdso2Fdso_dlfcn.c
"            sprintf(translated, ""lib%s"" DSO_EXTENSION, filename);
        else
            sprintf(translated, ""%s"" DSO_EXTENSION, filename);
    } else
        sprintf(translated, ""%s"", filename);
",1,unused,268,unused,"            sprintf(translated, ""lib%s"" DSO_EXTENSION, filename);
        else
            sprintf(translated, ""%s"" DSO_EXTENSION, filename);
    } else
        sprintf(translated, ""%s"", filename);
",unused,test_openssl-crypto2Fdso2Fdso_dlfcn.c
"        return int_ctrl_cmd_is_null(cdp) ? 0 : cdp->cmd_num;
    case ENGINE_CTRL_GET_NAME_LEN_FROM_CMD:
        return strlen(cdp->cmd_name);
    case ENGINE_CTRL_GET_NAME_FROM_CMD:
        return strlen(strcpy(s, cdp->cmd_name));
",1,unused,110,unused,"        return int_ctrl_cmd_is_null(cdp) ? 0 : cdp->cmd_num;
    case ENGINE_CTRL_GET_NAME_LEN_FROM_CMD:
        return strlen(cdp->cmd_name);
    case ENGINE_CTRL_GET_NAME_FROM_CMD:
        return strlen(strcpy(s, cdp->cmd_name));
",unused,test_openssl-crypto2Fengine2Feng_ctrl.c
"    case ENGINE_CTRL_GET_DESC_LEN_FROM_CMD:
        return strlen(cdp->cmd_desc == NULL ? int_no_description
                                            : cdp->cmd_desc);
    case ENGINE_CTRL_GET_DESC_FROM_CMD:
        return strlen(strcpy(s, cdp->cmd_desc == NULL ? int_no_description
",1,unused,115,unused,"    case ENGINE_CTRL_GET_DESC_LEN_FROM_CMD:
        return strlen(cdp->cmd_desc == NULL ? int_no_description
                                            : cdp->cmd_desc);
    case ENGINE_CTRL_GET_DESC_FROM_CMD:
        return strlen(strcpy(s, cdp->cmd_desc == NULL ? int_no_description
",unused,test_openssl-crypto2Fengine2Feng_ctrl.c
"    if (str == NULL)
        return NULL;
    ret = CRYPTO_malloc(strlen(str) + 1, file, line);
    if (ret != NULL)
        strcpy(ret, str);
",1,unused,35,unused,"    if (str == NULL)
        return NULL;
    ret = CRYPTO_malloc(strlen(str) + 1, file, line);
    if (ret != NULL)
        strcpy(ret, str);
",unused,test_openssl-crypto2Fo_str.c
"            j -= n;
            p += n;
        }
        if (j > 1)
            strcpy(p, ""\n"");
",1,unused,106,unused,"            j -= n;
            p += n;
        }
        if (j > 1)
            strcpy(p, ""\n"");
",unused,test_openssl-crypto2Fpem2Fpem_lib.c
"    len = strlen(s);
    if (use_randfile) {
        if (len + 1 >= size)
            return NULL;
        strcpy(buf, s);
",1,unused,284,unused,"    len = strlen(s);
    if (use_randfile) {
        if (len + 1 >= size)
            return NULL;
        strcpy(buf, s);
",unused,test_openssl-crypto2Frand2Frandfile.c
"        strcpy(buf, s);
    } else {
        if (len + 1 + strlen(RFILE) + 1 >= size)
            return NULL;
        strcpy(buf, s);
",1,unused,288,unused,"        strcpy(buf, s);
    } else {
        if (len + 1 + strlen(RFILE) + 1 >= size)
            return NULL;
        strcpy(buf, s);
",unused,test_openssl-crypto2Frand2Frandfile.c
"        if (len + 1 + strlen(RFILE) + 1 >= size)
            return NULL;
        strcpy(buf, s);
#ifndef OPENSSL_SYS_VMS
        strcat(buf, ""/"");
",1,unused,290,unused,"        if (len + 1 + strlen(RFILE) + 1 >= size)
            return NULL;
        strcpy(buf, s);
#ifndef OPENSSL_SYS_VMS
        strcat(buf, ""/"");
",unused,test_openssl-crypto2Frand2Frandfile.c
"        strcpy(buf, s);
#ifndef OPENSSL_SYS_VMS
        strcat(buf, ""/"");
#endif
        strcat(buf, RFILE);
",1,unused,292,unused,"        strcpy(buf, s);
#ifndef OPENSSL_SYS_VMS
        strcat(buf, ""/"");
#endif
        strcat(buf, RFILE);
",unused,test_openssl-crypto2Frand2Frandfile.c
"        for (i = 0; i < (int)OSSL_NELEM(ts_failure_info); ++i) {
            if (ASN1_BIT_STRING_get_bit(info->failure_info,
                                        ts_failure_info[i].code)) {
                if (!first)
                    strcat(failure_text, "","");
",1,unused,499,unused,"        for (i = 0; i < (int)OSSL_NELEM(ts_failure_info); ++i) {
            if (ASN1_BIT_STRING_get_bit(info->failure_info,
                                        ts_failure_info[i].code)) {
                if (!first)
                    strcat(failure_text, "","");
",unused,test_openssl-crypto2Fts2Fts_rsp_verify.c
"                if (!first)
                    strcat(failure_text, "","");
                else
                    first = 0;
                strcat(failure_text, ts_failure_info[i].text);
",1,unused,502,unused,"                if (!first)
                    strcat(failure_text, "","");
                else
                    first = 0;
                strcat(failure_text, ts_failure_info[i].text);
",unused,test_openssl-crypto2Fts2Fts_rsp_verify.c
"            }
        }
    }
    if (failure_text[0] == '\0')
        strcpy(failure_text, ""unspecified"");
",1,unused,507,unused,"            }
        }
    }
    if (failure_text[0] == '\0')
        strcpy(failure_text, ""unspecified"");
",unused,test_openssl-crypto2Fts2Fts_rsp_verify.c
"            oline[0] = 0;
            for (i = 0; i < 8; i++) {
                BIO_snprintf(htmp, sizeof(htmp), ""%X"", p[0] << 8 | p[1]);
                p += 2;
                strcat(oline, htmp);
",1,unused,119,unused,"            oline[0] = 0;
            for (i = 0; i < 8; i++) {
                BIO_snprintf(htmp, sizeof(htmp), ""%X"", p[0] << 8 | p[1]);
                p += 2;
                strcat(oline, htmp);
",unused,test_openssl-crypto2Fx509v32Fv3_alt.c
"                BIO_snprintf(htmp, sizeof(htmp), ""%X"", p[0] << 8 | p[1]);
                p += 2;
                strcat(oline, htmp);
                if (i != 7)
                    strcat(oline, "":"");
",1,unused,121,unused,"                BIO_snprintf(htmp, sizeof(htmp), ""%X"", p[0] << 8 | p[1]);
                p += 2;
                strcat(oline, htmp);
                if (i != 7)
                    strcat(oline, "":"");
",unused,test_openssl-crypto2Fx509v32Fv3_alt.c
"            if (pathname == NULL) {
                pathname = malloc(PATH_MAX);
                if (pathname == NULL)
                    break;
                strcpy(pathname, argv[n]);
",1,unused,82,unused,"            if (pathname == NULL) {
                pathname = malloc(PATH_MAX);
                if (pathname == NULL)
                    break;
                strcpy(pathname, argv[n]);
",unused,test_openssl-fuzz2Ftest-corpus.c
"#endif
                    pathname[dirname_len++] = '/';
                pathname[dirname_len] = '\0';
            }
            strcpy(pathname + dirname_len, filename);
",1,unused,89,unused,"#endif
                    pathname[dirname_len++] = '/';
                pathname[dirname_len] = '\0';
            }
            strcpy(pathname + dirname_len, filename);
",unused,test_openssl-fuzz2Ftest-corpus.c
"                --p;
            *p = '\0';
            return buf;
        }
        strcpy(p, c->name);
",1,unused,2579,unused,"                --p;
            *p = '\0';
            return buf;
        }
        strcpy(p, c->name);
",unused,test_openssl-ssl2Fssl_lib.c
"                 ERR_R_MALLOC_FAILURE);
        return 0;
    }

    strcpy(cursor, prefix);
",1,unused,5057,unused,"                 ERR_R_MALLOC_FAILURE);
        return 0;
    }

    strcpy(cursor, prefix);
",unused,test_openssl-ssl2Fssl_lib.c
"    cursor += prefix_len;
    *cursor++ = ' ';

    for (i = 0; i < parameter_1_len; i++) {
        sprintf(cursor, ""%02x"", parameter_1[i]);
",1,unused,5062,unused,"    cursor += prefix_len;
    *cursor++ = ' ';

    for (i = 0; i < parameter_1_len; i++) {
        sprintf(cursor, ""%02x"", parameter_1[i]);
",unused,test_openssl-ssl2Fssl_lib.c
"    }
    *cursor++ = ' ';

    for (i = 0; i < parameter_2_len; i++) {
        sprintf(cursor, ""%02x"", parameter_2[i]);
",1,unused,5068,unused,"    }
    *cursor++ = ' ';

    for (i = 0; i < parameter_2_len; i++) {
        sprintf(cursor, ""%02x"", parameter_2[i]);
",unused,test_openssl-ssl2Fssl_lib.c
"        memset(tls13tbs, 32, TLS13_TBS_START_SIZE);
        /* This copies the 33 bytes of context plus the 0 separator byte */
        if (s->statem.hand_state == TLS_ST_CR_CERT_VRFY
                 || s->statem.hand_state == TLS_ST_SW_CERT_VRFY)
            strcpy((char *)tls13tbs + TLS13_TBS_START_SIZE, servercontext);
",1,unused,187,unused,"        memset(tls13tbs, 32, TLS13_TBS_START_SIZE);
        /* This copies the 33 bytes of context plus the 0 separator byte */
        if (s->statem.hand_state == TLS_ST_CR_CERT_VRFY
                 || s->statem.hand_state == TLS_ST_SW_CERT_VRFY)
            strcpy((char *)tls13tbs + TLS13_TBS_START_SIZE, servercontext);
",unused,test_openssl-ssl2Fstatem2Fstatem_lib.c
"        if (s->statem.hand_state == TLS_ST_CR_CERT_VRFY
                 || s->statem.hand_state == TLS_ST_SW_CERT_VRFY)
            strcpy((char *)tls13tbs + TLS13_TBS_START_SIZE, servercontext);
        else
            strcpy((char *)tls13tbs + TLS13_TBS_START_SIZE, clientcontext);
",1,unused,189,unused,"        if (s->statem.hand_state == TLS_ST_CR_CERT_VRFY
                 || s->statem.hand_state == TLS_ST_SW_CERT_VRFY)
            strcpy((char *)tls13tbs + TLS13_TBS_START_SIZE, servercontext);
        else
            strcpy((char *)tls13tbs + TLS13_TBS_START_SIZE, clientcontext);
",unused,test_openssl-ssl2Fstatem2Fstatem_lib.c
"        goto end;

    TEST_info(""About to beef up the engine-type list"");
    for (loop = 0; loop < NUMTOADD; loop++) {
        sprintf(buf, ""id%d"", loop);
",1,unused,140,unused,"        goto end;

    TEST_info(""About to beef up the engine-type list"");
    for (loop = 0; loop < NUMTOADD; loop++) {
        sprintf(buf, ""id%d"", loop);
",unused,test_openssl-test2Fenginetest.c
"    TEST_info(""About to beef up the engine-type list"");
    for (loop = 0; loop < NUMTOADD; loop++) {
        sprintf(buf, ""id%d"", loop);
        id = OPENSSL_strdup(buf);
        sprintf(buf, ""Fake engine type %d"", loop);
",1,unused,142,unused,"    TEST_info(""About to beef up the engine-type list"");
    for (loop = 0; loop < NUMTOADD; loop++) {
        sprintf(buf, ""id%d"", loop);
        id = OPENSSL_strdup(buf);
        sprintf(buf, ""Fake engine type %d"", loop);
",unused,test_openssl-test2Fenginetest.c
"    unsigned int i;
    static char buf[80];

    for (i = 0; i < len; i++)
        sprintf(&(buf[i * 2]), ""%02x"", md[i]);
",1,unused,234,unused,"    unsigned int i;
    static char buf[80];

    for (i = 0; i < len; i++)
        sprintf(&(buf[i * 2]), ""%02x"", md[i]);
",unused,test_openssl-test2Fhmactest.c
"        error_writing_log = 1;
        return;
    }

    strcat(client_log_buffer, line);
",1,unused,85,unused,"        error_writing_log = 1;
        return;
    }

    strcat(client_log_buffer, line);
",unused,test_openssl-test2Fsslapitest.c
"        error_writing_log = 1;
        return;
    }

    strcat(server_log_buffer, line);
",1,unused,101,unused,"        error_writing_log = 1;
        return;
    }

    strcat(server_log_buffer, line);
",unused,test_openssl-test2Fsslapitest.c
"    if (!TEST_size_t_eq(raw_length * 2, hex_length))
        return 1;

    for (i = j = 0; i < raw_length && j + 1 < hex_length; i++, j += 2) {
        sprintf(hexed, ""%02x"", raw[i]);
",1,unused,118,unused,"    if (!TEST_size_t_eq(raw_length * 2, hex_length))
        return 1;

    for (i = j = 0; i < raw_length && j + 1 < hex_length; i++, j += 2) {
        sprintf(hexed, ""%02x"", raw[i]);
",unused,test_openssl-test2Fsslapitest.c
"    if (!TEST_ptr(ret = p = OPENSSL_malloc(len + 1)))
        return NULL;

    for (i = 0; list[i] != NULL; i++)
        p += strlen(strcpy(p, list[i]));
",1,unused,295,unused,"    if (!TEST_ptr(ret = p = OPENSSL_malloc(len + 1)))
        return NULL;

    for (i = 0; list[i] != NULL; i++)
        p += strlen(strcpy(p, list[i]));
",unused,test_openssl-test2Ftestutil2Fdriver.c
"    if (bn == NULL)
        q = ""NULL"";
    else
        q = BN_is_negative(bn) ? ""-0"" : ""0"";
    strcpy(p - strlen(q), q);
",1,unused,254,unused,"    if (bn == NULL)
        q = ""NULL"";
    else
        q = BN_is_negative(bn) ? ""-0"" : ""0"";
    strcpy(p - strlen(q), q);
",unused,test_openssl-test2Ftestutil2Fformat_output.c
"
void manipulate_string(char* input){

	char buf[MAXINPUT];
	strcpy(buf, input);
",1,unused,8,unused,"
void manipulate_string(char* input){

	char buf[MAXINPUT];
	strcpy(buf, input);
",unused,testclang-BOFstrcpy_NoLocal.c
"	char buf[MAXINPUT];
	int sizeInput =  strlen(input) + 1; //strlen not including the terminating null character
	
	if(sizeInput <= MAXINPUT){
		strcpy(buf, input);
",1,unused,11,unused,"	char buf[MAXINPUT];
	int sizeInput =  strlen(input) + 1; //strlen not including the terminating null character
	
	if(sizeInput <= MAXINPUT){
		strcpy(buf, input);
",unused,testclang-BOFstrcpy_NoLocal_sol.c
"	int sizePass =  sizeof(password) / sizeof(password[0]); //sizePass -> 12
	int sizeUser =  sizeof(user) / sizeof(user[0]); //sizeUser -> 6

	if(sizePass <= sizeUser){
   		strcpy(user, password);
",1,unused,13,unused,"	int sizePass =  sizeof(password) / sizeof(password[0]); //sizePass -> 12
	int sizeUser =  sizeof(user) / sizeof(user[0]); //sizeUser -> 6

	if(sizePass <= sizeUser){
   		strcpy(user, password);
",unused,testclang-sol_strcpy.c
"  UNUSED(cursor);

  char line[MAXLINE];
  char output_line[MAXLINE];
  strcpy(line, contents);
",1,unused,34,unused,"  UNUSED(cursor);

  char line[MAXLINE];
  char output_line[MAXLINE];
  strcpy(line, contents);
",unused,this_is_random_symbols-app2Fshownum.c
"  /*        */
  if (cursor >= 0) {
    strncpy(output_line, line, cursor);
    output_line[cursor] = '|';
    strcpy(output_line + cursor + 1, line + cursor);
",1,unused,40,unused,"  /*        */
  if (cursor >= 0) {
    strncpy(output_line, line, cursor);
    output_line[cursor] = '|';
    strcpy(output_line + cursor + 1, line + cursor);
",unused,this_is_random_symbols-app2Fshownum.c
"  UNUSED(cursor);

  char line[MAXLINE];
  char output_line[MAXLINE];
  strcpy(line, contents);
",1,unused,34,unused,"  UNUSED(cursor);

  char line[MAXLINE];
  char output_line[MAXLINE];
  strcpy(line, contents);
",unused,this_is_random_symbols-app2Fshownum.c
"  /*        */
  if (cursor >= 0) {
    strncpy(output_line, line, cursor);
    output_line[cursor] = '|';
    strcpy(output_line + cursor + 1, line + cursor);
",1,unused,40,unused,"  /*        */
  if (cursor >= 0) {
    strncpy(output_line, line, cursor);
    output_line[cursor] = '|';
    strcpy(output_line + cursor + 1, line + cursor);
",unused,this_is_random_symbols-app2Fshownum.c
"				sock_info->local_port = (u16_t) sockets[i].conn->pcb.raw->protocol;
				sock_info->remote_port = 0;
			}
			if (pthread_getname_np(sockets[i].conn->pid, sock_info->pid_name)) {
				strcpy(sock_info->pid_name, ""NONE"");
",1,unused,470,unused,"				sock_info->local_port = (u16_t) sockets[i].conn->pcb.raw->protocol;
				sock_info->remote_port = 0;
			}
			if (pthread_getname_np(sockets[i].conn->pid, sock_info->pid_name)) {
				strcpy(sock_info->pid_name, ""NONE"");
",unused,tizenrt-webeng-3-net2Flwip2Fsrc2Fapi2Fsockets.c
"				sock_info->local_port = (u16_t) sockets[i].conn->pcb.raw->protocol;
				sock_info->remote_port = 0;
			}
			if (pthread_getname_np(sockets[i].conn->pid, sock_info->pid_name)) {
				strcpy(sock_info->pid_name, ""NONE"");
",1,unused,470,unused,"				sock_info->local_port = (u16_t) sockets[i].conn->pcb.raw->protocol;
				sock_info->remote_port = 0;
			}
			if (pthread_getname_np(sockets[i].conn->pid, sock_info->pid_name)) {
				strcpy(sock_info->pid_name, ""NONE"");
",unused,tizenrt2-webeng-net2Flwip2Fsrc2Fapi2Fsockets.c
"#endif
#if defined(CONFIG_MTD_SMART) && defined(CONFIG_FS_SMARTFS)
		if (!strncmp(types, ""smartfs,"", 8)) {
			char partref[4];
			snprintf(partref, sizeof(partref), ""p%d"", partno);
",1,unused,184,unused,"#endif
#if defined(CONFIG_MTD_SMART) && defined(CONFIG_FS_SMARTFS)
		if (!strncmp(types, ""smartfs,"", 8)) {
			char partref[4];
			snprintf(partref, sizeof(partref), ""p%d"", partno);
",unused,tizenrt3-arch2Farm2Fsrc2Fboard2Fartik053_tash.c
"static rtp_route_t routeTable[NUM_ROUTES];

void NE_Init() {
    for (int i = 0; i < NUM_DEVICES; i++) {
        strcpy(devicesList[i].key, """");
",1,unused,21,unused,"static rtp_route_t routeTable[NUM_ROUTES];

void NE_Init() {
    for (int i = 0; i < NUM_DEVICES; i++) {
        strcpy(devicesList[i].key, """");
",unused,udpEcho1014-netmanager.c
"
void NE_put(char *key, struct sockaddr_in addr) {
    for (int i = 0; i < NUM_DEVICES; i++) {
        if (devicesList[i].isFree) {
            strcpy(devicesList[i].key, key);
",1,unused,40,unused,"
void NE_put(char *key, struct sockaddr_in addr) {
    for (int i = 0; i < NUM_DEVICES; i++) {
        if (devicesList[i].isFree) {
            strcpy(devicesList[i].key, key);
",unused,udpEcho1014-netmanager.c
"}

void NE_remove(char *key) {
    char tmp_key[50];
    strcpy(tmp_key, key);
",1,unused,79,unused,"}

void NE_remove(char *key) {
    char tmp_key[50];
    strcpy(tmp_key, key);
",unused,udpEcho1014-netmanager.c
"    char tmp_key[50];
    strcpy(tmp_key, key);
    for (int i = 0; i < NUM_DEVICES; i++) {
        if (strcmp(devicesList[i].key, tmp_key) == 0) {
            strcpy(devicesList[i].key, """");
",1,unused,82,unused,"    char tmp_key[50];
    strcpy(tmp_key, key);
    for (int i = 0; i < NUM_DEVICES; i++) {
        if (strcmp(devicesList[i].key, tmp_key) == 0) {
            strcpy(devicesList[i].key, """");
",unused,udpEcho1014-netmanager.c
"
void NE_initTableRoute() {

    for (int i = 0; i < NUM_ROUTES; ++i) {
        strcpy(routeTable[0].ne_a, """");
",1,unused,94,unused,"
void NE_initTableRoute() {

    for (int i = 0; i < NUM_ROUTES; ++i) {
        strcpy(routeTable[0].ne_a, """");
",unused,udpEcho1014-netmanager.c
"void NE_initTableRoute() {

    for (int i = 0; i < NUM_ROUTES; ++i) {
        strcpy(routeTable[0].ne_a, """");
        strcpy(routeTable[0].ne_b, """");
",1,unused,95,unused,"void NE_initTableRoute() {

    for (int i = 0; i < NUM_ROUTES; ++i) {
        strcpy(routeTable[0].ne_a, """");
        strcpy(routeTable[0].ne_b, """");
",unused,udpEcho1014-netmanager.c
"        strcpy(routeTable[0].ne_a, """");
        strcpy(routeTable[0].ne_b, """");
    }

    strcpy(routeTable[0].ne_a, ""4568@ericsonj.net"");
",1,unused,98,unused,"        strcpy(routeTable[0].ne_a, """");
        strcpy(routeTable[0].ne_b, """");
    }

    strcpy(routeTable[0].ne_a, ""4568@ericsonj.net"");
",unused,udpEcho1014-netmanager.c
"        strcpy(routeTable[0].ne_b, """");
    }

    strcpy(routeTable[0].ne_a, ""4568@ericsonj.net"");
    strcpy(routeTable[0].ne_b, ""1001@ericsonj.net"");
",1,unused,99,unused,"        strcpy(routeTable[0].ne_b, """");
    }

    strcpy(routeTable[0].ne_a, ""4568@ericsonj.net"");
    strcpy(routeTable[0].ne_b, ""1001@ericsonj.net"");
",unused,udpEcho1014-netmanager.c
"	    char_u	*s;

	    if (opt.jo_set & JO_IN_BUF)
	    {
		sprintf((char *)numbuf, ""%d"", opt.jo_io_buf[PART_IN]);
",1,unused,4102,unused,"	    char_u	*s;

	    if (opt.jo_set & JO_IN_BUF)
	    {
		sprintf((char *)numbuf, ""%d"", opt.jo_io_buf[PART_IN]);
",unused,vimactualxenialpreviousversion-src2Fchannel.c
"
    list_hashtable_vars(&curbuf->b_vars->dv_hashtab, (char_u *)""b:"",
								 TRUE, first);

    sprintf((char *)numbuf, ""%ld"", (long)curbuf->b_changedtick);
",1,unused,2195,unused,"
    list_hashtable_vars(&curbuf->b_vars->dv_hashtab, (char_u *)""b:"",
								 TRUE, first);

    sprintf((char *)numbuf, ""%ld"", (long)curbuf->b_changedtick);
",unused,vimactualxenialpreviousversion-src2Feval.c
"	    if (current_SID <= 0)
		*error = ERROR_SCRIPT;
	    else
	    {
		sprintf((char *)fname_buf + 3, ""%ld_"", (long)current_SID);
",1,unused,8808,unused,"	    if (current_SID <= 0)
		*error = ERROR_SCRIPT;
	    else
	    {
		sprintf((char *)fname_buf + 3, ""%ld_"", (long)current_SID);
",unused,vimactualxenialpreviousversion-src2Feval.c
"	    ga_concat(gap, (char_u *)"" "");
    }
    if (sourcing_lnum > 0)
    {
	sprintf(buf, ""line %ld"", (long)sourcing_lnum);
",1,unused,9348,unused,"	    ga_concat(gap, (char_u *)"" "");
    }
    if (sourcing_lnum > 0)
    {
	sprintf(buf, ""line %ld"", (long)sourcing_lnum);
",unused,vimactualxenialpreviousversion-src2Feval.c
"		    + 20				    /* for %3ld */
		    + STRLEN(s)));			    /* concatenated */
	if (r != NULL)
	{
	    sprintf((char *)r, txt, vimvars[VV_FOLDDASHES].vv_str,
",1,unused,11883,unused,"		    + 20				    /* for %3ld */
		    + STRLEN(s)));			    /* concatenated */
	if (r != NULL)
	{
	    sprintf((char *)r, txt, vimvars[VV_FOLDDASHES].vv_str,
",unused,vimactualxenialpreviousversion-src2Feval.c
"	    /* Expand s: and <SID> into <SNR>nr_, so that the function can
	     * also be called from another script. Using trans_function_name()
	     * would also work, but some plugins depend on the name being
	     * printable text. */
	    sprintf(sid_buf, ""<SNR>%ld_"", (long)current_SID);
",1,unused,11996,unused,"	    /* Expand s: and <SID> into <SNR>nr_, so that the function can
	     * also be called from another script. Using trans_function_name()
	     * would also work, but some plugins depend on the name being
	     * printable text. */
	    sprintf(sid_buf, ""<SNR>%ld_"", (long)current_SID);
",unused,vimactualxenialpreviousversion-src2Feval.c
"		    {
			list_append_number(l, (varnumber_T)llpos->col);
			list_append_number(l, (varnumber_T)llpos->len);
		    }
		    sprintf(buf, ""pos%d"", i + 1);
",1,unused,12778,unused,"		    {
			list_append_number(l, (varnumber_T)llpos->col);
			list_append_number(l, (varnumber_T)llpos->len);
		    }
		    sprintf(buf, ""pos%d"", i + 1);
",unused,vimactualxenialpreviousversion-src2Feval.c
"	case MLINE: buf[0] = 'V'; break;
	case MCHAR: buf[0] = 'v'; break;
	case MBLOCK:
		buf[0] = Ctrl_V;
		sprintf((char *)buf + 1, ""%ld"", reglen + 1);
",1,unused,12988,unused,"	case MLINE: buf[0] = 'V'; break;
	case MCHAR: buf[0] = 'v'; break;
	case MBLOCK:
		buf[0] = Ctrl_V;
		sprintf((char *)buf + 1, ""%ld"", reglen + 1);
",unused,vimactualxenialpreviousversion-src2Feval.c
"	dictitem_T	v;
	char_u		str[30];
	char_u		*idvar;

	sprintf((char *)str, PRINTF_HEX_LONG_U, (long_u)w);
",1,unused,16625,unused,"	dictitem_T	v;
	char_u		str[30];
	char_u		*idvar;

	sprintf((char *)str, PRINTF_HEX_LONG_U, (long_u)w);
",unused,vimactualxenialpreviousversion-src2Feval.c
"    pat2 = alloc((unsigned)(STRLEN(spat) + STRLEN(epat) + 15));
    pat3 = alloc((unsigned)(STRLEN(spat) + STRLEN(mpat) + STRLEN(epat) + 23));
    if (pat2 == NULL || pat3 == NULL)
	goto theend;
    sprintf((char *)pat2, ""\\(%s\\m\\)\\|\\(%s\\m\\)"", spat, epat);
",1,unused,17624,unused,"    pat2 = alloc((unsigned)(STRLEN(spat) + STRLEN(epat) + 15));
    pat3 = alloc((unsigned)(STRLEN(spat) + STRLEN(mpat) + STRLEN(epat) + 23));
    if (pat2 == NULL || pat3 == NULL)
	goto theend;
    sprintf((char *)pat2, ""\\(%s\\m\\)\\|\\(%s\\m\\)"", spat, epat);
",unused,vimactualxenialpreviousversion-src2Feval.c
"    sprintf((char *)pat2, ""\\(%s\\m\\)\\|\\(%s\\m\\)"", spat, epat);
    if (*mpat == NUL)
	STRCPY(pat3, pat2);
    else
	sprintf((char *)pat3, ""\\(%s\\m\\)\\|\\(%s\\m\\)\\|\\(%s\\m\\)"",
",1,unused,17628,unused,"    sprintf((char *)pat2, ""\\(%s\\m\\)\\|\\(%s\\m\\)"", spat, epat);
    if (*mpat == NUL)
	STRCPY(pat3, pat2);
    else
	sprintf((char *)pat3, ""\\(%s\\m\\)\\|\\(%s\\m\\)\\|\\(%s\\m\\)"",
",unused,vimactualxenialpreviousversion-src2Feval.c
"
		/* match from matchaddpos() */
		for (i = 1; i < 9; i++)
		{
		    sprintf((char *)buf, (char *)""pos%d"", i);
",1,unused,18154,unused,"
		/* match from matchaddpos() */
		for (i = 1; i < 9; i++)
		{
		    sprintf((char *)buf, (char *)""pos%d"", i);
",unused,vimactualxenialpreviousversion-src2Feval.c
"
    ga_init2(&ga, (int)sizeof(char), 70);
    for (wp = firstwin; wp != NULL; wp = wp->w_next)
    {
	sprintf((char *)buf, ""%dresize %d|"", winnr, wp->w_height);
",1,unused,20786,unused,"
    ga_init2(&ga, (int)sizeof(char), 70);
    for (wp = firstwin; wp != NULL; wp = wp->w_next)
    {
	sprintf((char *)buf, ""%dresize %d|"", winnr, wp->w_height);
",unused,vimactualxenialpreviousversion-src2Feval.c
"    for (wp = firstwin; wp != NULL; wp = wp->w_next)
    {
	sprintf((char *)buf, ""%dresize %d|"", winnr, wp->w_height);
	ga_concat(&ga, buf);
	sprintf((char *)buf, ""vert %dresize %d|"", winnr, wp->w_width);
",1,unused,20788,unused,"    for (wp = firstwin; wp != NULL; wp = wp->w_next)
    {
	sprintf((char *)buf, ""%dresize %d|"", winnr, wp->w_height);
	ga_concat(&ga, buf);
	sprintf((char *)buf, ""vert %dresize %d|"", winnr, wp->w_width);
",unused,vimactualxenialpreviousversion-src2Feval.c
"    if (newval == NULL)
	return NULL;

    if (eap->force_bin == FORCE_BIN)
	sprintf((char *)newval, "" ++bin"");
",1,unused,21723,unused,"    if (newval == NULL)
	return NULL;

    if (eap->force_bin == FORCE_BIN)
	sprintf((char *)newval, "" ++bin"");
",unused,vimactualxenialpreviousversion-src2Feval.c
"
    if (eap->force_bin == FORCE_BIN)
	sprintf((char *)newval, "" ++bin"");
    else if (eap->force_bin == FORCE_NOBIN)
	sprintf((char *)newval, "" ++nobin"");
",1,unused,21725,unused,"
    if (eap->force_bin == FORCE_BIN)
	sprintf((char *)newval, "" ++bin"");
    else if (eap->force_bin == FORCE_NOBIN)
	sprintf((char *)newval, "" ++nobin"");
",unused,vimactualxenialpreviousversion-src2Feval.c
"    if (eap->read_edit)
	STRCAT(newval, "" ++edit"");

    if (eap->force_ff != 0)
	sprintf((char *)newval + STRLEN(newval), "" ++ff=%s"",
",1,unused,21733,unused,"    if (eap->read_edit)
	STRCAT(newval, "" ++edit"");

    if (eap->force_ff != 0)
	sprintf((char *)newval + STRLEN(newval), "" ++ff=%s"",
",unused,vimactualxenialpreviousversion-src2Feval.c
"	sprintf((char *)newval + STRLEN(newval), "" ++ff=%s"",
						eap->cmd + eap->force_ff);
# ifdef FEAT_MBYTE
    if (eap->force_enc != 0)
	sprintf((char *)newval + STRLEN(newval), "" ++enc=%s"",
",1,unused,21737,unused,"	sprintf((char *)newval + STRLEN(newval), "" ++ff=%s"",
						eap->cmd + eap->force_ff);
# ifdef FEAT_MBYTE
    if (eap->force_enc != 0)
	sprintf((char *)newval + STRLEN(newval), "" ++enc=%s"",
",unused,vimactualxenialpreviousversion-src2Feval.c
"	STRCPY(newval + STRLEN(newval), "" ++bad=keep"");
    else if (eap->bad_char == BAD_DROP)
	STRCPY(newval + STRLEN(newval), "" ++bad=drop"");
    else if (eap->bad_char != 0)
	sprintf((char *)newval + STRLEN(newval), "" ++bad=%c"", eap->bad_char);
",1,unused,21744,unused,"	STRCPY(newval + STRLEN(newval), "" ++bad=keep"");
    else if (eap->bad_char == BAD_DROP)
	STRCPY(newval + STRLEN(newval), "" ++bad=drop"");
    else if (eap->bad_char != 0)
	sprintf((char *)newval + STRLEN(newval), "" ++bad=%c"", eap->bad_char);
",unused,vimactualxenialpreviousversion-src2Feval.c
"{
    switch (varp->v_type)
    {
	case VAR_NUMBER:
	    sprintf((char *)buf, ""%ld"", (long)varp->vval.v_number);
",1,unused,22301,unused,"{
    switch (varp->v_type)
    {
	case VAR_NUMBER:
	    sprintf((char *)buf, ""%ld"", (long)varp->vval.v_number);
",unused,vimactualxenialpreviousversion-src2Feval.c
"
	/* Give the function a sequential number.  Can only be used with a
	 * Funcref! */
	vim_free(name);
	sprintf(numbuf, ""%d"", ++func_nr);
",1,unused,23915,unused,"
	/* Give the function a sequential number.  Can only be used with a
	 * Funcref! */
	vim_free(name);
	sprintf(numbuf, ""%d"", ++func_nr);
",unused,vimactualxenialpreviousversion-src2Feval.c
"	    {
		EMSG(_(e_usingsid));
		goto theend;
	    }
	    sprintf((char *)sid_buf, ""%ld_"", (long)current_SID);
",1,unused,24204,unused,"	    {
		EMSG(_(e_usingsid));
		goto theend;
	    }
	    sprintf((char *)sid_buf, ""%ld_"", (long)current_SID);
",unused,vimactualxenialpreviousversion-src2Feval.c
"	    name = FUNCARG(fp, i);
	else
	{
	    /* ""..."" argument a:1, a:2, etc. */
	    sprintf((char *)numbuf, ""%d"", ai + 1);
",1,unused,24978,unused,"	    name = FUNCARG(fp, i);
	else
	{
	    /* ""..."" argument a:1, a:2, etc. */
	    sprintf((char *)numbuf, ""%d"", ai + 1);
",unused,vimactualxenialpreviousversion-src2Feval.c
"    if (sourcing_name != NULL)
    {
	if (save_sourcing_name != NULL
			  && STRNCMP(save_sourcing_name, ""function "", 9) == 0)
	    sprintf((char *)sourcing_name, ""%s[%d].."",
",1,unused,25023,unused,"    if (sourcing_name != NULL)
    {
	if (save_sourcing_name != NULL
			  && STRNCMP(save_sourcing_name, ""function "", 9) == 0)
	    sprintf((char *)sourcing_name, ""%s[%d].."",
",unused,vimactualxenialpreviousversion-src2Feval.c
"	    if (s == NULL)
		got_int = TRUE;
	    else
	    {
		sprintf((char *)s, ""help-tags\t%s\t1\n"", tagfname);
",1,unused,6663,unused,"	    if (s == NULL)
		got_int = TRUE;
	    else
	    {
		sprintf((char *)s, ""help-tags\t%s\t1\n"", tagfname);
",unused,vimactualxenialpreviousversion-src2Fex_cmds.c
"			    break;
			}
			((char_u **)ga.ga_data)[ga.ga_len] = s;
			++ga.ga_len;
			sprintf((char *)s, ""%s\t%s"", p1, fname);
",1,unused,6759,unused,"			    break;
			}
			((char_u **)ga.ga_data)[ga.ga_len] = s;
			++ga.ga_len;
			sprintf((char *)s, ""%s\t%s"", p1, fname);
",unused,vimactualxenialpreviousversion-src2Fex_cmds.c
"
		    cmd = alloc((unsigned)STRLEN(buf->b_fname) + 25);
		    if (cmd == NULL)
			return;
		    sprintf((char *)cmd, ""e +%ld %s"", (long)lnum, buf->b_fname);
",1,unused,7403,unused,"
		    cmd = alloc((unsigned)STRLEN(buf->b_fname) + 25);
		    if (cmd == NULL)
			return;
		    sprintf((char *)cmd, ""e +%ld %s"", (long)lnum, buf->b_fname);
",unused,vimactualxenialpreviousversion-src2Fex_cmds.c
"
    QueryPerformanceFrequency(&fr);
    sprintf(buf, ""%10.6lf"", (double)tm->QuadPart / (double)fr.QuadPart);
# else
    sprintf(buf, ""%3ld.%06ld"", (long)tm->tv_sec, (long)tm->tv_usec);
",1,unused,1003,unused,"
    QueryPerformanceFrequency(&fr);
    sprintf(buf, ""%10.6lf"", (double)tm->QuadPart / (double)fr.QuadPart);
# else
    sprintf(buf, ""%3ld.%06ld"", (long)tm->tv_sec, (long)tm->tv_usec);
",unused,vimactualxenialpreviousversion-src2Fex_cmds2.c
"	    }
	    do_unlet((char_u *)""g:current_compiler"", TRUE);
	    do_unlet((char_u *)""b:current_compiler"", TRUE);

	    sprintf((char *)buf, ""compiler/%s.vim"", eap->arg);
",1,unused,3042,unused,"	    }
	    do_unlet((char_u *)""g:current_compiler"", TRUE);
	    do_unlet((char_u *)""b:current_compiler"", TRUE);

	    sprintf((char *)buf, ""compiler/%s.vim"", eap->arg);
",unused,vimactualxenialpreviousversion-src2Fex_cmds2.c
"	    {
		if (a & COUNT)
		{
		    /* -count=N */
		    sprintf((char *)IObuff + len, ""%ldc"", cmd->uc_def);
",1,unused,5934,unused,"	    {
		if (a & COUNT)
		{
		    /* -count=N */
		    sprintf((char *)IObuff + len, ""%ldc"", cmd->uc_def);
",unused,vimactualxenialpreviousversion-src2Fex_docmd.c
"		    IObuff[len++] = '%';
		else if (cmd->uc_def >= 0)
		{
		    /* -range=N */
		    sprintf((char *)IObuff + len, ""%ld"", cmd->uc_def);
",1,unused,5942,unused,"		    IObuff[len++] = '%';
		else if (cmd->uc_def >= 0)
		{
		    /* -range=N */
		    sprintf((char *)IObuff + len, ""%ld"", cmd->uc_def);
",unused,vimactualxenialpreviousversion-src2Fex_docmd.c
"		   (type == ct_LINE2) ? eap->line2 :
		   (eap->addr_count > 0) ? eap->line2 : cmd->uc_def;
	size_t num_len;

	sprintf(num_buf, ""%ld"", num);
",1,unused,6568,unused,"		   (type == ct_LINE2) ? eap->line2 :
		   (eap->addr_count > 0) ? eap->line2 : cmd->uc_def;
	size_t num_len;

	sprintf(num_buf, ""%ld"", num);
",unused,vimactualxenialpreviousversion-src2Fex_docmd.c
"#  else
	if (mch_get_winpos(&x, &y) != FAIL)
#  endif
	{
	    sprintf((char *)IObuff, _(""Window position: X %d, Y %d""), x, y);
",1,unused,9005,unused,"#  else
	if (mch_get_winpos(&x, &y) != FAIL)
#  endif
	{
	    sprintf((char *)IObuff, _(""Window position: X %d, Y %d""), x, y);
",unused,vimactualxenialpreviousversion-src2Fex_docmd.c
"		{
		    *errormsg = (char_u *)_(""E496: no autocommand buffer number to substitute for \""<abuf>\"""");
		    return NULL;
		}
		sprintf((char *)strbuf, ""%d"", autocmd_bufnr);
",1,unused,10522,unused,"		{
		    *errormsg = (char_u *)_(""E496: no autocommand buffer number to substitute for \""<abuf>\"""");
		    return NULL;
		}
		sprintf((char *)strbuf, ""%d"", autocmd_bufnr);
",unused,vimactualxenialpreviousversion-src2Fex_docmd.c
"		{
		    *errormsg = (char_u *)_(""E842: no line number to use for \""<slnum>\"""");
		    return NULL;
		}
		sprintf((char *)strbuf, ""%ld"", (long)sourcing_lnum);
",1,unused,10550,unused,"		{
		    *errormsg = (char_u *)_(""E842: no line number to use for \""<slnum>\"""");
		    return NULL;
		}
		sprintf((char *)strbuf, ""%ld"", (long)sourcing_lnum);
",unused,vimactualxenialpreviousversion-src2Fex_docmd.c
"		result = strbuf;
		break;
#if defined(FEAT_CLIENTSERVER)
	case SPEC_CLIENT:	/* Source of last submitted input */
		sprintf((char *)strbuf, PRINTF_HEX_LONG_U,
",1,unused,10555,unused,"		result = strbuf;
		break;
#if defined(FEAT_CLIENTSERVER)
	case SPEC_CLIENT:	/* Source of last submitted input */
		sprintf((char *)strbuf, PRINTF_HEX_LONG_U,
",unused,vimactualxenialpreviousversion-src2Fex_docmd.c
"			continue;

		    STRCAT(val, p);
		    p[-2] = NUL;
		    sprintf((char *)(val + STRLEN(p)), "" (%s)"", &mesg[1]);
",1,unused,482,unused,"			continue;

		    STRCAT(val, p);
		    p[-2] = NUL;
		    sprintf((char *)(val + STRLEN(p)), "" (%s)"", &mesg[1]);
",unused,vimactualxenialpreviousversion-src2Fex_eval.c
"    }

    args[0] = vim_strnsave(xp->xp_pattern, xp->xp_pattern_len);
    args[1] = xp->xp_line;
    sprintf((char *)num, ""%d"", xp->xp_col);
",1,unused,5031,unused,"    }

    args[0] = vim_strnsave(xp->xp_pattern, xp->xp_pattern_len);
    args[1] = xp->xp_line;
    sprintf((char *)num, ""%d"", xp->xp_col);
",unused,vimactualxenialpreviousversion-src2Fex_getln.c
"	{
	    ga_clear_strings(&ga);
	    return FAIL;
	}
	sprintf((char *)s, ""%s/%s*.vim"", dirnames[i], pat);
",1,unused,5181,unused,"	{
	    ga_clear_strings(&ga);
	    return FAIL;
	}
	sprintf((char *)s, ""%s/%s*.vim"", dirnames[i], pat);
",unused,vimactualxenialpreviousversion-src2Fex_getln.c
"	    {
		ga_clear_strings(&ga);
		return FAIL;
	    }
	    sprintf((char *)s, ""pack/*/start/*/%s/%s*.vim"", dirnames[i], pat);
",1,unused,5195,unused,"	    {
		ga_clear_strings(&ga);
		return FAIL;
	    }
	    sprintf((char *)s, ""pack/*/start/*/%s/%s*.vim"", dirnames[i], pat);
",unused,vimactualxenialpreviousversion-src2Fex_getln.c
"	    {
		ga_clear_strings(&ga);
		return FAIL;
	    }
	    sprintf((char *)s, ""pack/*/opt/*/%s/%s*.vim"", dirnames[i], pat);
",1,unused,5210,unused,"	    {
		ga_clear_strings(&ga);
		return FAIL;
	    }
	    sprintf((char *)s, ""pack/*/opt/*/%s/%s*.vim"", dirnames[i], pat);
",unused,vimactualxenialpreviousversion-src2Fex_getln.c
"    {
	ga_clear_strings(&ga);
	return FAIL;
    }
    sprintf((char *)s, ""pack/*/opt/%s*"", pat);
",1,unused,5273,unused,"    {
	ga_clear_strings(&ga);
	return FAIL;
    }
    sprintf((char *)s, ""pack/*/opt/%s*"", pat);
",unused,vimactualxenialpreviousversion-src2Fex_getln.c
"		if (hist[i].hisstr != NULL
			&& hist[i].hisnum >= j && hist[i].hisnum <= k)
		{
		    msg_putchar('\n');
		    sprintf((char *)IObuff, ""%c%6d  "", i == idx ? '>' : ' ',
",1,unused,6107,unused,"		if (hist[i].hisstr != NULL
			&& hist[i].hisnum >= j && hist[i].hisnum <= k)
		{
		    msg_putchar('\n');
		    sprintf((char *)IObuff, ""%c%6d  "", i == idx ? '>' : ' ',
",unused,vimactualxenialpreviousversion-src2Fex_getln.c
"#endif
#ifdef FEAT_MBYTE
	    if (conv_error != 0)
	    {
		sprintf((char *)IObuff + STRLEN(IObuff),
",1,unused,2520,unused,"#endif
#ifdef FEAT_MBYTE
	    if (conv_error != 0)
	    {
		sprintf((char *)IObuff + STRLEN(IObuff),
",unused,vimactualxenialpreviousversion-src2Ffileio.c
"		c = TRUE;
	    }
	    else if (illegal_byte > 0)
	    {
		sprintf((char *)IObuff + STRLEN(IObuff),
",1,unused,2526,unused,"		c = TRUE;
	    }
	    else if (illegal_byte > 0)
	    {
		sprintf((char *)IObuff + STRLEN(IObuff),
",unused,vimactualxenialpreviousversion-src2Ffileio.c
"    if (eap->cmd == NULL)
	return FAIL;

#ifdef FEAT_MBYTE
    sprintf((char *)eap->cmd, ""e ++ff=%s ++enc=%s"", buf->b_p_ff, buf->b_p_fenc);
",1,unused,2750,unused,"    if (eap->cmd == NULL)
	return FAIL;

#ifdef FEAT_MBYTE
    sprintf((char *)eap->cmd, ""e ++ff=%s ++enc=%s"", buf->b_p_ff, buf->b_p_fenc);
",unused,vimactualxenialpreviousversion-src2Ffileio.c
"		 */
		STRCPY(IObuff, fname);
		for (i = 4913; ; i += 123)
		{
		    sprintf((char *)gettail(IObuff), ""%d"", i);
",1,unused,3699,unused,"		 */
		STRCPY(IObuff, fname);
		for (i = 4913; ; i += 123)
		{
		    sprintf((char *)gettail(IObuff), ""%d"", i);
",unused,vimactualxenialpreviousversion-src2Ffileio.c
"
    if (insert_space)
	*p++ = ' ';
    if (shortmess(SHM_LINES))
	sprintf((char *)p,
",1,unused,5208,unused,"
    if (insert_space)
	*p++ = ' ';
    if (shortmess(SHM_LINES))
	sprintf((char *)p,
",unused,vimactualxenialpreviousversion-src2Ffileio.c
"    {
	if (lnum == 1)
	    STRCPY(p, _(""1 line, ""));
	else
	    sprintf((char *)p, _(""%ld lines, ""), lnum);
",1,unused,5221,unused,"    {
	if (lnum == 1)
	    STRCPY(p, _(""1 line, ""));
	else
	    sprintf((char *)p, _(""%ld lines, ""), lnum);
",unused,vimactualxenialpreviousversion-src2Ffileio.c
"	p += STRLEN(p);
	if (nchars == 1)
	    STRCPY(p, _(""1 character""));
	else
	    sprintf((char *)p,
",1,unused,5226,unused,"	p += STRLEN(p);
	if (nchars == 1)
	    STRCPY(p, _(""1 character""));
	else
	    sprintf((char *)p,
",unused,vimactualxenialpreviousversion-src2Ffileio.c
"	    return -1;
	STRCPY(tempname, from);
	for (n = 123; n < 99999; ++n)
	{
	    sprintf((char *)gettail((char_u *)tempname), ""%d"", n);
",1,unused,6487,unused,"	    return -1;
	STRCPY(tempname, from);
	for (n = 123; n < 99999; ++n)
	{
	    sprintf((char *)gettail((char_u *)tempname), ""%d"", n);
",unused,vimactualxenialpreviousversion-src2Ffileio.c
"	    if (!helpmesg)
		mesg2 = """";
	    tbuf = alloc((unsigned)(STRLEN(path) + STRLEN(mesg)
							+ STRLEN(mesg2) + 2));
	    sprintf((char *)tbuf, mesg, path);
",1,unused,6930,unused,"	    if (!helpmesg)
		mesg2 = """";
	    tbuf = alloc((unsigned)(STRLEN(path) + STRLEN(mesg)
							+ STRLEN(mesg2) + 2));
	    sprintf((char *)tbuf, mesg, path);
",unused,vimactualxenialpreviousversion-src2Ffileio.c
"    if (vim_tempdir != NULL)
    {
	/* There is no need to check if the file exists, because we own the
	 * directory and nobody else creates a file in it. */
	sprintf((char *)itmp, ""%s%ld"", vim_tempdir, temp_count++);
",1,unused,7429,unused,"    if (vim_tempdir != NULL)
    {
	/* There is no need to check if the file exists, because we own the
	 * directory and nobody else creates a file in it. */
	sprintf((char *)itmp, ""%s%ld"", vim_tempdir, temp_count++);
",unused,vimactualxenialpreviousversion-src2Ffileio.c
"
	if (is_buflocal)
	{
	    /* normalize pat into standard ""<buffer>#N"" form */
	    sprintf((char *)buflocal_pat, ""<buffer=%d>"", buflocal_nr);
",1,unused,8500,unused,"
	if (is_buflocal)
	{
	    /* normalize pat into standard ""<buffer>#N"" form */
	    sprintf((char *)buflocal_pat, ""<buffer=%d>"", buflocal_nr);
",unused,vimactualxenialpreviousversion-src2Ffileio.c
"		sourcing_name = alloc((unsigned)(STRLEN(s)
					    + STRLEN(name) + ap->patlen + 1));
		if (sourcing_name != NULL)
		{
		    sprintf((char *)sourcing_name, s,
",1,unused,9621,unused,"		sourcing_name = alloc((unsigned)(STRLEN(s)
					    + STRLEN(name) + ap->patlen + 1));
		if (sourcing_name != NULL)
		{
		    sprintf((char *)sourcing_name, s,
",unused,vimactualxenialpreviousversion-src2Ffileio.c
"    }
    if (text == NULL)
#endif
    {
	sprintf((char *)buf, _(""+--%3ld lines folded ""),
",1,unused,1960,unused,"    }
    if (text == NULL)
#endif
    {
	sprintf((char *)buf, _(""+--%3ld lines folded ""),
",unused,vimactualxenialpreviousversion-src2Ffold.c
"add_num_buff(buffheader_T *buf, long n)
{
    char_u	number[32];

    sprintf((char *)number, ""%ld"", n);
",1,unused,295,unused,"add_num_buff(buffheader_T *buf, long n)
{
    char_u	number[32];

    sprintf((char *)number, ""%ld"", n);
",unused,vimactualxenialpreviousversion-src2Fgetchar.c
"		i = getdigits(&p);
		if (i != 0)
		{
		    /* Double the width specification. */
		    sprintf((char *)wp, ""%d%s"", i * 2, p);
",1,unused,951,unused,"		i = getdigits(&p);
		if (i != 0)
		{
		    /* Double the width specification. */
		    sprintf((char *)wp, ""%d%s"", i * 2, p);
",unused,vimactualxenialpreviousversion-src2Fgui.c
"    if (strcmp(path, SFcurrentDir))
    {
	result = mch_chdir(path);
	if (!result)
	    (void) strcpy(SFcurrentDir, path);
",1,unused,253,unused,"    if (strcmp(path, SFcurrentDir))
    {
	result = mch_chdir(path);
	if (!result)
	    (void) strcpy(SFcurrentDir, path);
",unused,vimactualxenialpreviousversion-src2Fgui_at_fs.c
"
    static void
SFstrdup(char **s1, char *s2)
{
    *s1 = strcpy(XtMalloc((unsigned)(strlen(s2) + 1)), s2);
",1,unused,287,unused,"
    static void
SFstrdup(char **s1, char *s2)
{
    *s1 = strcpy(XtMalloc((unsigned)(strlen(s2) + 1)), s2);
",unused,vimactualxenialpreviousversion-src2Fgui_at_fs.c
"
    *(dir->path) = 0;
    len = strlen(str);
    if (str[len - 1] == '/')
	(void) strcat(SFcurrentPath, str);
",1,unused,315,unused,"
    *(dir->path) = 0;
    len = strlen(str);
    if (str[len - 1] == '/')
	(void) strcat(SFcurrentPath, str);
",unused,vimactualxenialpreviousversion-src2Fgui_at_fs.c
"    i = 1;
    entries = (SFEntry *)XtMalloc(sizeof(SFEntry));
    SFlogins = (SFLogin *)XtMalloc(sizeof(SFLogin));
    entries[0].real = XtMalloc(3);
    (void) strcpy(entries[0].real, ""~"");
",1,unused,520,unused,"    i = 1;
    entries = (SFEntry *)XtMalloc(sizeof(SFEntry));
    SFlogins = (SFLogin *)XtMalloc(sizeof(SFLogin));
    entries[0].real = XtMalloc(3);
    (void) strcpy(entries[0].real, ""~"");
",unused,vimactualxenialpreviousversion-src2Fgui_at_fs.c
"					 (unsigned)(Alloc * sizeof(SFLogin)));
	}
	len = strlen(pw->pw_name);
	entries[i].real = XtMalloc((unsigned) (len + 3));
	(void) strcat(strcpy(entries[i].real, ""~""), pw->pw_name);
",1,unused,542,unused,"					 (unsigned)(Alloc * sizeof(SFLogin)));
	}
	len = strlen(pw->pw_name);
	entries[i].real = XtMalloc((unsigned) (len + 3));
	(void) strcat(strcpy(entries[i].real, ""~""), pw->pw_name);
",unused,vimactualxenialpreviousversion-src2Fgui_at_fs.c
"					 (unsigned)(Alloc * sizeof(SFLogin)));
	}
	len = strlen(pw->pw_name);
	entries[i].real = XtMalloc((unsigned) (len + 3));
	(void) strcat(strcpy(entries[i].real, ""~""), pw->pw_name);
",1,unused,542,unused,"					 (unsigned)(Alloc * sizeof(SFLogin)));
	}
	len = strlen(pw->pw_name);
	entries[i].real = XtMalloc((unsigned) (len + 3));
	(void) strcat(strcpy(entries[i].real, ""~""), pw->pw_name);
",unused,vimactualxenialpreviousversion-src2Fgui_at_fs.c
"    qsort((char *)entries, (size_t)i, sizeof(SFEntry), SFcompareEntries);
    qsort((char *)SFlogins, (size_t)i, sizeof(SFLogin), SFcompareLogins);

    for (i--; i >= 0; i--)
	(void)strcat(entries[i].real, ""/"");
",1,unused,568,unused,"    qsort((char *)entries, (size_t)i, sizeof(SFEntry), SFcompareEntries);
    qsort((char *)SFlogins, (size_t)i, sizeof(SFLogin), SFcompareLogins);

    for (i--; i >= 0; i--)
	(void)strcat(entries[i].real, ""/"");
",unused,vimactualxenialpreviousversion-src2Fgui_at_fs.c
"	if (!strcmp(SFhomeDir.entries[i].real, begin))
	{
	    *end = save;
	    SFstrdup(&theRest, end);
	    (void) strcat(strcat(strcpy(SFcurrentPath,
",1,unused,589,unused,"	if (!strcmp(SFhomeDir.entries[i].real, begin))
	{
	    *end = save;
	    SFstrdup(&theRest, end);
	    (void) strcat(strcat(strcpy(SFcurrentPath,
",unused,vimactualxenialpreviousversion-src2Fgui_at_fs.c
"	if (!strcmp(SFhomeDir.entries[i].real, begin))
	{
	    *end = save;
	    SFstrdup(&theRest, end);
	    (void) strcat(strcat(strcpy(SFcurrentPath,
",1,unused,589,unused,"	if (!strcmp(SFhomeDir.entries[i].real, begin))
	{
	    *end = save;
	    SFstrdup(&theRest, end);
	    (void) strcat(strcat(strcpy(SFcurrentPath,
",unused,vimactualxenialpreviousversion-src2Fgui_at_fs.c
"	if (!strcmp(SFhomeDir.entries[i].real, begin))
	{
	    *end = save;
	    SFstrdup(&theRest, end);
	    (void) strcat(strcat(strcpy(SFcurrentPath,
",1,unused,589,unused,"	if (!strcmp(SFhomeDir.entries[i].real, begin))
	{
	    *end = save;
	    SFstrdup(&theRest, end);
	    (void) strcat(strcat(strcpy(SFcurrentPath,
",unused,vimactualxenialpreviousversion-src2Fgui_at_fs.c
"			int len;

			len = strlen(shown);
			entry->shown = XtMalloc((unsigned) (len + 2));
			(void) strcpy(entry->shown, shown);
",1,unused,1366,unused,"			int len;

			len = strlen(shown);
			entry->shown = XtMalloc((unsigned) (len + 2));
			(void) strcpy(entry->shown, shown);
",unused,vimactualxenialpreviousversion-src2Fgui_at_fs.c
"	result[i].statDone = 0;
	str = dp->d_name;
	len = strlen(str);
	result[i].real = XtMalloc((unsigned) (len + 2));
	(void) strcat(strcpy(result[i].real, str), "" "");
",1,unused,2095,unused,"	result[i].statDone = 0;
	str = dp->d_name;
	len = strlen(str);
	result[i].real = XtMalloc((unsigned) (len + 2));
	(void) strcat(strcpy(result[i].real, str), "" "");
",unused,vimactualxenialpreviousversion-src2Fgui_at_fs.c
"	result[i].statDone = 0;
	str = dp->d_name;
	len = strlen(str);
	result[i].real = XtMalloc((unsigned) (len + 2));
	(void) strcat(strcpy(result[i].real, str), "" "");
",1,unused,2095,unused,"	result[i].statDone = 0;
	str = dp->d_name;
	len = strlen(str);
	result[i].real = XtMalloc((unsigned) (len + 2));
	(void) strcat(strcpy(result[i].real, str), "" "");
",unused,vimactualxenialpreviousversion-src2Fgui_at_fs.c
"	    SFtextPos = XawTextGetInsertionPoint(selFileField);
	}
	else
	{
	    strcpy(SFcurrentPath, SFstartDir);
",1,unused,2637,unused,"	    SFtextPos = XawTextGetInsertionPoint(selFileField);
	}
	else
	{
	    strcpy(SFcurrentPath, SFstartDir);
",unused,vimactualxenialpreviousversion-src2Fgui_at_fs.c
"    else
#endif
    if ((SFtextBuffer[0] == '/') || (SFtextBuffer[0] == '~'))
    {
	(void) strcpy(SFcurrentPath, SFtextBuffer);
",1,unused,2647,unused,"    else
#endif
    if ((SFtextBuffer[0] == '/') || (SFtextBuffer[0] == '~'))
    {
	(void) strcpy(SFcurrentPath, SFtextBuffer);
",unused,vimactualxenialpreviousversion-src2Fgui_at_fs.c
"	SFtextPos = XawTextGetInsertionPoint(selFileField);
    }
    else
    {
	(void) strcat(strcpy(SFcurrentPath, SFstartDir), SFtextBuffer);
",1,unused,2652,unused,"	SFtextPos = XawTextGetInsertionPoint(selFileField);
    }
    else
    {
	(void) strcat(strcpy(SFcurrentPath, SFstartDir), SFtextBuffer);
",unused,vimactualxenialpreviousversion-src2Fgui_at_fs.c
"	SFtextPos = XawTextGetInsertionPoint(selFileField);
    }
    else
    {
	(void) strcat(strcpy(SFcurrentPath, SFstartDir), SFtextBuffer);
",1,unused,2652,unused,"	SFtextPos = XawTextGetInsertionPoint(selFileField);
    }
    else
    {
	(void) strcat(strcpy(SFcurrentPath, SFstartDir), SFtextBuffer);
",unused,vimactualxenialpreviousversion-src2Fgui_at_fs.c
"
    XtVaSetValues(selFile, XtNx, x, XtNy, y, NULL);
    XtMapWidget(selFile);

    (void)strcat(SFstartDir, ""/"");
",1,unused,2750,unused,"
    XtVaSetValues(selFile, XtNx, x, XtNy, y, NULL);
    XtMapWidget(selFile);

    (void)strcat(SFstartDir, ""/"");
",unused,vimactualxenialpreviousversion-src2Fgui_at_fs.c
"    XtVaSetValues(selFile, XtNx, x, XtNy, y, NULL);
    XtMapWidget(selFile);

    (void)strcat(SFstartDir, ""/"");
    (void)strcpy(SFcurrentDir, SFstartDir);
",1,unused,2751,unused,"    XtVaSetValues(selFile, XtNx, x, XtNy, y, NULL);
    XtMapWidget(selFile);

    (void)strcat(SFstartDir, ""/"");
    (void)strcpy(SFcurrentDir, SFstartDir);
",unused,vimactualxenialpreviousversion-src2Fgui_at_fs.c
"    if (init_path)
    {
	if (init_path[0] == '/')
	{
	    (void)strcpy(SFcurrentPath, init_path);
",1,unused,2757,unused,"    if (init_path)
    {
	if (init_path[0] == '/')
	{
	    (void)strcpy(SFcurrentPath, init_path);
",unused,vimactualxenialpreviousversion-src2Fgui_at_fs.c
"		SFsetText(&(SFcurrentPath[strlen(SFstartDir)]));
	}
	else
	{
	    (void)strcat(strcpy(SFcurrentPath, SFstartDir), init_path);
",1,unused,2765,unused,"		SFsetText(&(SFcurrentPath[strlen(SFstartDir)]));
	}
	else
	{
	    (void)strcat(strcpy(SFcurrentPath, SFstartDir), init_path);
",unused,vimactualxenialpreviousversion-src2Fgui_at_fs.c
"		SFsetText(&(SFcurrentPath[strlen(SFstartDir)]));
	}
	else
	{
	    (void)strcat(strcpy(SFcurrentPath, SFstartDir), init_path);
",1,unused,2765,unused,"		SFsetText(&(SFcurrentPath[strlen(SFstartDir)]));
	}
	else
	{
	    (void)strcat(strcpy(SFcurrentPath, SFstartDir), init_path);
",unused,vimactualxenialpreviousversion-src2Fgui_at_fs.c
"	    SFsetText(&(SFcurrentPath[strlen(SFstartDir)]));
	}
    }
    else
	(void)strcpy(SFcurrentPath, SFstartDir);
",1,unused,2770,unused,"	    SFsetText(&(SFcurrentPath[strlen(SFstartDir)]));
	}
    }
    else
	(void)strcpy(SFcurrentPath, SFstartDir);
",unused,vimactualxenialpreviousversion-src2Fgui_at_fs.c
"
    pname = vim_strnsave(name, STRLEN(name) + strlen(""-pullright""));
    if (pname != NULL)
    {
	strcat((char *)pname, ""-pullright"");
",1,unused,1141,unused,"
    pname = vim_strnsave(name, STRLEN(name) + strlen(""-pullright""));
    if (pname != NULL)
    {
	strcat((char *)pname, ""-pullright"");
",unused,vimactualxenialpreviousversion-src2Fgui_athena.c
"    mch_print_start_line(TRUE, page_line);

    /* Leave two spaces between the number and the text; depends on
     * PRINT_NUMBER_WIDTH. */
    sprintf((char *)tbuf, ""%6ld"", (long)lnum);
",1,unused,374,unused,"    mch_print_start_line(TRUE, page_line);

    /* Leave two spaces between the number and the text; depends on
     * PRINT_NUMBER_WIDTH. */
    sprintf((char *)tbuf, ""%6ld"", (long)lnum);
",unused,vimactualxenialpreviousversion-src2Fhardcopy.c
"	curwin->w_botline = tmp_botline;
    }
    else
#endif
	sprintf((char *)tbuf, _(""Page %d""), pagenum);
",1,unused,493,unused,"	curwin->w_botline = tmp_botline;
    }
    else
#endif
	sprintf((char *)tbuf, _(""Page %d""), pagenum);
",unused,vimactualxenialpreviousversion-src2Fhardcopy.c
"		    ui_breakcheck();
		    if (got_int || settings.user_abort)
			goto print_fail;

		    sprintf((char *)IObuff, _(""Printing page %d (%d%%)""),
",1,unused,726,unused,"		    ui_breakcheck();
		    if (got_int || settings.user_abort)
			goto print_fail;

		    sprintf((char *)IObuff, _(""Printing page %d (%d%%)""),
",unused,vimactualxenialpreviousversion-src2Fhardcopy.c
"		    if (!mch_print_begin_page(IObuff))
			goto print_fail;

		    if (settings.n_collated_copies > 1)
			sprintf((char *)IObuff + STRLEN(IObuff),
",1,unused,737,unused,"		    if (!mch_print_begin_page(IObuff))
			goto print_fail;

		    if (settings.n_collated_copies > 1)
			sprintf((char *)IObuff + STRLEN(IObuff),
",unused,vimactualxenialpreviousversion-src2Fhardcopy.c
"
print_fail:
    if (got_int || settings.user_abort)
    {
	sprintf((char *)IObuff, ""%s"", _(""Printing aborted""));
",1,unused,804,unused,"
print_fail:
    if (got_int || settings.user_abort)
    {
	sprintf((char *)IObuff, ""%s"", _(""Printing aborted""));
",unused,vimactualxenialpreviousversion-src2Fhardcopy.c
" */
    static void
prt_write_int(int i)
{
    sprintf((char *)prt_line_buffer, ""%d "", i);
",1,unused,1493,unused," */
    static void
prt_write_int(int i)
{
    sprintf((char *)prt_line_buffer, ""%d "", i);
",unused,vimactualxenialpreviousversion-src2Fhardcopy.c
" */
    static void
prt_write_boolean(int b)
{
    sprintf((char *)prt_line_buffer, ""%s "", (b ? ""T"" : ""F""));
",1,unused,1503,unused," */
    static void
prt_write_boolean(int b)
{
    sprintf((char *)prt_line_buffer, ""%s "", (b ? ""T"" : ""F""));
",unused,vimactualxenialpreviousversion-src2Fhardcopy.c
"			  ""/_%s /VIM-%s /%s ref\n"", new_name, encoding, font);
    prt_write_file(prt_line_buffer);
#ifdef FEAT_MBYTE
    if (prt_out_mbyte)
	sprintf((char *)prt_line_buffer, ""/%s %d %f /_%s sffs\n"",
",1,unused,1522,unused,"			  ""/_%s /VIM-%s /%s ref\n"", new_name, encoding, font);
    prt_write_file(prt_line_buffer);
#ifdef FEAT_MBYTE
    if (prt_out_mbyte)
	sprintf((char *)prt_line_buffer, ""/%s %d %f /_%s sffs\n"",
",unused,vimactualxenialpreviousversion-src2Fhardcopy.c
"    int     fraction;

    prt_real_bits(val, prec, &integer, &fraction);
    /* Emit integer part */
    sprintf((char *)prt_line_buffer, ""%d"", integer);
",1,unused,1598,unused,"    int     fraction;

    prt_real_bits(val, prec, &integer, &fraction);
    /* Emit integer part */
    sprintf((char *)prt_line_buffer, ""%d"", integer);
",unused,vimactualxenialpreviousversion-src2Fhardcopy.c
"	    prec--;
	    fraction /= 10;
	}
	/* Emit fraction left padded with zeros */
	sprintf((char *)prt_line_buffer, "".%0*d"", prec, fraction);
",1,unused,1610,unused,"	    prec--;
	    fraction /= 10;
	}
	/* Emit fraction left padded with zeros */
	sprintf((char *)prt_line_buffer, "".%0*d"", prec, fraction);
",unused,vimactualxenialpreviousversion-src2Fhardcopy.c
"	/* Emit fraction left padded with zeros */
	sprintf((char *)prt_line_buffer, "".%0*d"", prec, fraction);
	prt_write_file(prt_line_buffer);
    }
    sprintf((char *)prt_line_buffer, "" "");
",1,unused,1613,unused,"	/* Emit fraction left padded with zeros */
	sprintf((char *)prt_line_buffer, "".%0*d"", prec, fraction);
	prt_write_file(prt_line_buffer);
    }
    sprintf((char *)prt_line_buffer, "" "");
",unused,vimactualxenialpreviousversion-src2Fhardcopy.c
"    vim_snprintf((char *)prt_line_buffer, sizeof(prt_line_buffer),
								""/%s "", name);
    prt_write_file(prt_line_buffer);
    prt_write_real(value, prec);
    sprintf((char *)prt_line_buffer, ""d\n"");
",1,unused,1627,unused,"    vim_snprintf((char *)prt_line_buffer, sizeof(prt_line_buffer),
								""/%s "", name);
    prt_write_file(prt_line_buffer);
    prt_write_real(value, prec);
    sprintf((char *)prt_line_buffer, ""d\n"");
",unused,vimactualxenialpreviousversion-src2Fhardcopy.c
"    prt_write_file(prt_line_buffer);

    for (i = 0; i < count; i++)
    {
	sprintf((char *)prt_line_buffer, "" %d"", ints[i]);
",1,unused,2070,unused,"    prt_write_file(prt_line_buffer);

    for (i = 0; i < count; i++)
    {
	sprintf((char *)prt_line_buffer, "" %d"", ints[i]);
",unused,vimactualxenialpreviousversion-src2Fhardcopy.c
"     */
    if (!(duplex || collate || color || (num_copies > 1)))
	return;

    sprintf((char *)prt_line_buffer, ""%%%%Requirements:"");
",1,unused,2122,unused,"     */
    if (!(duplex || collate || color || (num_copies > 1)))
	return;

    sprintf((char *)prt_line_buffer, ""%%%%Requirements:"");
",unused,vimactualxenialpreviousversion-src2Fhardcopy.c
"    if (num_copies > 1)
    {
	prt_write_string("" numcopies("");
	/* Note: no space wanted so don't use prt_write_int() */
	sprintf((char *)prt_line_buffer, ""%d"", num_copies);
",1,unused,2139,unused,"    if (num_copies > 1)
    {
	prt_write_string("" numcopies("");
	/* Note: no space wanted so don't use prt_write_int() */
	sprintf((char *)prt_line_buffer, ""%d"", num_copies);
",unused,vimactualxenialpreviousversion-src2Fhardcopy.c
"		case ')':  ga_append(&prt_ps_buffer, IF_EB(')', 0051)); break;
		case '\\': ga_append(&prt_ps_buffer, IF_EB('\\', 0134)); break;

		default:
			   sprintf((char *)ch_buff, ""%03o"", (unsigned int)ch);
",1,unused,3540,unused,"		case ')':  ga_append(&prt_ps_buffer, IF_EB(')', 0051)); break;
		case '\\': ga_append(&prt_ps_buffer, IF_EB('\\', 0134)); break;

		default:
			   sprintf((char *)ch_buff, ""%03o"", (unsigned int)ch);
",unused,vimactualxenialpreviousversion-src2Fhardcopy.c
"    char *buf = (char *)alloc((unsigned)strlen(stat_emsg) + MAXPATHL + 10);

    if (buf != NULL)
    {
	(void)sprintf(buf, stat_emsg, fname, errno);
",1,unused,501,unused,"    char *buf = (char *)alloc((unsigned)strlen(stat_emsg) + MAXPATHL + 10);

    if (buf != NULL)
    {
	(void)sprintf(buf, stat_emsg, fname, errno);
",unused,vimactualxenialpreviousversion-src2Fif_cscope.c
"	    if (fname[0] == '\0')
		break;
	}
	if (fname[0] == '\0')
	    (void)sprintf(fname2, ""/%s"", CSCOPE_DBFILE);
",1,unused,591,unused,"	    if (fname[0] == '\0')
		break;
	}
	if (fname[0] == '\0')
	    (void)sprintf(fname2, ""/%s"", CSCOPE_DBFILE);
",unused,vimactualxenialpreviousversion-src2Fif_cscope.c
"	}
	if (fname[0] == '\0')
	    (void)sprintf(fname2, ""/%s"", CSCOPE_DBFILE);
	else
	    (void)sprintf(fname2, ""%s/%s"", fname, CSCOPE_DBFILE);
",1,unused,593,unused,"	}
	if (fname[0] == '\0')
	    (void)sprintf(fname2, ""/%s"", CSCOPE_DBFILE);
	else
	    (void)sprintf(fname2, ""%s/%s"", fname, CSCOPE_DBFILE);
",unused,vimactualxenialpreviousversion-src2Fif_cscope.c
"
    if ((cmd = (char *)alloc((unsigned)(strlen(pat) + 2))) == NULL)
	return NULL;

    (void)sprintf(cmd, ""%d%s"", search, pat);
",1,unused,810,unused,"
    if ((cmd = (char *)alloc((unsigned)(strlen(pat) + 2))) == NULL)
	return NULL;

    (void)sprintf(cmd, ""%d%s"", search, pat);
",unused,vimactualxenialpreviousversion-src2Fif_cscope.c
"	}

	/* run the cscope command; is there execl for non-unix systems? */
#if defined(UNIX)
	(void)sprintf(cmd, ""exec %s -dl -f %s"", prog, csinfo[i].fname);
",1,unused,961,unused,"	}

	/* run the cscope command; is there execl for non-unix systems? */
#if defined(UNIX)
	(void)sprintf(cmd, ""exec %s -dl -f %s"", prog, csinfo[i].fname);
",unused,vimactualxenialpreviousversion-src2Fif_cscope.c
"	(void)sprintf(cmd, ""%s -dl -f %s"", prog, csinfo[i].fname);
#endif
	if (csinfo[i].ppath != NULL)
	{
	    (void)strcat(cmd, "" -P"");
",1,unused,968,unused,"	(void)sprintf(cmd, ""%s -dl -f %s"", prog, csinfo[i].fname);
#endif
	if (csinfo[i].ppath != NULL)
	{
	    (void)strcat(cmd, "" -P"");
",unused,vimactualxenialpreviousversion-src2Fif_cscope.c
"#endif
	if (csinfo[i].ppath != NULL)
	{
	    (void)strcat(cmd, "" -P"");
	    (void)strcat(cmd, csinfo[i].ppath);
",1,unused,969,unused,"#endif
	if (csinfo[i].ppath != NULL)
	{
	    (void)strcat(cmd, "" -P"");
	    (void)strcat(cmd, csinfo[i].ppath);
",unused,vimactualxenialpreviousversion-src2Fif_cscope.c
"	    (void)strcat(cmd, csinfo[i].ppath);
	}
	if (csinfo[i].flags != NULL)
	{
	    (void)strcat(cmd, "" "");
",1,unused,973,unused,"	    (void)strcat(cmd, csinfo[i].ppath);
	}
	if (csinfo[i].flags != NULL)
	{
	    (void)strcat(cmd, "" "");
",unused,vimactualxenialpreviousversion-src2Fif_cscope.c
"	}
	if (csinfo[i].flags != NULL)
	{
	    (void)strcat(cmd, "" "");
	    (void)strcat(cmd, csinfo[i].flags);
",1,unused,974,unused,"	}
	if (csinfo[i].flags != NULL)
	{
	    (void)strcat(cmd, "" "");
	    (void)strcat(cmd, csinfo[i].flags);
",unused,vimactualxenialpreviousversion-src2Fif_cscope.c
"
	    /* strlen will be enough because we use chars */
	    if (buf != NULL)
	    {
		sprintf(buf, nf, *qfpos, *(qfpos-1));
",1,unused,1171,unused,"
	    /* strlen will be enough because we use chars */
	    if (buf != NULL)
	    {
		sprintf(buf, nf, *qfpos, *(qfpos-1));
",unused,vimactualxenialpreviousversion-src2Fif_cscope.c
"	if (buf == NULL)
	    (void)EMSG(nf);
	else
	{
	    sprintf(buf, nf, opt, pat);
",1,unused,1244,unused,"	if (buf == NULL)
	    (void)EMSG(nf);
	else
	{
	    sprintf(buf, nf, opt, pat);
",unused,vimactualxenialpreviousversion-src2Fif_cscope.c
"
    if ((csinfo[i].fname = (char *)alloc((unsigned)strlen(fname)+1)) == NULL)
	return -1;

    (void)strcpy(csinfo[i].fname, (const char *)fname);
",1,unused,1514,unused,"
    if ((csinfo[i].fname = (char *)alloc((unsigned)strlen(fname)+1)) == NULL)
	return -1;

    (void)strcpy(csinfo[i].fname, (const char *)fname);
",unused,vimactualxenialpreviousversion-src2Fif_cscope.c
"	    vim_free(csinfo[i].fname);
	    csinfo[i].fname = NULL;
	    return -1;
	}
	(void)strcpy(csinfo[i].ppath, (const char *)ppath);
",1,unused,1524,unused,"	    vim_free(csinfo[i].fname);
	    csinfo[i].fname = NULL;
	    return -1;
	}
	(void)strcpy(csinfo[i].ppath, (const char *)ppath);
",unused,vimactualxenialpreviousversion-src2Fif_cscope.c
"	    csinfo[i].fname = NULL;
	    csinfo[i].ppath = NULL;
	    return -1;
	}
	(void)strcpy(csinfo[i].flags, (const char *)flags);
",1,unused,1538,unused,"	    csinfo[i].fname = NULL;
	    csinfo[i].ppath = NULL;
	    return -1;
	}
	(void)strcpy(csinfo[i].flags, (const char *)flags);
",unused,vimactualxenialpreviousversion-src2Fif_cscope.c
"	amt = (int)(strlen(fname) + strlen(slno) + strlen(tagstr) + strlen(search)+6);
	if ((buf = (char *)alloc(amt)) == NULL)
	    return NULL;

	(void)sprintf(buf, ""%s\t%s\t%s;\""\t%s"", tagstr, fname, slno, search);
",1,unused,1710,unused,"	amt = (int)(strlen(fname) + strlen(slno) + strlen(tagstr) + strlen(search)+6);
	if ((buf = (char *)alloc(amt)) == NULL)
	    return NULL;

	(void)sprintf(buf, ""%s\t%s\t%s;\""\t%s"", tagstr, fname, slno, search);
",unused,vimactualxenialpreviousversion-src2Fif_cscope.c
"	amt = (int)(strlen(fname) + strlen(slno) + strlen(tagstr) + 5);
	if ((buf = (char *)alloc(amt)) == NULL)
	    return NULL;

	(void)sprintf(buf, ""%s\t%s\t%s;\"""", tagstr, fname, slno);
",1,unused,1718,unused,"	amt = (int)(strlen(fname) + strlen(slno) + strlen(tagstr) + 5);
	if ((buf = (char *)alloc(amt)) == NULL)
	    return NULL;

	(void)sprintf(buf, ""%s\t%s\t%s;\"""", tagstr, fname, slno);
",unused,vimactualxenialpreviousversion-src2Fif_cscope.c
"	   if (context == NULL)
	       continue;

	   if (strcmp(cntx, ""<global>"")==0)
	       strcpy(context, ""<<global>>"");
",1,unused,1903,unused,"	   if (context == NULL)
	       continue;

	   if (strcmp(cntx, ""<global>"")==0)
	       strcpy(context, ""<<global>>"");
",unused,vimactualxenialpreviousversion-src2Fif_cscope.c
"
	   if (strcmp(cntx, ""<global>"")==0)
	       strcpy(context, ""<<global>>"");
	   else
	       sprintf(context, ""<<%s>>"", cntx);
",1,unused,1905,unused,"
	   if (strcmp(cntx, ""<global>"")==0)
	       strcpy(context, ""<<global>>"");
	   else
	       sprintf(context, ""<<%s>>"", cntx);
",unused,vimactualxenialpreviousversion-src2Fif_cscope.c
"
    if ((tbuf = (char *)alloc((unsigned)strlen(matches[0]) + 1)) == NULL)
	return;

    strcpy(tbuf, matches[0]);
",1,unused,2062,unused,"
    if ((tbuf = (char *)alloc((unsigned)strlen(matches[0]) + 1)) == NULL)
	return;

    strcpy(tbuf, matches[0]);
",unused,vimactualxenialpreviousversion-src2Fif_cscope.c
"    buf = (char *)alloc(newsize);
    if (buf != NULL)
    {
	bufsize = newsize;
	(void)sprintf(buf, cstag_msg, ptag);
",1,unused,2075,unused,"    buf = (char *)alloc(newsize);
    if (buf != NULL)
    {
	bufsize = newsize;
	(void)sprintf(buf, cstag_msg, ptag);
",unused,vimactualxenialpreviousversion-src2Fif_cscope.c
"	 * directly, but that's too much of a hassle
	 */
	if ((tbuf = (char *)alloc((unsigned)strlen(matches[idx]) + 1)) == NULL)
	    continue;
	(void)strcpy(tbuf, matches[idx]);
",1,unused,2096,unused,"	 * directly, but that's too much of a hassle
	 */
	if ((tbuf = (char *)alloc((unsigned)strlen(matches[idx]) + 1)) == NULL)
	    continue;
	(void)strcpy(tbuf, matches[idx]);
",unused,vimactualxenialpreviousversion-src2Fif_cscope.c
"	}
	if (buf != NULL)
	{
	    /* csfmt_str = ""%4d %6s  ""; */
	    (void)sprintf(buf, csfmt_str, num, lno);
",1,unused,2126,unused,"	}
	if (buf != NULL)
	{
	    /* csfmt_str = ""%4d %6s  ""; */
	    (void)sprintf(buf, csfmt_str, num, lno);
",unused,vimactualxenialpreviousversion-src2Fif_cscope.c
"		bufsize = newsize;
	}
	if (buf != NULL)
	{
	    (void)sprintf(buf, cntxformat, context);
",1,unused,2152,unused,"		bufsize = newsize;
	}
	if (buf != NULL)
	{
	    (void)sprintf(buf, cntxformat, context);
",unused,vimactualxenialpreviousversion-src2Fif_cscope.c
"		/* don't use smsg_attr() because we want to display the
		 * connection number in the same line as
		 * ""Added cscope database...""
		 */
		sprintf(buf, "" (#%d)"", i);
",1,unused,2460,unused,"		/* don't use smsg_attr() because we want to display the
		 * connection number in the same line as
		 * ""Added cscope database...""
		 */
		sprintf(buf, "" (#%d)"", i);
",unused,vimactualxenialpreviousversion-src2Fif_cscope.c
"#endif
       )
    {
	if ((fullname = (char *)alloc(len)) != NULL)
	    (void)sprintf(fullname, ""%s/%s"", csinfo[i].ppath, name);
",1,unused,2530,unused,"#endif
       )
    {
	if ((fullname = (char *)alloc(len)) != NULL)
	    (void)sprintf(fullname, ""%s/%s"", csinfo[i].ppath, name);
",unused,vimactualxenialpreviousversion-src2Fif_cscope.c
"			    a = argv[0];
			p = alloc((unsigned)(STRLEN(a) + 4));
			if (p == NULL)
			    mch_exit(2);
			sprintf((char *)p, ""so %s"", a);
",1,unused,2284,unused,"			    a = argv[0];
			p = alloc((unsigned)(STRLEN(a) + 4));
			if (p == NULL)
			    mch_exit(2);
			sprintf((char *)p, ""so %s"", a);
",unused,vimactualxenialpreviousversion-src2Fmain.c
"    {
	p = alloc((unsigned)STRLEN(parmp->commands[0]) + 3);
	if (p != NULL)
	{
	    sprintf((char *)p, "":%s\r"", parmp->commands[0]);
",1,unused,2510,unused,"    {
	p = alloc((unsigned)STRLEN(parmp->commands[0]) + 3);
	if (p != NULL)
	{
	    sprintf((char *)p, "":%s\r"", parmp->commands[0]);
",unused,vimactualxenialpreviousversion-src2Fmain.c
"	}
	msg_putchar('\n');
	if (!got_int)
	{
	    sprintf((char *)IObuff, "" %c %6ld %4d "", c, p->lnum, p->col);
",1,unused,773,unused,"	}
	msg_putchar('\n');
	if (!got_int)
	{
	    sprintf((char *)IObuff, "" %c %6ld %4d "", c, p->lnum, p->col);
",unused,vimactualxenialpreviousversion-src2Fmark.c
"	    {
		vim_free(name);
		break;
	    }
	    sprintf((char *)IObuff, ""%c %2d %5ld %4d "",
",1,unused,902,unused,"	    {
		vim_free(name);
		break;
	    }
	    sprintf((char *)IObuff, ""%c %2d %5ld %4d "",
",unused,vimactualxenialpreviousversion-src2Fmark.c
"	{
	    msg_putchar('\n');
	    if (got_int)
		break;
	    sprintf((char *)IObuff, ""%c %3d %5ld %4d "",
",1,unused,940,unused,"	{
	    msg_putchar('\n');
	    if (got_int)
		break;
	    sprintf((char *)IObuff, ""%c %3d %5ld %4d "",
",unused,vimactualxenialpreviousversion-src2Fmark.c
"		rlen += 2;
	    }
	    clen = utf_ptr2len(line + i);
	}
	sprintf((char *)IObuff + rlen, ""%02x "",
",1,unused,3528,unused,"		rlen += 2;
	    }
	    clen = utf_ptr2len(line + i);
	}
	sprintf((char *)IObuff + rlen, ""%02x "",
",unused,vimactualxenialpreviousversion-src2Fmbyte.c
"	return FALSE;

    if (gui.rsrc_input_method != NULL && *gui.rsrc_input_method != NUL)
    {
	strcpy(tmp, gui.rsrc_input_method);
",1,unused,5722,unused,"	return FALSE;

    if (gui.rsrc_input_method != NULL && *gui.rsrc_input_method != NUL)
    {
	strcpy(tmp, gui.rsrc_input_method);
",unused,vimactualxenialpreviousversion-src2Fmbyte.c
"	    *end = NUL;

	    if (strlen(s) <= IMLEN_MAX)
	    {
		strcpy(buf, ""@im="");
",1,unused,5736,unused,"	    *end = NUL;

	    if (strlen(s) <= IMLEN_MAX)
	    {
		strcpy(buf, ""@im="");
",unused,vimactualxenialpreviousversion-src2Fmbyte.c
"
	    if (strlen(s) <= IMLEN_MAX)
	    {
		strcpy(buf, ""@im="");
		strcat(buf, s);
",1,unused,5737,unused,"
	    if (strlen(s) <= IMLEN_MAX)
	    {
		strcpy(buf, ""@im="");
		strcat(buf, s);
",unused,vimactualxenialpreviousversion-src2Fmbyte.c
"	return FALSE;
    }

    found = False;
    strcpy(tmp, gui.rsrc_preedit_type_name);
",1,unused,5789,unused,"	return FALSE;
    }

    found = False;
    strcpy(tmp, gui.rsrc_preedit_type_name);
",unused,vimactualxenialpreviousversion-src2Fmbyte.c
"    {
	p = (char_u *)_(""Error detected while processing %s:"");
	Buf = alloc((unsigned)(STRLEN(sourcing_name) + STRLEN(p)));
	if (Buf != NULL)
	    sprintf((char *)Buf, (char *)p, sourcing_name);
",1,unused,420,unused,"    {
	p = (char_u *)_(""Error detected while processing %s:"");
	Buf = alloc((unsigned)(STRLEN(sourcing_name) + STRLEN(p)));
	if (Buf != NULL)
	    sprintf((char *)Buf, (char *)p, sourcing_name);
",unused,vimactualxenialpreviousversion-src2Fmessage.c
"    {
	p = (char_u *)_(""line %4ld:"");
	Buf = alloc((unsigned)(STRLEN(p) + 20));
	if (Buf != NULL)
	    sprintf((char *)Buf, (char *)p, (long)sourcing_lnum);
",1,unused,445,unused,"    {
	p = (char_u *)_(""line %4ld:"");
	Buf = alloc((unsigned)(STRLEN(p) + 20));
	if (Buf != NULL)
	    sprintf((char *)Buf, (char *)p, (long)sourcing_lnum);
",unused,vimactualxenialpreviousversion-src2Fmessage.c
"msg_outnum(long n)
{
    char_u	buf[20];

    sprintf((char *)buf, ""%ld"", n);
",1,unused,1210,unused,"msg_outnum(long n)
{
    char_u	buf[20];

    sprintf((char *)buf, ""%ld"", n);
",unused,vimactualxenialpreviousversion-src2Fmessage.c
"			f[f_l++] = fmt_spec;
			f[f_l++] = '\0';

			if (fmt_spec == 'p')
			    str_arg_l += sprintf(tmp + str_arg_l, f, ptr_arg);
",1,unused,4402,unused,"			f[f_l++] = fmt_spec;
			f[f_l++] = '\0';

			if (fmt_spec == 'p')
			    str_arg_l += sprintf(tmp + str_arg_l, f, ptr_arg);
",unused,vimactualxenialpreviousversion-src2Fmessage.c
"			    /* signed */
			    switch (length_modifier)
			    {
			    case '\0':
			    case 'h': str_arg_l += sprintf(
",1,unused,4409,unused,"			    /* signed */
			    switch (length_modifier)
			    {
			    case '\0':
			    case 'h': str_arg_l += sprintf(
",unused,vimactualxenialpreviousversion-src2Fmessage.c
"			    case '\0':
			    case 'h': str_arg_l += sprintf(
						 tmp + str_arg_l, f, int_arg);
				      break;
			    case 'l': str_arg_l += sprintf(
",1,unused,4412,unused,"			    case '\0':
			    case 'h': str_arg_l += sprintf(
						 tmp + str_arg_l, f, int_arg);
				      break;
			    case 'l': str_arg_l += sprintf(
",unused,vimactualxenialpreviousversion-src2Fmessage.c
"			    /* unsigned */
			    switch (length_modifier)
			    {
			    case '\0':
			    case 'h': str_arg_l += sprintf(
",1,unused,4423,unused,"			    /* unsigned */
			    switch (length_modifier)
			    {
			    case '\0':
			    case 'h': str_arg_l += sprintf(
",unused,vimactualxenialpreviousversion-src2Fmessage.c
"			    case '\0':
			    case 'h': str_arg_l += sprintf(
						tmp + str_arg_l, f, uint_arg);
				      break;
			    case 'l': str_arg_l += sprintf(
",1,unused,4426,unused,"			    case '\0':
			    case 'h': str_arg_l += sprintf(
						tmp + str_arg_l, f, uint_arg);
				      break;
			    case 'l': str_arg_l += sprintf(
",unused,vimactualxenialpreviousversion-src2Fmessage.c
"#  endif
			    )
		    {
			/* Avoid a buffer overflow */
			strcpy(tmp, ""inf"");
",1,unused,4525,unused,"#  endif
			    )
		    {
			/* Avoid a buffer overflow */
			strcpy(tmp, ""inf"");
",unused,vimactualxenialpreviousversion-src2Fmessage.c
"			    if (fmt_spec == 'f' && abs_f > 1.0)
				max_prec -= (size_t)log10(abs_f);
			    if (precision > max_prec)
				precision = max_prec;
			    l += sprintf(format + 1, "".%d"", (int)precision);
",1,unused,4542,unused,"			    if (fmt_spec == 'f' && abs_f > 1.0)
				max_prec -= (size_t)log10(abs_f);
			    if (precision > max_prec)
				precision = max_prec;
			    l += sprintf(format + 1, "".%d"", (int)precision);
",unused,vimactualxenialpreviousversion-src2Fmessage.c
"			    l += sprintf(format + 1, "".%d"", (int)precision);
			}
			format[l] = fmt_spec;
			format[l + 1] = NUL;
			str_arg_l = sprintf(tmp, format, f);
",1,unused,4546,unused,"			    l += sprintf(format + 1, "".%d"", (int)precision);
			}
			format[l] = fmt_spec;
			format[l + 1] = NUL;
			str_arg_l = sprintf(tmp, format, f);
",unused,vimactualxenialpreviousversion-src2Fmessage.c
"	    /* success, login */
	    vim_snprintf(buf, sizeof(buf), ""AUTH %s\n"", password);
	    nb_send(buf, ""netbeans_connect"");

	    sprintf(buf, ""0:version=0 \""%s\""\n"", ExtEdProtocolVersion);
",1,unused,231,unused,"	    /* success, login */
	    vim_snprintf(buf, sizeof(buf), ""AUTH %s\n"", password);
	    nb_send(buf, ""netbeans_connect"");

	    sprintf(buf, ""0:version=0 \""%s\""\n"", ExtEdProtocolVersion);
",unused,vimactualxenialpreviousversion-src2Fnetbeans.c
"	    continue;
	if (netbeansForcedQuit)
	{
	    /* mark as unmodified so NetBeans won't put up dialog on ""killed"" */
	    sprintf(buf, ""%d:unmodified=%d\n"", i, r_cmdno);
",1,unused,744,unused,"	    continue;
	if (netbeansForcedQuit)
	{
	    /* mark as unmodified so NetBeans won't put up dialog on ""killed"" */
	    sprintf(buf, ""%d:unmodified=%d\n"", i, r_cmdno);
",unused,vimactualxenialpreviousversion-src2Fnetbeans.c
"	    sprintf(buf, ""%d:unmodified=%d\n"", i, r_cmdno);
	    nbdebug((""EVT: %s"", buf));
	    nb_send(buf, ""netbeans_end"");
	}
	sprintf(buf, ""%d:killed=%d\n"", i, r_cmdno);
",1,unused,748,unused,"	    sprintf(buf, ""%d:unmodified=%d\n"", i, r_cmdno);
	    nbdebug((""EVT: %s"", buf));
	    nb_send(buf, ""netbeans_end"");
	}
	sprintf(buf, ""%d:killed=%d\n"", i, r_cmdno);
",unused,vimactualxenialpreviousversion-src2Fnetbeans.c
"    /* Avoid printing an annoying error message. */
    if (!NETBEANS_OPEN)
	return;

    sprintf(reply, ""%d\n"", cmdno);
",1,unused,781,unused,"    /* Avoid printing an annoying error message. */
    if (!NETBEANS_OPEN)
	return;

    sprintf(reply, ""%d\n"", cmdno);
",unused,vimactualxenialpreviousversion-src2Fnetbeans.c
"
    nbdebug((""REP %d: %s\n"", cmdno, (char *)result));

    reply = alloc((unsigned)STRLEN(result) + 32);
    sprintf((char *)reply, ""%d %s\n"", cmdno, (char *)result);
",1,unused,798,unused,"
    nbdebug((""REP %d: %s\n"", cmdno, (char *)result));

    reply = alloc((unsigned)STRLEN(result) + 32);
    sprintf((char *)reply, ""%d %s\n"", cmdno, (char *)result);
",unused,vimactualxenialpreviousversion-src2Fnetbeans.c
"    char reply[32];

    nbdebug((""REP %d: %ld\n"", cmdno, result));

    sprintf(reply, ""%d %ld\n"", cmdno, result);
",1,unused,815,unused,"    char reply[32];

    nbdebug((""REP %d: %ld\n"", cmdno, result));

    sprintf(reply, ""%d %ld\n"", cmdno, result);
",unused,vimactualxenialpreviousversion-src2Fnetbeans.c
"
	    /* Note: nb_getbufno() may return -1.  This indicates the IDE
	     * didn't assign a number to the current buffer in response to a
	     * fileOpened event. */
	    sprintf((char *)text, ""%d %ld %d %ld"",
",1,unused,1024,unused,"
	    /* Note: nb_getbufno() may return -1.  This indicates the IDE
	     * didn't assign a number to the current buffer in response to a
	     * fileOpened event. */
	    sprintf((char *)text, ""%d %ld %d %ld"",
",unused,vimactualxenialpreviousversion-src2Fnetbeans.c
"	    }
	    tok++;
	}

	strcpy(&keybuf[i], tok);
",1,unused,2351,unused,"	    }
	    tok++;
	}

	strcpy(&keybuf[i], tok);
",unused,vimactualxenialpreviousversion-src2Fnetbeans.c
"    }

    buf[0] = '\0';
    if (ctrl)
	strcat(buf, ""C"");
",1,unused,2468,unused,"    }

    buf[0] = '\0';
    if (ctrl)
	strcat(buf, ""C"");
",unused,vimactualxenialpreviousversion-src2Fnetbeans.c
"    buf[0] = '\0';
    if (ctrl)
	strcat(buf, ""C"");
    if (shift)
	strcat(buf, ""S"");
",1,unused,2470,unused,"    buf[0] = '\0';
    if (ctrl)
	strcat(buf, ""C"");
    if (shift)
	strcat(buf, ""S"");
",unused,vimactualxenialpreviousversion-src2Fnetbeans.c
"	strcat(buf, ""C"");
    if (shift)
	strcat(buf, ""S"");
    if (alt)
	strcat(buf, ""M""); /* META */
",1,unused,2472,unused,"	strcat(buf, ""C"");
    if (shift)
	strcat(buf, ""S"");
    if (alt)
	strcat(buf, ""M""); /* META */
",unused,vimactualxenialpreviousversion-src2Fnetbeans.c
"	strcat(buf, ""S"");
    if (alt)
	strcat(buf, ""M""); /* META */
    if (ctrl || shift || alt)
	strcat(buf, ""-"");
",1,unused,2474,unused,"	strcat(buf, ""S"");
    if (alt)
	strcat(buf, ""M""); /* META */
    if (ctrl || shift || alt)
	strcat(buf, ""-"");
",unused,vimactualxenialpreviousversion-src2Fnetbeans.c
"    if (alt)
	strcat(buf, ""M""); /* META */
    if (ctrl || shift || alt)
	strcat(buf, ""-"");
    strcat(buf, name);
",1,unused,2475,unused,"    if (alt)
	strcat(buf, ""M""); /* META */
    if (ctrl || shift || alt)
	strcat(buf, ""-"");
    strcat(buf, name);
",unused,vimactualxenialpreviousversion-src2Fnetbeans.c
"    char buf[128];

    if (NETBEANS_OPEN)
    {
	sprintf(buf, ""0:disconnect=%d\n"", r_cmdno);
",1,unused,2582,unused,"    char buf[128];

    if (NETBEANS_OPEN)
    {
	sprintf(buf, ""0:disconnect=%d\n"", r_cmdno);
",unused,vimactualxenialpreviousversion-src2Fnetbeans.c
"
    if (!NETBEANS_OPEN)
	return;

    sprintf(buf, ""0:geometry=%d %d %d %d %d\n"",
",1,unused,2600,unused,"
    if (!NETBEANS_OPEN)
	return;

    sprintf(buf, ""0:geometry=%d %d %d %d %d\n"",
",unused,vimactualxenialpreviousversion-src2Fnetbeans.c
"
    nbdebug((""netbeans_file_killed:\n""));
    nbdebug((""    Killing bufno: %d"", bufno));

    sprintf(buffer, ""%d:killed=%d\n"", bufno, r_cmdno);
",1,unused,2692,unused,"
    nbdebug((""netbeans_file_killed:\n""));
    nbdebug((""    Killing bufno: %d"", bufno));

    sprintf(buffer, ""%d:killed=%d\n"", bufno, r_cmdno);
",unused,vimactualxenialpreviousversion-src2Fnetbeans.c
"    p = nb_quote(newtxt);
    if (p != NULL)
    {
	buf = alloc(128 + 2*newlen);
	sprintf((char *)buf, ""%d:insert=%d %ld \""%s\""\n"",
",1,unused,2769,unused,"    p = nb_quote(newtxt);
    if (p != NULL)
    {
	buf = alloc(128 + 2*newlen);
	sprintf((char *)buf, ""%d:insert=%d %ld \""%s\""\n"",
",unused,vimactualxenialpreviousversion-src2Fnetbeans.c
"    pos.col = col;

    off = pos2off(bufp, &pos);

    sprintf((char *)buf, ""%d:remove=%d %ld %ld\n"", bufno, r_cmdno, off, len);
",1,unused,2815,unused,"    pos.col = col;

    off = pos2off(bufp, &pos);

    sprintf((char *)buf, ""%d:remove=%d %ld %ld\n"", bufno, r_cmdno, off, len);
",unused,vimactualxenialpreviousversion-src2Fnetbeans.c
"			      - ((curwin->w_p_nu || curwin->w_p_rnu) ? 9 : 1);
	long off = pos2off(curbuf, &curwin->w_cursor);

	/* sync the cursor position */
	sprintf(buf, ""%d:newDotAndMark=%d %ld %ld\n"", bufno, r_cmdno, off, off);
",1,unused,2852,unused,"			      - ((curwin->w_p_nu || curwin->w_p_rnu) ? 9 : 1);
	long off = pos2off(curbuf, &curwin->w_cursor);

	/* sync the cursor position */
	sprintf(buf, ""%d:newDotAndMark=%d %ld %ld\n"", bufno, r_cmdno, off, off);
",unused,vimactualxenialpreviousversion-src2Fnetbeans.c
"	sprintf(buf, ""%d:newDotAndMark=%d %ld %ld\n"", bufno, r_cmdno, off, off);
	nbdebug((""EVT: %s"", buf));
	nb_send(buf, ""netbeans_button_release[newDotAndMark]"");

	sprintf(buf, ""%d:buttonRelease=%d %d %ld %d\n"", bufno, r_cmdno,
",1,unused,2856,unused,"	sprintf(buf, ""%d:newDotAndMark=%d %ld %ld\n"", bufno, r_cmdno, off, off);
	nbdebug((""EVT: %s"", buf));
	nb_send(buf, ""netbeans_button_release[newDotAndMark]"");

	sprintf(buf, ""%d:buttonRelease=%d %d %ld %d\n"", bufno, r_cmdno,
",unused,vimactualxenialpreviousversion-src2Fnetbeans.c
"    }

    /* sync the cursor position */
    off = pos2off(curbuf, &curwin->w_cursor);
    sprintf(buf, ""%d:newDotAndMark=%d %ld %ld\n"", bufno, r_cmdno, off, off);
",1,unused,2919,unused,"    }

    /* sync the cursor position */
    off = pos2off(curbuf, &curwin->w_cursor);
    sprintf(buf, ""%d:newDotAndMark=%d %ld %ld\n"", bufno, r_cmdno, off, off);
",unused,vimactualxenialpreviousversion-src2Fnetbeans.c
"	return;

    nbbuf->modified = 0;

    sprintf((char *)buf, ""%d:save=%d\n"", bufno, r_cmdno);
",1,unused,2963,unused,"	return;

    nbbuf->modified = 0;

    sprintf((char *)buf, ""%d:save=%d\n"", bufno, r_cmdno);
",unused,vimactualxenialpreviousversion-src2Fnetbeans.c
"    /* Don't mark as modified for initial read */
    if (nbbuf->insertDone)
	nbbuf->modified = 1;

    sprintf((char *)buf, ""%d:remove=%d 0 -1\n"", bufno, r_cmdno);
",1,unused,2990,unused,"    /* Don't mark as modified for initial read */
    if (nbbuf->insertDone)
	nbbuf->modified = 1;

    sprintf((char *)buf, ""%d:remove=%d 0 -1\n"", bufno, r_cmdno);
",unused,vimactualxenialpreviousversion-src2Fnetbeans.c
"	    int value;

	    value = strtol((char *)fg, &ptr, 10);
	    if (ptr != (char *)fg)
		sprintf(fgbuf, ""guifg=#%06x"", value & 0xFFFFFF);
",1,unused,3215,unused,"	    int value;

	    value = strtol((char *)fg, &ptr, 10);
	    if (ptr != (char *)fg)
		sprintf(fgbuf, ""guifg=#%06x"", value & 0xFFFFFF);
",unused,vimactualxenialpreviousversion-src2Fnetbeans.c
"	    value = strtol((char *)fg, &ptr, 10);
	    if (ptr != (char *)fg)
		sprintf(fgbuf, ""guifg=#%06x"", value & 0xFFFFFF);
	    else
		sprintf(fgbuf, ""guifg=%s ctermfg=%s"", fg, fg);
",1,unused,3217,unused,"	    value = strtol((char *)fg, &ptr, 10);
	    if (ptr != (char *)fg)
		sprintf(fgbuf, ""guifg=#%06x"", value & 0xFFFFFF);
	    else
		sprintf(fgbuf, ""guifg=%s ctermfg=%s"", fg, fg);
",unused,vimactualxenialpreviousversion-src2Fnetbeans.c
"		sprintf(fgbuf, ""guifg=%s ctermfg=%s"", fg, fg);

	    value = strtol((char *)bg, &ptr, 10);
	    if (ptr != (char *)bg)
		sprintf(bgbuf, ""guibg=#%06x"", value & 0xFFFFFF);
",1,unused,3221,unused,"		sprintf(fgbuf, ""guifg=%s ctermfg=%s"", fg, fg);

	    value = strtol((char *)bg, &ptr, 10);
	    if (ptr != (char *)bg)
		sprintf(bgbuf, ""guibg=#%06x"", value & 0xFFFFFF);
",unused,vimactualxenialpreviousversion-src2Fnetbeans.c
"	    value = strtol((char *)bg, &ptr, 10);
	    if (ptr != (char *)bg)
		sprintf(bgbuf, ""guibg=#%06x"", value & 0xFFFFFF);
	    else
		sprintf(bgbuf, ""guibg=%s ctermbg=%s"", bg, bg);
",1,unused,3223,unused,"	    value = strtol((char *)bg, &ptr, 10);
	    if (ptr != (char *)bg)
		sprintf(bgbuf, ""guibg=#%06x"", value & 0xFFFFFF);
	    else
		sprintf(bgbuf, ""guibg=%s ctermbg=%s"", bg, bg);
",unused,vimactualxenialpreviousversion-src2Fnetbeans.c
"	    getvcols(curwin, &curwin->w_cursor, &VIsual, &leftcol, &rightcol);
# ifdef FEAT_LINEBREAK
	    p_sbr = saved_sbr;
# endif
	    sprintf((char *)showcmd_buf, ""%ldx%ld"", lines,
",1,unused,3773,unused,"	    getvcols(curwin, &curwin->w_cursor, &VIsual, &leftcol, &rightcol);
# ifdef FEAT_LINEBREAK
	    p_sbr = saved_sbr;
# endif
	    sprintf((char *)showcmd_buf, ""%ldx%ld"", lines,
",unused,vimactualxenialpreviousversion-src2Fnormal.c
"	    sprintf((char *)showcmd_buf, ""%ldx%ld"", lines,
					      (long)(rightcol - leftcol + 1));
	}
	else if (VIsual_mode == 'V' || VIsual.lnum != curwin->w_cursor.lnum)
	    sprintf((char *)showcmd_buf, ""%ld"", lines);
",1,unused,3777,unused,"	    sprintf((char *)showcmd_buf, ""%ldx%ld"", lines,
					      (long)(rightcol - leftcol + 1));
	}
	else if (VIsual_mode == 'V' || VIsual.lnum != curwin->w_cursor.lnum)
	    sprintf((char *)showcmd_buf, ""%ld"", lines);
",unused,vimactualxenialpreviousversion-src2Fnormal.c
"		++chars;
		s += l;
	    }
	    if (bytes == chars)
		sprintf((char *)showcmd_buf, ""%d"", chars);
",1,unused,3813,unused,"		++chars;
		s += l;
	    }
	    if (bytes == chars)
		sprintf((char *)showcmd_buf, ""%d"", chars);
",unused,vimactualxenialpreviousversion-src2Fnormal.c
"	    }
	    if (bytes == chars)
		sprintf((char *)showcmd_buf, ""%d"", chars);
	    else
		sprintf((char *)showcmd_buf, ""%d-%d"", chars, bytes);
",1,unused,3815,unused,"	    }
	    if (bytes == chars)
		sprintf((char *)showcmd_buf, ""%d"", chars);
	    else
		sprintf((char *)showcmd_buf, ""%d-%d"", chars, bytes);
",unused,vimactualxenialpreviousversion-src2Fnormal.c
"	return FAIL;

    /* Put ""\V"" before the pattern to avoid that the special meaning of "".""
     * and ""~"" causes trouble. */
    sprintf((char *)pat, vim_iswordp(ptr) ? ""\\V\\<%.*s\\>"" : ""\\V%.*s"",
",1,unused,4269,unused,"	return FAIL;

    /* Put ""\V"" before the pattern to avoid that the special meaning of "".""
     * and ""~"" causes trouble. */
    sprintf((char *)pat, vim_iswordp(ptr) ? ""\\V\\<%.*s\\>"" : ""\\V%.*s"",
",unused,vimactualxenialpreviousversion-src2Fnormal.c
"		 * really what we want? */
		isman = (STRCMP(kp, ""man"") == 0);
		isman_s = (STRCMP(kp, ""man -s"") == 0);
		if (cap->count0 != 0 && !(isman || isman_s))
		    sprintf((char *)buf, "".,.+%ld"", cap->count0 - 1);
",1,unused,5585,unused,"		 * really what we want? */
		isman = (STRCMP(kp, ""man"") == 0);
		isman_s = (STRCMP(kp, ""man -s"") == 0);
		if (cap->count0 != 0 && !(isman || isman_s))
		    sprintf((char *)buf, "".,.+%ld"", cap->count0 - 1);
",unused,vimactualxenialpreviousversion-src2Fnormal.c
"		    STRCAT(buf, kp);
		STRCAT(buf, "" "");
		if (cap->count0 != 0 && (isman || isman_s))
		{
		    sprintf((char *)buf + STRLEN(buf), ""%ld"", cap->count0);
",1,unused,5595,unused,"		    STRCAT(buf, kp);
		STRCAT(buf, "" "");
		if (cap->count0 != 0 && (isman || isman_s))
		{
		    sprintf((char *)buf + STRLEN(buf), ""%ld"", cap->count0);
",unused,vimactualxenialpreviousversion-src2Fnormal.c
"	    {
		if (g_cmd)
		    STRCPY(buf, ""tj "");
		else
		    sprintf((char *)buf, ""%ldta "", cap->count0);
",1,unused,5620,unused,"	    {
		if (g_cmd)
		    STRCPY(buf, ""tj "");
		else
		    sprintf((char *)buf, ""%ldta "", cap->count0);
",unused,vimactualxenialpreviousversion-src2Fnormal.c
"	    s = (char_u *)""<"";
	if (oap->line_count == 1)
	{
	    if (amount == 1)
		sprintf((char *)IObuff, _(""1 line %sed 1 time""), s);
",1,unused,284,unused,"	    s = (char_u *)""<"";
	if (oap->line_count == 1)
	{
	    if (amount == 1)
		sprintf((char *)IObuff, _(""1 line %sed 1 time""), s);
",unused,vimactualxenialpreviousversion-src2Fops.c
"	{
	    if (amount == 1)
		sprintf((char *)IObuff, _(""1 line %sed 1 time""), s);
	    else
		sprintf((char *)IObuff, _(""1 line %sed %d times""), s, amount);
",1,unused,286,unused,"	{
	    if (amount == 1)
		sprintf((char *)IObuff, _(""1 line %sed 1 time""), s);
	    else
		sprintf((char *)IObuff, _(""1 line %sed %d times""), s, amount);
",unused,vimactualxenialpreviousversion-src2Fops.c
"	}
	else
	{
	    if (amount == 1)
		sprintf((char *)IObuff, _(""%ld lines %sed 1 time""),
",1,unused,291,unused,"	}
	else
	{
	    if (amount == 1)
		sprintf((char *)IObuff, _(""%ld lines %sed 1 time""),
",unused,vimactualxenialpreviousversion-src2Fops.c
"	    if (amount == 1)
		sprintf((char *)IObuff, _(""%ld lines %sed 1 time""),
							  oap->line_count, s);
	    else
		sprintf((char *)IObuff, _(""%ld lines %sed %d times""),
",1,unused,294,unused,"	    if (amount == 1)
		sprintf((char *)IObuff, _(""%ld lines %sed 1 time""),
							  oap->line_count, s);
	    else
		sprintf((char *)IObuff, _(""%ld lines %sed %d times""),
",unused,vimactualxenialpreviousversion-src2Fops.c
"
	    buf2[i] = '\0';
	}
	else if (pre == 0)
	    sprintf((char *)buf2, ""%lu"", n);
",1,unused,5747,unused,"
	    buf2[i] = '\0';
	}
	else if (pre == 0)
	    sprintf((char *)buf2, ""%lu"", n);
",unused,vimactualxenialpreviousversion-src2Fops.c
"	}
	else if (pre == 0)
	    sprintf((char *)buf2, ""%lu"", n);
	else if (pre == '0')
	    sprintf((char *)buf2, ""%lo"", n);
",1,unused,5749,unused,"	}
	else if (pre == 0)
	    sprintf((char *)buf2, ""%lu"", n);
	else if (pre == '0')
	    sprintf((char *)buf2, ""%lo"", n);
",unused,vimactualxenialpreviousversion-src2Fops.c
"	    sprintf((char *)buf2, ""%lu"", n);
	else if (pre == '0')
	    sprintf((char *)buf2, ""%lo"", n);
	else if (pre && hexupper)
	    sprintf((char *)buf2, ""%lX"", n);
",1,unused,5751,unused,"	    sprintf((char *)buf2, ""%lu"", n);
	else if (pre == '0')
	    sprintf((char *)buf2, ""%lo"", n);
	else if (pre && hexupper)
	    sprintf((char *)buf2, ""%lX"", n);
",unused,vimactualxenialpreviousversion-src2Fops.c
"	    sprintf((char *)buf2, ""%lo"", n);
	else if (pre && hexupper)
	    sprintf((char *)buf2, ""%lX"", n);
	else
	    sprintf((char *)buf2, ""%lx"", n);
",1,unused,5753,unused,"	    sprintf((char *)buf2, ""%lo"", n);
	else if (pre && hexupper)
	    sprintf((char *)buf2, ""%lX"", n);
	else
	    sprintf((char *)buf2, ""%lx"", n);
",unused,vimactualxenialpreviousversion-src2Fops.c
"	    case MBLOCK:
		type = (char_u *)""BLOCK"";
		break;
	    default:
		sprintf((char *)IObuff, _(""E574: Unknown register type %d""),
",1,unused,5994,unused,"	    case MBLOCK:
		type = (char_u *)""BLOCK"";
		break;
	    default:
		sprintf((char *)IObuff, _(""E574: Unknown register type %d""),
",unused,vimactualxenialpreviousversion-src2Fops.c
"			if (saved_origval != NULL)
			{
			    char_u buf_type[7];

			    sprintf((char *)buf_type, ""%s"",
",1,unused,4963,unused,"			if (saved_origval != NULL)
			{
			    char_u buf_type[7];

			    sprintf((char *)buf_type, ""%s"",
",unused,vimactualxenialpreviousversion-src2Foption.c
"illegal_char(char_u *errbuf, int c)
{
    if (errbuf == NULL)
	return (char_u *)"""";
    sprintf((char *)errbuf, _(""E539: Illegal character <%s>""),
",1,unused,5100,unused,"illegal_char(char_u *errbuf, int c)
{
    if (errbuf == NULL)
	return (char_u *)"""";
    sprintf((char *)errbuf, _(""E539: Illegal character <%s>""),
",unused,vimactualxenialpreviousversion-src2Foption.c
"#if defined(FEAT_AUTOCMD) && defined(FEAT_EVAL)
	if (saved_oldval != NULL)
	{
	    char_u buf_type[7];
	    sprintf((char *)buf_type, ""%s"",
",1,unused,5777,unused,"#if defined(FEAT_AUTOCMD) && defined(FEAT_EVAL)
	if (saved_oldval != NULL)
	{
	    char_u buf_type[7];
	    sprintf((char *)buf_type, ""%s"",
",unused,vimactualxenialpreviousversion-src2Foption.c
"		if (!VIM_ISDIGIT(*(s - 1)))
		{
		    if (errbuf != NULL)
		    {
			sprintf((char *)errbuf,
",1,unused,6496,unused,"		if (!VIM_ISDIGIT(*(s - 1)))
		{
		    if (errbuf != NULL)
		    {
			sprintf((char *)errbuf,
",unused,vimactualxenialpreviousversion-src2Foption.c
"		else
		{
		    if (errbuf != NULL)
		    {
			sprintf((char *)errbuf,
",1,unused,6936,unused,"		else
		{
		    if (errbuf != NULL)
		    {
			sprintf((char *)errbuf,
",unused,vimactualxenialpreviousversion-src2Foption.c
"	    STRCPY(NameBuff, get_special_key_name((int)wc, 0));
	else if (wc != 0)
	    STRCPY(NameBuff, transchar((int)wc));
	else
	    sprintf((char *)NameBuff, ""%ld"", *(long *)varp);
",1,unused,11337,unused,"	    STRCPY(NameBuff, get_special_key_name((int)wc, 0));
	else if (wc != 0)
	    STRCPY(NameBuff, transchar((int)wc));
	else
	    sprintf((char *)NameBuff, ""%ld"", *(long *)varp);
",unused,vimactualxenialpreviousversion-src2Foption.c
"    }

    /* No translation, it may call malloc(). */
#ifdef SIGHASARG
    sprintf((char *)IObuff, ""Vim: Caught deadly signal %s\n"",
",1,unused,1102,unused,"    }

    /* No translation, it may call malloc(). */
#ifdef SIGHASARG
    sprintf((char *)IObuff, ""Vim: Caught deadly signal %s\n"",
",unused,vimactualxenialpreviousversion-src2Fos_unix.c
"	vim_strncpy(s, (char_u *)pw->pw_name, len - 1);
	return OK;
    }
#endif
    sprintf((char *)s, ""%d"", (int)uid);	    /* assumes s is long enough */
",1,unused,2309,unused,"	vim_strncpy(s, (char_u *)pw->pw_name, len - 1);
	return OK;
    }
#endif
    sprintf((char *)s, ""%d"", (int)uid);	    /* assumes s is long enough */
",unused,vimactualxenialpreviousversion-src2Fos_unix.c
"
    /* Simulate to have a dumb terminal (for now) */
# ifdef HAVE_SETENV
    setenv(""TERM"", ""dumb"", 1);
    sprintf((char *)envbuf, ""%ld"", Rows);
",1,unused,4002,unused,"
    /* Simulate to have a dumb terminal (for now) */
# ifdef HAVE_SETENV
    setenv(""TERM"", ""dumb"", 1);
    sprintf((char *)envbuf, ""%ld"", Rows);
",unused,vimactualxenialpreviousversion-src2Fos_unix.c
"# ifdef HAVE_SETENV
    setenv(""TERM"", ""dumb"", 1);
    sprintf((char *)envbuf, ""%ld"", Rows);
    setenv(""ROWS"", (char *)envbuf, 1);
    sprintf((char *)envbuf, ""%ld"", Rows);
",1,unused,4004,unused,"# ifdef HAVE_SETENV
    setenv(""TERM"", ""dumb"", 1);
    sprintf((char *)envbuf, ""%ld"", Rows);
    setenv(""ROWS"", (char *)envbuf, 1);
    sprintf((char *)envbuf, ""%ld"", Rows);
",unused,vimactualxenialpreviousversion-src2Fos_unix.c
"    sprintf((char *)envbuf, ""%ld"", Rows);
    setenv(""ROWS"", (char *)envbuf, 1);
    sprintf((char *)envbuf, ""%ld"", Rows);
    setenv(""LINES"", (char *)envbuf, 1);
    sprintf((char *)envbuf, ""%ld"", Columns);
",1,unused,4006,unused,"    sprintf((char *)envbuf, ""%ld"", Rows);
    setenv(""ROWS"", (char *)envbuf, 1);
    sprintf((char *)envbuf, ""%ld"", Rows);
    setenv(""LINES"", (char *)envbuf, 1);
    sprintf((char *)envbuf, ""%ld"", Columns);
",unused,vimactualxenialpreviousversion-src2Fos_unix.c
"		if (idx < FMT_PATTERNS)
		{
		    if (fmt_ptr->addr[idx])
		    {
			sprintf((char *)errmsg,
",1,unused,335,unused,"		if (idx < FMT_PATTERNS)
		{
		    if (fmt_ptr->addr[idx])
		    {
			sprintf((char *)errmsg,
",unused,vimactualxenialpreviousversion-src2Fquickfix.c
"			    || (idx == 6
				&& vim_strchr((char_u *)""OPQ"",
						    fmt_ptr->prefix) == NULL))
		    {
			sprintf((char *)errmsg,
",1,unused,348,unused,"			    || (idx == 6
				&& vim_strchr((char_u *)""OPQ"",
						    fmt_ptr->prefix) == NULL))
		    {
			sprintf((char *)errmsg,
",unused,vimactualxenialpreviousversion-src2Fquickfix.c
"		    }
		    else
		    {
			/* TODO: scanf()-like: %*ud, %*3c, %*f, ... ? */
			sprintf((char *)errmsg,
",1,unused,424,unused,"		    }
		    else
		    {
			/* TODO: scanf()-like: %*ud, %*3c, %*f, ... ? */
			sprintf((char *)errmsg,
",unused,vimactualxenialpreviousversion-src2Fquickfix.c
"		    if (vim_strchr((char_u *)""DXAEWICZGOPQ"", *efmp) != NULL)
			fmt_ptr->prefix = *efmp;
		    else
		    {
			sprintf((char *)errmsg,
",1,unused,444,unused,"		    if (vim_strchr((char_u *)""DXAEWICZGOPQ"", *efmp) != NULL)
			fmt_ptr->prefix = *efmp;
		    else
		    {
			sprintf((char *)errmsg,
",unused,vimactualxenialpreviousversion-src2Fquickfix.c
"		    }
		}
		else
		{
		    sprintf((char *)errmsg,
",1,unused,452,unused,"		    }
		}
		else
		{
		    sprintf((char *)errmsg,
",unused,vimactualxenialpreviousversion-src2Fquickfix.c
"	char_u *p = alloc((int)STRLEN(title) + 2);

	qi->qf_lists[qi->qf_curlist].qf_title = p;
	if (p != NULL)
	    sprintf((char *)p, "":%s"", (char *)title);
",1,unused,898,unused,"	char_u *p = alloc((int)STRLEN(title) + 2);

	qi->qf_lists[qi->qf_curlist].qf_title = p;
	if (p != NULL)
	    sprintf((char *)p, "":%s"", (char *)title);
",unused,vimactualxenialpreviousversion-src2Fquickfix.c
"	    /* Update the screen before showing the message, unless the screen
	     * scrolled up. */
	    if (!msg_scrolled)
		update_topline_redraw();
	    sprintf((char *)IObuff, _(""(%d of %d)%s%s: ""), qf_index,
",1,unused,1931,unused,"	    /* Update the screen before showing the message, unless the screen
	     * scrolled up. */
	    if (!msg_scrolled)
		update_topline_redraw();
	    sprintf((char *)IObuff, _(""(%d of %d)%s%s: ""), qf_index,
",unused,vimactualxenialpreviousversion-src2Fquickfix.c
"		if (qfp->qf_type == 1)	/* :helpgrep */
		    fname = gettail(fname);
	    }
	    if (fname == NULL)
		sprintf((char *)IObuff, ""%2d"", i);
",1,unused,2057,unused,"		if (qfp->qf_type == 1)	/* :helpgrep */
		    fname = gettail(fname);
	    }
	    if (fname == NULL)
		sprintf((char *)IObuff, ""%2d"", i);
",unused,vimactualxenialpreviousversion-src2Fquickfix.c
"					   ? hl_attr(HLF_L) : hl_attr(HLF_D));
	    if (qfp->qf_lnum == 0)
		IObuff[0] = NUL;
	    else if (qfp->qf_col == 0)
		sprintf((char *)IObuff, "":%ld"", qfp->qf_lnum);
",1,unused,2066,unused,"					   ? hl_attr(HLF_L) : hl_attr(HLF_D));
	    if (qfp->qf_lnum == 0)
		IObuff[0] = NUL;
	    else if (qfp->qf_col == 0)
		sprintf((char *)IObuff, "":%ld"", qfp->qf_lnum);
",unused,vimactualxenialpreviousversion-src2Fquickfix.c
"		IObuff[0] = NUL;
	    else if (qfp->qf_col == 0)
		sprintf((char *)IObuff, "":%ld"", qfp->qf_lnum);
	    else
		sprintf((char *)IObuff, "":%ld col %d"",
",1,unused,2068,unused,"		IObuff[0] = NUL;
	    else if (qfp->qf_col == 0)
		sprintf((char *)IObuff, "":%ld"", qfp->qf_lnum);
	    else
		sprintf((char *)IObuff, "":%ld col %d"",
",unused,vimactualxenialpreviousversion-src2Fquickfix.c
"		sprintf((char *)IObuff, "":%ld"", qfp->qf_lnum);
	    else
		sprintf((char *)IObuff, "":%ld col %d"",
						   qfp->qf_lnum, qfp->qf_col);
	    sprintf((char *)IObuff + STRLEN(IObuff), ""%s:"",
",1,unused,2070,unused,"		sprintf((char *)IObuff, "":%ld"", qfp->qf_lnum);
	    else
		sprintf((char *)IObuff, "":%ld col %d"",
						   qfp->qf_lnum, qfp->qf_col);
	    sprintf((char *)IObuff + STRLEN(IObuff), ""%s:"",
",unused,vimactualxenialpreviousversion-src2Fquickfix.c
"
    if (nr <= 0)
	return p;

    sprintf((char *)buf, ""%s %3d"", (char *)p, nr);
",1,unused,2297,unused,"
    if (nr <= 0)
	return p;

    sprintf((char *)buf, ""%s %3d"", (char *)p, nr);
",unused,vimactualxenialpreviousversion-src2Fquickfix.c
"	    IObuff[len++] = '|';

	    if (qfp->qf_lnum > 0)
	    {
		sprintf((char *)IObuff + len, ""%ld"", qfp->qf_lnum);
",1,unused,2691,unused,"	    IObuff[len++] = '|';

	    if (qfp->qf_lnum > 0)
	    {
		sprintf((char *)IObuff + len, ""%ld"", qfp->qf_lnum);
",unused,vimactualxenialpreviousversion-src2Fquickfix.c
"		len += (int)STRLEN(IObuff + len);

		if (qfp->qf_col > 0)
		{
		    sprintf((char *)IObuff + len, "" col %d"", qfp->qf_col);
",1,unused,2696,unused,"		len += (int)STRLEN(IObuff + len);

		if (qfp->qf_col > 0)
		{
		    sprintf((char *)IObuff + len, "" col %d"", qfp->qf_col);
",unused,vimactualxenialpreviousversion-src2Fquickfix.c
"		    sprintf((char *)IObuff + len, "" col %d"", qfp->qf_col);
		    len += (int)STRLEN(IObuff + len);
		}

		sprintf((char *)IObuff + len, ""%s"",
",1,unused,2700,unused,"		    sprintf((char *)IObuff + len, "" col %d"", qfp->qf_col);
		    len += (int)STRLEN(IObuff + len);
		}

		sprintf((char *)IObuff + len, ""%s"",
",unused,vimactualxenialpreviousversion-src2Fquickfix.c
"	len += (unsigned)STRLEN(p_sp) + (unsigned)STRLEN(fname) + 3;
    cmd = alloc(len);
    if (cmd == NULL)
	return;
    sprintf((char *)cmd, ""%s%s%s"", (char *)p_shq, (char *)eap->arg,
",1,unused,2888,unused,"	len += (unsigned)STRLEN(p_sp) + (unsigned)STRLEN(fname) + 3;
    cmd = alloc(len);
    if (cmd == NULL)
	return;
    sprintf((char *)cmd, ""%s%s%s"", (char *)p_shq, (char *)eap->arg,
",unused,vimactualxenialpreviousversion-src2Fquickfix.c
"	name = alloc((unsigned)STRLEN(p_mef) + 30);
	if (name == NULL)
	    break;
	STRCPY(name, p_mef);
	sprintf((char *)name + (p - p_mef), ""%d%d"", start, off);
",1,unused,2980,unused,"	name = alloc((unsigned)STRLEN(p_mef) + 30);
	if (name == NULL)
	    break;
	STRCPY(name, p_mef);
	sprintf((char *)name + (p - p_mef), ""%d%d"", start, off);
",unused,vimactualxenialpreviousversion-src2Fquickfix.c
"    if (re_multi_type(peekchr()) != NOT_MULTI)
    {
	/* Can't have a multi follow a multi. */
	if (peekchr() == Magic('*'))
	    sprintf((char *)IObuff, _(""E61: Nested %s*""),
",1,unused,1881,unused,"    if (re_multi_type(peekchr()) != NOT_MULTI)
    {
	/* Can't have a multi follow a multi. */
	if (peekchr() == Magic('*'))
	    sprintf((char *)IObuff, _(""E61: Nested %s*""),
",unused,vimactualxenialpreviousversion-src2Fregexp.c
"	if (peekchr() == Magic('*'))
	    sprintf((char *)IObuff, _(""E61: Nested %s*""),
					    reg_magic >= MAGIC_ON ? """" : ""\\"");
	else
	    sprintf((char *)IObuff, _(""E62: Nested %s%c""),
",1,unused,1884,unused,"	if (peekchr() == Magic('*'))
	    sprintf((char *)IObuff, _(""E61: Nested %s*""),
					    reg_magic >= MAGIC_ON ? """" : ""\\"");
	else
	    sprintf((char *)IObuff, _(""E62: Nested %s%c""),
",unused,vimactualxenialpreviousversion-src2Fregexp.c
"      case Magic('@'):
      case Magic('{'):
      case Magic('*'):
	c = no_Magic(c);
	sprintf((char *)IObuff, _(""E64: %s%c follows nothing""),
",1,unused,2059,unused,"      case Magic('@'):
      case Magic('{'):
      case Magic('*'):
	c = no_Magic(c);
	sprintf((char *)IObuff, _(""E64: %s%c follows nothing""),
",unused,vimactualxenialpreviousversion-src2Fregexp.c
"    if (*regparse == '\\')
	regparse++;	/* Allow either \{...} or \{...\} */
    if (*regparse != '}')
    {
	sprintf((char *)IObuff, _(""E554: Syntax error in %s{...}""),
",1,unused,3403,unused,"    if (*regparse == '\\')
	regparse++;	/* Allow either \{...} or \{...\} */
    if (*regparse != '}')
    {
	sprintf((char *)IObuff, _(""E554: Syntax error in %s{...}""),
",unused,vimactualxenialpreviousversion-src2Fregexp.c
"			*p++ = 's';
		    if (spats[0].off.off > 0 || spats[0].off.line)
			*p++ = '+';
		    if (spats[0].off.off != 0 || spats[0].off.line)
			sprintf((char *)p, ""%ld"", spats[0].off.off);
",1,unused,1343,unused,"			*p++ = 's';
		    if (spats[0].off.off > 0 || spats[0].off.line)
			*p++ = '+';
		    if (spats[0].off.off != 0 || spats[0].off.line)
			sprintf((char *)p, ""%ld"", spats[0].off.off);
",unused,vimactualxenialpreviousversion-src2Fsearch.c
"	vim_free(epat);
	curwin->w_cursor = old_pos;
	goto theend;
    }
    sprintf((char *)spat, ""<%.*s\\>\\%%(\\s\\_[^>]\\{-}[^/]>\\|>\\)\\c"", len, p);
",1,unused,3982,unused,"	vim_free(epat);
	curwin->w_cursor = old_pos;
	goto theend;
    }
    sprintf((char *)spat, ""<%.*s\\>\\%%(\\s\\_[^>]\\{-}[^/]>\\|>\\)\\c"", len, p);
",unused,vimactualxenialpreviousversion-src2Fsearch.c
"	curwin->w_cursor = old_pos;
	goto theend;
    }
    sprintf((char *)spat, ""<%.*s\\>\\%%(\\s\\_[^>]\\{-}[^/]>\\|>\\)\\c"", len, p);
    sprintf((char *)epat, ""</%.*s>\\c"", len, p);
",1,unused,3983,unused,"	curwin->w_cursor = old_pos;
	goto theend;
    }
    sprintf((char *)spat, ""<%.*s\\>\\%%(\\s\\_[^>]\\{-}[^/]>\\|>\\)\\c"", len, p);
    sprintf((char *)epat, ""</%.*s>\\c"", len, p);
",unused,vimactualxenialpreviousversion-src2Fsearch.c
"    {
	pat = alloc(len + 5);
	if (pat == NULL)
	    goto fpip_end;
	sprintf((char *)pat, whole ? ""\\<%.*s\\>"" : ""%.*s"", len, ptr);
",1,unused,4861,unused,"    {
	pat = alloc(len + 5);
	if (pat == NULL)
	    goto fpip_end;
	sprintf((char *)pat, whole ? ""\\<%.*s\\>"" : ""%.*s"", len, ptr);
",unused,vimactualxenialpreviousversion-src2Fsearch.c
"	    *(p + 1) = NUL;
	}
	if (action == ACTION_SHOW_ALL)
	{
	    sprintf((char *)IObuff, ""%3ld: "", count);	/* show match nr */
",1,unused,5535,unused,"	    *(p + 1) = NUL;
	}
	if (action == ACTION_SHOW_ALL)
	{
	    sprintf((char *)IObuff, ""%3ld: "", count);	/* show match nr */
",unused,vimactualxenialpreviousversion-src2Fsearch.c
"	if (action == ACTION_SHOW_ALL)
	{
	    sprintf((char *)IObuff, ""%3ld: "", count);	/* show match nr */
	    msg_puts(IObuff);
	    sprintf((char *)IObuff, ""%4ld"", *lnum);	/* show line nr */
",1,unused,5537,unused,"	if (action == ACTION_SHOW_ALL)
	{
	    sprintf((char *)IObuff, ""%3ld: "", count);	/* show match nr */
	    msg_puts(IObuff);
	    sprintf((char *)IObuff, ""%4ld"", *lnum);	/* show line nr */
",unused,vimactualxenialpreviousversion-src2Fsearch.c
"    if (salt != NULL)
	sha256_update(&ctx, salt, salt_len);
    sha256_finish(&ctx, sha256sum);
    for (j = 0; j < 32; j++)
	sprintf((char *)hexit + j * 2, ""%02x"", sha256sum[j]);
",1,unused,294,unused,"    if (salt != NULL)
	sha256_update(&ctx, salt, salt_len);
    sha256_finish(&ctx, sha256sum);
    for (j = 0; j < 32; j++)
	sprintf((char *)hexit + j * 2, ""%02x"", sha256sum[j]);
",unused,vimactualxenialpreviousversion-src2Fsha256.c
"	    for (j = 0; j < 1000; j++)
		sha256_update(&ctx, (char_u *)buf, 1000);
	    sha256_finish(&ctx, sha256sum);
	    for (j = 0; j < 32; j++)
		sprintf(output + j * 2, ""%02x"", sha256sum[j]);
",1,unused,371,unused,"	    for (j = 0; j < 1000; j++)
		sha256_update(&ctx, (char_u *)buf, 1000);
	    sha256_finish(&ctx, sha256sum);
	    for (j = 0; j < 32; j++)
		sprintf(output + j * 2, ""%02x"", sha256sum[j]);
",unused,vimactualxenialpreviousversion-src2Fsha256.c
"			char_u	buf[MAXLINELEN];

			aff_entry->ae_cond = getroom_save(spin, items[4]);
			if (*items[0] == 'P')
			    sprintf((char *)buf, ""^%s"", items[4]);
",1,unused,5720,unused,"			char_u	buf[MAXLINELEN];

			aff_entry->ae_cond = getroom_save(spin, items[4]);
			if (*items[0] == 'P')
			    sprintf((char *)buf, ""^%s"", items[4]);
",unused,vimactualxenialpreviousversion-src2Fspell.c
"			aff_entry->ae_cond = getroom_save(spin, items[4]);
			if (*items[0] == 'P')
			    sprintf((char *)buf, ""^%s"", items[4]);
			else
			    sprintf((char *)buf, ""%s$"", items[4]);
",1,unused,5722,unused,"			aff_entry->ae_cond = getroom_save(spin, items[4]);
			if (*items[0] == 'P')
			    sprintf((char *)buf, ""^%s"", items[4]);
			else
			    sprintf((char *)buf, ""%s$"", items[4]);
",unused,vimactualxenialpreviousversion-src2Fspell.c
"#endif
					    *aff_entry->ae_cond = c_up;
					if (aff_entry->ae_cond != NULL)
					{
					    sprintf((char *)buf, ""^%s"",
",1,unused,5787,unused,"#endif
					    *aff_entry->ae_cond = c_up;
					if (aff_entry->ae_cond != NULL)
					{
					    sprintf((char *)buf, ""^%s"",
",unused,vimactualxenialpreviousversion-src2Fspell.c
"
    frompat = alloc((unsigned)STRLEN(repl_from) + 7);
    if (frompat == NULL)
	return;
    sprintf((char *)frompat, ""\\V\\<%s\\>"", repl_from);
",1,unused,10401,unused,"
    frompat = alloc((unsigned)STRLEN(repl_from) + 7);
    if (frompat == NULL)
	return;
    sprintf((char *)frompat, ""\\V\\<%s\\>"", repl_from);
",unused,vimactualxenialpreviousversion-src2Fspell.c
"		STRCAT(badword, ""?"");
	    if (flags & WF_REGION)
		for (i = 0; i < 7; ++i)
		    if (flags & (0x10000 << i))
			sprintf((char *)badword + STRLEN(badword), ""%d"", i + 1);
",1,unused,15836,unused,"		STRCAT(badword, ""?"");
	    if (flags & WF_REGION)
		for (i = 0; i < 7; ++i)
		    if (flags & (0x10000 << i))
			sprintf((char *)badword + STRLEN(badword), ""%d"", i + 1);
",unused,vimactualxenialpreviousversion-src2Fspell.c
"    recursive = TRUE;
    buf = alloc((unsigned)(STRLEN(name) + 12));
    if (buf != NULL)
    {
	sprintf((char *)buf, ""colors/%s.vim"", name);
",1,unused,7106,unused,"    recursive = TRUE;
    buf = alloc((unsigned)(STRLEN(name) + 12));
    if (buf != NULL)
    {
	sprintf((char *)buf, ""colors/%s.vim"", name);
",unused,vimactualxenialpreviousversion-src2Fsyntax.c
"    if (type == LIST_STRING ? (sarg != NULL) : (iarg != 0))
    {
	ts = buf;
	if (type == LIST_INT)
	    sprintf((char *)buf, ""%d"", iarg - 1);
",1,unused,8864,unused,"    if (type == LIST_STRING ? (sarg != NULL) : (iarg != 0))
    {
	ts = buf;
	if (type == LIST_INT)
	    sprintf((char *)buf, ""%d"", iarg - 1);
",unused,vimactualxenialpreviousversion-src2Fsyntax.c
"		color = HL_TABLE()[id - 1].sg_gui_bg;
	    if (color == INVALCOLOR)
		return NULL;
	    rgb = gui_mch_get_rgb(color);
	    sprintf((char *)buf, ""#%02x%02x%02x"",
",1,unused,8981,unused,"		color = HL_TABLE()[id - 1].sg_gui_bg;
	    if (color == INVALCOLOR)
		return NULL;
	    rgb = gui_mch_get_rgb(color);
	    sprintf((char *)buf, ""#%02x%02x%02x"",
",unused,vimactualxenialpreviousversion-src2Fsyntax.c
"	else
	    n = HL_TABLE()[id - 1].sg_cterm_bg - 1;
	if (n < 0)
	    return NULL;
	sprintf((char *)name, ""%d"", n);
",1,unused,9004,unused,"	else
	    n = HL_TABLE()[id - 1].sg_cterm_bg - 1;
	if (n < 0)
	    return NULL;
	sprintf((char *)name, ""%d"", n);
",unused,vimactualxenialpreviousversion-src2Fsyntax.c
"    }
# endif
    for (i = 0; i < 9; i++)
    {
	sprintf((char *)userhl, ""User%d"", i + 1);
",1,unused,9594,unused,"    }
# endif
    for (i = 0; i < 9; i++)
    {
	sprintf((char *)userhl, ""User%d"", i + 1);
",unused,vimactualxenialpreviousversion-src2Fsyntax.c
"		&& (num_matches > 1 || ic)
		&& !skip_msg)
	    {
		/* Give an indication of the number of matching tags */
		sprintf((char *)IObuff, _(""tag %d of %d%s""),
",1,unused,1000,unused,"		&& (num_matches > 1 || ic)
		&& !skip_msg)
	    {
		/* Give an indication of the number of matching tags */
		sprintf((char *)IObuff, _(""tag %d of %d%s""),
",unused,vimactualxenialpreviousversion-src2Ftag.c
"	    if (name == NULL)	    /* file name not available */
		continue;

	    msg_putchar('\n');
	    sprintf((char *)IObuff, ""%c%2d %2d %-15s %5ld  "",
",1,unused,1136,unused,"	    if (name == NULL)	    /* file name not available */
		continue;

	    msg_putchar('\n');
	    sprintf((char *)IObuff, ""%c%2d %2d %-15s %5ld  "",
",unused,vimactualxenialpreviousversion-src2Ftag.c
"#ifdef FEAT_MULTI_LANG
			    p[len] = '@';
			    STRCPY(p + len + 1, help_lang);
#endif
			    sprintf((char *)p + len + 1 + ML_EXTRA, ""%06d"",
",1,unused,2288,unused,"#ifdef FEAT_MULTI_LANG
			    p[len] = '@';
			    STRCPY(p + len + 1, help_lang);
#endif
			    sprintf((char *)p + len + 1 + ML_EXTRA, ""%06d"",
",unused,vimactualxenialpreviousversion-src2Ftag.c
"		    found = 2;
		    (void)test_for_static(&tagp);
		    cc = *tagp.tagname_end;
		    *tagp.tagname_end = NUL;
		    sprintf((char *)pbuf, ""^%s\\s\\*("", tagp.tagname);
",1,unused,3271,unused,"		    found = 2;
		    (void)test_for_static(&tagp);
		    cc = *tagp.tagname_end;
		    *tagp.tagname_end = NUL;
		    sprintf((char *)pbuf, ""^%s\\s\\*("", tagp.tagname);
",unused,vimactualxenialpreviousversion-src2Ftag.c
"		    if (!do_search(NULL, '/', pbuf, (long)1,
							search_options, NULL))
		    {
			/* Guess again: ""^char * \<func  ("" */
			sprintf((char *)pbuf, ""^\\[#a-zA-Z_]\\.\\*\\<%s\\s\\*("",
",1,unused,3276,unused,"		    if (!do_search(NULL, '/', pbuf, (long)1,
							search_options, NULL))
		    {
			/* Guess again: ""^char * \<func  ("" */
			sprintf((char *)pbuf, ""^\\[#a-zA-Z_]\\.\\*\\<%s\\s\\*("",
",unused,vimactualxenialpreviousversion-src2Ftag.c
"    char_u	nr_colors[20];		/* string for number of colors */

    t_colors = nr;
    if (t_colors > 1)
	sprintf((char *)nr_colors, ""%d"", t_colors);
",1,unused,1412,unused,"    char_u	nr_colors[20];		/* string for number of colors */

    t_colors = nr;
    if (t_colors > 1)
	sprintf((char *)nr_colors, ""%d"", t_colors);
",unused,vimactualxenialpreviousversion-src2Fterm.c
"	      && (STRCMP(s + i + 1, ""%p1%dm"") == 0
		  || STRCMP(s + i + 1, ""%dm"") == 0)
	      && (s[i] == '3' || s[i] == '4'))
    {
	sprintf(buf,
",1,unused,2596,unused,"	      && (STRCMP(s + i + 1, ""%p1%dm"") == 0
		  || STRCMP(s + i + 1, ""%dm"") == 0)
	      && (s[i] == '3' || s[i] == '4'))
    {
	sprintf(buf,
",unused,vimactualxenialpreviousversion-src2Fterm.c
"		    src += 5;
		    result[dlen++] = K_SPECIAL;
		    result[dlen++] = (int)KS_EXTRA;
		    result[dlen++] = (int)KE_SNR;
		    sprintf((char *)result + dlen, ""%ld"", (long)current_SID);
",1,unused,5357,unused,"		    src += 5;
		    result[dlen++] = K_SPECIAL;
		    result[dlen++] = (int)KS_EXTRA;
		    result[dlen++] = (int)KE_SNR;
		    sprintf((char *)result + dlen, ""%ld"", (long)current_SID);
",unused,vimactualxenialpreviousversion-src2Fterm.c
"	sprintf(dbuf, ""Requesting XT %d: %s"",
				       xt_index_out, key_names[xt_index_out]);
	log_tr(dbuf);
# endif
	sprintf(buf, ""\033P+q%02x%02x\033\\"",
",1,unused,5718,unused,"	sprintf(dbuf, ""Requesting XT %d: %s"",
				       xt_index_out, key_names[xt_index_out]);
	log_tr(dbuf);
# endif
	sprintf(buf, ""\033P+q%02x%02x\033\\"",
",unused,vimactualxenialpreviousversion-src2Fterm.c
"	    /* Check for 9.9x or 9.9xx, alpha/beta version */
	    if (isalpha((int)vers[3]))
	    {
		int len = (isalpha((int)vers[4])) ? 5 : 4;
		sprintf((char *)vers + len, "".%d%s"", highest_patch(),
",1,unused,4746,unused,"	    /* Check for 9.9x or 9.9xx, alpha/beta version */
	    if (isalpha((int)vers[3]))
	    {
		int len = (isalpha((int)vers[4])) ? 5 : 4;
		sprintf((char *)vers + len, "".%d%s"", highest_patch(),
",unused,vimactualxenialpreviousversion-src2Fversion.c
"		sprintf((char *)vers + len, "".%d%s"", highest_patch(),
							 mediumVersion + len);
	    }
	    else
		sprintf((char *)vers + 3, "".%d"", highest_patch());
",1,unused,4750,unused,"		sprintf((char *)vers + len, "".%d%s"", highest_patch(),
							 mediumVersion + len);
	    }
	    else
		sprintf((char *)vers + 3, "".%d"", highest_patch());
",unused,vimactualxenialpreviousversion-src2Fversion.c
"		 * cursor in a new window.
		 */
		if (bt_quickfix(curbuf))
		{
		    sprintf((char *)cbuf, ""split +%ld%s"",
",1,unused,528,unused,"		 * cursor in a new window.
		 */
		if (bt_quickfix(curbuf))
		{
		    sprintf((char *)cbuf, ""split +%ld%s"",
",unused,vimactualxenialpreviousversion-src2Fwindow.c
"  static char z[LLEN+1];
  static int zero_seen = 0;

  if (!nz && zero_seen == 1)
    strcpy(z, l);
",1,unused,420,unused,"  static char z[LLEN+1];
  static int zero_seen = 0;

  if (!nz && zero_seen == 1)
    strcpy(z, l);
",unused,vimactualxenialpreviousversion-src2Fxxd2Fxxd.c
"  while ((length < 0 || n < length) && (e = getc(fp)) != EOF)
    {
      if (p == 0)
	{
	  sprintf(l, ""%08lx:"",
",1,unused,823,unused,"  while ((length < 0 || n < length) && (e = getc(fp)) != EOF)
    {
      if (p == 0)
	{
	  sprintf(l, ""%08lx:"",
",unused,vimactualxenialpreviousversion-src2Fxxd2Fxxd.c
"
    static void
buf_hashtab_add(buf_T *buf)
{
    sprintf((char *)buf->b_key, ""%x"", buf->b_fnum);
",1,unused,414,unused,"
    static void
buf_hashtab_add(buf_T *buf)
{
    sprintf((char *)buf->b_key, ""%x"", buf->b_fnum);
",unused,vimartful-src2Fbuffer.c
"    hashitem_T	*hi;

    if (nr == 0)
	nr = curwin->w_alt_fnum;
    sprintf((char *)key, ""%x"", nr);
",1,unused,2738,unused,"    hashitem_T	*hi;

    if (nr == 0)
	nr = curwin->w_alt_fnum;
    sprintf((char *)key, ""%x"", nr);
",unused,vimartful-src2Fbuffer.c
"	    char_u	*s;

	    if (opt.jo_set & JO_IN_BUF)
	    {
		sprintf((char *)numbuf, ""%d"", opt.jo_io_buf[PART_IN]);
",1,unused,4941,unused,"	    char_u	*s;

	    if (opt.jo_set & JO_IN_BUF)
	    {
		sprintf((char *)numbuf, ""%d"", opt.jo_io_buf[PART_IN]);
",unused,vimartful-src2Fchannel.c
"
    list_hashtable_vars(&curbuf->b_vars->dv_hashtab, (char_u *)""b:"",
								 TRUE, first);

    sprintf((char *)numbuf, ""%ld"", (long)curbuf->b_changedtick);
",1,unused,1459,unused,"
    list_hashtable_vars(&curbuf->b_vars->dv_hashtab, (char_u *)""b:"",
								 TRUE, first);

    sprintf((char *)numbuf, ""%ld"", (long)curbuf->b_changedtick);
",unused,vimartful-src2Feval.c
"    if (newval == NULL)
	return NULL;

    if (eap->force_bin == FORCE_BIN)
	sprintf((char *)newval, "" ++bin"");
",1,unused,6784,unused,"    if (newval == NULL)
	return NULL;

    if (eap->force_bin == FORCE_BIN)
	sprintf((char *)newval, "" ++bin"");
",unused,vimartful-src2Feval.c
"
    if (eap->force_bin == FORCE_BIN)
	sprintf((char *)newval, "" ++bin"");
    else if (eap->force_bin == FORCE_NOBIN)
	sprintf((char *)newval, "" ++nobin"");
",1,unused,6786,unused,"
    if (eap->force_bin == FORCE_BIN)
	sprintf((char *)newval, "" ++bin"");
    else if (eap->force_bin == FORCE_NOBIN)
	sprintf((char *)newval, "" ++nobin"");
",unused,vimartful-src2Feval.c
"    if (eap->read_edit)
	STRCAT(newval, "" ++edit"");

    if (eap->force_ff != 0)
	sprintf((char *)newval + STRLEN(newval), "" ++ff=%s"",
",1,unused,6794,unused,"    if (eap->read_edit)
	STRCAT(newval, "" ++edit"");

    if (eap->force_ff != 0)
	sprintf((char *)newval + STRLEN(newval), "" ++ff=%s"",
",unused,vimartful-src2Feval.c
"	sprintf((char *)newval + STRLEN(newval), "" ++ff=%s"",
						eap->cmd + eap->force_ff);
# ifdef FEAT_MBYTE
    if (eap->force_enc != 0)
	sprintf((char *)newval + STRLEN(newval), "" ++enc=%s"",
",1,unused,6798,unused,"	sprintf((char *)newval + STRLEN(newval), "" ++ff=%s"",
						eap->cmd + eap->force_ff);
# ifdef FEAT_MBYTE
    if (eap->force_enc != 0)
	sprintf((char *)newval + STRLEN(newval), "" ++enc=%s"",
",unused,vimartful-src2Feval.c
"	STRCPY(newval + STRLEN(newval), "" ++bad=keep"");
    else if (eap->bad_char == BAD_DROP)
	STRCPY(newval + STRLEN(newval), "" ++bad=drop"");
    else if (eap->bad_char != 0)
	sprintf((char *)newval + STRLEN(newval), "" ++bad=%c"", eap->bad_char);
",1,unused,6805,unused,"	STRCPY(newval + STRLEN(newval), "" ++bad=keep"");
    else if (eap->bad_char == BAD_DROP)
	STRCPY(newval + STRLEN(newval), "" ++bad=drop"");
    else if (eap->bad_char != 0)
	sprintf((char *)newval + STRLEN(newval), "" ++bad=%c"", eap->bad_char);
",unused,vimartful-src2Feval.c
"	    ga_concat(gap, (char_u *)"" "");
    }
    if (sourcing_lnum > 0)
    {
	sprintf(buf, ""line %ld"", (long)sourcing_lnum);
",1,unused,9016,unused,"	    ga_concat(gap, (char_u *)"" "");
    }
    if (sourcing_lnum > 0)
    {
	sprintf(buf, ""line %ld"", (long)sourcing_lnum);
",unused,vimartful-src2Feval.c
"		    + 20		    /* for %3ld */
		    + STRLEN(s)));	    /* concatenated */
	if (r != NULL)
	{
	    sprintf((char *)r, txt, dashes, count);
",1,unused,3517,unused,"		    + 20		    /* for %3ld */
		    + STRLEN(s)));	    /* concatenated */
	if (r != NULL)
	{
	    sprintf((char *)r, txt, dashes, count);
",unused,vimartful-src2Fevalfunc.c
"	    /* Expand s: and <SID> into <SNR>nr_, so that the function can
	     * also be called from another script. Using trans_function_name()
	     * would also work, but some plugins depend on the name being
	     * printable text. */
	    sprintf(sid_buf, ""<SNR>%ld_"", (long)current_SID);
",1,unused,3636,unused,"	    /* Expand s: and <SID> into <SNR>nr_, so that the function can
	     * also be called from another script. Using trans_function_name()
	     * would also work, but some plugins depend on the name being
	     * printable text. */
	    sprintf(sid_buf, ""<SNR>%ld_"", (long)current_SID);
",unused,vimartful-src2Fevalfunc.c
"		    {
			list_append_number(l, (varnumber_T)llpos->col);
			list_append_number(l, (varnumber_T)llpos->len);
		    }
		    sprintf(buf, ""pos%d"", i + 1);
",1,unused,4803,unused,"		    {
			list_append_number(l, (varnumber_T)llpos->col);
			list_append_number(l, (varnumber_T)llpos->len);
		    }
		    sprintf(buf, ""pos%d"", i + 1);
",unused,vimartful-src2Fevalfunc.c
"	case MLINE: buf[0] = 'V'; break;
	case MCHAR: buf[0] = 'v'; break;
	case MBLOCK:
		buf[0] = Ctrl_V;
		sprintf((char *)buf + 1, ""%ld"", reglen + 1);
",1,unused,4999,unused,"	case MLINE: buf[0] = 'V'; break;
	case MCHAR: buf[0] = 'v'; break;
	case MBLOCK:
		buf[0] = Ctrl_V;
		sprintf((char *)buf + 1, ""%ld"", reglen + 1);
",unused,vimartful-src2Fevalfunc.c
"	dictitem_T	v;
	char_u		str[30];
	char_u		*idvar;

	sprintf((char *)str, PRINTF_HEX_LONG_U, (long_u)w);
",1,unused,8488,unused,"	dictitem_T	v;
	char_u		str[30];
	char_u		*idvar;

	sprintf((char *)str, PRINTF_HEX_LONG_U, (long_u)w);
",unused,vimartful-src2Fevalfunc.c
"    pat2 = alloc((unsigned)(STRLEN(spat) + STRLEN(epat) + 17));
    pat3 = alloc((unsigned)(STRLEN(spat) + STRLEN(mpat) + STRLEN(epat) + 25));
    if (pat2 == NULL || pat3 == NULL)
	goto theend;
    sprintf((char *)pat2, ""\\m\\(%s\\m\\)\\|\\(%s\\m\\)"", spat, epat);
",1,unused,9487,unused,"    pat2 = alloc((unsigned)(STRLEN(spat) + STRLEN(epat) + 17));
    pat3 = alloc((unsigned)(STRLEN(spat) + STRLEN(mpat) + STRLEN(epat) + 25));
    if (pat2 == NULL || pat3 == NULL)
	goto theend;
    sprintf((char *)pat2, ""\\m\\(%s\\m\\)\\|\\(%s\\m\\)"", spat, epat);
",unused,vimartful-src2Fevalfunc.c
"    sprintf((char *)pat2, ""\\m\\(%s\\m\\)\\|\\(%s\\m\\)"", spat, epat);
    if (*mpat == NUL)
	STRCPY(pat3, pat2);
    else
	sprintf((char *)pat3, ""\\m\\(%s\\m\\)\\|\\(%s\\m\\)\\|\\(%s\\m\\)"",
",1,unused,9491,unused,"    sprintf((char *)pat2, ""\\m\\(%s\\m\\)\\|\\(%s\\m\\)"", spat, epat);
    if (*mpat == NUL)
	STRCPY(pat3, pat2);
    else
	sprintf((char *)pat3, ""\\m\\(%s\\m\\)\\|\\(%s\\m\\)\\|\\(%s\\m\\)"",
",unused,vimartful-src2Fevalfunc.c
"
		/* match from matchaddpos() */
		for (i = 1; i < 9; i++)
		{
		    sprintf((char *)buf, (char *)""pos%d"", i);
",1,unused,10043,unused,"
		/* match from matchaddpos() */
		for (i = 1; i < 9; i++)
		{
		    sprintf((char *)buf, (char *)""pos%d"", i);
",unused,vimartful-src2Fevalfunc.c
"
    ga_init2(&ga, (int)sizeof(char), 70);
    FOR_ALL_WINDOWS(wp)
    {
	sprintf((char *)buf, ""%dresize %d|"", winnr, wp->w_height);
",1,unused,12931,unused,"
    ga_init2(&ga, (int)sizeof(char), 70);
    FOR_ALL_WINDOWS(wp)
    {
	sprintf((char *)buf, ""%dresize %d|"", winnr, wp->w_height);
",unused,vimartful-src2Fevalfunc.c
"    FOR_ALL_WINDOWS(wp)
    {
	sprintf((char *)buf, ""%dresize %d|"", winnr, wp->w_height);
	ga_concat(&ga, buf);
	sprintf((char *)buf, ""vert %dresize %d|"", winnr, wp->w_width);
",1,unused,12933,unused,"    FOR_ALL_WINDOWS(wp)
    {
	sprintf((char *)buf, ""%dresize %d|"", winnr, wp->w_height);
	ga_concat(&ga, buf);
	sprintf((char *)buf, ""vert %dresize %d|"", winnr, wp->w_width);
",unused,vimartful-src2Fevalfunc.c
"	    if (s == NULL)
		got_int = TRUE;
	    else
	    {
		sprintf((char *)s, ""help-tags\t%s\t1\n"", tagfname);
",1,unused,7114,unused,"	    if (s == NULL)
		got_int = TRUE;
	    else
	    {
		sprintf((char *)s, ""help-tags\t%s\t1\n"", tagfname);
",unused,vimartful-src2Fex_cmds.c
"			    break;
			}
			((char_u **)ga.ga_data)[ga.ga_len] = s;
			++ga.ga_len;
			sprintf((char *)s, ""%s\t%s"", p1, fname);
",1,unused,7210,unused,"			    break;
			}
			((char_u **)ga.ga_data)[ga.ga_len] = s;
			++ga.ga_len;
			sprintf((char *)s, ""%s\t%s"", p1, fname);
",unused,vimartful-src2Fex_cmds.c
"		    }
		    cmd = alloc((unsigned)STRLEN(buf->b_fname) + 25);
		    if (cmd == NULL)
			return;
		    sprintf((char *)cmd, ""e +%ld %s"", (long)lnum, buf->b_fname);
",1,unused,7859,unused,"		    }
		    cmd = alloc((unsigned)STRLEN(buf->b_fname) + 25);
		    if (cmd == NULL)
			return;
		    sprintf((char *)cmd, ""e +%ld %s"", (long)lnum, buf->b_fname);
",unused,vimartful-src2Fex_cmds.c
"
    QueryPerformanceFrequency(&fr);
    sprintf(buf, ""%10.6lf"", (double)tm->QuadPart / (double)fr.QuadPart);
# else
    sprintf(buf, ""%3ld.%06ld"", (long)tm->tv_sec, (long)tm->tv_usec);
",1,unused,1001,unused,"
    QueryPerformanceFrequency(&fr);
    sprintf(buf, ""%10.6lf"", (double)tm->QuadPart / (double)fr.QuadPart);
# else
    sprintf(buf, ""%3ld.%06ld"", (long)tm->tv_sec, (long)tm->tv_usec);
",unused,vimartful-src2Fex_cmds2.c
"	    }
	    do_unlet((char_u *)""g:current_compiler"", TRUE);
	    do_unlet((char_u *)""b:current_compiler"", TRUE);

	    sprintf((char *)buf, ""compiler/%s.vim"", eap->arg);
",1,unused,3204,unused,"	    }
	    do_unlet((char_u *)""g:current_compiler"", TRUE);
	    do_unlet((char_u *)""b:current_compiler"", TRUE);

	    sprintf((char *)buf, ""compiler/%s.vim"", eap->arg);
",unused,vimartful-src2Fex_cmds2.c
"	    {
		if (a & COUNT)
		{
		    /* -count=N */
		    sprintf((char *)IObuff + len, ""%ldc"", cmd->uc_def);
",1,unused,6015,unused,"	    {
		if (a & COUNT)
		{
		    /* -count=N */
		    sprintf((char *)IObuff + len, ""%ldc"", cmd->uc_def);
",unused,vimartful-src2Fex_docmd.c
"		    IObuff[len++] = '%';
		else if (cmd->uc_def >= 0)
		{
		    /* -range=N */
		    sprintf((char *)IObuff + len, ""%ld"", cmd->uc_def);
",1,unused,6023,unused,"		    IObuff[len++] = '%';
		else if (cmd->uc_def >= 0)
		{
		    /* -range=N */
		    sprintf((char *)IObuff + len, ""%ld"", cmd->uc_def);
",unused,vimartful-src2Fex_docmd.c
"		   (type == ct_LINE2) ? eap->line2 :
		   (eap->addr_count > 0) ? eap->line2 : cmd->uc_def;
	size_t num_len;

	sprintf(num_buf, ""%ld"", num);
",1,unused,6671,unused,"		   (type == ct_LINE2) ? eap->line2 :
		   (eap->addr_count > 0) ? eap->line2 : cmd->uc_def;
	size_t num_len;

	sprintf(num_buf, ""%ld"", num);
",unused,vimartful-src2Fex_docmd.c
"#  else
	if (mch_get_winpos(&x, &y) != FAIL)
#  endif
	{
	    sprintf((char *)IObuff, _(""Window position: X %d, Y %d""), x, y);
",1,unused,9203,unused,"#  else
	if (mch_get_winpos(&x, &y) != FAIL)
#  endif
	{
	    sprintf((char *)IObuff, _(""Window position: X %d, Y %d""), x, y);
",unused,vimartful-src2Fex_docmd.c
"		{
		    *errormsg = (char_u *)_(""E496: no autocommand buffer number to substitute for \""<abuf>\"""");
		    return NULL;
		}
		sprintf((char *)strbuf, ""%d"", autocmd_bufnr);
",1,unused,10730,unused,"		{
		    *errormsg = (char_u *)_(""E496: no autocommand buffer number to substitute for \""<abuf>\"""");
		    return NULL;
		}
		sprintf((char *)strbuf, ""%d"", autocmd_bufnr);
",unused,vimartful-src2Fex_docmd.c
"		{
		    *errormsg = (char_u *)_(""E842: no line number to use for \""<slnum>\"""");
		    return NULL;
		}
		sprintf((char *)strbuf, ""%ld"", (long)sourcing_lnum);
",1,unused,10758,unused,"		{
		    *errormsg = (char_u *)_(""E842: no line number to use for \""<slnum>\"""");
		    return NULL;
		}
		sprintf((char *)strbuf, ""%ld"", (long)sourcing_lnum);
",unused,vimartful-src2Fex_docmd.c
"		result = strbuf;
		break;
#if defined(FEAT_CLIENTSERVER)
	case SPEC_CLIENT:	/* Source of last submitted input */
		sprintf((char *)strbuf, PRINTF_HEX_LONG_U,
",1,unused,10763,unused,"		result = strbuf;
		break;
#if defined(FEAT_CLIENTSERVER)
	case SPEC_CLIENT:	/* Source of last submitted input */
		sprintf((char *)strbuf, PRINTF_HEX_LONG_U,
",unused,vimartful-src2Fex_docmd.c
"			continue;

		    STRCAT(val, p);
		    p[-2] = NUL;
		    sprintf((char *)(val + STRLEN(p)), "" (%s)"", &mesg[1]);
",1,unused,482,unused,"			continue;

		    STRCAT(val, p);
		    p[-2] = NUL;
		    sprintf((char *)(val + STRLEN(p)), "" (%s)"", &mesg[1]);
",unused,vimartful-src2Fex_eval.c
"    }

    args[0] = vim_strnsave(xp->xp_pattern, xp->xp_pattern_len);
    args[1] = xp->xp_line;
    sprintf((char *)num, ""%d"", xp->xp_col);
",1,unused,5163,unused,"    }

    args[0] = vim_strnsave(xp->xp_pattern, xp->xp_pattern_len);
    args[1] = xp->xp_line;
    sprintf((char *)num, ""%d"", xp->xp_col);
",unused,vimartful-src2Fex_getln.c
"	{
	    ga_clear_strings(&ga);
	    return FAIL;
	}
	sprintf((char *)s, ""%s/%s*.vim"", dirnames[i], pat);
",1,unused,5313,unused,"	{
	    ga_clear_strings(&ga);
	    return FAIL;
	}
	sprintf((char *)s, ""%s/%s*.vim"", dirnames[i], pat);
",unused,vimartful-src2Fex_getln.c
"	    {
		ga_clear_strings(&ga);
		return FAIL;
	    }
	    sprintf((char *)s, ""pack/*/start/*/%s/%s*.vim"", dirnames[i], pat);
",1,unused,5327,unused,"	    {
		ga_clear_strings(&ga);
		return FAIL;
	    }
	    sprintf((char *)s, ""pack/*/start/*/%s/%s*.vim"", dirnames[i], pat);
",unused,vimartful-src2Fex_getln.c
"	    {
		ga_clear_strings(&ga);
		return FAIL;
	    }
	    sprintf((char *)s, ""pack/*/opt/*/%s/%s*.vim"", dirnames[i], pat);
",1,unused,5342,unused,"	    {
		ga_clear_strings(&ga);
		return FAIL;
	    }
	    sprintf((char *)s, ""pack/*/opt/*/%s/%s*.vim"", dirnames[i], pat);
",unused,vimartful-src2Fex_getln.c
"    {
	ga_clear_strings(&ga);
	return FAIL;
    }
    sprintf((char *)s, ""pack/*/opt/%s*"", pat);
",1,unused,5405,unused,"    {
	ga_clear_strings(&ga);
	return FAIL;
    }
    sprintf((char *)s, ""pack/*/opt/%s*"", pat);
",unused,vimartful-src2Fex_getln.c
"		if (hist[i].hisstr != NULL
			&& hist[i].hisnum >= j && hist[i].hisnum <= k)
		{
		    msg_putchar('\n');
		    sprintf((char *)IObuff, ""%c%6d  "", i == idx ? '>' : ' ',
",1,unused,6242,unused,"		if (hist[i].hisstr != NULL
			&& hist[i].hisnum >= j && hist[i].hisnum <= k)
		{
		    msg_putchar('\n');
		    sprintf((char *)IObuff, ""%c%6d  "", i == idx ? '>' : ' ',
",unused,vimartful-src2Fex_getln.c
"			     * |{bartype},{histtype},{timestamp},{separator},""text"" */
			    if (c == NUL)
				cbuf[0] = NUL;
			    else
				sprintf(cbuf, ""%d"", c);
",1,unused,6708,unused,"			     * |{bartype},{histtype},{timestamp},{separator},""text"" */
			    if (c == NUL)
				cbuf[0] = NUL;
			    else
				sprintf(cbuf, ""%d"", c);
",unused,vimartful-src2Fex_getln.c
"#endif
#ifdef FEAT_MBYTE
	    if (conv_error != 0)
	    {
		sprintf((char *)IObuff + STRLEN(IObuff),
",1,unused,2542,unused,"#endif
#ifdef FEAT_MBYTE
	    if (conv_error != 0)
	    {
		sprintf((char *)IObuff + STRLEN(IObuff),
",unused,vimartful-src2Ffileio.c
"		c = TRUE;
	    }
	    else if (illegal_byte > 0)
	    {
		sprintf((char *)IObuff + STRLEN(IObuff),
",1,unused,2548,unused,"		c = TRUE;
	    }
	    else if (illegal_byte > 0)
	    {
		sprintf((char *)IObuff + STRLEN(IObuff),
",unused,vimartful-src2Ffileio.c
"    if (eap->cmd == NULL)
	return FAIL;

#ifdef FEAT_MBYTE
    sprintf((char *)eap->cmd, ""e ++ff=%s ++enc=%s"", buf->b_p_ff, buf->b_p_fenc);
",1,unused,2781,unused,"    if (eap->cmd == NULL)
	return FAIL;

#ifdef FEAT_MBYTE
    sprintf((char *)eap->cmd, ""e ++ff=%s ++enc=%s"", buf->b_p_ff, buf->b_p_fenc);
",unused,vimartful-src2Ffileio.c
"		 */
		STRCPY(IObuff, fname);
		for (i = 4913; ; i += 123)
		{
		    sprintf((char *)gettail(IObuff), ""%d"", i);
",1,unused,3735,unused,"		 */
		STRCPY(IObuff, fname);
		for (i = 4913; ; i += 123)
		{
		    sprintf((char *)gettail(IObuff), ""%d"", i);
",unused,vimartful-src2Ffileio.c
"    {
	if (lnum == 1)
	    STRCPY(p, _(""1 line, ""));
	else
	    sprintf((char *)p, _(""%ld lines, ""), lnum);
",1,unused,5259,unused,"    {
	if (lnum == 1)
	    STRCPY(p, _(""1 line, ""));
	else
	    sprintf((char *)p, _(""%ld lines, ""), lnum);
",unused,vimartful-src2Ffileio.c
"	    return -1;
	STRCPY(tempname, from);
	for (n = 123; n < 99999; ++n)
	{
	    sprintf((char *)gettail((char_u *)tempname), ""%d"", n);
",1,unused,6519,unused,"	    return -1;
	STRCPY(tempname, from);
	for (n = 123; n < 99999; ++n)
	{
	    sprintf((char *)gettail((char_u *)tempname), ""%d"", n);
",unused,vimartful-src2Ffileio.c
"	    if (!helpmesg)
		mesg2 = """";
	    tbuf = alloc((unsigned)(STRLEN(path) + STRLEN(mesg)
							+ STRLEN(mesg2) + 2));
	    sprintf((char *)tbuf, mesg, path);
",1,unused,6967,unused,"	    if (!helpmesg)
		mesg2 = """";
	    tbuf = alloc((unsigned)(STRLEN(path) + STRLEN(mesg)
							+ STRLEN(mesg2) + 2));
	    sprintf((char *)tbuf, mesg, path);
",unused,vimartful-src2Ffileio.c
"    if (vim_tempdir != NULL)
    {
	/* There is no need to check if the file exists, because we own the
	 * directory and nobody else creates a file in it. */
	sprintf((char *)itmp, ""%s%ld"", vim_tempdir, temp_count++);
",1,unused,7465,unused,"    if (vim_tempdir != NULL)
    {
	/* There is no need to check if the file exists, because we own the
	 * directory and nobody else creates a file in it. */
	sprintf((char *)itmp, ""%s%ld"", vim_tempdir, temp_count++);
",unused,vimartful-src2Ffileio.c
"
	if (is_buflocal)
	{
	    /* normalize pat into standard ""<buffer>#N"" form */
	    sprintf((char *)buflocal_pat, ""<buffer=%d>"", buflocal_nr);
",1,unused,8601,unused,"
	if (is_buflocal)
	{
	    /* normalize pat into standard ""<buffer>#N"" form */
	    sprintf((char *)buflocal_pat, ""<buffer=%d>"", buflocal_nr);
",unused,vimartful-src2Ffileio.c
"		sourcing_name = alloc((unsigned)(STRLEN(s)
					    + STRLEN(name) + ap->patlen + 1));
		if (sourcing_name != NULL)
		{
		    sprintf((char *)sourcing_name, s,
",1,unused,9738,unused,"		sourcing_name = alloc((unsigned)(STRLEN(s)
					    + STRLEN(name) + ap->patlen + 1));
		if (sourcing_name != NULL)
		{
		    sprintf((char *)sourcing_name, s,
",unused,vimartful-src2Ffileio.c
"add_num_buff(buffheader_T *buf, long n)
{
    char_u	number[32];

    sprintf((char *)number, ""%ld"", n);
",1,unused,296,unused,"add_num_buff(buffheader_T *buf, long n)
{
    char_u	number[32];

    sprintf((char *)number, ""%ld"", n);
",unused,vimartful-src2Fgetchar.c
"		i = getdigits(&p);
		if (i != 0)
		{
		    /* Double the width specification. */
		    sprintf((char *)wp, ""%d%s"", i * 2, p);
",1,unused,951,unused,"		i = getdigits(&p);
		if (i != 0)
		{
		    /* Double the width specification. */
		    sprintf((char *)wp, ""%d%s"", i * 2, p);
",unused,vimartful-src2Fgui.c
"    if (strcmp(path, SFcurrentDir))
    {
	result = mch_chdir(path);
	if (!result)
	    (void) strcpy(SFcurrentDir, path);
",1,unused,253,unused,"    if (strcmp(path, SFcurrentDir))
    {
	result = mch_chdir(path);
	if (!result)
	    (void) strcpy(SFcurrentDir, path);
",unused,vimartful-src2Fgui_at_fs.c
"
    static void
SFstrdup(char **s1, char *s2)
{
    *s1 = strcpy(XtMalloc((unsigned)(strlen(s2) + 1)), s2);
",1,unused,287,unused,"
    static void
SFstrdup(char **s1, char *s2)
{
    *s1 = strcpy(XtMalloc((unsigned)(strlen(s2) + 1)), s2);
",unused,vimartful-src2Fgui_at_fs.c
"
    *(dir->path) = 0;
    len = strlen(str);
    if (str[len - 1] == '/')
	(void) strcat(SFcurrentPath, str);
",1,unused,315,unused,"
    *(dir->path) = 0;
    len = strlen(str);
    if (str[len - 1] == '/')
	(void) strcat(SFcurrentPath, str);
",unused,vimartful-src2Fgui_at_fs.c
"    i = 1;
    entries = (SFEntry *)XtMalloc(sizeof(SFEntry));
    SFlogins = (SFLogin *)XtMalloc(sizeof(SFLogin));
    entries[0].real = XtMalloc(3);
    (void) strcpy(entries[0].real, ""~"");
",1,unused,520,unused,"    i = 1;
    entries = (SFEntry *)XtMalloc(sizeof(SFEntry));
    SFlogins = (SFLogin *)XtMalloc(sizeof(SFLogin));
    entries[0].real = XtMalloc(3);
    (void) strcpy(entries[0].real, ""~"");
",unused,vimartful-src2Fgui_at_fs.c
"					 (unsigned)(Alloc * sizeof(SFLogin)));
	}
	len = strlen(pw->pw_name);
	entries[i].real = XtMalloc((unsigned) (len + 3));
	(void) strcat(strcpy(entries[i].real, ""~""), pw->pw_name);
",1,unused,542,unused,"					 (unsigned)(Alloc * sizeof(SFLogin)));
	}
	len = strlen(pw->pw_name);
	entries[i].real = XtMalloc((unsigned) (len + 3));
	(void) strcat(strcpy(entries[i].real, ""~""), pw->pw_name);
",unused,vimartful-src2Fgui_at_fs.c
"					 (unsigned)(Alloc * sizeof(SFLogin)));
	}
	len = strlen(pw->pw_name);
	entries[i].real = XtMalloc((unsigned) (len + 3));
	(void) strcat(strcpy(entries[i].real, ""~""), pw->pw_name);
",1,unused,542,unused,"					 (unsigned)(Alloc * sizeof(SFLogin)));
	}
	len = strlen(pw->pw_name);
	entries[i].real = XtMalloc((unsigned) (len + 3));
	(void) strcat(strcpy(entries[i].real, ""~""), pw->pw_name);
",unused,vimartful-src2Fgui_at_fs.c
"    qsort((char *)entries, (size_t)i, sizeof(SFEntry), SFcompareEntries);
    qsort((char *)SFlogins, (size_t)i, sizeof(SFLogin), SFcompareLogins);

    for (i--; i >= 0; i--)
	(void)strcat(entries[i].real, ""/"");
",1,unused,568,unused,"    qsort((char *)entries, (size_t)i, sizeof(SFEntry), SFcompareEntries);
    qsort((char *)SFlogins, (size_t)i, sizeof(SFLogin), SFcompareLogins);

    for (i--; i >= 0; i--)
	(void)strcat(entries[i].real, ""/"");
",unused,vimartful-src2Fgui_at_fs.c
"	if (!strcmp(SFhomeDir.entries[i].real, begin))
	{
	    *end = save;
	    SFstrdup(&theRest, end);
	    (void) strcat(strcat(strcpy(SFcurrentPath,
",1,unused,589,unused,"	if (!strcmp(SFhomeDir.entries[i].real, begin))
	{
	    *end = save;
	    SFstrdup(&theRest, end);
	    (void) strcat(strcat(strcpy(SFcurrentPath,
",unused,vimartful-src2Fgui_at_fs.c
"	if (!strcmp(SFhomeDir.entries[i].real, begin))
	{
	    *end = save;
	    SFstrdup(&theRest, end);
	    (void) strcat(strcat(strcpy(SFcurrentPath,
",1,unused,589,unused,"	if (!strcmp(SFhomeDir.entries[i].real, begin))
	{
	    *end = save;
	    SFstrdup(&theRest, end);
	    (void) strcat(strcat(strcpy(SFcurrentPath,
",unused,vimartful-src2Fgui_at_fs.c
"	if (!strcmp(SFhomeDir.entries[i].real, begin))
	{
	    *end = save;
	    SFstrdup(&theRest, end);
	    (void) strcat(strcat(strcpy(SFcurrentPath,
",1,unused,589,unused,"	if (!strcmp(SFhomeDir.entries[i].real, begin))
	{
	    *end = save;
	    SFstrdup(&theRest, end);
	    (void) strcat(strcat(strcpy(SFcurrentPath,
",unused,vimartful-src2Fgui_at_fs.c
"			int len;

			len = strlen(shown);
			entry->shown = XtMalloc((unsigned) (len + 2));
			(void) strcpy(entry->shown, shown);
",1,unused,1366,unused,"			int len;

			len = strlen(shown);
			entry->shown = XtMalloc((unsigned) (len + 2));
			(void) strcpy(entry->shown, shown);
",unused,vimartful-src2Fgui_at_fs.c
"	result[i].statDone = 0;
	str = dp->d_name;
	len = strlen(str);
	result[i].real = XtMalloc((unsigned) (len + 2));
	(void) strcat(strcpy(result[i].real, str), "" "");
",1,unused,2095,unused,"	result[i].statDone = 0;
	str = dp->d_name;
	len = strlen(str);
	result[i].real = XtMalloc((unsigned) (len + 2));
	(void) strcat(strcpy(result[i].real, str), "" "");
",unused,vimartful-src2Fgui_at_fs.c
"	result[i].statDone = 0;
	str = dp->d_name;
	len = strlen(str);
	result[i].real = XtMalloc((unsigned) (len + 2));
	(void) strcat(strcpy(result[i].real, str), "" "");
",1,unused,2095,unused,"	result[i].statDone = 0;
	str = dp->d_name;
	len = strlen(str);
	result[i].real = XtMalloc((unsigned) (len + 2));
	(void) strcat(strcpy(result[i].real, str), "" "");
",unused,vimartful-src2Fgui_at_fs.c
"	    SFtextPos = XawTextGetInsertionPoint(selFileField);
	}
	else
	{
	    strcpy(SFcurrentPath, SFstartDir);
",1,unused,2637,unused,"	    SFtextPos = XawTextGetInsertionPoint(selFileField);
	}
	else
	{
	    strcpy(SFcurrentPath, SFstartDir);
",unused,vimartful-src2Fgui_at_fs.c
"    else
#endif
    if ((SFtextBuffer[0] == '/') || (SFtextBuffer[0] == '~'))
    {
	(void) strcpy(SFcurrentPath, SFtextBuffer);
",1,unused,2647,unused,"    else
#endif
    if ((SFtextBuffer[0] == '/') || (SFtextBuffer[0] == '~'))
    {
	(void) strcpy(SFcurrentPath, SFtextBuffer);
",unused,vimartful-src2Fgui_at_fs.c
"	SFtextPos = XawTextGetInsertionPoint(selFileField);
    }
    else
    {
	(void) strcat(strcpy(SFcurrentPath, SFstartDir), SFtextBuffer);
",1,unused,2652,unused,"	SFtextPos = XawTextGetInsertionPoint(selFileField);
    }
    else
    {
	(void) strcat(strcpy(SFcurrentPath, SFstartDir), SFtextBuffer);
",unused,vimartful-src2Fgui_at_fs.c
"	SFtextPos = XawTextGetInsertionPoint(selFileField);
    }
    else
    {
	(void) strcat(strcpy(SFcurrentPath, SFstartDir), SFtextBuffer);
",1,unused,2652,unused,"	SFtextPos = XawTextGetInsertionPoint(selFileField);
    }
    else
    {
	(void) strcat(strcpy(SFcurrentPath, SFstartDir), SFtextBuffer);
",unused,vimartful-src2Fgui_at_fs.c
"
    XtVaSetValues(selFile, XtNx, x, XtNy, y, NULL);
    XtMapWidget(selFile);

    (void)strcat(SFstartDir, ""/"");
",1,unused,2750,unused,"
    XtVaSetValues(selFile, XtNx, x, XtNy, y, NULL);
    XtMapWidget(selFile);

    (void)strcat(SFstartDir, ""/"");
",unused,vimartful-src2Fgui_at_fs.c
"    XtVaSetValues(selFile, XtNx, x, XtNy, y, NULL);
    XtMapWidget(selFile);

    (void)strcat(SFstartDir, ""/"");
    (void)strcpy(SFcurrentDir, SFstartDir);
",1,unused,2751,unused,"    XtVaSetValues(selFile, XtNx, x, XtNy, y, NULL);
    XtMapWidget(selFile);

    (void)strcat(SFstartDir, ""/"");
    (void)strcpy(SFcurrentDir, SFstartDir);
",unused,vimartful-src2Fgui_at_fs.c
"    if (init_path)
    {
	if (init_path[0] == '/')
	{
	    (void)strcpy(SFcurrentPath, init_path);
",1,unused,2757,unused,"    if (init_path)
    {
	if (init_path[0] == '/')
	{
	    (void)strcpy(SFcurrentPath, init_path);
",unused,vimartful-src2Fgui_at_fs.c
"		SFsetText(&(SFcurrentPath[strlen(SFstartDir)]));
	}
	else
	{
	    (void)strcat(strcpy(SFcurrentPath, SFstartDir), init_path);
",1,unused,2765,unused,"		SFsetText(&(SFcurrentPath[strlen(SFstartDir)]));
	}
	else
	{
	    (void)strcat(strcpy(SFcurrentPath, SFstartDir), init_path);
",unused,vimartful-src2Fgui_at_fs.c
"		SFsetText(&(SFcurrentPath[strlen(SFstartDir)]));
	}
	else
	{
	    (void)strcat(strcpy(SFcurrentPath, SFstartDir), init_path);
",1,unused,2765,unused,"		SFsetText(&(SFcurrentPath[strlen(SFstartDir)]));
	}
	else
	{
	    (void)strcat(strcpy(SFcurrentPath, SFstartDir), init_path);
",unused,vimartful-src2Fgui_at_fs.c
"	    SFsetText(&(SFcurrentPath[strlen(SFstartDir)]));
	}
    }
    else
	(void)strcpy(SFcurrentPath, SFstartDir);
",1,unused,2770,unused,"	    SFsetText(&(SFcurrentPath[strlen(SFstartDir)]));
	}
    }
    else
	(void)strcpy(SFcurrentPath, SFstartDir);
",unused,vimartful-src2Fgui_at_fs.c
"
    pname = vim_strnsave(name, STRLEN(name) + strlen(""-pullright""));
    if (pname != NULL)
    {
	strcat((char *)pname, ""-pullright"");
",1,unused,1141,unused,"
    pname = vim_strnsave(name, STRLEN(name) + strlen(""-pullright""));
    if (pname != NULL)
    {
	strcat((char *)pname, ""-pullright"");
",unused,vimartful-src2Fgui_athena.c
"    mch_print_start_line(TRUE, page_line);

    /* Leave two spaces between the number and the text; depends on
     * PRINT_NUMBER_WIDTH. */
    sprintf((char *)tbuf, ""%6ld"", (long)lnum);
",1,unused,399,unused,"    mch_print_start_line(TRUE, page_line);

    /* Leave two spaces between the number and the text; depends on
     * PRINT_NUMBER_WIDTH. */
    sprintf((char *)tbuf, ""%6ld"", (long)lnum);
",unused,vimartful-src2Fhardcopy.c
"	curwin->w_botline = tmp_botline;
    }
    else
#endif
	sprintf((char *)tbuf, _(""Page %d""), pagenum);
",1,unused,518,unused,"	curwin->w_botline = tmp_botline;
    }
    else
#endif
	sprintf((char *)tbuf, _(""Page %d""), pagenum);
",unused,vimartful-src2Fhardcopy.c
"		    ui_breakcheck();
		    if (got_int || settings.user_abort)
			goto print_fail;

		    sprintf((char *)IObuff, _(""Printing page %d (%d%%)""),
",1,unused,751,unused,"		    ui_breakcheck();
		    if (got_int || settings.user_abort)
			goto print_fail;

		    sprintf((char *)IObuff, _(""Printing page %d (%d%%)""),
",unused,vimartful-src2Fhardcopy.c
"		    if (!mch_print_begin_page(IObuff))
			goto print_fail;

		    if (settings.n_collated_copies > 1)
			sprintf((char *)IObuff + STRLEN(IObuff),
",1,unused,762,unused,"		    if (!mch_print_begin_page(IObuff))
			goto print_fail;

		    if (settings.n_collated_copies > 1)
			sprintf((char *)IObuff + STRLEN(IObuff),
",unused,vimartful-src2Fhardcopy.c
"
print_fail:
    if (got_int || settings.user_abort)
    {
	sprintf((char *)IObuff, ""%s"", _(""Printing aborted""));
",1,unused,829,unused,"
print_fail:
    if (got_int || settings.user_abort)
    {
	sprintf((char *)IObuff, ""%s"", _(""Printing aborted""));
",unused,vimartful-src2Fhardcopy.c
" */
    static void
prt_write_int(int i)
{
    sprintf((char *)prt_line_buffer, ""%d "", i);
",1,unused,1518,unused," */
    static void
prt_write_int(int i)
{
    sprintf((char *)prt_line_buffer, ""%d "", i);
",unused,vimartful-src2Fhardcopy.c
" */
    static void
prt_write_boolean(int b)
{
    sprintf((char *)prt_line_buffer, ""%s "", (b ? ""T"" : ""F""));
",1,unused,1528,unused," */
    static void
prt_write_boolean(int b)
{
    sprintf((char *)prt_line_buffer, ""%s "", (b ? ""T"" : ""F""));
",unused,vimartful-src2Fhardcopy.c
"			  ""/_%s /VIM-%s /%s ref\n"", new_name, encoding, font);
    prt_write_file(prt_line_buffer);
#ifdef FEAT_MBYTE
    if (prt_out_mbyte)
	sprintf((char *)prt_line_buffer, ""/%s %d %f /_%s sffs\n"",
",1,unused,1547,unused,"			  ""/_%s /VIM-%s /%s ref\n"", new_name, encoding, font);
    prt_write_file(prt_line_buffer);
#ifdef FEAT_MBYTE
    if (prt_out_mbyte)
	sprintf((char *)prt_line_buffer, ""/%s %d %f /_%s sffs\n"",
",unused,vimartful-src2Fhardcopy.c
"    int     fraction;

    prt_real_bits(val, prec, &integer, &fraction);
    /* Emit integer part */
    sprintf((char *)prt_line_buffer, ""%d"", integer);
",1,unused,1623,unused,"    int     fraction;

    prt_real_bits(val, prec, &integer, &fraction);
    /* Emit integer part */
    sprintf((char *)prt_line_buffer, ""%d"", integer);
",unused,vimartful-src2Fhardcopy.c
"	    prec--;
	    fraction /= 10;
	}
	/* Emit fraction left padded with zeros */
	sprintf((char *)prt_line_buffer, "".%0*d"", prec, fraction);
",1,unused,1635,unused,"	    prec--;
	    fraction /= 10;
	}
	/* Emit fraction left padded with zeros */
	sprintf((char *)prt_line_buffer, "".%0*d"", prec, fraction);
",unused,vimartful-src2Fhardcopy.c
"	/* Emit fraction left padded with zeros */
	sprintf((char *)prt_line_buffer, "".%0*d"", prec, fraction);
	prt_write_file(prt_line_buffer);
    }
    sprintf((char *)prt_line_buffer, "" "");
",1,unused,1638,unused,"	/* Emit fraction left padded with zeros */
	sprintf((char *)prt_line_buffer, "".%0*d"", prec, fraction);
	prt_write_file(prt_line_buffer);
    }
    sprintf((char *)prt_line_buffer, "" "");
",unused,vimartful-src2Fhardcopy.c
"    vim_snprintf((char *)prt_line_buffer, sizeof(prt_line_buffer),
								""/%s "", name);
    prt_write_file(prt_line_buffer);
    prt_write_real(value, prec);
    sprintf((char *)prt_line_buffer, ""d\n"");
",1,unused,1652,unused,"    vim_snprintf((char *)prt_line_buffer, sizeof(prt_line_buffer),
								""/%s "", name);
    prt_write_file(prt_line_buffer);
    prt_write_real(value, prec);
    sprintf((char *)prt_line_buffer, ""d\n"");
",unused,vimartful-src2Fhardcopy.c
"    prt_write_file(prt_line_buffer);

    for (i = 0; i < count; i++)
    {
	sprintf((char *)prt_line_buffer, "" %d"", ints[i]);
",1,unused,2095,unused,"    prt_write_file(prt_line_buffer);

    for (i = 0; i < count; i++)
    {
	sprintf((char *)prt_line_buffer, "" %d"", ints[i]);
",unused,vimartful-src2Fhardcopy.c
"     */
    if (!(duplex || collate || color || (num_copies > 1)))
	return;

    sprintf((char *)prt_line_buffer, ""%%%%Requirements:"");
",1,unused,2147,unused,"     */
    if (!(duplex || collate || color || (num_copies > 1)))
	return;

    sprintf((char *)prt_line_buffer, ""%%%%Requirements:"");
",unused,vimartful-src2Fhardcopy.c
"    if (num_copies > 1)
    {
	prt_write_string("" numcopies("");
	/* Note: no space wanted so don't use prt_write_int() */
	sprintf((char *)prt_line_buffer, ""%d"", num_copies);
",1,unused,2164,unused,"    if (num_copies > 1)
    {
	prt_write_string("" numcopies("");
	/* Note: no space wanted so don't use prt_write_int() */
	sprintf((char *)prt_line_buffer, ""%d"", num_copies);
",unused,vimartful-src2Fhardcopy.c
"		case ')':  ga_append(&prt_ps_buffer, IF_EB(')', 0051)); break;
		case '\\': ga_append(&prt_ps_buffer, IF_EB('\\', 0134)); break;

		default:
			   sprintf((char *)ch_buff, ""%03o"", (unsigned int)ch);
",1,unused,3565,unused,"		case ')':  ga_append(&prt_ps_buffer, IF_EB(')', 0051)); break;
		case '\\': ga_append(&prt_ps_buffer, IF_EB('\\', 0134)); break;

		default:
			   sprintf((char *)ch_buff, ""%03o"", (unsigned int)ch);
",unused,vimartful-src2Fhardcopy.c
"    char *buf = (char *)alloc((unsigned)strlen(stat_emsg) + MAXPATHL + 10);

    if (buf != NULL)
    {
	(void)sprintf(buf, stat_emsg, fname, errno);
",1,unused,486,unused,"    char *buf = (char *)alloc((unsigned)strlen(stat_emsg) + MAXPATHL + 10);

    if (buf != NULL)
    {
	(void)sprintf(buf, stat_emsg, fname, errno);
",unused,vimartful-src2Fif_cscope.c
"	    if (fname[0] == '\0')
		break;
	}
	if (fname[0] == '\0')
	    (void)sprintf(fname2, ""/%s"", CSCOPE_DBFILE);
",1,unused,574,unused,"	    if (fname[0] == '\0')
		break;
	}
	if (fname[0] == '\0')
	    (void)sprintf(fname2, ""/%s"", CSCOPE_DBFILE);
",unused,vimartful-src2Fif_cscope.c
"	}
	if (fname[0] == '\0')
	    (void)sprintf(fname2, ""/%s"", CSCOPE_DBFILE);
	else
	    (void)sprintf(fname2, ""%s/%s"", fname, CSCOPE_DBFILE);
",1,unused,576,unused,"	}
	if (fname[0] == '\0')
	    (void)sprintf(fname2, ""/%s"", CSCOPE_DBFILE);
	else
	    (void)sprintf(fname2, ""%s/%s"", fname, CSCOPE_DBFILE);
",unused,vimartful-src2Fif_cscope.c
"
    if ((cmd = (char *)alloc((unsigned)(strlen(pat) + 2))) == NULL)
	return NULL;

    (void)sprintf(cmd, ""%d%s"", search, pat);
",1,unused,790,unused,"
    if ((cmd = (char *)alloc((unsigned)(strlen(pat) + 2))) == NULL)
	return NULL;

    (void)sprintf(cmd, ""%d%s"", search, pat);
",unused,vimartful-src2Fif_cscope.c
"	}

	/* run the cscope command; is there execl for non-unix systems? */
#if defined(UNIX)
	(void)sprintf(cmd, ""exec %s -dl -f %s"", prog, csinfo[i].fname);
",1,unused,935,unused,"	}

	/* run the cscope command; is there execl for non-unix systems? */
#if defined(UNIX)
	(void)sprintf(cmd, ""exec %s -dl -f %s"", prog, csinfo[i].fname);
",unused,vimartful-src2Fif_cscope.c
"	(void)sprintf(cmd, ""%s -dl -f %s"", prog, csinfo[i].fname);
#endif
	if (csinfo[i].ppath != NULL)
	{
	    (void)strcat(cmd, "" -P"");
",1,unused,942,unused,"	(void)sprintf(cmd, ""%s -dl -f %s"", prog, csinfo[i].fname);
#endif
	if (csinfo[i].ppath != NULL)
	{
	    (void)strcat(cmd, "" -P"");
",unused,vimartful-src2Fif_cscope.c
"#endif
	if (csinfo[i].ppath != NULL)
	{
	    (void)strcat(cmd, "" -P"");
	    (void)strcat(cmd, csinfo[i].ppath);
",1,unused,943,unused,"#endif
	if (csinfo[i].ppath != NULL)
	{
	    (void)strcat(cmd, "" -P"");
	    (void)strcat(cmd, csinfo[i].ppath);
",unused,vimartful-src2Fif_cscope.c
"	    (void)strcat(cmd, csinfo[i].ppath);
	}
	if (csinfo[i].flags != NULL)
	{
	    (void)strcat(cmd, "" "");
",1,unused,947,unused,"	    (void)strcat(cmd, csinfo[i].ppath);
	}
	if (csinfo[i].flags != NULL)
	{
	    (void)strcat(cmd, "" "");
",unused,vimartful-src2Fif_cscope.c
"	}
	if (csinfo[i].flags != NULL)
	{
	    (void)strcat(cmd, "" "");
	    (void)strcat(cmd, csinfo[i].flags);
",1,unused,948,unused,"	}
	if (csinfo[i].flags != NULL)
	{
	    (void)strcat(cmd, "" "");
	    (void)strcat(cmd, csinfo[i].flags);
",unused,vimartful-src2Fif_cscope.c
"
	    /* strlen will be enough because we use chars */
	    if (buf != NULL)
	    {
		sprintf(buf, nf, *qfpos, *(qfpos-1));
",1,unused,1144,unused,"
	    /* strlen will be enough because we use chars */
	    if (buf != NULL)
	    {
		sprintf(buf, nf, *qfpos, *(qfpos-1));
",unused,vimartful-src2Fif_cscope.c
"	if (buf == NULL)
	    (void)EMSG(nf);
	else
	{
	    sprintf(buf, nf, opt, pat);
",1,unused,1217,unused,"	if (buf == NULL)
	    (void)EMSG(nf);
	else
	{
	    sprintf(buf, nf, opt, pat);
",unused,vimartful-src2Fif_cscope.c
"
    if ((csinfo[i].fname = (char *)alloc((unsigned)strlen(fname)+1)) == NULL)
	return -1;

    (void)strcpy(csinfo[i].fname, (const char *)fname);
",1,unused,1479,unused,"
    if ((csinfo[i].fname = (char *)alloc((unsigned)strlen(fname)+1)) == NULL)
	return -1;

    (void)strcpy(csinfo[i].fname, (const char *)fname);
",unused,vimartful-src2Fif_cscope.c
"	    vim_free(csinfo[i].fname);
	    csinfo[i].fname = NULL;
	    return -1;
	}
	(void)strcpy(csinfo[i].ppath, (const char *)ppath);
",1,unused,1489,unused,"	    vim_free(csinfo[i].fname);
	    csinfo[i].fname = NULL;
	    return -1;
	}
	(void)strcpy(csinfo[i].ppath, (const char *)ppath);
",unused,vimartful-src2Fif_cscope.c
"	    csinfo[i].fname = NULL;
	    csinfo[i].ppath = NULL;
	    return -1;
	}
	(void)strcpy(csinfo[i].flags, (const char *)flags);
",1,unused,1503,unused,"	    csinfo[i].fname = NULL;
	    csinfo[i].ppath = NULL;
	    return -1;
	}
	(void)strcpy(csinfo[i].flags, (const char *)flags);
",unused,vimartful-src2Fif_cscope.c
"	amt = (int)(strlen(fname) + strlen(slno) + strlen(tagstr) + strlen(search)+6);
	if ((buf = (char *)alloc(amt)) == NULL)
	    return NULL;

	(void)sprintf(buf, ""%s\t%s\t%s;\""\t%s"", tagstr, fname, slno, search);
",1,unused,1667,unused,"	amt = (int)(strlen(fname) + strlen(slno) + strlen(tagstr) + strlen(search)+6);
	if ((buf = (char *)alloc(amt)) == NULL)
	    return NULL;

	(void)sprintf(buf, ""%s\t%s\t%s;\""\t%s"", tagstr, fname, slno, search);
",unused,vimartful-src2Fif_cscope.c
"	amt = (int)(strlen(fname) + strlen(slno) + strlen(tagstr) + 5);
	if ((buf = (char *)alloc(amt)) == NULL)
	    return NULL;

	(void)sprintf(buf, ""%s\t%s\t%s;\"""", tagstr, fname, slno);
",1,unused,1675,unused,"	amt = (int)(strlen(fname) + strlen(slno) + strlen(tagstr) + 5);
	if ((buf = (char *)alloc(amt)) == NULL)
	    return NULL;

	(void)sprintf(buf, ""%s\t%s\t%s;\"""", tagstr, fname, slno);
",unused,vimartful-src2Fif_cscope.c
"	   if (context == NULL)
	       continue;

	   if (strcmp(cntx, ""<global>"")==0)
	       strcpy(context, ""<<global>>"");
",1,unused,1854,unused,"	   if (context == NULL)
	       continue;

	   if (strcmp(cntx, ""<global>"")==0)
	       strcpy(context, ""<<global>>"");
",unused,vimartful-src2Fif_cscope.c
"
	   if (strcmp(cntx, ""<global>"")==0)
	       strcpy(context, ""<<global>>"");
	   else
	       sprintf(context, ""<<%s>>"", cntx);
",1,unused,1856,unused,"
	   if (strcmp(cntx, ""<global>"")==0)
	       strcpy(context, ""<<global>>"");
	   else
	       sprintf(context, ""<<%s>>"", cntx);
",unused,vimartful-src2Fif_cscope.c
"
    if ((tbuf = (char *)alloc((unsigned)strlen(matches[0]) + 1)) == NULL)
	return;

    strcpy(tbuf, matches[0]);
",1,unused,2009,unused,"
    if ((tbuf = (char *)alloc((unsigned)strlen(matches[0]) + 1)) == NULL)
	return;

    strcpy(tbuf, matches[0]);
",unused,vimartful-src2Fif_cscope.c
"    buf = (char *)alloc(newsize);
    if (buf != NULL)
    {
	bufsize = newsize;
	(void)sprintf(buf, cstag_msg, ptag);
",1,unused,2022,unused,"    buf = (char *)alloc(newsize);
    if (buf != NULL)
    {
	bufsize = newsize;
	(void)sprintf(buf, cstag_msg, ptag);
",unused,vimartful-src2Fif_cscope.c
"	 * directly, but that's too much of a hassle
	 */
	if ((tbuf = (char *)alloc((unsigned)strlen(matches[idx]) + 1)) == NULL)
	    continue;
	(void)strcpy(tbuf, matches[idx]);
",1,unused,2043,unused,"	 * directly, but that's too much of a hassle
	 */
	if ((tbuf = (char *)alloc((unsigned)strlen(matches[idx]) + 1)) == NULL)
	    continue;
	(void)strcpy(tbuf, matches[idx]);
",unused,vimartful-src2Fif_cscope.c
"	}
	if (buf != NULL)
	{
	    /* csfmt_str = ""%4d %6s  ""; */
	    (void)sprintf(buf, csfmt_str, num, lno);
",1,unused,2073,unused,"	}
	if (buf != NULL)
	{
	    /* csfmt_str = ""%4d %6s  ""; */
	    (void)sprintf(buf, csfmt_str, num, lno);
",unused,vimartful-src2Fif_cscope.c
"		bufsize = newsize;
	}
	if (buf != NULL)
	{
	    (void)sprintf(buf, cntxformat, context);
",1,unused,2099,unused,"		bufsize = newsize;
	}
	if (buf != NULL)
	{
	    (void)sprintf(buf, cntxformat, context);
",unused,vimartful-src2Fif_cscope.c
"		/* don't use smsg_attr() because we want to display the
		 * connection number in the same line as
		 * ""Added cscope database...""
		 */
		sprintf(buf, "" (#%d)"", i);
",1,unused,2401,unused,"		/* don't use smsg_attr() because we want to display the
		 * connection number in the same line as
		 * ""Added cscope database...""
		 */
		sprintf(buf, "" (#%d)"", i);
",unused,vimartful-src2Fif_cscope.c
"#endif
       )
    {
	if ((fullname = (char *)alloc(len)) != NULL)
	    (void)sprintf(fullname, ""%s/%s"", csinfo[i].ppath, name);
",1,unused,2469,unused,"#endif
       )
    {
	if ((fullname = (char *)alloc(len)) != NULL)
	    (void)sprintf(fullname, ""%s/%s"", csinfo[i].ppath, name);
",unused,vimartful-src2Fif_cscope.c
"	    {
		res = -10;
		continue;
	    }
	    sprintf((char *)p, ""%s%d"", name, i++);
",1,unused,244,unused,"	    {
		res = -10;
		continue;
	    }
	    sprintf((char *)p, ""%s%d"", name, i++);
",unused,vimartful-src2Fif_xcmdsrv.c
"	    return -1;
	}
	(void)LookupName(dpy, name, /*delete=*/TRUE, NULL);
    }
    sprintf((char *)propInfo, ""%x %.*s"", (int_u)commWindow,
",1,unused,303,unused,"	    return -1;
	}
	(void)LookupName(dpy, name, /*delete=*/TRUE, NULL);
    }
    sprintf((char *)propInfo, ""%x %.*s"", (int_u)commWindow,
",unused,vimartful-src2Fif_xcmdsrv.c
"    if (serverName != NULL)
    {
	/* Reinsert name if we was already registered */
	(void)LookupName(dpy, serverName, /*delete=*/TRUE, NULL);
	sprintf((char *)propInfo, ""%x %.*s"",
",1,unused,354,unused,"    if (serverName != NULL)
    {
	/* Reinsert name if we was already registered */
	(void)LookupName(dpy, serverName, /*delete=*/TRUE, NULL);
	sprintf((char *)propInfo, ""%x %.*s"",
",unused,vimartful-src2Fif_xcmdsrv.c
"#endif
    property = (char_u *)alloc((unsigned)length + 30);

#ifdef FEAT_MBYTE
    sprintf((char *)property, ""%c%c%c-n %s%c-E %s%c-s %s"",
",1,unused,471,unused,"#endif
    property = (char_u *)alloc((unsigned)length + 30);

#ifdef FEAT_MBYTE
    sprintf((char *)property, ""%c%c%c-n %s%c-E %s%c-s %s"",
",unused,vimartful-src2Fif_xcmdsrv.c
"    if (name == loosename)
	vim_free(loosename);
    /* Add a back reference to our comm window */
    serial++;
    sprintf((char *)property + length, ""%c-r %x %d"",
",1,unused,481,unused,"    if (name == loosename)
	vim_free(loosename);
    /* Add a back reference to our comm window */
    serial++;
    sprintf((char *)property + length, ""%c-r %x %d"",
",unused,vimartful-src2Fif_xcmdsrv.c
"#endif
    if ((property = (char_u *)alloc((unsigned)length + 30)) != NULL)
    {
#ifdef FEAT_MBYTE
	sprintf((char *)property, ""%cn%c-E %s%c-n %s%c-w %x"",
",1,unused,784,unused,"#endif
    if ((property = (char_u *)alloc((unsigned)length + 30)) != NULL)
    {
#ifdef FEAT_MBYTE
	sprintf((char *)property, ""%cn%c-E %s%c-n %s%c-w %x"",
",unused,vimartful-src2Fif_xcmdsrv.c
"			/* Initialize the result property. */
			ga_init2(&reply, 1, 100);
#ifdef FEAT_MBYTE
			(void)ga_grow(&reply, 50 + STRLEN(p_enc));
			sprintf(reply.ga_data, ""%cr%c-E %s%c-s %s%c-r "",
",1,unused,1350,unused,"			/* Initialize the result property. */
			ga_init2(&reply, 1, 100);
#ifdef FEAT_MBYTE
			(void)ga_grow(&reply, 50 + STRLEN(p_enc));
			sprintf(reply.ga_data, ""%cr%c-E %s%c-s %s%c-r "",
",unused,vimartful-src2Fif_xcmdsrv.c
"#ifdef FEAT_AUTOCMD
	    {
		char_u	winstr[30];

		sprintf((char *)winstr, ""0x%x"", (unsigned int)win);
",1,unused,1496,unused,"#ifdef FEAT_AUTOCMD
	    {
		char_u	winstr[30];

		sprintf((char *)winstr, ""0x%x"", (unsigned int)win);
",unused,vimartful-src2Fif_xcmdsrv.c
"			    a = argv[0];
			p = alloc((unsigned)(STRLEN(a) + 4));
			if (p == NULL)
			    mch_exit(2);
			sprintf((char *)p, ""so %s"", a);
",1,unused,2246,unused,"			    a = argv[0];
			p = alloc((unsigned)(STRLEN(a) + 4));
			if (p == NULL)
			    mch_exit(2);
			sprintf((char *)p, ""so %s"", a);
",unused,vimartful-src2Fmain.c
"    {
	p = alloc((unsigned)STRLEN(parmp->commands[0]) + 3);
	if (p != NULL)
	{
	    sprintf((char *)p, "":%s\r"", parmp->commands[0]);
",1,unused,2472,unused,"    {
	p = alloc((unsigned)STRLEN(parmp->commands[0]) + 3);
	if (p != NULL)
	{
	    sprintf((char *)p, "":%s\r"", parmp->commands[0]);
",unused,vimartful-src2Fmain.c
"	}
	msg_putchar('\n');
	if (!got_int)
	{
	    sprintf((char *)IObuff, "" %c %6ld %4d "", c, p->lnum, p->col);
",1,unused,780,unused,"	}
	msg_putchar('\n');
	if (!got_int)
	{
	    sprintf((char *)IObuff, "" %c %6ld %4d "", c, p->lnum, p->col);
",unused,vimartful-src2Fmark.c
"	    {
		vim_free(name);
		break;
	    }
	    sprintf((char *)IObuff, ""%c %2d %5ld %4d "",
",1,unused,912,unused,"	    {
		vim_free(name);
		break;
	    }
	    sprintf((char *)IObuff, ""%c %2d %5ld %4d "",
",unused,vimartful-src2Fmark.c
"	{
	    msg_putchar('\n');
	    if (got_int)
		break;
	    sprintf((char *)IObuff, ""%c %3d %5ld %4d "",
",1,unused,958,unused,"	{
	    msg_putchar('\n');
	    if (got_int)
		break;
	    sprintf((char *)IObuff, ""%c %3d %5ld %4d "",
",unused,vimartful-src2Fmark.c
"		rlen += 2;
	    }
	    clen = utf_ptr2len(line + i);
	}
	sprintf((char *)IObuff + rlen, ""%02x "",
",1,unused,3654,unused,"		rlen += 2;
	    }
	    clen = utf_ptr2len(line + i);
	}
	sprintf((char *)IObuff + rlen, ""%02x "",
",unused,vimartful-src2Fmbyte.c
"	return FALSE;

    if (gui.rsrc_input_method != NULL && *gui.rsrc_input_method != NUL)
    {
	strcpy(tmp, gui.rsrc_input_method);
",1,unused,5807,unused,"	return FALSE;

    if (gui.rsrc_input_method != NULL && *gui.rsrc_input_method != NUL)
    {
	strcpy(tmp, gui.rsrc_input_method);
",unused,vimartful-src2Fmbyte.c
"	    *end = NUL;

	    if (strlen(s) <= IMLEN_MAX)
	    {
		strcpy(buf, ""@im="");
",1,unused,5821,unused,"	    *end = NUL;

	    if (strlen(s) <= IMLEN_MAX)
	    {
		strcpy(buf, ""@im="");
",unused,vimartful-src2Fmbyte.c
"
	    if (strlen(s) <= IMLEN_MAX)
	    {
		strcpy(buf, ""@im="");
		strcat(buf, s);
",1,unused,5822,unused,"
	    if (strlen(s) <= IMLEN_MAX)
	    {
		strcpy(buf, ""@im="");
		strcat(buf, s);
",unused,vimartful-src2Fmbyte.c
"	return FALSE;
    }

    found = False;
    strcpy(tmp, gui.rsrc_preedit_type_name);
",1,unused,5874,unused,"	return FALSE;
    }

    found = False;
    strcpy(tmp, gui.rsrc_preedit_type_name);
",unused,vimartful-src2Fmbyte.c
"    {
	p = (char_u *)_(""Error detected while processing %s:"");
	Buf = alloc((unsigned)(STRLEN(sourcing_name) + STRLEN(p)));
	if (Buf != NULL)
	    sprintf((char *)Buf, (char *)p, sourcing_name);
",1,unused,455,unused,"    {
	p = (char_u *)_(""Error detected while processing %s:"");
	Buf = alloc((unsigned)(STRLEN(sourcing_name) + STRLEN(p)));
	if (Buf != NULL)
	    sprintf((char *)Buf, (char *)p, sourcing_name);
",unused,vimartful-src2Fmessage.c
"    {
	p = (char_u *)_(""line %4ld:"");
	Buf = alloc((unsigned)(STRLEN(p) + 20));
	if (Buf != NULL)
	    sprintf((char *)Buf, (char *)p, (long)sourcing_lnum);
",1,unused,480,unused,"    {
	p = (char_u *)_(""line %4ld:"");
	Buf = alloc((unsigned)(STRLEN(p) + 20));
	if (Buf != NULL)
	    sprintf((char *)Buf, (char *)p, (long)sourcing_lnum);
",unused,vimartful-src2Fmessage.c
"msg_outnum(long n)
{
    char_u	buf[20];

    sprintf((char *)buf, ""%ld"", n);
",1,unused,1388,unused,"msg_outnum(long n)
{
    char_u	buf[20];

    sprintf((char *)buf, ""%ld"", n);
",unused,vimartful-src2Fmessage.c
"			f[f_l++] = fmt_spec;
			f[f_l++] = '\0';

			if (fmt_spec == 'p')
			    str_arg_l += sprintf(tmp + str_arg_l, f, ptr_arg);
",1,unused,4710,unused,"			f[f_l++] = fmt_spec;
			f[f_l++] = '\0';

			if (fmt_spec == 'p')
			    str_arg_l += sprintf(tmp + str_arg_l, f, ptr_arg);
",unused,vimartful-src2Fmessage.c
"			    /* signed */
			    switch (length_modifier)
			    {
			    case '\0':
			    case 'h': str_arg_l += sprintf(
",1,unused,4733,unused,"			    /* signed */
			    switch (length_modifier)
			    {
			    case '\0':
			    case 'h': str_arg_l += sprintf(
",unused,vimartful-src2Fmessage.c
"			    case '\0':
			    case 'h': str_arg_l += sprintf(
						 tmp + str_arg_l, f, int_arg);
				      break;
			    case 'l': str_arg_l += sprintf(
",1,unused,4736,unused,"			    case '\0':
			    case 'h': str_arg_l += sprintf(
						 tmp + str_arg_l, f, int_arg);
				      break;
			    case 'l': str_arg_l += sprintf(
",unused,vimartful-src2Fmessage.c
"			    case 'l': str_arg_l += sprintf(
						tmp + str_arg_l, f, long_arg);
				      break;
# ifdef FEAT_NUM64
			    case 'L': str_arg_l += sprintf(
",1,unused,4740,unused,"			    case 'l': str_arg_l += sprintf(
						tmp + str_arg_l, f, long_arg);
				      break;
# ifdef FEAT_NUM64
			    case 'L': str_arg_l += sprintf(
",unused,vimartful-src2Fmessage.c
"			    /* unsigned */
			    switch (length_modifier)
			    {
			    case '\0':
			    case 'h': str_arg_l += sprintf(
",1,unused,4752,unused,"			    /* unsigned */
			    switch (length_modifier)
			    {
			    case '\0':
			    case 'h': str_arg_l += sprintf(
",unused,vimartful-src2Fmessage.c
"			    case '\0':
			    case 'h': str_arg_l += sprintf(
						tmp + str_arg_l, f, uint_arg);
				      break;
			    case 'l': str_arg_l += sprintf(
",1,unused,4755,unused,"			    case '\0':
			    case 'h': str_arg_l += sprintf(
						tmp + str_arg_l, f, uint_arg);
				      break;
			    case 'l': str_arg_l += sprintf(
",unused,vimartful-src2Fmessage.c
"			    case 'l': str_arg_l += sprintf(
					       tmp + str_arg_l, f, ulong_arg);
				      break;
# ifdef FEAT_NUM64
			    case 'L': str_arg_l += sprintf(
",1,unused,4759,unused,"			    case 'l': str_arg_l += sprintf(
					       tmp + str_arg_l, f, ulong_arg);
				      break;
# ifdef FEAT_NUM64
			    case 'L': str_arg_l += sprintf(
",unused,vimartful-src2Fmessage.c
"								&& abs_f > 1.0)
				    max_prec -= (size_t)log10(abs_f);
				if (precision > max_prec)
				    precision = max_prec;
				l += sprintf(format + l, "".%d"", (int)precision);
",1,unused,4900,unused,"								&& abs_f > 1.0)
				    max_prec -= (size_t)log10(abs_f);
				if (precision > max_prec)
				    precision = max_prec;
				l += sprintf(format + l, "".%d"", (int)precision);
",unused,vimartful-src2Fmessage.c
"			    }
			    format[l] = fmt_spec == 'F' ? 'f' : fmt_spec;
			    format[l + 1] = NUL;

			    str_arg_l = sprintf(tmp, format, f);
",1,unused,4905,unused,"			    }
			    format[l] = fmt_spec == 'F' ? 'f' : fmt_spec;
			    format[l + 1] = NUL;

			    str_arg_l = sprintf(tmp, format, f);
",unused,vimartful-src2Fmessage.c
"	    /* success, login */
	    vim_snprintf(buf, sizeof(buf), ""AUTH %s\n"", password);
	    nb_send(buf, ""netbeans_connect"");

	    sprintf(buf, ""0:version=0 \""%s\""\n"", ExtEdProtocolVersion);
",1,unused,231,unused,"	    /* success, login */
	    vim_snprintf(buf, sizeof(buf), ""AUTH %s\n"", password);
	    nb_send(buf, ""netbeans_connect"");

	    sprintf(buf, ""0:version=0 \""%s\""\n"", ExtEdProtocolVersion);
",unused,vimartful-src2Fnetbeans.c
"	    continue;
	if (netbeansForcedQuit)
	{
	    /* mark as unmodified so NetBeans won't put up dialog on ""killed"" */
	    sprintf(buf, ""%d:unmodified=%d\n"", i, r_cmdno);
",1,unused,749,unused,"	    continue;
	if (netbeansForcedQuit)
	{
	    /* mark as unmodified so NetBeans won't put up dialog on ""killed"" */
	    sprintf(buf, ""%d:unmodified=%d\n"", i, r_cmdno);
",unused,vimartful-src2Fnetbeans.c
"	    sprintf(buf, ""%d:unmodified=%d\n"", i, r_cmdno);
	    nbdebug((""EVT: %s"", buf));
	    nb_send(buf, ""netbeans_end"");
	}
	sprintf(buf, ""%d:killed=%d\n"", i, r_cmdno);
",1,unused,753,unused,"	    sprintf(buf, ""%d:unmodified=%d\n"", i, r_cmdno);
	    nbdebug((""EVT: %s"", buf));
	    nb_send(buf, ""netbeans_end"");
	}
	sprintf(buf, ""%d:killed=%d\n"", i, r_cmdno);
",unused,vimartful-src2Fnetbeans.c
"    /* Avoid printing an annoying error message. */
    if (!NETBEANS_OPEN)
	return;

    sprintf(reply, ""%d\n"", cmdno);
",1,unused,787,unused,"    /* Avoid printing an annoying error message. */
    if (!NETBEANS_OPEN)
	return;

    sprintf(reply, ""%d\n"", cmdno);
",unused,vimartful-src2Fnetbeans.c
"
    nbdebug((""REP %d: %s\n"", cmdno, (char *)result));

    reply = alloc((unsigned)STRLEN(result) + 32);
    sprintf((char *)reply, ""%d %s\n"", cmdno, (char *)result);
",1,unused,804,unused,"
    nbdebug((""REP %d: %s\n"", cmdno, (char *)result));

    reply = alloc((unsigned)STRLEN(result) + 32);
    sprintf((char *)reply, ""%d %s\n"", cmdno, (char *)result);
",unused,vimartful-src2Fnetbeans.c
"    char reply[32];

    nbdebug((""REP %d: %ld\n"", cmdno, result));

    sprintf(reply, ""%d %ld\n"", cmdno, result);
",1,unused,821,unused,"    char reply[32];

    nbdebug((""REP %d: %ld\n"", cmdno, result));

    sprintf(reply, ""%d %ld\n"", cmdno, result);
",unused,vimartful-src2Fnetbeans.c
"
	    /* Note: nb_getbufno() may return -1.  This indicates the IDE
	     * didn't assign a number to the current buffer in response to a
	     * fileOpened event. */
	    sprintf((char *)text, ""%d %ld %d %ld"",
",1,unused,1030,unused,"
	    /* Note: nb_getbufno() may return -1.  This indicates the IDE
	     * didn't assign a number to the current buffer in response to a
	     * fileOpened event. */
	    sprintf((char *)text, ""%d %ld %d %ld"",
",unused,vimartful-src2Fnetbeans.c
"	    }
	    tok++;
	}

	strcpy(&keybuf[i], tok);
",1,unused,2362,unused,"	    }
	    tok++;
	}

	strcpy(&keybuf[i], tok);
",unused,vimartful-src2Fnetbeans.c
"    }

    buf[0] = '\0';
    if (ctrl)
	strcat(buf, ""C"");
",1,unused,2479,unused,"    }

    buf[0] = '\0';
    if (ctrl)
	strcat(buf, ""C"");
",unused,vimartful-src2Fnetbeans.c
"    buf[0] = '\0';
    if (ctrl)
	strcat(buf, ""C"");
    if (shift)
	strcat(buf, ""S"");
",1,unused,2481,unused,"    buf[0] = '\0';
    if (ctrl)
	strcat(buf, ""C"");
    if (shift)
	strcat(buf, ""S"");
",unused,vimartful-src2Fnetbeans.c
"	strcat(buf, ""C"");
    if (shift)
	strcat(buf, ""S"");
    if (alt)
	strcat(buf, ""M""); /* META */
",1,unused,2483,unused,"	strcat(buf, ""C"");
    if (shift)
	strcat(buf, ""S"");
    if (alt)
	strcat(buf, ""M""); /* META */
",unused,vimartful-src2Fnetbeans.c
"	strcat(buf, ""S"");
    if (alt)
	strcat(buf, ""M""); /* META */
    if (ctrl || shift || alt)
	strcat(buf, ""-"");
",1,unused,2485,unused,"	strcat(buf, ""S"");
    if (alt)
	strcat(buf, ""M""); /* META */
    if (ctrl || shift || alt)
	strcat(buf, ""-"");
",unused,vimartful-src2Fnetbeans.c
"    if (alt)
	strcat(buf, ""M""); /* META */
    if (ctrl || shift || alt)
	strcat(buf, ""-"");
    strcat(buf, name);
",1,unused,2486,unused,"    if (alt)
	strcat(buf, ""M""); /* META */
    if (ctrl || shift || alt)
	strcat(buf, ""-"");
    strcat(buf, name);
",unused,vimartful-src2Fnetbeans.c
"    char buf[128];

    if (NETBEANS_OPEN)
    {
	sprintf(buf, ""0:disconnect=%d\n"", r_cmdno);
",1,unused,2593,unused,"    char buf[128];

    if (NETBEANS_OPEN)
    {
	sprintf(buf, ""0:disconnect=%d\n"", r_cmdno);
",unused,vimartful-src2Fnetbeans.c
"
    if (!NETBEANS_OPEN)
	return;

    sprintf(buf, ""0:geometry=%d %d %d %d %d\n"",
",1,unused,2628,unused,"
    if (!NETBEANS_OPEN)
	return;

    sprintf(buf, ""0:geometry=%d %d %d %d %d\n"",
",unused,vimartful-src2Fnetbeans.c
"
    nbdebug((""netbeans_file_killed:\n""));
    nbdebug((""    Killing bufno: %d"", bufno));

    sprintf(buffer, ""%d:killed=%d\n"", bufno, r_cmdno);
",1,unused,2720,unused,"
    nbdebug((""netbeans_file_killed:\n""));
    nbdebug((""    Killing bufno: %d"", bufno));

    sprintf(buffer, ""%d:killed=%d\n"", bufno, r_cmdno);
",unused,vimartful-src2Fnetbeans.c
"    p = nb_quote(newtxt);
    if (p != NULL)
    {
	buf = alloc(128 + 2*newlen);
	sprintf((char *)buf, ""%d:insert=%d %ld \""%s\""\n"",
",1,unused,2797,unused,"    p = nb_quote(newtxt);
    if (p != NULL)
    {
	buf = alloc(128 + 2*newlen);
	sprintf((char *)buf, ""%d:insert=%d %ld \""%s\""\n"",
",unused,vimartful-src2Fnetbeans.c
"    pos.col = col;

    off = pos2off(bufp, &pos);

    sprintf((char *)buf, ""%d:remove=%d %ld %ld\n"", bufno, r_cmdno, off, len);
",1,unused,2843,unused,"    pos.col = col;

    off = pos2off(bufp, &pos);

    sprintf((char *)buf, ""%d:remove=%d %ld %ld\n"", bufno, r_cmdno, off, len);
",unused,vimartful-src2Fnetbeans.c
"			      - ((curwin->w_p_nu || curwin->w_p_rnu) ? 9 : 1);
	long off = pos2off(curbuf, &curwin->w_cursor);

	/* sync the cursor position */
	sprintf(buf, ""%d:newDotAndMark=%d %ld %ld\n"", bufno, r_cmdno, off, off);
",1,unused,2880,unused,"			      - ((curwin->w_p_nu || curwin->w_p_rnu) ? 9 : 1);
	long off = pos2off(curbuf, &curwin->w_cursor);

	/* sync the cursor position */
	sprintf(buf, ""%d:newDotAndMark=%d %ld %ld\n"", bufno, r_cmdno, off, off);
",unused,vimartful-src2Fnetbeans.c
"	sprintf(buf, ""%d:newDotAndMark=%d %ld %ld\n"", bufno, r_cmdno, off, off);
	nbdebug((""EVT: %s"", buf));
	nb_send(buf, ""netbeans_button_release[newDotAndMark]"");

	sprintf(buf, ""%d:buttonRelease=%d %d %ld %d\n"", bufno, r_cmdno,
",1,unused,2884,unused,"	sprintf(buf, ""%d:newDotAndMark=%d %ld %ld\n"", bufno, r_cmdno, off, off);
	nbdebug((""EVT: %s"", buf));
	nb_send(buf, ""netbeans_button_release[newDotAndMark]"");

	sprintf(buf, ""%d:buttonRelease=%d %d %ld %d\n"", bufno, r_cmdno,
",unused,vimartful-src2Fnetbeans.c
"    }

    /* sync the cursor position */
    off = pos2off(curbuf, &curwin->w_cursor);
    sprintf(buf, ""%d:newDotAndMark=%d %ld %ld\n"", bufno, r_cmdno, off, off);
",1,unused,2947,unused,"    }

    /* sync the cursor position */
    off = pos2off(curbuf, &curwin->w_cursor);
    sprintf(buf, ""%d:newDotAndMark=%d %ld %ld\n"", bufno, r_cmdno, off, off);
",unused,vimartful-src2Fnetbeans.c
"	return;

    nbbuf->modified = 0;

    sprintf((char *)buf, ""%d:save=%d\n"", bufno, r_cmdno);
",1,unused,2991,unused,"	return;

    nbbuf->modified = 0;

    sprintf((char *)buf, ""%d:save=%d\n"", bufno, r_cmdno);
",unused,vimartful-src2Fnetbeans.c
"    /* Don't mark as modified for initial read */
    if (nbbuf->insertDone)
	nbbuf->modified = 1;

    sprintf((char *)buf, ""%d:remove=%d 0 -1\n"", bufno, r_cmdno);
",1,unused,3018,unused,"    /* Don't mark as modified for initial read */
    if (nbbuf->insertDone)
	nbbuf->modified = 1;

    sprintf((char *)buf, ""%d:remove=%d 0 -1\n"", bufno, r_cmdno);
",unused,vimartful-src2Fnetbeans.c
"	    int value;

	    value = strtol((char *)fg, &ptr, 10);
	    if (ptr != (char *)fg)
		sprintf(fgbuf, ""guifg=#%06x"", value & 0xFFFFFF);
",1,unused,3228,unused,"	    int value;

	    value = strtol((char *)fg, &ptr, 10);
	    if (ptr != (char *)fg)
		sprintf(fgbuf, ""guifg=#%06x"", value & 0xFFFFFF);
",unused,vimartful-src2Fnetbeans.c
"	    value = strtol((char *)fg, &ptr, 10);
	    if (ptr != (char *)fg)
		sprintf(fgbuf, ""guifg=#%06x"", value & 0xFFFFFF);
	    else
		sprintf(fgbuf, ""guifg=%s ctermfg=%s"", fg, fg);
",1,unused,3230,unused,"	    value = strtol((char *)fg, &ptr, 10);
	    if (ptr != (char *)fg)
		sprintf(fgbuf, ""guifg=#%06x"", value & 0xFFFFFF);
	    else
		sprintf(fgbuf, ""guifg=%s ctermfg=%s"", fg, fg);
",unused,vimartful-src2Fnetbeans.c
"		sprintf(fgbuf, ""guifg=%s ctermfg=%s"", fg, fg);

	    value = strtol((char *)bg, &ptr, 10);
	    if (ptr != (char *)bg)
		sprintf(bgbuf, ""guibg=#%06x"", value & 0xFFFFFF);
",1,unused,3234,unused,"		sprintf(fgbuf, ""guifg=%s ctermfg=%s"", fg, fg);

	    value = strtol((char *)bg, &ptr, 10);
	    if (ptr != (char *)bg)
		sprintf(bgbuf, ""guibg=#%06x"", value & 0xFFFFFF);
",unused,vimartful-src2Fnetbeans.c
"	    value = strtol((char *)bg, &ptr, 10);
	    if (ptr != (char *)bg)
		sprintf(bgbuf, ""guibg=#%06x"", value & 0xFFFFFF);
	    else
		sprintf(bgbuf, ""guibg=%s ctermbg=%s"", bg, bg);
",1,unused,3236,unused,"	    value = strtol((char *)bg, &ptr, 10);
	    if (ptr != (char *)bg)
		sprintf(bgbuf, ""guibg=#%06x"", value & 0xFFFFFF);
	    else
		sprintf(bgbuf, ""guibg=%s ctermbg=%s"", bg, bg);
",unused,vimartful-src2Fnetbeans.c
"	    getvcols(curwin, &curwin->w_cursor, &VIsual, &leftcol, &rightcol);
# ifdef FEAT_LINEBREAK
	    p_sbr = saved_sbr;
# endif
	    sprintf((char *)showcmd_buf, ""%ldx%ld"", lines,
",1,unused,3782,unused,"	    getvcols(curwin, &curwin->w_cursor, &VIsual, &leftcol, &rightcol);
# ifdef FEAT_LINEBREAK
	    p_sbr = saved_sbr;
# endif
	    sprintf((char *)showcmd_buf, ""%ldx%ld"", lines,
",unused,vimartful-src2Fnormal.c
"	    sprintf((char *)showcmd_buf, ""%ldx%ld"", lines,
					      (long)(rightcol - leftcol + 1));
	}
	else if (VIsual_mode == 'V' || VIsual.lnum != curwin->w_cursor.lnum)
	    sprintf((char *)showcmd_buf, ""%ld"", lines);
",1,unused,3786,unused,"	    sprintf((char *)showcmd_buf, ""%ldx%ld"", lines,
					      (long)(rightcol - leftcol + 1));
	}
	else if (VIsual_mode == 'V' || VIsual.lnum != curwin->w_cursor.lnum)
	    sprintf((char *)showcmd_buf, ""%ld"", lines);
",unused,vimartful-src2Fnormal.c
"		++chars;
		s += l;
	    }
	    if (bytes == chars)
		sprintf((char *)showcmd_buf, ""%d"", chars);
",1,unused,3822,unused,"		++chars;
		s += l;
	    }
	    if (bytes == chars)
		sprintf((char *)showcmd_buf, ""%d"", chars);
",unused,vimartful-src2Fnormal.c
"	    }
	    if (bytes == chars)
		sprintf((char *)showcmd_buf, ""%d"", chars);
	    else
		sprintf((char *)showcmd_buf, ""%d-%d"", chars, bytes);
",1,unused,3824,unused,"	    }
	    if (bytes == chars)
		sprintf((char *)showcmd_buf, ""%d"", chars);
	    else
		sprintf((char *)showcmd_buf, ""%d-%d"", chars, bytes);
",unused,vimartful-src2Fnormal.c
"	return FAIL;

    /* Put ""\V"" before the pattern to avoid that the special meaning of "".""
     * and ""~"" causes trouble. */
    sprintf((char *)pat, vim_iswordp(ptr) ? ""\\V\\<%.*s\\>"" : ""\\V%.*s"",
",1,unused,4327,unused,"	return FAIL;

    /* Put ""\V"" before the pattern to avoid that the special meaning of "".""
     * and ""~"" causes trouble. */
    sprintf((char *)pat, vim_iswordp(ptr) ? ""\\V\\<%.*s\\>"" : ""\\V%.*s"",
",unused,vimartful-src2Fnormal.c
"		 * really what we want? */
		isman = (STRCMP(kp, ""man"") == 0);
		isman_s = (STRCMP(kp, ""man -s"") == 0);
		if (cap->count0 != 0 && !(isman || isman_s))
		    sprintf((char *)buf, "".,.+%ld"", cap->count0 - 1);
",1,unused,5679,unused,"		 * really what we want? */
		isman = (STRCMP(kp, ""man"") == 0);
		isman_s = (STRCMP(kp, ""man -s"") == 0);
		if (cap->count0 != 0 && !(isman || isman_s))
		    sprintf((char *)buf, "".,.+%ld"", cap->count0 - 1);
",unused,vimartful-src2Fnormal.c
"		    STRCAT(buf, kp);
		STRCAT(buf, "" "");
		if (cap->count0 != 0 && (isman || isman_s))
		{
		    sprintf((char *)buf + STRLEN(buf), ""%ld"", cap->count0);
",1,unused,5689,unused,"		    STRCAT(buf, kp);
		STRCAT(buf, "" "");
		if (cap->count0 != 0 && (isman || isman_s))
		{
		    sprintf((char *)buf + STRLEN(buf), ""%ld"", cap->count0);
",unused,vimartful-src2Fnormal.c
"	    {
		if (g_cmd)
		    STRCPY(buf, ""tj "");
		else
		    sprintf((char *)buf, ""%ldta "", cap->count0);
",1,unused,5714,unused,"	    {
		if (g_cmd)
		    STRCPY(buf, ""tj "");
		else
		    sprintf((char *)buf, ""%ldta "", cap->count0);
",unused,vimartful-src2Fnormal.c
"			if (saved_origval != NULL)
			{
			    char_u buf_type[7];

			    sprintf((char *)buf_type, ""%s"",
",1,unused,5000,unused,"			if (saved_origval != NULL)
			{
			    char_u buf_type[7];

			    sprintf((char *)buf_type, ""%s"",
",unused,vimartful-src2Foption.c
"illegal_char(char_u *errbuf, int c)
{
    if (errbuf == NULL)
	return (char_u *)"""";
    sprintf((char *)errbuf, _(""E539: Illegal character <%s>""),
",1,unused,5137,unused,"illegal_char(char_u *errbuf, int c)
{
    if (errbuf == NULL)
	return (char_u *)"""";
    sprintf((char *)errbuf, _(""E539: Illegal character <%s>""),
",unused,vimartful-src2Foption.c
"#if defined(FEAT_AUTOCMD) && defined(FEAT_EVAL)
	if (saved_oldval != NULL)
	{
	    char_u buf_type[7];
	    sprintf((char *)buf_type, ""%s"",
",1,unused,5815,unused,"#if defined(FEAT_AUTOCMD) && defined(FEAT_EVAL)
	if (saved_oldval != NULL)
	{
	    char_u buf_type[7];
	    sprintf((char *)buf_type, ""%s"",
",unused,vimartful-src2Foption.c
"		if (!VIM_ISDIGIT(*(s - 1)))
		{
		    if (errbuf != NULL)
		    {
			sprintf((char *)errbuf,
",1,unused,6558,unused,"		if (!VIM_ISDIGIT(*(s - 1)))
		{
		    if (errbuf != NULL)
		    {
			sprintf((char *)errbuf,
",unused,vimartful-src2Foption.c
"		else
		{
		    if (errbuf != NULL)
		    {
			sprintf((char *)errbuf,
",1,unused,6998,unused,"		else
		{
		    if (errbuf != NULL)
		    {
			sprintf((char *)errbuf,
",unused,vimartful-src2Foption.c
"	    STRCPY(NameBuff, get_special_key_name((int)wc, 0));
	else if (wc != 0)
	    STRCPY(NameBuff, transchar((int)wc));
	else
	    sprintf((char *)NameBuff, ""%ld"", *(long *)varp);
",1,unused,11470,unused,"	    STRCPY(NameBuff, get_special_key_name((int)wc, 0));
	else if (wc != 0)
	    STRCPY(NameBuff, transchar((int)wc));
	else
	    sprintf((char *)NameBuff, ""%ld"", *(long *)varp);
",unused,vimartful-src2Foption.c
"    }

    /* No translation, it may call malloc(). */
#ifdef SIGHASARG
    sprintf((char *)IObuff, ""Vim: Caught deadly signal %s\n"",
",1,unused,1140,unused,"    }

    /* No translation, it may call malloc(). */
#ifdef SIGHASARG
    sprintf((char *)IObuff, ""Vim: Caught deadly signal %s\n"",
",unused,vimartful-src2Fos_unix.c
"	vim_strncpy(s, (char_u *)pw->pw_name, len - 1);
	return OK;
    }
#endif
    sprintf((char *)s, ""%d"", (int)uid);	    /* assumes s is long enough */
",1,unused,2373,unused,"	vim_strncpy(s, (char_u *)pw->pw_name, len - 1);
	return OK;
    }
#endif
    sprintf((char *)s, ""%d"", (int)uid);	    /* assumes s is long enough */
",unused,vimartful-src2Fos_unix.c
"
    /* Simulate to have a dumb terminal (for now) */
# ifdef HAVE_SETENV
    setenv(""TERM"", ""dumb"", 1);
    sprintf((char *)envbuf, ""%ld"", Rows);
",1,unused,4058,unused,"
    /* Simulate to have a dumb terminal (for now) */
# ifdef HAVE_SETENV
    setenv(""TERM"", ""dumb"", 1);
    sprintf((char *)envbuf, ""%ld"", Rows);
",unused,vimartful-src2Fos_unix.c
"# ifdef HAVE_SETENV
    setenv(""TERM"", ""dumb"", 1);
    sprintf((char *)envbuf, ""%ld"", Rows);
    setenv(""ROWS"", (char *)envbuf, 1);
    sprintf((char *)envbuf, ""%ld"", Rows);
",1,unused,4060,unused,"# ifdef HAVE_SETENV
    setenv(""TERM"", ""dumb"", 1);
    sprintf((char *)envbuf, ""%ld"", Rows);
    setenv(""ROWS"", (char *)envbuf, 1);
    sprintf((char *)envbuf, ""%ld"", Rows);
",unused,vimartful-src2Fos_unix.c
"    sprintf((char *)envbuf, ""%ld"", Rows);
    setenv(""ROWS"", (char *)envbuf, 1);
    sprintf((char *)envbuf, ""%ld"", Rows);
    setenv(""LINES"", (char *)envbuf, 1);
    sprintf((char *)envbuf, ""%ld"", Columns);
",1,unused,4062,unused,"    sprintf((char *)envbuf, ""%ld"", Rows);
    setenv(""ROWS"", (char *)envbuf, 1);
    sprintf((char *)envbuf, ""%ld"", Rows);
    setenv(""LINES"", (char *)envbuf, 1);
    sprintf((char *)envbuf, ""%ld"", Columns);
",unused,vimartful-src2Fos_unix.c
"	    if (idx < FMT_PATTERNS)
	    {
		if (fmt_ptr->addr[idx])
		{
		    sprintf((char *)errmsg,
",1,unused,244,unused,"	    if (idx < FMT_PATTERNS)
	    {
		if (fmt_ptr->addr[idx])
		{
		    sprintf((char *)errmsg,
",unused,vimartful-src2Fquickfix.c
"			|| (idx == 6
			    && vim_strchr((char_u *)""OPQ"",
				fmt_ptr->prefix) == NULL))
		{
		    sprintf((char *)errmsg,
",1,unused,257,unused,"			|| (idx == 6
			    && vim_strchr((char_u *)""OPQ"",
				fmt_ptr->prefix) == NULL))
		{
		    sprintf((char *)errmsg,
",unused,vimartful-src2Fquickfix.c
"		}
		else
		{
		    /* TODO: scanf()-like: %*ud, %*3c, %*f, ... ? */
		    sprintf((char *)errmsg,
",1,unused,333,unused,"		}
		else
		{
		    /* TODO: scanf()-like: %*ud, %*3c, %*f, ... ? */
		    sprintf((char *)errmsg,
",unused,vimartful-src2Fquickfix.c
"		if (vim_strchr((char_u *)""DXAEWICZGOPQ"", *efmp) != NULL)
		    fmt_ptr->prefix = *efmp;
		else
		{
		    sprintf((char *)errmsg,
",1,unused,353,unused,"		if (vim_strchr((char_u *)""DXAEWICZGOPQ"", *efmp) != NULL)
		    fmt_ptr->prefix = *efmp;
		else
		{
		    sprintf((char *)errmsg,
",unused,vimartful-src2Fquickfix.c
"		}
	    }
	    else
	    {
		sprintf((char *)errmsg,
",1,unused,361,unused,"		}
	    }
	    else
	    {
		sprintf((char *)errmsg,
",unused,vimartful-src2Fquickfix.c
"	char_u *p = alloc((int)STRLEN(title) + 2);

	qi->qf_lists[qi->qf_curlist].qf_title = p;
	if (p != NULL)
	    sprintf((char *)p, "":%s"", (char *)title);
",1,unused,1302,unused,"	char_u *p = alloc((int)STRLEN(title) + 2);

	qi->qf_lists[qi->qf_curlist].qf_title = p;
	if (p != NULL)
	    sprintf((char *)p, "":%s"", (char *)title);
",unused,vimartful-src2Fquickfix.c
"	    /* Update the screen before showing the message, unless the screen
	     * scrolled up. */
	    if (!msg_scrolled)
		update_topline_redraw();
	    sprintf((char *)IObuff, _(""(%d of %d)%s%s: ""), qf_index,
",1,unused,2375,unused,"	    /* Update the screen before showing the message, unless the screen
	     * scrolled up. */
	    if (!msg_scrolled)
		update_topline_redraw();
	    sprintf((char *)IObuff, _(""(%d of %d)%s%s: ""), qf_index,
",unused,vimartful-src2Fquickfix.c
"		if (qfp->qf_type == 1)	/* :helpgrep */
		    fname = gettail(fname);
	    }
	    if (fname == NULL)
		sprintf((char *)IObuff, ""%2d"", i);
",1,unused,2516,unused,"		if (qfp->qf_type == 1)	/* :helpgrep */
		    fname = gettail(fname);
	    }
	    if (fname == NULL)
		sprintf((char *)IObuff, ""%2d"", i);
",unused,vimartful-src2Fquickfix.c
"					   ? hl_attr(HLF_L) : hl_attr(HLF_D));
	    if (qfp->qf_lnum == 0)
		IObuff[0] = NUL;
	    else if (qfp->qf_col == 0)
		sprintf((char *)IObuff, "":%ld"", qfp->qf_lnum);
",1,unused,2525,unused,"					   ? hl_attr(HLF_L) : hl_attr(HLF_D));
	    if (qfp->qf_lnum == 0)
		IObuff[0] = NUL;
	    else if (qfp->qf_col == 0)
		sprintf((char *)IObuff, "":%ld"", qfp->qf_lnum);
",unused,vimartful-src2Fquickfix.c
"		IObuff[0] = NUL;
	    else if (qfp->qf_col == 0)
		sprintf((char *)IObuff, "":%ld"", qfp->qf_lnum);
	    else
		sprintf((char *)IObuff, "":%ld col %d"",
",1,unused,2527,unused,"		IObuff[0] = NUL;
	    else if (qfp->qf_col == 0)
		sprintf((char *)IObuff, "":%ld"", qfp->qf_lnum);
	    else
		sprintf((char *)IObuff, "":%ld col %d"",
",unused,vimartful-src2Fquickfix.c
"		sprintf((char *)IObuff, "":%ld"", qfp->qf_lnum);
	    else
		sprintf((char *)IObuff, "":%ld col %d"",
						   qfp->qf_lnum, qfp->qf_col);
	    sprintf((char *)IObuff + STRLEN(IObuff), ""%s:"",
",1,unused,2529,unused,"		sprintf((char *)IObuff, "":%ld"", qfp->qf_lnum);
	    else
		sprintf((char *)IObuff, "":%ld col %d"",
						   qfp->qf_lnum, qfp->qf_col);
	    sprintf((char *)IObuff + STRLEN(IObuff), ""%s:"",
",unused,vimartful-src2Fquickfix.c
"
    if (nr <= 0)
	return p;

    sprintf((char *)buf, ""%s %3d"", (char *)p, nr);
",1,unused,2810,unused,"
    if (nr <= 0)
	return p;

    sprintf((char *)buf, ""%s %3d"", (char *)p, nr);
",unused,vimartful-src2Fquickfix.c
"	    IObuff[len++] = '|';

	    if (qfp->qf_lnum > 0)
	    {
		sprintf((char *)IObuff + len, ""%ld"", qfp->qf_lnum);
",1,unused,3284,unused,"	    IObuff[len++] = '|';

	    if (qfp->qf_lnum > 0)
	    {
		sprintf((char *)IObuff + len, ""%ld"", qfp->qf_lnum);
",unused,vimartful-src2Fquickfix.c
"		len += (int)STRLEN(IObuff + len);

		if (qfp->qf_col > 0)
		{
		    sprintf((char *)IObuff + len, "" col %d"", qfp->qf_col);
",1,unused,3289,unused,"		len += (int)STRLEN(IObuff + len);

		if (qfp->qf_col > 0)
		{
		    sprintf((char *)IObuff + len, "" col %d"", qfp->qf_col);
",unused,vimartful-src2Fquickfix.c
"		    sprintf((char *)IObuff + len, "" col %d"", qfp->qf_col);
		    len += (int)STRLEN(IObuff + len);
		}

		sprintf((char *)IObuff + len, ""%s"",
",1,unused,3293,unused,"		    sprintf((char *)IObuff + len, "" col %d"", qfp->qf_col);
		    len += (int)STRLEN(IObuff + len);
		}

		sprintf((char *)IObuff + len, ""%s"",
",unused,vimartful-src2Fquickfix.c
"	len += (unsigned)STRLEN(p_sp) + (unsigned)STRLEN(fname) + 3;
    cmd = alloc(len);
    if (cmd == NULL)
	return;
    sprintf((char *)cmd, ""%s%s%s"", (char *)p_shq, (char *)eap->arg,
",1,unused,3487,unused,"	len += (unsigned)STRLEN(p_sp) + (unsigned)STRLEN(fname) + 3;
    cmd = alloc(len);
    if (cmd == NULL)
	return;
    sprintf((char *)cmd, ""%s%s%s"", (char *)p_shq, (char *)eap->arg,
",unused,vimartful-src2Fquickfix.c
"	name = alloc((unsigned)STRLEN(p_mef) + 30);
	if (name == NULL)
	    break;
	STRCPY(name, p_mef);
	sprintf((char *)name + (p - p_mef), ""%d%d"", start, off);
",1,unused,3579,unused,"	name = alloc((unsigned)STRLEN(p_mef) + 30);
	if (name == NULL)
	    break;
	STRCPY(name, p_mef);
	sprintf((char *)name + (p - p_mef), ""%d%d"", start, off);
",unused,vimartful-src2Fquickfix.c
"		    fmt = ""%-*ld "";
		}
	    }

	    sprintf((char *)buf, fmt, w, num);
",1,unused,2547,unused,"		    fmt = ""%-*ld "";
		}
	    }

	    sprintf((char *)buf, fmt, w, num);
",unused,vimartful-src2Fscreen.c
"				fmt = ""%-*ld "";
			    }
			}

			sprintf((char *)extra, fmt,
",1,unused,3762,unused,"				fmt = ""%-*ld "";
			    }
			}

			sprintf((char *)extra, fmt,
",unused,vimartful-src2Fscreen.c
"	{
	    char	buf[20];

	    /* The GUI handles this internally. */
	    sprintf(buf, IF_EB(""\033|%dh"", ESC_STR ""|%dh""), attr);
",1,unused,7864,unused,"	{
	    char	buf[20];

	    /* The GUI handles this internally. */
	    sprintf(buf, IF_EB(""\033|%dh"", ESC_STR ""|%dh""), attr);
",unused,vimartful-src2Fscreen.c
"	{
	    char	buf[20];

	    /* use internal GUI code */
	    sprintf(buf, IF_EB(""\033|%dH"", ESC_STR ""|%dH""), screen_attr);
",1,unused,7958,unused,"	{
	    char	buf[20];

	    /* use internal GUI code */
	    sprintf(buf, IF_EB(""\033|%dH"", ESC_STR ""|%dH""), screen_attr);
",unused,vimartful-src2Fscreen.c
"    MSG_PUTS_ATTR(_(""recording""), attr);
    if (!shortmess(SHM_RECORDING))
    {
	char_u s[4];
	sprintf((char *)s, "" @%c"", Recording);
",1,unused,10309,unused,"    MSG_PUTS_ATTR(_(""recording""), attr);
    if (!shortmess(SHM_RECORDING))
    {
	char_u s[4];
	sprintf((char *)s, "" @%c"", Recording);
",unused,vimartful-src2Fscreen.c
"			*p++ = 's';
		    if (spats[0].off.off > 0 || spats[0].off.line)
			*p++ = '+';
		    if (spats[0].off.off != 0 || spats[0].off.line)
			sprintf((char *)p, ""%ld"", spats[0].off.off);
",1,unused,1351,unused,"			*p++ = 's';
		    if (spats[0].off.off > 0 || spats[0].off.line)
			*p++ = '+';
		    if (spats[0].off.off != 0 || spats[0].off.line)
			sprintf((char *)p, ""%ld"", spats[0].off.off);
",unused,vimartful-src2Fsearch.c
"	vim_free(epat);
	curwin->w_cursor = old_pos;
	goto theend;
    }
    sprintf((char *)spat, ""<%.*s\\>\\%%(\\s\\_[^>]\\{-}[^/]>\\|>\\)\\c"", len, p);
",1,unused,3992,unused,"	vim_free(epat);
	curwin->w_cursor = old_pos;
	goto theend;
    }
    sprintf((char *)spat, ""<%.*s\\>\\%%(\\s\\_[^>]\\{-}[^/]>\\|>\\)\\c"", len, p);
",unused,vimartful-src2Fsearch.c
"	curwin->w_cursor = old_pos;
	goto theend;
    }
    sprintf((char *)spat, ""<%.*s\\>\\%%(\\s\\_[^>]\\{-}[^/]>\\|>\\)\\c"", len, p);
    sprintf((char *)epat, ""</%.*s>\\c"", len, p);
",1,unused,3993,unused,"	curwin->w_cursor = old_pos;
	goto theend;
    }
    sprintf((char *)spat, ""<%.*s\\>\\%%(\\s\\_[^>]\\{-}[^/]>\\|>\\)\\c"", len, p);
    sprintf((char *)epat, ""</%.*s>\\c"", len, p);
",unused,vimartful-src2Fsearch.c
"    {
	pat = alloc(len + 5);
	if (pat == NULL)
	    goto fpip_end;
	sprintf((char *)pat, whole ? ""\\<%.*s\\>"" : ""%.*s"", len, ptr);
",1,unused,4883,unused,"    {
	pat = alloc(len + 5);
	if (pat == NULL)
	    goto fpip_end;
	sprintf((char *)pat, whole ? ""\\<%.*s\\>"" : ""%.*s"", len, ptr);
",unused,vimartful-src2Fsearch.c
"	    *(p + 1) = NUL;
	}
	if (action == ACTION_SHOW_ALL)
	{
	    sprintf((char *)IObuff, ""%3ld: "", count);	/* show match nr */
",1,unused,5557,unused,"	    *(p + 1) = NUL;
	}
	if (action == ACTION_SHOW_ALL)
	{
	    sprintf((char *)IObuff, ""%3ld: "", count);	/* show match nr */
",unused,vimartful-src2Fsearch.c
"	if (action == ACTION_SHOW_ALL)
	{
	    sprintf((char *)IObuff, ""%3ld: "", count);	/* show match nr */
	    msg_puts(IObuff);
	    sprintf((char *)IObuff, ""%4ld"", *lnum);	/* show line nr */
",1,unused,5559,unused,"	if (action == ACTION_SHOW_ALL)
	{
	    sprintf((char *)IObuff, ""%3ld: "", count);	/* show match nr */
	    msg_puts(IObuff);
	    sprintf((char *)IObuff, ""%4ld"", *lnum);	/* show line nr */
",unused,vimartful-src2Fsearch.c
"    if (salt != NULL)
	sha256_update(&ctx, salt, salt_len);
    sha256_finish(&ctx, sha256sum);
    for (j = 0; j < 32; j++)
	sprintf((char *)hexit + j * 2, ""%02x"", sha256sum[j]);
",1,unused,294,unused,"    if (salt != NULL)
	sha256_update(&ctx, salt, salt_len);
    sha256_finish(&ctx, sha256sum);
    for (j = 0; j < 32; j++)
	sprintf((char *)hexit + j * 2, ""%02x"", sha256sum[j]);
",unused,vimartful-src2Fsha256.c
"	    for (j = 0; j < 1000; j++)
		sha256_update(&ctx, (char_u *)buf, 1000);
	    sha256_finish(&ctx, sha256sum);
	    for (j = 0; j < 32; j++)
		sprintf(output + j * 2, ""%02x"", sha256sum[j]);
",1,unused,371,unused,"	    for (j = 0; j < 1000; j++)
		sha256_update(&ctx, (char_u *)buf, 1000);
	    sha256_finish(&ctx, sha256sum);
	    for (j = 0; j < 32; j++)
		sprintf(output + j * 2, ""%02x"", sha256sum[j]);
",unused,vimartful-src2Fsha256.c
"			char_u	buf[MAXLINELEN];

			aff_entry->ae_cond = getroom_save(spin, items[4]);
			if (*items[0] == 'P')
			    sprintf((char *)buf, ""^%s"", items[4]);
",1,unused,2760,unused,"			char_u	buf[MAXLINELEN];

			aff_entry->ae_cond = getroom_save(spin, items[4]);
			if (*items[0] == 'P')
			    sprintf((char *)buf, ""^%s"", items[4]);
",unused,vimartful-src2Fspellfile.c
"			aff_entry->ae_cond = getroom_save(spin, items[4]);
			if (*items[0] == 'P')
			    sprintf((char *)buf, ""^%s"", items[4]);
			else
			    sprintf((char *)buf, ""%s$"", items[4]);
",1,unused,2762,unused,"			aff_entry->ae_cond = getroom_save(spin, items[4]);
			if (*items[0] == 'P')
			    sprintf((char *)buf, ""^%s"", items[4]);
			else
			    sprintf((char *)buf, ""%s$"", items[4]);
",unused,vimartful-src2Fspellfile.c
"#endif
					    *aff_entry->ae_cond = c_up;
					if (aff_entry->ae_cond != NULL)
					{
					    sprintf((char *)buf, ""^%s"",
",1,unused,2827,unused,"#endif
					    *aff_entry->ae_cond = c_up;
					if (aff_entry->ae_cond != NULL)
					{
					    sprintf((char *)buf, ""^%s"",
",unused,vimartful-src2Fspellfile.c
"    recursive = TRUE;
    buf = alloc((unsigned)(STRLEN(name) + 12));
    if (buf != NULL)
    {
	sprintf((char *)buf, ""colors/%s.vim"", name);
",1,unused,7141,unused,"    recursive = TRUE;
    buf = alloc((unsigned)(STRLEN(name) + 12));
    if (buf != NULL)
    {
	sprintf((char *)buf, ""colors/%s.vim"", name);
",unused,vimartful-src2Fsyntax.c
"    if (type == LIST_STRING ? (sarg != NULL) : (iarg != 0))
    {
	ts = buf;
	if (type == LIST_INT)
	    sprintf((char *)buf, ""%d"", iarg - 1);
",1,unused,8989,unused,"    if (type == LIST_STRING ? (sarg != NULL) : (iarg != 0))
    {
	ts = buf;
	if (type == LIST_INT)
	    sprintf((char *)buf, ""%d"", iarg - 1);
",unused,vimartful-src2Fsyntax.c
"		color = HL_TABLE()[id - 1].sg_gui_bg;
	    if (color == INVALCOLOR)
		return NULL;
	    rgb = (long_u)GUI_MCH_GET_RGB(color);
	    sprintf((char *)buf, ""#%02x%02x%02x"",
",1,unused,9112,unused,"		color = HL_TABLE()[id - 1].sg_gui_bg;
	    if (color == INVALCOLOR)
		return NULL;
	    rgb = (long_u)GUI_MCH_GET_RGB(color);
	    sprintf((char *)buf, ""#%02x%02x%02x"",
",unused,vimartful-src2Fsyntax.c
"	else
	    n = HL_TABLE()[id - 1].sg_cterm_bg - 1;
	if (n < 0)
	    return NULL;
	sprintf((char *)name, ""%d"", n);
",1,unused,9135,unused,"	else
	    n = HL_TABLE()[id - 1].sg_cterm_bg - 1;
	if (n < 0)
	    return NULL;
	sprintf((char *)name, ""%d"", n);
",unused,vimartful-src2Fsyntax.c
"    }
# endif
    for (i = 0; i < 9; i++)
    {
	sprintf((char *)userhl, ""User%d"", i + 1);
",1,unused,9748,unused,"    }
# endif
    for (i = 0; i < 9; i++)
    {
	sprintf((char *)userhl, ""User%d"", i + 1);
",unused,vimartful-src2Fsyntax.c
"		&& (num_matches > 1 || ic)
		&& !skip_msg)
	    {
		/* Give an indication of the number of matching tags */
		sprintf((char *)IObuff, _(""tag %d of %d%s""),
",1,unused,995,unused,"		&& (num_matches > 1 || ic)
		&& !skip_msg)
	    {
		/* Give an indication of the number of matching tags */
		sprintf((char *)IObuff, _(""tag %d of %d%s""),
",unused,vimartful-src2Ftag.c
"	    if (name == NULL)	    /* file name not available */
		continue;

	    msg_putchar('\n');
	    sprintf((char *)IObuff, ""%c%2d %2d %-15s %5ld  "",
",1,unused,1134,unused,"	    if (name == NULL)	    /* file name not available */
		continue;

	    msg_putchar('\n');
	    sprintf((char *)IObuff, ""%c%2d %2d %-15s %5ld  "",
",unused,vimartful-src2Ftag.c
"				    match_re ? matchoff : 0, !match_no_ic);
#ifdef FEAT_MULTI_LANG
			heuristic += help_pri;
#endif
			sprintf((char *)p + len + 1 + ML_EXTRA, ""%06d"",
",1,unused,2296,unused,"				    match_re ? matchoff : 0, !match_no_ic);
#ifdef FEAT_MULTI_LANG
			heuristic += help_pri;
#endif
			sprintf((char *)p + len + 1 + ML_EXTRA, ""%06d"",
",unused,vimartful-src2Ftag.c
"		    found = 2;
		    (void)test_for_static(&tagp);
		    cc = *tagp.tagname_end;
		    *tagp.tagname_end = NUL;
		    sprintf((char *)pbuf, ""^%s\\s\\*("", tagp.tagname);
",1,unused,3285,unused,"		    found = 2;
		    (void)test_for_static(&tagp);
		    cc = *tagp.tagname_end;
		    *tagp.tagname_end = NUL;
		    sprintf((char *)pbuf, ""^%s\\s\\*("", tagp.tagname);
",unused,vimartful-src2Ftag.c
"		    if (!do_search(NULL, '/', pbuf, (long)1,
							search_options, NULL))
		    {
			/* Guess again: ""^char * \<func  ("" */
			sprintf((char *)pbuf, ""^\\[#a-zA-Z_]\\.\\*\\<%s\\s\\*("",
",1,unused,3290,unused,"		    if (!do_search(NULL, '/', pbuf, (long)1,
							search_options, NULL))
		    {
			/* Guess again: ""^char * \<func  ("" */
			sprintf((char *)pbuf, ""^\\[#a-zA-Z_]\\.\\*\\<%s\\s\\*("",
",unused,vimartful-src2Ftag.c
"    char_u	nr_colors[20];		/* string for number of colors */

    t_colors = nr;
    if (t_colors > 1)
	sprintf((char *)nr_colors, ""%d"", t_colors);
",1,unused,1437,unused,"    char_u	nr_colors[20];		/* string for number of colors */

    t_colors = nr;
    if (t_colors > 1)
	sprintf((char *)nr_colors, ""%d"", t_colors);
",unused,vimartful-src2Fterm.c
"	char *format = ""%s%s%%p1%%dm"";
#else
	char *format = ""%s%s%%dm"";
#endif
	sprintf(buf, format,
",1,unused,2623,unused,"	char *format = ""%s%s%%p1%%dm"";
#else
	char *format = ""%s%s%%dm"";
#endif
	sprintf(buf, format,
",unused,vimartful-src2Fterm.c
"		    src += 5;
		    result[dlen++] = K_SPECIAL;
		    result[dlen++] = (int)KS_EXTRA;
		    result[dlen++] = (int)KE_SNR;
		    sprintf((char *)result + dlen, ""%ld"", (long)current_SID);
",1,unused,5424,unused,"		    src += 5;
		    result[dlen++] = K_SPECIAL;
		    result[dlen++] = (int)KS_EXTRA;
		    result[dlen++] = (int)KE_SNR;
		    sprintf((char *)result + dlen, ""%ld"", (long)current_SID);
",unused,vimartful-src2Fterm.c
"	sprintf(dbuf, ""Requesting XT %d: %s"",
				       xt_index_out, key_names[xt_index_out]);
	log_tr(dbuf);
# endif
	sprintf(buf, ""\033P+q%02x%02x\033\\"",
",1,unused,5785,unused,"	sprintf(dbuf, ""Requesting XT %d: %s"",
				       xt_index_out, key_names[xt_index_out]);
	log_tr(dbuf);
# endif
	sprintf(buf, ""\033P+q%02x%02x\033\\"",
",unused,vimartful-src2Fterm.c
"	char_u	    *p;
	char_u	    name[20];
	partial_T   *pt;

	sprintf((char*)name, ""<lambda>%d"", ++lambda_no);
",1,unused,256,unused,"	char_u	    *p;
	char_u	    name[20];
	partial_T   *pt;

	sprintf((char*)name, ""<lambda>%d"", ++lambda_no);
",unused,vimartful-src2Fuserfunc.c
"	    if (current_SID <= 0)
		*error = ERROR_SCRIPT;
	    else
	    {
		sprintf((char *)fname_buf + 3, ""%ld_"", (long)current_SID);
",1,unused,513,unused,"	    if (current_SID <= 0)
		*error = ERROR_SCRIPT;
	    else
	    {
		sprintf((char *)fname_buf + 3, ""%ld_"", (long)current_SID);
",unused,vimartful-src2Fuserfunc.c
"	}
	else
	{
	    /* ""..."" argument a:1, a:2, etc. */
	    sprintf((char *)numbuf, ""%d"", ai + 1);
",1,unused,765,unused,"	}
	else
	{
	    /* ""..."" argument a:1, a:2, etc. */
	    sprintf((char *)numbuf, ""%d"", ai + 1);
",unused,vimartful-src2Fuserfunc.c
"    if (sourcing_name != NULL)
    {
	if (save_sourcing_name != NULL
			  && STRNCMP(save_sourcing_name, ""function "", 9) == 0)
	    sprintf((char *)sourcing_name, ""%s[%d].."",
",1,unused,819,unused,"    if (sourcing_name != NULL)
    {
	if (save_sourcing_name != NULL
			  && STRNCMP(save_sourcing_name, ""function "", 9) == 0)
	    sprintf((char *)sourcing_name, ""%s[%d].."",
",unused,vimartful-src2Fuserfunc.c
"	    {
		EMSG(_(e_usingsid));
		goto theend;
	    }
	    sprintf((char *)sid_buf, ""%ld_"", (long)current_SID);
",1,unused,1660,unused,"	    {
		EMSG(_(e_usingsid));
		goto theend;
	    }
	    sprintf((char *)sid_buf, ""%ld_"", (long)current_SID);
",unused,vimartful-src2Fuserfunc.c
"
	/* Give the function a sequential number.  Can only be used with a
	 * Funcref! */
	vim_free(name);
	sprintf(numbuf, ""%d"", ++func_nr);
",1,unused,2232,unused,"
	/* Give the function a sequential number.  Can only be used with a
	 * Funcref! */
	vim_free(name);
	sprintf(numbuf, ""%d"", ++func_nr);
",unused,vimartful-src2Fuserfunc.c
"		 * cursor in a new window.
		 */
		if (bt_quickfix(curbuf))
		{
		    sprintf((char *)cbuf, ""split +%ld%s"",
",1,unused,536,unused,"		 * cursor in a new window.
		 */
		if (bt_quickfix(curbuf))
		{
		    sprintf((char *)cbuf, ""split +%ld%s"",
",unused,vimartful-src2Fwindow.c
"  static char z[LLEN+1];
  static int zero_seen = 0;

  if (!nz && zero_seen == 1)
    strcpy(z, l);
",1,unused,404,unused,"  static char z[LLEN+1];
  static int zero_seen = 0;

  if (!nz && zero_seen == 1)
    strcpy(z, l);
",unused,vimartful-src2Fxxd2Fxxd.c
"  while ((length < 0 || n < length) && (e = getc(fp)) != EOF)
    {
      if (p == 0)
	{
	  sprintf(l, ""%08lx:"",
",1,unused,807,unused,"  while ((length < 0 || n < length) && (e = getc(fp)) != EOF)
    {
      if (p == 0)
	{
	  sprintf(l, ""%08lx:"",
",unused,vimartful-src2Fxxd2Fxxd.c
"
    static void
buf_hashtab_add(buf_T *buf)
{
    sprintf((char *)buf->b_key, ""%x"", buf->b_fnum);
",1,unused,414,unused,"
    static void
buf_hashtab_add(buf_T *buf)
{
    sprintf((char *)buf->b_key, ""%x"", buf->b_fnum);
",unused,vimdebstretche-src2Fbuffer.c
"    hashitem_T	*hi;

    if (nr == 0)
	nr = curwin->w_alt_fnum;
    sprintf((char *)key, ""%x"", nr);
",1,unused,2738,unused,"    hashitem_T	*hi;

    if (nr == 0)
	nr = curwin->w_alt_fnum;
    sprintf((char *)key, ""%x"", nr);
",unused,vimdebstretche-src2Fbuffer.c
"	    char_u	*s;

	    if (opt.jo_set & JO_IN_BUF)
	    {
		sprintf((char *)numbuf, ""%d"", opt.jo_io_buf[PART_IN]);
",1,unused,4941,unused,"	    char_u	*s;

	    if (opt.jo_set & JO_IN_BUF)
	    {
		sprintf((char *)numbuf, ""%d"", opt.jo_io_buf[PART_IN]);
",unused,vimdebstretche-src2Fchannel.c
"
    list_hashtable_vars(&curbuf->b_vars->dv_hashtab, (char_u *)""b:"",
								 TRUE, first);

    sprintf((char *)numbuf, ""%ld"", (long)curbuf->b_changedtick);
",1,unused,1459,unused,"
    list_hashtable_vars(&curbuf->b_vars->dv_hashtab, (char_u *)""b:"",
								 TRUE, first);

    sprintf((char *)numbuf, ""%ld"", (long)curbuf->b_changedtick);
",unused,vimdebstretche-src2Feval.c
"    if (newval == NULL)
	return NULL;

    if (eap->force_bin == FORCE_BIN)
	sprintf((char *)newval, "" ++bin"");
",1,unused,6784,unused,"    if (newval == NULL)
	return NULL;

    if (eap->force_bin == FORCE_BIN)
	sprintf((char *)newval, "" ++bin"");
",unused,vimdebstretche-src2Feval.c
"
    if (eap->force_bin == FORCE_BIN)
	sprintf((char *)newval, "" ++bin"");
    else if (eap->force_bin == FORCE_NOBIN)
	sprintf((char *)newval, "" ++nobin"");
",1,unused,6786,unused,"
    if (eap->force_bin == FORCE_BIN)
	sprintf((char *)newval, "" ++bin"");
    else if (eap->force_bin == FORCE_NOBIN)
	sprintf((char *)newval, "" ++nobin"");
",unused,vimdebstretche-src2Feval.c
"    if (eap->read_edit)
	STRCAT(newval, "" ++edit"");

    if (eap->force_ff != 0)
	sprintf((char *)newval + STRLEN(newval), "" ++ff=%s"",
",1,unused,6794,unused,"    if (eap->read_edit)
	STRCAT(newval, "" ++edit"");

    if (eap->force_ff != 0)
	sprintf((char *)newval + STRLEN(newval), "" ++ff=%s"",
",unused,vimdebstretche-src2Feval.c
"	sprintf((char *)newval + STRLEN(newval), "" ++ff=%s"",
						eap->cmd + eap->force_ff);
# ifdef FEAT_MBYTE
    if (eap->force_enc != 0)
	sprintf((char *)newval + STRLEN(newval), "" ++enc=%s"",
",1,unused,6798,unused,"	sprintf((char *)newval + STRLEN(newval), "" ++ff=%s"",
						eap->cmd + eap->force_ff);
# ifdef FEAT_MBYTE
    if (eap->force_enc != 0)
	sprintf((char *)newval + STRLEN(newval), "" ++enc=%s"",
",unused,vimdebstretche-src2Feval.c
"	STRCPY(newval + STRLEN(newval), "" ++bad=keep"");
    else if (eap->bad_char == BAD_DROP)
	STRCPY(newval + STRLEN(newval), "" ++bad=drop"");
    else if (eap->bad_char != 0)
	sprintf((char *)newval + STRLEN(newval), "" ++bad=%c"", eap->bad_char);
",1,unused,6805,unused,"	STRCPY(newval + STRLEN(newval), "" ++bad=keep"");
    else if (eap->bad_char == BAD_DROP)
	STRCPY(newval + STRLEN(newval), "" ++bad=drop"");
    else if (eap->bad_char != 0)
	sprintf((char *)newval + STRLEN(newval), "" ++bad=%c"", eap->bad_char);
",unused,vimdebstretche-src2Feval.c
"	    ga_concat(gap, (char_u *)"" "");
    }
    if (sourcing_lnum > 0)
    {
	sprintf(buf, ""line %ld"", (long)sourcing_lnum);
",1,unused,9016,unused,"	    ga_concat(gap, (char_u *)"" "");
    }
    if (sourcing_lnum > 0)
    {
	sprintf(buf, ""line %ld"", (long)sourcing_lnum);
",unused,vimdebstretche-src2Feval.c
"		    + 20		    /* for %3ld */
		    + STRLEN(s)));	    /* concatenated */
	if (r != NULL)
	{
	    sprintf((char *)r, txt, dashes, count);
",1,unused,3517,unused,"		    + 20		    /* for %3ld */
		    + STRLEN(s)));	    /* concatenated */
	if (r != NULL)
	{
	    sprintf((char *)r, txt, dashes, count);
",unused,vimdebstretche-src2Fevalfunc.c
"	    /* Expand s: and <SID> into <SNR>nr_, so that the function can
	     * also be called from another script. Using trans_function_name()
	     * would also work, but some plugins depend on the name being
	     * printable text. */
	    sprintf(sid_buf, ""<SNR>%ld_"", (long)current_SID);
",1,unused,3636,unused,"	    /* Expand s: and <SID> into <SNR>nr_, so that the function can
	     * also be called from another script. Using trans_function_name()
	     * would also work, but some plugins depend on the name being
	     * printable text. */
	    sprintf(sid_buf, ""<SNR>%ld_"", (long)current_SID);
",unused,vimdebstretche-src2Fevalfunc.c
"		    {
			list_append_number(l, (varnumber_T)llpos->col);
			list_append_number(l, (varnumber_T)llpos->len);
		    }
		    sprintf(buf, ""pos%d"", i + 1);
",1,unused,4803,unused,"		    {
			list_append_number(l, (varnumber_T)llpos->col);
			list_append_number(l, (varnumber_T)llpos->len);
		    }
		    sprintf(buf, ""pos%d"", i + 1);
",unused,vimdebstretche-src2Fevalfunc.c
"	case MLINE: buf[0] = 'V'; break;
	case MCHAR: buf[0] = 'v'; break;
	case MBLOCK:
		buf[0] = Ctrl_V;
		sprintf((char *)buf + 1, ""%ld"", reglen + 1);
",1,unused,4999,unused,"	case MLINE: buf[0] = 'V'; break;
	case MCHAR: buf[0] = 'v'; break;
	case MBLOCK:
		buf[0] = Ctrl_V;
		sprintf((char *)buf + 1, ""%ld"", reglen + 1);
",unused,vimdebstretche-src2Fevalfunc.c
"	dictitem_T	v;
	char_u		str[30];
	char_u		*idvar;

	sprintf((char *)str, PRINTF_HEX_LONG_U, (long_u)w);
",1,unused,8488,unused,"	dictitem_T	v;
	char_u		str[30];
	char_u		*idvar;

	sprintf((char *)str, PRINTF_HEX_LONG_U, (long_u)w);
",unused,vimdebstretche-src2Fevalfunc.c
"    pat2 = alloc((unsigned)(STRLEN(spat) + STRLEN(epat) + 17));
    pat3 = alloc((unsigned)(STRLEN(spat) + STRLEN(mpat) + STRLEN(epat) + 25));
    if (pat2 == NULL || pat3 == NULL)
	goto theend;
    sprintf((char *)pat2, ""\\m\\(%s\\m\\)\\|\\(%s\\m\\)"", spat, epat);
",1,unused,9487,unused,"    pat2 = alloc((unsigned)(STRLEN(spat) + STRLEN(epat) + 17));
    pat3 = alloc((unsigned)(STRLEN(spat) + STRLEN(mpat) + STRLEN(epat) + 25));
    if (pat2 == NULL || pat3 == NULL)
	goto theend;
    sprintf((char *)pat2, ""\\m\\(%s\\m\\)\\|\\(%s\\m\\)"", spat, epat);
",unused,vimdebstretche-src2Fevalfunc.c
"    sprintf((char *)pat2, ""\\m\\(%s\\m\\)\\|\\(%s\\m\\)"", spat, epat);
    if (*mpat == NUL)
	STRCPY(pat3, pat2);
    else
	sprintf((char *)pat3, ""\\m\\(%s\\m\\)\\|\\(%s\\m\\)\\|\\(%s\\m\\)"",
",1,unused,9491,unused,"    sprintf((char *)pat2, ""\\m\\(%s\\m\\)\\|\\(%s\\m\\)"", spat, epat);
    if (*mpat == NUL)
	STRCPY(pat3, pat2);
    else
	sprintf((char *)pat3, ""\\m\\(%s\\m\\)\\|\\(%s\\m\\)\\|\\(%s\\m\\)"",
",unused,vimdebstretche-src2Fevalfunc.c
"
		/* match from matchaddpos() */
		for (i = 1; i < 9; i++)
		{
		    sprintf((char *)buf, (char *)""pos%d"", i);
",1,unused,10043,unused,"
		/* match from matchaddpos() */
		for (i = 1; i < 9; i++)
		{
		    sprintf((char *)buf, (char *)""pos%d"", i);
",unused,vimdebstretche-src2Fevalfunc.c
"
    ga_init2(&ga, (int)sizeof(char), 70);
    FOR_ALL_WINDOWS(wp)
    {
	sprintf((char *)buf, ""%dresize %d|"", winnr, wp->w_height);
",1,unused,12931,unused,"
    ga_init2(&ga, (int)sizeof(char), 70);
    FOR_ALL_WINDOWS(wp)
    {
	sprintf((char *)buf, ""%dresize %d|"", winnr, wp->w_height);
",unused,vimdebstretche-src2Fevalfunc.c
"    FOR_ALL_WINDOWS(wp)
    {
	sprintf((char *)buf, ""%dresize %d|"", winnr, wp->w_height);
	ga_concat(&ga, buf);
	sprintf((char *)buf, ""vert %dresize %d|"", winnr, wp->w_width);
",1,unused,12933,unused,"    FOR_ALL_WINDOWS(wp)
    {
	sprintf((char *)buf, ""%dresize %d|"", winnr, wp->w_height);
	ga_concat(&ga, buf);
	sprintf((char *)buf, ""vert %dresize %d|"", winnr, wp->w_width);
",unused,vimdebstretche-src2Fevalfunc.c
"	    if (s == NULL)
		got_int = TRUE;
	    else
	    {
		sprintf((char *)s, ""help-tags\t%s\t1\n"", tagfname);
",1,unused,7114,unused,"	    if (s == NULL)
		got_int = TRUE;
	    else
	    {
		sprintf((char *)s, ""help-tags\t%s\t1\n"", tagfname);
",unused,vimdebstretche-src2Fex_cmds.c
"			    break;
			}
			((char_u **)ga.ga_data)[ga.ga_len] = s;
			++ga.ga_len;
			sprintf((char *)s, ""%s\t%s"", p1, fname);
",1,unused,7210,unused,"			    break;
			}
			((char_u **)ga.ga_data)[ga.ga_len] = s;
			++ga.ga_len;
			sprintf((char *)s, ""%s\t%s"", p1, fname);
",unused,vimdebstretche-src2Fex_cmds.c
"		    }
		    cmd = alloc((unsigned)STRLEN(buf->b_fname) + 25);
		    if (cmd == NULL)
			return;
		    sprintf((char *)cmd, ""e +%ld %s"", (long)lnum, buf->b_fname);
",1,unused,7859,unused,"		    }
		    cmd = alloc((unsigned)STRLEN(buf->b_fname) + 25);
		    if (cmd == NULL)
			return;
		    sprintf((char *)cmd, ""e +%ld %s"", (long)lnum, buf->b_fname);
",unused,vimdebstretche-src2Fex_cmds.c
"
    QueryPerformanceFrequency(&fr);
    sprintf(buf, ""%10.6lf"", (double)tm->QuadPart / (double)fr.QuadPart);
# else
    sprintf(buf, ""%3ld.%06ld"", (long)tm->tv_sec, (long)tm->tv_usec);
",1,unused,1001,unused,"
    QueryPerformanceFrequency(&fr);
    sprintf(buf, ""%10.6lf"", (double)tm->QuadPart / (double)fr.QuadPart);
# else
    sprintf(buf, ""%3ld.%06ld"", (long)tm->tv_sec, (long)tm->tv_usec);
",unused,vimdebstretche-src2Fex_cmds2.c
"	    }
	    do_unlet((char_u *)""g:current_compiler"", TRUE);
	    do_unlet((char_u *)""b:current_compiler"", TRUE);

	    sprintf((char *)buf, ""compiler/%s.vim"", eap->arg);
",1,unused,3204,unused,"	    }
	    do_unlet((char_u *)""g:current_compiler"", TRUE);
	    do_unlet((char_u *)""b:current_compiler"", TRUE);

	    sprintf((char *)buf, ""compiler/%s.vim"", eap->arg);
",unused,vimdebstretche-src2Fex_cmds2.c
"	    {
		if (a & COUNT)
		{
		    /* -count=N */
		    sprintf((char *)IObuff + len, ""%ldc"", cmd->uc_def);
",1,unused,6015,unused,"	    {
		if (a & COUNT)
		{
		    /* -count=N */
		    sprintf((char *)IObuff + len, ""%ldc"", cmd->uc_def);
",unused,vimdebstretche-src2Fex_docmd.c
"		    IObuff[len++] = '%';
		else if (cmd->uc_def >= 0)
		{
		    /* -range=N */
		    sprintf((char *)IObuff + len, ""%ld"", cmd->uc_def);
",1,unused,6023,unused,"		    IObuff[len++] = '%';
		else if (cmd->uc_def >= 0)
		{
		    /* -range=N */
		    sprintf((char *)IObuff + len, ""%ld"", cmd->uc_def);
",unused,vimdebstretche-src2Fex_docmd.c
"		   (type == ct_LINE2) ? eap->line2 :
		   (eap->addr_count > 0) ? eap->line2 : cmd->uc_def;
	size_t num_len;

	sprintf(num_buf, ""%ld"", num);
",1,unused,6671,unused,"		   (type == ct_LINE2) ? eap->line2 :
		   (eap->addr_count > 0) ? eap->line2 : cmd->uc_def;
	size_t num_len;

	sprintf(num_buf, ""%ld"", num);
",unused,vimdebstretche-src2Fex_docmd.c
"#  else
	if (mch_get_winpos(&x, &y) != FAIL)
#  endif
	{
	    sprintf((char *)IObuff, _(""Window position: X %d, Y %d""), x, y);
",1,unused,9203,unused,"#  else
	if (mch_get_winpos(&x, &y) != FAIL)
#  endif
	{
	    sprintf((char *)IObuff, _(""Window position: X %d, Y %d""), x, y);
",unused,vimdebstretche-src2Fex_docmd.c
"		{
		    *errormsg = (char_u *)_(""E496: no autocommand buffer number to substitute for \""<abuf>\"""");
		    return NULL;
		}
		sprintf((char *)strbuf, ""%d"", autocmd_bufnr);
",1,unused,10730,unused,"		{
		    *errormsg = (char_u *)_(""E496: no autocommand buffer number to substitute for \""<abuf>\"""");
		    return NULL;
		}
		sprintf((char *)strbuf, ""%d"", autocmd_bufnr);
",unused,vimdebstretche-src2Fex_docmd.c
"		{
		    *errormsg = (char_u *)_(""E842: no line number to use for \""<slnum>\"""");
		    return NULL;
		}
		sprintf((char *)strbuf, ""%ld"", (long)sourcing_lnum);
",1,unused,10758,unused,"		{
		    *errormsg = (char_u *)_(""E842: no line number to use for \""<slnum>\"""");
		    return NULL;
		}
		sprintf((char *)strbuf, ""%ld"", (long)sourcing_lnum);
",unused,vimdebstretche-src2Fex_docmd.c
"		result = strbuf;
		break;
#if defined(FEAT_CLIENTSERVER)
	case SPEC_CLIENT:	/* Source of last submitted input */
		sprintf((char *)strbuf, PRINTF_HEX_LONG_U,
",1,unused,10763,unused,"		result = strbuf;
		break;
#if defined(FEAT_CLIENTSERVER)
	case SPEC_CLIENT:	/* Source of last submitted input */
		sprintf((char *)strbuf, PRINTF_HEX_LONG_U,
",unused,vimdebstretche-src2Fex_docmd.c
"			continue;

		    STRCAT(val, p);
		    p[-2] = NUL;
		    sprintf((char *)(val + STRLEN(p)), "" (%s)"", &mesg[1]);
",1,unused,482,unused,"			continue;

		    STRCAT(val, p);
		    p[-2] = NUL;
		    sprintf((char *)(val + STRLEN(p)), "" (%s)"", &mesg[1]);
",unused,vimdebstretche-src2Fex_eval.c
"    }

    args[0] = vim_strnsave(xp->xp_pattern, xp->xp_pattern_len);
    args[1] = xp->xp_line;
    sprintf((char *)num, ""%d"", xp->xp_col);
",1,unused,5163,unused,"    }

    args[0] = vim_strnsave(xp->xp_pattern, xp->xp_pattern_len);
    args[1] = xp->xp_line;
    sprintf((char *)num, ""%d"", xp->xp_col);
",unused,vimdebstretche-src2Fex_getln.c
"	{
	    ga_clear_strings(&ga);
	    return FAIL;
	}
	sprintf((char *)s, ""%s/%s*.vim"", dirnames[i], pat);
",1,unused,5313,unused,"	{
	    ga_clear_strings(&ga);
	    return FAIL;
	}
	sprintf((char *)s, ""%s/%s*.vim"", dirnames[i], pat);
",unused,vimdebstretche-src2Fex_getln.c
"	    {
		ga_clear_strings(&ga);
		return FAIL;
	    }
	    sprintf((char *)s, ""pack/*/start/*/%s/%s*.vim"", dirnames[i], pat);
",1,unused,5327,unused,"	    {
		ga_clear_strings(&ga);
		return FAIL;
	    }
	    sprintf((char *)s, ""pack/*/start/*/%s/%s*.vim"", dirnames[i], pat);
",unused,vimdebstretche-src2Fex_getln.c
"	    {
		ga_clear_strings(&ga);
		return FAIL;
	    }
	    sprintf((char *)s, ""pack/*/opt/*/%s/%s*.vim"", dirnames[i], pat);
",1,unused,5342,unused,"	    {
		ga_clear_strings(&ga);
		return FAIL;
	    }
	    sprintf((char *)s, ""pack/*/opt/*/%s/%s*.vim"", dirnames[i], pat);
",unused,vimdebstretche-src2Fex_getln.c
"    {
	ga_clear_strings(&ga);
	return FAIL;
    }
    sprintf((char *)s, ""pack/*/opt/%s*"", pat);
",1,unused,5405,unused,"    {
	ga_clear_strings(&ga);
	return FAIL;
    }
    sprintf((char *)s, ""pack/*/opt/%s*"", pat);
",unused,vimdebstretche-src2Fex_getln.c
"		if (hist[i].hisstr != NULL
			&& hist[i].hisnum >= j && hist[i].hisnum <= k)
		{
		    msg_putchar('\n');
		    sprintf((char *)IObuff, ""%c%6d  "", i == idx ? '>' : ' ',
",1,unused,6242,unused,"		if (hist[i].hisstr != NULL
			&& hist[i].hisnum >= j && hist[i].hisnum <= k)
		{
		    msg_putchar('\n');
		    sprintf((char *)IObuff, ""%c%6d  "", i == idx ? '>' : ' ',
",unused,vimdebstretche-src2Fex_getln.c
"			     * |{bartype},{histtype},{timestamp},{separator},""text"" */
			    if (c == NUL)
				cbuf[0] = NUL;
			    else
				sprintf(cbuf, ""%d"", c);
",1,unused,6708,unused,"			     * |{bartype},{histtype},{timestamp},{separator},""text"" */
			    if (c == NUL)
				cbuf[0] = NUL;
			    else
				sprintf(cbuf, ""%d"", c);
",unused,vimdebstretche-src2Fex_getln.c
"#endif
#ifdef FEAT_MBYTE
	    if (conv_error != 0)
	    {
		sprintf((char *)IObuff + STRLEN(IObuff),
",1,unused,2542,unused,"#endif
#ifdef FEAT_MBYTE
	    if (conv_error != 0)
	    {
		sprintf((char *)IObuff + STRLEN(IObuff),
",unused,vimdebstretche-src2Ffileio.c
"		c = TRUE;
	    }
	    else if (illegal_byte > 0)
	    {
		sprintf((char *)IObuff + STRLEN(IObuff),
",1,unused,2548,unused,"		c = TRUE;
	    }
	    else if (illegal_byte > 0)
	    {
		sprintf((char *)IObuff + STRLEN(IObuff),
",unused,vimdebstretche-src2Ffileio.c
"    if (eap->cmd == NULL)
	return FAIL;

#ifdef FEAT_MBYTE
    sprintf((char *)eap->cmd, ""e ++ff=%s ++enc=%s"", buf->b_p_ff, buf->b_p_fenc);
",1,unused,2781,unused,"    if (eap->cmd == NULL)
	return FAIL;

#ifdef FEAT_MBYTE
    sprintf((char *)eap->cmd, ""e ++ff=%s ++enc=%s"", buf->b_p_ff, buf->b_p_fenc);
",unused,vimdebstretche-src2Ffileio.c
"		 */
		STRCPY(IObuff, fname);
		for (i = 4913; ; i += 123)
		{
		    sprintf((char *)gettail(IObuff), ""%d"", i);
",1,unused,3735,unused,"		 */
		STRCPY(IObuff, fname);
		for (i = 4913; ; i += 123)
		{
		    sprintf((char *)gettail(IObuff), ""%d"", i);
",unused,vimdebstretche-src2Ffileio.c
"    {
	if (lnum == 1)
	    STRCPY(p, _(""1 line, ""));
	else
	    sprintf((char *)p, _(""%ld lines, ""), lnum);
",1,unused,5259,unused,"    {
	if (lnum == 1)
	    STRCPY(p, _(""1 line, ""));
	else
	    sprintf((char *)p, _(""%ld lines, ""), lnum);
",unused,vimdebstretche-src2Ffileio.c
"	    return -1;
	STRCPY(tempname, from);
	for (n = 123; n < 99999; ++n)
	{
	    sprintf((char *)gettail((char_u *)tempname), ""%d"", n);
",1,unused,6519,unused,"	    return -1;
	STRCPY(tempname, from);
	for (n = 123; n < 99999; ++n)
	{
	    sprintf((char *)gettail((char_u *)tempname), ""%d"", n);
",unused,vimdebstretche-src2Ffileio.c
"	    if (!helpmesg)
		mesg2 = """";
	    tbuf = alloc((unsigned)(STRLEN(path) + STRLEN(mesg)
							+ STRLEN(mesg2) + 2));
	    sprintf((char *)tbuf, mesg, path);
",1,unused,6967,unused,"	    if (!helpmesg)
		mesg2 = """";
	    tbuf = alloc((unsigned)(STRLEN(path) + STRLEN(mesg)
							+ STRLEN(mesg2) + 2));
	    sprintf((char *)tbuf, mesg, path);
",unused,vimdebstretche-src2Ffileio.c
"    if (vim_tempdir != NULL)
    {
	/* There is no need to check if the file exists, because we own the
	 * directory and nobody else creates a file in it. */
	sprintf((char *)itmp, ""%s%ld"", vim_tempdir, temp_count++);
",1,unused,7465,unused,"    if (vim_tempdir != NULL)
    {
	/* There is no need to check if the file exists, because we own the
	 * directory and nobody else creates a file in it. */
	sprintf((char *)itmp, ""%s%ld"", vim_tempdir, temp_count++);
",unused,vimdebstretche-src2Ffileio.c
"
	if (is_buflocal)
	{
	    /* normalize pat into standard ""<buffer>#N"" form */
	    sprintf((char *)buflocal_pat, ""<buffer=%d>"", buflocal_nr);
",1,unused,8601,unused,"
	if (is_buflocal)
	{
	    /* normalize pat into standard ""<buffer>#N"" form */
	    sprintf((char *)buflocal_pat, ""<buffer=%d>"", buflocal_nr);
",unused,vimdebstretche-src2Ffileio.c
"		sourcing_name = alloc((unsigned)(STRLEN(s)
					    + STRLEN(name) + ap->patlen + 1));
		if (sourcing_name != NULL)
		{
		    sprintf((char *)sourcing_name, s,
",1,unused,9738,unused,"		sourcing_name = alloc((unsigned)(STRLEN(s)
					    + STRLEN(name) + ap->patlen + 1));
		if (sourcing_name != NULL)
		{
		    sprintf((char *)sourcing_name, s,
",unused,vimdebstretche-src2Ffileio.c
"add_num_buff(buffheader_T *buf, long n)
{
    char_u	number[32];

    sprintf((char *)number, ""%ld"", n);
",1,unused,296,unused,"add_num_buff(buffheader_T *buf, long n)
{
    char_u	number[32];

    sprintf((char *)number, ""%ld"", n);
",unused,vimdebstretche-src2Fgetchar.c
"		i = getdigits(&p);
		if (i != 0)
		{
		    /* Double the width specification. */
		    sprintf((char *)wp, ""%d%s"", i * 2, p);
",1,unused,951,unused,"		i = getdigits(&p);
		if (i != 0)
		{
		    /* Double the width specification. */
		    sprintf((char *)wp, ""%d%s"", i * 2, p);
",unused,vimdebstretche-src2Fgui.c
"    if (strcmp(path, SFcurrentDir))
    {
	result = mch_chdir(path);
	if (!result)
	    (void) strcpy(SFcurrentDir, path);
",1,unused,253,unused,"    if (strcmp(path, SFcurrentDir))
    {
	result = mch_chdir(path);
	if (!result)
	    (void) strcpy(SFcurrentDir, path);
",unused,vimdebstretche-src2Fgui_at_fs.c
"
    static void
SFstrdup(char **s1, char *s2)
{
    *s1 = strcpy(XtMalloc((unsigned)(strlen(s2) + 1)), s2);
",1,unused,287,unused,"
    static void
SFstrdup(char **s1, char *s2)
{
    *s1 = strcpy(XtMalloc((unsigned)(strlen(s2) + 1)), s2);
",unused,vimdebstretche-src2Fgui_at_fs.c
"
    *(dir->path) = 0;
    len = strlen(str);
    if (str[len - 1] == '/')
	(void) strcat(SFcurrentPath, str);
",1,unused,315,unused,"
    *(dir->path) = 0;
    len = strlen(str);
    if (str[len - 1] == '/')
	(void) strcat(SFcurrentPath, str);
",unused,vimdebstretche-src2Fgui_at_fs.c
"    i = 1;
    entries = (SFEntry *)XtMalloc(sizeof(SFEntry));
    SFlogins = (SFLogin *)XtMalloc(sizeof(SFLogin));
    entries[0].real = XtMalloc(3);
    (void) strcpy(entries[0].real, ""~"");
",1,unused,520,unused,"    i = 1;
    entries = (SFEntry *)XtMalloc(sizeof(SFEntry));
    SFlogins = (SFLogin *)XtMalloc(sizeof(SFLogin));
    entries[0].real = XtMalloc(3);
    (void) strcpy(entries[0].real, ""~"");
",unused,vimdebstretche-src2Fgui_at_fs.c
"					 (unsigned)(Alloc * sizeof(SFLogin)));
	}
	len = strlen(pw->pw_name);
	entries[i].real = XtMalloc((unsigned) (len + 3));
	(void) strcat(strcpy(entries[i].real, ""~""), pw->pw_name);
",1,unused,542,unused,"					 (unsigned)(Alloc * sizeof(SFLogin)));
	}
	len = strlen(pw->pw_name);
	entries[i].real = XtMalloc((unsigned) (len + 3));
	(void) strcat(strcpy(entries[i].real, ""~""), pw->pw_name);
",unused,vimdebstretche-src2Fgui_at_fs.c
"					 (unsigned)(Alloc * sizeof(SFLogin)));
	}
	len = strlen(pw->pw_name);
	entries[i].real = XtMalloc((unsigned) (len + 3));
	(void) strcat(strcpy(entries[i].real, ""~""), pw->pw_name);
",1,unused,542,unused,"					 (unsigned)(Alloc * sizeof(SFLogin)));
	}
	len = strlen(pw->pw_name);
	entries[i].real = XtMalloc((unsigned) (len + 3));
	(void) strcat(strcpy(entries[i].real, ""~""), pw->pw_name);
",unused,vimdebstretche-src2Fgui_at_fs.c
"    qsort((char *)entries, (size_t)i, sizeof(SFEntry), SFcompareEntries);
    qsort((char *)SFlogins, (size_t)i, sizeof(SFLogin), SFcompareLogins);

    for (i--; i >= 0; i--)
	(void)strcat(entries[i].real, ""/"");
",1,unused,568,unused,"    qsort((char *)entries, (size_t)i, sizeof(SFEntry), SFcompareEntries);
    qsort((char *)SFlogins, (size_t)i, sizeof(SFLogin), SFcompareLogins);

    for (i--; i >= 0; i--)
	(void)strcat(entries[i].real, ""/"");
",unused,vimdebstretche-src2Fgui_at_fs.c
"	if (!strcmp(SFhomeDir.entries[i].real, begin))
	{
	    *end = save;
	    SFstrdup(&theRest, end);
	    (void) strcat(strcat(strcpy(SFcurrentPath,
",1,unused,589,unused,"	if (!strcmp(SFhomeDir.entries[i].real, begin))
	{
	    *end = save;
	    SFstrdup(&theRest, end);
	    (void) strcat(strcat(strcpy(SFcurrentPath,
",unused,vimdebstretche-src2Fgui_at_fs.c
"	if (!strcmp(SFhomeDir.entries[i].real, begin))
	{
	    *end = save;
	    SFstrdup(&theRest, end);
	    (void) strcat(strcat(strcpy(SFcurrentPath,
",1,unused,589,unused,"	if (!strcmp(SFhomeDir.entries[i].real, begin))
	{
	    *end = save;
	    SFstrdup(&theRest, end);
	    (void) strcat(strcat(strcpy(SFcurrentPath,
",unused,vimdebstretche-src2Fgui_at_fs.c
"	if (!strcmp(SFhomeDir.entries[i].real, begin))
	{
	    *end = save;
	    SFstrdup(&theRest, end);
	    (void) strcat(strcat(strcpy(SFcurrentPath,
",1,unused,589,unused,"	if (!strcmp(SFhomeDir.entries[i].real, begin))
	{
	    *end = save;
	    SFstrdup(&theRest, end);
	    (void) strcat(strcat(strcpy(SFcurrentPath,
",unused,vimdebstretche-src2Fgui_at_fs.c
"			int len;

			len = strlen(shown);
			entry->shown = XtMalloc((unsigned) (len + 2));
			(void) strcpy(entry->shown, shown);
",1,unused,1366,unused,"			int len;

			len = strlen(shown);
			entry->shown = XtMalloc((unsigned) (len + 2));
			(void) strcpy(entry->shown, shown);
",unused,vimdebstretche-src2Fgui_at_fs.c
"	result[i].statDone = 0;
	str = dp->d_name;
	len = strlen(str);
	result[i].real = XtMalloc((unsigned) (len + 2));
	(void) strcat(strcpy(result[i].real, str), "" "");
",1,unused,2095,unused,"	result[i].statDone = 0;
	str = dp->d_name;
	len = strlen(str);
	result[i].real = XtMalloc((unsigned) (len + 2));
	(void) strcat(strcpy(result[i].real, str), "" "");
",unused,vimdebstretche-src2Fgui_at_fs.c
"	result[i].statDone = 0;
	str = dp->d_name;
	len = strlen(str);
	result[i].real = XtMalloc((unsigned) (len + 2));
	(void) strcat(strcpy(result[i].real, str), "" "");
",1,unused,2095,unused,"	result[i].statDone = 0;
	str = dp->d_name;
	len = strlen(str);
	result[i].real = XtMalloc((unsigned) (len + 2));
	(void) strcat(strcpy(result[i].real, str), "" "");
",unused,vimdebstretche-src2Fgui_at_fs.c
"	    SFtextPos = XawTextGetInsertionPoint(selFileField);
	}
	else
	{
	    strcpy(SFcurrentPath, SFstartDir);
",1,unused,2637,unused,"	    SFtextPos = XawTextGetInsertionPoint(selFileField);
	}
	else
	{
	    strcpy(SFcurrentPath, SFstartDir);
",unused,vimdebstretche-src2Fgui_at_fs.c
"    else
#endif
    if ((SFtextBuffer[0] == '/') || (SFtextBuffer[0] == '~'))
    {
	(void) strcpy(SFcurrentPath, SFtextBuffer);
",1,unused,2647,unused,"    else
#endif
    if ((SFtextBuffer[0] == '/') || (SFtextBuffer[0] == '~'))
    {
	(void) strcpy(SFcurrentPath, SFtextBuffer);
",unused,vimdebstretche-src2Fgui_at_fs.c
"	SFtextPos = XawTextGetInsertionPoint(selFileField);
    }
    else
    {
	(void) strcat(strcpy(SFcurrentPath, SFstartDir), SFtextBuffer);
",1,unused,2652,unused,"	SFtextPos = XawTextGetInsertionPoint(selFileField);
    }
    else
    {
	(void) strcat(strcpy(SFcurrentPath, SFstartDir), SFtextBuffer);
",unused,vimdebstretche-src2Fgui_at_fs.c
"	SFtextPos = XawTextGetInsertionPoint(selFileField);
    }
    else
    {
	(void) strcat(strcpy(SFcurrentPath, SFstartDir), SFtextBuffer);
",1,unused,2652,unused,"	SFtextPos = XawTextGetInsertionPoint(selFileField);
    }
    else
    {
	(void) strcat(strcpy(SFcurrentPath, SFstartDir), SFtextBuffer);
",unused,vimdebstretche-src2Fgui_at_fs.c
"
    XtVaSetValues(selFile, XtNx, x, XtNy, y, NULL);
    XtMapWidget(selFile);

    (void)strcat(SFstartDir, ""/"");
",1,unused,2750,unused,"
    XtVaSetValues(selFile, XtNx, x, XtNy, y, NULL);
    XtMapWidget(selFile);

    (void)strcat(SFstartDir, ""/"");
",unused,vimdebstretche-src2Fgui_at_fs.c
"    XtVaSetValues(selFile, XtNx, x, XtNy, y, NULL);
    XtMapWidget(selFile);

    (void)strcat(SFstartDir, ""/"");
    (void)strcpy(SFcurrentDir, SFstartDir);
",1,unused,2751,unused,"    XtVaSetValues(selFile, XtNx, x, XtNy, y, NULL);
    XtMapWidget(selFile);

    (void)strcat(SFstartDir, ""/"");
    (void)strcpy(SFcurrentDir, SFstartDir);
",unused,vimdebstretche-src2Fgui_at_fs.c
"    if (init_path)
    {
	if (init_path[0] == '/')
	{
	    (void)strcpy(SFcurrentPath, init_path);
",1,unused,2757,unused,"    if (init_path)
    {
	if (init_path[0] == '/')
	{
	    (void)strcpy(SFcurrentPath, init_path);
",unused,vimdebstretche-src2Fgui_at_fs.c
"		SFsetText(&(SFcurrentPath[strlen(SFstartDir)]));
	}
	else
	{
	    (void)strcat(strcpy(SFcurrentPath, SFstartDir), init_path);
",1,unused,2765,unused,"		SFsetText(&(SFcurrentPath[strlen(SFstartDir)]));
	}
	else
	{
	    (void)strcat(strcpy(SFcurrentPath, SFstartDir), init_path);
",unused,vimdebstretche-src2Fgui_at_fs.c
"		SFsetText(&(SFcurrentPath[strlen(SFstartDir)]));
	}
	else
	{
	    (void)strcat(strcpy(SFcurrentPath, SFstartDir), init_path);
",1,unused,2765,unused,"		SFsetText(&(SFcurrentPath[strlen(SFstartDir)]));
	}
	else
	{
	    (void)strcat(strcpy(SFcurrentPath, SFstartDir), init_path);
",unused,vimdebstretche-src2Fgui_at_fs.c
"	    SFsetText(&(SFcurrentPath[strlen(SFstartDir)]));
	}
    }
    else
	(void)strcpy(SFcurrentPath, SFstartDir);
",1,unused,2770,unused,"	    SFsetText(&(SFcurrentPath[strlen(SFstartDir)]));
	}
    }
    else
	(void)strcpy(SFcurrentPath, SFstartDir);
",unused,vimdebstretche-src2Fgui_at_fs.c
"
    pname = vim_strnsave(name, STRLEN(name) + strlen(""-pullright""));
    if (pname != NULL)
    {
	strcat((char *)pname, ""-pullright"");
",1,unused,1141,unused,"
    pname = vim_strnsave(name, STRLEN(name) + strlen(""-pullright""));
    if (pname != NULL)
    {
	strcat((char *)pname, ""-pullright"");
",unused,vimdebstretche-src2Fgui_athena.c
"    mch_print_start_line(TRUE, page_line);

    /* Leave two spaces between the number and the text; depends on
     * PRINT_NUMBER_WIDTH. */
    sprintf((char *)tbuf, ""%6ld"", (long)lnum);
",1,unused,399,unused,"    mch_print_start_line(TRUE, page_line);

    /* Leave two spaces between the number and the text; depends on
     * PRINT_NUMBER_WIDTH. */
    sprintf((char *)tbuf, ""%6ld"", (long)lnum);
",unused,vimdebstretche-src2Fhardcopy.c
"	curwin->w_botline = tmp_botline;
    }
    else
#endif
	sprintf((char *)tbuf, _(""Page %d""), pagenum);
",1,unused,518,unused,"	curwin->w_botline = tmp_botline;
    }
    else
#endif
	sprintf((char *)tbuf, _(""Page %d""), pagenum);
",unused,vimdebstretche-src2Fhardcopy.c
"		    ui_breakcheck();
		    if (got_int || settings.user_abort)
			goto print_fail;

		    sprintf((char *)IObuff, _(""Printing page %d (%d%%)""),
",1,unused,751,unused,"		    ui_breakcheck();
		    if (got_int || settings.user_abort)
			goto print_fail;

		    sprintf((char *)IObuff, _(""Printing page %d (%d%%)""),
",unused,vimdebstretche-src2Fhardcopy.c
"		    if (!mch_print_begin_page(IObuff))
			goto print_fail;

		    if (settings.n_collated_copies > 1)
			sprintf((char *)IObuff + STRLEN(IObuff),
",1,unused,762,unused,"		    if (!mch_print_begin_page(IObuff))
			goto print_fail;

		    if (settings.n_collated_copies > 1)
			sprintf((char *)IObuff + STRLEN(IObuff),
",unused,vimdebstretche-src2Fhardcopy.c
"
print_fail:
    if (got_int || settings.user_abort)
    {
	sprintf((char *)IObuff, ""%s"", _(""Printing aborted""));
",1,unused,829,unused,"
print_fail:
    if (got_int || settings.user_abort)
    {
	sprintf((char *)IObuff, ""%s"", _(""Printing aborted""));
",unused,vimdebstretche-src2Fhardcopy.c
" */
    static void
prt_write_int(int i)
{
    sprintf((char *)prt_line_buffer, ""%d "", i);
",1,unused,1518,unused," */
    static void
prt_write_int(int i)
{
    sprintf((char *)prt_line_buffer, ""%d "", i);
",unused,vimdebstretche-src2Fhardcopy.c
" */
    static void
prt_write_boolean(int b)
{
    sprintf((char *)prt_line_buffer, ""%s "", (b ? ""T"" : ""F""));
",1,unused,1528,unused," */
    static void
prt_write_boolean(int b)
{
    sprintf((char *)prt_line_buffer, ""%s "", (b ? ""T"" : ""F""));
",unused,vimdebstretche-src2Fhardcopy.c
"			  ""/_%s /VIM-%s /%s ref\n"", new_name, encoding, font);
    prt_write_file(prt_line_buffer);
#ifdef FEAT_MBYTE
    if (prt_out_mbyte)
	sprintf((char *)prt_line_buffer, ""/%s %d %f /_%s sffs\n"",
",1,unused,1547,unused,"			  ""/_%s /VIM-%s /%s ref\n"", new_name, encoding, font);
    prt_write_file(prt_line_buffer);
#ifdef FEAT_MBYTE
    if (prt_out_mbyte)
	sprintf((char *)prt_line_buffer, ""/%s %d %f /_%s sffs\n"",
",unused,vimdebstretche-src2Fhardcopy.c
"    int     fraction;

    prt_real_bits(val, prec, &integer, &fraction);
    /* Emit integer part */
    sprintf((char *)prt_line_buffer, ""%d"", integer);
",1,unused,1623,unused,"    int     fraction;

    prt_real_bits(val, prec, &integer, &fraction);
    /* Emit integer part */
    sprintf((char *)prt_line_buffer, ""%d"", integer);
",unused,vimdebstretche-src2Fhardcopy.c
"	    prec--;
	    fraction /= 10;
	}
	/* Emit fraction left padded with zeros */
	sprintf((char *)prt_line_buffer, "".%0*d"", prec, fraction);
",1,unused,1635,unused,"	    prec--;
	    fraction /= 10;
	}
	/* Emit fraction left padded with zeros */
	sprintf((char *)prt_line_buffer, "".%0*d"", prec, fraction);
",unused,vimdebstretche-src2Fhardcopy.c
"	/* Emit fraction left padded with zeros */
	sprintf((char *)prt_line_buffer, "".%0*d"", prec, fraction);
	prt_write_file(prt_line_buffer);
    }
    sprintf((char *)prt_line_buffer, "" "");
",1,unused,1638,unused,"	/* Emit fraction left padded with zeros */
	sprintf((char *)prt_line_buffer, "".%0*d"", prec, fraction);
	prt_write_file(prt_line_buffer);
    }
    sprintf((char *)prt_line_buffer, "" "");
",unused,vimdebstretche-src2Fhardcopy.c
"    vim_snprintf((char *)prt_line_buffer, sizeof(prt_line_buffer),
								""/%s "", name);
    prt_write_file(prt_line_buffer);
    prt_write_real(value, prec);
    sprintf((char *)prt_line_buffer, ""d\n"");
",1,unused,1652,unused,"    vim_snprintf((char *)prt_line_buffer, sizeof(prt_line_buffer),
								""/%s "", name);
    prt_write_file(prt_line_buffer);
    prt_write_real(value, prec);
    sprintf((char *)prt_line_buffer, ""d\n"");
",unused,vimdebstretche-src2Fhardcopy.c
"    prt_write_file(prt_line_buffer);

    for (i = 0; i < count; i++)
    {
	sprintf((char *)prt_line_buffer, "" %d"", ints[i]);
",1,unused,2095,unused,"    prt_write_file(prt_line_buffer);

    for (i = 0; i < count; i++)
    {
	sprintf((char *)prt_line_buffer, "" %d"", ints[i]);
",unused,vimdebstretche-src2Fhardcopy.c
"     */
    if (!(duplex || collate || color || (num_copies > 1)))
	return;

    sprintf((char *)prt_line_buffer, ""%%%%Requirements:"");
",1,unused,2147,unused,"     */
    if (!(duplex || collate || color || (num_copies > 1)))
	return;

    sprintf((char *)prt_line_buffer, ""%%%%Requirements:"");
",unused,vimdebstretche-src2Fhardcopy.c
"    if (num_copies > 1)
    {
	prt_write_string("" numcopies("");
	/* Note: no space wanted so don't use prt_write_int() */
	sprintf((char *)prt_line_buffer, ""%d"", num_copies);
",1,unused,2164,unused,"    if (num_copies > 1)
    {
	prt_write_string("" numcopies("");
	/* Note: no space wanted so don't use prt_write_int() */
	sprintf((char *)prt_line_buffer, ""%d"", num_copies);
",unused,vimdebstretche-src2Fhardcopy.c
"		case ')':  ga_append(&prt_ps_buffer, IF_EB(')', 0051)); break;
		case '\\': ga_append(&prt_ps_buffer, IF_EB('\\', 0134)); break;

		default:
			   sprintf((char *)ch_buff, ""%03o"", (unsigned int)ch);
",1,unused,3565,unused,"		case ')':  ga_append(&prt_ps_buffer, IF_EB(')', 0051)); break;
		case '\\': ga_append(&prt_ps_buffer, IF_EB('\\', 0134)); break;

		default:
			   sprintf((char *)ch_buff, ""%03o"", (unsigned int)ch);
",unused,vimdebstretche-src2Fhardcopy.c
"    char *buf = (char *)alloc((unsigned)strlen(stat_emsg) + MAXPATHL + 10);

    if (buf != NULL)
    {
	(void)sprintf(buf, stat_emsg, fname, errno);
",1,unused,486,unused,"    char *buf = (char *)alloc((unsigned)strlen(stat_emsg) + MAXPATHL + 10);

    if (buf != NULL)
    {
	(void)sprintf(buf, stat_emsg, fname, errno);
",unused,vimdebstretche-src2Fif_cscope.c
"	    if (fname[0] == '\0')
		break;
	}
	if (fname[0] == '\0')
	    (void)sprintf(fname2, ""/%s"", CSCOPE_DBFILE);
",1,unused,574,unused,"	    if (fname[0] == '\0')
		break;
	}
	if (fname[0] == '\0')
	    (void)sprintf(fname2, ""/%s"", CSCOPE_DBFILE);
",unused,vimdebstretche-src2Fif_cscope.c
"	}
	if (fname[0] == '\0')
	    (void)sprintf(fname2, ""/%s"", CSCOPE_DBFILE);
	else
	    (void)sprintf(fname2, ""%s/%s"", fname, CSCOPE_DBFILE);
",1,unused,576,unused,"	}
	if (fname[0] == '\0')
	    (void)sprintf(fname2, ""/%s"", CSCOPE_DBFILE);
	else
	    (void)sprintf(fname2, ""%s/%s"", fname, CSCOPE_DBFILE);
",unused,vimdebstretche-src2Fif_cscope.c
"
    if ((cmd = (char *)alloc((unsigned)(strlen(pat) + 2))) == NULL)
	return NULL;

    (void)sprintf(cmd, ""%d%s"", search, pat);
",1,unused,790,unused,"
    if ((cmd = (char *)alloc((unsigned)(strlen(pat) + 2))) == NULL)
	return NULL;

    (void)sprintf(cmd, ""%d%s"", search, pat);
",unused,vimdebstretche-src2Fif_cscope.c
"	}

	/* run the cscope command; is there execl for non-unix systems? */
#if defined(UNIX)
	(void)sprintf(cmd, ""exec %s -dl -f %s"", prog, csinfo[i].fname);
",1,unused,935,unused,"	}

	/* run the cscope command; is there execl for non-unix systems? */
#if defined(UNIX)
	(void)sprintf(cmd, ""exec %s -dl -f %s"", prog, csinfo[i].fname);
",unused,vimdebstretche-src2Fif_cscope.c
"	(void)sprintf(cmd, ""%s -dl -f %s"", prog, csinfo[i].fname);
#endif
	if (csinfo[i].ppath != NULL)
	{
	    (void)strcat(cmd, "" -P"");
",1,unused,942,unused,"	(void)sprintf(cmd, ""%s -dl -f %s"", prog, csinfo[i].fname);
#endif
	if (csinfo[i].ppath != NULL)
	{
	    (void)strcat(cmd, "" -P"");
",unused,vimdebstretche-src2Fif_cscope.c
"#endif
	if (csinfo[i].ppath != NULL)
	{
	    (void)strcat(cmd, "" -P"");
	    (void)strcat(cmd, csinfo[i].ppath);
",1,unused,943,unused,"#endif
	if (csinfo[i].ppath != NULL)
	{
	    (void)strcat(cmd, "" -P"");
	    (void)strcat(cmd, csinfo[i].ppath);
",unused,vimdebstretche-src2Fif_cscope.c
"	    (void)strcat(cmd, csinfo[i].ppath);
	}
	if (csinfo[i].flags != NULL)
	{
	    (void)strcat(cmd, "" "");
",1,unused,947,unused,"	    (void)strcat(cmd, csinfo[i].ppath);
	}
	if (csinfo[i].flags != NULL)
	{
	    (void)strcat(cmd, "" "");
",unused,vimdebstretche-src2Fif_cscope.c
"	}
	if (csinfo[i].flags != NULL)
	{
	    (void)strcat(cmd, "" "");
	    (void)strcat(cmd, csinfo[i].flags);
",1,unused,948,unused,"	}
	if (csinfo[i].flags != NULL)
	{
	    (void)strcat(cmd, "" "");
	    (void)strcat(cmd, csinfo[i].flags);
",unused,vimdebstretche-src2Fif_cscope.c
"
	    /* strlen will be enough because we use chars */
	    if (buf != NULL)
	    {
		sprintf(buf, nf, *qfpos, *(qfpos-1));
",1,unused,1144,unused,"
	    /* strlen will be enough because we use chars */
	    if (buf != NULL)
	    {
		sprintf(buf, nf, *qfpos, *(qfpos-1));
",unused,vimdebstretche-src2Fif_cscope.c
"	if (buf == NULL)
	    (void)EMSG(nf);
	else
	{
	    sprintf(buf, nf, opt, pat);
",1,unused,1217,unused,"	if (buf == NULL)
	    (void)EMSG(nf);
	else
	{
	    sprintf(buf, nf, opt, pat);
",unused,vimdebstretche-src2Fif_cscope.c
"
    if ((csinfo[i].fname = (char *)alloc((unsigned)strlen(fname)+1)) == NULL)
	return -1;

    (void)strcpy(csinfo[i].fname, (const char *)fname);
",1,unused,1479,unused,"
    if ((csinfo[i].fname = (char *)alloc((unsigned)strlen(fname)+1)) == NULL)
	return -1;

    (void)strcpy(csinfo[i].fname, (const char *)fname);
",unused,vimdebstretche-src2Fif_cscope.c
"	    vim_free(csinfo[i].fname);
	    csinfo[i].fname = NULL;
	    return -1;
	}
	(void)strcpy(csinfo[i].ppath, (const char *)ppath);
",1,unused,1489,unused,"	    vim_free(csinfo[i].fname);
	    csinfo[i].fname = NULL;
	    return -1;
	}
	(void)strcpy(csinfo[i].ppath, (const char *)ppath);
",unused,vimdebstretche-src2Fif_cscope.c
"	    csinfo[i].fname = NULL;
	    csinfo[i].ppath = NULL;
	    return -1;
	}
	(void)strcpy(csinfo[i].flags, (const char *)flags);
",1,unused,1503,unused,"	    csinfo[i].fname = NULL;
	    csinfo[i].ppath = NULL;
	    return -1;
	}
	(void)strcpy(csinfo[i].flags, (const char *)flags);
",unused,vimdebstretche-src2Fif_cscope.c
"	amt = (int)(strlen(fname) + strlen(slno) + strlen(tagstr) + strlen(search)+6);
	if ((buf = (char *)alloc(amt)) == NULL)
	    return NULL;

	(void)sprintf(buf, ""%s\t%s\t%s;\""\t%s"", tagstr, fname, slno, search);
",1,unused,1667,unused,"	amt = (int)(strlen(fname) + strlen(slno) + strlen(tagstr) + strlen(search)+6);
	if ((buf = (char *)alloc(amt)) == NULL)
	    return NULL;

	(void)sprintf(buf, ""%s\t%s\t%s;\""\t%s"", tagstr, fname, slno, search);
",unused,vimdebstretche-src2Fif_cscope.c
"	amt = (int)(strlen(fname) + strlen(slno) + strlen(tagstr) + 5);
	if ((buf = (char *)alloc(amt)) == NULL)
	    return NULL;

	(void)sprintf(buf, ""%s\t%s\t%s;\"""", tagstr, fname, slno);
",1,unused,1675,unused,"	amt = (int)(strlen(fname) + strlen(slno) + strlen(tagstr) + 5);
	if ((buf = (char *)alloc(amt)) == NULL)
	    return NULL;

	(void)sprintf(buf, ""%s\t%s\t%s;\"""", tagstr, fname, slno);
",unused,vimdebstretche-src2Fif_cscope.c
"	   if (context == NULL)
	       continue;

	   if (strcmp(cntx, ""<global>"")==0)
	       strcpy(context, ""<<global>>"");
",1,unused,1854,unused,"	   if (context == NULL)
	       continue;

	   if (strcmp(cntx, ""<global>"")==0)
	       strcpy(context, ""<<global>>"");
",unused,vimdebstretche-src2Fif_cscope.c
"
	   if (strcmp(cntx, ""<global>"")==0)
	       strcpy(context, ""<<global>>"");
	   else
	       sprintf(context, ""<<%s>>"", cntx);
",1,unused,1856,unused,"
	   if (strcmp(cntx, ""<global>"")==0)
	       strcpy(context, ""<<global>>"");
	   else
	       sprintf(context, ""<<%s>>"", cntx);
",unused,vimdebstretche-src2Fif_cscope.c
"
    if ((tbuf = (char *)alloc((unsigned)strlen(matches[0]) + 1)) == NULL)
	return;

    strcpy(tbuf, matches[0]);
",1,unused,2009,unused,"
    if ((tbuf = (char *)alloc((unsigned)strlen(matches[0]) + 1)) == NULL)
	return;

    strcpy(tbuf, matches[0]);
",unused,vimdebstretche-src2Fif_cscope.c
"    buf = (char *)alloc(newsize);
    if (buf != NULL)
    {
	bufsize = newsize;
	(void)sprintf(buf, cstag_msg, ptag);
",1,unused,2022,unused,"    buf = (char *)alloc(newsize);
    if (buf != NULL)
    {
	bufsize = newsize;
	(void)sprintf(buf, cstag_msg, ptag);
",unused,vimdebstretche-src2Fif_cscope.c
"	 * directly, but that's too much of a hassle
	 */
	if ((tbuf = (char *)alloc((unsigned)strlen(matches[idx]) + 1)) == NULL)
	    continue;
	(void)strcpy(tbuf, matches[idx]);
",1,unused,2043,unused,"	 * directly, but that's too much of a hassle
	 */
	if ((tbuf = (char *)alloc((unsigned)strlen(matches[idx]) + 1)) == NULL)
	    continue;
	(void)strcpy(tbuf, matches[idx]);
",unused,vimdebstretche-src2Fif_cscope.c
"	}
	if (buf != NULL)
	{
	    /* csfmt_str = ""%4d %6s  ""; */
	    (void)sprintf(buf, csfmt_str, num, lno);
",1,unused,2073,unused,"	}
	if (buf != NULL)
	{
	    /* csfmt_str = ""%4d %6s  ""; */
	    (void)sprintf(buf, csfmt_str, num, lno);
",unused,vimdebstretche-src2Fif_cscope.c
"		bufsize = newsize;
	}
	if (buf != NULL)
	{
	    (void)sprintf(buf, cntxformat, context);
",1,unused,2099,unused,"		bufsize = newsize;
	}
	if (buf != NULL)
	{
	    (void)sprintf(buf, cntxformat, context);
",unused,vimdebstretche-src2Fif_cscope.c
"		/* don't use smsg_attr() because we want to display the
		 * connection number in the same line as
		 * ""Added cscope database...""
		 */
		sprintf(buf, "" (#%d)"", i);
",1,unused,2401,unused,"		/* don't use smsg_attr() because we want to display the
		 * connection number in the same line as
		 * ""Added cscope database...""
		 */
		sprintf(buf, "" (#%d)"", i);
",unused,vimdebstretche-src2Fif_cscope.c
"#endif
       )
    {
	if ((fullname = (char *)alloc(len)) != NULL)
	    (void)sprintf(fullname, ""%s/%s"", csinfo[i].ppath, name);
",1,unused,2469,unused,"#endif
       )
    {
	if ((fullname = (char *)alloc(len)) != NULL)
	    (void)sprintf(fullname, ""%s/%s"", csinfo[i].ppath, name);
",unused,vimdebstretche-src2Fif_cscope.c
"	    {
		res = -10;
		continue;
	    }
	    sprintf((char *)p, ""%s%d"", name, i++);
",1,unused,244,unused,"	    {
		res = -10;
		continue;
	    }
	    sprintf((char *)p, ""%s%d"", name, i++);
",unused,vimdebstretche-src2Fif_xcmdsrv.c
"	    return -1;
	}
	(void)LookupName(dpy, name, /*delete=*/TRUE, NULL);
    }
    sprintf((char *)propInfo, ""%x %.*s"", (int_u)commWindow,
",1,unused,303,unused,"	    return -1;
	}
	(void)LookupName(dpy, name, /*delete=*/TRUE, NULL);
    }
    sprintf((char *)propInfo, ""%x %.*s"", (int_u)commWindow,
",unused,vimdebstretche-src2Fif_xcmdsrv.c
"    if (serverName != NULL)
    {
	/* Reinsert name if we was already registered */
	(void)LookupName(dpy, serverName, /*delete=*/TRUE, NULL);
	sprintf((char *)propInfo, ""%x %.*s"",
",1,unused,354,unused,"    if (serverName != NULL)
    {
	/* Reinsert name if we was already registered */
	(void)LookupName(dpy, serverName, /*delete=*/TRUE, NULL);
	sprintf((char *)propInfo, ""%x %.*s"",
",unused,vimdebstretche-src2Fif_xcmdsrv.c
"#endif
    property = (char_u *)alloc((unsigned)length + 30);

#ifdef FEAT_MBYTE
    sprintf((char *)property, ""%c%c%c-n %s%c-E %s%c-s %s"",
",1,unused,471,unused,"#endif
    property = (char_u *)alloc((unsigned)length + 30);

#ifdef FEAT_MBYTE
    sprintf((char *)property, ""%c%c%c-n %s%c-E %s%c-s %s"",
",unused,vimdebstretche-src2Fif_xcmdsrv.c
"    if (name == loosename)
	vim_free(loosename);
    /* Add a back reference to our comm window */
    serial++;
    sprintf((char *)property + length, ""%c-r %x %d"",
",1,unused,481,unused,"    if (name == loosename)
	vim_free(loosename);
    /* Add a back reference to our comm window */
    serial++;
    sprintf((char *)property + length, ""%c-r %x %d"",
",unused,vimdebstretche-src2Fif_xcmdsrv.c
"#endif
    if ((property = (char_u *)alloc((unsigned)length + 30)) != NULL)
    {
#ifdef FEAT_MBYTE
	sprintf((char *)property, ""%cn%c-E %s%c-n %s%c-w %x"",
",1,unused,784,unused,"#endif
    if ((property = (char_u *)alloc((unsigned)length + 30)) != NULL)
    {
#ifdef FEAT_MBYTE
	sprintf((char *)property, ""%cn%c-E %s%c-n %s%c-w %x"",
",unused,vimdebstretche-src2Fif_xcmdsrv.c
"			/* Initialize the result property. */
			ga_init2(&reply, 1, 100);
#ifdef FEAT_MBYTE
			(void)ga_grow(&reply, 50 + STRLEN(p_enc));
			sprintf(reply.ga_data, ""%cr%c-E %s%c-s %s%c-r "",
",1,unused,1350,unused,"			/* Initialize the result property. */
			ga_init2(&reply, 1, 100);
#ifdef FEAT_MBYTE
			(void)ga_grow(&reply, 50 + STRLEN(p_enc));
			sprintf(reply.ga_data, ""%cr%c-E %s%c-s %s%c-r "",
",unused,vimdebstretche-src2Fif_xcmdsrv.c
"#ifdef FEAT_AUTOCMD
	    {
		char_u	winstr[30];

		sprintf((char *)winstr, ""0x%x"", (unsigned int)win);
",1,unused,1496,unused,"#ifdef FEAT_AUTOCMD
	    {
		char_u	winstr[30];

		sprintf((char *)winstr, ""0x%x"", (unsigned int)win);
",unused,vimdebstretche-src2Fif_xcmdsrv.c
"			    a = argv[0];
			p = alloc((unsigned)(STRLEN(a) + 4));
			if (p == NULL)
			    mch_exit(2);
			sprintf((char *)p, ""so %s"", a);
",1,unused,2246,unused,"			    a = argv[0];
			p = alloc((unsigned)(STRLEN(a) + 4));
			if (p == NULL)
			    mch_exit(2);
			sprintf((char *)p, ""so %s"", a);
",unused,vimdebstretche-src2Fmain.c
"    {
	p = alloc((unsigned)STRLEN(parmp->commands[0]) + 3);
	if (p != NULL)
	{
	    sprintf((char *)p, "":%s\r"", parmp->commands[0]);
",1,unused,2472,unused,"    {
	p = alloc((unsigned)STRLEN(parmp->commands[0]) + 3);
	if (p != NULL)
	{
	    sprintf((char *)p, "":%s\r"", parmp->commands[0]);
",unused,vimdebstretche-src2Fmain.c
"	}
	msg_putchar('\n');
	if (!got_int)
	{
	    sprintf((char *)IObuff, "" %c %6ld %4d "", c, p->lnum, p->col);
",1,unused,780,unused,"	}
	msg_putchar('\n');
	if (!got_int)
	{
	    sprintf((char *)IObuff, "" %c %6ld %4d "", c, p->lnum, p->col);
",unused,vimdebstretche-src2Fmark.c
"	    {
		vim_free(name);
		break;
	    }
	    sprintf((char *)IObuff, ""%c %2d %5ld %4d "",
",1,unused,912,unused,"	    {
		vim_free(name);
		break;
	    }
	    sprintf((char *)IObuff, ""%c %2d %5ld %4d "",
",unused,vimdebstretche-src2Fmark.c
"	{
	    msg_putchar('\n');
	    if (got_int)
		break;
	    sprintf((char *)IObuff, ""%c %3d %5ld %4d "",
",1,unused,958,unused,"	{
	    msg_putchar('\n');
	    if (got_int)
		break;
	    sprintf((char *)IObuff, ""%c %3d %5ld %4d "",
",unused,vimdebstretche-src2Fmark.c
"		rlen += 2;
	    }
	    clen = utf_ptr2len(line + i);
	}
	sprintf((char *)IObuff + rlen, ""%02x "",
",1,unused,3654,unused,"		rlen += 2;
	    }
	    clen = utf_ptr2len(line + i);
	}
	sprintf((char *)IObuff + rlen, ""%02x "",
",unused,vimdebstretche-src2Fmbyte.c
"	return FALSE;

    if (gui.rsrc_input_method != NULL && *gui.rsrc_input_method != NUL)
    {
	strcpy(tmp, gui.rsrc_input_method);
",1,unused,5807,unused,"	return FALSE;

    if (gui.rsrc_input_method != NULL && *gui.rsrc_input_method != NUL)
    {
	strcpy(tmp, gui.rsrc_input_method);
",unused,vimdebstretche-src2Fmbyte.c
"	    *end = NUL;

	    if (strlen(s) <= IMLEN_MAX)
	    {
		strcpy(buf, ""@im="");
",1,unused,5821,unused,"	    *end = NUL;

	    if (strlen(s) <= IMLEN_MAX)
	    {
		strcpy(buf, ""@im="");
",unused,vimdebstretche-src2Fmbyte.c
"
	    if (strlen(s) <= IMLEN_MAX)
	    {
		strcpy(buf, ""@im="");
		strcat(buf, s);
",1,unused,5822,unused,"
	    if (strlen(s) <= IMLEN_MAX)
	    {
		strcpy(buf, ""@im="");
		strcat(buf, s);
",unused,vimdebstretche-src2Fmbyte.c
"	return FALSE;
    }

    found = False;
    strcpy(tmp, gui.rsrc_preedit_type_name);
",1,unused,5874,unused,"	return FALSE;
    }

    found = False;
    strcpy(tmp, gui.rsrc_preedit_type_name);
",unused,vimdebstretche-src2Fmbyte.c
"    {
	p = (char_u *)_(""Error detected while processing %s:"");
	Buf = alloc((unsigned)(STRLEN(sourcing_name) + STRLEN(p)));
	if (Buf != NULL)
	    sprintf((char *)Buf, (char *)p, sourcing_name);
",1,unused,455,unused,"    {
	p = (char_u *)_(""Error detected while processing %s:"");
	Buf = alloc((unsigned)(STRLEN(sourcing_name) + STRLEN(p)));
	if (Buf != NULL)
	    sprintf((char *)Buf, (char *)p, sourcing_name);
",unused,vimdebstretche-src2Fmessage.c
"    {
	p = (char_u *)_(""line %4ld:"");
	Buf = alloc((unsigned)(STRLEN(p) + 20));
	if (Buf != NULL)
	    sprintf((char *)Buf, (char *)p, (long)sourcing_lnum);
",1,unused,480,unused,"    {
	p = (char_u *)_(""line %4ld:"");
	Buf = alloc((unsigned)(STRLEN(p) + 20));
	if (Buf != NULL)
	    sprintf((char *)Buf, (char *)p, (long)sourcing_lnum);
",unused,vimdebstretche-src2Fmessage.c
"msg_outnum(long n)
{
    char_u	buf[20];

    sprintf((char *)buf, ""%ld"", n);
",1,unused,1388,unused,"msg_outnum(long n)
{
    char_u	buf[20];

    sprintf((char *)buf, ""%ld"", n);
",unused,vimdebstretche-src2Fmessage.c
"			f[f_l++] = fmt_spec;
			f[f_l++] = '\0';

			if (fmt_spec == 'p')
			    str_arg_l += sprintf(tmp + str_arg_l, f, ptr_arg);
",1,unused,4710,unused,"			f[f_l++] = fmt_spec;
			f[f_l++] = '\0';

			if (fmt_spec == 'p')
			    str_arg_l += sprintf(tmp + str_arg_l, f, ptr_arg);
",unused,vimdebstretche-src2Fmessage.c
"			    /* signed */
			    switch (length_modifier)
			    {
			    case '\0':
			    case 'h': str_arg_l += sprintf(
",1,unused,4733,unused,"			    /* signed */
			    switch (length_modifier)
			    {
			    case '\0':
			    case 'h': str_arg_l += sprintf(
",unused,vimdebstretche-src2Fmessage.c
"			    case '\0':
			    case 'h': str_arg_l += sprintf(
						 tmp + str_arg_l, f, int_arg);
				      break;
			    case 'l': str_arg_l += sprintf(
",1,unused,4736,unused,"			    case '\0':
			    case 'h': str_arg_l += sprintf(
						 tmp + str_arg_l, f, int_arg);
				      break;
			    case 'l': str_arg_l += sprintf(
",unused,vimdebstretche-src2Fmessage.c
"			    case 'l': str_arg_l += sprintf(
						tmp + str_arg_l, f, long_arg);
				      break;
# ifdef FEAT_NUM64
			    case 'L': str_arg_l += sprintf(
",1,unused,4740,unused,"			    case 'l': str_arg_l += sprintf(
						tmp + str_arg_l, f, long_arg);
				      break;
# ifdef FEAT_NUM64
			    case 'L': str_arg_l += sprintf(
",unused,vimdebstretche-src2Fmessage.c
"			    /* unsigned */
			    switch (length_modifier)
			    {
			    case '\0':
			    case 'h': str_arg_l += sprintf(
",1,unused,4752,unused,"			    /* unsigned */
			    switch (length_modifier)
			    {
			    case '\0':
			    case 'h': str_arg_l += sprintf(
",unused,vimdebstretche-src2Fmessage.c
"			    case '\0':
			    case 'h': str_arg_l += sprintf(
						tmp + str_arg_l, f, uint_arg);
				      break;
			    case 'l': str_arg_l += sprintf(
",1,unused,4755,unused,"			    case '\0':
			    case 'h': str_arg_l += sprintf(
						tmp + str_arg_l, f, uint_arg);
				      break;
			    case 'l': str_arg_l += sprintf(
",unused,vimdebstretche-src2Fmessage.c
"			    case 'l': str_arg_l += sprintf(
					       tmp + str_arg_l, f, ulong_arg);
				      break;
# ifdef FEAT_NUM64
			    case 'L': str_arg_l += sprintf(
",1,unused,4759,unused,"			    case 'l': str_arg_l += sprintf(
					       tmp + str_arg_l, f, ulong_arg);
				      break;
# ifdef FEAT_NUM64
			    case 'L': str_arg_l += sprintf(
",unused,vimdebstretche-src2Fmessage.c
"								&& abs_f > 1.0)
				    max_prec -= (size_t)log10(abs_f);
				if (precision > max_prec)
				    precision = max_prec;
				l += sprintf(format + l, "".%d"", (int)precision);
",1,unused,4900,unused,"								&& abs_f > 1.0)
				    max_prec -= (size_t)log10(abs_f);
				if (precision > max_prec)
				    precision = max_prec;
				l += sprintf(format + l, "".%d"", (int)precision);
",unused,vimdebstretche-src2Fmessage.c
"			    }
			    format[l] = fmt_spec == 'F' ? 'f' : fmt_spec;
			    format[l + 1] = NUL;

			    str_arg_l = sprintf(tmp, format, f);
",1,unused,4905,unused,"			    }
			    format[l] = fmt_spec == 'F' ? 'f' : fmt_spec;
			    format[l + 1] = NUL;

			    str_arg_l = sprintf(tmp, format, f);
",unused,vimdebstretche-src2Fmessage.c
"	    /* success, login */
	    vim_snprintf(buf, sizeof(buf), ""AUTH %s\n"", password);
	    nb_send(buf, ""netbeans_connect"");

	    sprintf(buf, ""0:version=0 \""%s\""\n"", ExtEdProtocolVersion);
",1,unused,231,unused,"	    /* success, login */
	    vim_snprintf(buf, sizeof(buf), ""AUTH %s\n"", password);
	    nb_send(buf, ""netbeans_connect"");

	    sprintf(buf, ""0:version=0 \""%s\""\n"", ExtEdProtocolVersion);
",unused,vimdebstretche-src2Fnetbeans.c
"	    continue;
	if (netbeansForcedQuit)
	{
	    /* mark as unmodified so NetBeans won't put up dialog on ""killed"" */
	    sprintf(buf, ""%d:unmodified=%d\n"", i, r_cmdno);
",1,unused,749,unused,"	    continue;
	if (netbeansForcedQuit)
	{
	    /* mark as unmodified so NetBeans won't put up dialog on ""killed"" */
	    sprintf(buf, ""%d:unmodified=%d\n"", i, r_cmdno);
",unused,vimdebstretche-src2Fnetbeans.c
"	    sprintf(buf, ""%d:unmodified=%d\n"", i, r_cmdno);
	    nbdebug((""EVT: %s"", buf));
	    nb_send(buf, ""netbeans_end"");
	}
	sprintf(buf, ""%d:killed=%d\n"", i, r_cmdno);
",1,unused,753,unused,"	    sprintf(buf, ""%d:unmodified=%d\n"", i, r_cmdno);
	    nbdebug((""EVT: %s"", buf));
	    nb_send(buf, ""netbeans_end"");
	}
	sprintf(buf, ""%d:killed=%d\n"", i, r_cmdno);
",unused,vimdebstretche-src2Fnetbeans.c
"    /* Avoid printing an annoying error message. */
    if (!NETBEANS_OPEN)
	return;

    sprintf(reply, ""%d\n"", cmdno);
",1,unused,787,unused,"    /* Avoid printing an annoying error message. */
    if (!NETBEANS_OPEN)
	return;

    sprintf(reply, ""%d\n"", cmdno);
",unused,vimdebstretche-src2Fnetbeans.c
"
    nbdebug((""REP %d: %s\n"", cmdno, (char *)result));

    reply = alloc((unsigned)STRLEN(result) + 32);
    sprintf((char *)reply, ""%d %s\n"", cmdno, (char *)result);
",1,unused,804,unused,"
    nbdebug((""REP %d: %s\n"", cmdno, (char *)result));

    reply = alloc((unsigned)STRLEN(result) + 32);
    sprintf((char *)reply, ""%d %s\n"", cmdno, (char *)result);
",unused,vimdebstretche-src2Fnetbeans.c
"    char reply[32];

    nbdebug((""REP %d: %ld\n"", cmdno, result));

    sprintf(reply, ""%d %ld\n"", cmdno, result);
",1,unused,821,unused,"    char reply[32];

    nbdebug((""REP %d: %ld\n"", cmdno, result));

    sprintf(reply, ""%d %ld\n"", cmdno, result);
",unused,vimdebstretche-src2Fnetbeans.c
"
	    /* Note: nb_getbufno() may return -1.  This indicates the IDE
	     * didn't assign a number to the current buffer in response to a
	     * fileOpened event. */
	    sprintf((char *)text, ""%d %ld %d %ld"",
",1,unused,1030,unused,"
	    /* Note: nb_getbufno() may return -1.  This indicates the IDE
	     * didn't assign a number to the current buffer in response to a
	     * fileOpened event. */
	    sprintf((char *)text, ""%d %ld %d %ld"",
",unused,vimdebstretche-src2Fnetbeans.c
"	    }
	    tok++;
	}

	strcpy(&keybuf[i], tok);
",1,unused,2362,unused,"	    }
	    tok++;
	}

	strcpy(&keybuf[i], tok);
",unused,vimdebstretche-src2Fnetbeans.c
"    }

    buf[0] = '\0';
    if (ctrl)
	strcat(buf, ""C"");
",1,unused,2479,unused,"    }

    buf[0] = '\0';
    if (ctrl)
	strcat(buf, ""C"");
",unused,vimdebstretche-src2Fnetbeans.c
"    buf[0] = '\0';
    if (ctrl)
	strcat(buf, ""C"");
    if (shift)
	strcat(buf, ""S"");
",1,unused,2481,unused,"    buf[0] = '\0';
    if (ctrl)
	strcat(buf, ""C"");
    if (shift)
	strcat(buf, ""S"");
",unused,vimdebstretche-src2Fnetbeans.c
"	strcat(buf, ""C"");
    if (shift)
	strcat(buf, ""S"");
    if (alt)
	strcat(buf, ""M""); /* META */
",1,unused,2483,unused,"	strcat(buf, ""C"");
    if (shift)
	strcat(buf, ""S"");
    if (alt)
	strcat(buf, ""M""); /* META */
",unused,vimdebstretche-src2Fnetbeans.c
"	strcat(buf, ""S"");
    if (alt)
	strcat(buf, ""M""); /* META */
    if (ctrl || shift || alt)
	strcat(buf, ""-"");
",1,unused,2485,unused,"	strcat(buf, ""S"");
    if (alt)
	strcat(buf, ""M""); /* META */
    if (ctrl || shift || alt)
	strcat(buf, ""-"");
",unused,vimdebstretche-src2Fnetbeans.c
"    if (alt)
	strcat(buf, ""M""); /* META */
    if (ctrl || shift || alt)
	strcat(buf, ""-"");
    strcat(buf, name);
",1,unused,2486,unused,"    if (alt)
	strcat(buf, ""M""); /* META */
    if (ctrl || shift || alt)
	strcat(buf, ""-"");
    strcat(buf, name);
",unused,vimdebstretche-src2Fnetbeans.c
"    char buf[128];

    if (NETBEANS_OPEN)
    {
	sprintf(buf, ""0:disconnect=%d\n"", r_cmdno);
",1,unused,2593,unused,"    char buf[128];

    if (NETBEANS_OPEN)
    {
	sprintf(buf, ""0:disconnect=%d\n"", r_cmdno);
",unused,vimdebstretche-src2Fnetbeans.c
"
    if (!NETBEANS_OPEN)
	return;

    sprintf(buf, ""0:geometry=%d %d %d %d %d\n"",
",1,unused,2628,unused,"
    if (!NETBEANS_OPEN)
	return;

    sprintf(buf, ""0:geometry=%d %d %d %d %d\n"",
",unused,vimdebstretche-src2Fnetbeans.c
"
    nbdebug((""netbeans_file_killed:\n""));
    nbdebug((""    Killing bufno: %d"", bufno));

    sprintf(buffer, ""%d:killed=%d\n"", bufno, r_cmdno);
",1,unused,2720,unused,"
    nbdebug((""netbeans_file_killed:\n""));
    nbdebug((""    Killing bufno: %d"", bufno));

    sprintf(buffer, ""%d:killed=%d\n"", bufno, r_cmdno);
",unused,vimdebstretche-src2Fnetbeans.c
"    p = nb_quote(newtxt);
    if (p != NULL)
    {
	buf = alloc(128 + 2*newlen);
	sprintf((char *)buf, ""%d:insert=%d %ld \""%s\""\n"",
",1,unused,2797,unused,"    p = nb_quote(newtxt);
    if (p != NULL)
    {
	buf = alloc(128 + 2*newlen);
	sprintf((char *)buf, ""%d:insert=%d %ld \""%s\""\n"",
",unused,vimdebstretche-src2Fnetbeans.c
"    pos.col = col;

    off = pos2off(bufp, &pos);

    sprintf((char *)buf, ""%d:remove=%d %ld %ld\n"", bufno, r_cmdno, off, len);
",1,unused,2843,unused,"    pos.col = col;

    off = pos2off(bufp, &pos);

    sprintf((char *)buf, ""%d:remove=%d %ld %ld\n"", bufno, r_cmdno, off, len);
",unused,vimdebstretche-src2Fnetbeans.c
"			      - ((curwin->w_p_nu || curwin->w_p_rnu) ? 9 : 1);
	long off = pos2off(curbuf, &curwin->w_cursor);

	/* sync the cursor position */
	sprintf(buf, ""%d:newDotAndMark=%d %ld %ld\n"", bufno, r_cmdno, off, off);
",1,unused,2880,unused,"			      - ((curwin->w_p_nu || curwin->w_p_rnu) ? 9 : 1);
	long off = pos2off(curbuf, &curwin->w_cursor);

	/* sync the cursor position */
	sprintf(buf, ""%d:newDotAndMark=%d %ld %ld\n"", bufno, r_cmdno, off, off);
",unused,vimdebstretche-src2Fnetbeans.c
"	sprintf(buf, ""%d:newDotAndMark=%d %ld %ld\n"", bufno, r_cmdno, off, off);
	nbdebug((""EVT: %s"", buf));
	nb_send(buf, ""netbeans_button_release[newDotAndMark]"");

	sprintf(buf, ""%d:buttonRelease=%d %d %ld %d\n"", bufno, r_cmdno,
",1,unused,2884,unused,"	sprintf(buf, ""%d:newDotAndMark=%d %ld %ld\n"", bufno, r_cmdno, off, off);
	nbdebug((""EVT: %s"", buf));
	nb_send(buf, ""netbeans_button_release[newDotAndMark]"");

	sprintf(buf, ""%d:buttonRelease=%d %d %ld %d\n"", bufno, r_cmdno,
",unused,vimdebstretche-src2Fnetbeans.c
"    }

    /* sync the cursor position */
    off = pos2off(curbuf, &curwin->w_cursor);
    sprintf(buf, ""%d:newDotAndMark=%d %ld %ld\n"", bufno, r_cmdno, off, off);
",1,unused,2947,unused,"    }

    /* sync the cursor position */
    off = pos2off(curbuf, &curwin->w_cursor);
    sprintf(buf, ""%d:newDotAndMark=%d %ld %ld\n"", bufno, r_cmdno, off, off);
",unused,vimdebstretche-src2Fnetbeans.c
"	return;

    nbbuf->modified = 0;

    sprintf((char *)buf, ""%d:save=%d\n"", bufno, r_cmdno);
",1,unused,2991,unused,"	return;

    nbbuf->modified = 0;

    sprintf((char *)buf, ""%d:save=%d\n"", bufno, r_cmdno);
",unused,vimdebstretche-src2Fnetbeans.c
"    /* Don't mark as modified for initial read */
    if (nbbuf->insertDone)
	nbbuf->modified = 1;

    sprintf((char *)buf, ""%d:remove=%d 0 -1\n"", bufno, r_cmdno);
",1,unused,3018,unused,"    /* Don't mark as modified for initial read */
    if (nbbuf->insertDone)
	nbbuf->modified = 1;

    sprintf((char *)buf, ""%d:remove=%d 0 -1\n"", bufno, r_cmdno);
",unused,vimdebstretche-src2Fnetbeans.c
"	    int value;

	    value = strtol((char *)fg, &ptr, 10);
	    if (ptr != (char *)fg)
		sprintf(fgbuf, ""guifg=#%06x"", value & 0xFFFFFF);
",1,unused,3228,unused,"	    int value;

	    value = strtol((char *)fg, &ptr, 10);
	    if (ptr != (char *)fg)
		sprintf(fgbuf, ""guifg=#%06x"", value & 0xFFFFFF);
",unused,vimdebstretche-src2Fnetbeans.c
"	    value = strtol((char *)fg, &ptr, 10);
	    if (ptr != (char *)fg)
		sprintf(fgbuf, ""guifg=#%06x"", value & 0xFFFFFF);
	    else
		sprintf(fgbuf, ""guifg=%s ctermfg=%s"", fg, fg);
",1,unused,3230,unused,"	    value = strtol((char *)fg, &ptr, 10);
	    if (ptr != (char *)fg)
		sprintf(fgbuf, ""guifg=#%06x"", value & 0xFFFFFF);
	    else
		sprintf(fgbuf, ""guifg=%s ctermfg=%s"", fg, fg);
",unused,vimdebstretche-src2Fnetbeans.c
"		sprintf(fgbuf, ""guifg=%s ctermfg=%s"", fg, fg);

	    value = strtol((char *)bg, &ptr, 10);
	    if (ptr != (char *)bg)
		sprintf(bgbuf, ""guibg=#%06x"", value & 0xFFFFFF);
",1,unused,3234,unused,"		sprintf(fgbuf, ""guifg=%s ctermfg=%s"", fg, fg);

	    value = strtol((char *)bg, &ptr, 10);
	    if (ptr != (char *)bg)
		sprintf(bgbuf, ""guibg=#%06x"", value & 0xFFFFFF);
",unused,vimdebstretche-src2Fnetbeans.c
"	    value = strtol((char *)bg, &ptr, 10);
	    if (ptr != (char *)bg)
		sprintf(bgbuf, ""guibg=#%06x"", value & 0xFFFFFF);
	    else
		sprintf(bgbuf, ""guibg=%s ctermbg=%s"", bg, bg);
",1,unused,3236,unused,"	    value = strtol((char *)bg, &ptr, 10);
	    if (ptr != (char *)bg)
		sprintf(bgbuf, ""guibg=#%06x"", value & 0xFFFFFF);
	    else
		sprintf(bgbuf, ""guibg=%s ctermbg=%s"", bg, bg);
",unused,vimdebstretche-src2Fnetbeans.c
"	    getvcols(curwin, &curwin->w_cursor, &VIsual, &leftcol, &rightcol);
# ifdef FEAT_LINEBREAK
	    p_sbr = saved_sbr;
# endif
	    sprintf((char *)showcmd_buf, ""%ldx%ld"", lines,
",1,unused,3782,unused,"	    getvcols(curwin, &curwin->w_cursor, &VIsual, &leftcol, &rightcol);
# ifdef FEAT_LINEBREAK
	    p_sbr = saved_sbr;
# endif
	    sprintf((char *)showcmd_buf, ""%ldx%ld"", lines,
",unused,vimdebstretche-src2Fnormal.c
"	    sprintf((char *)showcmd_buf, ""%ldx%ld"", lines,
					      (long)(rightcol - leftcol + 1));
	}
	else if (VIsual_mode == 'V' || VIsual.lnum != curwin->w_cursor.lnum)
	    sprintf((char *)showcmd_buf, ""%ld"", lines);
",1,unused,3786,unused,"	    sprintf((char *)showcmd_buf, ""%ldx%ld"", lines,
					      (long)(rightcol - leftcol + 1));
	}
	else if (VIsual_mode == 'V' || VIsual.lnum != curwin->w_cursor.lnum)
	    sprintf((char *)showcmd_buf, ""%ld"", lines);
",unused,vimdebstretche-src2Fnormal.c
"		++chars;
		s += l;
	    }
	    if (bytes == chars)
		sprintf((char *)showcmd_buf, ""%d"", chars);
",1,unused,3822,unused,"		++chars;
		s += l;
	    }
	    if (bytes == chars)
		sprintf((char *)showcmd_buf, ""%d"", chars);
",unused,vimdebstretche-src2Fnormal.c
"	    }
	    if (bytes == chars)
		sprintf((char *)showcmd_buf, ""%d"", chars);
	    else
		sprintf((char *)showcmd_buf, ""%d-%d"", chars, bytes);
",1,unused,3824,unused,"	    }
	    if (bytes == chars)
		sprintf((char *)showcmd_buf, ""%d"", chars);
	    else
		sprintf((char *)showcmd_buf, ""%d-%d"", chars, bytes);
",unused,vimdebstretche-src2Fnormal.c
"	return FAIL;

    /* Put ""\V"" before the pattern to avoid that the special meaning of "".""
     * and ""~"" causes trouble. */
    sprintf((char *)pat, vim_iswordp(ptr) ? ""\\V\\<%.*s\\>"" : ""\\V%.*s"",
",1,unused,4327,unused,"	return FAIL;

    /* Put ""\V"" before the pattern to avoid that the special meaning of "".""
     * and ""~"" causes trouble. */
    sprintf((char *)pat, vim_iswordp(ptr) ? ""\\V\\<%.*s\\>"" : ""\\V%.*s"",
",unused,vimdebstretche-src2Fnormal.c
"		 * really what we want? */
		isman = (STRCMP(kp, ""man"") == 0);
		isman_s = (STRCMP(kp, ""man -s"") == 0);
		if (cap->count0 != 0 && !(isman || isman_s))
		    sprintf((char *)buf, "".,.+%ld"", cap->count0 - 1);
",1,unused,5679,unused,"		 * really what we want? */
		isman = (STRCMP(kp, ""man"") == 0);
		isman_s = (STRCMP(kp, ""man -s"") == 0);
		if (cap->count0 != 0 && !(isman || isman_s))
		    sprintf((char *)buf, "".,.+%ld"", cap->count0 - 1);
",unused,vimdebstretche-src2Fnormal.c
"		    STRCAT(buf, kp);
		STRCAT(buf, "" "");
		if (cap->count0 != 0 && (isman || isman_s))
		{
		    sprintf((char *)buf + STRLEN(buf), ""%ld"", cap->count0);
",1,unused,5689,unused,"		    STRCAT(buf, kp);
		STRCAT(buf, "" "");
		if (cap->count0 != 0 && (isman || isman_s))
		{
		    sprintf((char *)buf + STRLEN(buf), ""%ld"", cap->count0);
",unused,vimdebstretche-src2Fnormal.c
"	    {
		if (g_cmd)
		    STRCPY(buf, ""tj "");
		else
		    sprintf((char *)buf, ""%ldta "", cap->count0);
",1,unused,5714,unused,"	    {
		if (g_cmd)
		    STRCPY(buf, ""tj "");
		else
		    sprintf((char *)buf, ""%ldta "", cap->count0);
",unused,vimdebstretche-src2Fnormal.c
"	    s = (char_u *)""<"";
	if (oap->line_count == 1)
	{
	    if (amount == 1)
		sprintf((char *)IObuff, _(""1 line %sed 1 time""), s);
",1,unused,290,unused,"	    s = (char_u *)""<"";
	if (oap->line_count == 1)
	{
	    if (amount == 1)
		sprintf((char *)IObuff, _(""1 line %sed 1 time""), s);
",unused,vimdebstretche-src2Fops.c
"	{
	    if (amount == 1)
		sprintf((char *)IObuff, _(""1 line %sed 1 time""), s);
	    else
		sprintf((char *)IObuff, _(""1 line %sed %d times""), s, amount);
",1,unused,292,unused,"	{
	    if (amount == 1)
		sprintf((char *)IObuff, _(""1 line %sed 1 time""), s);
	    else
		sprintf((char *)IObuff, _(""1 line %sed %d times""), s, amount);
",unused,vimdebstretche-src2Fops.c
"	}
	else
	{
	    if (amount == 1)
		sprintf((char *)IObuff, _(""%ld lines %sed 1 time""),
",1,unused,297,unused,"	}
	else
	{
	    if (amount == 1)
		sprintf((char *)IObuff, _(""%ld lines %sed 1 time""),
",unused,vimdebstretche-src2Fops.c
"	    if (amount == 1)
		sprintf((char *)IObuff, _(""%ld lines %sed 1 time""),
							  oap->line_count, s);
	    else
		sprintf((char *)IObuff, _(""%ld lines %sed %d times""),
",1,unused,300,unused,"	    if (amount == 1)
		sprintf((char *)IObuff, _(""%ld lines %sed 1 time""),
							  oap->line_count, s);
	    else
		sprintf((char *)IObuff, _(""%ld lines %sed %d times""),
",unused,vimdebstretche-src2Fops.c
"	    case MBLOCK:
		type = (char_u *)""BLOCK"";
		break;
	    default:
		sprintf((char *)IObuff, _(""E574: Unknown register type %d""),
",1,unused,6213,unused,"	    case MBLOCK:
		type = (char_u *)""BLOCK"";
		break;
	    default:
		sprintf((char *)IObuff, _(""E574: Unknown register type %d""),
",unused,vimdebstretche-src2Fops.c
"			if (saved_origval != NULL)
			{
			    char_u buf_type[7];

			    sprintf((char *)buf_type, ""%s"",
",1,unused,5000,unused,"			if (saved_origval != NULL)
			{
			    char_u buf_type[7];

			    sprintf((char *)buf_type, ""%s"",
",unused,vimdebstretche-src2Foption.c
"illegal_char(char_u *errbuf, int c)
{
    if (errbuf == NULL)
	return (char_u *)"""";
    sprintf((char *)errbuf, _(""E539: Illegal character <%s>""),
",1,unused,5137,unused,"illegal_char(char_u *errbuf, int c)
{
    if (errbuf == NULL)
	return (char_u *)"""";
    sprintf((char *)errbuf, _(""E539: Illegal character <%s>""),
",unused,vimdebstretche-src2Foption.c
"#if defined(FEAT_AUTOCMD) && defined(FEAT_EVAL)
	if (saved_oldval != NULL)
	{
	    char_u buf_type[7];
	    sprintf((char *)buf_type, ""%s"",
",1,unused,5815,unused,"#if defined(FEAT_AUTOCMD) && defined(FEAT_EVAL)
	if (saved_oldval != NULL)
	{
	    char_u buf_type[7];
	    sprintf((char *)buf_type, ""%s"",
",unused,vimdebstretche-src2Foption.c
"		if (!VIM_ISDIGIT(*(s - 1)))
		{
		    if (errbuf != NULL)
		    {
			sprintf((char *)errbuf,
",1,unused,6558,unused,"		if (!VIM_ISDIGIT(*(s - 1)))
		{
		    if (errbuf != NULL)
		    {
			sprintf((char *)errbuf,
",unused,vimdebstretche-src2Foption.c
"		else
		{
		    if (errbuf != NULL)
		    {
			sprintf((char *)errbuf,
",1,unused,6998,unused,"		else
		{
		    if (errbuf != NULL)
		    {
			sprintf((char *)errbuf,
",unused,vimdebstretche-src2Foption.c
"	    STRCPY(NameBuff, get_special_key_name((int)wc, 0));
	else if (wc != 0)
	    STRCPY(NameBuff, transchar((int)wc));
	else
	    sprintf((char *)NameBuff, ""%ld"", *(long *)varp);
",1,unused,11470,unused,"	    STRCPY(NameBuff, get_special_key_name((int)wc, 0));
	else if (wc != 0)
	    STRCPY(NameBuff, transchar((int)wc));
	else
	    sprintf((char *)NameBuff, ""%ld"", *(long *)varp);
",unused,vimdebstretche-src2Foption.c
"    }

    /* No translation, it may call malloc(). */
#ifdef SIGHASARG
    sprintf((char *)IObuff, ""Vim: Caught deadly signal %s\n"",
",1,unused,1140,unused,"    }

    /* No translation, it may call malloc(). */
#ifdef SIGHASARG
    sprintf((char *)IObuff, ""Vim: Caught deadly signal %s\n"",
",unused,vimdebstretche-src2Fos_unix.c
"	vim_strncpy(s, (char_u *)pw->pw_name, len - 1);
	return OK;
    }
#endif
    sprintf((char *)s, ""%d"", (int)uid);	    /* assumes s is long enough */
",1,unused,2373,unused,"	vim_strncpy(s, (char_u *)pw->pw_name, len - 1);
	return OK;
    }
#endif
    sprintf((char *)s, ""%d"", (int)uid);	    /* assumes s is long enough */
",unused,vimdebstretche-src2Fos_unix.c
"
    /* Simulate to have a dumb terminal (for now) */
# ifdef HAVE_SETENV
    setenv(""TERM"", ""dumb"", 1);
    sprintf((char *)envbuf, ""%ld"", Rows);
",1,unused,4058,unused,"
    /* Simulate to have a dumb terminal (for now) */
# ifdef HAVE_SETENV
    setenv(""TERM"", ""dumb"", 1);
    sprintf((char *)envbuf, ""%ld"", Rows);
",unused,vimdebstretche-src2Fos_unix.c
"# ifdef HAVE_SETENV
    setenv(""TERM"", ""dumb"", 1);
    sprintf((char *)envbuf, ""%ld"", Rows);
    setenv(""ROWS"", (char *)envbuf, 1);
    sprintf((char *)envbuf, ""%ld"", Rows);
",1,unused,4060,unused,"# ifdef HAVE_SETENV
    setenv(""TERM"", ""dumb"", 1);
    sprintf((char *)envbuf, ""%ld"", Rows);
    setenv(""ROWS"", (char *)envbuf, 1);
    sprintf((char *)envbuf, ""%ld"", Rows);
",unused,vimdebstretche-src2Fos_unix.c
"    sprintf((char *)envbuf, ""%ld"", Rows);
    setenv(""ROWS"", (char *)envbuf, 1);
    sprintf((char *)envbuf, ""%ld"", Rows);
    setenv(""LINES"", (char *)envbuf, 1);
    sprintf((char *)envbuf, ""%ld"", Columns);
",1,unused,4062,unused,"    sprintf((char *)envbuf, ""%ld"", Rows);
    setenv(""ROWS"", (char *)envbuf, 1);
    sprintf((char *)envbuf, ""%ld"", Rows);
    setenv(""LINES"", (char *)envbuf, 1);
    sprintf((char *)envbuf, ""%ld"", Columns);
",unused,vimdebstretche-src2Fos_unix.c
"	    if (idx < FMT_PATTERNS)
	    {
		if (fmt_ptr->addr[idx])
		{
		    sprintf((char *)errmsg,
",1,unused,244,unused,"	    if (idx < FMT_PATTERNS)
	    {
		if (fmt_ptr->addr[idx])
		{
		    sprintf((char *)errmsg,
",unused,vimdebstretche-src2Fquickfix.c
"			|| (idx == 6
			    && vim_strchr((char_u *)""OPQ"",
				fmt_ptr->prefix) == NULL))
		{
		    sprintf((char *)errmsg,
",1,unused,257,unused,"			|| (idx == 6
			    && vim_strchr((char_u *)""OPQ"",
				fmt_ptr->prefix) == NULL))
		{
		    sprintf((char *)errmsg,
",unused,vimdebstretche-src2Fquickfix.c
"		}
		else
		{
		    /* TODO: scanf()-like: %*ud, %*3c, %*f, ... ? */
		    sprintf((char *)errmsg,
",1,unused,333,unused,"		}
		else
		{
		    /* TODO: scanf()-like: %*ud, %*3c, %*f, ... ? */
		    sprintf((char *)errmsg,
",unused,vimdebstretche-src2Fquickfix.c
"		if (vim_strchr((char_u *)""DXAEWICZGOPQ"", *efmp) != NULL)
		    fmt_ptr->prefix = *efmp;
		else
		{
		    sprintf((char *)errmsg,
",1,unused,353,unused,"		if (vim_strchr((char_u *)""DXAEWICZGOPQ"", *efmp) != NULL)
		    fmt_ptr->prefix = *efmp;
		else
		{
		    sprintf((char *)errmsg,
",unused,vimdebstretche-src2Fquickfix.c
"		}
	    }
	    else
	    {
		sprintf((char *)errmsg,
",1,unused,361,unused,"		}
	    }
	    else
	    {
		sprintf((char *)errmsg,
",unused,vimdebstretche-src2Fquickfix.c
"	char_u *p = alloc((int)STRLEN(title) + 2);

	qi->qf_lists[qi->qf_curlist].qf_title = p;
	if (p != NULL)
	    sprintf((char *)p, "":%s"", (char *)title);
",1,unused,1302,unused,"	char_u *p = alloc((int)STRLEN(title) + 2);

	qi->qf_lists[qi->qf_curlist].qf_title = p;
	if (p != NULL)
	    sprintf((char *)p, "":%s"", (char *)title);
",unused,vimdebstretche-src2Fquickfix.c
"	    /* Update the screen before showing the message, unless the screen
	     * scrolled up. */
	    if (!msg_scrolled)
		update_topline_redraw();
	    sprintf((char *)IObuff, _(""(%d of %d)%s%s: ""), qf_index,
",1,unused,2375,unused,"	    /* Update the screen before showing the message, unless the screen
	     * scrolled up. */
	    if (!msg_scrolled)
		update_topline_redraw();
	    sprintf((char *)IObuff, _(""(%d of %d)%s%s: ""), qf_index,
",unused,vimdebstretche-src2Fquickfix.c
"		if (qfp->qf_type == 1)	/* :helpgrep */
		    fname = gettail(fname);
	    }
	    if (fname == NULL)
		sprintf((char *)IObuff, ""%2d"", i);
",1,unused,2516,unused,"		if (qfp->qf_type == 1)	/* :helpgrep */
		    fname = gettail(fname);
	    }
	    if (fname == NULL)
		sprintf((char *)IObuff, ""%2d"", i);
",unused,vimdebstretche-src2Fquickfix.c
"					   ? hl_attr(HLF_L) : hl_attr(HLF_D));
	    if (qfp->qf_lnum == 0)
		IObuff[0] = NUL;
	    else if (qfp->qf_col == 0)
		sprintf((char *)IObuff, "":%ld"", qfp->qf_lnum);
",1,unused,2525,unused,"					   ? hl_attr(HLF_L) : hl_attr(HLF_D));
	    if (qfp->qf_lnum == 0)
		IObuff[0] = NUL;
	    else if (qfp->qf_col == 0)
		sprintf((char *)IObuff, "":%ld"", qfp->qf_lnum);
",unused,vimdebstretche-src2Fquickfix.c
"		IObuff[0] = NUL;
	    else if (qfp->qf_col == 0)
		sprintf((char *)IObuff, "":%ld"", qfp->qf_lnum);
	    else
		sprintf((char *)IObuff, "":%ld col %d"",
",1,unused,2527,unused,"		IObuff[0] = NUL;
	    else if (qfp->qf_col == 0)
		sprintf((char *)IObuff, "":%ld"", qfp->qf_lnum);
	    else
		sprintf((char *)IObuff, "":%ld col %d"",
",unused,vimdebstretche-src2Fquickfix.c
"		sprintf((char *)IObuff, "":%ld"", qfp->qf_lnum);
	    else
		sprintf((char *)IObuff, "":%ld col %d"",
						   qfp->qf_lnum, qfp->qf_col);
	    sprintf((char *)IObuff + STRLEN(IObuff), ""%s:"",
",1,unused,2529,unused,"		sprintf((char *)IObuff, "":%ld"", qfp->qf_lnum);
	    else
		sprintf((char *)IObuff, "":%ld col %d"",
						   qfp->qf_lnum, qfp->qf_col);
	    sprintf((char *)IObuff + STRLEN(IObuff), ""%s:"",
",unused,vimdebstretche-src2Fquickfix.c
"
    if (nr <= 0)
	return p;

    sprintf((char *)buf, ""%s %3d"", (char *)p, nr);
",1,unused,2810,unused,"
    if (nr <= 0)
	return p;

    sprintf((char *)buf, ""%s %3d"", (char *)p, nr);
",unused,vimdebstretche-src2Fquickfix.c
"	    IObuff[len++] = '|';

	    if (qfp->qf_lnum > 0)
	    {
		sprintf((char *)IObuff + len, ""%ld"", qfp->qf_lnum);
",1,unused,3284,unused,"	    IObuff[len++] = '|';

	    if (qfp->qf_lnum > 0)
	    {
		sprintf((char *)IObuff + len, ""%ld"", qfp->qf_lnum);
",unused,vimdebstretche-src2Fquickfix.c
"		len += (int)STRLEN(IObuff + len);

		if (qfp->qf_col > 0)
		{
		    sprintf((char *)IObuff + len, "" col %d"", qfp->qf_col);
",1,unused,3289,unused,"		len += (int)STRLEN(IObuff + len);

		if (qfp->qf_col > 0)
		{
		    sprintf((char *)IObuff + len, "" col %d"", qfp->qf_col);
",unused,vimdebstretche-src2Fquickfix.c
"		    sprintf((char *)IObuff + len, "" col %d"", qfp->qf_col);
		    len += (int)STRLEN(IObuff + len);
		}

		sprintf((char *)IObuff + len, ""%s"",
",1,unused,3293,unused,"		    sprintf((char *)IObuff + len, "" col %d"", qfp->qf_col);
		    len += (int)STRLEN(IObuff + len);
		}

		sprintf((char *)IObuff + len, ""%s"",
",unused,vimdebstretche-src2Fquickfix.c
"	len += (unsigned)STRLEN(p_sp) + (unsigned)STRLEN(fname) + 3;
    cmd = alloc(len);
    if (cmd == NULL)
	return;
    sprintf((char *)cmd, ""%s%s%s"", (char *)p_shq, (char *)eap->arg,
",1,unused,3487,unused,"	len += (unsigned)STRLEN(p_sp) + (unsigned)STRLEN(fname) + 3;
    cmd = alloc(len);
    if (cmd == NULL)
	return;
    sprintf((char *)cmd, ""%s%s%s"", (char *)p_shq, (char *)eap->arg,
",unused,vimdebstretche-src2Fquickfix.c
"	name = alloc((unsigned)STRLEN(p_mef) + 30);
	if (name == NULL)
	    break;
	STRCPY(name, p_mef);
	sprintf((char *)name + (p - p_mef), ""%d%d"", start, off);
",1,unused,3579,unused,"	name = alloc((unsigned)STRLEN(p_mef) + 30);
	if (name == NULL)
	    break;
	STRCPY(name, p_mef);
	sprintf((char *)name + (p - p_mef), ""%d%d"", start, off);
",unused,vimdebstretche-src2Fquickfix.c
"    if (re_multi_type(peekchr()) != NOT_MULTI)
    {
	/* Can't have a multi follow a multi. */
	if (peekchr() == Magic('*'))
	    sprintf((char *)IObuff, _(""E61: Nested %s*""),
",1,unused,1880,unused,"    if (re_multi_type(peekchr()) != NOT_MULTI)
    {
	/* Can't have a multi follow a multi. */
	if (peekchr() == Magic('*'))
	    sprintf((char *)IObuff, _(""E61: Nested %s*""),
",unused,vimdebstretche-src2Fregexp.c
"	if (peekchr() == Magic('*'))
	    sprintf((char *)IObuff, _(""E61: Nested %s*""),
					    reg_magic >= MAGIC_ON ? """" : ""\\"");
	else
	    sprintf((char *)IObuff, _(""E62: Nested %s%c""),
",1,unused,1883,unused,"	if (peekchr() == Magic('*'))
	    sprintf((char *)IObuff, _(""E61: Nested %s*""),
					    reg_magic >= MAGIC_ON ? """" : ""\\"");
	else
	    sprintf((char *)IObuff, _(""E62: Nested %s%c""),
",unused,vimdebstretche-src2Fregexp.c
"      case Magic('@'):
      case Magic('{'):
      case Magic('*'):
	c = no_Magic(c);
	sprintf((char *)IObuff, _(""E64: %s%c follows nothing""),
",1,unused,2058,unused,"      case Magic('@'):
      case Magic('{'):
      case Magic('*'):
	c = no_Magic(c);
	sprintf((char *)IObuff, _(""E64: %s%c follows nothing""),
",unused,vimdebstretche-src2Fregexp.c
"    if (*regparse == '\\')
	regparse++;	/* Allow either \{...} or \{...\} */
    if (*regparse != '}')
    {
	sprintf((char *)IObuff, _(""E554: Syntax error in %s{...}""),
",1,unused,3403,unused,"    if (*regparse == '\\')
	regparse++;	/* Allow either \{...} or \{...\} */
    if (*regparse != '}')
    {
	sprintf((char *)IObuff, _(""E554: Syntax error in %s{...}""),
",unused,vimdebstretche-src2Fregexp.c
"		    fmt = ""%-*ld "";
		}
	    }

	    sprintf((char *)buf, fmt, w, num);
",1,unused,2547,unused,"		    fmt = ""%-*ld "";
		}
	    }

	    sprintf((char *)buf, fmt, w, num);
",unused,vimdebstretche-src2Fscreen.c
"				fmt = ""%-*ld "";
			    }
			}

			sprintf((char *)extra, fmt,
",1,unused,3762,unused,"				fmt = ""%-*ld "";
			    }
			}

			sprintf((char *)extra, fmt,
",unused,vimdebstretche-src2Fscreen.c
"	{
	    char	buf[20];

	    /* The GUI handles this internally. */
	    sprintf(buf, IF_EB(""\033|%dh"", ESC_STR ""|%dh""), attr);
",1,unused,7864,unused,"	{
	    char	buf[20];

	    /* The GUI handles this internally. */
	    sprintf(buf, IF_EB(""\033|%dh"", ESC_STR ""|%dh""), attr);
",unused,vimdebstretche-src2Fscreen.c
"	{
	    char	buf[20];

	    /* use internal GUI code */
	    sprintf(buf, IF_EB(""\033|%dH"", ESC_STR ""|%dH""), screen_attr);
",1,unused,7958,unused,"	{
	    char	buf[20];

	    /* use internal GUI code */
	    sprintf(buf, IF_EB(""\033|%dH"", ESC_STR ""|%dH""), screen_attr);
",unused,vimdebstretche-src2Fscreen.c
"    MSG_PUTS_ATTR(_(""recording""), attr);
    if (!shortmess(SHM_RECORDING))
    {
	char_u s[4];
	sprintf((char *)s, "" @%c"", Recording);
",1,unused,10309,unused,"    MSG_PUTS_ATTR(_(""recording""), attr);
    if (!shortmess(SHM_RECORDING))
    {
	char_u s[4];
	sprintf((char *)s, "" @%c"", Recording);
",unused,vimdebstretche-src2Fscreen.c
"			*p++ = 's';
		    if (spats[0].off.off > 0 || spats[0].off.line)
			*p++ = '+';
		    if (spats[0].off.off != 0 || spats[0].off.line)
			sprintf((char *)p, ""%ld"", spats[0].off.off);
",1,unused,1351,unused,"			*p++ = 's';
		    if (spats[0].off.off > 0 || spats[0].off.line)
			*p++ = '+';
		    if (spats[0].off.off != 0 || spats[0].off.line)
			sprintf((char *)p, ""%ld"", spats[0].off.off);
",unused,vimdebstretche-src2Fsearch.c
"	vim_free(epat);
	curwin->w_cursor = old_pos;
	goto theend;
    }
    sprintf((char *)spat, ""<%.*s\\>\\%%(\\s\\_[^>]\\{-}[^/]>\\|>\\)\\c"", len, p);
",1,unused,3992,unused,"	vim_free(epat);
	curwin->w_cursor = old_pos;
	goto theend;
    }
    sprintf((char *)spat, ""<%.*s\\>\\%%(\\s\\_[^>]\\{-}[^/]>\\|>\\)\\c"", len, p);
",unused,vimdebstretche-src2Fsearch.c
"	curwin->w_cursor = old_pos;
	goto theend;
    }
    sprintf((char *)spat, ""<%.*s\\>\\%%(\\s\\_[^>]\\{-}[^/]>\\|>\\)\\c"", len, p);
    sprintf((char *)epat, ""</%.*s>\\c"", len, p);
",1,unused,3993,unused,"	curwin->w_cursor = old_pos;
	goto theend;
    }
    sprintf((char *)spat, ""<%.*s\\>\\%%(\\s\\_[^>]\\{-}[^/]>\\|>\\)\\c"", len, p);
    sprintf((char *)epat, ""</%.*s>\\c"", len, p);
",unused,vimdebstretche-src2Fsearch.c
"    {
	pat = alloc(len + 5);
	if (pat == NULL)
	    goto fpip_end;
	sprintf((char *)pat, whole ? ""\\<%.*s\\>"" : ""%.*s"", len, ptr);
",1,unused,4883,unused,"    {
	pat = alloc(len + 5);
	if (pat == NULL)
	    goto fpip_end;
	sprintf((char *)pat, whole ? ""\\<%.*s\\>"" : ""%.*s"", len, ptr);
",unused,vimdebstretche-src2Fsearch.c
"	    *(p + 1) = NUL;
	}
	if (action == ACTION_SHOW_ALL)
	{
	    sprintf((char *)IObuff, ""%3ld: "", count);	/* show match nr */
",1,unused,5557,unused,"	    *(p + 1) = NUL;
	}
	if (action == ACTION_SHOW_ALL)
	{
	    sprintf((char *)IObuff, ""%3ld: "", count);	/* show match nr */
",unused,vimdebstretche-src2Fsearch.c
"	if (action == ACTION_SHOW_ALL)
	{
	    sprintf((char *)IObuff, ""%3ld: "", count);	/* show match nr */
	    msg_puts(IObuff);
	    sprintf((char *)IObuff, ""%4ld"", *lnum);	/* show line nr */
",1,unused,5559,unused,"	if (action == ACTION_SHOW_ALL)
	{
	    sprintf((char *)IObuff, ""%3ld: "", count);	/* show match nr */
	    msg_puts(IObuff);
	    sprintf((char *)IObuff, ""%4ld"", *lnum);	/* show line nr */
",unused,vimdebstretche-src2Fsearch.c
"
    frompat = alloc((unsigned)STRLEN(repl_from) + 7);
    if (frompat == NULL)
	return;
    sprintf((char *)frompat, ""\\V\\<%s\\>"", repl_from);
",1,unused,3670,unused,"
    frompat = alloc((unsigned)STRLEN(repl_from) + 7);
    if (frompat == NULL)
	return;
    sprintf((char *)frompat, ""\\V\\<%s\\>"", repl_from);
",unused,vimdebstretche-src2Fspell.c
"		STRCAT(badword, ""?"");
	    if (flags & WF_REGION)
		for (i = 0; i < 7; ++i)
		    if (flags & (0x10000 << i))
			sprintf((char *)badword + STRLEN(badword), ""%d"", i + 1);
",1,unused,8822,unused,"		STRCAT(badword, ""?"");
	    if (flags & WF_REGION)
		for (i = 0; i < 7; ++i)
		    if (flags & (0x10000 << i))
			sprintf((char *)badword + STRLEN(badword), ""%d"", i + 1);
",unused,vimdebstretche-src2Fspell.c
"			char_u	buf[MAXLINELEN];

			aff_entry->ae_cond = getroom_save(spin, items[4]);
			if (*items[0] == 'P')
			    sprintf((char *)buf, ""^%s"", items[4]);
",1,unused,2760,unused,"			char_u	buf[MAXLINELEN];

			aff_entry->ae_cond = getroom_save(spin, items[4]);
			if (*items[0] == 'P')
			    sprintf((char *)buf, ""^%s"", items[4]);
",unused,vimdebstretche-src2Fspellfile.c
"			aff_entry->ae_cond = getroom_save(spin, items[4]);
			if (*items[0] == 'P')
			    sprintf((char *)buf, ""^%s"", items[4]);
			else
			    sprintf((char *)buf, ""%s$"", items[4]);
",1,unused,2762,unused,"			aff_entry->ae_cond = getroom_save(spin, items[4]);
			if (*items[0] == 'P')
			    sprintf((char *)buf, ""^%s"", items[4]);
			else
			    sprintf((char *)buf, ""%s$"", items[4]);
",unused,vimdebstretche-src2Fspellfile.c
"#endif
					    *aff_entry->ae_cond = c_up;
					if (aff_entry->ae_cond != NULL)
					{
					    sprintf((char *)buf, ""^%s"",
",1,unused,2827,unused,"#endif
					    *aff_entry->ae_cond = c_up;
					if (aff_entry->ae_cond != NULL)
					{
					    sprintf((char *)buf, ""^%s"",
",unused,vimdebstretche-src2Fspellfile.c
"    recursive = TRUE;
    buf = alloc((unsigned)(STRLEN(name) + 12));
    if (buf != NULL)
    {
	sprintf((char *)buf, ""colors/%s.vim"", name);
",1,unused,7141,unused,"    recursive = TRUE;
    buf = alloc((unsigned)(STRLEN(name) + 12));
    if (buf != NULL)
    {
	sprintf((char *)buf, ""colors/%s.vim"", name);
",unused,vimdebstretche-src2Fsyntax.c
"    if (type == LIST_STRING ? (sarg != NULL) : (iarg != 0))
    {
	ts = buf;
	if (type == LIST_INT)
	    sprintf((char *)buf, ""%d"", iarg - 1);
",1,unused,8989,unused,"    if (type == LIST_STRING ? (sarg != NULL) : (iarg != 0))
    {
	ts = buf;
	if (type == LIST_INT)
	    sprintf((char *)buf, ""%d"", iarg - 1);
",unused,vimdebstretche-src2Fsyntax.c
"		color = HL_TABLE()[id - 1].sg_gui_bg;
	    if (color == INVALCOLOR)
		return NULL;
	    rgb = (long_u)GUI_MCH_GET_RGB(color);
	    sprintf((char *)buf, ""#%02x%02x%02x"",
",1,unused,9112,unused,"		color = HL_TABLE()[id - 1].sg_gui_bg;
	    if (color == INVALCOLOR)
		return NULL;
	    rgb = (long_u)GUI_MCH_GET_RGB(color);
	    sprintf((char *)buf, ""#%02x%02x%02x"",
",unused,vimdebstretche-src2Fsyntax.c
"	else
	    n = HL_TABLE()[id - 1].sg_cterm_bg - 1;
	if (n < 0)
	    return NULL;
	sprintf((char *)name, ""%d"", n);
",1,unused,9135,unused,"	else
	    n = HL_TABLE()[id - 1].sg_cterm_bg - 1;
	if (n < 0)
	    return NULL;
	sprintf((char *)name, ""%d"", n);
",unused,vimdebstretche-src2Fsyntax.c
"    }
# endif
    for (i = 0; i < 9; i++)
    {
	sprintf((char *)userhl, ""User%d"", i + 1);
",1,unused,9748,unused,"    }
# endif
    for (i = 0; i < 9; i++)
    {
	sprintf((char *)userhl, ""User%d"", i + 1);
",unused,vimdebstretche-src2Fsyntax.c
"		&& (num_matches > 1 || ic)
		&& !skip_msg)
	    {
		/* Give an indication of the number of matching tags */
		sprintf((char *)IObuff, _(""tag %d of %d%s""),
",1,unused,995,unused,"		&& (num_matches > 1 || ic)
		&& !skip_msg)
	    {
		/* Give an indication of the number of matching tags */
		sprintf((char *)IObuff, _(""tag %d of %d%s""),
",unused,vimdebstretche-src2Ftag.c
"	    if (name == NULL)	    /* file name not available */
		continue;

	    msg_putchar('\n');
	    sprintf((char *)IObuff, ""%c%2d %2d %-15s %5ld  "",
",1,unused,1134,unused,"	    if (name == NULL)	    /* file name not available */
		continue;

	    msg_putchar('\n');
	    sprintf((char *)IObuff, ""%c%2d %2d %-15s %5ld  "",
",unused,vimdebstretche-src2Ftag.c
"				    match_re ? matchoff : 0, !match_no_ic);
#ifdef FEAT_MULTI_LANG
			heuristic += help_pri;
#endif
			sprintf((char *)p + len + 1 + ML_EXTRA, ""%06d"",
",1,unused,2296,unused,"				    match_re ? matchoff : 0, !match_no_ic);
#ifdef FEAT_MULTI_LANG
			heuristic += help_pri;
#endif
			sprintf((char *)p + len + 1 + ML_EXTRA, ""%06d"",
",unused,vimdebstretche-src2Ftag.c
"		    found = 2;
		    (void)test_for_static(&tagp);
		    cc = *tagp.tagname_end;
		    *tagp.tagname_end = NUL;
		    sprintf((char *)pbuf, ""^%s\\s\\*("", tagp.tagname);
",1,unused,3285,unused,"		    found = 2;
		    (void)test_for_static(&tagp);
		    cc = *tagp.tagname_end;
		    *tagp.tagname_end = NUL;
		    sprintf((char *)pbuf, ""^%s\\s\\*("", tagp.tagname);
",unused,vimdebstretche-src2Ftag.c
"		    if (!do_search(NULL, '/', pbuf, (long)1,
							search_options, NULL))
		    {
			/* Guess again: ""^char * \<func  ("" */
			sprintf((char *)pbuf, ""^\\[#a-zA-Z_]\\.\\*\\<%s\\s\\*("",
",1,unused,3290,unused,"		    if (!do_search(NULL, '/', pbuf, (long)1,
							search_options, NULL))
		    {
			/* Guess again: ""^char * \<func  ("" */
			sprintf((char *)pbuf, ""^\\[#a-zA-Z_]\\.\\*\\<%s\\s\\*("",
",unused,vimdebstretche-src2Ftag.c
"    char_u	nr_colors[20];		/* string for number of colors */

    t_colors = nr;
    if (t_colors > 1)
	sprintf((char *)nr_colors, ""%d"", t_colors);
",1,unused,1437,unused,"    char_u	nr_colors[20];		/* string for number of colors */

    t_colors = nr;
    if (t_colors > 1)
	sprintf((char *)nr_colors, ""%d"", t_colors);
",unused,vimdebstretche-src2Fterm.c
"	char *format = ""%s%s%%p1%%dm"";
#else
	char *format = ""%s%s%%dm"";
#endif
	sprintf(buf, format,
",1,unused,2623,unused,"	char *format = ""%s%s%%p1%%dm"";
#else
	char *format = ""%s%s%%dm"";
#endif
	sprintf(buf, format,
",unused,vimdebstretche-src2Fterm.c
"		    src += 5;
		    result[dlen++] = K_SPECIAL;
		    result[dlen++] = (int)KS_EXTRA;
		    result[dlen++] = (int)KE_SNR;
		    sprintf((char *)result + dlen, ""%ld"", (long)current_SID);
",1,unused,5424,unused,"		    src += 5;
		    result[dlen++] = K_SPECIAL;
		    result[dlen++] = (int)KS_EXTRA;
		    result[dlen++] = (int)KE_SNR;
		    sprintf((char *)result + dlen, ""%ld"", (long)current_SID);
",unused,vimdebstretche-src2Fterm.c
"	sprintf(dbuf, ""Requesting XT %d: %s"",
				       xt_index_out, key_names[xt_index_out]);
	log_tr(dbuf);
# endif
	sprintf(buf, ""\033P+q%02x%02x\033\\"",
",1,unused,5785,unused,"	sprintf(dbuf, ""Requesting XT %d: %s"",
				       xt_index_out, key_names[xt_index_out]);
	log_tr(dbuf);
# endif
	sprintf(buf, ""\033P+q%02x%02x\033\\"",
",unused,vimdebstretche-src2Fterm.c
"	char_u	    *p;
	char_u	    name[20];
	partial_T   *pt;

	sprintf((char*)name, ""<lambda>%d"", ++lambda_no);
",1,unused,256,unused,"	char_u	    *p;
	char_u	    name[20];
	partial_T   *pt;

	sprintf((char*)name, ""<lambda>%d"", ++lambda_no);
",unused,vimdebstretche-src2Fuserfunc.c
"	    if (current_SID <= 0)
		*error = ERROR_SCRIPT;
	    else
	    {
		sprintf((char *)fname_buf + 3, ""%ld_"", (long)current_SID);
",1,unused,513,unused,"	    if (current_SID <= 0)
		*error = ERROR_SCRIPT;
	    else
	    {
		sprintf((char *)fname_buf + 3, ""%ld_"", (long)current_SID);
",unused,vimdebstretche-src2Fuserfunc.c
"	}
	else
	{
	    /* ""..."" argument a:1, a:2, etc. */
	    sprintf((char *)numbuf, ""%d"", ai + 1);
",1,unused,765,unused,"	}
	else
	{
	    /* ""..."" argument a:1, a:2, etc. */
	    sprintf((char *)numbuf, ""%d"", ai + 1);
",unused,vimdebstretche-src2Fuserfunc.c
"    if (sourcing_name != NULL)
    {
	if (save_sourcing_name != NULL
			  && STRNCMP(save_sourcing_name, ""function "", 9) == 0)
	    sprintf((char *)sourcing_name, ""%s[%d].."",
",1,unused,819,unused,"    if (sourcing_name != NULL)
    {
	if (save_sourcing_name != NULL
			  && STRNCMP(save_sourcing_name, ""function "", 9) == 0)
	    sprintf((char *)sourcing_name, ""%s[%d].."",
",unused,vimdebstretche-src2Fuserfunc.c
"	    {
		EMSG(_(e_usingsid));
		goto theend;
	    }
	    sprintf((char *)sid_buf, ""%ld_"", (long)current_SID);
",1,unused,1660,unused,"	    {
		EMSG(_(e_usingsid));
		goto theend;
	    }
	    sprintf((char *)sid_buf, ""%ld_"", (long)current_SID);
",unused,vimdebstretche-src2Fuserfunc.c
"
	/* Give the function a sequential number.  Can only be used with a
	 * Funcref! */
	vim_free(name);
	sprintf(numbuf, ""%d"", ++func_nr);
",1,unused,2232,unused,"
	/* Give the function a sequential number.  Can only be used with a
	 * Funcref! */
	vim_free(name);
	sprintf(numbuf, ""%d"", ++func_nr);
",unused,vimdebstretche-src2Fuserfunc.c
"	    /* Check for 9.9x or 9.9xx, alpha/beta version */
	    if (isalpha((int)vers[3]))
	    {
		int len = (isalpha((int)vers[4])) ? 5 : 4;
		sprintf((char *)vers + len, "".%d%s"", highest_patch(),
",1,unused,1759,unused,"	    /* Check for 9.9x or 9.9xx, alpha/beta version */
	    if (isalpha((int)vers[3]))
	    {
		int len = (isalpha((int)vers[4])) ? 5 : 4;
		sprintf((char *)vers + len, "".%d%s"", highest_patch(),
",unused,vimdebstretche-src2Fversion.c
"		sprintf((char *)vers + len, "".%d%s"", highest_patch(),
							 mediumVersion + len);
	    }
	    else
		sprintf((char *)vers + 3, "".%d"", highest_patch());
",1,unused,1763,unused,"		sprintf((char *)vers + len, "".%d%s"", highest_patch(),
							 mediumVersion + len);
	    }
	    else
		sprintf((char *)vers + 3, "".%d"", highest_patch());
",unused,vimdebstretche-src2Fversion.c
"		 * cursor in a new window.
		 */
		if (bt_quickfix(curbuf))
		{
		    sprintf((char *)cbuf, ""split +%ld%s"",
",1,unused,536,unused,"		 * cursor in a new window.
		 */
		if (bt_quickfix(curbuf))
		{
		    sprintf((char *)cbuf, ""split +%ld%s"",
",unused,vimdebstretche-src2Fwindow.c
"  static char z[LLEN+1];
  static int zero_seen = 0;

  if (!nz && zero_seen == 1)
    strcpy(z, l);
",1,unused,404,unused,"  static char z[LLEN+1];
  static int zero_seen = 0;

  if (!nz && zero_seen == 1)
    strcpy(z, l);
",unused,vimdebstretche-src2Fxxd2Fxxd.c
"  while ((length < 0 || n < length) && (e = getc(fp)) != EOF)
    {
      if (p == 0)
	{
	  sprintf(l, ""%08lx:"",
",1,unused,807,unused,"  while ((length < 0 || n < length) && (e = getc(fp)) != EOF)
    {
      if (p == 0)
	{
	  sprintf(l, ""%08lx:"",
",unused,vimdebstretche-src2Fxxd2Fxxd.c
"
    static void
buf_hashtab_add(buf_T *buf)
{
    sprintf((char *)buf->b_key, ""%x"", buf->b_fnum);
",1,unused,414,unused,"
    static void
buf_hashtab_add(buf_T *buf)
{
    sprintf((char *)buf->b_key, ""%x"", buf->b_fnum);
",unused,vimxenial-src2Fbuffer.c
"    hashitem_T	*hi;

    if (nr == 0)
	nr = curwin->w_alt_fnum;
    sprintf((char *)key, ""%x"", nr);
",1,unused,2738,unused,"    hashitem_T	*hi;

    if (nr == 0)
	nr = curwin->w_alt_fnum;
    sprintf((char *)key, ""%x"", nr);
",unused,vimxenial-src2Fbuffer.c
"
    list_hashtable_vars(&curbuf->b_vars->dv_hashtab, (char_u *)""b:"",
								 TRUE, first);

    sprintf((char *)numbuf, ""%ld"", (long)curbuf->b_changedtick);
",1,unused,1459,unused,"
    list_hashtable_vars(&curbuf->b_vars->dv_hashtab, (char_u *)""b:"",
								 TRUE, first);

    sprintf((char *)numbuf, ""%ld"", (long)curbuf->b_changedtick);
",unused,vimxenial-src2Feval.c
"    if (newval == NULL)
	return NULL;

    if (eap->force_bin == FORCE_BIN)
	sprintf((char *)newval, "" ++bin"");
",1,unused,6784,unused,"    if (newval == NULL)
	return NULL;

    if (eap->force_bin == FORCE_BIN)
	sprintf((char *)newval, "" ++bin"");
",unused,vimxenial-src2Feval.c
"
    if (eap->force_bin == FORCE_BIN)
	sprintf((char *)newval, "" ++bin"");
    else if (eap->force_bin == FORCE_NOBIN)
	sprintf((char *)newval, "" ++nobin"");
",1,unused,6786,unused,"
    if (eap->force_bin == FORCE_BIN)
	sprintf((char *)newval, "" ++bin"");
    else if (eap->force_bin == FORCE_NOBIN)
	sprintf((char *)newval, "" ++nobin"");
",unused,vimxenial-src2Feval.c
"    if (eap->read_edit)
	STRCAT(newval, "" ++edit"");

    if (eap->force_ff != 0)
	sprintf((char *)newval + STRLEN(newval), "" ++ff=%s"",
",1,unused,6794,unused,"    if (eap->read_edit)
	STRCAT(newval, "" ++edit"");

    if (eap->force_ff != 0)
	sprintf((char *)newval + STRLEN(newval), "" ++ff=%s"",
",unused,vimxenial-src2Feval.c
"	sprintf((char *)newval + STRLEN(newval), "" ++ff=%s"",
						eap->cmd + eap->force_ff);
# ifdef FEAT_MBYTE
    if (eap->force_enc != 0)
	sprintf((char *)newval + STRLEN(newval), "" ++enc=%s"",
",1,unused,6798,unused,"	sprintf((char *)newval + STRLEN(newval), "" ++ff=%s"",
						eap->cmd + eap->force_ff);
# ifdef FEAT_MBYTE
    if (eap->force_enc != 0)
	sprintf((char *)newval + STRLEN(newval), "" ++enc=%s"",
",unused,vimxenial-src2Feval.c
"	STRCPY(newval + STRLEN(newval), "" ++bad=keep"");
    else if (eap->bad_char == BAD_DROP)
	STRCPY(newval + STRLEN(newval), "" ++bad=drop"");
    else if (eap->bad_char != 0)
	sprintf((char *)newval + STRLEN(newval), "" ++bad=%c"", eap->bad_char);
",1,unused,6805,unused,"	STRCPY(newval + STRLEN(newval), "" ++bad=keep"");
    else if (eap->bad_char == BAD_DROP)
	STRCPY(newval + STRLEN(newval), "" ++bad=drop"");
    else if (eap->bad_char != 0)
	sprintf((char *)newval + STRLEN(newval), "" ++bad=%c"", eap->bad_char);
",unused,vimxenial-src2Feval.c
"	    ga_concat(gap, (char_u *)"" "");
    }
    if (sourcing_lnum > 0)
    {
	sprintf(buf, ""line %ld"", (long)sourcing_lnum);
",1,unused,9016,unused,"	    ga_concat(gap, (char_u *)"" "");
    }
    if (sourcing_lnum > 0)
    {
	sprintf(buf, ""line %ld"", (long)sourcing_lnum);
",unused,vimxenial-src2Feval.c
"		    + 20		    /* for %3ld */
		    + STRLEN(s)));	    /* concatenated */
	if (r != NULL)
	{
	    sprintf((char *)r, txt, dashes, count);
",1,unused,3517,unused,"		    + 20		    /* for %3ld */
		    + STRLEN(s)));	    /* concatenated */
	if (r != NULL)
	{
	    sprintf((char *)r, txt, dashes, count);
",unused,vimxenial-src2Fevalfunc.c
"	    /* Expand s: and <SID> into <SNR>nr_, so that the function can
	     * also be called from another script. Using trans_function_name()
	     * would also work, but some plugins depend on the name being
	     * printable text. */
	    sprintf(sid_buf, ""<SNR>%ld_"", (long)current_SID);
",1,unused,3636,unused,"	    /* Expand s: and <SID> into <SNR>nr_, so that the function can
	     * also be called from another script. Using trans_function_name()
	     * would also work, but some plugins depend on the name being
	     * printable text. */
	    sprintf(sid_buf, ""<SNR>%ld_"", (long)current_SID);
",unused,vimxenial-src2Fevalfunc.c
"		    {
			list_append_number(l, (varnumber_T)llpos->col);
			list_append_number(l, (varnumber_T)llpos->len);
		    }
		    sprintf(buf, ""pos%d"", i + 1);
",1,unused,4803,unused,"		    {
			list_append_number(l, (varnumber_T)llpos->col);
			list_append_number(l, (varnumber_T)llpos->len);
		    }
		    sprintf(buf, ""pos%d"", i + 1);
",unused,vimxenial-src2Fevalfunc.c
"	case MLINE: buf[0] = 'V'; break;
	case MCHAR: buf[0] = 'v'; break;
	case MBLOCK:
		buf[0] = Ctrl_V;
		sprintf((char *)buf + 1, ""%ld"", reglen + 1);
",1,unused,4999,unused,"	case MLINE: buf[0] = 'V'; break;
	case MCHAR: buf[0] = 'v'; break;
	case MBLOCK:
		buf[0] = Ctrl_V;
		sprintf((char *)buf + 1, ""%ld"", reglen + 1);
",unused,vimxenial-src2Fevalfunc.c
"	dictitem_T	v;
	char_u		str[30];
	char_u		*idvar;

	sprintf((char *)str, PRINTF_HEX_LONG_U, (long_u)w);
",1,unused,8488,unused,"	dictitem_T	v;
	char_u		str[30];
	char_u		*idvar;

	sprintf((char *)str, PRINTF_HEX_LONG_U, (long_u)w);
",unused,vimxenial-src2Fevalfunc.c
"    pat2 = alloc((unsigned)(STRLEN(spat) + STRLEN(epat) + 17));
    pat3 = alloc((unsigned)(STRLEN(spat) + STRLEN(mpat) + STRLEN(epat) + 25));
    if (pat2 == NULL || pat3 == NULL)
	goto theend;
    sprintf((char *)pat2, ""\\m\\(%s\\m\\)\\|\\(%s\\m\\)"", spat, epat);
",1,unused,9487,unused,"    pat2 = alloc((unsigned)(STRLEN(spat) + STRLEN(epat) + 17));
    pat3 = alloc((unsigned)(STRLEN(spat) + STRLEN(mpat) + STRLEN(epat) + 25));
    if (pat2 == NULL || pat3 == NULL)
	goto theend;
    sprintf((char *)pat2, ""\\m\\(%s\\m\\)\\|\\(%s\\m\\)"", spat, epat);
",unused,vimxenial-src2Fevalfunc.c
"    sprintf((char *)pat2, ""\\m\\(%s\\m\\)\\|\\(%s\\m\\)"", spat, epat);
    if (*mpat == NUL)
	STRCPY(pat3, pat2);
    else
	sprintf((char *)pat3, ""\\m\\(%s\\m\\)\\|\\(%s\\m\\)\\|\\(%s\\m\\)"",
",1,unused,9491,unused,"    sprintf((char *)pat2, ""\\m\\(%s\\m\\)\\|\\(%s\\m\\)"", spat, epat);
    if (*mpat == NUL)
	STRCPY(pat3, pat2);
    else
	sprintf((char *)pat3, ""\\m\\(%s\\m\\)\\|\\(%s\\m\\)\\|\\(%s\\m\\)"",
",unused,vimxenial-src2Fevalfunc.c
"
		/* match from matchaddpos() */
		for (i = 1; i < 9; i++)
		{
		    sprintf((char *)buf, (char *)""pos%d"", i);
",1,unused,10043,unused,"
		/* match from matchaddpos() */
		for (i = 1; i < 9; i++)
		{
		    sprintf((char *)buf, (char *)""pos%d"", i);
",unused,vimxenial-src2Fevalfunc.c
"
    ga_init2(&ga, (int)sizeof(char), 70);
    FOR_ALL_WINDOWS(wp)
    {
	sprintf((char *)buf, ""%dresize %d|"", winnr, wp->w_height);
",1,unused,12931,unused,"
    ga_init2(&ga, (int)sizeof(char), 70);
    FOR_ALL_WINDOWS(wp)
    {
	sprintf((char *)buf, ""%dresize %d|"", winnr, wp->w_height);
",unused,vimxenial-src2Fevalfunc.c
"    FOR_ALL_WINDOWS(wp)
    {
	sprintf((char *)buf, ""%dresize %d|"", winnr, wp->w_height);
	ga_concat(&ga, buf);
	sprintf((char *)buf, ""vert %dresize %d|"", winnr, wp->w_width);
",1,unused,12933,unused,"    FOR_ALL_WINDOWS(wp)
    {
	sprintf((char *)buf, ""%dresize %d|"", winnr, wp->w_height);
	ga_concat(&ga, buf);
	sprintf((char *)buf, ""vert %dresize %d|"", winnr, wp->w_width);
",unused,vimxenial-src2Fevalfunc.c
"	    if (s == NULL)
		got_int = TRUE;
	    else
	    {
		sprintf((char *)s, ""help-tags\t%s\t1\n"", tagfname);
",1,unused,7114,unused,"	    if (s == NULL)
		got_int = TRUE;
	    else
	    {
		sprintf((char *)s, ""help-tags\t%s\t1\n"", tagfname);
",unused,vimxenial-src2Fex_cmds.c
"			    break;
			}
			((char_u **)ga.ga_data)[ga.ga_len] = s;
			++ga.ga_len;
			sprintf((char *)s, ""%s\t%s"", p1, fname);
",1,unused,7210,unused,"			    break;
			}
			((char_u **)ga.ga_data)[ga.ga_len] = s;
			++ga.ga_len;
			sprintf((char *)s, ""%s\t%s"", p1, fname);
",unused,vimxenial-src2Fex_cmds.c
"		    }
		    cmd = alloc((unsigned)STRLEN(buf->b_fname) + 25);
		    if (cmd == NULL)
			return;
		    sprintf((char *)cmd, ""e +%ld %s"", (long)lnum, buf->b_fname);
",1,unused,7859,unused,"		    }
		    cmd = alloc((unsigned)STRLEN(buf->b_fname) + 25);
		    if (cmd == NULL)
			return;
		    sprintf((char *)cmd, ""e +%ld %s"", (long)lnum, buf->b_fname);
",unused,vimxenial-src2Fex_cmds.c
"
    QueryPerformanceFrequency(&fr);
    sprintf(buf, ""%10.6lf"", (double)tm->QuadPart / (double)fr.QuadPart);
# else
    sprintf(buf, ""%3ld.%06ld"", (long)tm->tv_sec, (long)tm->tv_usec);
",1,unused,1001,unused,"
    QueryPerformanceFrequency(&fr);
    sprintf(buf, ""%10.6lf"", (double)tm->QuadPart / (double)fr.QuadPart);
# else
    sprintf(buf, ""%3ld.%06ld"", (long)tm->tv_sec, (long)tm->tv_usec);
",unused,vimxenial-src2Fex_cmds2.c
"	    }
	    do_unlet((char_u *)""g:current_compiler"", TRUE);
	    do_unlet((char_u *)""b:current_compiler"", TRUE);

	    sprintf((char *)buf, ""compiler/%s.vim"", eap->arg);
",1,unused,3204,unused,"	    }
	    do_unlet((char_u *)""g:current_compiler"", TRUE);
	    do_unlet((char_u *)""b:current_compiler"", TRUE);

	    sprintf((char *)buf, ""compiler/%s.vim"", eap->arg);
",unused,vimxenial-src2Fex_cmds2.c
"	    {
		if (a & COUNT)
		{
		    /* -count=N */
		    sprintf((char *)IObuff + len, ""%ldc"", cmd->uc_def);
",1,unused,6015,unused,"	    {
		if (a & COUNT)
		{
		    /* -count=N */
		    sprintf((char *)IObuff + len, ""%ldc"", cmd->uc_def);
",unused,vimxenial-src2Fex_docmd.c
"		    IObuff[len++] = '%';
		else if (cmd->uc_def >= 0)
		{
		    /* -range=N */
		    sprintf((char *)IObuff + len, ""%ld"", cmd->uc_def);
",1,unused,6023,unused,"		    IObuff[len++] = '%';
		else if (cmd->uc_def >= 0)
		{
		    /* -range=N */
		    sprintf((char *)IObuff + len, ""%ld"", cmd->uc_def);
",unused,vimxenial-src2Fex_docmd.c
"		   (type == ct_LINE2) ? eap->line2 :
		   (eap->addr_count > 0) ? eap->line2 : cmd->uc_def;
	size_t num_len;

	sprintf(num_buf, ""%ld"", num);
",1,unused,6671,unused,"		   (type == ct_LINE2) ? eap->line2 :
		   (eap->addr_count > 0) ? eap->line2 : cmd->uc_def;
	size_t num_len;

	sprintf(num_buf, ""%ld"", num);
",unused,vimxenial-src2Fex_docmd.c
"#  else
	if (mch_get_winpos(&x, &y) != FAIL)
#  endif
	{
	    sprintf((char *)IObuff, _(""Window position: X %d, Y %d""), x, y);
",1,unused,9203,unused,"#  else
	if (mch_get_winpos(&x, &y) != FAIL)
#  endif
	{
	    sprintf((char *)IObuff, _(""Window position: X %d, Y %d""), x, y);
",unused,vimxenial-src2Fex_docmd.c
"		{
		    *errormsg = (char_u *)_(""E496: no autocommand buffer number to substitute for \""<abuf>\"""");
		    return NULL;
		}
		sprintf((char *)strbuf, ""%d"", autocmd_bufnr);
",1,unused,10730,unused,"		{
		    *errormsg = (char_u *)_(""E496: no autocommand buffer number to substitute for \""<abuf>\"""");
		    return NULL;
		}
		sprintf((char *)strbuf, ""%d"", autocmd_bufnr);
",unused,vimxenial-src2Fex_docmd.c
"		{
		    *errormsg = (char_u *)_(""E842: no line number to use for \""<slnum>\"""");
		    return NULL;
		}
		sprintf((char *)strbuf, ""%ld"", (long)sourcing_lnum);
",1,unused,10758,unused,"		{
		    *errormsg = (char_u *)_(""E842: no line number to use for \""<slnum>\"""");
		    return NULL;
		}
		sprintf((char *)strbuf, ""%ld"", (long)sourcing_lnum);
",unused,vimxenial-src2Fex_docmd.c
"		result = strbuf;
		break;
#if defined(FEAT_CLIENTSERVER)
	case SPEC_CLIENT:	/* Source of last submitted input */
		sprintf((char *)strbuf, PRINTF_HEX_LONG_U,
",1,unused,10763,unused,"		result = strbuf;
		break;
#if defined(FEAT_CLIENTSERVER)
	case SPEC_CLIENT:	/* Source of last submitted input */
		sprintf((char *)strbuf, PRINTF_HEX_LONG_U,
",unused,vimxenial-src2Fex_docmd.c
"			continue;

		    STRCAT(val, p);
		    p[-2] = NUL;
		    sprintf((char *)(val + STRLEN(p)), "" (%s)"", &mesg[1]);
",1,unused,482,unused,"			continue;

		    STRCAT(val, p);
		    p[-2] = NUL;
		    sprintf((char *)(val + STRLEN(p)), "" (%s)"", &mesg[1]);
",unused,vimxenial-src2Fex_eval.c
"    }

    args[0] = vim_strnsave(xp->xp_pattern, xp->xp_pattern_len);
    args[1] = xp->xp_line;
    sprintf((char *)num, ""%d"", xp->xp_col);
",1,unused,5163,unused,"    }

    args[0] = vim_strnsave(xp->xp_pattern, xp->xp_pattern_len);
    args[1] = xp->xp_line;
    sprintf((char *)num, ""%d"", xp->xp_col);
",unused,vimxenial-src2Fex_getln.c
"	{
	    ga_clear_strings(&ga);
	    return FAIL;
	}
	sprintf((char *)s, ""%s/%s*.vim"", dirnames[i], pat);
",1,unused,5313,unused,"	{
	    ga_clear_strings(&ga);
	    return FAIL;
	}
	sprintf((char *)s, ""%s/%s*.vim"", dirnames[i], pat);
",unused,vimxenial-src2Fex_getln.c
"	    {
		ga_clear_strings(&ga);
		return FAIL;
	    }
	    sprintf((char *)s, ""pack/*/start/*/%s/%s*.vim"", dirnames[i], pat);
",1,unused,5327,unused,"	    {
		ga_clear_strings(&ga);
		return FAIL;
	    }
	    sprintf((char *)s, ""pack/*/start/*/%s/%s*.vim"", dirnames[i], pat);
",unused,vimxenial-src2Fex_getln.c
"	    {
		ga_clear_strings(&ga);
		return FAIL;
	    }
	    sprintf((char *)s, ""pack/*/opt/*/%s/%s*.vim"", dirnames[i], pat);
",1,unused,5342,unused,"	    {
		ga_clear_strings(&ga);
		return FAIL;
	    }
	    sprintf((char *)s, ""pack/*/opt/*/%s/%s*.vim"", dirnames[i], pat);
",unused,vimxenial-src2Fex_getln.c
"    {
	ga_clear_strings(&ga);
	return FAIL;
    }
    sprintf((char *)s, ""pack/*/opt/%s*"", pat);
",1,unused,5405,unused,"    {
	ga_clear_strings(&ga);
	return FAIL;
    }
    sprintf((char *)s, ""pack/*/opt/%s*"", pat);
",unused,vimxenial-src2Fex_getln.c
"		if (hist[i].hisstr != NULL
			&& hist[i].hisnum >= j && hist[i].hisnum <= k)
		{
		    msg_putchar('\n');
		    sprintf((char *)IObuff, ""%c%6d  "", i == idx ? '>' : ' ',
",1,unused,6242,unused,"		if (hist[i].hisstr != NULL
			&& hist[i].hisnum >= j && hist[i].hisnum <= k)
		{
		    msg_putchar('\n');
		    sprintf((char *)IObuff, ""%c%6d  "", i == idx ? '>' : ' ',
",unused,vimxenial-src2Fex_getln.c
"			     * |{bartype},{histtype},{timestamp},{separator},""text"" */
			    if (c == NUL)
				cbuf[0] = NUL;
			    else
				sprintf(cbuf, ""%d"", c);
",1,unused,6708,unused,"			     * |{bartype},{histtype},{timestamp},{separator},""text"" */
			    if (c == NUL)
				cbuf[0] = NUL;
			    else
				sprintf(cbuf, ""%d"", c);
",unused,vimxenial-src2Fex_getln.c
"#endif
#ifdef FEAT_MBYTE
	    if (conv_error != 0)
	    {
		sprintf((char *)IObuff + STRLEN(IObuff),
",1,unused,2542,unused,"#endif
#ifdef FEAT_MBYTE
	    if (conv_error != 0)
	    {
		sprintf((char *)IObuff + STRLEN(IObuff),
",unused,vimxenial-src2Ffileio.c
"		c = TRUE;
	    }
	    else if (illegal_byte > 0)
	    {
		sprintf((char *)IObuff + STRLEN(IObuff),
",1,unused,2548,unused,"		c = TRUE;
	    }
	    else if (illegal_byte > 0)
	    {
		sprintf((char *)IObuff + STRLEN(IObuff),
",unused,vimxenial-src2Ffileio.c
"    if (eap->cmd == NULL)
	return FAIL;

#ifdef FEAT_MBYTE
    sprintf((char *)eap->cmd, ""e ++ff=%s ++enc=%s"", buf->b_p_ff, buf->b_p_fenc);
",1,unused,2781,unused,"    if (eap->cmd == NULL)
	return FAIL;

#ifdef FEAT_MBYTE
    sprintf((char *)eap->cmd, ""e ++ff=%s ++enc=%s"", buf->b_p_ff, buf->b_p_fenc);
",unused,vimxenial-src2Ffileio.c
"		 */
		STRCPY(IObuff, fname);
		for (i = 4913; ; i += 123)
		{
		    sprintf((char *)gettail(IObuff), ""%d"", i);
",1,unused,3735,unused,"		 */
		STRCPY(IObuff, fname);
		for (i = 4913; ; i += 123)
		{
		    sprintf((char *)gettail(IObuff), ""%d"", i);
",unused,vimxenial-src2Ffileio.c
"    {
	if (lnum == 1)
	    STRCPY(p, _(""1 line, ""));
	else
	    sprintf((char *)p, _(""%ld lines, ""), lnum);
",1,unused,5259,unused,"    {
	if (lnum == 1)
	    STRCPY(p, _(""1 line, ""));
	else
	    sprintf((char *)p, _(""%ld lines, ""), lnum);
",unused,vimxenial-src2Ffileio.c
"	    return -1;
	STRCPY(tempname, from);
	for (n = 123; n < 99999; ++n)
	{
	    sprintf((char *)gettail((char_u *)tempname), ""%d"", n);
",1,unused,6519,unused,"	    return -1;
	STRCPY(tempname, from);
	for (n = 123; n < 99999; ++n)
	{
	    sprintf((char *)gettail((char_u *)tempname), ""%d"", n);
",unused,vimxenial-src2Ffileio.c
"	    if (!helpmesg)
		mesg2 = """";
	    tbuf = alloc((unsigned)(STRLEN(path) + STRLEN(mesg)
							+ STRLEN(mesg2) + 2));
	    sprintf((char *)tbuf, mesg, path);
",1,unused,6967,unused,"	    if (!helpmesg)
		mesg2 = """";
	    tbuf = alloc((unsigned)(STRLEN(path) + STRLEN(mesg)
							+ STRLEN(mesg2) + 2));
	    sprintf((char *)tbuf, mesg, path);
",unused,vimxenial-src2Ffileio.c
"    if (vim_tempdir != NULL)
    {
	/* There is no need to check if the file exists, because we own the
	 * directory and nobody else creates a file in it. */
	sprintf((char *)itmp, ""%s%ld"", vim_tempdir, temp_count++);
",1,unused,7465,unused,"    if (vim_tempdir != NULL)
    {
	/* There is no need to check if the file exists, because we own the
	 * directory and nobody else creates a file in it. */
	sprintf((char *)itmp, ""%s%ld"", vim_tempdir, temp_count++);
",unused,vimxenial-src2Ffileio.c
"
	if (is_buflocal)
	{
	    /* normalize pat into standard ""<buffer>#N"" form */
	    sprintf((char *)buflocal_pat, ""<buffer=%d>"", buflocal_nr);
",1,unused,8601,unused,"
	if (is_buflocal)
	{
	    /* normalize pat into standard ""<buffer>#N"" form */
	    sprintf((char *)buflocal_pat, ""<buffer=%d>"", buflocal_nr);
",unused,vimxenial-src2Ffileio.c
"		sourcing_name = alloc((unsigned)(STRLEN(s)
					    + STRLEN(name) + ap->patlen + 1));
		if (sourcing_name != NULL)
		{
		    sprintf((char *)sourcing_name, s,
",1,unused,9738,unused,"		sourcing_name = alloc((unsigned)(STRLEN(s)
					    + STRLEN(name) + ap->patlen + 1));
		if (sourcing_name != NULL)
		{
		    sprintf((char *)sourcing_name, s,
",unused,vimxenial-src2Ffileio.c
"add_num_buff(buffheader_T *buf, long n)
{
    char_u	number[32];

    sprintf((char *)number, ""%ld"", n);
",1,unused,296,unused,"add_num_buff(buffheader_T *buf, long n)
{
    char_u	number[32];

    sprintf((char *)number, ""%ld"", n);
",unused,vimxenial-src2Fgetchar.c
"		i = getdigits(&p);
		if (i != 0)
		{
		    /* Double the width specification. */
		    sprintf((char *)wp, ""%d%s"", i * 2, p);
",1,unused,951,unused,"		i = getdigits(&p);
		if (i != 0)
		{
		    /* Double the width specification. */
		    sprintf((char *)wp, ""%d%s"", i * 2, p);
",unused,vimxenial-src2Fgui.c
"
    pname = vim_strnsave(name, STRLEN(name) + strlen(""-pullright""));
    if (pname != NULL)
    {
	strcat((char *)pname, ""-pullright"");
",1,unused,1141,unused,"
    pname = vim_strnsave(name, STRLEN(name) + strlen(""-pullright""));
    if (pname != NULL)
    {
	strcat((char *)pname, ""-pullright"");
",unused,vimxenial-src2Fgui_athena.c
"    mch_print_start_line(TRUE, page_line);

    /* Leave two spaces between the number and the text; depends on
     * PRINT_NUMBER_WIDTH. */
    sprintf((char *)tbuf, ""%6ld"", (long)lnum);
",1,unused,399,unused,"    mch_print_start_line(TRUE, page_line);

    /* Leave two spaces between the number and the text; depends on
     * PRINT_NUMBER_WIDTH. */
    sprintf((char *)tbuf, ""%6ld"", (long)lnum);
",unused,vimxenial-src2Fhardcopy.c
"	curwin->w_botline = tmp_botline;
    }
    else
#endif
	sprintf((char *)tbuf, _(""Page %d""), pagenum);
",1,unused,518,unused,"	curwin->w_botline = tmp_botline;
    }
    else
#endif
	sprintf((char *)tbuf, _(""Page %d""), pagenum);
",unused,vimxenial-src2Fhardcopy.c
"		    ui_breakcheck();
		    if (got_int || settings.user_abort)
			goto print_fail;

		    sprintf((char *)IObuff, _(""Printing page %d (%d%%)""),
",1,unused,751,unused,"		    ui_breakcheck();
		    if (got_int || settings.user_abort)
			goto print_fail;

		    sprintf((char *)IObuff, _(""Printing page %d (%d%%)""),
",unused,vimxenial-src2Fhardcopy.c
"		    if (!mch_print_begin_page(IObuff))
			goto print_fail;

		    if (settings.n_collated_copies > 1)
			sprintf((char *)IObuff + STRLEN(IObuff),
",1,unused,762,unused,"		    if (!mch_print_begin_page(IObuff))
			goto print_fail;

		    if (settings.n_collated_copies > 1)
			sprintf((char *)IObuff + STRLEN(IObuff),
",unused,vimxenial-src2Fhardcopy.c
"
print_fail:
    if (got_int || settings.user_abort)
    {
	sprintf((char *)IObuff, ""%s"", _(""Printing aborted""));
",1,unused,829,unused,"
print_fail:
    if (got_int || settings.user_abort)
    {
	sprintf((char *)IObuff, ""%s"", _(""Printing aborted""));
",unused,vimxenial-src2Fhardcopy.c
" */
    static void
prt_write_int(int i)
{
    sprintf((char *)prt_line_buffer, ""%d "", i);
",1,unused,1518,unused," */
    static void
prt_write_int(int i)
{
    sprintf((char *)prt_line_buffer, ""%d "", i);
",unused,vimxenial-src2Fhardcopy.c
" */
    static void
prt_write_boolean(int b)
{
    sprintf((char *)prt_line_buffer, ""%s "", (b ? ""T"" : ""F""));
",1,unused,1528,unused," */
    static void
prt_write_boolean(int b)
{
    sprintf((char *)prt_line_buffer, ""%s "", (b ? ""T"" : ""F""));
",unused,vimxenial-src2Fhardcopy.c
"			  ""/_%s /VIM-%s /%s ref\n"", new_name, encoding, font);
    prt_write_file(prt_line_buffer);
#ifdef FEAT_MBYTE
    if (prt_out_mbyte)
	sprintf((char *)prt_line_buffer, ""/%s %d %f /_%s sffs\n"",
",1,unused,1547,unused,"			  ""/_%s /VIM-%s /%s ref\n"", new_name, encoding, font);
    prt_write_file(prt_line_buffer);
#ifdef FEAT_MBYTE
    if (prt_out_mbyte)
	sprintf((char *)prt_line_buffer, ""/%s %d %f /_%s sffs\n"",
",unused,vimxenial-src2Fhardcopy.c
"    int     fraction;

    prt_real_bits(val, prec, &integer, &fraction);
    /* Emit integer part */
    sprintf((char *)prt_line_buffer, ""%d"", integer);
",1,unused,1623,unused,"    int     fraction;

    prt_real_bits(val, prec, &integer, &fraction);
    /* Emit integer part */
    sprintf((char *)prt_line_buffer, ""%d"", integer);
",unused,vimxenial-src2Fhardcopy.c
"	    prec--;
	    fraction /= 10;
	}
	/* Emit fraction left padded with zeros */
	sprintf((char *)prt_line_buffer, "".%0*d"", prec, fraction);
",1,unused,1635,unused,"	    prec--;
	    fraction /= 10;
	}
	/* Emit fraction left padded with zeros */
	sprintf((char *)prt_line_buffer, "".%0*d"", prec, fraction);
",unused,vimxenial-src2Fhardcopy.c
"	/* Emit fraction left padded with zeros */
	sprintf((char *)prt_line_buffer, "".%0*d"", prec, fraction);
	prt_write_file(prt_line_buffer);
    }
    sprintf((char *)prt_line_buffer, "" "");
",1,unused,1638,unused,"	/* Emit fraction left padded with zeros */
	sprintf((char *)prt_line_buffer, "".%0*d"", prec, fraction);
	prt_write_file(prt_line_buffer);
    }
    sprintf((char *)prt_line_buffer, "" "");
",unused,vimxenial-src2Fhardcopy.c
"    vim_snprintf((char *)prt_line_buffer, sizeof(prt_line_buffer),
								""/%s "", name);
    prt_write_file(prt_line_buffer);
    prt_write_real(value, prec);
    sprintf((char *)prt_line_buffer, ""d\n"");
",1,unused,1652,unused,"    vim_snprintf((char *)prt_line_buffer, sizeof(prt_line_buffer),
								""/%s "", name);
    prt_write_file(prt_line_buffer);
    prt_write_real(value, prec);
    sprintf((char *)prt_line_buffer, ""d\n"");
",unused,vimxenial-src2Fhardcopy.c
"    prt_write_file(prt_line_buffer);

    for (i = 0; i < count; i++)
    {
	sprintf((char *)prt_line_buffer, "" %d"", ints[i]);
",1,unused,2095,unused,"    prt_write_file(prt_line_buffer);

    for (i = 0; i < count; i++)
    {
	sprintf((char *)prt_line_buffer, "" %d"", ints[i]);
",unused,vimxenial-src2Fhardcopy.c
"     */
    if (!(duplex || collate || color || (num_copies > 1)))
	return;

    sprintf((char *)prt_line_buffer, ""%%%%Requirements:"");
",1,unused,2147,unused,"     */
    if (!(duplex || collate || color || (num_copies > 1)))
	return;

    sprintf((char *)prt_line_buffer, ""%%%%Requirements:"");
",unused,vimxenial-src2Fhardcopy.c
"    if (num_copies > 1)
    {
	prt_write_string("" numcopies("");
	/* Note: no space wanted so don't use prt_write_int() */
	sprintf((char *)prt_line_buffer, ""%d"", num_copies);
",1,unused,2164,unused,"    if (num_copies > 1)
    {
	prt_write_string("" numcopies("");
	/* Note: no space wanted so don't use prt_write_int() */
	sprintf((char *)prt_line_buffer, ""%d"", num_copies);
",unused,vimxenial-src2Fhardcopy.c
"		case ')':  ga_append(&prt_ps_buffer, IF_EB(')', 0051)); break;
		case '\\': ga_append(&prt_ps_buffer, IF_EB('\\', 0134)); break;

		default:
			   sprintf((char *)ch_buff, ""%03o"", (unsigned int)ch);
",1,unused,3565,unused,"		case ')':  ga_append(&prt_ps_buffer, IF_EB(')', 0051)); break;
		case '\\': ga_append(&prt_ps_buffer, IF_EB('\\', 0134)); break;

		default:
			   sprintf((char *)ch_buff, ""%03o"", (unsigned int)ch);
",unused,vimxenial-src2Fhardcopy.c
"    char *buf = (char *)alloc((unsigned)strlen(stat_emsg) + MAXPATHL + 10);

    if (buf != NULL)
    {
	(void)sprintf(buf, stat_emsg, fname, errno);
",1,unused,486,unused,"    char *buf = (char *)alloc((unsigned)strlen(stat_emsg) + MAXPATHL + 10);

    if (buf != NULL)
    {
	(void)sprintf(buf, stat_emsg, fname, errno);
",unused,vimxenial-src2Fif_cscope.c
"	    if (fname[0] == '\0')
		break;
	}
	if (fname[0] == '\0')
	    (void)sprintf(fname2, ""/%s"", CSCOPE_DBFILE);
",1,unused,574,unused,"	    if (fname[0] == '\0')
		break;
	}
	if (fname[0] == '\0')
	    (void)sprintf(fname2, ""/%s"", CSCOPE_DBFILE);
",unused,vimxenial-src2Fif_cscope.c
"	}
	if (fname[0] == '\0')
	    (void)sprintf(fname2, ""/%s"", CSCOPE_DBFILE);
	else
	    (void)sprintf(fname2, ""%s/%s"", fname, CSCOPE_DBFILE);
",1,unused,576,unused,"	}
	if (fname[0] == '\0')
	    (void)sprintf(fname2, ""/%s"", CSCOPE_DBFILE);
	else
	    (void)sprintf(fname2, ""%s/%s"", fname, CSCOPE_DBFILE);
",unused,vimxenial-src2Fif_cscope.c
"
    if ((cmd = (char *)alloc((unsigned)(strlen(pat) + 2))) == NULL)
	return NULL;

    (void)sprintf(cmd, ""%d%s"", search, pat);
",1,unused,790,unused,"
    if ((cmd = (char *)alloc((unsigned)(strlen(pat) + 2))) == NULL)
	return NULL;

    (void)sprintf(cmd, ""%d%s"", search, pat);
",unused,vimxenial-src2Fif_cscope.c
"	}

	/* run the cscope command; is there execl for non-unix systems? */
#if defined(UNIX)
	(void)sprintf(cmd, ""exec %s -dl -f %s"", prog, csinfo[i].fname);
",1,unused,935,unused,"	}

	/* run the cscope command; is there execl for non-unix systems? */
#if defined(UNIX)
	(void)sprintf(cmd, ""exec %s -dl -f %s"", prog, csinfo[i].fname);
",unused,vimxenial-src2Fif_cscope.c
"	(void)sprintf(cmd, ""%s -dl -f %s"", prog, csinfo[i].fname);
#endif
	if (csinfo[i].ppath != NULL)
	{
	    (void)strcat(cmd, "" -P"");
",1,unused,942,unused,"	(void)sprintf(cmd, ""%s -dl -f %s"", prog, csinfo[i].fname);
#endif
	if (csinfo[i].ppath != NULL)
	{
	    (void)strcat(cmd, "" -P"");
",unused,vimxenial-src2Fif_cscope.c
"#endif
	if (csinfo[i].ppath != NULL)
	{
	    (void)strcat(cmd, "" -P"");
	    (void)strcat(cmd, csinfo[i].ppath);
",1,unused,943,unused,"#endif
	if (csinfo[i].ppath != NULL)
	{
	    (void)strcat(cmd, "" -P"");
	    (void)strcat(cmd, csinfo[i].ppath);
",unused,vimxenial-src2Fif_cscope.c
"	    (void)strcat(cmd, csinfo[i].ppath);
	}
	if (csinfo[i].flags != NULL)
	{
	    (void)strcat(cmd, "" "");
",1,unused,947,unused,"	    (void)strcat(cmd, csinfo[i].ppath);
	}
	if (csinfo[i].flags != NULL)
	{
	    (void)strcat(cmd, "" "");
",unused,vimxenial-src2Fif_cscope.c
"	}
	if (csinfo[i].flags != NULL)
	{
	    (void)strcat(cmd, "" "");
	    (void)strcat(cmd, csinfo[i].flags);
",1,unused,948,unused,"	}
	if (csinfo[i].flags != NULL)
	{
	    (void)strcat(cmd, "" "");
	    (void)strcat(cmd, csinfo[i].flags);
",unused,vimxenial-src2Fif_cscope.c
"
	    /* strlen will be enough because we use chars */
	    if (buf != NULL)
	    {
		sprintf(buf, nf, *qfpos, *(qfpos-1));
",1,unused,1144,unused,"
	    /* strlen will be enough because we use chars */
	    if (buf != NULL)
	    {
		sprintf(buf, nf, *qfpos, *(qfpos-1));
",unused,vimxenial-src2Fif_cscope.c
"	if (buf == NULL)
	    (void)EMSG(nf);
	else
	{
	    sprintf(buf, nf, opt, pat);
",1,unused,1217,unused,"	if (buf == NULL)
	    (void)EMSG(nf);
	else
	{
	    sprintf(buf, nf, opt, pat);
",unused,vimxenial-src2Fif_cscope.c
"
    if ((csinfo[i].fname = (char *)alloc((unsigned)strlen(fname)+1)) == NULL)
	return -1;

    (void)strcpy(csinfo[i].fname, (const char *)fname);
",1,unused,1479,unused,"
    if ((csinfo[i].fname = (char *)alloc((unsigned)strlen(fname)+1)) == NULL)
	return -1;

    (void)strcpy(csinfo[i].fname, (const char *)fname);
",unused,vimxenial-src2Fif_cscope.c
"	    vim_free(csinfo[i].fname);
	    csinfo[i].fname = NULL;
	    return -1;
	}
	(void)strcpy(csinfo[i].ppath, (const char *)ppath);
",1,unused,1489,unused,"	    vim_free(csinfo[i].fname);
	    csinfo[i].fname = NULL;
	    return -1;
	}
	(void)strcpy(csinfo[i].ppath, (const char *)ppath);
",unused,vimxenial-src2Fif_cscope.c
"	    csinfo[i].fname = NULL;
	    csinfo[i].ppath = NULL;
	    return -1;
	}
	(void)strcpy(csinfo[i].flags, (const char *)flags);
",1,unused,1503,unused,"	    csinfo[i].fname = NULL;
	    csinfo[i].ppath = NULL;
	    return -1;
	}
	(void)strcpy(csinfo[i].flags, (const char *)flags);
",unused,vimxenial-src2Fif_cscope.c
"	amt = (int)(strlen(fname) + strlen(slno) + strlen(tagstr) + strlen(search)+6);
	if ((buf = (char *)alloc(amt)) == NULL)
	    return NULL;

	(void)sprintf(buf, ""%s\t%s\t%s;\""\t%s"", tagstr, fname, slno, search);
",1,unused,1667,unused,"	amt = (int)(strlen(fname) + strlen(slno) + strlen(tagstr) + strlen(search)+6);
	if ((buf = (char *)alloc(amt)) == NULL)
	    return NULL;

	(void)sprintf(buf, ""%s\t%s\t%s;\""\t%s"", tagstr, fname, slno, search);
",unused,vimxenial-src2Fif_cscope.c
"	amt = (int)(strlen(fname) + strlen(slno) + strlen(tagstr) + 5);
	if ((buf = (char *)alloc(amt)) == NULL)
	    return NULL;

	(void)sprintf(buf, ""%s\t%s\t%s;\"""", tagstr, fname, slno);
",1,unused,1675,unused,"	amt = (int)(strlen(fname) + strlen(slno) + strlen(tagstr) + 5);
	if ((buf = (char *)alloc(amt)) == NULL)
	    return NULL;

	(void)sprintf(buf, ""%s\t%s\t%s;\"""", tagstr, fname, slno);
",unused,vimxenial-src2Fif_cscope.c
"	   if (context == NULL)
	       continue;

	   if (strcmp(cntx, ""<global>"")==0)
	       strcpy(context, ""<<global>>"");
",1,unused,1854,unused,"	   if (context == NULL)
	       continue;

	   if (strcmp(cntx, ""<global>"")==0)
	       strcpy(context, ""<<global>>"");
",unused,vimxenial-src2Fif_cscope.c
"
	   if (strcmp(cntx, ""<global>"")==0)
	       strcpy(context, ""<<global>>"");
	   else
	       sprintf(context, ""<<%s>>"", cntx);
",1,unused,1856,unused,"
	   if (strcmp(cntx, ""<global>"")==0)
	       strcpy(context, ""<<global>>"");
	   else
	       sprintf(context, ""<<%s>>"", cntx);
",unused,vimxenial-src2Fif_cscope.c
"
    if ((tbuf = (char *)alloc((unsigned)strlen(matches[0]) + 1)) == NULL)
	return;

    strcpy(tbuf, matches[0]);
",1,unused,2009,unused,"
    if ((tbuf = (char *)alloc((unsigned)strlen(matches[0]) + 1)) == NULL)
	return;

    strcpy(tbuf, matches[0]);
",unused,vimxenial-src2Fif_cscope.c
"    buf = (char *)alloc(newsize);
    if (buf != NULL)
    {
	bufsize = newsize;
	(void)sprintf(buf, cstag_msg, ptag);
",1,unused,2022,unused,"    buf = (char *)alloc(newsize);
    if (buf != NULL)
    {
	bufsize = newsize;
	(void)sprintf(buf, cstag_msg, ptag);
",unused,vimxenial-src2Fif_cscope.c
"	 * directly, but that's too much of a hassle
	 */
	if ((tbuf = (char *)alloc((unsigned)strlen(matches[idx]) + 1)) == NULL)
	    continue;
	(void)strcpy(tbuf, matches[idx]);
",1,unused,2043,unused,"	 * directly, but that's too much of a hassle
	 */
	if ((tbuf = (char *)alloc((unsigned)strlen(matches[idx]) + 1)) == NULL)
	    continue;
	(void)strcpy(tbuf, matches[idx]);
",unused,vimxenial-src2Fif_cscope.c
"	}
	if (buf != NULL)
	{
	    /* csfmt_str = ""%4d %6s  ""; */
	    (void)sprintf(buf, csfmt_str, num, lno);
",1,unused,2073,unused,"	}
	if (buf != NULL)
	{
	    /* csfmt_str = ""%4d %6s  ""; */
	    (void)sprintf(buf, csfmt_str, num, lno);
",unused,vimxenial-src2Fif_cscope.c
"		bufsize = newsize;
	}
	if (buf != NULL)
	{
	    (void)sprintf(buf, cntxformat, context);
",1,unused,2099,unused,"		bufsize = newsize;
	}
	if (buf != NULL)
	{
	    (void)sprintf(buf, cntxformat, context);
",unused,vimxenial-src2Fif_cscope.c
"		/* don't use smsg_attr() because we want to display the
		 * connection number in the same line as
		 * ""Added cscope database...""
		 */
		sprintf(buf, "" (#%d)"", i);
",1,unused,2401,unused,"		/* don't use smsg_attr() because we want to display the
		 * connection number in the same line as
		 * ""Added cscope database...""
		 */
		sprintf(buf, "" (#%d)"", i);
",unused,vimxenial-src2Fif_cscope.c
"#endif
       )
    {
	if ((fullname = (char *)alloc(len)) != NULL)
	    (void)sprintf(fullname, ""%s/%s"", csinfo[i].ppath, name);
",1,unused,2469,unused,"#endif
       )
    {
	if ((fullname = (char *)alloc(len)) != NULL)
	    (void)sprintf(fullname, ""%s/%s"", csinfo[i].ppath, name);
",unused,vimxenial-src2Fif_cscope.c
"	    {
		res = -10;
		continue;
	    }
	    sprintf((char *)p, ""%s%d"", name, i++);
",1,unused,244,unused,"	    {
		res = -10;
		continue;
	    }
	    sprintf((char *)p, ""%s%d"", name, i++);
",unused,vimxenial-src2Fif_xcmdsrv.c
"	    return -1;
	}
	(void)LookupName(dpy, name, /*delete=*/TRUE, NULL);
    }
    sprintf((char *)propInfo, ""%x %.*s"", (int_u)commWindow,
",1,unused,303,unused,"	    return -1;
	}
	(void)LookupName(dpy, name, /*delete=*/TRUE, NULL);
    }
    sprintf((char *)propInfo, ""%x %.*s"", (int_u)commWindow,
",unused,vimxenial-src2Fif_xcmdsrv.c
"    if (serverName != NULL)
    {
	/* Reinsert name if we was already registered */
	(void)LookupName(dpy, serverName, /*delete=*/TRUE, NULL);
	sprintf((char *)propInfo, ""%x %.*s"",
",1,unused,354,unused,"    if (serverName != NULL)
    {
	/* Reinsert name if we was already registered */
	(void)LookupName(dpy, serverName, /*delete=*/TRUE, NULL);
	sprintf((char *)propInfo, ""%x %.*s"",
",unused,vimxenial-src2Fif_xcmdsrv.c
"#endif
    property = (char_u *)alloc((unsigned)length + 30);

#ifdef FEAT_MBYTE
    sprintf((char *)property, ""%c%c%c-n %s%c-E %s%c-s %s"",
",1,unused,471,unused,"#endif
    property = (char_u *)alloc((unsigned)length + 30);

#ifdef FEAT_MBYTE
    sprintf((char *)property, ""%c%c%c-n %s%c-E %s%c-s %s"",
",unused,vimxenial-src2Fif_xcmdsrv.c
"    if (name == loosename)
	vim_free(loosename);
    /* Add a back reference to our comm window */
    serial++;
    sprintf((char *)property + length, ""%c-r %x %d"",
",1,unused,481,unused,"    if (name == loosename)
	vim_free(loosename);
    /* Add a back reference to our comm window */
    serial++;
    sprintf((char *)property + length, ""%c-r %x %d"",
",unused,vimxenial-src2Fif_xcmdsrv.c
"#endif
    if ((property = (char_u *)alloc((unsigned)length + 30)) != NULL)
    {
#ifdef FEAT_MBYTE
	sprintf((char *)property, ""%cn%c-E %s%c-n %s%c-w %x"",
",1,unused,784,unused,"#endif
    if ((property = (char_u *)alloc((unsigned)length + 30)) != NULL)
    {
#ifdef FEAT_MBYTE
	sprintf((char *)property, ""%cn%c-E %s%c-n %s%c-w %x"",
",unused,vimxenial-src2Fif_xcmdsrv.c
"			/* Initialize the result property. */
			ga_init2(&reply, 1, 100);
#ifdef FEAT_MBYTE
			(void)ga_grow(&reply, 50 + STRLEN(p_enc));
			sprintf(reply.ga_data, ""%cr%c-E %s%c-s %s%c-r "",
",1,unused,1350,unused,"			/* Initialize the result property. */
			ga_init2(&reply, 1, 100);
#ifdef FEAT_MBYTE
			(void)ga_grow(&reply, 50 + STRLEN(p_enc));
			sprintf(reply.ga_data, ""%cr%c-E %s%c-s %s%c-r "",
",unused,vimxenial-src2Fif_xcmdsrv.c
"#ifdef FEAT_AUTOCMD
	    {
		char_u	winstr[30];

		sprintf((char *)winstr, ""0x%x"", (unsigned int)win);
",1,unused,1496,unused,"#ifdef FEAT_AUTOCMD
	    {
		char_u	winstr[30];

		sprintf((char *)winstr, ""0x%x"", (unsigned int)win);
",unused,vimxenial-src2Fif_xcmdsrv.c
"			    a = argv[0];
			p = alloc((unsigned)(STRLEN(a) + 4));
			if (p == NULL)
			    mch_exit(2);
			sprintf((char *)p, ""so %s"", a);
",1,unused,2246,unused,"			    a = argv[0];
			p = alloc((unsigned)(STRLEN(a) + 4));
			if (p == NULL)
			    mch_exit(2);
			sprintf((char *)p, ""so %s"", a);
",unused,vimxenial-src2Fmain.c
"    {
	p = alloc((unsigned)STRLEN(parmp->commands[0]) + 3);
	if (p != NULL)
	{
	    sprintf((char *)p, "":%s\r"", parmp->commands[0]);
",1,unused,2472,unused,"    {
	p = alloc((unsigned)STRLEN(parmp->commands[0]) + 3);
	if (p != NULL)
	{
	    sprintf((char *)p, "":%s\r"", parmp->commands[0]);
",unused,vimxenial-src2Fmain.c
"	}
	msg_putchar('\n');
	if (!got_int)
	{
	    sprintf((char *)IObuff, "" %c %6ld %4d "", c, p->lnum, p->col);
",1,unused,780,unused,"	}
	msg_putchar('\n');
	if (!got_int)
	{
	    sprintf((char *)IObuff, "" %c %6ld %4d "", c, p->lnum, p->col);
",unused,vimxenial-src2Fmark.c
"	    {
		vim_free(name);
		break;
	    }
	    sprintf((char *)IObuff, ""%c %2d %5ld %4d "",
",1,unused,912,unused,"	    {
		vim_free(name);
		break;
	    }
	    sprintf((char *)IObuff, ""%c %2d %5ld %4d "",
",unused,vimxenial-src2Fmark.c
"	{
	    msg_putchar('\n');
	    if (got_int)
		break;
	    sprintf((char *)IObuff, ""%c %3d %5ld %4d "",
",1,unused,958,unused,"	{
	    msg_putchar('\n');
	    if (got_int)
		break;
	    sprintf((char *)IObuff, ""%c %3d %5ld %4d "",
",unused,vimxenial-src2Fmark.c
"		rlen += 2;
	    }
	    clen = utf_ptr2len(line + i);
	}
	sprintf((char *)IObuff + rlen, ""%02x "",
",1,unused,3654,unused,"		rlen += 2;
	    }
	    clen = utf_ptr2len(line + i);
	}
	sprintf((char *)IObuff + rlen, ""%02x "",
",unused,vimxenial-src2Fmbyte.c
"	return FALSE;

    if (gui.rsrc_input_method != NULL && *gui.rsrc_input_method != NUL)
    {
	strcpy(tmp, gui.rsrc_input_method);
",1,unused,5807,unused,"	return FALSE;

    if (gui.rsrc_input_method != NULL && *gui.rsrc_input_method != NUL)
    {
	strcpy(tmp, gui.rsrc_input_method);
",unused,vimxenial-src2Fmbyte.c
"	    *end = NUL;

	    if (strlen(s) <= IMLEN_MAX)
	    {
		strcpy(buf, ""@im="");
",1,unused,5821,unused,"	    *end = NUL;

	    if (strlen(s) <= IMLEN_MAX)
	    {
		strcpy(buf, ""@im="");
",unused,vimxenial-src2Fmbyte.c
"
	    if (strlen(s) <= IMLEN_MAX)
	    {
		strcpy(buf, ""@im="");
		strcat(buf, s);
",1,unused,5822,unused,"
	    if (strlen(s) <= IMLEN_MAX)
	    {
		strcpy(buf, ""@im="");
		strcat(buf, s);
",unused,vimxenial-src2Fmbyte.c
"	return FALSE;
    }

    found = False;
    strcpy(tmp, gui.rsrc_preedit_type_name);
",1,unused,5874,unused,"	return FALSE;
    }

    found = False;
    strcpy(tmp, gui.rsrc_preedit_type_name);
",unused,vimxenial-src2Fmbyte.c
"    {
	p = (char_u *)_(""Error detected while processing %s:"");
	Buf = alloc((unsigned)(STRLEN(sourcing_name) + STRLEN(p)));
	if (Buf != NULL)
	    sprintf((char *)Buf, (char *)p, sourcing_name);
",1,unused,455,unused,"    {
	p = (char_u *)_(""Error detected while processing %s:"");
	Buf = alloc((unsigned)(STRLEN(sourcing_name) + STRLEN(p)));
	if (Buf != NULL)
	    sprintf((char *)Buf, (char *)p, sourcing_name);
",unused,vimxenial-src2Fmessage.c
"    {
	p = (char_u *)_(""line %4ld:"");
	Buf = alloc((unsigned)(STRLEN(p) + 20));
	if (Buf != NULL)
	    sprintf((char *)Buf, (char *)p, (long)sourcing_lnum);
",1,unused,480,unused,"    {
	p = (char_u *)_(""line %4ld:"");
	Buf = alloc((unsigned)(STRLEN(p) + 20));
	if (Buf != NULL)
	    sprintf((char *)Buf, (char *)p, (long)sourcing_lnum);
",unused,vimxenial-src2Fmessage.c
"msg_outnum(long n)
{
    char_u	buf[20];

    sprintf((char *)buf, ""%ld"", n);
",1,unused,1388,unused,"msg_outnum(long n)
{
    char_u	buf[20];

    sprintf((char *)buf, ""%ld"", n);
",unused,vimxenial-src2Fmessage.c
"			f[f_l++] = fmt_spec;
			f[f_l++] = '\0';

			if (fmt_spec == 'p')
			    str_arg_l += sprintf(tmp + str_arg_l, f, ptr_arg);
",1,unused,4710,unused,"			f[f_l++] = fmt_spec;
			f[f_l++] = '\0';

			if (fmt_spec == 'p')
			    str_arg_l += sprintf(tmp + str_arg_l, f, ptr_arg);
",unused,vimxenial-src2Fmessage.c
"			    /* signed */
			    switch (length_modifier)
			    {
			    case '\0':
			    case 'h': str_arg_l += sprintf(
",1,unused,4733,unused,"			    /* signed */
			    switch (length_modifier)
			    {
			    case '\0':
			    case 'h': str_arg_l += sprintf(
",unused,vimxenial-src2Fmessage.c
"			    case '\0':
			    case 'h': str_arg_l += sprintf(
						 tmp + str_arg_l, f, int_arg);
				      break;
			    case 'l': str_arg_l += sprintf(
",1,unused,4736,unused,"			    case '\0':
			    case 'h': str_arg_l += sprintf(
						 tmp + str_arg_l, f, int_arg);
				      break;
			    case 'l': str_arg_l += sprintf(
",unused,vimxenial-src2Fmessage.c
"			    case 'l': str_arg_l += sprintf(
						tmp + str_arg_l, f, long_arg);
				      break;
# ifdef FEAT_NUM64
			    case 'L': str_arg_l += sprintf(
",1,unused,4740,unused,"			    case 'l': str_arg_l += sprintf(
						tmp + str_arg_l, f, long_arg);
				      break;
# ifdef FEAT_NUM64
			    case 'L': str_arg_l += sprintf(
",unused,vimxenial-src2Fmessage.c
"			    /* unsigned */
			    switch (length_modifier)
			    {
			    case '\0':
			    case 'h': str_arg_l += sprintf(
",1,unused,4752,unused,"			    /* unsigned */
			    switch (length_modifier)
			    {
			    case '\0':
			    case 'h': str_arg_l += sprintf(
",unused,vimxenial-src2Fmessage.c
"			    case '\0':
			    case 'h': str_arg_l += sprintf(
						tmp + str_arg_l, f, uint_arg);
				      break;
			    case 'l': str_arg_l += sprintf(
",1,unused,4755,unused,"			    case '\0':
			    case 'h': str_arg_l += sprintf(
						tmp + str_arg_l, f, uint_arg);
				      break;
			    case 'l': str_arg_l += sprintf(
",unused,vimxenial-src2Fmessage.c
"			    case 'l': str_arg_l += sprintf(
					       tmp + str_arg_l, f, ulong_arg);
				      break;
# ifdef FEAT_NUM64
			    case 'L': str_arg_l += sprintf(
",1,unused,4759,unused,"			    case 'l': str_arg_l += sprintf(
					       tmp + str_arg_l, f, ulong_arg);
				      break;
# ifdef FEAT_NUM64
			    case 'L': str_arg_l += sprintf(
",unused,vimxenial-src2Fmessage.c
"								&& abs_f > 1.0)
				    max_prec -= (size_t)log10(abs_f);
				if (precision > max_prec)
				    precision = max_prec;
				l += sprintf(format + l, "".%d"", (int)precision);
",1,unused,4900,unused,"								&& abs_f > 1.0)
				    max_prec -= (size_t)log10(abs_f);
				if (precision > max_prec)
				    precision = max_prec;
				l += sprintf(format + l, "".%d"", (int)precision);
",unused,vimxenial-src2Fmessage.c
"			    }
			    format[l] = fmt_spec == 'F' ? 'f' : fmt_spec;
			    format[l + 1] = NUL;

			    str_arg_l = sprintf(tmp, format, f);
",1,unused,4905,unused,"			    }
			    format[l] = fmt_spec == 'F' ? 'f' : fmt_spec;
			    format[l + 1] = NUL;

			    str_arg_l = sprintf(tmp, format, f);
",unused,vimxenial-src2Fmessage.c
"	    /* success, login */
	    vim_snprintf(buf, sizeof(buf), ""AUTH %s\n"", password);
	    nb_send(buf, ""netbeans_connect"");

	    sprintf(buf, ""0:version=0 \""%s\""\n"", ExtEdProtocolVersion);
",1,unused,231,unused,"	    /* success, login */
	    vim_snprintf(buf, sizeof(buf), ""AUTH %s\n"", password);
	    nb_send(buf, ""netbeans_connect"");

	    sprintf(buf, ""0:version=0 \""%s\""\n"", ExtEdProtocolVersion);
",unused,vimxenial-src2Fnetbeans.c
"	    continue;
	if (netbeansForcedQuit)
	{
	    /* mark as unmodified so NetBeans won't put up dialog on ""killed"" */
	    sprintf(buf, ""%d:unmodified=%d\n"", i, r_cmdno);
",1,unused,749,unused,"	    continue;
	if (netbeansForcedQuit)
	{
	    /* mark as unmodified so NetBeans won't put up dialog on ""killed"" */
	    sprintf(buf, ""%d:unmodified=%d\n"", i, r_cmdno);
",unused,vimxenial-src2Fnetbeans.c
"	    sprintf(buf, ""%d:unmodified=%d\n"", i, r_cmdno);
	    nbdebug((""EVT: %s"", buf));
	    nb_send(buf, ""netbeans_end"");
	}
	sprintf(buf, ""%d:killed=%d\n"", i, r_cmdno);
",1,unused,753,unused,"	    sprintf(buf, ""%d:unmodified=%d\n"", i, r_cmdno);
	    nbdebug((""EVT: %s"", buf));
	    nb_send(buf, ""netbeans_end"");
	}
	sprintf(buf, ""%d:killed=%d\n"", i, r_cmdno);
",unused,vimxenial-src2Fnetbeans.c
"    /* Avoid printing an annoying error message. */
    if (!NETBEANS_OPEN)
	return;

    sprintf(reply, ""%d\n"", cmdno);
",1,unused,787,unused,"    /* Avoid printing an annoying error message. */
    if (!NETBEANS_OPEN)
	return;

    sprintf(reply, ""%d\n"", cmdno);
",unused,vimxenial-src2Fnetbeans.c
"
    nbdebug((""REP %d: %s\n"", cmdno, (char *)result));

    reply = alloc((unsigned)STRLEN(result) + 32);
    sprintf((char *)reply, ""%d %s\n"", cmdno, (char *)result);
",1,unused,804,unused,"
    nbdebug((""REP %d: %s\n"", cmdno, (char *)result));

    reply = alloc((unsigned)STRLEN(result) + 32);
    sprintf((char *)reply, ""%d %s\n"", cmdno, (char *)result);
",unused,vimxenial-src2Fnetbeans.c
"    char reply[32];

    nbdebug((""REP %d: %ld\n"", cmdno, result));

    sprintf(reply, ""%d %ld\n"", cmdno, result);
",1,unused,821,unused,"    char reply[32];

    nbdebug((""REP %d: %ld\n"", cmdno, result));

    sprintf(reply, ""%d %ld\n"", cmdno, result);
",unused,vimxenial-src2Fnetbeans.c
"
	    /* Note: nb_getbufno() may return -1.  This indicates the IDE
	     * didn't assign a number to the current buffer in response to a
	     * fileOpened event. */
	    sprintf((char *)text, ""%d %ld %d %ld"",
",1,unused,1030,unused,"
	    /* Note: nb_getbufno() may return -1.  This indicates the IDE
	     * didn't assign a number to the current buffer in response to a
	     * fileOpened event. */
	    sprintf((char *)text, ""%d %ld %d %ld"",
",unused,vimxenial-src2Fnetbeans.c
"	    }
	    tok++;
	}

	strcpy(&keybuf[i], tok);
",1,unused,2362,unused,"	    }
	    tok++;
	}

	strcpy(&keybuf[i], tok);
",unused,vimxenial-src2Fnetbeans.c
"    }

    buf[0] = '\0';
    if (ctrl)
	strcat(buf, ""C"");
",1,unused,2479,unused,"    }

    buf[0] = '\0';
    if (ctrl)
	strcat(buf, ""C"");
",unused,vimxenial-src2Fnetbeans.c
"    buf[0] = '\0';
    if (ctrl)
	strcat(buf, ""C"");
    if (shift)
	strcat(buf, ""S"");
",1,unused,2481,unused,"    buf[0] = '\0';
    if (ctrl)
	strcat(buf, ""C"");
    if (shift)
	strcat(buf, ""S"");
",unused,vimxenial-src2Fnetbeans.c
"	strcat(buf, ""C"");
    if (shift)
	strcat(buf, ""S"");
    if (alt)
	strcat(buf, ""M""); /* META */
",1,unused,2483,unused,"	strcat(buf, ""C"");
    if (shift)
	strcat(buf, ""S"");
    if (alt)
	strcat(buf, ""M""); /* META */
",unused,vimxenial-src2Fnetbeans.c
"	strcat(buf, ""S"");
    if (alt)
	strcat(buf, ""M""); /* META */
    if (ctrl || shift || alt)
	strcat(buf, ""-"");
",1,unused,2485,unused,"	strcat(buf, ""S"");
    if (alt)
	strcat(buf, ""M""); /* META */
    if (ctrl || shift || alt)
	strcat(buf, ""-"");
",unused,vimxenial-src2Fnetbeans.c
"    if (alt)
	strcat(buf, ""M""); /* META */
    if (ctrl || shift || alt)
	strcat(buf, ""-"");
    strcat(buf, name);
",1,unused,2486,unused,"    if (alt)
	strcat(buf, ""M""); /* META */
    if (ctrl || shift || alt)
	strcat(buf, ""-"");
    strcat(buf, name);
",unused,vimxenial-src2Fnetbeans.c
"    char buf[128];

    if (NETBEANS_OPEN)
    {
	sprintf(buf, ""0:disconnect=%d\n"", r_cmdno);
",1,unused,2593,unused,"    char buf[128];

    if (NETBEANS_OPEN)
    {
	sprintf(buf, ""0:disconnect=%d\n"", r_cmdno);
",unused,vimxenial-src2Fnetbeans.c
"
    if (!NETBEANS_OPEN)
	return;

    sprintf(buf, ""0:geometry=%d %d %d %d %d\n"",
",1,unused,2628,unused,"
    if (!NETBEANS_OPEN)
	return;

    sprintf(buf, ""0:geometry=%d %d %d %d %d\n"",
",unused,vimxenial-src2Fnetbeans.c
"
    nbdebug((""netbeans_file_killed:\n""));
    nbdebug((""    Killing bufno: %d"", bufno));

    sprintf(buffer, ""%d:killed=%d\n"", bufno, r_cmdno);
",1,unused,2720,unused,"
    nbdebug((""netbeans_file_killed:\n""));
    nbdebug((""    Killing bufno: %d"", bufno));

    sprintf(buffer, ""%d:killed=%d\n"", bufno, r_cmdno);
",unused,vimxenial-src2Fnetbeans.c
"    p = nb_quote(newtxt);
    if (p != NULL)
    {
	buf = alloc(128 + 2*newlen);
	sprintf((char *)buf, ""%d:insert=%d %ld \""%s\""\n"",
",1,unused,2797,unused,"    p = nb_quote(newtxt);
    if (p != NULL)
    {
	buf = alloc(128 + 2*newlen);
	sprintf((char *)buf, ""%d:insert=%d %ld \""%s\""\n"",
",unused,vimxenial-src2Fnetbeans.c
"    pos.col = col;

    off = pos2off(bufp, &pos);

    sprintf((char *)buf, ""%d:remove=%d %ld %ld\n"", bufno, r_cmdno, off, len);
",1,unused,2843,unused,"    pos.col = col;

    off = pos2off(bufp, &pos);

    sprintf((char *)buf, ""%d:remove=%d %ld %ld\n"", bufno, r_cmdno, off, len);
",unused,vimxenial-src2Fnetbeans.c
"			      - ((curwin->w_p_nu || curwin->w_p_rnu) ? 9 : 1);
	long off = pos2off(curbuf, &curwin->w_cursor);

	/* sync the cursor position */
	sprintf(buf, ""%d:newDotAndMark=%d %ld %ld\n"", bufno, r_cmdno, off, off);
",1,unused,2880,unused,"			      - ((curwin->w_p_nu || curwin->w_p_rnu) ? 9 : 1);
	long off = pos2off(curbuf, &curwin->w_cursor);

	/* sync the cursor position */
	sprintf(buf, ""%d:newDotAndMark=%d %ld %ld\n"", bufno, r_cmdno, off, off);
",unused,vimxenial-src2Fnetbeans.c
"	sprintf(buf, ""%d:newDotAndMark=%d %ld %ld\n"", bufno, r_cmdno, off, off);
	nbdebug((""EVT: %s"", buf));
	nb_send(buf, ""netbeans_button_release[newDotAndMark]"");

	sprintf(buf, ""%d:buttonRelease=%d %d %ld %d\n"", bufno, r_cmdno,
",1,unused,2884,unused,"	sprintf(buf, ""%d:newDotAndMark=%d %ld %ld\n"", bufno, r_cmdno, off, off);
	nbdebug((""EVT: %s"", buf));
	nb_send(buf, ""netbeans_button_release[newDotAndMark]"");

	sprintf(buf, ""%d:buttonRelease=%d %d %ld %d\n"", bufno, r_cmdno,
",unused,vimxenial-src2Fnetbeans.c
"    }

    /* sync the cursor position */
    off = pos2off(curbuf, &curwin->w_cursor);
    sprintf(buf, ""%d:newDotAndMark=%d %ld %ld\n"", bufno, r_cmdno, off, off);
",1,unused,2947,unused,"    }

    /* sync the cursor position */
    off = pos2off(curbuf, &curwin->w_cursor);
    sprintf(buf, ""%d:newDotAndMark=%d %ld %ld\n"", bufno, r_cmdno, off, off);
",unused,vimxenial-src2Fnetbeans.c
"	return;

    nbbuf->modified = 0;

    sprintf((char *)buf, ""%d:save=%d\n"", bufno, r_cmdno);
",1,unused,2991,unused,"	return;

    nbbuf->modified = 0;

    sprintf((char *)buf, ""%d:save=%d\n"", bufno, r_cmdno);
",unused,vimxenial-src2Fnetbeans.c
"    /* Don't mark as modified for initial read */
    if (nbbuf->insertDone)
	nbbuf->modified = 1;

    sprintf((char *)buf, ""%d:remove=%d 0 -1\n"", bufno, r_cmdno);
",1,unused,3018,unused,"    /* Don't mark as modified for initial read */
    if (nbbuf->insertDone)
	nbbuf->modified = 1;

    sprintf((char *)buf, ""%d:remove=%d 0 -1\n"", bufno, r_cmdno);
",unused,vimxenial-src2Fnetbeans.c
"	    int value;

	    value = strtol((char *)fg, &ptr, 10);
	    if (ptr != (char *)fg)
		sprintf(fgbuf, ""guifg=#%06x"", value & 0xFFFFFF);
",1,unused,3228,unused,"	    int value;

	    value = strtol((char *)fg, &ptr, 10);
	    if (ptr != (char *)fg)
		sprintf(fgbuf, ""guifg=#%06x"", value & 0xFFFFFF);
",unused,vimxenial-src2Fnetbeans.c
"	    value = strtol((char *)fg, &ptr, 10);
	    if (ptr != (char *)fg)
		sprintf(fgbuf, ""guifg=#%06x"", value & 0xFFFFFF);
	    else
		sprintf(fgbuf, ""guifg=%s ctermfg=%s"", fg, fg);
",1,unused,3230,unused,"	    value = strtol((char *)fg, &ptr, 10);
	    if (ptr != (char *)fg)
		sprintf(fgbuf, ""guifg=#%06x"", value & 0xFFFFFF);
	    else
		sprintf(fgbuf, ""guifg=%s ctermfg=%s"", fg, fg);
",unused,vimxenial-src2Fnetbeans.c
"		sprintf(fgbuf, ""guifg=%s ctermfg=%s"", fg, fg);

	    value = strtol((char *)bg, &ptr, 10);
	    if (ptr != (char *)bg)
		sprintf(bgbuf, ""guibg=#%06x"", value & 0xFFFFFF);
",1,unused,3234,unused,"		sprintf(fgbuf, ""guifg=%s ctermfg=%s"", fg, fg);

	    value = strtol((char *)bg, &ptr, 10);
	    if (ptr != (char *)bg)
		sprintf(bgbuf, ""guibg=#%06x"", value & 0xFFFFFF);
",unused,vimxenial-src2Fnetbeans.c
"	    value = strtol((char *)bg, &ptr, 10);
	    if (ptr != (char *)bg)
		sprintf(bgbuf, ""guibg=#%06x"", value & 0xFFFFFF);
	    else
		sprintf(bgbuf, ""guibg=%s ctermbg=%s"", bg, bg);
",1,unused,3236,unused,"	    value = strtol((char *)bg, &ptr, 10);
	    if (ptr != (char *)bg)
		sprintf(bgbuf, ""guibg=#%06x"", value & 0xFFFFFF);
	    else
		sprintf(bgbuf, ""guibg=%s ctermbg=%s"", bg, bg);
",unused,vimxenial-src2Fnetbeans.c
"	    getvcols(curwin, &curwin->w_cursor, &VIsual, &leftcol, &rightcol);
# ifdef FEAT_LINEBREAK
	    p_sbr = saved_sbr;
# endif
	    sprintf((char *)showcmd_buf, ""%ldx%ld"", lines,
",1,unused,3782,unused,"	    getvcols(curwin, &curwin->w_cursor, &VIsual, &leftcol, &rightcol);
# ifdef FEAT_LINEBREAK
	    p_sbr = saved_sbr;
# endif
	    sprintf((char *)showcmd_buf, ""%ldx%ld"", lines,
",unused,vimxenial-src2Fnormal.c
"	    sprintf((char *)showcmd_buf, ""%ldx%ld"", lines,
					      (long)(rightcol - leftcol + 1));
	}
	else if (VIsual_mode == 'V' || VIsual.lnum != curwin->w_cursor.lnum)
	    sprintf((char *)showcmd_buf, ""%ld"", lines);
",1,unused,3786,unused,"	    sprintf((char *)showcmd_buf, ""%ldx%ld"", lines,
					      (long)(rightcol - leftcol + 1));
	}
	else if (VIsual_mode == 'V' || VIsual.lnum != curwin->w_cursor.lnum)
	    sprintf((char *)showcmd_buf, ""%ld"", lines);
",unused,vimxenial-src2Fnormal.c
"		++chars;
		s += l;
	    }
	    if (bytes == chars)
		sprintf((char *)showcmd_buf, ""%d"", chars);
",1,unused,3822,unused,"		++chars;
		s += l;
	    }
	    if (bytes == chars)
		sprintf((char *)showcmd_buf, ""%d"", chars);
",unused,vimxenial-src2Fnormal.c
"	    }
	    if (bytes == chars)
		sprintf((char *)showcmd_buf, ""%d"", chars);
	    else
		sprintf((char *)showcmd_buf, ""%d-%d"", chars, bytes);
",1,unused,3824,unused,"	    }
	    if (bytes == chars)
		sprintf((char *)showcmd_buf, ""%d"", chars);
	    else
		sprintf((char *)showcmd_buf, ""%d-%d"", chars, bytes);
",unused,vimxenial-src2Fnormal.c
"	return FAIL;

    /* Put ""\V"" before the pattern to avoid that the special meaning of "".""
     * and ""~"" causes trouble. */
    sprintf((char *)pat, vim_iswordp(ptr) ? ""\\V\\<%.*s\\>"" : ""\\V%.*s"",
",1,unused,4327,unused,"	return FAIL;

    /* Put ""\V"" before the pattern to avoid that the special meaning of "".""
     * and ""~"" causes trouble. */
    sprintf((char *)pat, vim_iswordp(ptr) ? ""\\V\\<%.*s\\>"" : ""\\V%.*s"",
",unused,vimxenial-src2Fnormal.c
"		 * really what we want? */
		isman = (STRCMP(kp, ""man"") == 0);
		isman_s = (STRCMP(kp, ""man -s"") == 0);
		if (cap->count0 != 0 && !(isman || isman_s))
		    sprintf((char *)buf, "".,.+%ld"", cap->count0 - 1);
",1,unused,5679,unused,"		 * really what we want? */
		isman = (STRCMP(kp, ""man"") == 0);
		isman_s = (STRCMP(kp, ""man -s"") == 0);
		if (cap->count0 != 0 && !(isman || isman_s))
		    sprintf((char *)buf, "".,.+%ld"", cap->count0 - 1);
",unused,vimxenial-src2Fnormal.c
"		    STRCAT(buf, kp);
		STRCAT(buf, "" "");
		if (cap->count0 != 0 && (isman || isman_s))
		{
		    sprintf((char *)buf + STRLEN(buf), ""%ld"", cap->count0);
",1,unused,5689,unused,"		    STRCAT(buf, kp);
		STRCAT(buf, "" "");
		if (cap->count0 != 0 && (isman || isman_s))
		{
		    sprintf((char *)buf + STRLEN(buf), ""%ld"", cap->count0);
",unused,vimxenial-src2Fnormal.c
"	    {
		if (g_cmd)
		    STRCPY(buf, ""tj "");
		else
		    sprintf((char *)buf, ""%ldta "", cap->count0);
",1,unused,5714,unused,"	    {
		if (g_cmd)
		    STRCPY(buf, ""tj "");
		else
		    sprintf((char *)buf, ""%ldta "", cap->count0);
",unused,vimxenial-src2Fnormal.c
"			if (saved_origval != NULL)
			{
			    char_u buf_type[7];

			    sprintf((char *)buf_type, ""%s"",
",1,unused,5000,unused,"			if (saved_origval != NULL)
			{
			    char_u buf_type[7];

			    sprintf((char *)buf_type, ""%s"",
",unused,vimxenial-src2Foption.c
"illegal_char(char_u *errbuf, int c)
{
    if (errbuf == NULL)
	return (char_u *)"""";
    sprintf((char *)errbuf, _(""E539: Illegal character <%s>""),
",1,unused,5137,unused,"illegal_char(char_u *errbuf, int c)
{
    if (errbuf == NULL)
	return (char_u *)"""";
    sprintf((char *)errbuf, _(""E539: Illegal character <%s>""),
",unused,vimxenial-src2Foption.c
"#if defined(FEAT_AUTOCMD) && defined(FEAT_EVAL)
	if (saved_oldval != NULL)
	{
	    char_u buf_type[7];
	    sprintf((char *)buf_type, ""%s"",
",1,unused,5815,unused,"#if defined(FEAT_AUTOCMD) && defined(FEAT_EVAL)
	if (saved_oldval != NULL)
	{
	    char_u buf_type[7];
	    sprintf((char *)buf_type, ""%s"",
",unused,vimxenial-src2Foption.c
"		if (!VIM_ISDIGIT(*(s - 1)))
		{
		    if (errbuf != NULL)
		    {
			sprintf((char *)errbuf,
",1,unused,6558,unused,"		if (!VIM_ISDIGIT(*(s - 1)))
		{
		    if (errbuf != NULL)
		    {
			sprintf((char *)errbuf,
",unused,vimxenial-src2Foption.c
"		else
		{
		    if (errbuf != NULL)
		    {
			sprintf((char *)errbuf,
",1,unused,6998,unused,"		else
		{
		    if (errbuf != NULL)
		    {
			sprintf((char *)errbuf,
",unused,vimxenial-src2Foption.c
"	    STRCPY(NameBuff, get_special_key_name((int)wc, 0));
	else if (wc != 0)
	    STRCPY(NameBuff, transchar((int)wc));
	else
	    sprintf((char *)NameBuff, ""%ld"", *(long *)varp);
",1,unused,11470,unused,"	    STRCPY(NameBuff, get_special_key_name((int)wc, 0));
	else if (wc != 0)
	    STRCPY(NameBuff, transchar((int)wc));
	else
	    sprintf((char *)NameBuff, ""%ld"", *(long *)varp);
",unused,vimxenial-src2Foption.c
"    }

    /* No translation, it may call malloc(). */
#ifdef SIGHASARG
    sprintf((char *)IObuff, ""Vim: Caught deadly signal %s\n"",
",1,unused,1140,unused,"    }

    /* No translation, it may call malloc(). */
#ifdef SIGHASARG
    sprintf((char *)IObuff, ""Vim: Caught deadly signal %s\n"",
",unused,vimxenial-src2Fos_unix.c
"	vim_strncpy(s, (char_u *)pw->pw_name, len - 1);
	return OK;
    }
#endif
    sprintf((char *)s, ""%d"", (int)uid);	    /* assumes s is long enough */
",1,unused,2373,unused,"	vim_strncpy(s, (char_u *)pw->pw_name, len - 1);
	return OK;
    }
#endif
    sprintf((char *)s, ""%d"", (int)uid);	    /* assumes s is long enough */
",unused,vimxenial-src2Fos_unix.c
"
    /* Simulate to have a dumb terminal (for now) */
# ifdef HAVE_SETENV
    setenv(""TERM"", ""dumb"", 1);
    sprintf((char *)envbuf, ""%ld"", Rows);
",1,unused,4058,unused,"
    /* Simulate to have a dumb terminal (for now) */
# ifdef HAVE_SETENV
    setenv(""TERM"", ""dumb"", 1);
    sprintf((char *)envbuf, ""%ld"", Rows);
",unused,vimxenial-src2Fos_unix.c
"# ifdef HAVE_SETENV
    setenv(""TERM"", ""dumb"", 1);
    sprintf((char *)envbuf, ""%ld"", Rows);
    setenv(""ROWS"", (char *)envbuf, 1);
    sprintf((char *)envbuf, ""%ld"", Rows);
",1,unused,4060,unused,"# ifdef HAVE_SETENV
    setenv(""TERM"", ""dumb"", 1);
    sprintf((char *)envbuf, ""%ld"", Rows);
    setenv(""ROWS"", (char *)envbuf, 1);
    sprintf((char *)envbuf, ""%ld"", Rows);
",unused,vimxenial-src2Fos_unix.c
"    sprintf((char *)envbuf, ""%ld"", Rows);
    setenv(""ROWS"", (char *)envbuf, 1);
    sprintf((char *)envbuf, ""%ld"", Rows);
    setenv(""LINES"", (char *)envbuf, 1);
    sprintf((char *)envbuf, ""%ld"", Columns);
",1,unused,4062,unused,"    sprintf((char *)envbuf, ""%ld"", Rows);
    setenv(""ROWS"", (char *)envbuf, 1);
    sprintf((char *)envbuf, ""%ld"", Rows);
    setenv(""LINES"", (char *)envbuf, 1);
    sprintf((char *)envbuf, ""%ld"", Columns);
",unused,vimxenial-src2Fos_unix.c
"	    if (idx < FMT_PATTERNS)
	    {
		if (fmt_ptr->addr[idx])
		{
		    sprintf((char *)errmsg,
",1,unused,244,unused,"	    if (idx < FMT_PATTERNS)
	    {
		if (fmt_ptr->addr[idx])
		{
		    sprintf((char *)errmsg,
",unused,vimxenial-src2Fquickfix.c
"			|| (idx == 6
			    && vim_strchr((char_u *)""OPQ"",
				fmt_ptr->prefix) == NULL))
		{
		    sprintf((char *)errmsg,
",1,unused,257,unused,"			|| (idx == 6
			    && vim_strchr((char_u *)""OPQ"",
				fmt_ptr->prefix) == NULL))
		{
		    sprintf((char *)errmsg,
",unused,vimxenial-src2Fquickfix.c
"		}
		else
		{
		    /* TODO: scanf()-like: %*ud, %*3c, %*f, ... ? */
		    sprintf((char *)errmsg,
",1,unused,333,unused,"		}
		else
		{
		    /* TODO: scanf()-like: %*ud, %*3c, %*f, ... ? */
		    sprintf((char *)errmsg,
",unused,vimxenial-src2Fquickfix.c
"		if (vim_strchr((char_u *)""DXAEWICZGOPQ"", *efmp) != NULL)
		    fmt_ptr->prefix = *efmp;
		else
		{
		    sprintf((char *)errmsg,
",1,unused,353,unused,"		if (vim_strchr((char_u *)""DXAEWICZGOPQ"", *efmp) != NULL)
		    fmt_ptr->prefix = *efmp;
		else
		{
		    sprintf((char *)errmsg,
",unused,vimxenial-src2Fquickfix.c
"		}
	    }
	    else
	    {
		sprintf((char *)errmsg,
",1,unused,361,unused,"		}
	    }
	    else
	    {
		sprintf((char *)errmsg,
",unused,vimxenial-src2Fquickfix.c
"	char_u *p = alloc((int)STRLEN(title) + 2);

	qi->qf_lists[qi->qf_curlist].qf_title = p;
	if (p != NULL)
	    sprintf((char *)p, "":%s"", (char *)title);
",1,unused,1302,unused,"	char_u *p = alloc((int)STRLEN(title) + 2);

	qi->qf_lists[qi->qf_curlist].qf_title = p;
	if (p != NULL)
	    sprintf((char *)p, "":%s"", (char *)title);
",unused,vimxenial-src2Fquickfix.c
"	    /* Update the screen before showing the message, unless the screen
	     * scrolled up. */
	    if (!msg_scrolled)
		update_topline_redraw();
	    sprintf((char *)IObuff, _(""(%d of %d)%s%s: ""), qf_index,
",1,unused,2375,unused,"	    /* Update the screen before showing the message, unless the screen
	     * scrolled up. */
	    if (!msg_scrolled)
		update_topline_redraw();
	    sprintf((char *)IObuff, _(""(%d of %d)%s%s: ""), qf_index,
",unused,vimxenial-src2Fquickfix.c
"		if (qfp->qf_type == 1)	/* :helpgrep */
		    fname = gettail(fname);
	    }
	    if (fname == NULL)
		sprintf((char *)IObuff, ""%2d"", i);
",1,unused,2516,unused,"		if (qfp->qf_type == 1)	/* :helpgrep */
		    fname = gettail(fname);
	    }
	    if (fname == NULL)
		sprintf((char *)IObuff, ""%2d"", i);
",unused,vimxenial-src2Fquickfix.c
"					   ? hl_attr(HLF_L) : hl_attr(HLF_D));
	    if (qfp->qf_lnum == 0)
		IObuff[0] = NUL;
	    else if (qfp->qf_col == 0)
		sprintf((char *)IObuff, "":%ld"", qfp->qf_lnum);
",1,unused,2525,unused,"					   ? hl_attr(HLF_L) : hl_attr(HLF_D));
	    if (qfp->qf_lnum == 0)
		IObuff[0] = NUL;
	    else if (qfp->qf_col == 0)
		sprintf((char *)IObuff, "":%ld"", qfp->qf_lnum);
",unused,vimxenial-src2Fquickfix.c
"		IObuff[0] = NUL;
	    else if (qfp->qf_col == 0)
		sprintf((char *)IObuff, "":%ld"", qfp->qf_lnum);
	    else
		sprintf((char *)IObuff, "":%ld col %d"",
",1,unused,2527,unused,"		IObuff[0] = NUL;
	    else if (qfp->qf_col == 0)
		sprintf((char *)IObuff, "":%ld"", qfp->qf_lnum);
	    else
		sprintf((char *)IObuff, "":%ld col %d"",
",unused,vimxenial-src2Fquickfix.c
"		sprintf((char *)IObuff, "":%ld"", qfp->qf_lnum);
	    else
		sprintf((char *)IObuff, "":%ld col %d"",
						   qfp->qf_lnum, qfp->qf_col);
	    sprintf((char *)IObuff + STRLEN(IObuff), ""%s:"",
",1,unused,2529,unused,"		sprintf((char *)IObuff, "":%ld"", qfp->qf_lnum);
	    else
		sprintf((char *)IObuff, "":%ld col %d"",
						   qfp->qf_lnum, qfp->qf_col);
	    sprintf((char *)IObuff + STRLEN(IObuff), ""%s:"",
",unused,vimxenial-src2Fquickfix.c
"
    if (nr <= 0)
	return p;

    sprintf((char *)buf, ""%s %3d"", (char *)p, nr);
",1,unused,2810,unused,"
    if (nr <= 0)
	return p;

    sprintf((char *)buf, ""%s %3d"", (char *)p, nr);
",unused,vimxenial-src2Fquickfix.c
"	    IObuff[len++] = '|';

	    if (qfp->qf_lnum > 0)
	    {
		sprintf((char *)IObuff + len, ""%ld"", qfp->qf_lnum);
",1,unused,3284,unused,"	    IObuff[len++] = '|';

	    if (qfp->qf_lnum > 0)
	    {
		sprintf((char *)IObuff + len, ""%ld"", qfp->qf_lnum);
",unused,vimxenial-src2Fquickfix.c
"		len += (int)STRLEN(IObuff + len);

		if (qfp->qf_col > 0)
		{
		    sprintf((char *)IObuff + len, "" col %d"", qfp->qf_col);
",1,unused,3289,unused,"		len += (int)STRLEN(IObuff + len);

		if (qfp->qf_col > 0)
		{
		    sprintf((char *)IObuff + len, "" col %d"", qfp->qf_col);
",unused,vimxenial-src2Fquickfix.c
"		    sprintf((char *)IObuff + len, "" col %d"", qfp->qf_col);
		    len += (int)STRLEN(IObuff + len);
		}

		sprintf((char *)IObuff + len, ""%s"",
",1,unused,3293,unused,"		    sprintf((char *)IObuff + len, "" col %d"", qfp->qf_col);
		    len += (int)STRLEN(IObuff + len);
		}

		sprintf((char *)IObuff + len, ""%s"",
",unused,vimxenial-src2Fquickfix.c
"	len += (unsigned)STRLEN(p_sp) + (unsigned)STRLEN(fname) + 3;
    cmd = alloc(len);
    if (cmd == NULL)
	return;
    sprintf((char *)cmd, ""%s%s%s"", (char *)p_shq, (char *)eap->arg,
",1,unused,3487,unused,"	len += (unsigned)STRLEN(p_sp) + (unsigned)STRLEN(fname) + 3;
    cmd = alloc(len);
    if (cmd == NULL)
	return;
    sprintf((char *)cmd, ""%s%s%s"", (char *)p_shq, (char *)eap->arg,
",unused,vimxenial-src2Fquickfix.c
"	name = alloc((unsigned)STRLEN(p_mef) + 30);
	if (name == NULL)
	    break;
	STRCPY(name, p_mef);
	sprintf((char *)name + (p - p_mef), ""%d%d"", start, off);
",1,unused,3579,unused,"	name = alloc((unsigned)STRLEN(p_mef) + 30);
	if (name == NULL)
	    break;
	STRCPY(name, p_mef);
	sprintf((char *)name + (p - p_mef), ""%d%d"", start, off);
",unused,vimxenial-src2Fquickfix.c
"    if (re_multi_type(peekchr()) != NOT_MULTI)
    {
	/* Can't have a multi follow a multi. */
	if (peekchr() == Magic('*'))
	    sprintf((char *)IObuff, _(""E61: Nested %s*""),
",1,unused,1880,unused,"    if (re_multi_type(peekchr()) != NOT_MULTI)
    {
	/* Can't have a multi follow a multi. */
	if (peekchr() == Magic('*'))
	    sprintf((char *)IObuff, _(""E61: Nested %s*""),
",unused,vimxenial-src2Fregexp.c
"	if (peekchr() == Magic('*'))
	    sprintf((char *)IObuff, _(""E61: Nested %s*""),
					    reg_magic >= MAGIC_ON ? """" : ""\\"");
	else
	    sprintf((char *)IObuff, _(""E62: Nested %s%c""),
",1,unused,1883,unused,"	if (peekchr() == Magic('*'))
	    sprintf((char *)IObuff, _(""E61: Nested %s*""),
					    reg_magic >= MAGIC_ON ? """" : ""\\"");
	else
	    sprintf((char *)IObuff, _(""E62: Nested %s%c""),
",unused,vimxenial-src2Fregexp.c
"      case Magic('@'):
      case Magic('{'):
      case Magic('*'):
	c = no_Magic(c);
	sprintf((char *)IObuff, _(""E64: %s%c follows nothing""),
",1,unused,2058,unused,"      case Magic('@'):
      case Magic('{'):
      case Magic('*'):
	c = no_Magic(c);
	sprintf((char *)IObuff, _(""E64: %s%c follows nothing""),
",unused,vimxenial-src2Fregexp.c
"    if (*regparse == '\\')
	regparse++;	/* Allow either \{...} or \{...\} */
    if (*regparse != '}')
    {
	sprintf((char *)IObuff, _(""E554: Syntax error in %s{...}""),
",1,unused,3403,unused,"    if (*regparse == '\\')
	regparse++;	/* Allow either \{...} or \{...\} */
    if (*regparse != '}')
    {
	sprintf((char *)IObuff, _(""E554: Syntax error in %s{...}""),
",unused,vimxenial-src2Fregexp.c
"		    fmt = ""%-*ld "";
		}
	    }

	    sprintf((char *)buf, fmt, w, num);
",1,unused,2547,unused,"		    fmt = ""%-*ld "";
		}
	    }

	    sprintf((char *)buf, fmt, w, num);
",unused,vimxenial-src2Fscreen.c
"				fmt = ""%-*ld "";
			    }
			}

			sprintf((char *)extra, fmt,
",1,unused,3762,unused,"				fmt = ""%-*ld "";
			    }
			}

			sprintf((char *)extra, fmt,
",unused,vimxenial-src2Fscreen.c
"	{
	    char	buf[20];

	    /* The GUI handles this internally. */
	    sprintf(buf, IF_EB(""\033|%dh"", ESC_STR ""|%dh""), attr);
",1,unused,7864,unused,"	{
	    char	buf[20];

	    /* The GUI handles this internally. */
	    sprintf(buf, IF_EB(""\033|%dh"", ESC_STR ""|%dh""), attr);
",unused,vimxenial-src2Fscreen.c
"	{
	    char	buf[20];

	    /* use internal GUI code */
	    sprintf(buf, IF_EB(""\033|%dH"", ESC_STR ""|%dH""), screen_attr);
",1,unused,7958,unused,"	{
	    char	buf[20];

	    /* use internal GUI code */
	    sprintf(buf, IF_EB(""\033|%dH"", ESC_STR ""|%dH""), screen_attr);
",unused,vimxenial-src2Fscreen.c
"    MSG_PUTS_ATTR(_(""recording""), attr);
    if (!shortmess(SHM_RECORDING))
    {
	char_u s[4];
	sprintf((char *)s, "" @%c"", Recording);
",1,unused,10309,unused,"    MSG_PUTS_ATTR(_(""recording""), attr);
    if (!shortmess(SHM_RECORDING))
    {
	char_u s[4];
	sprintf((char *)s, "" @%c"", Recording);
",unused,vimxenial-src2Fscreen.c
"			*p++ = 's';
		    if (spats[0].off.off > 0 || spats[0].off.line)
			*p++ = '+';
		    if (spats[0].off.off != 0 || spats[0].off.line)
			sprintf((char *)p, ""%ld"", spats[0].off.off);
",1,unused,1351,unused,"			*p++ = 's';
		    if (spats[0].off.off > 0 || spats[0].off.line)
			*p++ = '+';
		    if (spats[0].off.off != 0 || spats[0].off.line)
			sprintf((char *)p, ""%ld"", spats[0].off.off);
",unused,vimxenial-src2Fsearch.c
"	vim_free(epat);
	curwin->w_cursor = old_pos;
	goto theend;
    }
    sprintf((char *)spat, ""<%.*s\\>\\%%(\\s\\_[^>]\\{-}[^/]>\\|>\\)\\c"", len, p);
",1,unused,3992,unused,"	vim_free(epat);
	curwin->w_cursor = old_pos;
	goto theend;
    }
    sprintf((char *)spat, ""<%.*s\\>\\%%(\\s\\_[^>]\\{-}[^/]>\\|>\\)\\c"", len, p);
",unused,vimxenial-src2Fsearch.c
"	curwin->w_cursor = old_pos;
	goto theend;
    }
    sprintf((char *)spat, ""<%.*s\\>\\%%(\\s\\_[^>]\\{-}[^/]>\\|>\\)\\c"", len, p);
    sprintf((char *)epat, ""</%.*s>\\c"", len, p);
",1,unused,3993,unused,"	curwin->w_cursor = old_pos;
	goto theend;
    }
    sprintf((char *)spat, ""<%.*s\\>\\%%(\\s\\_[^>]\\{-}[^/]>\\|>\\)\\c"", len, p);
    sprintf((char *)epat, ""</%.*s>\\c"", len, p);
",unused,vimxenial-src2Fsearch.c
"    {
	pat = alloc(len + 5);
	if (pat == NULL)
	    goto fpip_end;
	sprintf((char *)pat, whole ? ""\\<%.*s\\>"" : ""%.*s"", len, ptr);
",1,unused,4883,unused,"    {
	pat = alloc(len + 5);
	if (pat == NULL)
	    goto fpip_end;
	sprintf((char *)pat, whole ? ""\\<%.*s\\>"" : ""%.*s"", len, ptr);
",unused,vimxenial-src2Fsearch.c
"	    *(p + 1) = NUL;
	}
	if (action == ACTION_SHOW_ALL)
	{
	    sprintf((char *)IObuff, ""%3ld: "", count);	/* show match nr */
",1,unused,5557,unused,"	    *(p + 1) = NUL;
	}
	if (action == ACTION_SHOW_ALL)
	{
	    sprintf((char *)IObuff, ""%3ld: "", count);	/* show match nr */
",unused,vimxenial-src2Fsearch.c
"	if (action == ACTION_SHOW_ALL)
	{
	    sprintf((char *)IObuff, ""%3ld: "", count);	/* show match nr */
	    msg_puts(IObuff);
	    sprintf((char *)IObuff, ""%4ld"", *lnum);	/* show line nr */
",1,unused,5559,unused,"	if (action == ACTION_SHOW_ALL)
	{
	    sprintf((char *)IObuff, ""%3ld: "", count);	/* show match nr */
	    msg_puts(IObuff);
	    sprintf((char *)IObuff, ""%4ld"", *lnum);	/* show line nr */
",unused,vimxenial-src2Fsearch.c
"    if (salt != NULL)
	sha256_update(&ctx, salt, salt_len);
    sha256_finish(&ctx, sha256sum);
    for (j = 0; j < 32; j++)
	sprintf((char *)hexit + j * 2, ""%02x"", sha256sum[j]);
",1,unused,294,unused,"    if (salt != NULL)
	sha256_update(&ctx, salt, salt_len);
    sha256_finish(&ctx, sha256sum);
    for (j = 0; j < 32; j++)
	sprintf((char *)hexit + j * 2, ""%02x"", sha256sum[j]);
",unused,vimxenial-src2Fsha256.c
"	    for (j = 0; j < 1000; j++)
		sha256_update(&ctx, (char_u *)buf, 1000);
	    sha256_finish(&ctx, sha256sum);
	    for (j = 0; j < 32; j++)
		sprintf(output + j * 2, ""%02x"", sha256sum[j]);
",1,unused,371,unused,"	    for (j = 0; j < 1000; j++)
		sha256_update(&ctx, (char_u *)buf, 1000);
	    sha256_finish(&ctx, sha256sum);
	    for (j = 0; j < 32; j++)
		sprintf(output + j * 2, ""%02x"", sha256sum[j]);
",unused,vimxenial-src2Fsha256.c
"
    frompat = alloc((unsigned)STRLEN(repl_from) + 7);
    if (frompat == NULL)
	return;
    sprintf((char *)frompat, ""\\V\\<%s\\>"", repl_from);
",1,unused,3670,unused,"
    frompat = alloc((unsigned)STRLEN(repl_from) + 7);
    if (frompat == NULL)
	return;
    sprintf((char *)frompat, ""\\V\\<%s\\>"", repl_from);
",unused,vimxenial-src2Fspell.c
"		STRCAT(badword, ""?"");
	    if (flags & WF_REGION)
		for (i = 0; i < 7; ++i)
		    if (flags & (0x10000 << i))
			sprintf((char *)badword + STRLEN(badword), ""%d"", i + 1);
",1,unused,8822,unused,"		STRCAT(badword, ""?"");
	    if (flags & WF_REGION)
		for (i = 0; i < 7; ++i)
		    if (flags & (0x10000 << i))
			sprintf((char *)badword + STRLEN(badword), ""%d"", i + 1);
",unused,vimxenial-src2Fspell.c
"			char_u	buf[MAXLINELEN];

			aff_entry->ae_cond = getroom_save(spin, items[4]);
			if (*items[0] == 'P')
			    sprintf((char *)buf, ""^%s"", items[4]);
",1,unused,2760,unused,"			char_u	buf[MAXLINELEN];

			aff_entry->ae_cond = getroom_save(spin, items[4]);
			if (*items[0] == 'P')
			    sprintf((char *)buf, ""^%s"", items[4]);
",unused,vimxenial-src2Fspellfile.c
"			aff_entry->ae_cond = getroom_save(spin, items[4]);
			if (*items[0] == 'P')
			    sprintf((char *)buf, ""^%s"", items[4]);
			else
			    sprintf((char *)buf, ""%s$"", items[4]);
",1,unused,2762,unused,"			aff_entry->ae_cond = getroom_save(spin, items[4]);
			if (*items[0] == 'P')
			    sprintf((char *)buf, ""^%s"", items[4]);
			else
			    sprintf((char *)buf, ""%s$"", items[4]);
",unused,vimxenial-src2Fspellfile.c
"#endif
					    *aff_entry->ae_cond = c_up;
					if (aff_entry->ae_cond != NULL)
					{
					    sprintf((char *)buf, ""^%s"",
",1,unused,2827,unused,"#endif
					    *aff_entry->ae_cond = c_up;
					if (aff_entry->ae_cond != NULL)
					{
					    sprintf((char *)buf, ""^%s"",
",unused,vimxenial-src2Fspellfile.c
"    recursive = TRUE;
    buf = alloc((unsigned)(STRLEN(name) + 12));
    if (buf != NULL)
    {
	sprintf((char *)buf, ""colors/%s.vim"", name);
",1,unused,7141,unused,"    recursive = TRUE;
    buf = alloc((unsigned)(STRLEN(name) + 12));
    if (buf != NULL)
    {
	sprintf((char *)buf, ""colors/%s.vim"", name);
",unused,vimxenial-src2Fsyntax.c
"    if (type == LIST_STRING ? (sarg != NULL) : (iarg != 0))
    {
	ts = buf;
	if (type == LIST_INT)
	    sprintf((char *)buf, ""%d"", iarg - 1);
",1,unused,8989,unused,"    if (type == LIST_STRING ? (sarg != NULL) : (iarg != 0))
    {
	ts = buf;
	if (type == LIST_INT)
	    sprintf((char *)buf, ""%d"", iarg - 1);
",unused,vimxenial-src2Fsyntax.c
"		color = HL_TABLE()[id - 1].sg_gui_bg;
	    if (color == INVALCOLOR)
		return NULL;
	    rgb = (long_u)GUI_MCH_GET_RGB(color);
	    sprintf((char *)buf, ""#%02x%02x%02x"",
",1,unused,9112,unused,"		color = HL_TABLE()[id - 1].sg_gui_bg;
	    if (color == INVALCOLOR)
		return NULL;
	    rgb = (long_u)GUI_MCH_GET_RGB(color);
	    sprintf((char *)buf, ""#%02x%02x%02x"",
",unused,vimxenial-src2Fsyntax.c
"	else
	    n = HL_TABLE()[id - 1].sg_cterm_bg - 1;
	if (n < 0)
	    return NULL;
	sprintf((char *)name, ""%d"", n);
",1,unused,9135,unused,"	else
	    n = HL_TABLE()[id - 1].sg_cterm_bg - 1;
	if (n < 0)
	    return NULL;
	sprintf((char *)name, ""%d"", n);
",unused,vimxenial-src2Fsyntax.c
"    }
# endif
    for (i = 0; i < 9; i++)
    {
	sprintf((char *)userhl, ""User%d"", i + 1);
",1,unused,9748,unused,"    }
# endif
    for (i = 0; i < 9; i++)
    {
	sprintf((char *)userhl, ""User%d"", i + 1);
",unused,vimxenial-src2Fsyntax.c
"		&& (num_matches > 1 || ic)
		&& !skip_msg)
	    {
		/* Give an indication of the number of matching tags */
		sprintf((char *)IObuff, _(""tag %d of %d%s""),
",1,unused,995,unused,"		&& (num_matches > 1 || ic)
		&& !skip_msg)
	    {
		/* Give an indication of the number of matching tags */
		sprintf((char *)IObuff, _(""tag %d of %d%s""),
",unused,vimxenial-src2Ftag.c
"	    if (name == NULL)	    /* file name not available */
		continue;

	    msg_putchar('\n');
	    sprintf((char *)IObuff, ""%c%2d %2d %-15s %5ld  "",
",1,unused,1134,unused,"	    if (name == NULL)	    /* file name not available */
		continue;

	    msg_putchar('\n');
	    sprintf((char *)IObuff, ""%c%2d %2d %-15s %5ld  "",
",unused,vimxenial-src2Ftag.c
"				    match_re ? matchoff : 0, !match_no_ic);
#ifdef FEAT_MULTI_LANG
			heuristic += help_pri;
#endif
			sprintf((char *)p + len + 1 + ML_EXTRA, ""%06d"",
",1,unused,2296,unused,"				    match_re ? matchoff : 0, !match_no_ic);
#ifdef FEAT_MULTI_LANG
			heuristic += help_pri;
#endif
			sprintf((char *)p + len + 1 + ML_EXTRA, ""%06d"",
",unused,vimxenial-src2Ftag.c
"		    found = 2;
		    (void)test_for_static(&tagp);
		    cc = *tagp.tagname_end;
		    *tagp.tagname_end = NUL;
		    sprintf((char *)pbuf, ""^%s\\s\\*("", tagp.tagname);
",1,unused,3285,unused,"		    found = 2;
		    (void)test_for_static(&tagp);
		    cc = *tagp.tagname_end;
		    *tagp.tagname_end = NUL;
		    sprintf((char *)pbuf, ""^%s\\s\\*("", tagp.tagname);
",unused,vimxenial-src2Ftag.c
"		    if (!do_search(NULL, '/', pbuf, (long)1,
							search_options, NULL))
		    {
			/* Guess again: ""^char * \<func  ("" */
			sprintf((char *)pbuf, ""^\\[#a-zA-Z_]\\.\\*\\<%s\\s\\*("",
",1,unused,3290,unused,"		    if (!do_search(NULL, '/', pbuf, (long)1,
							search_options, NULL))
		    {
			/* Guess again: ""^char * \<func  ("" */
			sprintf((char *)pbuf, ""^\\[#a-zA-Z_]\\.\\*\\<%s\\s\\*("",
",unused,vimxenial-src2Ftag.c
"    char_u	nr_colors[20];		/* string for number of colors */

    t_colors = nr;
    if (t_colors > 1)
	sprintf((char *)nr_colors, ""%d"", t_colors);
",1,unused,1437,unused,"    char_u	nr_colors[20];		/* string for number of colors */

    t_colors = nr;
    if (t_colors > 1)
	sprintf((char *)nr_colors, ""%d"", t_colors);
",unused,vimxenial-src2Fterm.c
"	char *format = ""%s%s%%p1%%dm"";
#else
	char *format = ""%s%s%%dm"";
#endif
	sprintf(buf, format,
",1,unused,2623,unused,"	char *format = ""%s%s%%p1%%dm"";
#else
	char *format = ""%s%s%%dm"";
#endif
	sprintf(buf, format,
",unused,vimxenial-src2Fterm.c
"		    src += 5;
		    result[dlen++] = K_SPECIAL;
		    result[dlen++] = (int)KS_EXTRA;
		    result[dlen++] = (int)KE_SNR;
		    sprintf((char *)result + dlen, ""%ld"", (long)current_SID);
",1,unused,5424,unused,"		    src += 5;
		    result[dlen++] = K_SPECIAL;
		    result[dlen++] = (int)KS_EXTRA;
		    result[dlen++] = (int)KE_SNR;
		    sprintf((char *)result + dlen, ""%ld"", (long)current_SID);
",unused,vimxenial-src2Fterm.c
"	sprintf(dbuf, ""Requesting XT %d: %s"",
				       xt_index_out, key_names[xt_index_out]);
	log_tr(dbuf);
# endif
	sprintf(buf, ""\033P+q%02x%02x\033\\"",
",1,unused,5785,unused,"	sprintf(dbuf, ""Requesting XT %d: %s"",
				       xt_index_out, key_names[xt_index_out]);
	log_tr(dbuf);
# endif
	sprintf(buf, ""\033P+q%02x%02x\033\\"",
",unused,vimxenial-src2Fterm.c
"	char_u	    *p;
	char_u	    name[20];
	partial_T   *pt;

	sprintf((char*)name, ""<lambda>%d"", ++lambda_no);
",1,unused,256,unused,"	char_u	    *p;
	char_u	    name[20];
	partial_T   *pt;

	sprintf((char*)name, ""<lambda>%d"", ++lambda_no);
",unused,vimxenial-src2Fuserfunc.c
"	    if (current_SID <= 0)
		*error = ERROR_SCRIPT;
	    else
	    {
		sprintf((char *)fname_buf + 3, ""%ld_"", (long)current_SID);
",1,unused,513,unused,"	    if (current_SID <= 0)
		*error = ERROR_SCRIPT;
	    else
	    {
		sprintf((char *)fname_buf + 3, ""%ld_"", (long)current_SID);
",unused,vimxenial-src2Fuserfunc.c
"	}
	else
	{
	    /* ""..."" argument a:1, a:2, etc. */
	    sprintf((char *)numbuf, ""%d"", ai + 1);
",1,unused,765,unused,"	}
	else
	{
	    /* ""..."" argument a:1, a:2, etc. */
	    sprintf((char *)numbuf, ""%d"", ai + 1);
",unused,vimxenial-src2Fuserfunc.c
"    if (sourcing_name != NULL)
    {
	if (save_sourcing_name != NULL
			  && STRNCMP(save_sourcing_name, ""function "", 9) == 0)
	    sprintf((char *)sourcing_name, ""%s[%d].."",
",1,unused,819,unused,"    if (sourcing_name != NULL)
    {
	if (save_sourcing_name != NULL
			  && STRNCMP(save_sourcing_name, ""function "", 9) == 0)
	    sprintf((char *)sourcing_name, ""%s[%d].."",
",unused,vimxenial-src2Fuserfunc.c
"	    {
		EMSG(_(e_usingsid));
		goto theend;
	    }
	    sprintf((char *)sid_buf, ""%ld_"", (long)current_SID);
",1,unused,1660,unused,"	    {
		EMSG(_(e_usingsid));
		goto theend;
	    }
	    sprintf((char *)sid_buf, ""%ld_"", (long)current_SID);
",unused,vimxenial-src2Fuserfunc.c
"
	/* Give the function a sequential number.  Can only be used with a
	 * Funcref! */
	vim_free(name);
	sprintf(numbuf, ""%d"", ++func_nr);
",1,unused,2232,unused,"
	/* Give the function a sequential number.  Can only be used with a
	 * Funcref! */
	vim_free(name);
	sprintf(numbuf, ""%d"", ++func_nr);
",unused,vimxenial-src2Fuserfunc.c
"	    /* Check for 9.9x or 9.9xx, alpha/beta version */
	    if (isalpha((int)vers[3]))
	    {
		int len = (isalpha((int)vers[4])) ? 5 : 4;
		sprintf((char *)vers + len, "".%d%s"", highest_patch(),
",1,unused,1759,unused,"	    /* Check for 9.9x or 9.9xx, alpha/beta version */
	    if (isalpha((int)vers[3]))
	    {
		int len = (isalpha((int)vers[4])) ? 5 : 4;
		sprintf((char *)vers + len, "".%d%s"", highest_patch(),
",unused,vimxenial-src2Fversion.c
"		sprintf((char *)vers + len, "".%d%s"", highest_patch(),
							 mediumVersion + len);
	    }
	    else
		sprintf((char *)vers + 3, "".%d"", highest_patch());
",1,unused,1763,unused,"		sprintf((char *)vers + len, "".%d%s"", highest_patch(),
							 mediumVersion + len);
	    }
	    else
		sprintf((char *)vers + 3, "".%d"", highest_patch());
",unused,vimxenial-src2Fversion.c
"		 * cursor in a new window.
		 */
		if (bt_quickfix(curbuf))
		{
		    sprintf((char *)cbuf, ""split +%ld%s"",
",1,unused,536,unused,"		 * cursor in a new window.
		 */
		if (bt_quickfix(curbuf))
		{
		    sprintf((char *)cbuf, ""split +%ld%s"",
",unused,vimxenial-src2Fwindow.c
"  static char z[LLEN+1];
  static int zero_seen = 0;

  if (!nz && zero_seen == 1)
    strcpy(z, l);
",1,unused,404,unused,"  static char z[LLEN+1];
  static int zero_seen = 0;

  if (!nz && zero_seen == 1)
    strcpy(z, l);
",unused,vimxenial-src2Fxxd2Fxxd.c
"  while ((length < 0 || n < length) && (e = getc(fp)) != EOF)
    {
      if (p == 0)
	{
	  sprintf(l, ""%08lx:"",
",1,unused,807,unused,"  while ((length < 0 || n < length) && (e = getc(fp)) != EOF)
    {
      if (p == 0)
	{
	  sprintf(l, ""%08lx:"",
",unused,vimxenial-src2Fxxd2Fxxd.c
"			return 0;
		else
			r = u;
		/* needed when rounds is zero prefixed or out of bounds */
		sprintf(rounds, ""rounds=%u$"", r);
",1,unused,237,unused,"			return 0;
		else
			r = u;
		/* needed when rounds is zero prefixed or out of bounds */
		sprintf(rounds, ""rounds=%u$"", r);
",unused,xreztento_eos-contracts2Fmusl2Fupstream2Fsrc2Fcrypt2Fcrypt_sha256.c
"	}

	/* output is $5$rounds=n$salt$hash */
	p = output;
	p += sprintf(p, ""$5$%s%.*s$"", rounds, slen, salt);
",1,unused,297,unused,"	}

	/* output is $5$rounds=n$salt$hash */
	p = output;
	p += sprintf(p, ""$5$%s%.*s$"", rounds, slen, salt);
",unused,xreztento_eos-contracts2Fmusl2Fupstream2Fsrc2Fcrypt2Fcrypt_sha256.c
"			return 0;
		else
			r = u;
		/* needed when rounds is zero prefixed or out of bounds */
		sprintf(rounds, ""rounds=%u$"", r);
",1,unused,259,unused,"			return 0;
		else
			r = u;
		/* needed when rounds is zero prefixed or out of bounds */
		sprintf(rounds, ""rounds=%u$"", r);
",unused,xreztento_eos-contracts2Fmusl2Fupstream2Fsrc2Fcrypt2Fcrypt_sha512.c
"	}

	/* output is $6$rounds=n$salt$hash */
	p = output;
	p += sprintf(p, ""$6$%s%.*s$"", rounds, slen, salt);
",1,unused,319,unused,"	}

	/* output is $6$rounds=n$salt$hash */
	p = output;
	p += sprintf(p, ""$6$%s%.*s$"", rounds, slen, salt);
",unused,xreztento_eos-contracts2Fmusl2Fupstream2Fsrc2Fcrypt2Fcrypt_sha512.c
"/* collate only by code points */
size_t __strxfrm_l(char *restrict dest, const char *restrict src, size_t n, locale_t loc)
{
	size_t l = strlen(src);
	if (n > l) strcpy(dest, src);
",1,unused,10,unused,"/* collate only by code points */
size_t __strxfrm_l(char *restrict dest, const char *restrict src, size_t n, locale_t loc)
{
	size_t l = strlen(src);
	if (n > l) strcpy(dest, src);
",unused,xreztento_eos-contracts2Fmusl2Fupstream2Fsrc2Flocale2Fstrxfrm.c
"	char tmp[32];
	int i, j;

	if (n-1U > 15) n = 15;
	sprintf(tmp, ""%.*e"", n-1, x);
",1,unused,12,unused,"	char tmp[32];
	int i, j;

	if (n-1U > 15) n = 15;
	sprintf(tmp, ""%.*e"", n-1, x);
",unused,xreztento_eos-contracts2Fmusl2Fupstream2Fsrc2Fstdlib2Fecvt.c
"#include <stdio.h>

char *gcvt(double x, int n, char *b)
{
	sprintf(b, ""%.*g"", n, x);
",1,unused,7,unused,"#include <stdio.h>

char *gcvt(double x, int n, char *b)
{
	sprintf(b, ""%.*g"", n, x);
",unused,xreztento_eos-contracts2Fmusl2Fupstream2Fsrc2Fstdlib2Fgcvt.c
"#include <string.h>

char *strcat(char *restrict dest, const char *restrict src)
{
	strcpy(dest + strlen(dest), src);
",1,unused,5,unused,"#include <string.h>

char *strcat(char *restrict dest, const char *restrict src)
{
	strcpy(dest + strlen(dest), src);
",unused,xreztento_eos-contracts2Fmusl2Fupstream2Fsrc2Fstring2Fstrcat.c
"
    err = compress(compr, &comprLen, (const Bytef*)hello, len);
    CHECK_ERR(err, ""compress"");

    strcpy((char*)uncompr, ""garbage"");
",1,unused,98,unused,"
    err = compress(compr, &comprLen, (const Bytef*)hello, len);
    CHECK_ERR(err, ""compress"");

    strcpy((char*)uncompr, ""garbage"");
",unused,zlib_test004-test2Fexample.c
"    if (file == NULL) {
        fprintf(stderr, ""gzopen error\n"");
        exit(1);
    }
    strcpy((char*)uncompr, ""garbage"");
",1,unused,149,unused,"    if (file == NULL) {
        fprintf(stderr, ""gzopen error\n"");
        exit(1);
    }
    strcpy((char*)uncompr, ""garbage"");
",unused,zlib_test004-test2Fexample.c
"{
    int err;
    z_stream d_stream; /* decompression stream */

    strcpy((char*)uncompr, ""garbage"");
",1,unused,245,unused,"{
    int err;
    z_stream d_stream; /* decompression stream */

    strcpy((char*)uncompr, ""garbage"");
",unused,zlib_test004-test2Fexample.c
"{
    int err;
    z_stream d_stream; /* decompression stream */

    strcpy((char*)uncompr, ""garbage"");
",1,unused,341,unused,"{
    int err;
    z_stream d_stream; /* decompression stream */

    strcpy((char*)uncompr, ""garbage"");
",unused,zlib_test004-test2Fexample.c
"{
    int err;
    z_stream d_stream; /* decompression stream */

    strcpy((char*)uncompr, ""garbage"");
",1,unused,420,unused,"{
    int err;
    z_stream d_stream; /* decompression stream */

    strcpy((char*)uncompr, ""garbage"");
",unused,zlib_test004-test2Fexample.c
"{
    int err;
    z_stream d_stream; /* decompression stream */

    strcpy((char*)uncompr, ""garbage"");
",1,unused,501,unused,"{
    int err;
    z_stream d_stream; /* decompression stream */

    strcpy((char*)uncompr, ""garbage"");
",unused,zlib_test004-test2Fexample.c
"
    err = compress(compr, &comprLen, (const Bytef*)hello, len);
    CHECK_ERR(err, ""compress"");

    strcpy((char*)uncompr, ""garbage"");
",1,unused,98,unused,"
    err = compress(compr, &comprLen, (const Bytef*)hello, len);
    CHECK_ERR(err, ""compress"");

    strcpy((char*)uncompr, ""garbage"");
",unused,zlib_test1-test2Fexample.c
"    if (file == NULL) {
        fprintf(stderr, ""gzopen error\n"");
        exit(1);
    }
    strcpy((char*)uncompr, ""garbage"");
",1,unused,149,unused,"    if (file == NULL) {
        fprintf(stderr, ""gzopen error\n"");
        exit(1);
    }
    strcpy((char*)uncompr, ""garbage"");
",unused,zlib_test1-test2Fexample.c
"{
    int err;
    z_stream d_stream; /* decompression stream */

    strcpy((char*)uncompr, ""garbage"");
",1,unused,245,unused,"{
    int err;
    z_stream d_stream; /* decompression stream */

    strcpy((char*)uncompr, ""garbage"");
",unused,zlib_test1-test2Fexample.c
"{
    int err;
    z_stream d_stream; /* decompression stream */

    strcpy((char*)uncompr, ""garbage"");
",1,unused,341,unused,"{
    int err;
    z_stream d_stream; /* decompression stream */

    strcpy((char*)uncompr, ""garbage"");
",unused,zlib_test1-test2Fexample.c
"{
    int err;
    z_stream d_stream; /* decompression stream */

    strcpy((char*)uncompr, ""garbage"");
",1,unused,420,unused,"{
    int err;
    z_stream d_stream; /* decompression stream */

    strcpy((char*)uncompr, ""garbage"");
",unused,zlib_test1-test2Fexample.c
"{
    int err;
    z_stream d_stream; /* decompression stream */

    strcpy((char*)uncompr, ""garbage"");
",1,unused,501,unused,"{
    int err;
    z_stream d_stream; /* decompression stream */

    strcpy((char*)uncompr, ""garbage"");
",unused,zlib_test1-test2Fexample.c
"
    err = compress(compr, &comprLen, (const Bytef*)hello, len);
    CHECK_ERR(err, ""compress"");

    strcpy((char*)uncompr, ""garbage"");
",1,unused,98,unused,"
    err = compress(compr, &comprLen, (const Bytef*)hello, len);
    CHECK_ERR(err, ""compress"");

    strcpy((char*)uncompr, ""garbage"");
",unused,zlibdebianstretche1.2.8-test2Fexample.c
"    if (file == NULL) {
        fprintf(stderr, ""gzopen error\n"");
        exit(1);
    }
    strcpy((char*)uncompr, ""garbage"");
",1,unused,149,unused,"    if (file == NULL) {
        fprintf(stderr, ""gzopen error\n"");
        exit(1);
    }
    strcpy((char*)uncompr, ""garbage"");
",unused,zlibdebianstretche1.2.8-test2Fexample.c
"{
    int err;
    z_stream d_stream; /* decompression stream */

    strcpy((char*)uncompr, ""garbage"");
",1,unused,245,unused,"{
    int err;
    z_stream d_stream; /* decompression stream */

    strcpy((char*)uncompr, ""garbage"");
",unused,zlibdebianstretche1.2.8-test2Fexample.c
"{
    int err;
    z_stream d_stream; /* decompression stream */

    strcpy((char*)uncompr, ""garbage"");
",1,unused,341,unused,"{
    int err;
    z_stream d_stream; /* decompression stream */

    strcpy((char*)uncompr, ""garbage"");
",unused,zlibdebianstretche1.2.8-test2Fexample.c
"{
    int err;
    z_stream d_stream; /* decompression stream */

    strcpy((char*)uncompr, ""garbage"");
",1,unused,420,unused,"{
    int err;
    z_stream d_stream; /* decompression stream */

    strcpy((char*)uncompr, ""garbage"");
",unused,zlibdebianstretche1.2.8-test2Fexample.c
"{
    int err;
    z_stream d_stream; /* decompression stream */

    strcpy((char*)uncompr, ""garbage"");
",1,unused,501,unused,"{
    int err;
    z_stream d_stream; /* decompression stream */

    strcpy((char*)uncompr, ""garbage"");
",unused,zlibdebianstretche1.2.8-test2Fexample.c
"
    err = compress(compr, &comprLen, (const Bytef*)hello, len);
    CHECK_ERR(err, ""compress"");

    strcpy((char*)uncompr, ""garbage"");
",1,unused,98,unused,"
    err = compress(compr, &comprLen, (const Bytef*)hello, len);
    CHECK_ERR(err, ""compress"");

    strcpy((char*)uncompr, ""garbage"");
",unused,zlibdebpatch-test2Fexample.c
"    if (file == NULL) {
        fprintf(stderr, ""gzopen error\n"");
        exit(1);
    }
    strcpy((char*)uncompr, ""garbage"");
",1,unused,149,unused,"    if (file == NULL) {
        fprintf(stderr, ""gzopen error\n"");
        exit(1);
    }
    strcpy((char*)uncompr, ""garbage"");
",unused,zlibdebpatch-test2Fexample.c
"{
    int err;
    z_stream d_stream; /* decompression stream */

    strcpy((char*)uncompr, ""garbage"");
",1,unused,245,unused,"{
    int err;
    z_stream d_stream; /* decompression stream */

    strcpy((char*)uncompr, ""garbage"");
",unused,zlibdebpatch-test2Fexample.c
"{
    int err;
    z_stream d_stream; /* decompression stream */

    strcpy((char*)uncompr, ""garbage"");
",1,unused,341,unused,"{
    int err;
    z_stream d_stream; /* decompression stream */

    strcpy((char*)uncompr, ""garbage"");
",unused,zlibdebpatch-test2Fexample.c
"{
    int err;
    z_stream d_stream; /* decompression stream */

    strcpy((char*)uncompr, ""garbage"");
",1,unused,420,unused,"{
    int err;
    z_stream d_stream; /* decompression stream */

    strcpy((char*)uncompr, ""garbage"");
",unused,zlibdebpatch-test2Fexample.c
"{
    int err;
    z_stream d_stream; /* decompression stream */

    strcpy((char*)uncompr, ""garbage"");
",1,unused,501,unused,"{
    int err;
    z_stream d_stream; /* decompression stream */

    strcpy((char*)uncompr, ""garbage"");
",unused,zlibdebpatch-test2Fexample.c
"
    err = compress(compr, &comprLen, (const Bytef*)hello, len);
    CHECK_ERR(err, ""compress"");

    strcpy((char*)uncompr, ""garbage"");
",1,unused,98,unused,"
    err = compress(compr, &comprLen, (const Bytef*)hello, len);
    CHECK_ERR(err, ""compress"");

    strcpy((char*)uncompr, ""garbage"");
",unused,zlibdebxenial-test2Fexample.c
"    if (file == NULL) {
        fprintf(stderr, ""gzopen error\n"");
        exit(1);
    }
    strcpy((char*)uncompr, ""garbage"");
",1,unused,149,unused,"    if (file == NULL) {
        fprintf(stderr, ""gzopen error\n"");
        exit(1);
    }
    strcpy((char*)uncompr, ""garbage"");
",unused,zlibdebxenial-test2Fexample.c
"{
    int err;
    z_stream d_stream; /* decompression stream */

    strcpy((char*)uncompr, ""garbage"");
",1,unused,245,unused,"{
    int err;
    z_stream d_stream; /* decompression stream */

    strcpy((char*)uncompr, ""garbage"");
",unused,zlibdebxenial-test2Fexample.c
"{
    int err;
    z_stream d_stream; /* decompression stream */

    strcpy((char*)uncompr, ""garbage"");
",1,unused,341,unused,"{
    int err;
    z_stream d_stream; /* decompression stream */

    strcpy((char*)uncompr, ""garbage"");
",unused,zlibdebxenial-test2Fexample.c
"{
    int err;
    z_stream d_stream; /* decompression stream */

    strcpy((char*)uncompr, ""garbage"");
",1,unused,420,unused,"{
    int err;
    z_stream d_stream; /* decompression stream */

    strcpy((char*)uncompr, ""garbage"");
",unused,zlibdebxenial-test2Fexample.c
"{
    int err;
    z_stream d_stream; /* decompression stream */

    strcpy((char*)uncompr, ""garbage"");
",1,unused,501,unused,"{
    int err;
    z_stream d_stream; /* decompression stream */

    strcpy((char*)uncompr, ""garbage"");
",unused,zlibdebxenial-test2Fexample.c
"
    err = compress(compr, &comprLen, (const Bytef*)hello, len);
    CHECK_ERR(err, ""compress"");

    strcpy((char*)uncompr, ""garbage"");
",1,unused,98,unused,"
    err = compress(compr, &comprLen, (const Bytef*)hello, len);
    CHECK_ERR(err, ""compress"");

    strcpy((char*)uncompr, ""garbage"");
",unused,zlibsources1.2.8-test2Fexample.c
"    if (file == NULL) {
        fprintf(stderr, ""gzopen error\n"");
        exit(1);
    }
    strcpy((char*)uncompr, ""garbage"");
",1,unused,149,unused,"    if (file == NULL) {
        fprintf(stderr, ""gzopen error\n"");
        exit(1);
    }
    strcpy((char*)uncompr, ""garbage"");
",unused,zlibsources1.2.8-test2Fexample.c
"{
    int err;
    z_stream d_stream; /* decompression stream */

    strcpy((char*)uncompr, ""garbage"");
",1,unused,245,unused,"{
    int err;
    z_stream d_stream; /* decompression stream */

    strcpy((char*)uncompr, ""garbage"");
",unused,zlibsources1.2.8-test2Fexample.c
"{
    int err;
    z_stream d_stream; /* decompression stream */

    strcpy((char*)uncompr, ""garbage"");
",1,unused,341,unused,"{
    int err;
    z_stream d_stream; /* decompression stream */

    strcpy((char*)uncompr, ""garbage"");
",unused,zlibsources1.2.8-test2Fexample.c
"{
    int err;
    z_stream d_stream; /* decompression stream */

    strcpy((char*)uncompr, ""garbage"");
",1,unused,420,unused,"{
    int err;
    z_stream d_stream; /* decompression stream */

    strcpy((char*)uncompr, ""garbage"");
",unused,zlibsources1.2.8-test2Fexample.c
"{
    int err;
    z_stream d_stream; /* decompression stream */

    strcpy((char*)uncompr, ""garbage"");
",1,unused,501,unused,"{
    int err;
    z_stream d_stream; /* decompression stream */

    strcpy((char*)uncompr, ""garbage"");
",unused,zlibsources1.2.8-test2Fexample.c
"
    err = compress(compr, &comprLen, (const Bytef*)hello, len);
    CHECK_ERR(err, ""compress"");

    strcpy((char*)uncompr, ""garbage"");
",1,unused,98,unused,"
    err = compress(compr, &comprLen, (const Bytef*)hello, len);
    CHECK_ERR(err, ""compress"");

    strcpy((char*)uncompr, ""garbage"");
",unused,zlibubuntuxenial1.2.8-test2Fexample.c
"    if (file == NULL) {
        fprintf(stderr, ""gzopen error\n"");
        exit(1);
    }
    strcpy((char*)uncompr, ""garbage"");
",1,unused,149,unused,"    if (file == NULL) {
        fprintf(stderr, ""gzopen error\n"");
        exit(1);
    }
    strcpy((char*)uncompr, ""garbage"");
",unused,zlibubuntuxenial1.2.8-test2Fexample.c
"{
    int err;
    z_stream d_stream; /* decompression stream */

    strcpy((char*)uncompr, ""garbage"");
",1,unused,245,unused,"{
    int err;
    z_stream d_stream; /* decompression stream */

    strcpy((char*)uncompr, ""garbage"");
",unused,zlibubuntuxenial1.2.8-test2Fexample.c
"{
    int err;
    z_stream d_stream; /* decompression stream */

    strcpy((char*)uncompr, ""garbage"");
",1,unused,341,unused,"{
    int err;
    z_stream d_stream; /* decompression stream */

    strcpy((char*)uncompr, ""garbage"");
",unused,zlibubuntuxenial1.2.8-test2Fexample.c
"{
    int err;
    z_stream d_stream; /* decompression stream */

    strcpy((char*)uncompr, ""garbage"");
",1,unused,420,unused,"{
    int err;
    z_stream d_stream; /* decompression stream */

    strcpy((char*)uncompr, ""garbage"");
",unused,zlibubuntuxenial1.2.8-test2Fexample.c
"{
    int err;
    z_stream d_stream; /* decompression stream */

    strcpy((char*)uncompr, ""garbage"");
",1,unused,501,unused,"{
    int err;
    z_stream d_stream; /* decompression stream */

    strcpy((char*)uncompr, ""garbage"");
",unused,zlibubuntuxenial1.2.8-test2Fexample.c
