static int AStreamPeekStream( stream_t *s, const uint8_t **pp_peek, unsigned int i_read )
{
    stream_sys_t *p_sys = s->p_sys;
    stream_track_t *tk = &p_sys->stream.tk[p_sys->stream.i_tk];
    uint64_t i_off;
    if( tk->i_start >= tk->i_end ) return 0; /* EOF */
#ifdef STREAM_DEBUG
    msg_Dbg( s, "AStreamPeekStream: %d pos=%"PRId64" tk=%d "
             "start=%"PRId64" offset=%d end=%"PRId64,
             i_read, p_sys->i_pos, p_sys->stream.i_tk,
             tk->i_start, p_sys->stream.i_offset, tk->i_end );
#endif
    /* Avoid problem, but that should *never* happen */
    if( i_read > STREAM_CACHE_TRACK_SIZE / 2 )
        i_read = STREAM_CACHE_TRACK_SIZE / 2;
    while( tk->i_end < tk->i_start + p_sys->stream.i_offset + i_read )
    {
        if( p_sys->stream.i_used <= 1 )
        {
            /* Be sure we will read something */
            p_sys->stream.i_used += tk->i_start + p_sys->stream.i_offset + i_read - tk->i_end;
        }
        if( AStreamRefillStream( s ) ) break;
    }
    if( tk->i_end < tk->i_start + p_sys->stream.i_offset + i_read )
    {
        i_read = tk->i_end - tk->i_start - p_sys->stream.i_offset;
    }
    /* Now, direct pointer or a copy ? */
    i_off = (tk->i_start + p_sys->stream.i_offset) % STREAM_CACHE_TRACK_SIZE;
    if( i_off + i_read <= STREAM_CACHE_TRACK_SIZE )
    {
        *pp_peek = &tk->p_buffer[i_off];
        return i_read;
    }
    if( p_sys->i_peek < i_read )
    {
        p_sys->p_peek = realloc_or_free( p_sys->p_peek, i_read );
        if( !p_sys->p_peek )
        {
            p_sys->i_peek = 0;
            return 0;
        }
        p_sys->i_peek = i_read;
    }
    memcpy( p_sys->p_peek, &tk->p_buffer[i_off],
            STREAM_CACHE_TRACK_SIZE - i_off );
    memcpy( &p_sys->p_peek[STREAM_CACHE_TRACK_SIZE - i_off],
            &tk->p_buffer[0], i_read - (STREAM_CACHE_TRACK_SIZE - i_off) );
    *pp_peek = p_sys->p_peek;
    return i_read;
}
