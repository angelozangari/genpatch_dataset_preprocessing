static bool parse_track_node ()
{
    int i_node;
    char *psz_name = NULL;
    char *psz_value = NULL;
    xml_elem_hnd_t *p_handler = NULL;

    xml_elem_hnd_t track_elements[] =
        { {"location",     SIMPLE_CONTENT,  {NULL} },
          {"identifier",   SIMPLE_CONTENT,  {NULL} },
          {"title",        SIMPLE_CONTENT,  {.smpl = set_item_info} },
          {"creator",      SIMPLE_CONTENT,  {.smpl = set_item_info} },
          {"annotation",   SIMPLE_CONTENT,  {.smpl = set_item_info} },
          {"info",         SIMPLE_CONTENT,  {NULL} },
          {"image",        SIMPLE_CONTENT,  {.smpl = set_item_info} },
          {"album",        SIMPLE_CONTENT,  {.smpl = set_item_info} },
          {"trackNum",     SIMPLE_CONTENT,  {.smpl = set_item_info} },
          {"duration",     SIMPLE_CONTENT,  {.smpl = set_item_info} },
          {"link",         SIMPLE_CONTENT,  {NULL} },
          {"meta",         SIMPLE_CONTENT,  {NULL} },
          {"extension",    COMPLEX_CONTENT, {.cmplx = parse_extension_node} },
          {NULL,           UNKNOWN_CONTENT, {NULL} }
        };

    input_item_t *p_new_input = input_item_NewExt( p_demux, NULL, NULL, 0, NULL, -1 );

    if( !p_new_input )
    {
        /* malloc has failed for input_item_NewExt, so bailout early */
        return false;
    }

    /* reset i_track_id */
    p_demux->p_sys->i_track_id = -1;

    while( xml_ReaderRead( p_xml_reader ) == 1 )
    {
        i_node = xml_ReaderNodeType( p_xml_reader );
        switch( i_node )
        {
            case XML_READER_NONE:
                break;

            case XML_READER_STARTELEM:
                /*  element start tag  */
                psz_name = xml_ReaderName( p_xml_reader );
                if( !psz_name || !*psz_name )
                {
                    msg_Err( p_demux, "invalid xml stream" );
                    FREE_ATT();
                    return false;
                }
                /* choose handler */
                for( p_handler = track_elements;
                     p_handler->name && strcmp( psz_name, p_handler->name );
                     p_handler++ );
                if( !p_handler->name )
                {
                    msg_Err( p_demux, "unexpected element <%s>", psz_name );
                    FREE_ATT();
                    return false;
                }
                FREE_NAME();
                /* complex content is parsed in a separate function */
                if( p_handler->type == COMPLEX_CONTENT )
                {
                    if( !p_new_input )
                    {
                        msg_Err( p_demux,
                                 "at <%s> level no new item has been allocated",
                                 p_handler->name );
                        FREE_ATT();
                        return false;
                    }
                    if( p_handler->pf_handler.cmplx( p_demux,
                                                     p_new_input,
                                                     p_xml_reader,
                                                     p_handler->name ) )
                    {
                        p_handler = NULL;
                        FREE_ATT();
                    }
                    else
                    {
                        FREE_ATT();
                        return false;
                    }
                }
                break;

            case XML_READER_TEXT:
                /* simple element content */
                FREE_ATT();
                psz_value = xml_ReaderValue( p_xml_reader );
                if( !psz_value )
                {
                    msg_Err( p_demux, "invalid xml stream" );
                    FREE_ATT();
                    return false;
                }
                break;

            case XML_READER_ENDELEM:
                /* element end tag */
                psz_name = xml_ReaderName( p_xml_reader );
                if( !psz_name )
                {
                    msg_Err( p_demux, "invalid xml stream" );
                    FREE_ATT();
                    return false;
                }
                /* leave if the current parent node <track> is terminated */
                if( !strcmp( psz_name, psz_element ) )
                {
                    FREE_ATT();

                    if( p_demux->p_sys->i_track_id < 0 )
                    {
                        char *psz_uri = input_item_GetURI( p_new_input );
                        if( psz_uri && *psz_uri)
                        {
                            input_item_AddSubItem( p_input_item, p_new_input );
                        }
                        vlc_gc_decref( p_new_input );
                        free( psz_uri );
                        return true;
                    }

                    if( p_demux->p_sys->i_track_id >=
                           p_demux->p_sys->i_tracklist_entries )
                    {
                        input_item_t **pp;
                        pp = realloc( p_demux->p_sys->pp_tracklist,
                            (p_demux->p_sys->i_track_id + 1) * sizeof(*pp) );
                        if( !pp )
                            return false;
                        p_demux->p_sys->pp_tracklist = pp;
                        while( p_demux->p_sys->i_track_id >=
                               p_demux->p_sys->i_tracklist_entries )
                            pp[p_demux->p_sys->i_tracklist_entries++] = NULL;
                    }

                    p_demux->p_sys->pp_tracklist[
                            p_demux->p_sys->i_track_id ] = p_new_input;
                    return true;
                }
                /* there MUST have been a start tag for that element name */
                if( !p_handler || !p_handler->name
                    || strcmp( p_handler->name, psz_name ))
                {
                    msg_Err( p_demux, "there's no open element left for <%s>",
                             psz_name );
                    FREE_ATT();
                    return false;
                }

                /* special case: location */
                if( !strcmp( p_handler->name, "location" ) )
                {
                    char *psz_uri = NULL;
                    psz_uri = decode_URI_duplicate( psz_value );

                    if( psz_uri )
                    {
                        if( p_demux->p_sys->psz_base &&
                            !strstr( psz_uri, "://" ) )
                        {
                           char* psz_tmp = malloc(
                                   strlen(p_demux->p_sys->psz_base) +
                                   strlen(psz_uri) +1 );
                           if( !psz_tmp )
                               return false;
                           sprintf( psz_tmp, "%s%s",
                                    p_demux->p_sys->psz_base, psz_uri );
                           free( psz_uri );
                           psz_uri = psz_tmp;
                        }
                        input_item_SetURI( p_new_input, psz_uri );
                        free( psz_uri );
                        input_item_CopyOptions( p_input_item, p_new_input );
                        psz_uri = NULL;
                        FREE_ATT();
                        p_handler = NULL;
                    }
                    else
                    {
                        FREE_ATT();
                        return false;
                    }
                }
                else
                {
                    /* there MUST be an item */
                    if( !p_new_input )
                    {
                        msg_Err( p_demux, "item not yet created at <%s>",
                                 psz_name );
                        FREE_ATT();
                        return false;
                    }
                    if( p_handler->pf_handler.smpl )
                    {
                        p_handler->pf_handler.smpl( p_new_input,
                                                    p_handler->name,
                                                    psz_value );
                        FREE_ATT();
                    }
                }
                FREE_ATT();
                p_handler = NULL;
                break;

            default:
                /* unknown/unexpected xml node */
                msg_Err( p_demux, "unexpected xml node %i", i_node );
                FREE_ATT();
                return false;
        }
        FREE_NAME();
    }
    msg_Err( p_demux, "unexpected end of xml data" );
    FREE_ATT();
    return false;
}
